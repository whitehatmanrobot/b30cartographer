+ sizeof(DWORD); TRUE; i++, pCur += cbAux) {

            //- - - Initialization - - -
            MACRO_LI_Offset(1);
            if (i > 0)
                Out(LI0(TEXT("\r\n")));

            wnsprintf(szKey, countof(szKey), IK_CONNECTNAME, i);
            InsGetString(IS_CONNECTSET, szKey, szName, countof(szName), g_GetIns());
            if (szName[0] == TEXT('\0')) {
                Out(LI2(TEXT("[%s], \"%s\" doesn't exist. There are no more RAS connections!"), IS_CONNECTSET, szKey));
                break;
            }

            wnsprintf(szKey, countof(szKey), IK_CONNECTSIZE, i);
            cbAux = InsGetInt(IS_CONNECTSET, szKey, 0, g_GetIns());
            if (cbAux == 0) {
                Out(LI0(TEXT("! The ins file is corrupt. No more RAS connections can be processed.")));
                break;
            }

            //- - - Main processing - - -
            Out(LI1(TEXT("Processing RAS connection \"%s\"..."), szName));

            preA = (LPRASENTRYA)pCur;

            // NOTE: (andrewgu) the is a remote possibility that sizes of RASENTRYA structure are
            // different on the server and client machines. there is nothing bad with server
            // structure being smaller than the client structure (all RAS apis are
            // backward-compatible). it's bad though when server structure is bigger than client
            // can handle, hence the trancation.
            // (something else to have in mind) this truncation should not affect alternate phone
            // numbers support on winnt. for more special cases also check out NOTE: below.
            if (preA->dwSize > sizeof(RASENTRYA))
                preA->dwSize = sizeof(RASENTRYA);

            // preA->szScript
            if (preA->szScript[0] != '\0') {
                pszScriptA = preA->szScript;
                if (preA->szScript[0] == '[')
                    pszScriptA = &preA->szScript[1];

                A2Tbuf(pszScriptA, szScript, countof(szScript));
                StrCpy(PathFindFileName(szTargetFile), PathFindFileName(szScript));
                if (PathFileExists(szTargetFile))
                    T2Abuf(szTargetFile, preA->szScript, MAX_PATH);

                else
                    preA->szScript[0] = '\0';
            }

            // preA->szDeviceName
            for (j = 0; j < cDevices; j++)
                if (0 == StrCmpIA(preA->szDeviceType, prdiA[j].szDeviceType)) {
                    StrCpyA(preA->szDeviceName, prdiA[j].szDeviceName);
                    break;
                }
            if (j >= cDevices)
                StrCpyA(preA->szDeviceName, prdiA[0].szDeviceName);

            A2Tbuf(preA->szDeviceName, szDeviceName, countof(szDeviceName));
            Out(LI1(TEXT("Set the device name to \"%s\"."), szDeviceName));

            // NOTE: (andrewgu) on win9x if there are alternate phone numbers (i.e. the package
            // installed on win9x machine was generated on winnt machine), cbAux will be larger
            // than preA->dwSize. this will fail with ERROR_INVALID_PARAMETER on win9x. hence on
            // this platform cbAux is reset so api has a chance of succeeding.
            cbRasEntry = cbAux;
            if (IsOS(OS_WINDOWS)) {
                preA->dwAlternateOffset = 0;
                cbRasEntry = preA->dwSize;
            }

            T2Abuf(szName, szNameA, countof(szNameA));
            dwResult = g_pfnRasSetEntryPropertiesA(NULL, szNameA, preA, cbRasEntry, NULL, 0);
            if (dwResult != ERROR_SUCCESS) {
                Out(LI1(TEXT("! Creating this RAS connection failed with %s."), GetHrSz(dwResult)));
                continue;
            }

            Out(LI0(TEXT("Done.")));
        }
        Out(LI0(TEXT("Done.")));

        //_____ Cleanup _____
RasExit:
        if (fRasApisLoaded)
            RasPrepareApis(RPA_UNLOAD, FALSE);

        if (prdiA != NULL)
            CoTaskMemFree(prdiA);

        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
            CloseFile(hFile);
            hFile = NULL;
        }
    }

    //----- Connect.set processing -----
    Out(LI1(TEXT("\r\nProcessing Wininet.dll connections information from \"%s\"."), CONNECT_SET));
    StrCpy(PathFindFileName(szTargetFile), CONNECT_SET);

    if (!PathFileExists(szTargetFile))
        Out(LI0(TEXT("This file doesn't exist!")));

    else {
        INTERNET_PER_CONN_OPTION_LISTA listA;
        INTERNET_PER_CONN_OPTIONA      rgOptionsA[7];
        PBYTE pAux;

        //_____ Read Connect.set into internal memory buffer _____
        hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            Out(LI0(TEXT("! This file can't be opened.")));
            goto WininetExit;
        }

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        cbAux = GetFileSize(hFile, NULL);
        if (cbAux == 0xFFFFFFFF) {
            Out(LI0(TEXT("! Internal processing error.")));
            goto WininetExit;
        }

        if (cbAux > cbBuffer) {
            pBuf = (PBYTE)CoTaskMemRealloc(pBuf, cbAux);
            if (pBuf == NULL) {
                Out(LI0(TEXT("! Internal processing ran out of memory.")));
                goto WininetExit;
            }
        }
        cbBuffer = cbAux;
        ZeroMemory(pBuf, cbBuffer);

        ReadFile(hFile, pBuf, cbBuffer, &cbAux, NULL);
        ASSERT(*((PDWORD)pBuf) == CS_VERSION_50);

        //_____ Parse through Wininet.dll connections information _____
        for (pCur = pBuf + sizeof(DWORD), cbAux = 0; pCur < (pBuf + cbBuffer); pCur += cbAux) {

            //- - - Initialization - - -
            MACRO_LI_Offset(1);
            if (pCur > (pBuf + sizeof(DWORD)))
                Out(LI0(TEXT("\r\n")));

            //- - - Main processing - - -
            pAux = pCur;

            cbAux = *((PDWORD)pAux);
            pAux += sizeof(DWORD);

            ZeroMemory(&listA, sizeof(listA));
            listA.dwSize   = sizeof(listA);     // listA.dwSize
            listA.pOptions = rgOptionsA;        // listA.pOptions

            // listA.pszConnection
            if (*pAux == NULL) {
                listA.pszConnection = NULL;
                pAux += sizeof(DWORD);
            }
            else {
                listA.pszConnection = (PSTR)pAux;
                pAux += StrCbFromSzA(listA.pszConnection);
            }

            // skip all but LAN settings if no RAS devices
            if (cDevices == 0 && listA.pszConnection != NULL)
                continue;

            if (listA.pszConnection == NULL)
                Out(LI0(TEXT("Proccessing Wininet.dll settings for LAN connection...")));
            else
                Out(LI1(TEXT("Proccessing Wininet.dll settings for \"%s\" connection..."),
                    A2CT(listA.pszConnection)));

            // listA.dwOptionCount
            listA.dwOptionCount = *((PDWORD)pAux);
            pAux += sizeof(DWORD);

            // listA.pOptions
            for (i = 0; i < min(listA.dwOptionCount, countof(rgOptionsA)); i++) {
                listA.pOptions[i].dwOption = *((PDWORD)pAux);
                pAux += sizeof(DWORD);

                switch (listA.pOptions[i].dwOption) {
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                    setSzFromBlobA(&pAux, &listA.pOptions[i].Value.pszValue);
                    break;

                case INTERNET_PER_CONN_FLAGS:
                case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                default:                        // everything else is also DWORD
                    listA.pOptions[i].Value.dwValue = *((PDWORD)pAux);
                    pAux += sizeof(DWORD);
                    break;
                }
            }
            ASSERT(pAux == pCur + cbAux);

            if (HasFlag(g_GetContext(), (CTX_ISP | CTX_ICP))) {
                ASSERT(listA.pOptions[0].dwOption == INTERNET_PER_CONN_FLAGS);

                if (HasFlag(listA.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY)) {
                    DWORD dwFlags;

                    dwFlags  = getWininetFlagsSetting(A2CT(listA.pszConnection));
                    dwFlags |= listA.pOptions[0].Value.dwValue;
                    listA.pOptions[0].Value.dwValue = dwFlags;
                }
                else {
                    Out(LI0(TEXT("No customizations!"))); // nothing to do since had only proxy
                    continue;                             // stuff to begin with. and now even
                }                                         // that is not there.
            }

            //- - - Merge new LAN's ProxyBypass settings with the existing ones - - -
            // NOTE: (andrewgu) since ieakeng.dll will always save the proxy information into the
            // ins file as well, it makes no sense to do this here because what's in the ins
            // should overwrite what's in the imported connections settings.

            //- - - Call into Wininet.dll - - -
            if (FALSE == InternetSetOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listA, listA.dwSize)) {
                Out(LI0(TEXT("! Processing of this Wininet.dll connection settings failed.")));
                continue;
            }

            Out(LI0(TEXT("Done.")));
        }
        Out(LI0(TEXT("Done.")));

        //_____ Cleanup _____
WininetExit:
        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
            CloseFile(hFile);
            hFile = NULL;
        }

        if (pBuf != NULL) {
            CoTaskMemFree(pBuf);
            pBuf = NULL;
        }
    }

    ASSERT(hFile == NULL);
    return S_OK;
}
*/

/////////////////////////////////////////////////////////////////////
HRESULT CRSoPGPO::ProcessRasCS(PCWSTR pszNameW, PBYTE *ppBlob,
							   LPRASDEVINFOW prdiW, UINT cDevices,
							   ComPtr<IWbemClassObject> pCSObj,
							   BSTR *pbstrConnDialUpSettingsObjPath)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessRasCS)

    USES_CONVERSION;

	HRESULT hr = E_FAIL;
	__try
	{
		LPRASENTRYW preW;
		TCHAR   szTargetScript[MAX_PATH];
		PWSTR   pszScriptW;
		PBYTE   pCur;
		DWORD   dwSize, cbRasEntry;
		UINT    i;
		BOOL    fImpersonate;

		ASSERT(RasIsInstalled());
		ASSERT(pszNameW != NULL && ppBlob != NULL && *ppBlob != NULL && prdiW != NULL && cDevices >= 1);

		//----- Validate the header -----
		pCur = *ppBlob;
		if (*((PDWORD)pCur) != CS_STRUCT_RAS)
			return E_UNEXPECTED;
		pCur += sizeof(DWORD);

		fImpersonate = FALSE;
		if (g_CtxIsGp())
			fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

		Out(LI0(TEXT("Processing RAS settings...")));

		dwSize = *((PDWORD)pCur);
		pCur  += sizeof(DWORD);

		//----- Main processing -----
		preW = (LPRASENTRYW)pCur;

		// NOTE: (andrewgu) the is a remote possibility that sizes of RASENTRYW structure are
		// different on the server and client machines. there is nothing bad with server structure
		// being smaller than the client structure (all RAS apis are backward-compatible). it's bad
		// though when server structure is bigger than client can handle, hence the trancation.
		// (something else to have in mind) this truncation should not affect alternate phone numbers
		// support on winnt.
		if (preW->dwSize > sizeof(RASENTRYW))
			preW->dwSize = sizeof(RASENTRYW);

		// preW->szScript
		if (preW->szScript[0] != L'\0') {
			pszScriptW = preW->szScript;
			if (preW->szScript[0] == L'[')
				pszScriptW = &preW->szScript[1];

					TCHAR szTargetDir[MAX_PATH];
					StrCpy(szTargetDir, m_szINSFile);
					PathCombine(szTargetScript, g_GetTargetPath(), PathFindFileName(W2CT(pszScriptW)));
			if (PathFileExists(szTargetScript))
				StrCpyW(preW->szScript, T2CW(szTargetScript));
			else
				preW->szScript[0] = L'\0';
		}

		// preW->szDeviceName
		for (i = 0; i < cDevices; i++) {
			if (0 == StrCmpIW(preW->szDeviceType, prdiW->szDeviceType)) {
				StrCpyW(preW->szDeviceName, prdiW->szDeviceName);
				break;
			}
		}
		if (i >= cDevices)
			StrCpyW(preW->szDeviceName, prdiW[0].szDeviceName);

		Out(LI1(TEXT("Set the device name to \"%s\"."), W2CT(preW->szDeviceName)));

		cbRasEntry = dwSize - 2*sizeof(DWORD);

		//
		// Create & populate RSOP_IEConnectionSettings
		//
		_bstr_t bstrClass = L"RSOP_IEConnectionDialUpSettings";
		ComPtr<IWbemClassObject> pDUSObj = NULL;
		hr = CreateRSOPObject(bstrClass, &pDUSObj);
		if (SUCCEEDED(hr))
		{
			// Write foreign keys from our stored precedence & id fields
			OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"),
										(BSTR)bstrClass, m_dwPrecedence));
			hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pDUSObj);

			OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"),
										(BSTR)bstrClass, (BSTR)m_bstrID));
			hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pDUSObj);

			//------------------------------------------------
			// connectionName
			hr = PutWbemInstancePropertyEx(L"connectionName", pszNameW, pDUSObj);

			//------------------------------------------------
			// rasEntryData
			SAFEARRAY *psa = CreateSafeArray(VT_UI1, cbRasEntry);
			void HUGEP *pData = NULL;
			hr = SafeArrayAccessData(psa, &pData);
			if (SUCCEEDED(hr))
			{
				memcpy(pData, preW, cbRasEntry);
				SafeArrayUnaccessData(psa);

				VARIANT vtData;
				vtData.vt = VT_UI1 | VT_ARRAY;
				vtData.parray = psa;
				hr = PutWbemInstancePropertyEx(L"rasEntryData", vtData, pDUSObj);
				SafeArrayDestroy(psa);
			}

			//------------------------------------------------
			// rasEntryDataSize
			hr = PutWbemInstancePropertyEx(L"rasEntryDataSize", (long)cbRasEntry, pDUSObj);

			//------------------------------------------------
			// options
			hr = PutWbemInstancePropertyEx(L"options", (long)preW->dwfOptions, pDUSObj);

			// Location/phone number
			hr = PutWbemInstancePropertyEx(L"countryID", (long)preW->dwCountryID, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"countryCode", (long)preW->dwCountryCode, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"areaCode", preW->szAreaCode, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"localPhoneNumber", preW->szLocalPhoneNumber, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"alternateOffset", (long)preW->dwAlternateOffset, pDUSObj);

			// PPP/Ip
			TCHAR szIPAddr[16];
			_stprintf(szIPAddr, _T("%d.%d.%d.%d"), preW->ipaddr.a, preW->ipaddr.b,
							preW->ipaddr.c, preW->ipaddr.d);
			hr = PutWbemInstancePropertyEx(L"ipAddress", szIPAddr, pDUSObj);

			_stprintf(szIPAddr, _T("%d.%d.%d.%d"), preW->ipaddrDns.a,
							preW->ipaddrDns.b, preW->ipaddrDns.c, preW->ipaddrDns.d);
			hr = PutWbemInstancePropertyEx(L"ipDNSAddress", szIPAddr, pDUSObj);

			_stprintf(szIPAddr, _T("%d.%d.%d.%d"), preW->ipaddrDnsAlt.a,
							preW->ipaddrDnsAlt.b, preW->ipaddrDnsAlt.c, preW->ipaddrDnsAlt.d);
			hr = PutWbemInstancePropertyEx(L"ipDNSAddressAlternate", szIPAddr, pDUSObj);

			_stprintf(szIPAddr, _T("%d.%d.%d.%d"), preW->ipaddrWins.a,
							preW->ipaddrWins.b, preW->ipaddrWins.c, preW->ipaddrWins.d);
			hr = PutWbemInstancePropertyEx(L"ipWINSAddress", szIPAddr, pDUSObj);

			_stprintf(szIPAddr, _T("%d.%d.%d.%d"), preW->ipaddrWinsAlt.a,
							preW->ipaddrWinsAlt.b, preW->ipaddrWinsAlt.c, preW->ipaddrWinsAlt.d);
			hr = PutWbemInstancePropertyEx(L"ipWINSAddressAlternate", szIPAddr, pDUSObj);

			// Framing
			hr = PutWbemInstancePropertyEx(L"frameSize", (long)preW->dwFrameSize, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"netProtocols", (long)preW->dwfNetProtocols, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"framingProtocol", (long)preW->dwFramingProtocol, pDUSObj);

			// Scripting
			hr = PutWbemInstancePropertyEx(L"scriptFile", preW->szScript, pDUSObj);

		  // AutoDial
			hr = PutWbemInstancePropertyEx(L"autodialDll", preW->szAutodialDll, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"autodialFunction", preW->szAutodialFunc, pDUSObj);

		  // Device
			hr = PutWbemInstancePropertyEx(L"deviceType", preW->szDeviceType, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"deviceName", preW->szDeviceName, pDUSObj);

		  // X.25
			hr = PutWbemInstancePropertyEx(L"x25PadType", preW->szX25PadType, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"x25Address", preW->szX25Address, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"x25Facilities", preW->szX25Facilities, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"x25UserData", preW->szX25UserData, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"channels", (long)preW->dwChannels, pDUSObj);

		  // Reserved
			hr = PutWbemInstancePropertyEx(L"reserved1", (long)preW->dwReserved1, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"reserved2", (long)preW->dwReserved2, pDUSObj);

			// We don't need to worry about dwAlternateOffset here.  It doesn't affect
			// the size of the structure.
			//
			// RASENTRY structure:
			// 
			// VERSION						ANSI size		UNICODE size
			// -------------			---------		------------
			// WINVER <	 401			1768				3468
			// WINVER >= 401			1796				3496
			// WINVER >= 500			2088				4048
			// WINVER >= 501			2096				4056
			DWORD nWinVerAtLeast = 1;
#ifdef UNICODE
			if (4056 == cbRasEntry)
				nWinVerAtLeast = 0x501;
			else if (4048 == cbRasEntry)
				nWinVerAtLeast = 0x500;
			else if (3496 == cbRasEntry)
				nWinVerAtLeast = 0x401;
			else if (3468 == cbRasEntry)
				nWinVerAtLeast = 0x1;
#else
			if (2096 == cbRasEntry)
				nWinVerAtLeast = 0x501;
			else if (2088 == cbRasEntry)
				nWinVerAtLeast = 0x500;
			else if (1796 == cbRasEntry)
				nWinVerAtLeast = 0x401;
			else if (1768 == cbRasEntry)
				nWinVerAtLeast = 0x1;
#endif

			//
			// #if (WINVER >= 0x401)
			//
			if (nWinVerAtLeast >= 0x401)
			{
				// Multilink
				hr = PutWbemInstancePropertyEx(L"subEntries", (long)preW->dwSubEntries, pDUSObj);
				hr = PutWbemInstancePropertyEx(L"dialMode", (long)preW->dwDialMode, pDUSObj);
				hr = PutWbemInstancePropertyEx(L"dialExtraPercent", (long)preW->dwDialExtraPercent, pDUSObj);
				hr = PutWbemInstancePropertyEx(L"dialExtraSampleSeconds", (long)preW->dwDialExtraSampleSeconds, pDUSObj);
				hr = PutWbemInstancePropertyEx(L"hangUpExtraPercent", (long)preW->dwHangUpExtraPercent, pDUSObj);
				hr = PutWbemInstancePropertyEx(L"hangUpExtraSampleSeconds", (long)preW->dwHangUpExtraSampleSeconds, pDUSObj);

				// Idle timeout
				hr = PutWbemInstancePropertyEx(L"idleDisconnectSeconds", (long)preW->dwIdleDisconnectSeconds, pDUSObj);
			}

			//
			// #if (WINVER >= 0x500)
			//
			if (nWinVerAtLeast >= 0x500)
			{
			  // Entry Type
				hr = PutWbemInstancePropertyEx(L"type", (long)preW->dwType, pDUSObj);

				// Encryption type
				hr = PutWbemInstancePropertyEx(L"encryptionType", (long)preW->dwEncryptionType, pDUSObj);

				// CustomAuthKey to be used for EAP
				hr = PutWbemInstancePropertyEx(L"customAuthenticationKey", (long)preW->dwCustomAuthKey, pDUSObj);

				// Guid of the connection
				WCHAR wszGuid[MAX_GUID_LENGTH];
				StringFromGUID2(preW->guidId, wszGuid, MAX_GUID_LENGTH);
				hr = PutWbemInstancePropertyEx(L"guidID", wszGuid, pDUSObj);

				// Custom Dial Dll
				hr = PutWbemInstancePropertyEx(L"customDialDll", preW->szCustomDialDll, pDUSObj);

				// DwVpnStrategy
				hr = PutWbemInstancePropertyEx(L"vpnStrategy", (long)preW->dwVpnStrategy, pDUSObj);
			}

			//
			// #if (WINVER >= 0x501)
			//
			if (nWinVerAtLeast >= 0x501)
			{
				// More RASEO_* options
				hr = PutWbemInstancePropertyEx(L"options2", (long)preW->dwfOptions2, pDUSObj);

				// For future use
				hr = PutWbemInstancePropertyEx(L"options3", (long)preW->dwfOptions3, pDUSObj);
			}

			// Store the windows version is of the machine where the structure
			// was originally from (we think).
			hr = PutWbemInstancePropertyEx(L"windowsVersion", (long)nWinVerAtLeast, pDUSObj);

			//alternatePhoneNumbers - ignored for now (see brandcs.cpp  - search on dwAlternateOffset
//				hr = PutWbemInstancePropertyEx(L"alternatePhoneNumbers", NULL, pDUSObj);


			//
			// Commit all above properties by calling PutInstance, semisynchronously
			//
			hr = PutWbemInstance(pDUSObj, bstrClass, pbstrConnDialUpSettingsObjPath);
		}

		*ppBlob += dwSize;

		Out(LI0(TEXT("Done.")));
		if (fImpersonate)
			RevertToSelf();
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in ProcessRasCS.")));
	}

	OutD(LI0(TEXT("Exiting ProcessRasCS function.\r\n")));
	return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT CRSoPGPO::ProcessRasCredentialsCS(PCWSTR pszNameW, PBYTE *ppBlob,
										  ComPtr<IWbemClassObject> pCSObj,
										  BSTR *pbstrConnDialUpCredObjPath)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessRasCredentialsCS)

    USES_CONVERSION;

	HRESULT hr = E_FAIL;
	__try
	{
		ASSERT(RasIsInstalled());
		ASSERT(pszNameW != NULL && ppBlob != NULL && *ppBlob != NULL);

		//----- Validate the header -----
		PBYTE pCur = *ppBlob;
		if (*((PDWORD)pCur) != CS_STRUCT_RAS_CREADENTIALS)
			return E_UNEXPECTED;
		pCur += sizeof(DWORD);

		BOOL fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

		Out(LI0(TEXT("Processing RAS credentials settings...")));
		BOOL fDeletePassword = FALSE;

		DWORD dwSize = *((PDWORD)pCur);
		pCur  += sizeof(DWORD);

		//----- Main processing -----
		RASDIALPARAMSW rdpW;
		ZeroMemory(&rdpW, sizeof(rdpW));
		rdpW.dwSize = sizeof(rdpW);

		StrCpyW(rdpW.szEntryName, pszNameW);

		PWSTR pszAuxW;
		setSzFromBlobW(&pCur, &pszAuxW);
		if (NULL != pszAuxW)
			StrCpyW(rdpW.szUserName, pszAuxW);

		setSzFromBlobW(&pCur, &pszAuxW);
		if (NULL != pszAuxW)
			StrCpyW(rdpW.szPassword, pszAuxW);

		setSzFromBlobW(&pCur, &pszAuxW);
		if (NULL != pszAuxW)
			StrCpyW(rdpW.szDomain, pszAuxW);

		if (rdpW.szPassword[0] == L'\0')
			fDeletePassword = TRUE;

		if (rdpW.szDomain[0] == L'\0') {
			rdpW.szDomain[0]  = L' ';
			ASSERT(rdpW.szDomain[1] == L'\0');
		}

		hr = S_OK;

		_bstr_t bstrClass = L"RSOP_IEConnectionDialUpCredentials";
		ComPtr<IWbemClassObject> pDUCObj = NULL;
		hr = CreateRSOPObject(bstrClass, &pDUCObj);
		if (SUCCEEDED(hr))
		{
			// Write foreign keys from our stored precedence & id fields
			OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"),
										(BSTR)bstrClass, m_dwPrecedence));
			hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pDUCObj);

			OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"),
										(BSTR)bstrClass, (BSTR)m_bstrID));
			hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pDUCObj);

			//------------------------------------------------
			// connectionName
			hr = PutWbemInstancePropertyEx(L"connectionName", pszNameW, pDUCObj);

			//------------------------------------------------
			// rasDialParamsData
			SAFEARRAY *psa = CreateSafeArray(VT_UI1, rdpW.dwSize);
			void HUGEP *pData = NULL;
			hr = SafeArrayAccessData(psa, &pData);
			if (SUCCEEDED(hr))
			{
				memcpy(pData, &rdpW, rdpW.dwSize);
				SafeArrayUnaccessData(psa);

				VARIANT vtData;
				vtData.vt = VT_UI1 | VT_ARRAY;
				vtData.parray = psa;
				hr = PutWbemInstancePropertyEx(L"rasDialParamsData", vtData, pDUCObj);
				SafeArrayDestroy(psa);
			}

			//------------------------------------------------
			// rasDialParamsDataSize
			hr = PutWbemInstancePropertyEx(L"rasDialParamsDataSize", (long)rdpW.dwSize, pDUCObj);

			//------------------------------------------------
			// entryName
			hr = PutWbemInstancePropertyEx(L"entryName", rdpW.szEntryName, pDUCObj);

			//------------------------------------------------
			// phoneNumber
			hr = PutWbemInstancePropertyEx(L"phoneNumber", rdpW.szPhoneNumber, pDUCObj);

			//------------------------------------------------
			// callbackNumber
			hr = PutWbemInstancePropertyEx(L"callbackNumber", rdpW.szCallbackNumber, pDUCObj);

			//------------------------------------------------
			// userName
			hr = PutWbemInstancePropertyEx(L"userName", rdpW.szUserName, pDUCObj);

			//------------------------------------------------
			// password
			hr = PutWbemInstancePropertyEx(L"password", rdpW.szPassword, pDUCObj);

			//------------------------------------------------
			// domain
			hr = PutWbemInstancePropertyEx(L"domain", rdpW.szDomain, pDUCObj);

			// RASDIALPARAMS structure:
			// 
			// VERSION						ANSI size		UNICODE size
			// -------------			---------		------------
			// WINVER <	 401			1052				2096
			// WINVER >= 401			1060				2104
			DWORD nWinVerAtLeast = 1;
#ifdef UNICODE
			if (2104 == rdpW.dwSize)
				nWinVerAtLeast = 0x401;
			else if (2096 == rdpW.dwSize)
				nWinVerAtLeast = 0x1;
#else
			if (1060 == rdpW.dwSize)
				nWinVerAtLeast = 0x401;
			else if (1052 == rdpW.dwSize)
				nWinVerAtLeast = 0x1;
#endif

			//
			// #if (WINVER >= 0x401)
			//
			if (nWinVerAtLeast >= 0x401)
			{
				//------------------------------------------------
				// subEntry
				hr = PutWbemInstancePropertyEx(L"subEntry", (long)rdpW.dwSubEntry, pDUCObj);

				//------------------------------------------------
				// callbackID
				hr = PutWbemInstancePropertyEx(L"callbackID", (long)rdpW.dwCallbackId, pDUCObj);
			}

			// Store the windows version is of the machine where the structure
			// was originally from (we think).
			hr = PutWbemInstancePropertyEx(L"windowsVersion", (long)nWinVerAtLeast, pDUCObj);


			//
			// Commit all above properties by calling PutInstance, semisynchronously
			//
			hr = PutWbemInstance(pDUCObj, bstrClass, pbstrConnDialUpCredObjPath);
		}

		Out(LI0(TEXT("Done.")));
		*ppBlob += dwSize;
		if (fImpersonate)
			RevertToSelf();
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in ProcessRasCredentialsCS.")));
	}

	OutD(LI0(TEXT("Exiting ProcessRasCredentialsCS function.\r\n")));
	return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT CRSoPGPO::ProcessWininetCS(PCWSTR pszNameW, PBYTE *ppBlob,
								   ComPtr<IWbemClassObject> pCSObj,
								   BSTR *pbstrConnWinINetSettingsObjPath)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessWininetCS)

    USES_CONVERSION;

	HRESULT hr = E_FAIL;
	__try
	{
		ASSERT(ppBlob != NULL && *ppBlob != NULL);

		//----- Validate the header -----
		PBYTE pCur = *ppBlob;
		if (*((PDWORD)pCur) != CS_STRUCT_WININET)
			hr = E_UNEXPECTED;
		else
		{
			pCur += sizeof(DWORD);

			Out(LI0(TEXT("Processing Wininet.dll settings...")));

			DWORD dwSize = *((PDWORD)pCur);
			pCur  += sizeof(DWORD);

			//----- Main processing -----
			INTERNET_PER_CONN_OPTION_LISTW listW;
			ZeroMemory(&listW, sizeof(listW));
			listW.dwSize   = sizeof(listW);             // listW.dwSize

			INTERNET_PER_CONN_OPTIONW rgOptionsW[7];
			listW.pOptions = rgOptionsW;                // listW.pOptions

			// listW.pszConnection
			listW.pszConnection = (PWSTR)pszNameW;

			// listW.dwOptionCount
			listW.dwOptionCount = *((PDWORD)pCur);
			pCur += sizeof(DWORD);

			// listW.pOptions
			UINT i;
			for (i = 0; i < min(listW.dwOptionCount, countof(rgOptionsW)); i++) {
				listW.pOptions[i].dwOption = *((PDWORD)pCur);
				pCur += sizeof(DWORD);

				switch (listW.pOptions[i].dwOption) {
				case INTERNET_PER_CONN_PROXY_SERVER:
				case INTERNET_PER_CONN_PROXY_BYPASS:
				case INTERNET_PER_CONN_AUTOCONFIG_URL:
				case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
					setSzFromBlobW(&pCur, &listW.pOptions[i].Value.pszValue);
					break;

				case INTERNET_PER_CONN_FLAGS:
				case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
				case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
				default:                        // everything else is also DWORD
					listW.pOptions[i].Value.dwValue = *((PDWORD)pCur);
					pCur += sizeof(DWORD);
					break;
				}
			}
			ASSERT(pCur == *ppBlob + dwSize);

			_bstr_t bstrClass = L"RSOP_IEConnectionWinINetSettings";
			ComPtr<IWbemClassObject> pWSObj = NULL;

			if (HasFlag(g_GetContext(), (CTX_ISP | CTX_ICP)))
			{
				ASSERT(listW.pOptions[0].dwOption == INTERNET_PER_CONN_FLAGS);

				if (HasFlag(listW.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY))
				{
					DWORD dwFlags = getWininetFlagsSetting(W2CT(listW.pszConnection));
					dwFlags |= listW.pOptions[0].Value.dwValue;
					listW.pOptions[0].Value.dwValue = dwFlags;
				}
				else
				{
					hr = S_OK;                            // nothing to do since had only proxy stuff to
					Out(LI0(TEXT("No customizations!"))); // begin with. and now even that is not there
					goto Exit;
				}
			}

			//----- Merge new LAN's ProxyBypass settings with the existing ones -----
			// NOTE: (andrewgu) since ieakeng.dll will always save the proxy information into the
			// ins file as well, it makes no sense to do this here because what's in the ins
			// should overwrite what's in the imported connections settings.

			hr = S_OK;

			hr = CreateRSOPObject(bstrClass, &pWSObj);
			if (SUCCEEDED(hr))
			{
				// Write foreign keys from our stored precedence & id fields
				OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"),
											(BSTR)bstrClass, m_dwPrecedence));
				hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pWSObj);

				OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"),
											(BSTR)bstrClass, (BSTR)m_bstrID));
				hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pWSObj);

				//------------------------------------------------
				// connectionName
				OutD(LI1(TEXT("WinINet connection name = %s"), NULL == pszNameW ? _T("{local LAN settings}") : pszNameW));
				hr = PutWbemInstancePropertyEx(L"connectionName", NULL == pszNameW ? L"" : pszNameW, pWSObj);

				//------------------------------------------------
				// internetPerConnOptionListData
				SAFEARRAY *psa = CreateSafeArray(VT_UI1, listW.dwSize);
				void HUGEP *pData = NULL;
				hr = SafeArrayAccessData(psa, &pData);
				if (SUCCEEDED(hr))
				{
					memcpy(pData, &listW, listW.dwSize);
					SafeArrayUnaccessData(psa);

					VARIANT vtData;
					vtData.vt = VT_UI1 | VT_ARRAY;
					vtData.parray = psa;
					hr = PutWbemInstancePropertyEx(L"internetPerConnOptionListData", vtData, pWSObj);
				SafeArrayDestroy(psa);
				}

				//------------------------------------------------
				// internetPerConnOptionListDataSize
				hr = PutWbemInstancePropertyEx(L"internetPerConnOptionListDataSize", (long)listW.dwSize, pWSObj);


				//
				// Commit all above properties by calling PutInstance, semisynchronously
				//
				hr = PutWbemInstance(pWSObj, bstrClass, pbstrConnWinINetSettingsObjPath);
			}

		Exit:
			Out(LI0(TEXT("Done.")));
			*ppBlob += dwSize;
		}
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in ProcessWininetCS.")));
	}

	OutD(LI0(TEXT("Exiting ProcessWininetCS function.\r\n")));
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\rsopadm.cpp ===
#include "precomp.h"

// The following bug may be due to having CHICAGO_PRODUCT set in sources.
// This file and all rsop??.cpp files need to have WINVER defined at at least 500

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0501
#include <userenv.h>

#include "RSoP.h"
//#include "wbemtime.h"
#include "utils.h"

#include <tchar.h>

typedef BOOL (*PFNREGFILECALLBACK)(BOOL bHKCU, LPTSTR lpKeyName,
                                   LPTSTR lpValueName, DWORD dwType,
                                   DWORD dwDataLength, LPBYTE lpData,
                                   REGHASHTABLE *pHashTable);

#define MAX_KEYNAME_SIZE         2048
#define MAX_VALUENAME_SIZE        512
const MAX_LENGTH = 100; // Length of stringized guid

HRESULT SystemTimeToWbemTime(SYSTEMTIME& sysTime, _bstr_t &xbstrWbemTime);

extern SAFEARRAY *CreateSafeArray(VARTYPE vtType, long nElements, long nDimensions = 1);


///////////////////////////////////////////////////////////
//  CheckSlash() - from nt\ds\security\gina\userenv\utils\util.c
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
///////////////////////////////////////////////////////////
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

///////////////////////////////////////////////////////////
//  IsUNCPath() - from nt\ds\security\gina\userenv\utils\util.c
//
//  Purpose:    Is the given path a UNC path
//
//  Parameters: lpPath  -   Path to check
//
//  Return:     TRUE if the path is UNC
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
///////////////////////////////////////////////////////////
BOOL IsUNCPath(LPCTSTR lpPath)
{

    if ((!lpPath) || (!lpPath[0]) && (!lpPath[1]))
        return FALSE;

    if (lpPath[0] == TEXT('\\') && lpPath[1] == TEXT('\\')) {
        return(TRUE);
    }
    return(FALSE);
}

///////////////////////////////////////////////////////////
//  MakePathUNC()
//
//  Purpose:    Makes the given path UNC s.t. it can be accessed from a remote machine..
//              if the path contains %systemroot% expanded then it substitutes
//              \\machname\admin$ otherwise \\machname\<driveletter>$
//
//  Parameters: lpPath          -   Input Path (needs to be absolute)
//              szComputerName  -   Name of the computer on which this is the local path
//
//  Return:     Path if it was fone successfully
//              NULL if not
//
//  Comments:
///////////////////////////////////////////////////////////
LPTSTR MakePathUNC(LPTSTR pwszFile, LPTSTR szComputerName)
{   MACRO_LI_PrologEx_C(PIF_STD_C, MakePathUNC)
    LPTSTR szUNCPath = NULL;
    TCHAR szSysRoot[MAX_PATH];
    DWORD dwSysLen;
    LPTSTR lpEnd = NULL;


    OutD(LI1(TEXT("Entering with <%s>"), pwszFile ? pwszFile : TEXT("NULL")));

	szUNCPath = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(pwszFile)+lstrlen(szComputerName)+3+lstrlen(TEXT("admin$"))+1));

    if (!szUNCPath)
        return NULL;

    if (!pwszFile || !*pwszFile) {
        OutD(LI0(TEXT("lpFile is NULL, setting lpResult to a null string")));
        *szUNCPath = TEXT('\0');
        return szUNCPath;
    }


    if (IsUNCPath(pwszFile)) {
        lstrcpy(szUNCPath, pwszFile);
        return szUNCPath;
    }


    lstrcpy(szUNCPath, TEXT("\\\\"));
    lstrcat(szUNCPath, szComputerName);


    //
    // If the first part of lpFile is the expanded value of %SystemRoot%
    //

    if (!ExpandEnvironmentStrings (TEXT("%SystemRoot%"), szSysRoot, MAX_PATH)) {
        OutD(LI1(TEXT("ExpandEnvironmentString failed with error %d, setting szSysRoot to %systemroot% "), GetLastError()));
        LocalFree((HLOCAL)szUNCPath);
        return NULL;
    }


    dwSysLen = lstrlen(szSysRoot);
    lpEnd = CheckSlash(szUNCPath);


    //
    // if the prefix is the same as expanded systemroot then..
    //

    if (((DWORD)lstrlen(pwszFile) > dwSysLen) &&
        (CompareString (LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                       szSysRoot, dwSysLen,
                       pwszFile, dwSysLen) == CSTR_EQUAL)) {

        lstrcat(szUNCPath, TEXT("admin$"));
        lstrcat(szUNCPath, pwszFile+dwSysLen);
    }
    else {

        if (pwszFile[1] != TEXT(':')) {
            OutD(LI1(TEXT("Input path %s is not an absolute path"), pwszFile));
            lstrcpy(szUNCPath, pwszFile);
            return szUNCPath;
        }

        lpEnd[0] = pwszFile[0];
        lpEnd[1] = TEXT('$');
        lpEnd[2] = TEXT('\0');

        lstrcat(szUNCPath, pwszFile+2);
    }

    OutD(LI1(TEXT("Returning a UNCPath of %s"), szUNCPath));

    return szUNCPath;
}

///////////////////////////////////////////////////////////
//  AllocAdmFileInfo()
//
//  Purpose:    Allocates a new struct for ADMFILEINFO
//
//  Parameters: pwszFile  -  File name
//              pwszGPO   -  Gpo
//              pftWrite  -  Last write time
///////////////////////////////////////////////////////////
ADMFILEINFO *AllocAdmFileInfo(WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite)
{   MACRO_LI_PrologEx_C(PIF_STD_C, AllocAdmFileInfo)
    ADMFILEINFO *pAdmFileInfo = (ADMFILEINFO *) LocalAlloc( LPTR, sizeof(ADMFILEINFO) );
    if  ( pAdmFileInfo == NULL ) {
        OutD(LI0(TEXT("Failed to allocate memory.")));
        return NULL;
    }

    pAdmFileInfo->pwszFile = (WCHAR *) LocalAlloc( LPTR, (lstrlen(pwszFile) + 1) * sizeof(WCHAR) );
    if ( pAdmFileInfo->pwszFile == NULL ) {
        OutD(LI0(TEXT("Failed to allocate memory.")));
        LocalFree( pAdmFileInfo );
        return NULL;
    }

    pAdmFileInfo->pwszGPO = (WCHAR *) LocalAlloc( LPTR, (lstrlen(pwszGPO) + 1) * sizeof(WCHAR) );
    if ( pAdmFileInfo->pwszGPO == NULL ) {
        OutD(LI0(TEXT("Failed to allocate memory.")));
        LocalFree( pAdmFileInfo->pwszFile );
        LocalFree( pAdmFileInfo );
        return NULL;
    }

    lstrcpy( pAdmFileInfo->pwszFile, pwszFile );
    lstrcpy( pAdmFileInfo->pwszGPO, pwszGPO );

    pAdmFileInfo->ftWrite = *pftWrite;

    return pAdmFileInfo;
}

///////////////////////////////////////////////////////////
//  FreeAdmFileInfo()
//
//  Purpose:    Deletes a ADMFILEINFO struct
//
//  Parameters: pAdmFileInfo - Struct to delete
//              pftWrite   -  Last write time
///////////////////////////////////////////////////////////
void FreeAdmFileInfo( ADMFILEINFO *pAdmFileInfo )
{
    if ( pAdmFileInfo ) {
        LocalFree( pAdmFileInfo->pwszFile );
        LocalFree( pAdmFileInfo->pwszGPO );
        LocalFree( pAdmFileInfo );
    }
}

///////////////////////////////////////////////////////////
//  FreeAdmFileCache() - taken from gpreg.cpp in nt\ds\security\gina\userenv\policy
//
//  Purpose:    Frees Adm File list
//
//  Parameters: pAdmFileCache - List of Adm files to free
///////////////////////////////////////////////////////////
void FreeAdmFileCache( ADMFILEINFO *pAdmFileCache )
{
    ADMFILEINFO *pNext;

    while ( pAdmFileCache ) {
        pNext = pAdmFileCache->pNext;
        FreeAdmFileInfo( pAdmFileCache );
        pAdmFileCache = pNext;
    }
}

///////////////////////////////////////////////////////////
//  AddAdmFile() - taken from gpreg.cpp in nt\ds\security\gina\userenv\policy
//
//  Purpose:    Prepends to list of Adm files
//
//  Parameters: pwszFile       - File path
//              pwszGPO        - Gpo
//              pftWrite       - Last write time
//              ppAdmFileCache - List of Adm files processed
///////////////////////////////////////////////////////////
BOOL AddAdmFile(WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite,
				WCHAR *szComputerName, ADMFILEINFO **ppAdmFileCache)
{   MACRO_LI_PrologEx_C(PIF_STD_C, AddAdmFile)
	LPWSTR wszLongPath;
    LPWSTR pwszUNCPath;

    OutD(LI1(TEXT("Adding File name <%s> to the Adm list."), pwszFile));
    if ((szComputerName) && (*szComputerName) && (!IsUNCPath(pwszFile))) {
        wszLongPath = MakePathUNC(pwszFile, szComputerName);

        if (!wszLongPath) {
            OutD(LI1(TEXT("Failed to Make the path UNC with error %d."), GetLastError()));
            return FALSE;
        }
        pwszUNCPath = wszLongPath;
    }
    else
        pwszUNCPath = pwszFile;


    ADMFILEINFO *pAdmInfo = AllocAdmFileInfo(pwszUNCPath, pwszGPO, pftWrite);
    if ( pAdmInfo == NULL )
        return FALSE;

    pAdmInfo->pNext = *ppAdmFileCache;
    *ppAdmFileCache = pAdmInfo;

    return TRUE;
}

///////////////////////////////////////////////////////////
// Function:        SystemTimeToWbemTime
//
// Description:
//
// Parameters:
//
// Return:
//
// History:         12/08/99        leonardm    Created.
///////////////////////////////////////////////////////////
#define WBEM_TIME_STRING_LENGTH 25
HRESULT SystemTimeToWbemTime(SYSTEMTIME& sysTime, _bstr_t &xbstrWbemTime)
{
    WCHAR *xTemp = new WCHAR[WBEM_TIME_STRING_LENGTH + 1];

    if(!xTemp)
        return E_OUTOFMEMORY;

    int nRes = wsprintf(xTemp, L"%04d%02d%02d%02d%02d%02d.000000+000",
                sysTime.wYear,
                sysTime.wMonth,
                sysTime.wDay,
                sysTime.wHour,
                sysTime.wMinute,
                sysTime.wSecond);

    if(nRes != WBEM_TIME_STRING_LENGTH)
        return E_FAIL;

    xbstrWbemTime = xTemp;

    if(!xbstrWbemTime)
        return E_OUTOFMEMORY;

    return S_OK;
}

///////////////////////////////////////////////////////////
//  ParseRegistryFile()
//
//  Purpose:    Parses a registry.pol file
//
//  Parameters: lpRegistry         -   Path to registry file (.INF)
//              pfnRegFileCallback -   Callback function
//              pHashTable         -   Hash table for registry keys
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
///////////////////////////////////////////////////////////
BOOL ParseRegistryFile (LPTSTR lpRegistry,
                        PFNREGFILECALLBACK pfnRegFileCallback,
						REGHASHTABLE *pHashTable)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ParseRegistryFile)
	BOOL bRet = FALSE;
	__try
	{
		OutD(LI1(TEXT("Entering with <%s>."), lpRegistry));

		//
		// Allocate buffers to hold the keyname, valuename, and data
		//

		LPWSTR lpValueName = NULL;
	    LPBYTE lpData = NULL;
		INT iType;
		DWORD dwType = REG_SZ, dwDataLength, dwValue = 0;
		BOOL bHKCU = TRUE;

		UINT nErrLine = 0;
		HINF hInfAdm = NULL;

		LPWSTR lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));
		if (!lpKeyName)
		{
			OutD(LI1(TEXT("Failed to allocate memory with %d"), GetLastError()));
			goto Exit;
		}


		lpValueName = (LPWSTR) LocalAlloc (LPTR, MAX_VALUENAME_SIZE * sizeof(WCHAR));
		if (!lpValueName)
		{
			OutD(LI1(TEXT("Failed to allocate memory with %d"), GetLastError()));
			goto Exit;
		}

		// Get the AddReg.Hkcu section for the registry strings.
		nErrLine = 0;
		hInfAdm = SetupOpenInfFile(lpRegistry, NULL, INF_STYLE_WIN4, &nErrLine);
		if (INVALID_HANDLE_VALUE != hInfAdm)
		{
			for (int iSection = 0; iSection < 2; iSection++)
			{
				OutD(LI1(TEXT("Reading section #%d."), iSection));
				bHKCU = (1 == iSection) ? TRUE : FALSE;

				// Get the first line in this section.
				INFCONTEXT infContext;
				BOOL bLineFound = SetupFindFirstLine(hInfAdm, bHKCU ?
													TEXT("AddRegSection.HKCU") : 
													TEXT("AddRegSection.HKLM"),
													NULL, &infContext);

				DWORD dwReqSize = 0;
				while (bLineFound)
				{
					// Read the data

					// **********************************
					// Process the registry setting line.

					// Read the keyname
					ZeroMemory(lpKeyName, MAX_KEYNAME_SIZE);
					dwReqSize = 0;
					if (!SetupGetStringField(&infContext, 2, lpKeyName,
											MAX_KEYNAME_SIZE, &dwReqSize))
					{
						if (dwReqSize >= MAX_KEYNAME_SIZE)
							OutD(LI0(TEXT("Keyname exceeded max size")));
						else
							OutD(LI1(TEXT("Failed to read keyname from line, error %d."), GetLastError()));
						goto Exit;
					}

					// Read the valuename
					ZeroMemory(lpValueName, MAX_VALUENAME_SIZE);
					dwReqSize = 0;
					if (!SetupGetStringField(&infContext, 3, lpValueName,
											MAX_VALUENAME_SIZE, &dwReqSize))
					{
						if (dwReqSize >= MAX_VALUENAME_SIZE)
							OutD(LI0(TEXT("Valuename exceeded max size")));
						else
						{
							OutD(LI1(TEXT("Failed to read valuename from line, error %d."),
									GetLastError()));
						}
						goto Exit;
					}

					// Read the type
					if (!SetupGetIntField(&infContext, 4, &iType))
					{
						OutD(LI1(TEXT("Failed to read type from line, error %d."),
								GetLastError()));
						goto Exit;
					}

					lpData = NULL;
					dwDataLength = 0;
					if (0 == iType)
					{
						dwType = REG_SZ;

						// Allocate memory for data
						dwReqSize = 0;
						if (!SetupGetStringField(&infContext, 5, NULL, 0, &dwReqSize))
						{
							OutD(LI1(TEXT("Failed to get size of string value from line, error %d."),
									GetLastError()));
							goto Exit;
						}

						if (dwReqSize > 0)
						{
							lpData = (LPBYTE)LocalAlloc(LPTR, dwReqSize * sizeof(TCHAR));
							if (!lpData)
							{
								OutD(LI1(TEXT("Failed to allocate memory for data with %d"),
										 GetLastError()));
								goto Exit;
							}

							// Read string data
							dwDataLength = dwReqSize;
							dwReqSize = 0;
							if (!SetupGetStringField(&infContext, 5, (LPTSTR)lpData, dwDataLength, &dwReqSize))
							{
								OutD(LI1(TEXT("Failed to get size of string value from line, error %d."),
										GetLastError()));
								goto Exit;
							}

							// convert to wide char string so the reader of the data doesn't have to guess
							// whether the data was written in ansi or unicode.
							if (NULL != lpData && dwDataLength > 0)
							{
								_bstr_t bstrData = (LPTSTR)lpData;
								dwDataLength = bstrData.length() * sizeof(WCHAR);
							}
						}
						else
							OutD(LI0(TEXT("Error.  Size of string data is 0.")));
					}
					else if (0x10001 == iType)
					{
						dwType = REG_DWORD;

						// Read numeric data
						dwDataLength = sizeof(dwValue);
						dwValue = 0;
						dwReqSize = 0;
						if (!SetupGetBinaryField(&infContext, 5, (PBYTE)&dwValue, dwDataLength, &dwReqSize))
						{
							OutD(LI1(TEXT("Failed to get DWORD value from line, error %d."),
									GetLastError()));
							goto Exit;
						}

						lpData = (LPBYTE)&dwValue;
					}
					else
					{
						OutD(LI1(TEXT("Invalid type (%lX)."), dwType));
						goto Exit;
					}

					if (NULL != lpData)
					{
						// Call the callback function
						if (!pfnRegFileCallback (bHKCU, lpKeyName, lpValueName, dwType,
												dwDataLength, lpData, pHashTable ))
						{
							OutD(LI0(TEXT("Callback function returned false.")));
							goto Exit;
						}
					}

					if (0 == iType && lpData)
						LocalFree (lpData);
					lpData = NULL;
					// **********************************

					// Move to the next line in the INF file.
					bLineFound = SetupFindNextLine(&infContext, &infContext);
				}
			}

			bRet = TRUE;
		}
		else
			OutD(LI1(TEXT("Error %d opening INF file,"), GetLastError()));

Exit:
		// Finished
		OutD(LI0(TEXT("Leaving.")));
		if (lpData)
			LocalFree(lpData);
		if (lpKeyName)
			LocalFree(lpKeyName);
		if (lpValueName)
			LocalFree(lpValueName);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in ParseRegistryFile.")));
	}
	return bRet;
}

///////////////////////////////////////////////////////////
//  SetRegistryValue()
//
//  Purpose:    Callback from ParseRegistryFile that sets
//              registry policies
//
//  Parameters: lpKeyName   -  Key name
//              lpValueName -  Value name
//              dwType      -  Registry data type
//              lpData      -  Registry data
//              pwszGPO     -   Gpo
//              pwszSOM     -   Sdou that the Gpo is linked to
//              pHashTable  -   Hash table for registry keys
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
///////////////////////////////////////////////////////////
BOOL SetRegistryValue (BOOL bHKCU, LPTSTR lpKeyName,
                       LPTSTR lpValueName, DWORD dwType,
                       DWORD dwDataLength, LPBYTE lpData,
                       REGHASHTABLE *pHashTable)
{   MACRO_LI_PrologEx_C(PIF_STD_C, SetRegistryValue)

    BOOL bRet = FALSE;
	__try
	{
		BOOL bUseValueName = FALSE;
    
		//
		// Save registry value
		//
		bRet = AddRegHashEntry( pHashTable, REG_ADDVALUE, bHKCU, lpKeyName,
									  lpValueName, dwType, dwDataLength, lpData,
									  NULL, NULL, bUseValueName ? lpValueName : TEXT(""), TRUE );
		if (bRet) 
		{
			switch (dwType)
			{
				case REG_SZ:
				case REG_EXPAND_SZ:
					OutD(LI2(TEXT("%s => %s  [OK]"), lpValueName, (LPTSTR)lpData));
					break;

				case REG_DWORD:
					OutD(LI2(TEXT("%s => %d  [OK]"), lpValueName, *((LPDWORD)lpData)));
					break;

				case REG_NONE:
					break;

				default:
					OutD(LI1(TEXT("%s was set successfully"), lpValueName));
					break;
			}
		}
		else
		{
			pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());

			OutD(LI2(TEXT("Failed AddRegHashEntry for value <%s> with %d"),
					 lpValueName, pHashTable->hrError));
		}
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in SetRegistryValue.")));
	}
	return bRet;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreADMSettings(LPWSTR wszGPO, LPWSTR wszSOM)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreADMSettings)

	HRESULT hr = E_FAIL;
	BOOL bContinue = TRUE;
	__try
	{
		OutD(LI0(TEXT("\r\nEntered StoreADMSettings function.")));

		// Setup hash table
		REGHASHTABLE *pHashTable = AllocHashTable();
		if (NULL == pHashTable)
		{
			bContinue = FALSE;
			hr = HRESULT_FROM_WIN32(GetLastError());
		}

		WCHAR pwszFile[MAX_PATH];
		LPWSTR pwszEnd = NULL;
		if (bContinue)
		{
			// convert the INS file path to a wide char string
			_bstr_t bstrINSFile = m_szINSFile;
			StrCpyW(pwszFile, (LPWSTR)bstrINSFile);
			PathRemoveFileSpec(pwszFile);

			// Log Adm data
			pwszEnd = pwszFile + lstrlen(pwszFile);
			lstrcpy(pwszEnd, L"\\*.adm");

			// Remember end point so that the actual Adm filename can be
			// easily concatenated.
			pwszEnd = pwszEnd + lstrlen( L"\\" );
		}

		HANDLE hFindFile = NULL;
	    WIN32_FIND_DATA findData;
		ZeroMemory(&findData, sizeof(findData));
		if (bContinue)
		{
			//
			// Enumerate all Adm files
			//
			hFindFile = FindFirstFile( pwszFile, &findData);
			if (INVALID_HANDLE_VALUE == hFindFile)
				bContinue = FALSE;
		}

	    ADMFILEINFO *pAdmFileCache = NULL;
		if (bContinue)
		{
			WIN32_FILE_ATTRIBUTE_DATA attrData;
			TCHAR szComputerName[3*MAX_COMPUTERNAME_LENGTH + 1];
			do
			{
				DWORD dwSize = 3*MAX_COMPUTERNAME_LENGTH + 1;
				if (!GetComputerName(szComputerName, &dwSize))
				{
					OutD(LI1(TEXT("ProcessGPORegistryPolicy: Couldn't get the computer Name with error %d."), GetLastError()));
					szComputerName[0] = TEXT('\0');
				}

				if ( !(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
				{
					lstrcpy( pwszEnd, findData.cFileName);

					WCHAR wszRegDataFile[MAX_PATH];
					StrCpyW(wszRegDataFile, pwszFile);
					PathRenameExtension(wszRegDataFile, TEXT(".INF"));

					if (ParseRegistryFile(wszRegDataFile, SetRegistryValue, pHashTable))
					{
						ZeroMemory (&attrData, sizeof(attrData));
						if ( GetFileAttributesEx (pwszFile, GetFileExInfoStandard, &attrData ) != 0 )
						{
							if (!AddAdmFile( pwszFile, wszGPO, &attrData.ftLastWriteTime,
											  szComputerName, &pAdmFileCache ) )
							{
								OutD(LI0(TEXT("ProcessGPORegistryPolicy: AddAdmFile failed.")));

								if (pHashTable->hrError == S_OK)
									pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
								hr = pHashTable->hrError;
							}
						}
					}
					else
						OutD(LI0(TEXT("ProcessGPORegistryPolicy: ParseRegistryFile failed.")));
				}   // if findData & file_attr_dir

			}  while ( FindNextFile(hFindFile, &findData) );//  do

			FindClose(hFindFile);

		}   // if hfindfile

		//
		// Log registry data to Cimom database
		//
		if (!LogRegistryRsopData(pHashTable, wszGPO, wszSOM))
		{
			OutD(LI0(TEXT("ProcessGPOs: Error when logging Registry Rsop data. Continuing.")));

			if (pHashTable->hrError == S_OK)
				pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
			hr = pHashTable->hrError;
		}
		if (!LogAdmRsopData(pAdmFileCache))
		{
			OutD(LI0(TEXT("ProcessGPOs: Error when logging Adm Rsop data. Continuing.")));

			if (pHashTable->hrError == S_OK)
				pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
			hr = pHashTable->hrError;
		}

		FreeHashTable(pHashTable);
		FreeAdmFileCache(pAdmFileCache);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreADMSettings.")));
	}

	OutD(LI0(TEXT("Exiting StoreADMSettings function.\r\n")));
	return hr;
}

///////////////////////////////////////////////////////////
//  LogAdmRsopData()
//
//  Purpose:    Logs Rsop ADM template data to Cimom database
//
//  Parameters: pAdmFileCache - List of adm file to log
//              pWbemServices - Namespace pointer
//
//  Return:     True if successful
///////////////////////////////////////////////////////////
BOOL CRSoPGPO::LogAdmRsopData(ADMFILEINFO *pAdmFileCache)
{   MACRO_LI_PrologEx_C(PIF_STD_C, LogAdmRsopData)
	BOOL bRet = TRUE;
	__try
	{
	//    if ( !DeleteInstances( L"RSOP_AdministrativeTemplateFile", pWbemServices ) )
	//         return FALSE;

		// Create & populate RSOP_IEAdministrativeTemplateFile
		_bstr_t bstrClass = L"RSOP_IEAdministrativeTemplateFile";
		ComPtr<IWbemClassObject> pATF = NULL;
		HRESULT hr = CreateRSOPObject(bstrClass, &pATF);
		if (SUCCEEDED(hr))
		{
			while ( pAdmFileCache )
			{
				//------------------------------------------------
				// name
				_bstr_t bstrName = pAdmFileCache->pwszFile;
				hr = PutWbemInstancePropertyEx(L"name", bstrName, pATF);

				//------------------------------------------------
				// GPOID
				hr = PutWbemInstancePropertyEx(L"GPOID", pAdmFileCache->pwszGPO, pATF);

				//------------------------------------------------
				// lastWriteTime
				SYSTEMTIME sysTime;
				if (!FileTimeToSystemTime( &pAdmFileCache->ftWrite, &sysTime ))
					OutD(LI1(TEXT("FileTimeToSystemTime failed with 0x%x" ), GetLastError() ));
				else
				{
					_bstr_t bstrTime;
					HRESULT hr = SystemTimeToWbemTime(sysTime, bstrTime);
					if(FAILED(hr) || bstrTime.length() <= 0)
						OutD(LI1(TEXT("Call to SystemTimeToWbemTime failed. hr=0x%08X"),hr));
					else
					{
						hr = PutWbemInstancePropertyEx(L"lastWriteTime", bstrTime, pATF);
						if ( FAILED(hr) )
							OutD(LI1(TEXT("Put failed with 0x%x" ), hr ));
					}
				}

				//
				// Commit all above properties by calling PutInstance, semisynchronously
				//
				BSTR bstrObjPath = NULL;
				hr = PutWbemInstance(pATF, bstrClass, &bstrObjPath);

				pAdmFileCache = pAdmFileCache->pNext;
			}
		}
		else
			bRet = FALSE;

		OutD(LI0(TEXT("Successfully logged Adm data" )));
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in LogAdmRsopData.")));
	}
	return bRet;
}

///////////////////////////////////////////////////////////
//  LogRegistryRsopData()
//
//  Purpose:    Logs registry Rsop data to Cimom database
//
//  Parameters: dwFlags       - Gpo Info flags
//              pHashTable    - Hash table with registry policy data
//              pWbemServices - Namespace pointer for logging
//
//  Return:     True if successful
///////////////////////////////////////////////////////////
BOOL CRSoPGPO::LogRegistryRsopData(REGHASHTABLE *pHashTable, LPWSTR wszGPOID,
								   LPWSTR wszSOMID)
{   MACRO_LI_PrologEx_C(PIF_STD_C, LogRegistryRsopData)
	BOOL bRet = FALSE;
	__try
	{
		_bstr_t bstrGPOID = wszGPOID;
		_bstr_t bstrSOMID = wszSOMID;

//    if ( !DeleteInstances( L"RSOP_RegistryPolicySetting", pWbemServices ) )
//         return FALSE;

		// Create & populate RSOP_IERegistryPolicySetting
		_bstr_t bstrClass = L"RSOP_IERegistryPolicySetting";
		ComPtr<IWbemClassObject> pRPS = NULL;
		HRESULT hr = CreateRSOPObject(bstrClass, &pRPS);
		if (SUCCEEDED(hr))
		{
			for ( DWORD i=0; i<HASH_TABLE_SIZE; i++ )
			{
				REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];
				while ( pKeyEntry )
				{
					WCHAR *pwszKeyName = pKeyEntry->pwszKeyName;
					REGVALUEENTRY *pValueEntry = pKeyEntry->pValueList;

					while ( pValueEntry )
					{
						DWORD dwOrder = 1;
						WCHAR *pwszValueName = pValueEntry->pwszValueName;
						REGDATAENTRY *pDataEntry = pValueEntry->pDataList;

						while ( pDataEntry )
						{
							// Write RSOP_PolicySetting keys out

							//------------------------------------------------
							// precedence
							OutD(LI2(TEXT("Storing property 'precedence' in %s, value = %lx"),
									(BSTR)bstrClass, m_dwPrecedence));
							hr = PutWbemInstancePropertyEx(L"precedence", (long)m_dwPrecedence, pRPS);

							//------------------------------------------------
							// id
							GUID guid;
							hr = CoCreateGuid( &guid );
							if ( FAILED(hr) ) {
								OutD(LI0(TEXT("Failed to obtain guid" )));
								return FALSE;
							}

							WCHAR wszId[MAX_LENGTH];
							StringFromGUID2(guid, wszId, sizeof(wszId));

							_bstr_t xId( wszId );
							if ( !xId ) {
								 OutD(LI0(TEXT("Failed to allocate memory" )));
								 return FALSE;
							}

							hr = PutWbemInstancePropertyEx(L"id", xId, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// currentUser
							hr = PutWbemInstancePropertyEx(L"currentUser", pKeyEntry->bHKCU ? true : false, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// deleted
							hr = PutWbemInstancePropertyEx(L"deleted", pDataEntry->bDeleted ? true : false, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// name
							_bstr_t xName( pwszValueName );
							hr = PutWbemInstancePropertyEx(L"name", xName, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// valueName
							hr = PutWbemInstancePropertyEx(L"valueName", xName, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// registryKey
							_bstr_t xKey( pwszKeyName );
							hr = PutWbemInstancePropertyEx(L"registryKey", xKey, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// GPOID
							hr = PutWbemInstancePropertyEx(L"GPOID", bstrGPOID, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// SOMID
							hr = PutWbemInstancePropertyEx(L"SOMID", bstrSOMID, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// command
							_bstr_t xCommand( pDataEntry->pwszCommand );
							hr = PutWbemInstancePropertyEx(L"command", xCommand, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// valueType
							hr = PutWbemInstancePropertyEx(L"valueType", (long)pDataEntry->dwValueType, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// value
							// Create a SAFEARRAY from our array of bstr connection names
							SAFEARRAY *psa = NULL;
							if (pDataEntry->dwDataLen > 0)
							{
								psa = CreateSafeArray(VT_UI1, pDataEntry->dwDataLen);
								if (NULL == psa)
								{
									OutD(LI0(TEXT("Failed to allocate memory" )));
									return FALSE;
								}
							}

							for (DWORD iElem = 0; iElem < pDataEntry->dwDataLen; iElem++) 
							{
								hr = SafeArrayPutElement(psa, (LONG*)&iElem, (void*)&pDataEntry->pData[iElem]);
								if ( FAILED( hr ) ) 
								{
									OutD(LI1(TEXT("Failed to SafeArrayPutElement with 0x%x" ), hr ));
									return FALSE;
								}
							}

							VARIANT var;
							var.vt = VT_ARRAY | VT_UI1;
							var.parray = psa;

							hr = PutWbemInstancePropertyEx(L"value", &var, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							OutD(LI0(TEXT("<<object>>")));
							//
							// Commit all above properties by calling PutInstance, semisynchronously
							//
							BSTR bstrObjPath = NULL;
							hr = PutWbemInstance(pRPS, bstrClass, &bstrObjPath);
							if ( FAILED(hr) )
								return FALSE;

							pDataEntry = pDataEntry->pNext;
							dwOrder++;
						}

						pValueEntry = pValueEntry->pNext;

					}   // while pValueEntry

					pKeyEntry = pKeyEntry->pNext;

				}   // while pKeyEntry

			}   // for
			bRet = TRUE;
		}

	    OutD(LI0(TEXT("LogRegistry RsopData: Successfully logged registry Rsop data" )));
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in LogRegistryRsopData.")));
	}
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

BOOL    InitializeDependancies(BOOL fInit = TRUE);

HRESULT MoveCabVersionsToHKLM(LPCTSTR pszIns);
LPCTSTR DecodeTitle(LPTSTR pszTitle, LPCTSTR pszIns);
BOOL    SHGetSetActiveDesktop(BOOL fSet, PBOOL pfValue);

#define SHGetFolderPathSimple(nFolder, pszPath) \
    (SHGetFolderPath(NULL, (nFolder), g_GetUserToken(), SHGFP_TYPE_CURRENT, (pszPath)))
HRESULT SHGetFolderLocationSimple(int nFolder, LPITEMIDLIST *ppidl);

LPCTSTR GetIEPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetWebPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetFavoritesPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetChannelsPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetSoftwareUpdatesPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetLinksPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetQuickLaunchPath(LPTSTR pszPath = NULL, UINT cch = 0);
BOOL    CreateWebFolder();

BOOL    SetFeatureBranded(UINT nID, DWORD dwFlags = FF_ENABLE);
DWORD   GetFeatureBranded(UINT nID);

BOOL    CreateCustomBrandingCabUI(BOOL fCreate = TRUE);

BOOL    SetUserFileOwner(HANDLE hUserToken, LPCTSTR pcszPath);

// download.cpp
BOOL    UpdateBrandingCab(BOOL fForceUpdate);
BOOL    UpdateDesktopCab (BOOL fForceUpdate);
HRESULT DownloadSourceFile(LPCTSTR pszURL, LPTSTR pszTargetPath, UINT cchTargetPath, BOOL fCheckTrust = TRUE);


// cmdline.cpp
static const MAPDW2PSZ g_mpFeatures[] = {
    { FID_CLEARBRANDING,         TEXT("clr")  },
    { FID_MIGRATEOLDSETTINGS,    NULL         },
    { FID_WININETSETUP,          NULL         },
    { FID_CS_DELETE,             TEXT("csd")  },
    { FID_ZONES_HKCU,            TEXT("znu")  },
    { FID_ZONES_HKLM,            NULL         },
    { FID_RATINGS,               NULL         },
    { FID_AUTHCODE,              NULL         },
    { FID_PROGRAMS,              NULL         },
    { FID_EXTREGINF_HKLM,        TEXT("erim") },
    { FID_EXTREGINF_HKCU,        TEXT("eriu") },
    { FID_LCY50_EXTREGINF,       NULL         },
    { FID_GENERAL,               TEXT("gen")  },
    { FID_CUSTOMHELPVER,         TEXT("chv")  },
    { FID_TOOLBARBUTTONS,        TEXT("tbb")  },
    { FID_ROOTCERT,              TEXT("rct")  },
    { FID_FAV_DELETE,            TEXT("favd") },
    { FID_FAV_MAIN,              TEXT("fav")  },
    { FID_FAV_ORDER,             TEXT("favo") },
    { FID_QL_MAIN,               TEXT("ql")   },
    { FID_QL_ORDER,              TEXT("qlo")  },
    { FID_CS_MAIN,               TEXT("cs")   },
    { FID_TPL,                   TEXT("tpl")  },
    { FID_CD_WELCOME,            TEXT("cdw")  },
    { FID_ACTIVESETUPSITES,      NULL         },
    { FID_LINKS_DELETE,          TEXT("lnkd") },
    { FID_OUTLOOKEXPRESS,        TEXT("oe")   },
    { FID_LCY4X_ACTIVEDESKTOP,   TEXT("ad")   },
    { FID_LCY4X_CHANNELS,        TEXT("chl")  },
    { FID_LCY4X_SOFTWAREUPDATES, TEXT("swu")  },
    { FID_LCY4X_WEBCHECK,        TEXT("wchk") },
    { FID_LCY4X_CHANNELBAR,      TEXT("chlb") },
    { FID_LCY4X_SUBSCRIPTIONS,   TEXT("sbs")  },
    { FID_REFRESHBROWSER,        TEXT("ref")  }
};

typedef struct tagCMDLINESWITCHES {
    DWORD dwContext;
    TCHAR szIns[MAX_PATH];
    TCHAR szTargetPath[MAX_PATH];
    BOOL  fPerUser;
    DWORD rgdwFlags[FID_LAST];
    BOOL  fDisable;
} CMDLINESWITCHES, *PCMDLINESWITCHES;

HRESULT GetCmdLineSwitches(PCTSTR pszCmdLine, PCMDLINESWITCHES pcls);


// Miscellaneous
BOOL BackToIE3orLower();

void Out(PCTSTR pszMsg);
void OutD(PCTSTR pszMsg);
void WINAPIV OutEx(PCTSTR pszFmt ...);

void TimerSleep(UINT nMilliSecs);
UINT GetFlagsNumber(DWORD dwFlags);

struct SInitializeDependancies {
// Constructor and Destructor
public:
    SInitializeDependancies()  { InitializeDependancies();      }
    ~SInitializeDependancies() { InitializeDependancies(FALSE); }
};

#define MACRO_InitializeDependacies() SInitializeDependancies init

// NOTE: (oliverl) must overload all references to HKEY_CURRENT_USER since when we're running as a
// GP client side extension we can't trust that HKEY_CURRENT_USER is correct since we're in the
// system context. do not allow the utils APIs that mask HKCU in this module.
#ifndef SHCreateKeyHKCU
#error  SHCreateKeyHKCU was not defined by ieakutil.h yet! Please correct.
#endif
#undef  SHCreateKeyHKCU

#ifndef SHOpenKeyHKCU
#error  SHOpenKeyHKCU was not defined by ieakutil.h yet! Please correct.
#endif
#undef  SHOpenKeyHKCU

// NOTE: (oliverl) save away real HKEY_CURRENT_USER since we need it in globals.cpp to handle non
// GP case.
#ifndef HKEY_CURRENT_USER
#error  HKEY_CURRENT_USER is somehow not defined! Please correct.
#endif
__declspec(selectany) HKEY g_hHKCU = HKEY_CURRENT_USER;
#undef HKEY_CURRENT_USER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\autorun\autorun.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#define STRICT
#define _INC_OLE
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <commctrl.h>
#include <regstr.h>
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define IE4_VERSION     44444

//---------------------------------------------------------------------------
// appwide globals
extern HINSTANCE g_hinst;
#define HINST_THISAPP g_hinst

extern BOOL g_fCrapForColor;
extern BOOL g_fPaletteDevice;

//---------------------------------------------------------------------------
// helpers.c

// just how many places is this floating around these days?
HPALETTE PaletteFromDS(HDC);

// handles SBS crap
void GetRealWindowsDirectory(char *buffer, int maxlen);

// non-exporeted code stolen from shelldll (prefixed by underscores)
BOOL _PathStripToRoot(LPSTR);


DWORD GetDataTextColor( int, LPSTR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\autorun\helpers.c ===
//---------------------------------------------------------------------------
#include "autorun.h"
#include "resource.h"

//#include "port32.h"
#define dbMSG(msg,title)    (MessageBox(NULL,msg,title,MB_OK | MB_ICONINFORMATION))

#define NORMAL 1
#define HIGHLIGHT 2

LONG WINAPI AnotherStrToLong( LPCSTR );
extern char * Res2Str(int rsString);

extern DWORD AUTORUN_8BIT_TEXTCOLOR;
extern DWORD AUTORUN_8BIT_HIGHLIGHT;

//---------------------------------------------------------------------------
LONG WINAPI StrToLong(LPCSTR sz)
{
    long l=0;
    BOOL fNeg = (*sz == '-');

    if (fNeg)
        sz++;

    while (*sz >= '0' && *sz <= '9')
        l = l*10 + (*sz++ - '0');

    if (fNeg)
        l *= -1L;

    return l;
}

//---------------------------------------------------------------------------
HPALETTE PaletteFromDS(HDC hdc)
{
    DWORD adw[257];
    int i,n;

    n = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)&adw[1]);

    for (i=1; i<=n; i++)
        adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i]));

    adw[0] = MAKELONG(0x300, n);

    return CreatePalette((LPLOGPALETTE)&adw[0]);
}
//---------------------------------------------------------------------------
void DrawBitmap ( HDC hdc, HBITMAP hBitmap, short xStart, short yStart )
{
    BITMAP  bm;
    HDC     hdcMem;
    DWORD   dwSize;
    POINT   ptSize, ptOrg;

    hdcMem = CreateCompatibleDC( hdc );
    SelectObject( hdcMem, hBitmap );
    SetMapMode( hdcMem, GetMapMode( hdc ));
    GetObject( hBitmap, sizeof(BITMAP), (LPSTR) &bm);
    ptSize.x = bm.bmWidth;
    ptSize.y = bm.bmHeight;
    DPtoLP( hdc, &ptSize, 1 );

    ptOrg.x = 0;
    ptOrg.y = 0;
    DPtoLP( hdcMem, &ptOrg, 1);

    BitBlt( hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem,
        ptOrg.x, ptOrg.y, SRCCOPY );

    DeleteDC( hdcMem );
}
//---------------------------------------------------------------------------
#pragma data_seg(".text")
static const char szRegStr_Setup[] = REGSTR_PATH_SETUP "\\Setup";
static const char szSharedDir[] = "SharedDir";
#pragma data_seg()

void GetRealWindowsDirectory(char *buffer, int maxlen)
{
    static char szRealWinDir[MAX_PATH] = "";

    if (!*szRealWinDir)
    {
        HKEY key = NULL;

        if(RegOpenKey(HKEY_LOCAL_MACHINE, szRegStr_Setup, &key) ==
            ERROR_SUCCESS)
        {
            LONG len = sizeof(szRealWinDir) / sizeof(szRealWinDir[0]);

            if( RegQueryValueEx(key, szSharedDir, NULL, NULL,
                (LPBYTE)szRealWinDir, &len) != ERROR_SUCCESS)
            {
                *szRealWinDir = '\0';
            }

            RegCloseKey(key);
        }

        if (!*szRealWinDir)
            GetWindowsDirectory(szRealWinDir, MAX_PATH);
    }

    if (maxlen > MAX_PATH)
        maxlen = MAX_PATH;

    lstrcpyn(buffer, szRealWinDir, maxlen);
}

//---------------------------------------------------------------------------
#define DBL_BSLASH(sz) (*(WORD *)(sz) == 0x5C5C)    // '\\'
#pragma data_seg(".text")
static const char c_szColonSlash[] = ":\\";
#pragma data_seg()

//---------------------------------------------------------------------------
BOOL _ChrCmp(WORD w1, WORD wMatch)
{
  /* Most of the time this won't match, so test it first for speed.
   */
  if (LOBYTE(w1) == LOBYTE(wMatch))
    {
      if (IsDBCSLeadByte(LOBYTE(w1)))
        {
          return(w1 != wMatch);
        }
      return FALSE;
    }
  return TRUE;
}

//---------------------------------------------------------------------------
LPSTR _StrChr(LPCSTR lpStart, WORD wMatch)
{
  for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
      if (!_ChrCmp(*(WORD FAR *)lpStart, wMatch))
          return((LPSTR)lpStart);
    }
  return (NULL);
}

//---------------------------------------------------------------------------
LPSTR _StrRChr(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
  LPCSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlen(lpStart);

  for ( ; lpStart < lpEnd; lpStart = AnsiNext(lpStart))
    {
      if (!_ChrCmp(*(WORD FAR *)lpStart, wMatch))
          lpFound = lpStart;
    }
  return ((LPSTR)lpFound);
}

//---------------------------------------------------------------------------
BOOL _PathIsRelative(LPCSTR lpszPath)
{
    // The NULL path is assumed relative
    if (*lpszPath == 0)
        return TRUE;

    // Does it begin with a slash ?
    if (lpszPath[0] == '\\')
        return FALSE;
    // Does it begin with a drive and a colon ?
    else if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == ':')
        return FALSE;
    // Probably relative.
    else
        return TRUE;
}

//---------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = AnsiNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;        // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}

//---------------------------------------------------------------------------
BOOL _PathIsRoot(LPCSTR pPath)
{
    if (!IsDBCSLeadByte(*pPath))
    {
        if (!lstrcmpi(pPath + 1, c_szColonSlash))                  // "X:\" case
            return TRUE;
    }

    if ((*pPath == '\\') && (*(pPath + 1) == 0))        // "\" case
        return TRUE;

    if (DBL_BSLASH(pPath))      // smells like UNC name
    {
        LPCSTR p;
        int cBackslashes = 0;

        for (p = pPath + 2; *p; p = AnsiNext(p)) {
            if (*p == '\\' && (++cBackslashes > 1))
               return FALSE;   /* not a bare UNC name, therefore not a root dir */
        }
        return TRUE;    /* end of string with only 1 more backslash */
                        /* must be a bare UNC, which looks like a root dir */
    }
    return FALSE;
}

//---------------------------------------------------------------------------
BOOL _PathStripToRoot(LPSTR szRoot)
{
    while(!_PathIsRoot(szRoot))
    {
        if (!_PathRemoveFileSpec(szRoot))
        {
            // If we didn't strip anything off,
            // must be current drive
            return(FALSE);
        }
    }

    return(TRUE);
}

//--------------------------------------------------------------------------
BOOL _PathIsUNC(LPCSTR pszPath)
{
    return DBL_BSLASH(pszPath);
}

//--------------------------------------------------------------------------
LPCSTR _GetPCEnd(LPCSTR lpszStart)
{
        LPCSTR lpszEnd;

        lpszEnd = _StrChr(lpszStart, '\\');
        if (!lpszEnd)
        {
                lpszEnd = lpszStart + lstrlen(lpszStart);
        }

        return lpszEnd;
}
//--------------------------------------------------------------------------
LPCSTR _PCStart(LPCSTR lpszStart, LPCSTR lpszEnd)
{
        LPCSTR lpszBegin = _StrRChr(lpszStart, lpszEnd, '\\');
        if (!lpszBegin)
        {
                lpszBegin = lpszStart;
        }
        return lpszBegin;
}

//--------------------------------------------------------------------------
// Fix up a few special cases so that things roughly make sense.
void _NearRootFixups(LPSTR lpszPath, BOOL fUNC)
{
    // Check for empty path.
    if (lpszPath[0] == '\0')
        {
        // Fix up.
        lpszPath[0] = '\\';
        lpszPath[1] = '\0';
        }
    // Check for missing slash.
    if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == ':' && lpszPath[2] == '\0')
        {
        // Fix up.
        lpszPath[2] = '\\';
        lpszPath[3] = '\0';
        }
    // Check for UNC root.
    if (fUNC && lpszPath[0] == '\\' && lpszPath[1] == '\0')
        {
        // Fix up.
        lpszPath[0] = '\\';
        lpszPath[1] = '\\';
        lpszPath[2] = '\0';
        }
}

//---------------------------------------------------------------------------
BOOL _PathCanonicalize(LPSTR lpszDst, LPCSTR lpszSrc)
{
    LPCSTR lpchSrc;
    LPCSTR lpchPCEnd;           // Pointer to end of path component.
    LPSTR lpchDst;
    BOOL fUNC;
    int cbPC;

    fUNC = _PathIsUNC(lpszSrc);    // Check for UNCness.

    // Init.
    lpchSrc = lpszSrc;
    lpchDst = lpszDst;

    while (*lpchSrc)
        {
        // REVIEW: this should just return the count
        lpchPCEnd = _GetPCEnd(lpchSrc);
        cbPC = (int)(lpchPCEnd - lpchSrc) + 1;

        // Check for slashes.
        if (cbPC == 1 && *lpchSrc == '\\')
            {
            // Just copy them.
            *lpchDst = '\\';
            lpchDst++;
            lpchSrc++;
            }
        // Check for dots.
        else if (cbPC == 2 && *lpchSrc == '.')
            {
            // Skip it...
            // Are we at the end?
            if (*(lpchSrc+1) == '\0')
                {
                lpchDst--;
                lpchSrc++;
                }
            else
                lpchSrc += 2;
            }
        // Check for dot dot.
        else if (cbPC == 3 && *lpchSrc == '.' && *(lpchSrc + 1) == '.')
            {
            // make sure we aren't already at the root
            if (!_PathIsRoot(lpszDst))
                {
                // Go up... Remove the previous path component.
                lpchDst = (LPSTR)_PCStart(lpszDst, lpchDst - 1);
                }
            else
                {
                // When we can't back up, remove the trailing backslash
                // so we don't copy one again. (C:\..\FOO would otherwise
                // turn into C:\\FOO).
                if (*(lpchSrc + 2) == '\\')
                    {
                    lpchSrc++;
                    }
                }
            lpchSrc += 2;       // skip ".."
            }
        // Everything else
        else
            {
            // Just copy it.
            lstrcpyn(lpchDst, lpchSrc, cbPC);
            lpchDst += cbPC - 1;
            lpchSrc += cbPC - 1;
            }
        // Keep everything nice and tidy.
        *lpchDst = '\0';
        }

    // Check for weirdo root directory stuff.
    _NearRootFixups(lpszDst, fUNC);

    return TRUE;
}

//---------------------------------------------------------------------------
LPSTR _PathAddBackslash(LPSTR lpszPath)
{
    LPSTR lpszEnd;

    int ichPath = lstrlen(lpszPath);
    if (ichPath >= (MAX_PATH - 1))
        return(NULL);

    lpszEnd = lpszPath + ichPath;

    // this is really an error, caller shouldn't pass
    // an empty string
    if (!*lpszPath)
        return lpszEnd;

    /* Get the end of the source directory
    */
    switch(*AnsiPrev(lpszPath, lpszEnd)) {
    case '\\':
        break;

    default:
        *lpszEnd++ = '\\';
        *lpszEnd = '\0';
    }
    return lpszEnd;
}

//---------------------------------------------------------------------------
LPSTR _PathCombine(LPSTR lpszDest, LPCSTR lpszDir, LPCSTR lpszFile)
{
    char szTemp[MAX_PATH];
    LPSTR pszT;

    if (!lpszFile || *lpszFile=='\0') {

        lstrcpyn(szTemp, lpszDir, sizeof(szTemp));       // lpszFile is empty

    } else if (lpszDir && *lpszDir && _PathIsRelative(lpszFile)) {

        lstrcpyn(szTemp, lpszDir, sizeof(szTemp));
        pszT = _PathAddBackslash(szTemp);
        if (pszT) {
            int iLen = lstrlen(szTemp);
            if ((iLen + lstrlen(lpszFile)) < sizeof(szTemp)) {
                lstrcpy(pszT, lpszFile);
            } else
                return NULL;
        } else
            return NULL;

    } else if (lpszDir && *lpszDir &&
        *lpszFile == '\\' && !_PathIsUNC(lpszFile)) {

        lstrcpyn(szTemp, lpszDir, sizeof(szTemp));
        // BUGBUG: Note that we do not check that an actual root is returned;
        // it is assumed that we are given valid parameters
        _PathStripToRoot(szTemp);

        pszT = _PathAddBackslash(szTemp);
        if (pszT)
        {
            // Skip the backslash when copying
            lstrcpyn(pszT, lpszFile+1, (int)(sizeof(szTemp) - 1 - (size_t)(pszT-szTemp)));
        } else
            return NULL;

    } else {

        lstrcpyn(szTemp, lpszFile, sizeof(szTemp));     // already fully qualified file part

    }

    _PathCanonicalize(lpszDest, szTemp);    // this deals with .. and . stuff

    return lpszDest;
}

//---------------------------------------------------------------------------
BOOL PathAppend(LPSTR pPath, LPCSTR pMore)
{

    /* Skip any initial terminators on input. */
    while (*pMore == '\\')
        pMore = AnsiNext(pMore);

    return (_PathCombine(pPath, pPath, pMore) != NULL) ? TRUE : FALSE;
}
//---------------------------------------------------------------------------
void CreateURLPath( LPSTR lpPath )  //create a directory from a URL name
{
    char szTmpPath[MAX_PATH];

    lstrcpy( szTmpPath, lpPath );
    _PathRemoveFileSpec( szTmpPath );

    CreateDirectory( szTmpPath, NULL );

}
//---------------------------------------------------------------------------
void CreateURL( LPSTR szCurrentDir )
{
    char szBuffer[80 * 80] = {0};
    char szDestPath[MAX_PATH];
    char szFavPath[MAX_PATH] = {0};
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];
    char szFileBuffer[1024] = {0};
    char *lpString;
    LONG lError = 0;
    DWORD dwType = 0;
    DWORD dwLength = MAX_PATH;
    BOOL fFile = FALSE;
    HANDLE hFile;
    HKEY hkFav;
    DWORD dwWriteLen = 0;
    int i = 0;

    lstrcpy( szTmpPath, szCurrentDir );
    lstrcat( szTmpPath, "\\iecd.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "fav.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    GetPrivateProfileSection( "Favorites", szBuffer, sizeof( szBuffer ), szIniPath);

    // pull favorites path out of the registry
    RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", 0, KEY_ALL_ACCESS, &hkFav );
    lError = RegQueryValueEx( hkFav, "Favorites", NULL, &dwType, szFavPath, &dwLength );
    //if no favorites directory exists, create one.
    if( lError != ERROR_SUCCESS )
    {
        GetPrivateProfileString( "Directory", "Dir", "Favorites", szTmpPath, sizeof( szTmpPath ), szIniPath );
        GetWindowsDirectory( szFavPath, MAX_PATH );
        lstrcat( szFavPath, "\\" );
        lstrcat( szFavPath, szTmpPath );
        if(!CreateDirectory( szFavPath, NULL ))
        {
            DeleteFile( szIniPath );
            RegCloseKey( hkFav );
            goto fail_gracefully;
        }
        RegSetValueEx( hkFav, "Favorites", 0, REG_SZ, szFavPath, strlen( szFavPath ) + 1);
    }

    DeleteFile( szIniPath );

    for( i = 0; i < sizeof(szBuffer); i++ )
    {
        if( szBuffer[i] == '=' )
            szBuffer[i] = (char)NULL;
    }

    lstrcat( szFavPath, "\\" );
    lstrcpy( szDestPath, szFavPath );
    RegCloseKey( hkFav );

    lstrcpyn( szDestPath + lstrlen(szDestPath), szBuffer, sizeof(szDestPath) - lstrlen(szDestPath) );
    CreateURLPath( szDestPath );
    hFile = CreateFile( szDestPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL );
    if (hFile == INVALID_HANDLE_VALUE)
        goto fail_gracefully;
    lstrcpy( szDestPath, szFavPath );

    for( i = 0; i < sizeof(szBuffer); i++ )
    {
        if( szBuffer[i] == (char)NULL )
        {
            if( szBuffer[i + 1] == (char)NULL ) break;
            lpString = &szBuffer[i] + 1;
            if( fFile )
            {
                lstrcpyn( szDestPath + lstrlen(szDestPath), lpString, sizeof(szDestPath) - lstrlen(szDestPath) );
                CreateURLPath( szDestPath );
                hFile = CreateFile( szDestPath, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                    FILE_ATTRIBUTE_NORMAL, NULL );
                lstrcpy( szDestPath, szFavPath );
            }
            else
            {
                lstrcpy( szFileBuffer, "[InternetShortcut]\nURL=");
                lstrcpyn( szFileBuffer + lstrlen(szFileBuffer), lpString, sizeof(szFileBuffer) - lstrlen(szFileBuffer) );
                WriteFile( hFile, szFileBuffer, strlen( szFileBuffer ),
                    &dwWriteLen, NULL );
                CloseHandle( hFile );
            }
            fFile = !fFile;
        }
    }

fail_gracefully:
    ;
}
//---------------------------------------------------------------------------
void VirusWarning( BOOL fWarning )
{
    HKEY hkVW;
    DWORD dwFlags;

    if( fWarning )
    {
        dwFlags = 0x000007d8;
    }
    else
    {
        dwFlags = 0x000107d0;
    }

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\classes\\exefile", 0, KEY_ALL_ACCESS, &hkVW ) == ERROR_SUCCESS)
    {
        RegSetValueEx( hkVW, "EditFlags", 0, REG_BINARY,(char *) &dwFlags, 4);
        RegCloseKey( hkVW );
    }
}
//---------------------------------------------------------------------------
BOOL IEExists( )
{
    HKEY hkAppPaths;
    LONG lError;
    DWORD dwType;
    DWORD dwLength = MAX_PATH;
    DWORD dwError;
    char szPath[MAX_PATH];

    lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE", 0, KEY_ALL_ACCESS, &hkAppPaths );
    if( lError != ERROR_SUCCESS ) return FALSE;
    RegQueryValueEx( hkAppPaths, "", NULL, &dwType, szPath, &dwLength );
    RegCloseKey( hkAppPaths );

    dwError = GetFileAttributes( szPath );
    if( dwError == 0xFFFFFFFF )
    {
        return FALSE;
    }

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL IEFutureBuild( )
{
    HKEY hkAppPaths;
    LONG lBuild;
    DWORD dwType;
    DWORD dwLength = 10;
    DWORD dwError;
    char szBuild[10];

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Explorer", 0, KEY_ALL_ACCESS, &hkAppPaths ) == ERROR_SUCCESS)
    {
        RegQueryValueEx( hkAppPaths, "Build", NULL, &dwType, szBuild, &dwLength );
        RegCloseKey( hkAppPaths );
    
        lBuild = StrToLong( szBuild );

        if( lBuild > IE4_VERSION ) return TRUE;
    }

    return FALSE;
}
//---------------------------------------------------------------------------
BOOL GetDataAppTitle( LPSTR szAppTitle, LPSTR szCurrentDir )
{
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];

    lstrcpy( szTmpPath, szCurrentDir );
    lstrcat( szTmpPath, "\\iecd.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "iecd.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    GetPrivateProfileString( "Custom", "Title", "Microsoft Internet Explorer CD", szTmpPath, sizeof( szTmpPath ), szIniPath );

    lstrcpy( szAppTitle, szTmpPath );

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL GetDataPages( LPSTR szStartPage, LPSTR szSearchPage, LPSTR szCurrentDir )
{
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];

    lstrcpy( szTmpPath, szCurrentDir );
    lstrcat( szTmpPath, "\\iecd.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "iecd.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    GetPrivateProfileString( "Custom", "Start", (char *)Res2Str( IDS_STARTPAGE ), szTmpPath, sizeof( szTmpPath ), szIniPath );
    lstrcpy( szStartPage, szTmpPath );
    GetPrivateProfileString( "Custom", "Search", (char *)Res2Str( IDS_SEARCHPAGE ), szTmpPath, sizeof( szTmpPath ), szIniPath );
    lstrcpy( szSearchPage, szTmpPath );

    return TRUE;
}
//---------------------------------------------------------------------------
DWORD GetDataTextColor( int nColor, LPSTR szCurrentDir )
{
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];
    char szColor[32];
    DWORD dwColor;

    lstrcpy( szTmpPath, szCurrentDir );
    lstrcat( szTmpPath, "\\iecd.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "iecd.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    if ( nColor == HIGHLIGHT )
    {
        char szDefault[MAX_PATH];

        wsprintf(szDefault, "%d", AUTORUN_8BIT_HIGHLIGHT);
        GetPrivateProfileString( "Custom", "HighlightColor", szDefault, szColor,
            32, szIniPath );
    }
    if ( nColor == NORMAL )
    {
        char szDefault[MAX_PATH];

        wsprintf(szDefault, "%d", AUTORUN_8BIT_TEXTCOLOR);
        GetPrivateProfileString( "Custom", "NormalColor", szDefault, szColor,
            32, szIniPath );
    }

    dwColor = AnotherStrToLong( szColor );
    if ( dwColor == -1 )
    {
        if ( nColor == NORMAL ) return (DWORD) AUTORUN_8BIT_TEXTCOLOR;
        if ( nColor == HIGHLIGHT ) return (DWORD) AUTORUN_8BIT_HIGHLIGHT;
    }

    return dwColor;
}
//---------------------------------------------------------------------------
BOOL GetDataButtons( LPSTR szCurrentDir )
{
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];

    lstrcpy( szTmpPath, szCurrentDir );
    lstrcat( szTmpPath, "\\iecd.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "iecd.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    GetPrivateProfileString( "Custom", "CoolButtons", "1", szTmpPath, sizeof( szTmpPath ), szIniPath );
    if( szTmpPath[0] == '1' )
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\autorun\autorun.c ===
//---------------------------------------------------------------------------
// Internet Explorer 2.0 Demo CD-ROM autorun application
// for questions, contact a-nathk
// MICROSOFT CONFIDENTIAL
//---------------------------------------------------------------------------
#include "autorun.h"
#include "resource.h"
#include <mmsystem.h>
#include <regstr.h>
#include <shlobj.h>
#include <stdio.h>

#define ISK_KILLSETUPHANDLE     WM_USER + 0x0010

#define DEMO    0
#define EXTRAS  1
#define README  2

//---------------------------------------------------------------------------
// appwide globals
HINSTANCE g_hinst = NULL;
HWND    g_hwnd;
BOOL    g_bCustomBMP;
BOOL    g_fCrapForColor = FALSE;
BOOL    g_fNeedPalette = FALSE;
BOOL    g_fMouseAvailable = FALSE;
BOOL    g_fSetup = FALSE;
BOOL    g_fClosed = FALSE;
BOOL    g_fIeRunning = FALSE;
BOOL    g_fRunDemo = FALSE;
BOOL    g_fRunExtras = FALSE;
BOOL    g_fRunReadme = FALSE;
BOOL    g_fSetupRunning = FALSE;
BOOL    g_fIEInstalled = TRUE;
BOOL    g_fChangeIcon = FALSE;
BOOL    g_fNewIEIcon = FALSE;
BOOL    g_fIeOnHardDisk = FALSE;
char    g_szTemp[2048] = {0};
char    g_szTemp2[2048] = {0};
char    g_szCurrentDir[MAX_PATH];
char    g_szTheInternetPath[MAX_PATH];
BYTE    g_abValue[2048];
BYTE    g_abValue2[2048];
DWORD   g_dwLength = 2048;
DWORD   g_dwLength2 = 2048;
DWORD   g_dwType;
DWORD   g_dwBitmapHeight;
DWORD   g_dwBitmapWidth;
DWORD   g_dwWindowHeight;
DWORD   g_dwWindowWidth;
HKEY    g_hkRegKey;
HANDLE  g_hIE = NULL;
HANDLE  g_hSETUP = NULL;
HANDLE  g_hIEExtra = NULL;
HANDLE  g_hREADME = NULL;
DWORD   g_cWait = 0;
HANDLE  g_ahWait[100];
BOOL    g_fClicked = FALSE;

//FARPROC g_pfnWake[10];
void UpdateIE( );
void AutoRunUpdateReg( );
extern BOOL GetDataButtons( LPSTR szCurrentDir );
extern BOOL PathAppend(LPSTR pPath, LPCSTR pMore);
extern BOOL _PathRemoveFileSpec(LPSTR pFile);
extern BOOL GetDataAppTitle( LPSTR szAppTitle, LPSTR szCurrentDir );

//---------------------------------------------------------------------------
// file globals
BOOL    g_fAppDisabled = TRUE;
HHOOK   g_hMouseHook = NULL;
HWND    g_hMainWindow = NULL;   // less of a pain for our mouse hook to see
int     g_iActiveButton = -2;   // less of a pain for our mouse hook to see

const RGBQUAD g_rgbBlack = {0};
const RGBQUAD g_rgbWhite = {0xFF, 0xFF, 0xFF, 0};

#pragma data_seg(".text")
static const char c_szAutoRunPrevention[] = "__Win95SetupDiskQuery";
static const char c_szAutoRunClass[] = "AutoRunMain";
static const char c_szNULL[] = "";
static const char c_szArial[] = "Arial";
static const char c_szButtonClass[] = "Button";
static const char c_szSetupKey[] = REGSTR_PATH_SETUP "\\SETUP";
static const char c_szExpoSwitch[] = "Expostrt";
#pragma data_seg()

//---------------------------------------------------------------------------
// private messages
#define ARM_MOUSEOVER       (WM_APP)

//---------------------------------------------------------------------------
// states for tracking mouse over buttons
#define BTNST_DEAD          (0)
#define BTNST_UP            (1)
#define BTNST_DOWN          (2)
#define BTNST_UNDOWN        (3)

//---------------------------------------------------------------------------
// how to root a relative path (if at all)
#define NOROOT      (0x00000000)
#define ONACD       (0x00000001)
#define INWIN       (0x00000002)
#define INSYS       (0x00000003)
#define INTMP       (0x00000004)
#define ALLROOTS  (0x00000003)

#define ROOTED(app,parms,dir) \
                            ((((DWORD)app)<<6)|(((DWORD)parms)<<3)|(DWORD)dir)

#define CMD_ROOT(item)      ((((DWORD)item)>>6)&ALLROOTS)
#define PARAMS_ROOT(item)   ((((DWORD)item)>>3)&ALLROOTS)
#define DEFDIR_ROOT(item)    (((DWORD)item)&ALLROOTS)

#define dbMSG(msg,title)    (MessageBox(NULL,msg,title,MB_OK | MB_ICONINFORMATION))

#define REGLEN(str)         (strlen(str) + 1)

// button x and y coords.  Default is 59x59

DWORD BUTTON_IMAGE_X_SIZE =     59;
DWORD BUTTON_IMAGE_Y_SIZE =     59;

#define NORMAL_IMAGE_X_OFFSET       (0)
#define FOCUS_IMAGE_X_OFFSET        (BUTTON_IMAGE_X_SIZE)
#define SELECTED_IMAGE_X_OFFSET     (2 * BUTTON_IMAGE_X_SIZE)
#define DISABLED_IMAGE_X_OFFSET     (3 * BUTTON_IMAGE_X_SIZE)

#define BUTTON_DEFAULT_CX           (BUTTON_IMAGE_X_SIZE)
#define BUTTON_DEFAULT_CY           (BUTTON_IMAGE_Y_SIZE)

//#define BUTTON_LABEL_RECT           { -160, 17, -20, 66 }
#define BUTTON_LABEL_RECT           { -160, 15, -10, 100 }
#define BUTTON_LABEL_RECT2           { -160, 18, -10, 90 }

#define DEF_BUTTON_LABEL_HEIGHT         (19)

#define AUTORUN_DESCRIPTION_LEFT    (36)
//#define AUTORUN_DESCRIPTION_TOP     (313)
#define AUTORUN_DESCRIPTION_RIGHT   (360)

DWORD AUTORUN_DESCRIPTION_TOP = 30;
//DWORD AUTORUN_DESCRIPTION_TOP = 313;

#define MIN_WINDOW_WIDTH            500
#define MIN_WINDOW_HEIGHT           300
#define MAX_WINDOW_WIDTH            600
#define MAX_WINDOW_HEIGHT           440
#define DEFAULT_WINDOW_WIDTH        600
#define DEFAULT_WINDOW_HEIGHT       420

//#define AUTORUN_4BIT_TEXTCOLOR             RGB(192,192,192)
//#define AUTORUN_4BIT_HIGHLIGHT             RGB(255,255,255)
//#define AUTORUN_4BIT_DISABLED              RGB(127,127,127)
//#define AUTORUN_4BIT_DESCRIPTION           RGB(192,192,192)


// main text box
#define MAINTEXT_TOPMARGIN      268
#define MAINTEXT_LEFTMARGIN     25
#define MAINTEXT_RIGHTMARGIN    25
#define MAINTEXT_BOTTOMMARGIN   10
//#define MAINTEXT_TOPMARGIN      10
//#define MAINTEXT_LEFTMARGIN     100
//#define MAINTEXT_RIGHTMARGIN    10

/*DWORD AUTORUN_4BIT_TEXTCOLOR = RGB(000,000,000);
DWORD AUTORUN_4BIT_HIGHLIGHT = RGB(000,000,127);
DWORD AUTORUN_4BIT_DISABLED = RGB(000,000,000);
DWORD AUTORUN_4BIT_DESCRIPTION = RGB(000,000,000);
*/
DWORD AUTORUN_4BIT_TEXTCOLOR = RGB(97,137,192);
DWORD AUTORUN_4BIT_HIGHLIGHT = RGB(255,255,255);
DWORD AUTORUN_4BIT_DISABLED = RGB(127,127,127);
DWORD AUTORUN_4BIT_DESCRIPTION = RGB(97,137,192);

//DWORD AUTORUN_8BIT_TEXTCOLOR = RGB(000,000,127);
DWORD AUTORUN_8BIT_TEXTCOLOR = PALETTERGB(97,137,192);
DWORD AUTORUN_8BIT_HIGHLIGHT = PALETTERGB(255,255,255);
DWORD AUTORUN_8BIT_DISABLED = PALETTERGB(127,127,127);
DWORD AUTORUN_8BIT_DESCRIPTION = PALETTERGB(97,137,192);

#define NORMAL 1
#define HIGHLIGHT 2

//#define AUTORUN_4BIT_TEXTCOLOR             RGB(000,000,000)
//#define AUTORUN_4BIT_HIGHLIGHT             RGB(000,000,127)
//#define AUTORUN_4BIT_DISABLED              RGB(107,136,185)
//#define AUTORUN_4BIT_DESCRIPTION           RGB(000,000,127)

//#define AUTORUN_8BIT_TEXTCOLOR      PALETTERGB( 75, 90,129)
//#define AUTORUN_8BIT_HIGHLIGHT             RGB(000,000,000)
//#define AUTORUN_8BIT_DISABLED       PALETTERGB(107,136,185)
//#define AUTORUN_8BIT_DESCRIPTION           RGB(000,000,000)

// button placements.  Default, x=519, y=40
DWORD BUTTON_X_PLACEMENT =  519;
DWORD BUTTON_Y_MARGIN =     0;

//#define BUTTON_Y_MARGIN             (40)

//#define BUTTON_X_PLACEMENT          (519)  x placement = window right - 80
//#define BUTTON_Y_MARGIN             (9)

//#define SHADOW_FACTOR               (930)

#define SHADOW_FACTOR       (0)

#define BUTTON_CLEAR_PALETTE_INDEX  (250)
#define BUTTON_SHADOW_PALETTE_INDEX (251)

#define LABEL_VERIFY_TIMER          (0)

#define MBERROR_INFO                (MB_OKCANCEL | MB_ICONINFORMATION)

//---------------------------------------------------------------------------
typedef struct
{
    int res;            // base for all resources this button owns

    DWORD rooting;      // packed info on how to root paths for the command

    int xpos, ypos;     // location of button in window
    RECT face;          // client coordinates of actual button image on video
    RECT textrect;      // parent coordinates of accompanying label text

    BOOL abdicated;     // did we just release the capture?
    int state;          // what are we doing?

    HWND window;        // handle of button control
    WNDPROC oldproc;    // original window procedure
    BOOL isdorky;       // is this a dorky icon button?

    char text[64];          // the label for the button
    char description[256];  // the description of the button's function

} AUTORUNBTN;

//---------------------------------------------------------------------------
AUTORUNBTN g_ButtonInfo[] =
{
    { IESETUP,    ROOTED(ONACD,  NOROOT, ONACD), 0, 0, 0, 0, 59, 59, 0, 0, 0, 0, FALSE, 0, NULL, NULL, FALSE, 0 },
    { IEFROMCD,   ROOTED(ONACD,  NOROOT, ONACD), 0, 0, 0, 0, 59, 59, 0, 0, 0, 0, FALSE, 0, NULL, NULL, FALSE, 0 }
};
#define IDAB_IEFROMCD   1
#define IDAB_IESETUP    0
#define AUTORUN_NUM_BUTTONS (sizeof(g_ButtonInfo)/sizeof(g_ButtonInfo[0]))

//---------------------------------------------------------------------------
typedef struct
{
    HWND window;        // main app window

    HDC image;          // source dc with our cool backdrop
    HBITMAP oldbmp;     // the default bitmap from the dc above
    HDC btnimage;       // source dc with our cool buttons
    HBITMAP oldbtnbmp;  // the default bitmap from the dc above
    HPALETTE palette;   // our app's palette (if any)

    HFONT textfont;     // font for labels
    RECT descrect;      // client coordinates of description text
    int wndheight;      // height of client area

    COLORREF clrnormal;      // normal text color
    COLORREF clrhigh;        // highlighted text color
    COLORREF clrdisable;     // disabled text color
    COLORREF clrdescription; // disabled text color

    BOOL keyboard;      // whether the app is under keyboard control

} AUTORUNDATA;


/////////////////////////////////////////////////////////////////////////////
// randomness
/////////////////////////////////////////////////////////////////////////////
LONG WINAPI AnotherStrToLong(LPCSTR sz)
{
    long l=0;
    BOOL fNeg = (*sz == '-');

    if (fNeg)
        sz++;

    while (*sz >= '0' && *sz <= '9')
        l = l*10 + (*sz++ - '0');

    if (fNeg)
        l *= -1L;

    return l;
}

//---------------------------------------------------------------------------
//      G E T  I E  V E R S I O N
//
//  ISK3
//  This will pull build information out of the system registry and return
//  true if it is less than IE4.
//---------------------------------------------------------------------------
int GetIEVersion( )
{
    HKEY hkIE;
    DWORD dwType;
    DWORD dwSize = 32;
    DWORD result;
    char szData[32];
	BOOL bNotIE4 = 1;

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Explorer", 0, KEY_READ|KEY_WRITE, &hkIE ) == ERROR_SUCCESS)
    {
        result = RegQueryValueEx( hkIE, "Version", NULL, &dwType, szData, &dwSize );
        if( result == ERROR_SUCCESS )
	    {
		    if(szData[0]=='4')
		    {
			    bNotIE4=0;
		    }
	    }
    
	    RegCloseKey( hkIE );
    }
    
	return bNotIE4;
}

//---------------------------------------------------------------------------
// Convert a string resource into a character pointer
// NOTE: Flag is in case we call this twice before we use the data
char * Res2Str(int rsString)
{
    static BOOL fSet = FALSE;

    if(fSet)
    {
        LoadString(HINST_THISAPP, rsString, g_szTemp, ARRAYSIZE(g_szTemp));
        fSet = FALSE;
        return(g_szTemp);
    }

    LoadString(HINST_THISAPP, rsString, g_szTemp2, ARRAYSIZE(g_szTemp2));
    fSet = TRUE;
    return(g_szTemp2);
}

//---------------------------------------------------------------------------
BOOL PathFileExists(LPCSTR lpszPath)
{
        return GetFileAttributes(lpszPath) !=-1;
}

//---------------------------------------------------------------------------
//      G E T  I E  P A T H
//
//  ISK3
//  This will retrieve the AppPath for IEXPLORE.EXE from the system registry
//  and return it as a string.
//
//  Parameters:
//      pszString - pointer to buffer to store path
//      nSize     - size of buffer
//---------------------------------------------------------------------------
char *GetIEPath( LPSTR pszString, int nSize )
{
    HKEY hkAppPath;
    DWORD dwType = REG_SZ;
    DWORD dwSize;

    dwSize = nSize;
    RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE",
        0, KEY_READ|KEY_WRITE, &hkAppPath );
    RegQueryValueEx( hkAppPath, "", NULL, &dwType, pszString, &dwSize );
    RegCloseKey( hkAppPath );

    return pszString;
}
//---------------------------------------------------------------------------
//      S E T  I E  H O M E
//
//  ISK3
//  This will set the Start and Search pages in the Registry for Internet
//  Explorer.
//
//  Parameters:
//      pszStart  - pointer to Start Page string
//      pszSearch - pointer to Search Page string
//---------------------------------------------------------------------------
void SetIEHome( LPSTR pszStart, LPSTR pszSearch )
{
    char szExtrasPath[MAX_PATH];
    char szHomePath[MAX_PATH];
    HKEY IEKey;

    lstrcpy( szExtrasPath, "file:" );
    lstrcat( szExtrasPath, g_szCurrentDir );
    lstrcat( szExtrasPath, pszStart );
	//Home CD Page
    lstrcpy( szHomePath, "file:" );
    lstrcat( szHomePath, g_szCurrentDir );
    lstrcat( szHomePath, pszSearch );

    if (RegOpenKeyEx(HKEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Internet Explorer\\Main",0,KEY_QUERY_VALUE, &IEKey) == ERROR_SUCCESS)
    {
        RegSetValueEx(IEKey, "Start Page", 0, REG_SZ, szExtrasPath , REGLEN(szExtrasPath));
        RegSetValueEx(IEKey, "Search Page", 0, REG_SZ, szHomePath, REGLEN(szHomePath));
        RegCloseKey( IEKey );
    }
}

/////////////////////////////////////////////////////////////////////////////
// main crap
/////////////////////////////////////////////////////////////////////////////
BOOL AssembleButtonImagesReal(AUTORUNDATA *data, HDC cellimage, HDC srcimage,
    SIZE size)
{
    RGBQUAD rgbSrc[256], rgbCell[256], rgbMask[256] = {0};
    HBITMAP dstbmp = CreateCompatibleBitmap(data->image, size.cx, size.cy);
    UINT uColors, uSrcColors, u;
    int iButton;

    //
    // set up the destination dc
    //
    if (!dstbmp)
        return FALSE;

    if ((data->btnimage = CreateCompatibleDC(data->image)) == NULL)
    {
        DeleteBitmap(dstbmp);
        return FALSE;
    }

    data->oldbtnbmp = SelectBitmap(data->btnimage, dstbmp);

    //
    // build a tile of the cell backgrounds based on button positions
    //
    for (iButton = 0; iButton < AUTORUN_NUM_BUTTONS; iButton++)
    {
        AUTORUNBTN *pButton = g_ButtonInfo + iButton;

        if (pButton->res != -1)
        {
            int xsrc = pButton->xpos;
            int ysrc = pButton->ypos;
            int xdst, ydst = iButton * BUTTON_IMAGE_Y_SIZE;

            for (xdst = 0; xdst < size.cx; xdst += BUTTON_IMAGE_X_SIZE)
            {
                BitBlt(cellimage, xdst, ydst, BUTTON_IMAGE_X_SIZE,
                    BUTTON_IMAGE_Y_SIZE, data->image, xsrc, ysrc,
                    SRCCOPY);
            }
        }
    }

    //
    // copy the entire cell backgrounds to the destination image
    //
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, cellimage, 0, 0, SRCCOPY);

    //
    // save the color table of the source image for posterity
    //
    uSrcColors = GetDIBColorTable(srcimage, 0, 256, rgbSrc);

    //
    // mask out holes on the destination for the buttons and shadows
    //
//    rgbMask[0] = g_rgbWhite;
    rgbMask[BUTTON_CLEAR_PALETTE_INDEX] = g_rgbWhite;
    SetDIBColorTable(srcimage, 0, uSrcColors, rgbMask);
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, srcimage, 0, 0, SRCAND);

    //
    // dim the background cells to produce the shadow image
    //
    u = uColors = GetDIBColorTable(cellimage, 0, 256, rgbCell);
    while (u--)
    {
        rgbCell[u].rgbBlue =
            (BYTE)(SHADOW_FACTOR * (UINT)rgbCell[u].rgbBlue / 1000);
        rgbCell[u].rgbGreen =
            (BYTE)(SHADOW_FACTOR * (UINT)rgbCell[u].rgbGreen / 1000);
        rgbCell[u].rgbRed =
            (BYTE)(SHADOW_FACTOR * (UINT)rgbCell[u].rgbRed / 1000);
    }
    SetDIBColorTable(cellimage, 0, uColors, rgbCell);

    //
    // mask out the shadows and add them to the destination image
    //
//    rgbMask[0] = g_rgbBlack;
//    rgbMask[1] = g_rgbWhite;
    rgbMask[BUTTON_CLEAR_PALETTE_INDEX] = g_rgbBlack;
    rgbMask[BUTTON_SHADOW_PALETTE_INDEX] = g_rgbWhite;

    SetDIBColorTable(srcimage, 0, uSrcColors, rgbMask);
    BitBlt(cellimage, 0, 0, size.cx, size.cy, srcimage, 0, 0, SRCAND);
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, cellimage, 0, 0, SRCPAINT);

    //
    // mask out the button faces and add them to the destination image
    //
//    rgbSrc[0] = rgbSrc[1] = g_rgbBlack;
    rgbSrc[BUTTON_CLEAR_PALETTE_INDEX] = rgbSrc[BUTTON_SHADOW_PALETTE_INDEX] = g_rgbBlack;
    SetDIBColorTable(srcimage, 0, uSrcColors, rgbSrc);
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, srcimage, 0, 0, SRCPAINT);

    // all done
    return TRUE;
}

//---------------------------------------------------------------------------
BOOL AssembleButtonImages(AUTORUNDATA *data)
{
    BOOL result = FALSE;
    HBITMAP hbmSrc;
    char szBmpPath[MAX_PATH];

    lstrcpy( szBmpPath, g_szCurrentDir );
    lstrcat( szBmpPath, "\\btns.bmp" );

    hbmSrc = LoadImage(HINST_THISAPP, szBmpPath, IMAGE_BITMAP, 0, 0,
        LR_CREATEDIBSECTION | LR_LOADFROMFILE);

    if( !hbmSrc )
    {
        hbmSrc = LoadImage(HINST_THISAPP,
            MAKEINTRESOURCE(IDB_8BPP_BUTTONS),IMAGE_BITMAP, 0, 0,
            LR_CREATEDIBSECTION);
    }

    if (hbmSrc)
    {
        HDC hdcSrc = CreateCompatibleDC(data->image);
        BITMAP bm;

        GetObject(hbmSrc, sizeof(bm), &bm);

        if (hdcSrc)
        {
            HBITMAP hbmSrcOld = SelectBitmap(hdcSrc, hbmSrc);

// changed for iak
//            SIZE size = {bm.bmWidth, bm.bmHeight};
            SIZE size = {g_dwWindowWidth, g_dwWindowHeight};

            HBITMAP hbmTmp =
                CreateCompatibleBitmap(data->image, size.cx, size.cy);

            if (hbmTmp)
            {
                HDC hdcTmp = CreateCompatibleDC(data->image);

                if (hdcTmp)
                {
                    HBITMAP hbmTmpOld = SelectBitmap(hdcTmp, hbmTmp);

                    result = AssembleButtonImagesReal(data, hdcTmp, hdcSrc,
                        size);

                    SelectBitmap(hdcTmp, hbmTmpOld);
                    DeleteDC(hdcTmp);

                }

                DeleteBitmap(hbmTmp);
            }

            SelectBitmap(hdcSrc, hbmSrcOld);
            DeleteDC(hdcSrc);
        }

        DeleteBitmap(hbmSrc);
    }

    return result;
}

//---------------------------------------------------------------------------
LRESULT CALLBACK
AutoRunButtonSubclassProc(HWND window, UINT msg, WPARAM wp, LPARAM lp)
{
    int index = (int)GetWindowLongPtr(window, GWLP_ID);

    if ((index >= 0) && (index < AUTORUN_NUM_BUTTONS))
    {
        if (msg == WM_KEYDOWN)
            PostMessage(GetParent(window), msg, wp, lp);

        return CallWindowProc((g_ButtonInfo + index)->oldproc,
            window, msg, wp, lp);
    }

    return 0L;
}

//---------------------------------------------------------------------------
#define DORKYBUTTONSTYLE \
    (WS_CHILD | WS_VISIBLE | BS_ICON | BS_CENTER | BS_VCENTER)

HWND AutoRunCreateDorkyButton(AUTORUNDATA *data, AUTORUNBTN *button)
{
    HICON icon = LoadIcon(HINST_THISAPP, IDI_ICON(button->res));
    HWND child = NULL;

    if (icon)
    {
        child = CreateWindow(c_szButtonClass, c_szNULL, DORKYBUTTONSTYLE,
            0, 0, 0, 0, data->window, NULL, HINST_THISAPP, 0);

        if (child)
        {
            button->isdorky = TRUE;
            SendMessage(child, BM_SETIMAGE, MAKEWPARAM(IMAGE_ICON,0),
                (LPARAM)icon);
        }
    }

    return child;
}

//---------------------------------------------------------------------------
#define COOLBUTTONSTYLE \
    (WS_CHILD | WS_VISIBLE | BS_OWNERDRAW)

HWND AutoRunCreateCoolButton(AUTORUNDATA *data, AUTORUNBTN *button)
{
    return CreateWindow(c_szButtonClass, c_szNULL, COOLBUTTONSTYLE,
        0, 0, 0, 0, data->window, NULL, HINST_THISAPP, 0);
}

//---------------------------------------------------------------------------
void AutoRunCreateButtons(AUTORUNDATA *data)
{
    RECT labelbase = BUTTON_LABEL_RECT;
    RECT labelbase2 = BUTTON_LABEL_RECT2;
    int i;

    for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
    {
        AUTORUNBTN *button = g_ButtonInfo + i;
        HWND child = NULL;

        if (button->res != -1)
        {
            if( g_fCrapForColor )
            {
                child = AutoRunCreateDorkyButton( data, button );
            }

            if (!g_fCrapForColor)
            if(GetDataButtons(g_szCurrentDir))
                child = AutoRunCreateCoolButton(data, button);

            if (!child)
                child = AutoRunCreateDorkyButton(data, button);
        }

        if (child)
        {
            int cx = BUTTON_DEFAULT_CX;
            int cy = BUTTON_DEFAULT_CY;

            button->window = child;
            SetWindowLongPtr(child, GWLP_ID, i);
            button->oldproc = SubclassWindow(child,
                (WNDPROC)AutoRunButtonSubclassProc);

            if (button->isdorky)
            {
                cx = button->face.right - button->face.left;
                cy = button->face.bottom - button->face.top;
            }

            SetWindowPos(child, NULL, button->xpos, button->ypos, cx, cy,
                SWP_NOZORDER | SWP_NOACTIVATE);

            LoadString(HINST_THISAPP, IDS_TITLE(button->res),
                button->text, ARRAYSIZE(button->text));

            LoadString(HINST_THISAPP, IDS_INFO(button->res),
                button->description, ARRAYSIZE(button->description));
				if (i != 1)
					{
               button->textrect = labelbase;
					}
				else
					{
               button->textrect = labelbase2;
					}
            OffsetRect(&button->textrect, button->xpos, button->ypos);
            InvalidateRect(data->window, &button->textrect, FALSE);
        }
    }
}

//---------------------------------------------------------------------------
void CleanupAutoRunWindow(AUTORUNDATA *data)
{
    //
    // Deactivate any button so its timer will get killed
    //
    if (g_iActiveButton >= 0)
    {
        data->keyboard = FALSE;
        SendMessage(data->window, ARM_MOUSEOVER, TRUE, (LPARAM)-1L);
    }

    if (data->image)
    {
        if (data->oldbmp)
        {
            SelectBitmap(data->image, data->oldbmp);
            // real backdrop image is deleted in WinMain
            data->oldbmp = NULL;
        }

        DeleteDC(data->image);
        data->image = NULL;
    }

    if (data->btnimage)
    {
        if (data->oldbtnbmp)
        {
            DeleteBitmap(SelectBitmap(data->btnimage, data->oldbtnbmp));
            data->oldbtnbmp = NULL;
        }

        DeleteDC(data->btnimage);
        data->btnimage = NULL;
    }

    if (data->palette)
    {
        DeleteObject(data->palette);
        data->palette = NULL;
    }

    if (data->textfont)
    {
        DeleteObject(data->textfont);
        data->textfont = NULL;
    }
}

//---------------------------------------------------------------------------
BOOL AutoRunBuildPath(char *spec, int resid, DWORD rooting)
{
    char prefix[MAX_PATH];

    //
    // get the relative path of the spec
    //
    if (resid == -1)
    {
        //
        // empty string hack for callers
        //
        *spec = 0;
    }
    else
    {
        //
        // normal case
        //
        if (!LoadString(HINST_THISAPP, resid, spec, MAX_PATH))
            return FALSE;
    }

    //
    // our "empty" strings contain a single space so we know they succeeded
    //
    if ((*spec == ' ') && !spec[1])
        *spec = 0;

    //
    // figure out what the prefix should be
    //
    *prefix = 0;
    switch (rooting)
    {
        case ONACD:
            //
            // assume the cd is the root of wherever we were launched from
            //
//            GetModuleFileName(HINST_THISAPP, prefix, ARRAYSIZE(prefix));
//            _PathStripToRoot(prefix);
            lstrcpy( prefix, g_szCurrentDir );
            break;

        case INWIN:
            GetRealWindowsDirectory(prefix, ARRAYSIZE(prefix));
            break;

        case INSYS:
            GetSystemDirectory(prefix, ARRAYSIZE(prefix));
            break;

        case INTMP:
            GetTempPath(ARRAYSIZE(prefix), prefix);
            break;
    }

    //
    // if we have a prefix then prepend it
    //
    if (*prefix)
    {
        if (*spec)
        {
            //
            // tack the spec onto its new prefix
            //
            PathAppend(prefix, spec);
        }

        //
        // copy the whole mess out to the original buffer
        //
        lstrcpy(spec, prefix);
    }

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL InitAutoRunWindow(HWND window, AUTORUNDATA *data, LPCREATESTRUCT cs)
{
    AUTORUNBTN *button;

    data->window = window;

    if ((data->image = CreateCompatibleDC(NULL)) == NULL)
        goto im_doug;

    if ((data->oldbmp = SelectBitmap(data->image,
        (HBITMAP)cs->lpCreateParams)) == NULL)
    {
        goto im_doug;
    }

    if (g_fNeedPalette)
    {
        if ((data->palette = PaletteFromDS(data->image)) == NULL)
            goto im_doug;
    }

    // artifical scoping oh boy!
    {
        BITMAP bm;
        int i, ivis = 0;
        int range = 0;
        int origin, extent;

        for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
        {
            button = g_ButtonInfo + i;

            if (button->res != -1)
                range++;
        }

        GetObject((HBITMAP)cs->lpCreateParams, sizeof(bm), &bm);
        origin = BUTTON_Y_MARGIN * ((1 + AUTORUN_NUM_BUTTONS) - range);

// changed for iak
//        extent = bm.bmHeight - ((2 * origin) + BUTTON_IMAGE_Y_SIZE);
        extent = g_dwWindowHeight - ((2 * origin) + BUTTON_IMAGE_Y_SIZE);

        if (--range < 1)
            range = 1;

        for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
        {
            button = g_ButtonInfo + i;

            if (button->res != -1)
            {
                button->xpos = BUTTON_X_PLACEMENT;
//                //button->ypos = ivis * extent / range + origin;
//                button->ypos = (ivis * extent) + (g_dwWindowHeight / 2) - BUTTON_IMAGE_Y_SIZE;
//                button->ypos = (g_dwWindowHeight / 3) * (ivis + 1) + 20;
                button->ypos = (g_dwWindowHeight / 4) * (ivis) + 20;
                ivis++;
            }
        }
    }

    // more artifical scoping!
    {
        HDC screen = GetDC(NULL);
        LOGFONT lf = { DEF_BUTTON_LABEL_HEIGHT, 0, 0, 0, FW_BOLD, FALSE,
            FALSE, FALSE, (screen? GetTextCharset(screen) : DEFAULT_CHARSET),
            OUT_STROKE_PRECIS, CLIP_DEFAULT_PRECIS,
            PROOF_QUALITY | NONANTIALIASED_QUALITY,
            VARIABLE_PITCH | FF_DONTCARE, 0 };
        char buf[32];

        if (screen)
            ReleaseDC(NULL, screen);

        if (!LoadString(HINST_THISAPP, IDS_LABELFONT, lf.lfFaceName,
            ARRAYSIZE(lf.lfFaceName)))
        {
            lstrcpy(lf.lfFaceName, c_szArial);
        }

        if (LoadString(HINST_THISAPP, IDS_LABELHEIGHT, buf, ARRAYSIZE(buf)))
            lf.lfHeight = AnotherStrToLong(buf);

        if ((data->textfont = CreateFontIndirect(&lf)) == NULL)
            goto im_doug;
    }
    //
    // see if we need to do 8bit+ work...
    //

    if (g_fCrapForColor)
    {
        data->clrnormal      = AUTORUN_4BIT_TEXTCOLOR;
        data->clrhigh        = AUTORUN_4BIT_HIGHLIGHT;
        data->clrdisable     = AUTORUN_4BIT_DISABLED;
        data->clrdescription = AUTORUN_4BIT_DESCRIPTION;
    }
    else
    {
        data->clrnormal      = AUTORUN_8BIT_TEXTCOLOR;
        data->clrhigh        = AUTORUN_8BIT_HIGHLIGHT;
        data->clrdisable     = AUTORUN_8BIT_DISABLED;
        data->clrdescription = AUTORUN_8BIT_DESCRIPTION;
        if (!AssembleButtonImages(data))
            goto im_doug;
    }

    PostMessage(g_hMainWindow, ARM_MOUSEOVER, TRUE, (LPARAM)-1L);
    return TRUE;

im_doug:
    CleanupAutoRunWindow(data);
    return FALSE;
}

//---------------------------------------------------------------------------
void AutoRunSized(AUTORUNDATA *data)
{
#ifdef DESCRIPTIONS
    GetClientRect(data->window, &data->descrect);
    data->wndheight = data->descrect.bottom - data->descrect.top;
    data->descrect.left = AUTORUN_DESCRIPTION_LEFT;
    data->descrect.top = AUTORUN_DESCRIPTION_TOP;
    data->descrect.right = AUTORUN_DESCRIPTION_RIGHT;
#else
    SetRectEmpty( &data->descrect);
#endif
}

//---------------------------------------------------------------------------
void AutoRunRealize(HWND window, AUTORUNDATA *data, HDC theirdc)
{
    if (data->palette)
    {
        HDC dc = theirdc? theirdc : GetDC(window);

        if (dc)
        {
            BOOL repaint = FALSE;

            SelectPalette(dc, data->palette, FALSE);
            repaint = (RealizePalette(dc) > 0);

            if (!theirdc)
                ReleaseDC(window, dc);

            if (repaint)
            {
                RedrawWindow(window, NULL, NULL, RDW_INVALIDATE |
                    RDW_ERASE | RDW_ALLCHILDREN);
            }
        }
    }
}

//---------------------------------------------------------------------------
void AutoRunErase(AUTORUNDATA *data, HDC dc)
{
    RECT rc;
    RECT textrect;

    GetClientRect(data->window, &rc);

    AutoRunRealize(data->window, data, dc);
    BitBlt(dc, 0, 0, rc.right, rc.bottom, data->image, 0, 0, SRCCOPY);

//    StretchBlt(dc, 0, 0, rc.right, rc.bottom, data->image, 0, 0, g_dwBitmapWidth, g_dwBitmapHeight, SRCCOPY);

    textrect.top = MAINTEXT_TOPMARGIN;
    textrect.left = MAINTEXT_LEFTMARGIN;
    textrect.right = g_dwWindowWidth - MAINTEXT_RIGHTMARGIN;
    textrect.bottom = g_dwWindowHeight - MAINTEXT_BOTTOMMARGIN;
//    textrect.bottom = g_dwWindowHeight / 2;

    SetBkMode(dc, TRANSPARENT);

    if( g_fCrapForColor )
        SetTextColor( dc, AUTORUN_4BIT_TEXTCOLOR );
    else
        SetTextColor( dc, AUTORUN_8BIT_TEXTCOLOR );

    if(!g_bCustomBMP) //if there is a custom bitmap, don't put up our text
    {
        DrawText(dc, Res2Str( IDS_MAINTEXT ), -1, &textrect,
            DT_WORDBREAK | DT_LEFT | DT_TOP);
    }
}

//---------------------------------------------------------------------------
void AutoRunPaint(AUTORUNDATA *data)
{
    PAINTSTRUCT ps;
    HDC dc = BeginPaint(data->window, &ps);
    AUTORUNBTN *button;
    COLORREF curtextcolor = GetTextColor(dc);
    COLORREF color;
    HFONT hfold = NULL;
    int i;

    AutoRunRealize(data->window, data, dc);
    SetBkMode(dc, TRANSPARENT);

    //
    // paint all the button labels
    //
    if (data->textfont)
        hfold = SelectFont(dc, data->textfont);

    for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
    {
        button = g_ButtonInfo + i;

        if (button->window)
        {
            color = (i == g_iActiveButton)? data->clrhigh :
                (IsWindowEnabled(button->window)? data->clrnormal :
                data->clrdisable);

            if (color != curtextcolor)
            {
                SetTextColor(dc, color);
                curtextcolor = color;
            }

            DrawText(dc, button->text, -1, &button->textrect,
                DT_WORDBREAK | DT_RIGHT | DT_TOP);
        }
    }

/* Removed for ISK3
    //
    // paint the description for the current button
    //
    if (g_iActiveButton >= 0)
    {
        button = g_ButtonInfo + g_iActiveButton;

        color = data->clrdescription;
        if (color != curtextcolor)
        {
            SetTextColor(dc, color);
            curtextcolor = color;
        }

// Removed for ISK3
//        DrawText(dc, button->description, -1, &data->descrect,
//            DT_WORDBREAK | DT_LEFT | DT_TOP);
    }
*/

    if (hfold)
        SelectFont(dc, hfold);

    EndPaint(data->window, &ps);
}

//---------------------------------------------------------------------------
void AutoRunDrawItem(AUTORUNDATA *data, DRAWITEMSTRUCT *dis)
{
    POINT loc = { dis->rcItem.left, dis->rcItem.top };
    SIZE size = { dis->rcItem.right - loc.x, dis->rcItem.bottom - loc.y };

    loc.y += dis->CtlID * BUTTON_IMAGE_Y_SIZE;

    if (dis->itemState & ODS_DISABLED)
    {
        loc.x += DISABLED_IMAGE_X_OFFSET;
    }
    else if (dis->itemState & ODS_SELECTED)
    {
        loc.x += SELECTED_IMAGE_X_OFFSET;
    }
    else if (dis->itemState & ODS_FOCUS)
    {
        loc.x += FOCUS_IMAGE_X_OFFSET;
    }

    AutoRunRealize(dis->hwndItem, data, dis->hDC);
    BitBlt(dis->hDC, dis->rcItem.left, dis->rcItem.top, size.cx, size.cy,
        data->btnimage, loc.x, loc.y, SRCCOPY);
}

//---------------------------------------------------------------------------
void AutoRunActivateItem(AUTORUNDATA *data, int index)
{
    if (index >= 0)
    {
        //
        // prevent disabled buttons from getting focus...
        //
        AUTORUNBTN *button = g_ButtonInfo + index;
        if (!button->window || !IsWindowEnabled(button->window))
            index = -1;
    }

    if (g_iActiveButton != index)
    {
        AUTORUNBTN *newbtn = (index >= 0)? (g_ButtonInfo + index) : NULL;
        AUTORUNBTN *oldbtn = (g_iActiveButton >= 0)?
            (g_ButtonInfo + g_iActiveButton) : NULL;

        //
        // if there was an previous button, repaint its label highlight
        //
        if (oldbtn)
            InvalidateRect(data->window, &oldbtn->textrect, FALSE);

        g_iActiveButton = index;

        if (newbtn)
        {
            InvalidateRect(data->window, &newbtn->textrect, FALSE);
            SetFocus(newbtn->window);

            //
            // if activating via mouse, track it (trust me...)
            //
            if (g_fMouseAvailable && !data->keyboard)
                SetTimer(data->window, LABEL_VERIFY_TIMER, 333, NULL);
        }
        else
        {
            SetFocus(data->window);

            if (g_fMouseAvailable)
                KillTimer(data->window, LABEL_VERIFY_TIMER);
        }

        //
        // go ahead and paint any label changes now before we erase
        //
        UpdateWindow(data->window);
        InvalidateRect(data->window, &data->descrect, TRUE);
    }
}

//---------------------------------------------------------------------------
void AutoRunMouseOver(AUTORUNDATA *data, int index, BOOL fForce)
{
    if ((index >= 0) || !data->keyboard || fForce)
    {
        data->keyboard = !g_fMouseAvailable;
        AutoRunActivateItem(data, index);
    }
}

//---------------------------------------------------------------------------
int AutoRunProcessPotentialHit(HWND candidate, const POINT *loc)
{
    if (GetAsyncKeyState(VK_LBUTTON) < 0)
        return g_iActiveButton;

    if (candidate && IsWindowEnabled(candidate) &&
        (GetParent(candidate) == g_hMainWindow))
    {
        int index;

        index = (int)GetWindowLongPtr(candidate, GWLP_ID);
        if ((index >= 0) && (index < AUTORUN_NUM_BUTTONS))
        {
            AUTORUNBTN *button = g_ButtonInfo + index;
            POINT cli = *loc;

            ScreenToClient(candidate, &cli);
            if (PtInRect(&button->face, cli)||PtInRect(&button->textrect,cli))
                return index;
        }
    }

    return -1;
}

//---------------------------------------------------------------------------
void AutoRunVerifyActiveItem(AUTORUNDATA *data)
{
    if (!data->keyboard)
    {
        int index = -1;

        if (!g_fAppDisabled)
        {
            POINT loc;
            HWND candidate;

            GetCursorPos(&loc);

            if ((candidate = WindowFromPoint(loc)) != NULL)
                index = AutoRunProcessPotentialHit(candidate, &loc);
        }

        if (index != g_iActiveButton)
            AutoRunMouseOver(data, index, FALSE);
    }
}

//---------------------------------------------------------------------------
void AutorunEnableButton(AUTORUNDATA *data, int id, BOOL f)
{
    if ((id >= 0) && (id < AUTORUN_NUM_BUTTONS))
    {
        AUTORUNBTN *button = g_ButtonInfo + id;
        HWND window = button->window;

        if (button->window && IsWindow(button->window))
        {
            EnableWindow(button->window, f);
            InvalidateRect(data->window, &button->textrect, FALSE);
            AutoRunVerifyActiveItem(data);
        }
    }
}

//---------------------------------------------------------------------------
BOOL AutoRunCDIsInDrive( )
{
    char me[MAX_PATH];
    GetModuleFileName(HINST_THISAPP, me, ARRAYSIZE(me));

    while (!PathFileExists(me))
    {
        if (MessageBox(NULL,Res2Str(IDS_NEEDCDROM),
            Res2Str(IDS_APPTITLE),
            MB_OKCANCEL | MB_ICONSTOP) == IDCANCEL)
        {
            return FALSE;
        }
    }
    return TRUE;
}
//---------------------------------------------------------------------------
void AutoRunMinimize( BOOL fMin )
{
    HWND hwndIE;

    if( fMin )
    {
        //Find Autorun App and Minimize it.
        hwndIE = FindWindow( "AutoRunMain", NULL );
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_MINIMIZE, 0L );
    }
    else
    {
        //Find Autorun App and Restore it.
        hwndIE = FindWindow( "AutoRunMain", NULL );
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_RESTORE, 0L );
    }
}

//ZZZZ
//---------------------------------------------------------------------------
HANDLE AutoRunExec( char *command, char *params, char *dir, int nWinState )
{
    SHELLEXECUTEINFO sei;

    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = "Open";
    sei.lpFile = command;
    sei.lpParameters = params;
    sei.lpDirectory = dir;
    sei.nShow = nWinState;
    sei.cbSize = sizeof(sei);


    if( ShellExecuteEx(&sei) )
    {
        g_ahWait[g_cWait] = sei.hProcess;
        g_cWait += 1;

        return sei.hProcess;
    }

    return NULL;

}

//---------------------------------------------------------------------------
BOOL AutoRunKillProcess( DWORD dwResult )
{
    char lpFName[MAX_PATH];
    char szCommand[MAX_PATH];
    char szDir[MAX_PATH];
    char szPath[MAX_PATH];
    HKEY    hkRunOnce;
    HKEY    hkIE;

    AutoRunCDIsInDrive();   //make sure we still have the CD in

    if( g_ahWait[dwResult] == g_hSETUP )
    {
		g_cWait -= 1;
        CloseHandle( g_ahWait[dwResult] );
        MoveMemory( &g_ahWait[dwResult], &g_ahWait[dwResult + 1], ARRAYSIZE(g_ahWait) - dwResult - 1);
        g_hSETUP = NULL;

        g_fSetupRunning = FALSE;

        AutoRunMinimize( FALSE );   //restore autorun app

        // See if the user actually installed IE

        GetWindowsDirectory( lpFName, MAX_PATH );
        lstrcat( lpFName, "\\inf\\mos105e.inf" );

        if( GetFileAttributes( lpFName ) != 0xFFFFFFFF )
        {

            g_fSetup = TRUE;
            if (!g_fIEInstalled) g_fNewIEIcon = TRUE;
            g_fIEInstalled = TRUE;
            g_fChangeIcon = TRUE;

            lstrcpy(szCommand, g_szCurrentDir);
            lstrcat(szCommand, Res2Str(IDS_CMD_MSN));
            lstrcpy(szDir, g_szCurrentDir);
            lstrcat(szDir, "\\");
            ShellExecute( NULL, NULL, szCommand, " ", szDir, SW_SHOWNORMAL );
        }

        SetFocus( g_hwnd );

        return TRUE;
    }

    if( g_ahWait[dwResult] == g_hIE )
    {
		g_cWait -= 1;
        CloseHandle( g_ahWait[dwResult] );
        MoveMemory( &g_ahWait[dwResult], &g_ahWait[dwResult + 1], ARRAYSIZE(g_ahWait) - dwResult - 1);
        g_hIE = NULL;
        g_fIeRunning = FALSE;

        if( !g_fRunReadme && !g_fRunExtras && !g_fRunDemo && !g_fSetupRunning)
        {
            AutoRunMinimize( FALSE );   //restore autorun app
        }

        return TRUE;
    }

    return FALSE;
}

//---------------------------------------------------------------------------
void AutoRunKillIE( void )
{
    HWND hwndIE;

    hwndIE = FindWindow( "IEFrame", NULL );
    PostMessage( hwndIE, WM_SYSCOMMAND, SC_CLOSE, 0L );

}

//AAA
//---------------------------------------------------------------------------
void AutoRunClick(AUTORUNDATA *data, int nCmd)
{
    char command[MAX_PATH], dir[MAX_PATH], params[MAX_PATH];
    char lpFName[MAX_PATH];
    char szMSNCommand[MAX_PATH];
    char szMSNDir[MAX_PATH];
    AUTORUNBTN *button;
    HKEY    IEKey;
    DWORD   dwLength = 2048;
    HWND    hwndIE;

    if( g_fSetupRunning ) goto cancelquit;  //if setup is running, get out of here

    AutoRunMinimize( TRUE );    //Minimize autorun app

    if ((nCmd < 0) || (nCmd >= AUTORUN_NUM_BUTTONS))
        return;

    button = g_ButtonInfo + nCmd;

    AutoRunBuildPath( command, IDS_CMD(button->res), CMD_ROOT(button->rooting));
    AutoRunBuildPath( dir, IDS_DIR(button->res), DEFDIR_ROOT(button->rooting));

    //
    // verify that the app disk is still visible and prompt if not...
    //
    if(!AutoRunCDIsInDrive( )) return;

    if(nCmd == IDAB_IEFROMCD)
    {
        HANDLE hReadme;

        PlaySound(MAKEINTRESOURCE(IDW_DEMO), HINST_THISAPP,
            SND_RESOURCE | SND_SYNC | SND_NODEFAULT);

        g_hIE = AutoRunExec( command, " ", dir, SW_SHOWNORMAL );

    }

    if(nCmd == IDAB_IESETUP)
    {
        HKEY hkRegKey,hkRunOnce;
		char szPath[MAX_PATH];
		char szWinPath[MAX_PATH];
		char szDestPath[MAX_PATH];
        DWORD dwVal;

        PlaySound(MAKEINTRESOURCE(IDW_INSTALL), HINST_THISAPP,
            SND_RESOURCE | SND_SYNC | SND_NODEFAULT);

        GetWindowsDirectory( szWinPath, MAX_PATH );
        wsprintf( szPath, "%s\\isk3ro.exe %s\\iecd.exe", szWinPath, g_szCurrentDir );
        if (RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Tips", 0, KEY_READ|KEY_WRITE, &hkRunOnce ) == ERROR_SUCCESS)
        {
            RegSetValueEx( hkRunOnce, "ShowIE4Plus", 0, REG_SZ, szPath, REGLEN(szPath));
            dwVal = 1;
            RegSetValueEx( hkRunOnce, "DisableStartHtm", 0, REG_DWORD, (CONST BYTE *)&dwVal, sizeof(dwVal));
            RegCloseKey( hkRunOnce );
        }

        if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion", 0, KEY_READ|KEY_WRITE, &hkRegKey ) == ERROR_SUCCESS)
        {
            RegSetValueEx( hkRegKey, "IEFromCD", 0, REG_SZ, "1", 2 );
            RegCloseKey( hkRegKey );
        }

        g_fClicked = TRUE;

        g_hSETUP = AutoRunExec( command, " ", dir, SW_SHOWNORMAL );
//        g_fSetupRunning = TRUE;

		PostMessage(g_hwnd,WM_CLOSE,(WPARAM) 0,(LPARAM) 0);
    }

cancelquit:
    ;

}

//---------------------------------------------------------------------------
void AutoRunHandleKeystroke(AUTORUNDATA *data, TCHAR key, LPARAM lp)
{
    int move = 0;
    int where = g_iActiveButton;

    //
    // see if we care about this keystroke
    //
    switch (key)
    {
    case VK_RETURN:
        if (where >= 0)
            AutoRunClick(data, where);
        //fallthru
    case VK_ESCAPE:
        where = -1;
        break;

    case VK_TAB:
        move = (GetKeyState(VK_SHIFT) < 0)? -1 : 1;
        break;

    case VK_END:
        where = AUTORUN_NUM_BUTTONS;
        //fallthru
    case VK_UP:
    case VK_LEFT:
        move = -1;
        break;

    case VK_HOME:
        where = -1;
        //fallthru
    case VK_DOWN:
    case VK_RIGHT:
        move = 1;
        break;

    default:
        return;
    }

    //
    // we should only get down here if the active button is going to change
    //
    if (move)
    {
        int scanned;

        for (scanned = 0; scanned <= AUTORUN_NUM_BUTTONS; scanned++)
        {
            where += move;

            if (where >= (int)AUTORUN_NUM_BUTTONS)
            {
                where = -1;
            }
            else if (where < 0)
            {
                where = AUTORUN_NUM_BUTTONS;
            }
            else
            {
                HWND child = (g_ButtonInfo + where)->window;
                if (child && IsWindowEnabled(child))
                    break;
            }
        }

    }

    if (where >= 0)
    {
        SetCursor(NULL);
        data->keyboard = TRUE;
    }
    else
        data->keyboard = !g_fMouseAvailable;

    AutoRunActivateItem(data, where);
}

//---------------------------------------------------------------------------
BOOL CheckVersionConsistency(AUTORUNDATA *data)
{
    DWORD dwResult;
    DWORD dwMajor;
    DWORD dwMinor;
    BOOL result = FALSE;

    dwResult = GetVersion();
    dwMajor = (DWORD)(LOBYTE(LOWORD(dwResult)));
    dwMinor = (DWORD)(HIBYTE(LOWORD(dwResult)));

    if( dwMajor == 4 && dwResult >= 0x80000000 )    //windows 95
    {
        result = TRUE;
    }
    else
    {
        result = FALSE;
    }

    return result;
}

//---------------------------------------------------------------------------
LRESULT CALLBACK AutoRunMouseHook(int code, WPARAM wp, LPARAM lp)
{
    if (code >= 0)
    {
        #define hook ((MOUSEHOOKSTRUCT *)lp)
        int id = g_fAppDisabled? -1 :
            AutoRunProcessPotentialHit(hook->hwnd, &hook->pt);

        if (id != g_iActiveButton)
            PostMessage(g_hMainWindow, ARM_MOUSEOVER, FALSE, (LPARAM)id);

        #undef hook
    }

    return CallNextHookEx(g_hMouseHook, code, wp, lp);
}


// CreateLink - uses the shell's IShellLink and IPersistFile interfaces
//   to create and store a shortcut to the specified object.
// Returns the result of calling the member functions of the interfaces.
// lpszPathObj - address of a buffer containing the path of the object
// lpszPathLink - address of a buffer containing the path where the
//   shell link is to be stored
// lpszDesc - address of a buffer containing the description of the
//   shell link
HRESULT CreateLink(LPCSTR lpszPathObj,
    LPSTR lpszPathLink, LPSTR lpszDesc)
{
    HRESULT hres;
    IShellLink* psl;

    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance(&CLSID_ShellLink, NULL,
        CLSCTX_INPROC_SERVER, &IID_IShellLink, &psl);
    if (SUCCEEDED(hres)) {
        IPersistFile* ppf;

        // Set the path to the shortcut target, and add the
        // description.
        psl->lpVtbl->SetPath(psl, lpszPathObj);
        psl->lpVtbl->SetDescription(psl, lpszDesc);

       // Query IShellLink for the IPersistFile interface for saving the
       // shortcut in persistent storage.
        hres = psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile,
            &ppf);

        if (SUCCEEDED(hres)) {
            WORD wsz[MAX_PATH];

            // Ensure that the string is ANSI.
            MultiByteToWideChar(CP_ACP, 0, lpszPathLink, -1,
                wsz, MAX_PATH);

            // Save the link by calling IPersistFile::Save.
            hres = ppf->lpVtbl->Save(ppf, wsz, TRUE);
            ppf->lpVtbl->Release(ppf);
        }
        psl->lpVtbl->Release(psl);
    }
    return hres;
}
//---------------------------------------------------------------------------
void InstallICWScript( )
{
    char szDest[MAX_PATH];
    char szSource[MAX_PATH];
    HKEY hkAppPath;
    DWORD dwType;
    DWORD dwLength = MAX_PATH;

    memset( szDest, 0, MAX_PATH );

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE",
        0, KEY_READ|KEY_WRITE, &hkAppPath ) != ERROR_SUCCESS )
        return;
    RegQueryValueEx( hkAppPath, "", NULL, &dwType, szDest, &dwLength );
    RegCloseKey( hkAppPath );

    if( lstrlen( szDest ) == 0 )
        return;

    _PathRemoveFileSpec( szDest );

    lstrcat( szDest, "\\ICWSCRPT.EXE" );

    wsprintf( szSource, "%s\\..\\ICWSCRPT.EXE", g_szCurrentDir );

    CopyFile( szSource, szDest, FALSE );

}

//---------------------------------------------------------------------------
LRESULT CALLBACK AutoRunWndProc(HWND window, UINT msg, WPARAM wp, LPARAM lp)
{
    AUTORUNDATA *data = (AUTORUNDATA *)GetWindowLongPtr(window, GWLP_USERDATA);
    HWND hwndIE;
    char szPath[MAX_PATH];
    char szWinPath[MAX_PATH];
    char szDestPath[MAX_PATH];
    HKEY hkIE;
    HKEY hkRunOnce;

    switch (msg)
    {
    case WM_NCCREATE:
        data = (AUTORUNDATA *)LocalAlloc(LPTR, sizeof(AUTORUNDATA));
        if (data && !InitAutoRunWindow(window, data, (LPCREATESTRUCT)lp))
        {
            LocalFree((HANDLE)data);
            data = NULL;
        }
        SetWindowLongPtr(window, GWLP_USERDATA, (UINT_PTR)data);
        if (!data)
            return FALSE;
        g_hMainWindow = window;
        goto DoDefault;

    case WM_CREATE:
        PlaySound(MAKEINTRESOURCE(IDW_STARTAPP), HINST_THISAPP,
            SND_RESOURCE | SND_ASYNC | SND_NODEFAULT);

        AutoRunCreateButtons(data);
        ShowWindow(window, SW_SHOWNORMAL);

        g_hwnd = window;

// version - fix for NT
//        if(!CheckVersionConsistency(data))
//            return -1;

        GetWindowsDirectory( szWinPath, MAX_PATH );
        wsprintf( szPath, "%s\\isk3ro.exe", g_szCurrentDir );
        wsprintf( szDestPath, "%s\\isk3ro.exe", szWinPath );
        
		if(GetFileAttributes(szDestPath)!=0xFFFFFFFF)
		{
			SetFileAttributes(szDestPath,FILE_ATTRIBUTE_ARCHIVE);
			
			DeleteFile(szDestPath);
		}

		CopyFile( szPath, szDestPath, FALSE );

        wsprintf( szPath, "%s\\welc.exe", g_szCurrentDir );
        wsprintf( szDestPath, "%s\\welc.exe", szWinPath );
        
		CopyFile( szPath, szDestPath, FALSE );

        break;

    case WM_CLOSE:

/*        hwndIE = FindWindow( "IEFrame", NULL );
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_CLOSE, 0L );

        if (g_cWait)
        {
            ShowWindow(window, SW_HIDE);
            g_fClosed = TRUE;
            break;
        }
*/
        goto DoDefault;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_NCDESTROY:
        if (data)
        {
            CleanupAutoRunWindow(data);
            LocalFree((HANDLE)data);
        }
        g_hMainWindow = NULL;
        goto DoDefault;

    case WM_ENDSESSION:
        if( !g_fClicked ) // bugid 3099
            goto DoDefault;

//        GetWindowsDirectory( szWinPath, MAX_PATH );
//        wsprintf( szPath, "%s\\packages\\isk3ro.exe", g_szCurrentDir );
//        wsprintf( szDestPath, "%s\\%s\\isk3ro.exe", szWinPath, Res2Str( IDS_STARTUPGROUP ));
//        wsprintf( szDestPath, "%s\\isk3ro.exe", szWinPath );
//        CopyFile( szPath, szDestPath, FALSE );
        GetWindowsDirectory( szWinPath, MAX_PATH );
        wsprintf( szPath, "%s\\isk3ro.exe %s\\iecd.exe", szWinPath, g_szCurrentDir );
        RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce", 0, KEY_READ|KEY_WRITE, &hkRunOnce );
        RegSetValueEx( hkRunOnce, "RunPlus", 0, REG_SZ, szPath, REGLEN(szPath));
        RegCloseKey( hkRunOnce );

        GetWindowsDirectory( szWinPath, MAX_PATH );

//        InstallICWScript( );

//        wsprintf( szPath, "%s\\isk3ro.exe %s\\..\\setup.exe", szWinPath, g_szCurrentDir );
//        wsprintf( szDestPath, "%s\\%s\\isk3ro.exe", szWinPath, Res2Str( IDS_STARTUPGROUP ));
//        CreateLink( szPath, szDestPath, "Internet Starter Kit");

        if (RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Internet Explorer\\Document Windows", 0, KEY_READ|KEY_WRITE, &hkIE ) == ERROR_SUCCESS)
        {
            RegSetValueEx( hkIE, "Maximized", 0, REG_SZ, "yes", 4 );
            RegCloseKey( hkIE );
        }
        goto DoDefault;

    case WM_SIZE:
        AutoRunSized(data);
        break;

    case WM_DRAWITEM:
        AutoRunDrawItem(data, (DRAWITEMSTRUCT *)lp);
        break;

    case ARM_MOUSEOVER:
        AutoRunMouseOver(data, (int)lp, (BOOL)wp);
        break;

    case WM_ACTIVATE:
        g_fAppDisabled = ((LOWORD(wp) == WA_INACTIVE) || HIWORD(wp));
        AutoRunVerifyActiveItem(data);
        goto DoDefault;

    case WM_TIMER:
        AutoRunVerifyActiveItem(data);
        break;

    case ISK_KILLSETUPHANDLE:
        CloseHandle( g_hSETUP );
        break;

    case WM_KEYDOWN:
        AutoRunHandleKeystroke(data, (TCHAR)wp, lp);
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wp, lp) == BN_CLICKED)
		{
            EnableWindow(window, FALSE);
					
            AutoRunClick(data, GET_WM_COMMAND_ID(wp, lp));

			EnableWindow(window, TRUE);
		}
        break;

    case WM_PALETTECHANGED:
        if ((HWND)wp == window)
            break;
        //fallthru
    case WM_QUERYNEWPALETTE:
        AutoRunRealize(window, data, NULL);
        break;

    case WM_ERASEBKGND:
        AutoRunErase(data, (HDC)wp);
        break;

    case WM_PAINT:
        AutoRunPaint(data);
        break;

    default:
    DoDefault:
        return DefWindowProc(window, msg, wp, lp);
    }

    return 1;
}


int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}


//---------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    char szAppTitle[128];
    char szBmpPath[MAX_PATH];
    WNDCLASS wc;
    HBITMAP hbm = NULL;
    BITMAP bm;
    DWORD style;
    HWND window;
    RECT r;
    HDC screen;
    int retval = -1;
    HWND hwndIE;
    HKEY hkRegKey;

    g_hinst = hInstance;

    //in case this is run from another directory...
    GetModuleFileName( NULL, g_szCurrentDir, MAX_PATH );
    _PathRemoveFileSpec( g_szCurrentDir );

    // put our path into the registry
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion", 0, KEY_READ|KEY_WRITE, &hkRegKey ) == ERROR_SUCCESS)
    {
        RegSetValueEx( hkRegKey, "IESKPath", 0, REG_SZ, g_szCurrentDir, lstrlen( g_szCurrentDir ) + 1 );
        RegCloseKey( hkRegKey );
    }

    //
    // is setup asking the user to insert a disk?
    //
/*    window = FindWindow(c_szAutoRunPrevention, c_szAutoRunPrevention);
    if (window)
    {
        // do nothing
        // setup is probably trying to copy a driver or something...
        retval = 0;
        goto im_doug;
    }
*/
    //
    // overwrite default apptitle if data file exists
    //
    GetDataAppTitle( szAppTitle, g_szCurrentDir );

    if( lstrlen( szAppTitle ) == 0 ) {
        lstrcpy( szAppTitle, Res2Str( IDS_APPTITLE ));
    }

    //
    // identity crisis?
    //
    window = FindWindow(c_szAutoRunClass, szAppTitle);
    if (window)
    {
        retval = 0;
        hwndIE = FindWindow( "IEFrame", NULL );
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_MINIMIZE, 0L );

//        PostMessage( hwndIE, WM_SYSCOMMAND, SC_CLOSE, 0L );
        ShowWindowAsync(window, SW_SHOWNORMAL);
        SetForegroundWindow(window);
        goto im_doug;
    }
    //kill Internet Explorer if it is running
    hwndIE = FindWindow( "IEFrame", NULL );
    if( hwndIE != NULL )
    {
        if( MessageBox( NULL, Res2Str( IDS_IERUNNINGMSG ), Res2Str( IDS_APPTITLE ), MB_YESNO | MB_ICONINFORMATION ) == IDNO )
        {
            goto im_doug;
        }
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_CLOSE, 0L );
    }
    //kill Internet Explorer if it is running
    hwndIE = FindWindow( "Internet Explorer_Frame", NULL );
    if( hwndIE != NULL )
    {
        if( MessageBox( NULL, Res2Str( IDS_IERUNNINGMSG ), Res2Str( IDS_APPTITLE ), MB_YESNO | MB_ICONINFORMATION ) == IDNO )
        {
            goto im_doug;
        }
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_CLOSE, 0L );
    }

    //
    // yet more mundane platform-centric details
    //
    if (!GetClassInfo(HINST_THISAPP, c_szAutoRunClass, &wc))
    {
        wc.style = 0;
        wc.lpfnWndProc = AutoRunWndProc;
        wc.cbClsExtra = wc.cbWndExtra = 0;
        wc.hInstance = hInstance;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon = NULL;
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = c_szAutoRunClass;

        if (!RegisterClass(&wc))
            goto im_doug;
    }

    //
    // get text color information from .ini file
    //

    AUTORUN_8BIT_TEXTCOLOR = GetDataTextColor( NORMAL, g_szCurrentDir );
    AUTORUN_8BIT_HIGHLIGHT = GetDataTextColor( HIGHLIGHT, g_szCurrentDir );
    AUTORUN_8BIT_DESCRIPTION = GetDataTextColor( HIGHLIGHT, g_szCurrentDir );
    AUTORUN_4BIT_TEXTCOLOR = GetDataTextColor( NORMAL, g_szCurrentDir );
    AUTORUN_4BIT_HIGHLIGHT = GetDataTextColor( HIGHLIGHT, g_szCurrentDir );
    AUTORUN_4BIT_DESCRIPTION = GetDataTextColor( HIGHLIGHT, g_szCurrentDir );

    //
    // get a few tidbits about the display we're running on
    //
    screen = GetDC(NULL);

#if defined (DEBUG) && defined (FORCE_CRAP)
    g_fCrapForColor = TRUE;
#else
    g_fCrapForColor = (GetDeviceCaps(screen, PLANES) *
        GetDeviceCaps(screen, BITSPIXEL)) < 8;
#endif

    g_fNeedPalette = (!g_fCrapForColor &&
        (GetDeviceCaps(screen, RASTERCAPS) & RC_PALETTE));

    ReleaseDC(NULL, screen);

    //
    // load the window backdrop image
    //

    lstrcpy( szBmpPath, g_szCurrentDir );
    lstrcat( szBmpPath, "\\back.bmp" );
    hbm = LoadImage( NULL, szBmpPath, IMAGE_BITMAP, 0, 0,
        LR_CREATEDIBSECTION | LR_LOADFROMFILE );

    g_bCustomBMP=TRUE;

    if(!hbm)    //if it doesn't exist, load the default
    {
        hbm = LoadImage(HINST_THISAPP, MAKEINTRESOURCE(g_fCrapForColor?
            IDB_4BPP_BACKDROP : IDB_8BPP_BACKDROP), IMAGE_BITMAP, 0, 0,
            LR_CREATEDIBSECTION );

        g_bCustomBMP=FALSE;
    }

    if (!hbm)
        goto im_doug;

//    if(!GetDataBackdrop( hbm ))
//        goto im_doug;


    //
    //
    // see if there is a moose around
    //
    if ((g_fMouseAvailable = (GetSystemMetrics(SM_MOUSEPRESENT) != 0)) != 0)
    {
        //
        // set up a moose hook for our thread
        // don't worrke if it fails, the app will stil work...
        //
        g_hMouseHook = SetWindowsHookEx(WH_MOUSE, AutoRunMouseHook,
            HINST_THISAPP, GetCurrentThreadId());
    }

    //
    // create the window based on the backdrop image
    //
    GetObject(hbm, sizeof(bm), &bm);

    g_dwBitmapWidth = bm.bmWidth;
    g_dwBitmapHeight = bm.bmHeight;
    g_dwWindowWidth = bm.bmWidth;
    g_dwWindowHeight = bm.bmHeight;
/*
    if( g_dwBitmapWidth < MIN_WINDOW_WIDTH || g_dwBitmapHeight < MIN_WINDOW_HEIGHT || g_dwBitmapHeight > MAX_WINDOW_HEIGHT || g_dwBitmapWidth > MAX_WINDOW_WIDTH)
    {
        // scale the window to a default scale.
        r.left = (GetSystemMetrics(SM_CXSCREEN) - DEFAULT_WINDOW_WIDTH) / 2;
        r.top = (GetSystemMetrics(SM_CYSCREEN) - DEFAULT_WINDOW_HEIGHT) / 3; // intended
        r.right = r.left + DEFAULT_WINDOW_WIDTH;
        r.bottom = r.top + DEFAULT_WINDOW_HEIGHT;
        g_dwWindowWidth = DEFAULT_WINDOW_WIDTH;
        g_dwWindowHeight = DEFAULT_WINDOW_HEIGHT;
    }
    else
    {
*/
        r.left = (GetSystemMetrics(SM_CXSCREEN) - bm.bmWidth) / 2;
        r.top = (GetSystemMetrics(SM_CYSCREEN) - bm.bmHeight) / 3; // intended
        r.right = r.left + bm.bmWidth;
        r.bottom = r.top + bm.bmHeight;
//    }

    BUTTON_X_PLACEMENT = g_dwWindowWidth - 80;
    AUTORUN_DESCRIPTION_TOP = g_dwWindowHeight - 100;

    style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
    AdjustWindowRect(&r, style, FALSE);

    g_hMainWindow = CreateWindow(c_szAutoRunClass, szAppTitle, style,
        r.left, r.top, r.right - r.left, r.bottom - r.top, NULL, NULL,
        HINST_THISAPP, hbm);

    //
    // if we got here it's probably safe to show ourselves and pump messages
    //
    if (g_hMainWindow)
    {
        MSG msg;

        for (;;)
        {
            DWORD dwResult = MsgWaitForMultipleObjects(g_cWait, g_ahWait, FALSE,
                INFINITE, QS_ALLINPUT);

            if (dwResult == WAIT_OBJECT_0 + g_cWait)
            {
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (msg.message == WM_QUIT)
                        goto get_out;
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
            else
            {
                dwResult -= WAIT_OBJECT_0;
                if( AutoRunKillProcess( dwResult ) )
                {
                    if( g_fClosed ) {
                        goto get_out;
                    }
                }
            }
        }

    get_out:

        retval = (int)msg.wParam;
    }

//    InstallICWScript( );

im_doug:
    //
    // random cleanup
    //
    if (g_hMouseHook)
    {
        UnhookWindowsHookEx(g_hMouseHook);
//        g_hMouseHook = NULL;
    }

    if (hbm)
        DeleteObject(hbm);

    // delete ini out of temp dir
    GetTempPath( MAX_PATH, szBmpPath );
    lstrcat( szBmpPath, "\\iecd.ini" );
    DeleteFile( szBmpPath );

    return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\brandll\utils.cpp ===
#include "precomp.h"
#include <shlobjp.h>                            // for SHELLSTATE structure only
#include "cabver.h"

// Private forward decalarations
#define SHGetSetSettings 68

void getSetOwnerPrivileges(BOOL fSet);

BOOL InitializeDependancies(BOOL fInit /*= TRUE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, InitializeDependancies)

    static int s_iComRef = 0;

    if (fInit) {
        HRESULT hr;

        // initialize COM
        if (s_iComRef == 0) {
            hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
            if (SUCCEEDED(hr))
                Out(LI1(TEXT("COM initialized with %s success code."), GetHrSz(hr)));

            else if (hr == RPC_E_CHANGED_MODE) {
                hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
                if (SUCCEEDED(hr))
                    Out(LI1(TEXT("COM initialized on a second attempt with %s success code!"), GetHrSz(hr)));
            }

            if (FAILED(hr)) {
                Out(LI1(TEXT("! COM initialization failed with %s."), GetHrSz(hr)));
                return FALSE;
            }
        }
        s_iComRef++;

        MACRO_LI_Offset(-1);                    // last thing to do on init
    }
    else {
        MACRO_LI_Offset(+1);                    // first thing to do on uninit

        // free COM
        if (s_iComRef == 1)
            CoUninitialize();

        if (s_iComRef > 0)
            s_iComRef--;
    }

    return TRUE;
}


HRESULT MoveCabVersionsToHKLM(LPCTSTR pszIns)
{   MACRO_LI_PrologEx_C(PIF_STD_C, MoveCabVersionsToHKLM)

    TCHAR   szInsLine[INTERNET_MAX_URL_LENGTH + 50],
            szVersion[32], szDate[32];
    LPCTSTR rgpszInsInfo[6];
    LPTSTR  pszCabFileURL, pszDelim;
    HKEY    hkNew,    hkOld,
            hkNewCur, hkOldCur;
    DWORD   cchVersion, cchDate,
            dwResult;
    BOOL    fResult;

    Out(LI0(TEXT("Migrating cabs version information to per-machine settings...")));

    // HKLM information exists -> no migration is needed
    dwResult = SHOpenKeyHKLM(RK_IEAK_CABVER, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkNew);
    if (dwResult == ERROR_SUCCESS) {
        SHCloseKey(hkNew);

        SHDeleteKey(g_GetHKCU(), RK_IEAK_CABVER);
        SHDeleteEmptyKey(g_GetHKCU(), RK_IEAK);

        Out(LI0(TEXT("Per-machine settings already exist!")));
        return S_FALSE;
    }

    // no HKCU information -> bail out
    dwResult = SHOpenKey(g_GetHKCU(), RK_IEAK_CABVER, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkOld);
    if (dwResult != ERROR_SUCCESS) {
        Out(LI0(TEXT("! Cabs version information is absent.")));
        return (dwResult == ERROR_FILE_NOT_FOUND) ? E_UNEXPECTED : E_FAIL;
    }

    //----- Main processing -----
    dwResult = SHCreateKeyHKLM(RK_IEAK_CABVER, KEY_CREATE_SUB_KEY | KEY_SET_VALUE, &hkNew);
    if (dwResult != ERROR_SUCCESS)
        return E_FAIL;

    // move version sections of individual cabs
    rgpszInsInfo[0] = IS_CUSTOMBRANDING; rgpszInsInfo[1] = IK_BRANDING;
    rgpszInsInfo[2] = IS_CUSTOMDESKTOP;  rgpszInsInfo[3] = IK_DESKTOP;
    rgpszInsInfo[4] = IS_CUSTOMCHANNELS; rgpszInsInfo[5] = IK_CHANNELS;

    fResult = TRUE;
    for (UINT i = 0; i < countof(rgpszInsInfo); i += 2) {
        GetPrivateProfileString(rgpszInsInfo[i], rgpszInsInfo[i+1], TEXT(""), szInsLine, countof(szInsLine), pszIns);
        if (szInsLine[0] == TEXT('\0'))
            GetPrivateProfileString(IS_CUSTOMVER, rgpszInsInfo[i+1], TEXT(""), szInsLine, countof(szInsLine), pszIns);
        if (szInsLine[0] == TEXT('\0')) {
            fResult = FALSE;
            Out(LI1(TEXT("! Download URL for \"%s\" cab can not be determined."), rgpszInsInfo[i+1]));
            continue;
        }

        dwResult = SHOpenKey(hkOld, rgpszInsInfo[i+1], KEY_QUERY_VALUE, &hkOldCur);
        if (dwResult != ERROR_SUCCESS) {
            fResult = FALSE;
            Out(LI1(TEXT("! Version information for \"%s\" cab is absent."), rgpszInsInfo[i+1]));
            continue;
        }

        dwResult = SHCreateKey(hkNew, rgpszInsInfo[i+1], KEY_SET_VALUE, &hkNewCur);
        if (dwResult != ERROR_SUCCESS) {
            ASSERT(hkOldCur != NULL);
            SHCloseKey(hkOldCur);

            fResult = FALSE;
            continue;
        }

        // cab url
        pszCabFileURL = szInsLine;
        pszDelim      = StrChr(pszCabFileURL, TEXT(','));
        if (pszDelim != NULL)
            *pszDelim = TEXT('\0');
        StrRemoveWhitespace(pszCabFileURL);

        // version
        szVersion[0] = TEXT('\0');
        cchVersion   = sizeof(szVersion);
        RegQueryValueEx(hkOldCur, RV_VERSION, NULL, NULL, (LPBYTE)&szVersion, &cchVersion);

        // date
        szDate[0] = TEXT('\0');
        cchDate   = sizeof(szDate);
        RegQueryValueEx(hkOldCur, RV_DATE, NULL, NULL, (LPBYTE)&szDate, &cchDate);

        RegSetValueEx(hkNewCur, RV_URL,     0, REG_SZ, (LPBYTE)pszCabFileURL, (DWORD)StrCbFromSz(pszCabFileURL));
        RegSetValueEx(hkNewCur, RV_VERSION, 0, REG_SZ, (LPBYTE)szVersion,     cchVersion);
        RegSetValueEx(hkNewCur, RV_DATE,    0, REG_SZ, (LPBYTE)szDate,        cchDate);

        SHCloseKey(hkOldCur);
        SHCloseKey(hkNewCur);
    }

    SHCloseKey(hkOld);
    SHCloseKey(hkNew);

    SHDeleteKey(g_GetHKCU(), RK_IEAK_CABVER);
    SHDeleteEmptyKey(g_GetHKCU(), RK_IEAK);

    Out(LI0(TEXT("Done.")));
    return S_OK;
}


LPCTSTR DecodeTitle(LPTSTR pszTitle, LPCTSTR pszIns)
{
    static BOOL fInit = FALSE,
                fDecode;

    TCHAR   szBuffer[MAX_PATH];
    LPCTSTR pszFrom;
    LPTSTR  pszTo;
    TCHAR   chAux;

    if (!fInit) {
        fDecode = InsGetBool(IS_BRANDING, IK_FAVORITES_ENCODE, FALSE, pszIns);
        fInit   = TRUE;
    }

    if (!fDecode)
        return pszTitle;

    pszFrom = szBuffer;
    pszTo   = pszTitle;
    StrCpy(szBuffer, pszTitle);

    while ((chAux = *pszFrom++) != TEXT('\0'))
        if (chAux != TEXT('%'))
            *pszTo++ = chAux;

        else
            switch (chAux = *pszFrom++) {
                case TEXT('('): *pszTo++ = TEXT('['); break;
                case TEXT(')'): *pszTo++ = TEXT(']'); break;
                case TEXT('-'): *pszTo++ = TEXT('='); break;
                case TEXT('%'): *pszTo++ = TEXT('%'); break;
                case TEXT('/'): *pszTo++ = IsDBCSLeadByte((CHAR)*(pszTo-1)) ? TEXT('\\') : TEXT('/'); break;
                default       : *pszTo++ = TEXT('%'); *pszTo++ = chAux; break;
            }

    *pszTo = TEXT('\0');
    return pszTitle;
}

BOOL SHGetSetActiveDesktop(BOOL fSet, PBOOL pfValue)
{   MACRO_LI_PrologEx_C(PIF_STD_C, SHGetSetActiveDesktop)

    typedef void (WINAPI *PFNSHGETSET)(LPSHELLSTATE, DWORD, BOOL);

    SHELLSTATE  ss;
    PFNSHGETSET pfnSHGetSet;
    HINSTANCE   hShell32Dll;
    BOOL        fResult;

    if (pfValue == NULL)
        return FALSE;
    fResult = FALSE;

    hShell32Dll = LoadLibrary(TEXT("shell32.dll"));
    if (hShell32Dll == NULL) {
        Out(LI0(TEXT("! \"shell32.dll\" could not be loaded.")));
        goto Exit;
    }

    pfnSHGetSet = (PFNSHGETSET)GetProcAddress(hShell32Dll, (LPCSTR)SHGetSetSettings);
    if (pfnSHGetSet == NULL) {
        Out(LI0(TEXT("! \"SHGetSetSettings\" in shell32.dll was not found.")));
        goto Exit;
    }

    ZeroMemory(&ss, sizeof(ss));
    if (fSet)
        ss.fDesktopHTML = *pfValue;

    // NOTE: (andrewgu) unicode vs. ansi issue. we are fine here even though on w95/ie4/ad4
    // shell32.dll is ansi. we may end up calling with unicode SHELLSTATE on this platform and get
    // back ansi stuff. the only variable were it matters is pszHiddenFileExts, which we never
    // reference.
    (*pfnSHGetSet)(&ss, SSF_DESKTOPHTML, fSet);

    if (!fSet)
        *pfValue = ss.fDesktopHTML;

    fResult = TRUE;

Exit:
    if (hShell32Dll != NULL)
        FreeLibrary(hShell32Dll);

    return fResult;
}

HRESULT SHGetFolderLocationSimple(int nFolder, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    hr = E_FAIL;
    if (!IsOS(OS_NT5)) {
        nFolder &= ~CSIDL_FLAG_MASK;
        hr       = SHGetSpecialFolderLocation(NULL, nFolder, ppidl);
    }
    else {
        // need to call NT5 version in case we need to impersonate the user
        HINSTANCE hShell32Dll;

        if (NULL != ppidl)
            *ppidl = NULL;

        hShell32Dll = LoadLibrary(TEXT("shell32.dll"));
        if (NULL != hShell32Dll) {
            typedef HRESULT (WINAPI *PSHGETFOLDERLOCATION)(HWND, int, HANDLE, DWORD, LPITEMIDLIST *);

            PSHGETFOLDERLOCATION pfnSHGetFolderLocation;

            pfnSHGetFolderLocation = (PSHGETFOLDERLOCATION)GetProcAddress(hShell32Dll, "SHGetFolderLocation");
            if (NULL != pfnSHGetFolderLocation)
                hr = pfnSHGetFolderLocation(NULL, nFolder, g_GetUserToken(), 0, ppidl);

            FreeLibrary(hShell32Dll);
        }
    }

    return hr;
}


LPCTSTR GetIEPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{
    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        PTSTR pszAux;
        LONG  lResult;

        s_dwSize = sizeof(s_szPath);
        lResult = SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\iexplore.exe"), RV_PATH, NULL, (LPBYTE)&s_szPath, &s_dwSize);
        if (lResult != ERROR_SUCCESS)
            return NULL;

        ASSERT(s_dwSize > 0);
        s_dwSize /= sizeof(TCHAR);
        s_dwSize--;

        if (StrRemoveWhitespace(s_szPath))
            s_dwSize = StrLen(s_szPath);

        ASSERT(s_dwSize > 0);
        if (s_szPath[s_dwSize - 1] == TEXT(';')) {
            s_szPath[s_dwSize - 1] = TEXT('\0');
            s_dwSize--;
        }

        pszAux = PathRemoveBackslash(s_szPath);
        if (*pszAux == TEXT('\0'))              // backslash was removed
            s_dwSize--;
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetWebPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetWebPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (g_CtxIsGp())
    {
        StrCpy(s_szPath, g_GetTargetPath());
        s_dwSize = StrLen(s_szPath) + 1;
    }
    else
    {
        if (s_szPath[0] == TEXT('\0')) {
            s_dwSize = GetWindowsDirectory(s_szPath, countof(s_szPath));
            
            PathAppend(s_szPath, FOLDER_WEB);
            s_dwSize += 1 + countof(FOLDER_WEB)-1;
            
            Out(LI1(TEXT("<Web> folder location is \"%s\"."), s_szPath));
        }
        else
            ASSERT(s_dwSize > 0);
    }

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetFavoritesPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetFavoritesPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        if (FAILED(SHGetFolderPathSimple(CSIDL_FAVORITES, s_szPath)))
            return NULL;

        s_dwSize = StrLen(s_szPath);
        Out(LI1(TEXT("<Favorites> folder location is \"%s\"."), s_szPath));
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetChannelsPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetChannelsPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        TCHAR   szFolder[MAX_PATH];
        LPCTSTR pszFavoritesPath;

        pszFavoritesPath = GetFavoritesPath();
        if (pszFavoritesPath == NULL)
            return NULL;

        szFolder[0] = TEXT('\0');
        LoadString(g_GetHinst(), IDS_FOLDER_CHANNELS, szFolder, countof(szFolder));
        if (szFolder[0] == TEXT('\0'))
            return NULL;

        PathCombine(s_szPath, pszFavoritesPath, szFolder);
        s_dwSize = StrLen(s_szPath);

        if (!PathFileExists(s_szPath))
            return NULL;

        Out(LI1(TEXT("<Channels> folder location is \"%s\"."), s_szPath));
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetSoftwareUpdatesPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetSoftwareUpdatesPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        TCHAR   szFolder[MAX_PATH];
        LPCTSTR pszFavoritesPath;

        pszFavoritesPath = GetFavoritesPath();
        if (pszFavoritesPath == NULL)
            return NULL;

        szFolder[0] = TEXT('\0');
        LoadString(g_GetHinst(), IDS_FOLDER_SOFTWAREUPDATES, szFolder, countof(szFolder));
        if (szFolder[0] == TEXT('\0'))
            return NULL;

        PathCombine(s_szPath, pszFavoritesPath, szFolder);
        s_dwSize = StrLen(s_szPath);

        if (!PathFileExists(s_szPath))
            return NULL;

        Out(LI1(TEXT("<Software Updates> folder location is \"%s\"."), s_szPath));
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetLinksPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetLinksPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        TCHAR   szFolder[MAX_PATH];
        LPCTSTR pszFavoritesPath;

        pszFavoritesPath = GetFavoritesPath();
        if (pszFavoritesPath == NULL)
            return NULL;

        szFolder[0] = TEXT('\0');
        LoadString(g_GetHinst(), IDS_FOLDER_LINKS, szFolder, countof(szFolder));
        if (szFolder[0] == TEXT('\0'))
            return NULL;

        PathCombine(s_szPath, pszFavoritesPath, szFolder);
        s_dwSize = StrLen(s_szPath);

        if (!PathFileExists(s_szPath))
            return NULL;

        Out(LI1(TEXT("<Links> folder location is \"%s\"."), s_szPath));
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetQuickLaunchPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetQuickLinksPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        HRESULT hr;
        TCHAR szAux[MAX_PATH];

        hr = SHGetFolderPathSimple(CSIDL_APPDATA, s_szPath);
        if (FAILED(hr))
            GetWindowsDirectory(s_szPath, countof(s_szPath));
        
        LoadString(g_GetHinst(), IDS_FOLDER_QUICKLAUNCH, szAux, countof(szAux));

        PathAppend(s_szPath, TEXT("Microsoft\\Internet Explorer"));
        PathAppend(s_szPath, szAux);
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

BOOL CreateWebFolder()
{
    LPCTSTR pszWebPath;

    pszWebPath = GetWebPath();
    if (pszWebPath == NULL)
        return FALSE;

    if (PathFileExists(pszWebPath))
        return TRUE;

    return CreateDirectory(pszWebPath, NULL);
}


static MAPDW2PSZ
    s_rgZonesHKCU     [] = { { FF_ENABLE, RV_BF_ZONES_HKCU         } },
    s_rgZonesHKLM     [] = { { FF_ENABLE, RV_BF_ZONES_HKLM         } },
    s_rgRatings       [] = { { FF_ENABLE, RV_BF_RATINGS            } },
    s_rgAuthcode      [] = { { FF_ENABLE, RV_BF_AUTHCODE           } },
    s_rgPrograms      [] = { { FF_ENABLE, RV_BF_PROGRAMS           } },
    s_rgGeneral       [] = {
        { FF_GEN_TITLE,        RV_BF_TITLE        },
        { FF_GEN_HOMEPAGE,     RV_BF_HOMEPAGE     },
        { FF_GEN_SEARCHPAGE,   RV_BF_SEARCHPAGE   },
        { FF_GEN_HELPPAGE,     RV_BF_HELPPAGE     },
        { FF_GEN_UASTRING,     RV_BF_UASTRING     },
        { FF_GEN_TOOLBARBMP,   RV_BF_TOOLBARBMP   },
        { FF_GEN_STATICLOGO,   RV_BF_STATICLOGO   },
        { FF_GEN_ANIMATEDLOGO, RV_BF_ANIMATEDLOGO },
        { FF_GEN_TBICONTHEME,  RV_BF_TBICONTHEME  }
//      not required in the GP context
//      { FF_GEN_FIRSTHOMEPAGE,RV_BF_FIRSTHOMEPAGE}
    },
    s_rgToolbarButtons[] = { { FF_ENABLE, RV_BF_TOOLBARBUTTONS     } },
    s_rgFavorites     [] = { { FF_ENABLE, RV_BF_FAVORITES          } },
    s_rgConSettings   [] = { { FF_ENABLE, RV_BF_CONNECTIONSETTINGS } },
    s_rgChannels      [] = { { FF_ENABLE, RV_BF_CHANNELS           } };

static struct {
    PMAPDW2PSZ pmapFlagToRegValue;
    UINT       cMapEntries;
} s_mapFidToRegInfo[] = {
    { NULL,               0                           },    // FID_CLEARBRANDING
    { NULL,               0                           },    // FID_MIGRATEOLDSETTINGS
    { NULL,               0                           },    // FID_WININETSETUP
    { NULL,               0                           },    // FID_CS_DELETE
    { s_rgZonesHKCU,      countof(s_rgZonesHKCU)      },    // FID_ZONES_HKCU
    { s_rgZonesHKLM,      countof(s_rgZonesHKLM)      },    // FID_ZONES_HKLM
    { s_rgRatings,        countof(s_rgRatings)        },    // FID_RATINGS
    { s_rgAuthcode,       countof(s_rgAuthcode)       },    // FID_AUTHCODE
    { s_rgPrograms,       countof(s_rgPrograms)       },    // FID_PROGRAMS
    { NULL,               0                           },    // FID_EXTREGINF_HKLM
    { NULL,               0                           },    // FID_EXTREGINF_HKCU
    { NULL,               0                           },    // FID_LCY50_EXTREGINF
    { s_rgGeneral,        countof(s_rgGeneral)        },    // FID_GENERAL
    { NULL,               0                           },    // FID_CUSTOMHELPVER
    { s_rgToolbarButtons, countof(s_rgToolbarButtons) },    // FID_TOOLBARBUTTONS
    { NULL,               0                           },    // FID_ROOTCERT
    { NULL,               0                           },    // FID_FAV_DELETE
    { s_rgFavorites,      countof(s_rgFavorites)      },    // FID_FAV_MAIN
    { NULL,               0                           },    // FID_FAV_ORDER
    { NULL,               0                           },    // FID_QL_MAIN
    { NULL,               0                           },    // FID_QL_ORDER
    { s_rgConSettings,    countof(s_rgConSettings)    },    // FID_CS_MAIN
    { NULL,               0                           },    // FID_TPL
    { NULL,               0                           },    // FID_CD_WELCOME
    { NULL,               0                           },    // FID_ACTIVESETUPSITES
    { NULL,               0                           },    // FID_LINKS_DELETE
    { NULL,               0                           },    // FID_OUTLOOKEXPRESS
    { NULL,               0                           },    // FID_LCY4X_ACTIVEDESKTOP
    { s_rgChannels,       countof(s_rgChannels)       },    // FID_LCY4X_CHANNELS
    { NULL,               0                           },    // FID_LCY4X_SOFTWAREUPDATES
    { NULL,               0                           },    // FID_LCY4X_WEBCHECK
    { NULL,               0                           },    // FID_LCY4X_CHANNELBAR
    { NULL,               0                           },    // FID_LCY4X_SUBSCRIPTIONS
    { NULL,               0                           }     // FID_REFRESHBROWSER
};

BOOL SetFeatureBranded(UINT nID, DWORD dwFlags /*= FF_ENABLE*/)
{
    PMAPDW2PSZ pMap;
    HKEY       hk;
    DWORD      dwValue;
    UINT       cMapEntries,
               i;

    if (!g_CtxIsGp() || g_CtxIs(CTX_MISC_PREFERENCES))
        return FALSE;

    if (nID < FID_FIRST || nID >= FID_LAST)
        return FALSE;

    pMap        = s_mapFidToRegInfo[nID].pmapFlagToRegValue;
    cMapEntries = s_mapFidToRegInfo[nID].cMapEntries;
    if (NULL == pMap || 0 == cMapEntries)
        return FALSE;

    hk = NULL;
    SHCreateKey(g_GetHKCU(), RK_IEAK_BRANDED, KEY_SET_VALUE, &hk);
    if (NULL == hk)
        return FALSE;

    for (i = 0; i < cMapEntries; i++) {
        if (HasFlag((pMap + i)->dw, dwFlags) || ((pMap + i)->dw == dwFlags)) {
            dwValue = FF_ENABLE;
            RegSetValueEx(hk, (pMap + i)->psz, 0, REG_DWORD, (PBYTE)&dwValue, sizeof(dwValue));
        }
    }

    SHCloseKey(hk);
    return TRUE;
}

DWORD GetFeatureBranded(UINT nID)
{
    PMAPDW2PSZ pMap;
    HKEY       hk;
    DWORD      dwValue, cValue,
               dwResult;
    UINT       cMapEntries,
               i;

    dwResult = FF_DISABLE;

    if (!g_CtxIsGp())
        return dwResult;

    if (nID < FID_FIRST || nID >= FID_LAST)
        return dwResult;

    pMap        = s_mapFidToRegInfo[nID].pmapFlagToRegValue;
    cMapEntries = s_mapFidToRegInfo[nID].cMapEntries;
    if (NULL == pMap || 0 == cMapEntries)
        return dwResult;

    // PERF: <oliverl> we should really look into caching this whole key since we go
    // through this code path so frequently

    hk = NULL;
    SHOpenKey(g_GetHKCU(), RK_IEAK_BRANDED, KEY_QUERY_VALUE, &hk);
    if (NULL == hk)
        return dwResult;

    for (i = 0; i < cMapEntries; i++) {
        if (S_OK != SHValueExists(hk, (pMap + i)->psz))
            continue;

        dwValue = FF_DISABLE;
        cValue  = sizeof(dwValue);
        RegQueryValueEx(hk, (pMap + i)->psz, NULL, NULL, (PBYTE)&dwValue, &cValue);

        if (FF_DISABLE != dwValue) {
            if (FF_DISABLE == dwResult)
                dwResult = 0;

            SetFlag(&dwResult, (pMap + i)->dw);
        }
    }

    SHCloseKey(hk);
    return dwResult;
}


/////////////////////////////////////////////////////////////////////////////
// CreateCustomBrandingCabUI, ShowUIDlgProc, ShowUIThreadProc

DWORD    WINAPI   ShowUIThreadProc(LPVOID);
INT_PTR  CALLBACK ShowUIDlgProc(HWND hDlg, UINT uMsg, WPARAM, LPARAM);

HWND  s_hDlg;
HICON s_hIcon;
BOOL  s_fDialogInit = FALSE;

BOOL CreateCustomBrandingCabUI(BOOL fCreate /*= TRUE*/)
{
    static HANDLE s_hThread = NULL;

    MSG    msg;
    DWORD  dwThreadID; 

    if (fCreate) {
        s_hThread = CreateThread(NULL, 4096, ShowUIThreadProc, NULL, 0, &dwThreadID);
        ASSERT(s_hThread != NULL);
    }
    else
        if (s_hThread != NULL) {
            while (s_fDialogInit == FALSE)
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }

            PostMessage(s_hDlg, WM_CLOSE, 0, 0L);

            while (MsgWaitForMultipleObjects(1, &s_hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }

            CloseHandle(s_hThread);
        }

    return TRUE;
}

DWORD WINAPI ShowUIThreadProc(LPVOID)
{
    TCHAR szIcon[MAX_PATH];

    GetWindowsDirectory(szIcon, countof(szIcon));
    PathAppend(szIcon, TEXT("cursors\\globe.ani"));
    
    s_hIcon = (HICON)LoadImage(NULL, szIcon, IMAGE_ICON, 0, 0, LR_LOADFROMFILE);

    DialogBox(g_GetHinst(), MAKEINTRESOURCE(IDD_DISPLAY), NULL, ShowUIDlgProc);
   
    if (s_hIcon != NULL)
        DestroyIcon(s_hIcon);
    s_hIcon = NULL;

    return 0L;
}

INT_PTR CALLBACK ShowUIDlgProc(HWND hDlg, UINT uMsg, WPARAM, LPARAM)
{
    switch (uMsg) {
        case WM_INITDIALOG:
            s_hDlg = hDlg;
            if (s_hIcon != NULL)
                SendDlgItemMessage(hDlg, IDC_ANIM, STM_SETICON, (WPARAM)s_hIcon, 0);
            s_fDialogInit = TRUE;
            break;

        case WM_CLOSE:
            EndDialog(hDlg, 0);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Miscellaneous

BOOL BackToIE3orLower()
{
    TCHAR szPrevIEVer[32];
    DWORD dwResult,
          dwSize;
    BOOL  fResult;

    fResult  = FALSE;
    dwSize   = sizeof(szPrevIEVer);
    dwResult = SHGetValue(HKEY_LOCAL_MACHINE, RK_IE4SETUP, TEXT("PreviousIESysFile"), NULL, (LPVOID)szPrevIEVer, &dwSize);
    if (dwResult == ERROR_SUCCESS) {
        SCabVersion cvPrevIE, cvIE4;

        // IE3's version is 4.70.xxxx.xx; so check against the major number of IE4
        if (cvPrevIE.Init(szPrevIEVer) && cvIE4.Init(TEXT("4.71.0.0")))
            fResult = (cvPrevIE < cvIE4);
    }

    return fResult;
}


void Out(PCTSTR pszMsg)
{
    USES_CONVERSION;

    DWORD dwWritten;

    if (pszMsg == NULL)
        return;

    if (g_hfileLog == NULL)
        return;

    WriteFile(g_hfileLog, T2CA(pszMsg), StrLen(pszMsg), &dwWritten, NULL);

    if (g_fFlushEveryWrite)
        FlushFileBuffers(g_hfileLog);
}

void OutD(PCTSTR pszMsg)
{
    UNREFERENCED_PARAMETER(pszMsg);
    DEBUG_CODE(Out(pszMsg));
}

void WINAPIV OutEx(PCTSTR pszFmt ...)
{
    USES_CONVERSION;

    TCHAR szMessage[3 * MAX_PATH];
    DWORD dwWritten;
    UINT  nLen;

    if (pszFmt == NULL)
        return;

    if (g_hfileLog == NULL)
        return;

    va_list  arglist;
    va_start(arglist, pszFmt);
    nLen = wvnsprintf(szMessage, countof(szMessage), pszFmt, arglist);
    va_end(arglist);

    WriteFile(g_hfileLog, T2CA(szMessage), nLen, &dwWritten, NULL);

    if (g_fFlushEveryWrite)
        FlushFileBuffers(g_hfileLog);
}


// REVIEW: (andrewgu) the following API isused by CloseRASConnections only
void TimerSleep(UINT nMilliSecs)
{
    MSG      msg;
    UINT_PTR idTimer;
    DWORD    dwInitTick;

    idTimer = SetTimer(NULL, 0, nMilliSecs, NULL);
    if (idTimer == 0)
        return;

    dwInitTick = GetTickCount();
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);

        if (msg.message == WM_TIMER && GetTickCount() >= dwInitTick + nMilliSecs)
            break;
    }

    KillTimer(NULL, idTimer);
}

UINT GetFlagsNumber(DWORD dwFlags)
{
    UINT nMaxFlags,
         i, cchFlags;

    if (dwFlags == 0)
        return 0;

    nMaxFlags = sizeof(DWORD) * 8;
    if (dwFlags == (DWORD)-1)
        return nMaxFlags;

    for (cchFlags = 0, i = 0; i < nMaxFlags; i++)
        if (HasFlag(dwFlags, 1 << i))
            cchFlags++;

    return cchFlags;
}

BOOL SetUserFileOwner(HANDLE hUserToken, LPCTSTR pcszPath)
{
    SECURITY_DESCRIPTOR SecDesc;
    PTOKEN_USER pTokenUser = NULL;
    PSID pSidUser = NULL;
    DWORD dwSize;
    BOOL fToken = FALSE;
    BOOL bRet = FALSE;
    
    getSetOwnerPrivileges(TRUE);

    dwSize = 0;
    pTokenUser = (PTOKEN_USER)CoTaskMemAlloc(sizeof(TOKEN_USER));

    if (pTokenUser == NULL)
        return FALSE;

    fToken = GetTokenInformation(hUserToken, TokenUser, pTokenUser, sizeof(TOKEN_USER), &dwSize);
    
    if (!fToken && (dwSize > sizeof(TOKEN_USER)))
    {
        CoTaskMemFree(pTokenUser);
        pTokenUser = (PTOKEN_USER)CoTaskMemAlloc(dwSize);
        if (pTokenUser != NULL)
            fToken = GetTokenInformation(hUserToken, TokenUser, pTokenUser, dwSize, &dwSize); 
    }
    
    if ((pTokenUser != NULL) && fToken)
    {
        dwSize = GetLengthSid(pTokenUser->User.Sid);
        pSidUser = (PSID)CoTaskMemAlloc(dwSize);
        
        if ((pSidUser != NULL) && (CopySid(dwSize, pSidUser, pTokenUser->User.Sid)))
        {
            if (InitializeSecurityDescriptor(&SecDesc, SECURITY_DESCRIPTOR_REVISION) &&
                SetSecurityDescriptorOwner(&SecDesc, pSidUser, FALSE))
            {
                bRet = SetFileSecurity(pcszPath, OWNER_SECURITY_INFORMATION, &SecDesc);
            }
        }
    }
    
    if (pTokenUser != NULL)
        CoTaskMemFree(pTokenUser);
    
    if (pSidUser != NULL)
        CoTaskMemFree(pSidUser);

    getSetOwnerPrivileges(FALSE);

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

void ShortPathName(LPTSTR pszFilename)
{
    UNREFERENCED_PARAMETER(pszFilename);
}

// this code ripped off from folder redirection in windows\gina\fdeploy\utils.cxx

TCHAR* NTPrivs[] = {
    SE_TAKE_OWNERSHIP_NAME,     //we only need take ownership privileges
    SE_RESTORE_NAME,            //we only need to be able to assign owners
    TEXT("\0")
};

void getSetOwnerPrivileges(BOOL fSet)
{
    static  DWORD s_dwTakeOwnerVal = 0xFFFFFFFF;
    static  DWORD s_dwRestoreNameVal = 0xFFFFFFFF;
    BOOL    bStatus;
    DWORD   dwSize = 0;
    DWORD   i, j;
    DWORD   dwPrivCount;
    PTOKEN_PRIVILEGES pPrivs = NULL;
    PTOKEN_PRIVILEGES pTokenPriv = NULL;
    HANDLE  hToken;
    
    //try to get all the windows NT privileges.
    for (i=0, dwPrivCount=0; *NTPrivs[i]; i++)
        dwPrivCount++;
    
    dwSize = sizeof (LUID_AND_ATTRIBUTES) * (dwPrivCount - 1) +
        sizeof(TOKEN_PRIVILEGES);
    
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
    {
        pPrivs = (PTOKEN_PRIVILEGES) CoTaskMemAlloc(dwSize);
        
        if (pPrivs != NULL)
        {    
            BOOL fToken = FALSE;
    
            if (fSet)
            {
                pTokenPriv = (PTOKEN_PRIVILEGES)CoTaskMemAlloc(sizeof(TOKEN_PRIVILEGES));

                fToken = GetTokenInformation(hToken, TokenPrivileges, pTokenPriv, sizeof(TOKEN_PRIVILEGES), &dwSize);
    
                if (!fToken && (dwSize > sizeof(TOKEN_PRIVILEGES)))
                {
                    CoTaskMemFree(pTokenPriv);
                    pTokenPriv = (PTOKEN_PRIVILEGES)CoTaskMemAlloc(dwSize);
                    if (pTokenPriv != NULL)
                        fToken = GetTokenInformation(hToken, TokenPrivileges, pTokenPriv, dwSize, &dwSize); 
                }
            }

            for (i=0, dwPrivCount = 0; *NTPrivs[i]; i++)
            {
                bStatus = LookupPrivilegeValue(NULL, NTPrivs[i], &(pPrivs->Privileges[dwPrivCount].Luid));
                if (!bStatus)
                    continue;

                if (fSet)
                {
                    if (fToken && (pTokenPriv != NULL))
                    {
                        for (j = 0; j < pTokenPriv->PrivilegeCount; j++)
                        {
                            TCHAR szName[MAX_PATH];

                            dwSize = countof(szName);
                            if (LookupPrivilegeName(TEXT(""), &(pTokenPriv->Privileges[j].Luid), szName, &dwSize) &&
                                (StrCmpI(szName, NTPrivs[i]) == 0))
                            {
                                if (i == 0)
                                    s_dwTakeOwnerVal = pTokenPriv->Privileges[j].Attributes;
                                else
                                    s_dwRestoreNameVal = pTokenPriv->Privileges[j].Attributes;
                            }
                        }
                    }
                    pPrivs->Privileges[dwPrivCount++].Attributes = SE_PRIVILEGE_ENABLED;
                }
                else
                {
                    if (i == 0) 
                        pPrivs->Privileges[dwPrivCount].Attributes = s_dwTakeOwnerVal;
                    else
                        pPrivs->Privileges[dwPrivCount].Attributes = s_dwRestoreNameVal;

                    if (pPrivs->Privileges[dwPrivCount].Attributes != 0xFFFFFFFF)
                        dwPrivCount++;
                }
            }
            
            pPrivs->PrivilegeCount = dwPrivCount;
            
            AdjustTokenPrivileges(hToken, FALSE, pPrivs, NULL, NULL, NULL);
                                    
            CoTaskMemFree(pPrivs);

            if (pTokenPriv != NULL)
                CoTaskMemFree(pTokenPriv);
        }
        CloseHandle(hToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\autorun\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// the following resources are defined once for the whole app
//
///////////////////////////////////////////////////////////////////////////////

// waveforms
#define IDW_STARTAPP        1
#define IDW_INSTALL         4
#define IDW_DEMO            5

// bitmaps
#define IDB_4BPP_BACKDROP        200
#define IDB_8BPP_BACKDROP        201
#define IDB_8BPP_BUTTONS         202

// strings
#define IDS_APPTITLE            1
#define IDS_NEEDCDROM           2
#define IDS_LABELFONT           8
#define IDS_LABELHEIGHT         9
#define IDS_STARTPAGE           10
#define IDS_SEARCHPAGE          11
#define IDS_IERUNNINGMSG        13
#define IDS_MAINTEXT            21

// string group helpers
#define IDS_TITLE(item)     ((item) + 1)
#define IDS_INFO(item)      ((item) + 2)
#define IDS_CMD(item)       ((item) + 3)
#define IDS_DIR(item)       ((item) + 4)

#define IDI_ICON(item)      (MAKEINTRESOURCE(item))

//
// string groups
// resource compiler doesn't expand macros
// so all these are declared as separate ids
//
#define IEFROMCD                100
#define IDS_TITLE_IEFROMCD      101
#define IDS_CMD_IEFROMCD        103
#define IDS_DIR_IEFROMCD        104
#define IESETUP                 110
#define IDS_TITLE_IESETUP       111
#define IDS_CMD_IESETUP         113
#define IDS_DIR_IESETUP         114
#define IDS_CMD_MSN             141
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\closeie\closeie.c ===
#include <windows.h>

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    HWND hwndIE;

    if ((hwndIE = FindWindow("IEFrame", NULL)) != NULL  ||
        (hwndIE = FindWindow("Internet Explorer_Frame", NULL)) != NULL  ||
        (hwndIE = FindWindow("CabinetWClass", NULL)) != NULL)
        PostMessage(hwndIE, WM_CLOSE, (WPARAM) 0, (LPARAM) 0);

    if ((hwndIE = FindWindow("IECD", NULL)) != NULL)
        PostMessage(hwndIE, WM_CLOSE, (WPARAM) 0, (LPARAM) 0);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\detect\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// the following resources are defined once for the whole app
//
///////////////////////////////////////////////////////////////////////////////

// icons
#define IDI_CDSTARTAPP      1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\detect\detect.c ===
#include <windows.h>
#include <shellapi.h>
#include <string.h>
#include "resource.h"

//---------------------------------------------------------------------------
// appwide globals

char g_szCurrentDir[MAX_PATH];
char g_szCodePage[32];

//---------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;    // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;        // stripped something
    }
}

//---------------------------------------------------------------------------
void ExecuteAutorun()
{
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];
    char szAutorunApp[MAX_PATH];
    char szDir[MAX_PATH];
    char szLang[8];
    BOOL fExecuted = FALSE;

    lstrcpy( szTmpPath, g_szCurrentDir );
    lstrcat( szTmpPath, "\\locale.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "locale.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    if (GetPrivateProfileString("Locale", g_szCodePage, "", szLang, sizeof(szLang), szIniPath))
    {
        lstrcpy( szDir, g_szCurrentDir );
        lstrcat( szDir, szLang );
        lstrcat( szDir, TEXT("bin\\") );
        lstrcpy( szAutorunApp, szDir );
        lstrcat( szAutorunApp, "IECD.exe" );

        if (GetFileAttributes(szAutorunApp) != 0xFFFFFFFF)
        {
            ShellExecute( NULL, NULL, szAutorunApp, " ", szDir, SW_SHOWNORMAL );
            fExecuted = TRUE;
        }
    }
    
    if( !fExecuted )
    {
        GetPrivateProfileString( "Locale", "Default", "\\EN\\", szLang, sizeof(szLang), szIniPath );
        lstrcpy( szDir, g_szCurrentDir );
        lstrcat( szDir, szLang );
        lstrcat( szDir, TEXT("bin\\") );
        lstrcpy( szAutorunApp, szDir );
        lstrcat( szAutorunApp, "IECD.exe" );
        ShellExecute( NULL, NULL, szAutorunApp, " ", szDir, SW_SHOWNORMAL );
    }
}

//---------------------------------------------------------------------------
void GetCodePage( )
{
    DWORD dwLCID;

    dwLCID = GetSystemDefaultLCID();

    if (dwLCID > 0x00000FFF)
        wsprintf(g_szCodePage, "0000%x", dwLCID);
    else
        wsprintf(g_szCodePage, "00000%x", dwLCID);
}

//---------------------------------------------------------------------------
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}

//---------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    GetModuleFileName(NULL, g_szCurrentDir, sizeof(g_szCurrentDir));
    _PathRemoveFileSpec(g_szCurrentDir);

    if (lstrlen(g_szCurrentDir) == 3)
        g_szCurrentDir[2] = '\0';

    GetCodePage();
    ExecuteAutorun();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\isk3ro\resource.h ===
#define IDS_CDMESSAGE   100
#define IDS_CDTITLE     101
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\iskrun\iskrun.c ===
#include <windows.h>
#include <shellapi.h>
#include "resource.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define ISK_CLOSEAPP    WM_USER + 0x021

HINSTANCE g_hInst;

char g_szTemp[1024];
char g_szTemp2[1024];

//-------------------------------------------------------------------------
//
//      R E S  2  S T R
//
//
//  Converts a resource identifier into a character pointer
//-------------------------------------------------------------------------
char *Res2Str(int nString)
{
    static BOOL fSet = FALSE;

    if(fSet)
    {
        LoadString(g_hInst, nString, g_szTemp, ARRAYSIZE(g_szTemp));
        fSet = FALSE;
        return(g_szTemp);
    }

    LoadString(g_hInst, nString, g_szTemp2, ARRAYSIZE(g_szTemp2));
    fSet = TRUE;
    return(g_szTemp2);
}
//-------------------------------------------------------------------------
//
//      P A T H  R E M O V E  F I L E  S P E C
//
//
//  Removes the file name from a path
//-------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything
    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;    // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}
//-------------------------------------------------------------------------
//
//      F I L E  E X I S T S
//
//
//  Checks to see if a file exists and returns true if it does
//-------------------------------------------------------------------------
BOOL FileExists( char *pszFile )
{
    return (GetFileAttributes( pszFile ) != -1 );
}
//-------------------------------------------------------------------------
//
//      E X E C  A P P
//
//
//  Executes and application and returns the process handle
//-------------------------------------------------------------------------
HANDLE ExecApp( char *command, char *params, char *dir, int nWinState )
{
    SHELLEXECUTEINFO sei;
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = "Open";
    sei.lpFile = command;
    sei.lpParameters = params;
    sei.lpDirectory = dir;
    sei.nShow = nWinState;
    sei.cbSize = sizeof(sei);

    if( ShellExecuteEx(&sei) )
        return sei.hProcess;

    return NULL;
}

int WINAPI WinMain( HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow )
{
    HANDLE hProcess;
    char szCommand[MAX_PATH];
    char szParams[MAX_PATH];
    char szDir[MAX_PATH];
    char szTemp[1024];
    char szRetPage[1024];
    BOOL fRetPage = FALSE;
    HWND hIskRo;
    HWND hISW;

    g_hInst = hInst;

    if( lstrlen( lpCmdLine ) == 0 )
        return FALSE;

    if( !FileExists( lpCmdLine ) )
        return FALSE;

    if( GetPrivateProfileInt( "ISK", "NoNT", 0, lpCmdLine ) == 1 )
    {
        OSVERSIONINFO osver;

        osver.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

        GetVersionEx( &osver );

        if( osver.dwMajorVersion < 4 || osver.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            MessageBox( NULL, Res2Str( IDS_WINNT ), Res2Str( IDS_TITLE ), MB_OK | MB_SETFOREGROUND );
            return FALSE;
        }
    }

    if( GetPrivateProfileInt( "ISK", "CloseIE", 0, lpCmdLine ) == 1 )
    {
        HWND hwndIE;

        fRetPage = TRUE;

        hwndIE=FindWindow("IEFrame",NULL);
        if(hwndIE!=NULL)
        {
            PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
        }
        else if ((hwndIE=FindWindow("Internet Explorer_Frame",NULL))!=NULL)
        {
            PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
        }
        else
        {
            hwndIE=FindWindow("CabinetWClass",NULL);
            if(hwndIE!=NULL)
            {
                PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
            }
        }

        hwndIE=FindWindow("IECD",NULL);
        if(hwndIE!=NULL)
        {
            PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
        }
    }

    if( GetPrivateProfileInt( "ISK", "RunIExplore", 0, lpCmdLine ) == 1 )
    {
        char szPage[MAX_PATH];

        GetPrivateProfileString( "ISK", "Params", "", szParams, MAX_PATH, lpCmdLine );

        lstrcpy( szDir, lpCmdLine );
        _PathRemoveFileSpec( szDir );

        wsprintf( szPage, "file://%s\\%s", szDir, szParams );

        hProcess = ExecApp( "IEXPLORE.EXE", szPage, szDir, SW_SHOWNORMAL );
    }
    else
    {
        GetPrivateProfileString( "ISK", "Command", "", szCommand, MAX_PATH, lpCmdLine );
        GetPrivateProfileString( "ISK", "Params", "", szParams, MAX_PATH, lpCmdLine );

        lstrcpy( szDir, lpCmdLine );
        _PathRemoveFileSpec( szDir );

        hProcess = ExecApp( szCommand, szParams, szDir, SW_SHOWNORMAL );
    }
    if( fRetPage )
    {
        if( hProcess )
        {
            DWORD dwResult;
            while((dwResult=MsgWaitForMultipleObjects(1, &hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
            {
                MSG msg;
                // read all of the messages in this next loop
                // removing each message as we read it
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if( msg.message == WM_QUIT )
                        goto get_out;
                    DefWindowProc( msg.hwnd, msg.message, msg.wParam, msg.lParam );
//                    DispatchMessage( &msg );
                }
            }
        }

get_out:

//        WaitForSingleObject( hProcess, INFINITE );


        hISW = FindWindow( NULL, Res2Str( IDS_ISW ) );
        if( hISW != NULL )
        {
            DWORD dwProcessId;
            HANDLE hProcess;

            GetWindowThreadProcessId( hISW, &dwProcessId );
            hProcess = OpenProcess( PROCESS_ALL_ACCESS, TRUE, dwProcessId );
            if( hProcess )
            {
                DWORD dwResult;
                while((dwResult=MsgWaitForMultipleObjects(1, &hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
                {
                    MSG msg;
                    // read all of the messages in this next loop
                    // removing each message as we read it
                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    {
                        if( msg.message == WM_QUIT )
                            goto get_out2;
                        DefWindowProc( msg.hwnd, msg.message, msg.wParam, msg.lParam );
                    }
                }
            }
        }
get_out2:

        GetPrivateProfileString( "ISK", "RetPage", "", szTemp, 1024, lpCmdLine );

        if( lstrlen( szTemp ) > 0 )
        {
            wsprintf( szRetPage, "%s\\%s", szDir, szTemp );
            ExecApp( "IECD.EXE", szRetPage, "", SW_SHOWNORMAL );
        }

        Sleep( 2000 );

        hIskRo = FindWindow( "ISK3RO", NULL );
        if( hIskRo ) SendMessage( hIskRo, ISK_CLOSEAPP, 0, 0 );

    }

    return 0;
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\iecd\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// the following resources are defined once for the whole app
//
///////////////////////////////////////////////////////////////////////////////

// icons
#define IDI_CDSTARTAPP      1

// strings
#define IDS_APPTITLE            1
#define IDS_NEEDCDROM           2
#define IDS_STARTPAGE           10
#define IDS_SEARCHPAGE          11
#define IDS_VIDEO               21
#define IDS_IE_VERSION          145
#define IDS_LATESTVER		146
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\isk3ro\isk3ro.c ===
#include <windows.h>
#include "resource.h"

#define ISK_STARTAPP    WM_USER + 0x020
#define ISK_CLOSEAPP    WM_USER + 0x021

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

HINSTANCE g_hInst;
char g_lpCmd[MAX_PATH];
int g_nCount=0;
BOOL g_fFirst = FALSE;
HANDLE g_hExec;

BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;    // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}

HRESULT LaunchProcess(LPCSTR pszCmd, HANDLE *phProc, LPCSTR pszDir, UINT uShow)
{
   STARTUPINFO startInfo;
   PROCESS_INFORMATION processInfo;
   HRESULT hr = S_OK;
   BOOL fRet;
   
   if(phProc)
      *phProc = NULL;

   // Create process on pszCmd
   ZeroMemory(&startInfo, sizeof(startInfo));
   startInfo.cb = sizeof(startInfo);
   startInfo.dwFlags |= STARTF_USESHOWWINDOW;
   startInfo.wShowWindow = (WORD) uShow;
   fRet = CreateProcess(NULL, (LPSTR)  pszCmd, NULL, NULL, FALSE, 
              NORMAL_PRIORITY_CLASS, NULL, pszDir, &startInfo, &processInfo);
   if(!fRet)
      return E_FAIL;

   if(phProc)
      *phProc = processInfo.hProcess;
   else
      CloseHandle(processInfo.hProcess);

   CloseHandle(processInfo.hThread);
   
   return S_OK;
}
   

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT LaunchAndWait(LPSTR pszCmd, HANDLE hAbort, HANDLE *phProc, LPSTR pszDir, UINT uShow)
{
   HRESULT hr = S_OK;

   hr = LaunchProcess(pszCmd, phProc, pszDir, uShow);
   
   if(SUCCEEDED(hr))
   {
      DWORD dwRet;
      HANDLE pHandles[2];
      BOOL fQuit = FALSE;

      pHandles[0] = *phProc;
      
      if(hAbort)
         pHandles[1] = hAbort;     

      while(!fQuit)
      {
         dwRet = MsgWaitForMultipleObjects(hAbort ? 2 : 1, pHandles, FALSE, INFINITE, QS_ALLINPUT);
         // Give abort the highest priority
         if(dwRet == WAIT_OBJECT_0)
         {
            fQuit = TRUE;
         }
         else if((dwRet == WAIT_OBJECT_0 + 1) && hAbort)
         {
            // Any abort work?
            hr = E_ABORT;
            fQuit = TRUE;
         }
         else
         {
            MSG msg;
            // read all of the messages in this next loop 
            // removing each message as we read it 
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            { 
 
               // if it's a quit message we're out of here 
               if (msg.message == WM_QUIT)
               {
				   TerminateProcess(pHandles[0],0);
				   fQuit = TRUE; 
               }
			   else
               {
                  // otherwise dispatch it 
                 DispatchMessage(&msg); 
               } // end of PeekMessage while loop 
            }
         }
      }
   }
   
   return hr;
}

LRESULT CALLBACK MainWndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    char szCDPath[MAX_PATH];
	char * szCheckRunOnce;
    char szMsg[128];
	char szPath[MAX_PATH];
	char szWinPath[MAX_PATH];
	char szTest[MAX_PATH];
	long lResult;
	HKEY hkRunOnce;
	DWORD dwTest;

    switch( msg )
    {
    case WM_CREATE:
        ShowWindow( hWnd, SW_HIDE );

        lstrcpy( szCDPath, g_lpCmd);
        _PathRemoveFileSpec( szCDPath );
        if(LaunchAndWait(g_lpCmd, NULL, &g_hExec, szCDPath, SW_SHOWNORMAL)==E_FAIL)
        {
            TCHAR szMessage[MAX_PATH];
            TCHAR szTitle[MAX_PATH];

            LoadString( g_hInst, IDS_CDMESSAGE, szMessage, MAX_PATH );
            LoadString( g_hInst, IDS_CDTITLE, szTitle, MAX_PATH );

            MessageBox(NULL,szMessage,szTitle,MB_OK);
        }

        SendMessage(hWnd,WM_CLOSE,(WPARAM) 0,(LPARAM) 0);

        break;

    case ISK_STARTAPP:
        if( !g_fFirst )
            g_fFirst = TRUE;
        g_nCount++;
//        wsprintf( szMsg, "Start App\ng_nCount++\ng_nCount: %d", g_nCount );
//        MessageBox( NULL, szMsg, "ISK3RO", MB_OK | MB_SETFOREGROUND );
        break;

    case ISK_CLOSEAPP:
        g_nCount--;
        if( g_fFirst )
        {
            if( g_nCount < 1 )
                PostQuitMessage(0);
        }
        wsprintf( szMsg, "Close App\ng_nCount--\ng_nCount: %d", g_nCount );
//        MessageBox( NULL, szMsg, "ISK3RO", MB_OK | MB_SETFOREGROUND );
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc( hWnd, msg, wParam, lParam );
    }

    return 1;
}

void RegisterMe( )
{
    WNDCLASS wc;
    MSG msg;


    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = wc.cbWndExtra = 0;
    wc.hInstance = g_hInst;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = "ISK3RO";

    RegisterClass(&wc);


    CreateWindow( "ISK3RO", "Isk3Ro", WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX, 0, 0, 30, 30,
        NULL, NULL, g_hInst, NULL );

    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

}

int WINAPI WinMain( HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow )
{
    char szCDPath[MAX_PATH];
    HWND hwndIE=NULL;
    char *pParams;
    int i;
    int len;
	BOOL bIsOk;
    HKEY hkCheckCD;

    g_hInst = hInst;

    lstrcpy( g_lpCmd, lpCmdLine );

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion",0,KEY_READ|KEY_WRITE,&hkCheckCD)==ERROR_SUCCESS)
    {
        HKEY hkTips;
        TCHAR szClass[64];
        char szCheckCD[MAX_PATH];
        DWORD dwType=REG_SZ;
        DWORD dwSize;
        DWORD dwRes;

        dwSize = sizeof(szCheckCD);
        if(RegQueryValueEx(hkCheckCD,"DeleteWelcome",NULL,&dwType,szCheckCD,&dwSize)==ERROR_SUCCESS)
        {
            DeleteFile(szCheckCD);
            RegDeleteValue(hkCheckCD, "DeleteWelcome");

            if(RegCreateKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Tips", 0, szClass,
                REG_OPTION_NON_VOLATILE,KEY_READ|KEY_WRITE,NULL,&hkTips,&dwRes)
                 == ERROR_SUCCESS)
            {
                DWORD K0 = 0;
                RegSetValueEx(hkTips, "ShowIE4", 0, REG_DWORD,(LPBYTE) &K0, 4);
                RegCloseKey(hkTips);
            }
        }

        dwSize = sizeof(szCheckCD);
        if(RegQueryValueEx(hkCheckCD,"CDForcedOn",NULL,&dwType,szCheckCD,&dwSize)==ERROR_SUCCESS)
        {
            RegDeleteValue(hkCheckCD,"CDForcedOn");

            if(RegCreateKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Tips", 0, szClass,
                0,KEY_READ|KEY_WRITE,NULL,&hkTips,NULL)
                 == ERROR_SUCCESS)
            {
                DWORD K0 = 0;
                RegSetValueEx(hkTips, "ShowIE4", 0, REG_DWORD,(LPBYTE) &K0, 4);
                RegCloseKey(hkTips);
            }
        }

        RegCloseKey(hkCheckCD);
    }

    RegisterMe( );

    return TRUE;
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\iskrun\resource.h ===
#define IDS_TITLE   1
#define IDS_WINNT   2
#define IDS_ISW     3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\iecd\iecd.c ===
#include <windows.h>
#include <shellapi.h>
#include <advpub.h>
#include <ntverp.h>
#include "resource.h"


#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define REGLEN(str)     (lstrlen(str) + 1)

#define NUM_VERSION_NUM 4

//---------------------------------------------------------------------------
// appwide globals
HINSTANCE g_hinst = NULL;
HANDLE g_hIExplore = NULL;
char    g_szTemp[2048] = {0};
char    g_szTemp2[2048] = {0};
char    g_szCurrentDir[MAX_PATH];
BOOL    g_fWindowsNT;

void ConvertVersionStr(LPSTR pszVer, WORD rwVer[]);
int VersionCmp(WORD rwVer1[], WORD rwVer2[]);

long AtoL(const char *nptr);

//---------------------------------------------------------------------------
// Convert a string resource into a character pointer
// NOTE: Flag is in case we call this twice before we use the data
char * Res2Str(int rsString)
{
    static BOOL fSet = FALSE;

    if(fSet)
    {
	    LoadString(g_hinst, rsString, g_szTemp, ARRAYSIZE(g_szTemp));
	    fSet = FALSE;
	    return(g_szTemp);
    }

    LoadString(g_hinst, rsString, g_szTemp2, ARRAYSIZE(g_szTemp2));
    fSet = TRUE;
    return(g_szTemp2);
}

//---------------------------------------------------------------------------
//      G E T  I E  V E R S I O N
//
//  ISK3
//  This will pull build information out of the system registry and return
//  true if it is less than IE5.
//---------------------------------------------------------------------------
int GetIEVersion( )
{
    HKEY hkIE;
    DWORD dwType;
    DWORD dwSize = 32;
    DWORD result;
    char szData[32],* lpszData;
	BOOL bNotIE5=1;

    if(RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Explorer", 0, KEY_READ|KEY_WRITE, &hkIE ) == ERROR_SUCCESS)
    {
	    result = RegQueryValueEx( hkIE, "Version", NULL, &dwType, szData, &dwSize );
	    if( result == ERROR_SUCCESS )
	    {
	        WORD rwRegVer[NUM_VERSION_NUM];
	        WORD rwRegVer2[NUM_VERSION_NUM];
	        ConvertVersionStr(szData, rwRegVer);

	        if (LoadString(g_hinst, IDS_IE_VERSION, szData, sizeof(szData)) == 0)
    		    lstrcpy(szData, VER_PRODUCTVERSION_STR);

	        ConvertVersionStr(szData, rwRegVer2);
	        // Check the version of IE is 5.0 or greater is installed
	        if (VersionCmp(rwRegVer, rwRegVer2) >= 0)
	            bNotIE5=0;
	    }
	    RegCloseKey( hkIE );
    }

	return bNotIE5;
}
//---------------------------------------------------------------------------
//      C H E C K  B R A N D
//
//  ISK3
//---------------------------------------------------------------------------
BOOL CheckBrand( )
{
    HKEY hkRegKey;
    char szCompany[MAX_PATH];
    char szInsPath[MAX_PATH];
    char szName[MAX_PATH];
    DWORD dwType;
    DWORD dwLength = MAX_PATH;

    wsprintf( szInsPath, "%s\\install.ins", g_szCurrentDir );
    GetPrivateProfileString( "Branding", "CompanyName", "", szName, MAX_PATH, szInsPath );

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Explorer\\Main", 0, KEY_READ|KEY_WRITE, &hkRegKey ) != ERROR_SUCCESS )
	    if( lstrlen( szName ) != 0 )
	        return FALSE;

    RegQueryValueEx( hkRegKey, "CompanyName", NULL, &dwType, szCompany, &dwLength );
    RegCloseKey( hkRegKey );

    if( lstrlen( szName ) == 0 )
	    return TRUE;

    if( lstrlen(szCompany) == 0 )
	    return FALSE;

    if( lstrcmpi( szName, szCompany ) == 0 )
	    return TRUE;

    return FALSE;
}

//---------------------------------------------------------------------------
//      G E T  I E  P A T H
//
//  ISK3
//  This will retrieve the AppPath for IEXPLORE.EXE from the system registry
//  and return it as a string.
//
//  Parameters:
//      pszString - pointer to buffer to store path
//      nSize     - size of buffer
//---------------------------------------------------------------------------
char *GetIEPath( LPSTR pszString, int nSize )
{
    HKEY hkAppPath;
    DWORD dwType = REG_SZ;
    DWORD dwSize;

    dwSize = nSize;
    RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE",
	0, KEY_READ|KEY_WRITE, &hkAppPath );
    RegQueryValueEx( hkAppPath, "", NULL, &dwType, pszString, &dwSize );
    RegCloseKey( hkAppPath );

    return pszString;
}

//---------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;	// stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;	// stripped something
    }
}

//---------------------------------------------------------------------------
BOOL AutoRunCDIsInDrive( )
{
    char me[MAX_PATH];
    GetModuleFileName(g_hinst, me, ARRAYSIZE(me));

    while (!(GetFileAttributes(me)!=-1))
        if (MessageBox(NULL,Res2Str(IDS_NEEDCDROM),Res2Str(IDS_APPTITLE),MB_OKCANCEL | MB_ICONSTOP) == IDCANCEL)
	        return FALSE;
    return TRUE;
}

//---------------------------------------------------------------------------
//      E X E C  A P P
//
//  ISK3
//  Similar to AutoRunExec except that we don't put process information into
//  the g_ahWait array.  For use with WaitForSingleObject.
//---------------------------------------------------------------------------
HANDLE ExecApp( char *command, char *params, char *dir, int nWinState )
{
    SHELLEXECUTEINFO sei;

    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = "Open";
    sei.lpFile = command;
    sei.lpParameters = params;
    sei.lpDirectory = dir;
    sei.nShow = nWinState;
    sei.cbSize = sizeof(sei);

    if( ShellExecuteEx(&sei) )
        return sei.hProcess;
    
    return NULL;
}

//---------------------------------------------------------------------------
void AutoRunKillIE( void )
{
    HWND hwndIE;

	hwndIE=FindWindow("IEFrame",NULL);
    if(hwndIE!=NULL)
    {
        PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
    }
    else if ((hwndIE=FindWindow("Internet Explorer_Frame",NULL))!=NULL)
    {
        PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
    }
    else
    {
        hwndIE=FindWindow("CabinetWClass",NULL);
        if(hwndIE!=NULL)
        {
            PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
        }
    }
}

//---------------------------------------------------------------------------
void RegisterISKRun( )
{
    HKEY hkISK;
    HKEY hkISK2;
    DWORD dwDisp;
    char szCommand[MAX_PATH];
    char szSource[MAX_PATH];

    lstrcpy( szSource, g_szCurrentDir );
    lstrcat( szSource, "\\iskrun.exe" );

    GetWindowsDirectory( szCommand, MAX_PATH );
    lstrcat( szCommand, "\\iskrun.exe" );

    CopyFile( szSource, szCommand, FALSE );

    lstrcat( szCommand, " %1" );

    if (RegCreateKeyEx( HKEY_CLASSES_ROOT, ".isk", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkISK, &dwDisp ) == ERROR_SUCCESS)
    {
        RegSetValueEx( hkISK, "", 0, REG_SZ, "ISKFile", REGLEN( "ISKFile" ));
        RegCloseKey( hkISK );
    }

    if (RegCreateKeyEx( HKEY_CLASSES_ROOT, "ISKFile", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkISK, &dwDisp ) == ERROR_SUCCESS)
    {
        if (RegCreateKeyEx( hkISK, "Shell", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkISK2, &dwDisp ) != ERROR_SUCCESS)
        {
            RegCloseKey( hkISK );
            return;
        }
        RegCloseKey( hkISK );
        if (RegCreateKeyEx( hkISK2, "Open", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkISK, &dwDisp ) != ERROR_SUCCESS)
        {
            RegCloseKey( hkISK2 );
            return;
        }
        RegCloseKey( hkISK2 );
        if (RegCreateKeyEx( hkISK, "Command", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkISK2, &dwDisp ) != ERROR_SUCCESS)
        {
            RegCloseKey( hkISK );
            return;
        }
        RegCloseKey( hkISK );
        RegSetValueEx( hkISK2, "", 0, REG_SZ, szCommand, REGLEN( szCommand ));
        RegCloseKey( hkISK2 );
    }
}

//---------------------------------------------------------------------------
void UnregisterISKRun( )
{
    HKEY hkISK;
    HKEY hkISK2;
    char szCommand[MAX_PATH];

    GetWindowsDirectory( szCommand, MAX_PATH );
    lstrcat( szCommand, "\\iskrun.exe" );

    SetFileAttributes( szCommand, FILE_ATTRIBUTE_NORMAL );

    DeleteFile( szCommand );

    RegDeleteKey( HKEY_CLASSES_ROOT, ".isk" );
    if (RegOpenKeyEx( HKEY_CLASSES_ROOT, "ISKFile\\Shell\\Open", 0, KEY_READ|KEY_WRITE, &hkISK ) == ERROR_SUCCESS)
    {
        RegDeleteKey( hkISK, "Command" );
        RegCloseKey( hkISK );
    }
    if (RegOpenKeyEx( HKEY_CLASSES_ROOT, "ISKFile\\Shell", 0, KEY_READ|KEY_WRITE, &hkISK ) == ERROR_SUCCESS)
    {
        RegDeleteKey( hkISK, "Open" );
        RegCloseKey( hkISK );
    }
    if (RegOpenKeyEx( HKEY_CLASSES_ROOT, "ISKFile", 0, KEY_READ|KEY_WRITE, &hkISK ) == ERROR_SUCCESS)
    {
        RegDeleteKey( hkISK, "Shell" );
        RegCloseKey( hkISK );
    }
    RegDeleteKey( HKEY_CLASSES_ROOT, "ISKFile" );
}

//---------------------------------------------------------------------------
void ActiveXEnable( )
{
    HKEY hkRegKey;
    DWORD dwType;
    DWORD dwLength = 4;
    DWORD dwValue;
    char szSCD[16];

    if (RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", 0, KEY_READ|KEY_WRITE, &hkRegKey ) == ERROR_SUCCESS)
    {
        if( RegQueryValueEx( hkRegKey, "Security_RunActiveXControls", NULL, &dwType, (LPBYTE) &dwValue, &dwLength ) == ERROR_SUCCESS )
	        RegSetValueEx( hkRegKey, "SRAXC_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        else
        {
	        dwValue = 1;
	        RegSetValueEx( hkRegKey, "SRAXC_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        }
        dwValue = 1;
        RegSetValueEx( hkRegKey, "Security_RunActiveXControls", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );

        dwLength = 4 ;
        if( RegQueryValueEx( hkRegKey, "Security_RunJavaApplets", NULL, &dwType, (LPBYTE) &dwValue, &dwLength ) == ERROR_SUCCESS )
            RegSetValueEx( hkRegKey, "SRJA_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        else
        {
	        dwValue = 1;
	        RegSetValueEx( hkRegKey, "SRJA_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        }
        dwValue = 1;
        RegSetValueEx( hkRegKey, "Security_RunJavaApplets", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );

        dwLength = 4 ;
        if( RegQueryValueEx( hkRegKey, "Security_RunScripts", NULL, &dwType, (LPBYTE) &dwValue, &dwLength ) == ERROR_SUCCESS )
            RegSetValueEx( hkRegKey, "SRS_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        else
        {
	        dwValue = 1;
	        RegSetValueEx( hkRegKey, "SRS_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        }
        dwValue = 1;
        RegSetValueEx( hkRegKey, "Security_RunScripts", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );

        dwLength = 16;
        dwType = REG_SZ;
        if( RegQueryValueEx( hkRegKey, "Code Download", NULL, &dwType, szSCD, &dwLength ) == ERROR_SUCCESS )
            RegSetValueEx( hkRegKey, "SCD_BACKUP", 0, REG_SZ, szSCD, lstrlen(szSCD) + 1);
        else
            RegSetValueEx( hkRegKey, "SCD_BACKUP", 0, REG_SZ, "yes", 4);
        RegSetValueEx( hkRegKey, "Code Download", 0, REG_SZ, "yes", 4 );
        RegCloseKey( hkRegKey );
    }
}

//---------------------------------------------------------------------------
void RestoreActiveX( )
{
    HKEY hkRegKey;
    DWORD dwType;
    DWORD dwLength = 4;
    DWORD dwValue;
    char szSCD[16];

    if (RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", 0, KEY_READ|KEY_WRITE, &hkRegKey ) == ERROR_SUCCESS)
    {
        RegQueryValueEx( hkRegKey, "SRAXC_BACKUP", NULL, &dwType, (LPBYTE) &dwValue, &dwLength );
        RegSetValueEx( hkRegKey, "Security_RunActiveXControls", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        RegDeleteValue( hkRegKey, "SRAXC_BACKUP" );

        dwLength = 4;
        RegQueryValueEx( hkRegKey, "SRJA_BACKUP", NULL, &dwType, (LPBYTE) &dwValue, &dwLength );
        RegSetValueEx( hkRegKey, "Security_RunJavaApplets", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        RegDeleteValue( hkRegKey, "SRJA_BACKUP" );

        dwLength = 4;
        RegQueryValueEx( hkRegKey, "SRS_BACKUP", NULL, &dwType, (LPBYTE) &dwValue, &dwLength );
        RegSetValueEx( hkRegKey, "Security_RunScripts", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        RegDeleteValue( hkRegKey, "SRS_BACKUP" );

        dwLength = 16;
        RegQueryValueEx( hkRegKey, "SCD_BACKUP", NULL, &dwType, szSCD, &dwLength );
        RegSetValueEx( hkRegKey, "Code Download", 0, REG_SZ, szSCD, lstrlen(szSCD) + 1);
        RegDeleteValue( hkRegKey, "SCD_BACKUP" );

        RegCloseKey( hkRegKey );
    }
}

//---------------------------------------------------------------------------
void CreateAppPath( )
{
    HKEY hkAppPath;
    HKEY hkIECD;
    DWORD dwDisp;
    char szIECD[MAX_PATH];

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths", 0, KEY_READ|KEY_WRITE, &hkAppPath ) == ERROR_SUCCESS)
    {
        if (RegCreateKeyEx( hkAppPath, "IECD.EXE", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkIECD, &dwDisp ) != ERROR_SUCCESS)
        {
            RegCloseKey( hkAppPath );
            return;
        }
        RegCloseKey( hkAppPath );
        lstrcpy( szIECD, g_szCurrentDir );
        lstrcat( szIECD, "\\iecd.exe" );

        RegSetValueEx( hkIECD, "", 0, REG_SZ, szIECD, REGLEN( szIECD ));
        RegCloseKey( hkIECD );
    }

}

//---------------------------------------------------------------------------
BOOL InstallVideoCodec( )
{
    char szInfPath[MAX_PATH];
    char szInfFile[MAX_PATH];
    HKEY hkRegKey;
    DWORD dwType = REG_SZ;
    DWORD dwLength = sizeof(szInfPath)/sizeof(szInfPath[0]);
    HRESULT hReturnCode;
    HANDLE hSetupLib;
    HRESULT (WINAPI *RunSetupCommand)(HWND,LPCSTR,LPCSTR,LPCSTR,LPCSTR,HANDLE,DWORD,LPVOID);
    char szSetupPath[MAX_PATH];
    char szInstalled[32];
    char szIECD[MAX_PATH];

    // quit if we are under NT
    if( g_fWindowsNT )
	    return TRUE;

    // Check to see if video is installed
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\icm", 0, KEY_READ|KEY_WRITE, &hkRegKey ) != ERROR_SUCCESS)
        return TRUE;
    RegQueryValueEx( hkRegKey, "Installed", NULL, &dwType, szInstalled, &dwLength );
    RegCloseKey( hkRegKey );
    if( szInstalled[0] == '1' )
    	return TRUE;
    
    dwLength = MAX_PATH;

    // get inf path
    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion", 0, KEY_READ|KEY_WRITE, &hkRegKey ) != ERROR_SUCCESS )
	    return TRUE;
    RegQueryValueEx( hkRegKey, "DevicePath", NULL, &dwType, szInfPath, &dwLength );
    RegCloseKey( hkRegKey );

    if( lstrlen( szInfPath ) == 0 )
	    return TRUE;

    // load dll
    hSetupLib = LoadLibrary( "advpack.dll" );
    if( hSetupLib )
    {
	    RunSetupCommand = (RUNSETUPCOMMAND) GetProcAddress( hSetupLib, "RunSetupCommand" );
        if( !RunSetupCommand )
	        return TRUE;
    }

    wsprintf( szInfFile, "%s\\motown.inf", szInfPath );

    // get setup directory
    RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Setup", 0, KEY_READ|KEY_WRITE, &hkRegKey );
    dwLength = MAX_PATH;
    RegQueryValueEx( hkRegKey, "SourcePath", NULL, &dwType, szSetupPath, &dwLength );
    RegCloseKey( hkRegKey );

    if( lstrlen( szSetupPath ) == 0 )
	    lstrcpy( szSetupPath, szInfPath );

    if( lstrlen( szSetupPath ) > 4 )
	    szSetupPath[lstrlen(szSetupPath) - 1] = '\0';

    if(MessageBox( NULL, Res2Str( IDS_VIDEO ), Res2Str( IDS_APPTITLE ), MB_YESNO | MB_ICONQUESTION | MB_SETFOREGROUND ) == IDNO )
	    return TRUE;

    // run setup
    hReturnCode = (*RunSetupCommand)( NULL, szInfFile, "media_icm", szSetupPath, Res2Str( IDS_APPTITLE ),
	NULL, RSC_FLAG_INF | RSC_FLAG_QUIET, NULL );


    lstrcpy( szIECD, g_szCurrentDir );
    lstrcpy( szIECD, "\\iecd.exe" );


    if( !AutoRunCDIsInDrive( ))
	    return FALSE;

    FreeLibrary( hSetupLib );

    return TRUE;

}

//-------------------------------------------------------------------------
//
//      C H E C K  O S  V E R S I O N
//
//
//  Checks the platform and version.
//-------------------------------------------------------------------------
BOOL CheckOsVersion( )
{
    OSVERSIONINFO osVersion;

    osVersion.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    GetVersionEx( &osVersion );

    // if we are running anything less than Windows NT 4.0 or Windows 95, return FALSE
    if( osVersion.dwMajorVersion < 4 )
    {
//        MessageBox( NULL, Res2Str( IDS_WRONGVERSION ), Res2Str( IDS_TITLE ), MB_OK | MB_SETFOREGROUND );
	    return FALSE;
    }

    if( osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT )
	    g_fWindowsNT = TRUE;
    else
	    g_fWindowsNT = FALSE;

    return TRUE;
}

LRESULT CALLBACK MainWndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch( msg )
    {
	case WM_QUERYENDSESSION:
	{
	    HWND hwndIE;
	    DWORD dwExitCode=0;

	    AutoRunKillIE();

	    do 
        {
		    if(hwndIE=FindWindow(NULL,"Microsoft Internet Explorer"))
		    {                        
		        HWND hButton;

		        hButton=GetWindow(hwndIE,GW_CHILD);
		        PostMessage(hwndIE,WM_COMMAND,MAKEWPARAM(IDOK,BN_CLICKED),MAKELPARAM(hButton,0)); //Press the ok button to dismiss the dialog
		    }

		    GetExitCodeProcess(g_hIExplore,&dwExitCode);
	    } while(dwExitCode==STILL_ACTIVE);

	    return(TRUE);
	}
	case WM_DESTROY:

	    PostQuitMessage(0);
	    break;

	default:
	    return DefWindowProc( hWnd, msg, wParam, lParam );
    }

    return 1;
}


int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}


//---------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    HWND window;
    HWND hwndIE;
    HWND hwndTray;
    HKEY hkLocale;
    HKEY hkIE;
    HKEY hkWin;
    int retval;
    char szIECmd[MAX_PATH];
    char szLang[MAX_PATH];
    DWORD dwLangSize=MAX_PATH;
    char szIEParams[MAX_PATH];
    char szIEDir[MAX_PATH];
    char szTemp[1024];
    char szStartHtm[MAX_PATH];
    // for security settings
    DWORD dwType;
    DWORD dwSize = 64;
    char szSecurity[64];
    char szTrust[64];
    BOOL fCmdLine = FALSE;
    HANDLE hMutex,hCDCache;
    HWND hIskRo;
    WNDCLASS wc;
    MSG msg;

    if( lstrlen( lpCmdLine ) != 0 )
	    fCmdLine = TRUE;

    g_hinst = hInstance;

    if( !CheckOsVersion( ))
	    return FALSE;

    //in case this is run from another directory...
    GetModuleFileName( NULL, g_szCurrentDir, MAX_PATH );
    _PathRemoveFileSpec( g_szCurrentDir );

    hMutex = CreateMutex( NULL, TRUE, "IESK_IECD" );
    if( GetLastError( ) == ERROR_ALREADY_EXISTS )
	    return(0);

    RegisterISKRun( );

    //
    // make sure they have IE5 Installed
    //

    if( (GetIEVersion()) || (!CheckBrand()) )
    {
	    //Install Microsoft Explorer 6
	    char szIE5Cmd[MAX_PATH],szInstallMessage[MAX_PATH],szInstallTitle[MAX_PATH];

	    // build paths for ExecApp
	    lstrcpy( szIE5Cmd, g_szCurrentDir );
	    lstrcat( szIE5Cmd, "\\ie3inst.exe" );

	    ExecApp( szIE5Cmd, " ", g_szCurrentDir, SW_SHOWNORMAL );

	    UnregisterISKRun( );

	    ReleaseMutex( hMutex );

	    return 0;
    }

    lstrcpy( szIEDir, GetIEPath( szIECmd, MAX_PATH ));
    _PathRemoveFileSpec( szIEDir );

    // add video compression drivers
    if(!InstallVideoCodec( ))
    {
	    UnregisterISKRun( );

	    ReleaseMutex( hMutex );

	    return 0;
    }

    CreateAppPath( );

    RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Internet Explorer\\Document Windows", 0, KEY_READ|KEY_WRITE, &hkIE );
    RegSetValueEx( hkIE, "Maximized", 0, REG_SZ, "yes", 4 );
    RegCloseKey( hkIE );

    RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Internet Explorer\\Security", 0, KEY_READ|KEY_WRITE, &hkIE );
    RegQueryValueEx( hkIE, "Safety Warning Level", NULL, &dwType, szSecurity, &dwSize );
    RegSetValueEx( hkIE, "SWL Backup", 0, REG_SZ, szSecurity, REGLEN( szSecurity ));
    RegSetValueEx( hkIE, "Safety Warning Level", 0, REG_SZ, "SucceedSilent", 14 );

    RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", 0, KEY_READ|KEY_WRITE, &hkWin );
    dwSize = 64;
	RegQueryValueEx( hkWin, "Trust Warning Level", NULL, &dwType, szTrust, &dwSize );
    RegSetValueEx( hkWin, "TWL Backup", 0, REG_SZ, szTrust, REGLEN( szTrust ));
    RegSetValueEx( hkWin, "Trust Warning Level", 0, REG_SZ, "No Security", 12 );

    ActiveXEnable( );

    lstrcpy( szIEParams, "-SLF -k file://" );

    if( !fCmdLine )
    {
        lstrcat( szIEParams, g_szCurrentDir );
        lstrcat( szIEParams, "\\start.htm" );
        lstrcpy( szStartHtm, g_szCurrentDir);
        lstrcat( szStartHtm, "\\start.htm");
    }
    else
    {
        lstrcat( szIEParams, lpCmdLine );
        lstrcpy( szStartHtm, lpCmdLine);
    }

    if (GetFileAttributes(szStartHtm) != 0xFFFFFFFF)
    {
        g_hIExplore = ExecApp( szIECmd, szIEParams, szIEDir, SW_SHOWNORMAL );
        
        if(g_hIExplore)
        {
            DWORD dwExitCode;
            BOOL bContinue=TRUE;
            HANDLE hArray[2];
            HWND hIEWnd;
            
            hArray[0]=g_hIExplore;
            
            wc.style = 0;
            wc.lpfnWndProc = MainWndProc;
            wc.cbClsExtra = wc.cbWndExtra = 0;
            wc.hInstance = g_hinst;
            wc.hCursor = LoadCursor(NULL, IDC_ARROW);
            wc.hIcon = NULL;
            wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
            wc.lpszMenuName = NULL;
            wc.lpszClassName = "IECD";
            
            RegisterClass(&wc);
            
            // NOTE: If the window classname is changed, it should be reflected in closeie.exe,
            // iskrun.exe and browseui.dll which depend on the classname to check whether iecd.exe
            // is running.
            hIEWnd=CreateWindow( "IECD", "IECD", WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX, 0, 0, 30, 30,
                NULL, NULL, g_hinst, NULL );
            
            hArray[1]=hIEWnd;
            
            while(bContinue)
            {
                MsgWaitForMultipleObjects(2,hArray,FALSE,INFINITE,QS_ALLINPUT);
                
                if(PeekMessage(&msg,hIEWnd,0,0,PM_REMOVE))
                {
                    if(msg.message==WM_QUIT)
                    {
                        bContinue=FALSE;
                    }
                    else
                    {
                        TranslateMessage( &msg );
                        DispatchMessage( &msg );
                    }
                }
                
                GetExitCodeProcess(g_hIExplore,&dwExitCode);
                
                if(dwExitCode!=STILL_ACTIVE)
                {
                    bContinue=FALSE;
                }
            }
        }
    }
    else
    {
        BOOL fShow = TRUE;
        DWORD dwVal = 0;
        HKEY hkShow;

        if (RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Tips", 0, KEY_READ|KEY_WRITE, &hkShow ) == ERROR_SUCCESS)
        {
            if ((RegQueryValueEx( hkShow, "DisableStartHtm", NULL, &dwType, (LPBYTE)&dwVal, &dwSize ) == ERROR_SUCCESS) &&
                dwVal)
            {
                RegDeleteValue(hkShow, "DisableStartHtm");
                fShow = FALSE;
            }
            RegCloseKey( hkShow );
        }

        if (fShow)
            MessageBox(NULL, Res2Str(IDS_LATESTVER), Res2Str(IDS_APPTITLE), MB_OK);
    }

    RestoreActiveX( );

    RegSetValueEx( hkIE, "Safety Warning Level", 0, REG_SZ, szSecurity, REGLEN( szSecurity ));
    RegDeleteValue( hkIE, "SWL Backup" );
    RegCloseKey( hkIE );

    RegSetValueEx( hkWin, "Trust Warning Level", 0, REG_SZ, szTrust, REGLEN( szTrust ));
    RegDeleteValue( hkWin, "TWL Backup" );
    RegCloseKey( hkWin );

    UnregisterISKRun( );

    ReleaseMutex( hMutex );

    return 0;
}

void ConvertVersionStr(LPSTR pszVer, WORD rwVer[])
{
    int i;
    for(i = 0; i < NUM_VERSION_NUM; i++)
	rwVer[i] = 0;

    for(i = 0; i < NUM_VERSION_NUM && pszVer; i++)
    {
	rwVer[i] = (WORD) AtoL(pszVer);
	pszVer = strchr(pszVer, '.');
	if (pszVer)
	    pszVer++;
    }
}

// Returns:
//    -1   Ver1 < Ver2
//     0   Ver1 == Ver2
//     1   Ver1 > Ver2
// Notes:
int VersionCmp(WORD rwVer1[], WORD rwVer2[])
{
    int i;
    for(i = 0; i < NUM_VERSION_NUM; i++)
    {
        if(rwVer1[i] < rwVer2[i])
            return -1;
        if(rwVer1[i] > rwVer2[i])
            return 1;
    }
    return 0;
}


#define IsSpace(c)              ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')
#define IsDigit(c)              ((c) >= '0'  &&  (c) <= '9')

// copied from msdev\crt\src\atox.c
/***
*long AtoL(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       Overflow is not detected.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       return long int value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

long AtoL(const char *nptr)
{
        int c;                  /* current char */
        long total;             /* current total */
        int sign;               /* if '-', then negative, otherwise positive */

        // NOTE: no need to worry about DBCS chars here because IsSpace(c), IsDigit(c),
        // '+' and '-' are "pure" ASCII chars, i.e., they are neither DBCS Leading nor
        // DBCS Trailing bytes -- pritvi

        /* skip whitespace */
        while ( IsSpace((int)(unsigned char)*nptr) )
                ++nptr;

        c = (int)(unsigned char)*nptr++;
        sign = c;               /* save sign indication */
        if (c == '-' || c == '+')
                c = (int)(unsigned char)*nptr++;        /* skip sign */

        total = 0;

        while (IsDigit(c)) {
                total = 10 * total + (c - '0');         /* accumulate digit */
                c = (int)(unsigned char)*nptr++;        /* get next char */
        }

        if (sign == '-')
                return -total;
        else
                return total;   /* return result, negated if necessary */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\readme\resource.h ===
#define IDD_README                      102
#define IDC_README                      1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\readme\readme.c ===
#include <windows.h>
#include <windowsx.h>
#include "resource.h"

char g_szCurrentDir[MAX_PATH];
char *g_szLicenseText;
//---------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;	// stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;	// stripped something
    }
}


//---------------------------------------------------------------------------
//      L O A D  R E A D M E
//
//  ISK3
//  This will load the readme data file
//
//---------------------------------------------------------------------------
void LoadReadme( char *szLicenseText)
{
    CHAR    szLicensePath[MAX_PATH];
    const   CHAR szLicenseFile[] = "\\license.txt";
    BOOL    retval = FALSE;
    HANDLE  hLicense;
    INT     filesize;
    DWORD   cbRead;

    lstrcpy( szLicensePath, g_szCurrentDir );
    lstrcat( szLicensePath, "\\Moreinfo.txt" );

    if (GetFileAttributes(szLicensePath) != (DWORD) -1)
    {
        // Open the file
        hLicense = CreateFile(szLicensePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hLicense != INVALID_HANDLE_VALUE)
        {

            // Get size and allocate buffer
            filesize = GetFileSize(hLicense, NULL);

            // Read File
            if (ReadFile( hLicense, szLicenseText, filesize, &cbRead, NULL))
            {
                // NULL terminate it
                szLicenseText[ filesize ] = '\0';

            }
        }
        CloseHandle( hLicense );
    }
}

void ReadmeCenterWindow( HWND hwnd )
{
    int screenx;
    int screeny;
    int height, width, x, y;
    RECT rect;

    screenx = GetSystemMetrics( SM_CXSCREEN );
    screeny = GetSystemMetrics( SM_CYSCREEN );

    GetWindowRect( hwnd, &rect );

    width = rect.right - rect.left;
    height = rect.bottom - rect.top;
    x = (screenx / 2) - (width / 2);
    y = (screeny / 2) - (height / 2);

    SetWindowPos( hwnd, HWND_TOP, x, y, width, height, SWP_NOZORDER );

}

void InitSysFont(HWND hDlg, int iCtrlID)
{
    static HFONT hfontSys;

    LOGFONT lf;
    HDC     hDC;
    HWND    hwndCtrl = GetDlgItem(hDlg, iCtrlID);
    HFONT   hFont;
    int     cyLogPixels;

    hDC = GetDC(NULL);
    if (hDC == NULL)
        return;

    cyLogPixels = GetDeviceCaps(hDC, LOGPIXELSY);
    ReleaseDC(NULL, hDC);

    if (hfontSys == NULL) {
        LOGFONT lfTemp;
        HFONT   hfontDef = (HFONT)GetStockObject(DEFAULT_GUI_FONT);

        GetObject(hfontDef, sizeof(lfTemp), &lfTemp);
        hFont = GetWindowFont(hwndCtrl);
        if (hFont != NULL)
            if (GetObject(hFont, sizeof(LOGFONT), (PVOID)&lf)) {
                lstrcpy(lf.lfFaceName, lfTemp.lfFaceName);
                lf.lfQuality        = lfTemp.lfQuality;
                lf.lfPitchAndFamily = lfTemp.lfPitchAndFamily;
                lf.lfCharSet        = lfTemp.lfCharSet;

                hfontSys = CreateFontIndirect(&lf);
            }
    }

    if (iCtrlID == 0xFFFF)
        return;

    if (hfontSys != NULL)
        SetWindowFont(hwndCtrl, hfontSys, FALSE);
}

INT_PTR CALLBACK ReadmeProc( HWND hDlg, UINT msg, WPARAM wparam, LPARAM lparam )
{
    switch( msg )
    {
        case WM_INITDIALOG:
            InitSysFont(hDlg, IDC_README);
            ReadmeCenterWindow( hDlg );
            SetDlgItemText( hDlg, IDC_README, g_szLicenseText );
            return(0);
        case WM_COMMAND:
            if( wparam == IDOK )
                EndDialog( hDlg, 0 );
                break;
            if( wparam == IDC_README )
                return(0);
                break;

        case WM_CLOSE:
            EndDialog( hDlg, 0 );
            break;
    }
    return(0);
}

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow )
{
    char *szLicenseText = (char *) LocalAlloc( LPTR, 64000 );

    g_szLicenseText = szLicenseText;

    GetModuleFileName( NULL, g_szCurrentDir, MAX_PATH );
    _PathRemoveFileSpec( g_szCurrentDir );

    LoadReadme( szLicenseText );

    DialogBox( hInstance, MAKEINTRESOURCE( IDD_README ), NULL, ReadmeProc );

    LocalFree( szLicenseText );

    szLicenseText = NULL;

	return(0);
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\runisp32\runisp32.c ===
#include <windows.h>
#include <shellapi.h>

//-------------------------------------------------------------------------
//
//      P A T H  R E M O V E  F I L E  S P E C
//
//
//  Removes the file name from a path
//-------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything
    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;    // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}
//-------------------------------------------------------------------------
//
//      E X E C  A P P
//
//
//  Executes and application and returns the process handle
//-------------------------------------------------------------------------
HANDLE ExecApp( char *command, char *params, char *dir, int nWinState )
{
    SHELLEXECUTEINFO sei;
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = "Open";
    sei.lpFile = command;
    sei.lpParameters = params;
    sei.lpDirectory = dir;
    sei.nShow = nWinState;
    sei.cbSize = sizeof(sei);

    if( ShellExecuteEx(&sei) )
        return sei.hProcess;

    return NULL;
}

int WINAPI WinMain( HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow )
{
    HKEY hkRegKey;
    DWORD dwType;
    DWORD dwLength=MAX_PATH;
    char szIEPath[MAX_PATH];
    char szDir[MAX_PATH];
    char szParams[MAX_PATH];
    HANDLE hProcess;

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE", 0, KEY_ALL_ACCESS, &hkRegKey ) != ERROR_SUCCESS)
        //we're toast
        goto get_out;
    RegQueryValueEx( hkRegKey, "", NULL, &dwType, szIEPath, &dwLength );
    RegCloseKey( hkRegKey );


    _PathRemoveFileSpec( szIEPath );

    lstrcat( szIEPath, "\\signup" );
    lstrcpy( szDir, szIEPath );
    lstrcat( szIEPath, "\\signup.htm" );

    wsprintf( szParams, "-h %s", szIEPath );
    hProcess = ExecApp( "ISIGNUP.EXE", szParams, szDir, SW_SHOWNORMAL );
    if( hProcess )
    {
        DWORD dwResult;
        while((dwResult=MsgWaitForMultipleObjects(1, &hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
        {
            MSG msg;
            // read all of the messages in this next loop
            // removing each message as we read it
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if( msg.message == WM_QUIT )
                    goto get_out;
                DefWindowProc( msg.hwnd, msg.message, msg.wParam, msg.lParam );
            }
        }
    }
get_out:
    return 0;
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cdinst\resource.h ===
#define IDS_TITLE                   0
#define IDS_SRCDIR_NOT_FOUND        1
#define IDS_DESTDIR_NOT_FOUND       2
#define IDS_INI_NOT_FOUND           3
#define IDS_NOT_ENOUGH_DISK_SPACE   4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cdinst\cdinst.cpp ===
#include <windows.h>
#include <regstr.h>
#include <shellapi.h>
#include "cdinst.h"
#include "resource.h"

// global variables
HINSTANCE g_hInst;
CHAR g_szTitle[128];
CHAR g_szSrcDir[MAX_PATH], g_szDstDir[MAX_PATH];


int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}


INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pszCmdLine, INT iCmdShow)
{
    BOOL bIniCopiedToTemp = FALSE;
    CHAR szIniFile[MAX_PATH], szSrcDir[MAX_PATH], szDstDir[MAX_PATH];
    LPSTR pszSection, pszPtr, pszLine, pszFile, pszSrcSubDir, pszDstSubDir;
    DWORD dwLen, dwSpaceReq, dwSpaceFree;

    g_hInst = hInstance;

    LoadString(g_hInst, IDS_TITLE, g_szTitle, sizeof(g_szTitle));

    ParseCmdLine(pszCmdLine);

    if (*g_szSrcDir == '\0')
    {
        if (GetModuleFileName(g_hInst, g_szSrcDir, sizeof(g_szSrcDir)))
            if ((pszPtr = ANSIStrRChr(g_szSrcDir, '\\')) != NULL)
                *pszPtr = '\0';

        if (*g_szSrcDir == '\0')
        {
            ErrorMsg(IDS_SRCDIR_NOT_FOUND);
            return -1;
        }
    }

    if (*g_szDstDir == '\0')
    {
        HKEY hk;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS "\\ieak6wiz.exe", 0, KEY_READ, &hk) == ERROR_SUCCESS)
        {
            dwLen = sizeof(g_szDstDir);

            RegQueryValueEx(hk, "Path", NULL, NULL, (LPBYTE) g_szDstDir, &dwLen);
            RegCloseKey(hk);
        }

        if (*g_szDstDir == '\0')
        {
            ErrorMsg(IDS_DESTDIR_NOT_FOUND);
            return -1;
        }
    }

    // look for cdinst.ini in the dir where the parent module (ieak6cd.exe) is running from
    *szIniFile = '\0';
    lstrcpy(szIniFile, g_szSrcDir);
    AddPath(szIniFile, "cdinst.ini");
    if (!FileExists(szIniFile))
    {
        // not found where ieak6cd.exe is running from; so look for it in the dir where the current
        // module (cdinst.exe) is running from
        *szIniFile = '\0';
        if (GetModuleFileName(g_hInst, szIniFile, sizeof(szIniFile)))
        {
            if ((pszPtr = ANSIStrRChr(szIniFile, '\\')) != NULL)
                *pszPtr = '\0';
            AddPath(szIniFile, "cdinst.ini");
        }

        if (!FileExists(szIniFile))
        {
            *szIniFile = '\0';
            GetModuleFileName(g_hInst, szIniFile, sizeof(szIniFile));
            ErrorMsg(IDS_INI_NOT_FOUND, g_szSrcDir, szIniFile);
            return -1;
        }
    }

    // copy cdinst.ini to the temp dir -- need to do this because on Win95, if cdinst.ini
    // is at the same location as ieak6cd.exe on a read-only media (like CD), then
    // GetPrivateProfileSection() calls would fail.
    // NOTE: szSrcDir and szDstDir are used as temp variables below
    if (GetTempPath(sizeof(szSrcDir), szSrcDir))
        if (GetTempFileName(szSrcDir, "cdinst", 0, szDstDir))
            if (CopyFile(szIniFile, szDstDir, FALSE))
            {
                bIniCopiedToTemp = TRUE;
                lstrcpy(szIniFile, szDstDir);
                SetFileAttributes(szIniFile, FILE_ATTRIBUTE_NORMAL);
            }

    // NOTE: If the destination dir is a UNC path, GetFreeDiskSpace() won't return the right value on Win95 Gold.
    //       So we turn off disk space checking if installing to a UNC path.
    while (!EnoughDiskSpace(g_szSrcDir, g_szDstDir, szIniFile, &dwSpaceReq, &dwSpaceFree))
    {
        if (ErrorMsg(IDS_NOT_ENOUGH_DISK_SPACE, dwSpaceReq, dwSpaceFree) == IDNO)
            return -1;
    }

    // copy files that are specified in the [copy] section
    // format of a line in the [copy] section is (all the fields should be on one line):
    //     <file (can contain wildcards)>,
    //     <src sub dir (can be a relative path) - optional>,
    //     <dest sub dir (can be a relative path) - optional>
    if (ReadSectionFromInf("Copy", &pszSection, &dwLen, szIniFile))
    {
        for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
        {
            ParseIniLine(pszLine, &pszFile, &pszSrcSubDir, &pszDstSubDir);
            GetDirPath(g_szSrcDir, pszSrcSubDir, szSrcDir, sizeof(szSrcDir), szIniFile);
            GetDirPath(g_szDstDir, pszDstSubDir, szDstDir, sizeof(szDstDir), szIniFile);
            CopyFiles(szSrcDir, pszFile, szDstDir, FALSE);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    // delete files that are specified in the [exclude] section from the destination dir
    // format of a line in the [exclude] section is (all the fields should be on one line):
    //     <file (can contain wildcards)>,
    //     <dest sub dir (can be a relative path) - optional>
    if (ReadSectionFromInf("Exclude", &pszSection, &dwLen, szIniFile))
    {
        for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
        {
            ParseIniLine(pszLine, &pszFile, NULL, &pszDstSubDir);
            GetDirPath(g_szDstDir, pszDstSubDir, szDstDir, sizeof(szDstDir), szIniFile);
            DelFiles(pszFile, szDstDir);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    // extract all the files from cabs that are specified in the [extract] section
    // format of a line in the [extract] section is (all the fields should be on one line):
    //     <cab file (can contain wildcards)>,
    //     <src sub dir (can be a relative path) - optional>,
    //     <dest sub dir (can be a relative path) - optional>
    if (ReadSectionFromInf("Extract", &pszSection, &dwLen, szIniFile))
    {
        HINSTANCE hAdvpack;

        if ((hAdvpack = LoadLibrary("advpack.dll")) != NULL)
        {
            EXTRACTFILES pfnExtractFiles;

            if ((pfnExtractFiles = (EXTRACTFILES) GetProcAddress(hAdvpack, "ExtractFiles")) != NULL)
            {
                for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
                {
                    ParseIniLine(pszLine, &pszFile, &pszSrcSubDir, &pszDstSubDir);
                    GetDirPath(g_szSrcDir, pszSrcSubDir, szSrcDir, sizeof(szSrcDir), szIniFile);
                    GetDirPath(g_szDstDir, pszDstSubDir, szDstDir, sizeof(szDstDir), szIniFile);
                    ExtractFiles(szSrcDir, pszFile, szDstDir, pfnExtractFiles);
                }
            }

            FreeLibrary(hAdvpack);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    // move files that are specified in the [move] section from a subdir to another subdir under the destination dir
    // format of a line in the [move] section is (all the fields should be on one line):
    //     <file (can contain wildcards)>,
    //     <from sub dir under the dest dir (can be a relative path) - optional>,
    //     <to sub dir under the dest dir (can be a relative path) - optional>
    if (ReadSectionFromInf("Move", &pszSection, &dwLen, szIniFile))
    {
        for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
        {
            ParseIniLine(pszLine, &pszFile, &pszSrcSubDir, &pszDstSubDir);
            GetDirPath(g_szDstDir, pszSrcSubDir, szSrcDir, sizeof(szSrcDir), szIniFile);
            GetDirPath(g_szDstDir, pszDstSubDir, szDstDir, sizeof(szDstDir), szIniFile);
            MoveFiles(szSrcDir, pszFile, szDstDir);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    if (bIniCopiedToTemp)
        DeleteFile(szIniFile);

    return 0;
}


BOOL EnoughDiskSpace(LPCSTR pcszSrcRootDir, LPCSTR pcszDstRootDir, LPCSTR pcszIniFile, LPDWORD pdwSpaceReq, LPDWORD pdwSpaceFree)
// check if there is enough free disk space to copy all the files
{
    DWORD dwSpaceReq = 0, dwSpaceFree;
    CHAR szSrcDir[MAX_PATH], szDstDir[MAX_PATH];
    LPSTR pszSection, pszLine, pszFile, pszSrcSubDir, pszDstSubDir;
    DWORD dwLen, dwFlags;

    if (!GetFreeDiskSpace(pcszDstRootDir, &dwSpaceFree, &dwFlags))
    {
        // if we can't get FreeDiskSpace info, then turn off disk space checking
        return TRUE;
    }

    // total space required =
    //     size of all the files to be copied +
    //     2 * size of all the files to be extracted

    if (ReadSectionFromInf("Copy", &pszSection, &dwLen, pcszIniFile))
    {
        for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
        {
            ParseIniLine(pszLine, &pszFile, &pszSrcSubDir, &pszDstSubDir);
            GetDirPath(pcszSrcRootDir, pszSrcSubDir, szSrcDir, sizeof(szSrcDir), pcszIniFile);
            GetDirPath(pcszDstRootDir, pszDstSubDir, szDstDir, sizeof(szDstDir), pcszIniFile);

            dwSpaceReq += FindSpaceRequired(szSrcDir, pszFile, szDstDir);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    if (ReadSectionFromInf("Extract", &pszSection, &dwLen, pcszIniFile))
    {
        for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
        {
            ParseIniLine(pszLine, &pszFile, &pszSrcSubDir, NULL);
            GetDirPath(pcszSrcRootDir, pszSrcSubDir, szSrcDir, sizeof(szSrcDir), pcszIniFile);

            dwSpaceReq += 2 * FindSpaceRequired(szSrcDir, pszFile, NULL);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    dwSpaceReq += 1024;             // 1MB buffer to account for random stuff

    if (dwFlags & FS_VOL_IS_COMPRESSED)
    {
        // if the destination volume is compressed, the free space returned is only
        // a guesstimate; for example, if it's a DoubleSpace volume, the system thinks
        // that it can compress by 50% and so it reports the free space as (actual free space * 2)

        // it's better to be safe when dealing with compressed volumes; so bump up the space
        // requirement by a factor 2
        dwSpaceReq <<= 1;           // multiply by 2
    }

    if (pdwSpaceReq != NULL)
        *pdwSpaceReq = dwSpaceReq;

    if (pdwSpaceFree != NULL)
        *pdwSpaceFree = dwSpaceFree;

    return dwSpaceFree > dwSpaceReq;
}


BOOL GetFreeDiskSpace(LPCSTR pcszDir, LPDWORD pdwFreeSpace, LPDWORD pdwFlags)
// Return the free disk space (in KBytes) in *pdwFreeSpace
{
    BOOL bRet = FALSE;
    DWORD dwFreeSpace = 0;
    DWORD nSectorsPerCluster, nBytesPerSector, nFreeClusters, nTotalClusters;
    CHAR szDrive[8];

    if (pcszDir == NULL  ||  *pcszDir == '\0'  ||  *(pcszDir + 1) != ':')
        return FALSE;

    if (pdwFreeSpace == NULL)
        return FALSE;

    lstrcpyn(szDrive, pcszDir, 3);
    AddPath(szDrive, NULL);
    if (GetDiskFreeSpace(szDrive, &nSectorsPerCluster, &nBytesPerSector, &nFreeClusters, &nTotalClusters))
    {
        // convert size to KBytes; assumption here is that the free space doesn't exceed 4096 gigs
        if ((*pdwFreeSpace = MulDiv(nFreeClusters, nSectorsPerCluster * nBytesPerSector, 1024)) != (DWORD) -1)
        {
            bRet = TRUE;

            if (pdwFlags != NULL)
            {
                *pdwFlags = 0;
                GetVolumeInformation(szDrive, NULL, 0, NULL, NULL, pdwFlags, NULL, 0);
            }
        }
    }

    return bRet;
}


DWORD FindSpaceRequired(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir)
// Return the difference in size (in KBytes) of pcszFile (can contain wildcards)
// under pcszSrcDir and pcszDstDir (if specified)
{
    DWORD dwSizeReq = 0;
    CHAR szSrcFile[MAX_PATH], szDstFile[MAX_PATH];
    LPSTR pszSrcPtr, pszDstPtr;
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;

    lstrcpy(szSrcFile, pcszSrcDir);
    AddPath(szSrcFile, NULL);
    pszSrcPtr = szSrcFile + lstrlen(szSrcFile);

    if (pcszDstDir != NULL)
    {
        lstrcpy(szDstFile, pcszDstDir);
        AddPath(szDstFile, NULL);
        pszDstPtr = szDstFile + lstrlen(szDstFile);
    }

    lstrcpy(pszSrcPtr, pcszFile);
    if ((hFindFile = FindFirstFile(szSrcFile, &fileData)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                DWORD dwSrcSize, dwDstSize;

                // assumption here is that the size of the file doesn't exceed 4 gigs
                dwSrcSize = fileData.nFileSizeLow;
                dwDstSize = 0;

                if (pcszDstDir != NULL)
                {
                    lstrcpy(pszDstPtr, fileData.cFileName);
                    dwDstSize = FileSize(szDstFile);
                }

                if (dwSrcSize >= dwDstSize)
                {
                    // divide the difference by 1024 (we are interested in KBytes)
                    dwSizeReq += ((dwSrcSize - dwDstSize) >> 10);
                    if (dwSrcSize > dwDstSize)
                        dwSizeReq++;            // increment by 1 to promote any fraction to a whole number
                }
            }
        } while (FindNextFile(hFindFile, &fileData));

        FindClose(hFindFile);
    }

    return dwSizeReq;
}


VOID ParseIniLine(LPSTR pszLine, LPSTR *ppszFile, LPSTR *ppszSrcDir, LPSTR *ppszDstDir)
{
    if (ppszFile != NULL)
        *ppszFile = Trim(GetNextField(&pszLine, ",", REMOVE_QUOTES));
    if (ppszSrcDir != NULL)
        *ppszSrcDir = Trim(GetNextField(&pszLine, ",", REMOVE_QUOTES));
    if (ppszDstDir != NULL)
        *ppszDstDir = Trim(GetNextField(&pszLine, ",", REMOVE_QUOTES));
}


LPSTR GetDirPath(LPCSTR pcszRootDir, LPCSTR pcszSubDir, CHAR szDirPath[], DWORD cchBuffer, LPCSTR pcszIniFile)
{
    *szDirPath = '\0';

    if (pcszRootDir == NULL)
        return NULL;

    lstrcpyn(szDirPath, pcszRootDir, cchBuffer);
    if (pcszSubDir != NULL  &&  *pcszSubDir)
    {
        CHAR szTemp[MAX_PATH];

        // if there are any placeholders in pcszSubDir (%en%, etc), ReplacePlaceholders will replace
        // them with the actual strings
        if (ReplacePlaceholders(pcszSubDir, pcszIniFile, szTemp, sizeof(szTemp)))
        {
            if ((DWORD) lstrlen(szDirPath) + 1 < cchBuffer)     // there is room for '\\' which AddPath
                                                                // might append to szDirPath (see below)
            {
                INT iLen;

                AddPath(szDirPath, NULL);                       // we have enough room in szDirPath for '\\'

                if (cchBuffer > (DWORD) (iLen = lstrlen(szDirPath)))
                    lstrcpyn(szDirPath + iLen, szTemp, cchBuffer - iLen);
            }
        }
    }

    return szDirPath;
}


DWORD ReplacePlaceholders(LPCSTR pszSrc, LPCSTR pszIns, LPSTR pszBuffer, DWORD cchBuffer)
{
    LPCSTR pszAux;
    CHAR szResult[MAX_PATH];
    UINT nDestPos, nLeftPos;

    nDestPos = 0;
    nLeftPos = (UINT) -1;

    for (pszAux = pszSrc;  *pszAux;  pszAux = CharNext(pszAux))
    {
        if (*pszAux != '%')
        {
            szResult[nDestPos++] = *pszAux;

            if (IsDBCSLeadByte(*pszAux))
                szResult[nDestPos++] = *(pszAux + 1);   // copy the trail byte as well
        }
        else if (*(pszAux + 1) == '%')                  // "%%" is just '%' in the string
        {
            if (nLeftPos != (UINT) -1)
                // REVIEW: (andrewgu) "%%" are not allowed inside tokens. this also means that
                // tokens can't be like %foo%%bar%, where the intention is for foo and bar to
                // be tokens.
                return 0;

            szResult[nDestPos++] = *pszAux++;
        }
        else
        {
            UINT nRightPos;

            nRightPos = (UINT) (pszAux - pszSrc);       // initialized, but not necessarily used as such
            if (nLeftPos == (UINT) -1)
                nLeftPos = nRightPos;
            else
            {
                CHAR szAux1[MAX_PATH], szAux2[MAX_PATH];
                DWORD dwLen;
                UINT nTokenLen;

                // "%%" is invalid here
                nTokenLen = nRightPos - nLeftPos - 1;

                lstrcpyn(szAux1, pszSrc + nLeftPos + 1, nTokenLen + 1);

                if ((dwLen = GetPrivateProfileString("Strings", szAux1, "", szAux2, sizeof(szAux2), pszIns)))
                {
                    lstrcpy(&szResult[nDestPos - nTokenLen], szAux2);
                    nDestPos += dwLen - nTokenLen;
                }

                nLeftPos = (UINT) -1;
            }
        }
    }

    if (nLeftPos != (UINT) -1)                      // mismatched '%'
        return 0;

    if (cchBuffer <= nDestPos)                      // insufficient buffer size
        return 0;

    szResult[nDestPos] = '\0';                      // make sure zero terminated
    lstrcpy(pszBuffer, szResult);

    return nDestPos;
}


VOID SetAttribsToNormal(LPCSTR pcszFile, LPCSTR pcszDir)
// Set the attribs of pcszFile (can contain wildcards) under pcszDir to NORMAL
{
    CHAR szFile[MAX_PATH];
    LPSTR pszPtr;
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;

    lstrcpy(szFile, pcszDir);
    AddPath(szFile, NULL);
    pszPtr = szFile + lstrlen(szFile);

    lstrcpy(pszPtr, pcszFile);
    if ((hFindFile = FindFirstFile(szFile, &fileData)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                lstrcpy(pszPtr, fileData.cFileName);
                SetFileAttributes(szFile, FILE_ATTRIBUTE_NORMAL);
            }
        } while (FindNextFile(hFindFile, &fileData));

        FindClose(hFindFile);
    }
}


VOID CopyFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir, BOOL fQuiet)
{
    SHFILEOPSTRUCT shfStruc;
    CHAR szSrcFiles[MAX_PATH + 1];

    if (!PathExists(pcszDstDir))
        PathCreatePath(pcszDstDir);
    else
    {
        // set the attribs of files under pcszDstDir to NORMAL so that on a reinstall,
        // SHFileOperation doesn't choke on read-only files
        SetAttribsToNormal(pcszFile, pcszDstDir);
    }

    ZeroMemory(szSrcFiles, sizeof(szSrcFiles));
    lstrcpy(szSrcFiles, pcszSrcDir);
    AddPath(szSrcFiles, pcszFile);

    ZeroMemory(&shfStruc, sizeof(shfStruc));

    shfStruc.hwnd = NULL;
    shfStruc.wFunc = FO_COPY;
    shfStruc.pFrom = szSrcFiles;
    shfStruc.pTo = pcszDstDir;
    shfStruc.fFlags = FOF_FILESONLY | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;
    if (fQuiet)
        shfStruc.fFlags |= FOF_SILENT;

    SHFileOperation(&shfStruc);
}


VOID DelFiles(LPCSTR pcszFile, LPCSTR pcszDstDir)
{
    SHFILEOPSTRUCT shfStruc;
    CHAR szDstFiles[MAX_PATH + 1];

    // set the attribs of files under pcszDstDir to NORMAL so that
    // SHFileOperation doesn't choke on read-only files
    SetAttribsToNormal(pcszFile, pcszDstDir);

    ZeroMemory(szDstFiles, sizeof(szDstFiles));
    lstrcpy(szDstFiles, pcszDstDir);
    AddPath(szDstFiles, pcszFile);

    ZeroMemory(&shfStruc, sizeof(shfStruc));

    shfStruc.hwnd = NULL;
    shfStruc.wFunc = FO_DELETE;
    shfStruc.pFrom = szDstFiles;
    shfStruc.fFlags = FOF_FILESONLY | FOF_NOCONFIRMATION | FOF_SILENT | FOF_NOERRORUI;

    SHFileOperation(&shfStruc);
}


VOID ExtractFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir, EXTRACTFILES pfnExtractFiles)
{
    CHAR szSrcCab[MAX_PATH];

    lstrcpy(szSrcCab, pcszSrcDir);
    AddPath(szSrcCab, pcszFile);

    // NOTE: ExtractFiles fails if the dest dir doesn't exist
    if (!PathExists(pcszDstDir))
        PathCreatePath(pcszDstDir);
    else
    {
        // set the attribs of all the files under pcszDstDir to NORMAL so that on a reinstall,
        // ExtractFiles doesn't choke on read-only files
        SetAttribsToNormal("*.*", pcszDstDir);
    }

    pfnExtractFiles(szSrcCab, pcszDstDir, 0, NULL, NULL, 0);
}


VOID MoveFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir)
{
    // Can't use SHFileOperation to move files because on a reinstall,
    // we get an error saying that the target files already exist.
    // Workaround is to call CopyFiles and then DelFiles.

    CopyFiles(pcszSrcDir, pcszFile, pcszDstDir, TRUE);
    DelFiles(pcszFile, pcszSrcDir);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\setup\setup.c ===
#include <windows.h>
#include <shellapi.h>
#include <ver.h>
#include <malloc.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <dos.h>

#define IDS_FILE        1
#define IDS_VER         2
#define IDS_LOWVER      3
#define IDS_HIGHVER     4
#define IDS_OLDER       5
#define IDS_TITLE       6
#define IDS_NOSETUP     7
#define IDS_VERSION     8
#define IDS_LATESTVER   9

#define MAX_PATH 128
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define NUM_VERSION_NUM 4

HINSTANCE g_hInst;

char g_szTemp[1024];
char g_szTemp2[1024];
char g_szIExplore[128];
char g_szSetupExe[MAX_PATH];
BOOL g_fNoSetup = FALSE;

char *Res2Str(int nString)
{
    static BOOL fSet = FALSE;

    if(fSet)
    {
        LoadString(g_hInst, nString, g_szTemp, ARRAYSIZE(g_szTemp));
        fSet = FALSE;
        return(g_szTemp);
    }

    LoadString(g_hInst, nString, g_szTemp2, ARRAYSIZE(g_szTemp2));
    fSet = TRUE;
    return(g_szTemp2);
}

BOOL FileExists( LPSTR pszFile )
{
    HFILE hFile;
    OFSTRUCT ofsFile;

    hFile = OpenFile( pszFile, &ofsFile, OF_EXIST );
    if( hFile == HFILE_ERROR )
        return FALSE;

    return TRUE;
}
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = AnsiNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything
    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;    // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}

void FindSetupExeName( LPSTR szDir, LPSTR szName )
{
    lstrcpy( szName, "iesetup.exe" );
//    struct _find_t fileinfo;
//    int nRetVal = 0;
//    char szFind[MAX_PATH];
//
//    lstrcpy( szFind, szDir );
//    lstrcat( szFind, "\\*.exe" );
//
//    _dos_findfirst( szFind, 0, &fileinfo );
//
//    lstrcpy( szName, fileinfo.name );
}

void GetLanguage( LPSTR szLang, LPSTR szDir, int nSize )
{
// may need this later
//    struct _find_t fileinfo;
    int nRetVal = 0;
//    _dos_findfirst( "win31\\*.*", _A_SUBDIR, &fileinfo );
//    while( lstrlen( fileinfo.name ) != 3 && nRetVal == 0 )
//    {
//        nRetVal = _dos_findnext( &fileinfo );
//    }
//    lstrcpy( szLang, fileinfo.name );

    char szDirTemp[MAX_PATH];

    GetProfileString( "intl", "sLanguage", "eng", szLang, nSize);

    // special case english
    if( lstrcmpi( szLang, "enu" ) == 0 )
        lstrcpy( szLang, "eng" );

    // special case russian
    if(( lstrcmpi( szLang, "ukr" ) == 0 ) || ( lstrcmpi( szLang, "bel" ) == 0 ))
        lstrcpy( szLang, "rus" );

    // special case modern spanish

    if (lstrcmpi( szLang, "esn") == 0)
        lstrcpy( szLang, "esp");

    // special case french canadian

    if (lstrcmpi( szLang, "frc") == 0)
        lstrcpy( szLang, "fra");

    wsprintf( szDirTemp, "%s\\%s\\%s", szDir, szLang, (LPSTR)g_szSetupExe );

    if( !FileExists( szDirTemp ))
    {
        // special case Slovak -> Czech
        if( lstrcmpi( szLang, "sky" ) == 0 )
        {
            lstrcpy( szLang, "csy" );
            wsprintf( szDirTemp, "%s\\%s", szDir, szLang );
//            FindSetupExeName( szDirTemp, g_szSetupExe );
            wsprintf( szDirTemp, "%s\\%s\\%s", szDir, szLang, (LPSTR)g_szSetupExe );
        }
        else if( lstrcmpi( szLang, "csy" ) == 0 )
        {
            lstrcpy( szLang, "sky" );
            wsprintf( szDirTemp, "%s\\%s", szDir, szLang );
//            FindSetupExeName( szDirTemp, g_szSetupExe );
            wsprintf( szDirTemp, "%s\\%s\\%s", szDir, szLang, (LPSTR)g_szSetupExe );
        }
    }

    if( !FileExists( szDirTemp ))
    {
        struct _find_t fileinfo;
        char szFilePath[MAX_PATH];
        char szLang1[16];
        char szLang2[16];

        lstrcpy( szLang1, szLang );
        szLang1[2] = '\0';

        wsprintf( szFilePath, "%s\\*.*", szDir );

        _dos_findfirst( szFilePath, _A_SUBDIR, &fileinfo );
        lstrcpy(szLang2, fileinfo.name);
        szLang2[2] = '\0';

        while( nRetVal == 0 && lstrcmpi(szLang1, szLang2))
        {
            nRetVal = _dos_findnext( &fileinfo );
            lstrcpy(szLang2, fileinfo.name);
            szLang2[2] = '\0';
        }

        if (nRetVal == 0)
        {
            lstrcpy( szLang, fileinfo.name );
            lstrcpy( szDirTemp, szDir );
            lstrcat( szDirTemp, "\\" );
            lstrcat( szDirTemp, szLang );
            lstrcat( szDirTemp, "\\" );
            lstrcat( szDirTemp, g_szSetupExe );
        }
        else
            lstrcpy(szDirTemp, "");

    }

    if( !FileExists( szDirTemp ))
    {
        MessageBox( NULL, Res2Str( IDS_NOSETUP ), Res2Str( IDS_TITLE ), MB_OK | MB_ICONINFORMATION );
    }
//    // default to english if no other choice
//    if( !FileExists(szDirTemp) )
//    {
//        lstrcpy( szLang, "eng" );
//    }
}


void ConvertVersionStr(PSTR pszVer, WORD rwVer[])
{
    int i;
    for(i = 0; i < NUM_VERSION_NUM; i++)
        rwVer[i] = 0;

    for(i = 0; i < NUM_VERSION_NUM && pszVer; i++)
    {
        rwVer[i] = (WORD) atol(pszVer);
        pszVer = strchr(pszVer, '.');
        if (pszVer)
            pszVer++;
    }
}

// Returns:
//    -1   Ver1 < Ver2
//     0   Ver1 == Ver2
//     1   Ver1 > Ver2
// Notes:
int VersionCmp(WORD rwVer1[], WORD rwVer2[])
{
   int i;
   for(i = 0; i < NUM_VERSION_NUM; i++)
   {
      if(rwVer1[i] < rwVer2[i])
         return -1;
      if(rwVer1[i] > rwVer2[i])
         return 1;
   }
   return 0;
}

BOOL CheckVersion( LPSTR szIniFile )
{
    VS_FIXEDFILEINFO *lpVSFixedFileInfo;
    char szIExplore[MAX_PATH];
    BYTE *pVersionInfo;
    DWORD dwVerInfoSize;
    DWORD dwHandle;
    WORD rwRegVer[NUM_VERSION_NUM];
    WORD rwRegVer2[NUM_VERSION_NUM];
    char szData[32];
    char *pTemp;
    HKEY    hKey;
    
    if (RegOpenKey(HKEY_CLASSES_ROOT, "mhtmlfile\\shell\\open\\command", &hKey) != ERROR_SUCCESS)
        return FALSE;

    dwVerInfoSize = sizeof(szIExplore);
    if (RegQueryValue(hKey, NULL, szIExplore, &dwVerInfoSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    
    pTemp = strchr(szIExplore, ' ');
    if (pTemp)
        *pTemp = '\0';
    
    lstrcpy( g_szIExplore, szIExplore );

    // get the version information
    dwVerInfoSize = GetFileVersionInfoSize( szIExplore, &dwHandle );
    pVersionInfo = (BYTE *) malloc( (size_t)dwVerInfoSize );
    if( !pVersionInfo )
        return FALSE;

    if( !GetFileVersionInfo( szIExplore, dwHandle, dwVerInfoSize, pVersionInfo ))
    {
        free( pVersionInfo );
        return TRUE;
    }
    
    VerQueryValue( (const void FAR*)pVersionInfo, "\\", (VOID FAR* FAR*)&lpVSFixedFileInfo, (UINT FAR*)&dwVerInfoSize );
    rwRegVer[0] = HIWORD(lpVSFixedFileInfo->dwFileVersionMS);
    rwRegVer[1] = LOWORD(lpVSFixedFileInfo->dwFileVersionMS);
    rwRegVer[2] = HIWORD(lpVSFixedFileInfo->dwFileVersionLS);
    rwRegVer[3] = LOWORD(lpVSFixedFileInfo->dwFileVersionLS);

    free( pVersionInfo );
    if (LoadString(g_hInst, IDS_VERSION, szData, ARRAYSIZE(szData)) == 0)
        lstrcpy(szData, "5.0.913.2200");
    ConvertVersionStr(szData, rwRegVer2);
    
    return (VersionCmp(rwRegVer, rwRegVer2) >= 0);
}

int FAR PASCAL WinMain( HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow )
{
    DWORD dwVersion;
    DWORD dwFlags;
    char szDir[MAX_PATH];
    char szTempFile[1024];
//    char szLoadLine[1024];
    char szExecFile[MAX_PATH];
    char szPage[MAX_PATH];
//    char szTemp[MAX_PATH];
    char szLang[32];

    g_hInst = hInst;

    GetModuleFileName( hInst, szDir, MAX_PATH );
    _PathRemoveFileSpec( szDir );

    if( lstrlen( szDir ) < 4 )
        szDir[2] = '\0';

    if (LoadString(g_hInst, IDS_FILE, g_szSetupExe, ARRAYSIZE(g_szSetupExe)) == 0)
        lstrcpy(g_szSetupExe, "Setup.exe");
    // check for WinNT
    dwFlags = GetWinFlags( );
    if( dwFlags & 0x4000 )
    {
        lstrcat( szDir, "\\WIN32" );
        lstrcpy( szExecFile, szDir );
        lstrcat( szExecFile, "\\IE.EXE" );
        goto execsetup;
    }

    // check for Win95 and Win31
    dwVersion = GetVersion( );
    if( HIBYTE(LOWORD(dwVersion)) == 95 )
    {
        lstrcat( szDir, "\\WIN32" );
        lstrcpy( szExecFile, szDir );
        lstrcat( szExecFile, "\\IE.EXE" );
    }
    else
    {
        lstrcat( szDir, "\\WIN16" );

        GetLanguage( szLang, szDir, ARRAYSIZE(szLang) );

        /***
        GetProfileString( "iesk", "load", "", szLoadLine, ARRAYSIZE( szLoadLine ));
        if( lstrlen( szLoadLine ) > 0 )
            WriteProfileString( "windows", "load", szLoadLine );
        else
            WriteProfileString( "windows", "load", "" );

        memset( szLoadLine, 0, ARRAYSIZE( szLoadLine ));
        ***/

        // check for IE
        GetWindowsDirectory( szTempFile, MAX_PATH );
        lstrcat( szTempFile, "\\iexplore.ini" );

        lstrcpy( szPage, szDir );
        lstrcat( szPage, "\\" );
        lstrcat( szPage, szLang );
        lstrcat( szPage, "\\BIN\\START.HTM" );

        if(CheckVersion( szTempFile ))
        {
            HINSTANCE hIEInst;

            if (FileExists(szPage))
            {
                lstrcpy( szPage, "-k -slf file:");
                lstrcat( szPage, szDir );
                lstrcat( szPage, "\\" );
                lstrcat( szPage, szLang );
                lstrcat( szPage, "\\BIN\\START.HTM" );

                hIEInst=ShellExecute( NULL, NULL, "IEXPLORE.EXE", szPage, "", SW_SHOWNORMAL );
                
                if(hIEInst <= 32) //shell execute failed
                {
                    ShellExecute( NULL, NULL, g_szIExplore, szPage, "", SW_SHOWNORMAL );                
                }
            }
            else
            {
                MessageBox( NULL, Res2Str( IDS_LATESTVER), Res2Str( IDS_TITLE ), MB_OK );
            }

            return 1;
        }
        else
        {
            char szFileName[MAX_PATH];
            int nRetVal = 0;

            if( g_fNoSetup )
                return 1;

            if (FileExists(szPage))
            {
                // write to the [ieak] section; runonc16.exe would read this in and run it
                // at the end of runonce processing (it would delete this entry after reading it in).
                GetModuleFileName( hInst, szFileName, MAX_PATH );
                WriteProfileString("ieak", "load", szFileName);

                /***
                GetProfileString( "windows", "load", "", szLoadLine, ARRAYSIZE( szLoadLine ));
                if( lstrlen( szLoadLine ) > 0 )
                {
                    WriteProfileString( "iesk", "load", szLoadLine );
                    lstrcat( szLoadLine, ";" );
                }

                lstrcat( szLoadLine, szFileName );
                WriteProfileString( "windows", "load", szLoadLine );
                ***/
            }

            lstrcpy( szExecFile, szDir );
            lstrcat( szExecFile, "\\");
            lstrcat( szExecFile, szLang );
            lstrcat( szExecFile, "\\" );
            lstrcat( szExecFile, g_szSetupExe );

        }
    }

execsetup:
    ShellExecute( NULL, NULL, szExecFile, "", szDir, SW_SHOWNORMAL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cdinst\utils.cpp ===
#include <windows.h>
#include "cdinst.h"


VOID ParseCmdLine(LPSTR pszCmdLine)
{
    LPSTR pszCurrArg;
    LPSTR pszPtr;

    GetNextField(&pszCmdLine, "/", 0);              // point to the first argument
    while ((pszCurrArg = GetNextField(&pszCmdLine, "/", 0)) != NULL)
    {
        switch (*pszCurrArg)
        {
            case 's':
            case 'S':
                if (*++pszCurrArg == ':')
                    pszCurrArg++;

                // Source dir from where to grab the files
                if ((pszPtr = Trim(GetNextField(&pszCurrArg, ",", REMOVE_QUOTES))) != NULL)
                    lstrcpy(g_szSrcDir, pszPtr);
                else
                    *g_szSrcDir = '\0';

                break;

            case 'd':
            case 'D':
                if (*++pszCurrArg == ':')
                    pszCurrArg++;

                // Destination dir to where to copy the files
                if ((pszPtr = Trim(GetNextField(&pszCurrArg, ",", REMOVE_QUOTES))) != NULL)
                    lstrcpy(g_szDstDir, pszPtr);
                else
                    *g_szDstDir = '\0';

                break;

            default:                                // ignore these arguments
                break;
        }
    }
}


DWORD ReadSectionFromInf(LPCSTR pcszSecName, LPSTR *ppszBuf, PDWORD pdwBufLen, LPCSTR pcszInfName)
{
    DWORD dwRet;

    // set the file attrib of pcszInfName to NORMAL so that GetPrivateProfileSecion doesn't
    // barf in case pcszInfName is read only
    SetFileAttributes(pcszInfName, FILE_ATTRIBUTE_NORMAL);

    // keep allocating buffers in increasing size of 1K till the entire section is read
    *ppszBuf = NULL;
    *pdwBufLen = 1024;
    do
    {
        if (*ppszBuf != NULL)
            LocalFree(*ppszBuf);            // free the previously allocated memory

        if (*pdwBufLen == MAX_BUF_LEN)
            (*pdwBufLen)--;                   // 32K - 1 is the size limit for a section

        if ((*ppszBuf = (LPSTR) LocalAlloc(LPTR, *pdwBufLen)) == NULL)
        {
            *pdwBufLen = 0;
            return 0;
        }
    } while ((dwRet = GetPrivateProfileSection(pcszSecName, *ppszBuf, *pdwBufLen, pcszInfName)) == *pdwBufLen - 2  &&
             (*pdwBufLen += 1024) <= MAX_BUF_LEN);

    return dwRet;
}


BOOL PathExists(LPCSTR pcszDir)
{
    DWORD dwAttrib = GetFileAttributes(pcszDir);

    return (dwAttrib != (DWORD) -1)  &&  (dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
}


BOOL FileExists(LPCSTR pcszFileName)
{
    DWORD dwAttrib = GetFileAttributes(pcszFileName);

    if (dwAttrib == (DWORD) -1)
        return FALSE;

    return !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
}


DWORD FileSize(LPCSTR pcszFile)
{
    DWORD dwFileSize = 0;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile;

    if (pcszFile == NULL  ||  *pcszFile == '\0')
        return dwFileSize;

    if ((hFile = FindFirstFile(pcszFile, &FindFileData)) != INVALID_HANDLE_VALUE)
    {
        // assumption here is that the size of the file doesn't exceed 4 gigs
        dwFileSize = FindFileData.nFileSizeLow;
        FindClose(hFile);
    }

    return dwFileSize;
}


LPSTR AddPath(LPSTR pszPath, LPCSTR pcszFileName)
{
    LPSTR pszPtr;

    if (pszPath == NULL)
        return NULL;

    pszPtr = pszPath + lstrlen(pszPath);
    if (pszPtr > pszPath  &&  *CharPrev(pszPath, pszPtr) != '\\')
        *pszPtr++ = '\\';

    if (pcszFileName != NULL)
        lstrcpy(pszPtr, pcszFileName);
    else
        *pszPtr = '\0';

    return pszPath;
}


BOOL PathIsUNCServer(LPCSTR pcszPath)
{
    if (PathIsUNC(pcszPath))
    {
        int i = 0;

        for ( ;  pcszPath != NULL && *pcszPath;  pcszPath = CharNext(pcszPath))
            if (*pcszPath == '\\')
                i++;

       return i == 2;
    }

    return FALSE;
}


BOOL PathIsUNCServerShare(LPCSTR pcszPath)
{
    if (PathIsUNC(pcszPath))
    {
        int i = 0;

        for ( ;  pcszPath != NULL && *pcszPath;  pcszPath = CharNext(pcszPath))
            if (*pcszPath == '\\')
                i++;

       return i == 3;
    }

    return FALSE;
}


BOOL PathCreatePath(LPCSTR pcszPathToCreate)
{
    CHAR szPath[MAX_PATH];
    LPSTR pszPtr;

    if (pcszPathToCreate == NULL  ||  lstrlen(pcszPathToCreate) <= 3)
        return FALSE;

    // eliminate relative paths
    if (!PathIsFullPath(pcszPathToCreate)  &&  !PathIsUNC(pcszPathToCreate))
        return FALSE;

    if (PathIsUNCServer(pcszPathToCreate)  ||  PathIsUNCServerShare(pcszPathToCreate))
        return FALSE;

    lstrcpy(szPath, pcszPathToCreate);

    // chop off the trailing backslash, if it exists
    pszPtr = CharPrev(szPath, szPath + lstrlen(szPath));
    if (*pszPtr == '\\')
        *pszPtr = '\0';

    // if it's a UNC path, seek up to the first dir after the share name
    if (PathIsUNC(szPath))
    {
        INT i;

        pszPtr = &szPath[2];

        for (i = 0;  i < 2;  i++)
            for ( ;  *pszPtr != '\\';  pszPtr = CharNext(pszPtr))
                ;

        pszPtr = CharNext(pszPtr);
    }
    else        // otherwise, just point to the beginning of the first dir
        pszPtr = &szPath[3];

    for ( ;  *pszPtr;  pszPtr = CharNext(pszPtr))
    {
        CHAR ch;

        // skip the non-backslash chars
        while (*pszPtr  &&  *pszPtr != '\\')
            pszPtr = CharNext(pszPtr);

        // save the current char
        ch = *pszPtr;

        *pszPtr = '\0';
        if (GetFileAttributes(szPath) == 0xFFFFFFFF)        // dir doesn't exist
            if (!CreateDirectory(szPath, NULL))
                return FALSE;

        // restore the current char
        *pszPtr = ch;
    }

    return TRUE;
}


VOID ErrorMsg(UINT uStringID)
{
    ErrorMsg(uStringID, "", "");
}


VOID ErrorMsg(UINT uStringID, LPCSTR pcszParam1, LPCSTR pcszParam2)
{
    LPSTR pszTextString;

    pszTextString = FormatMessageString(uStringID, pcszParam1, pcszParam2);

    MessageBox(NULL, (pszTextString != NULL) ? pszTextString : "", g_szTitle, MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_OK);

    if (pszTextString != NULL)
        LocalFree(pszTextString);
}


INT ErrorMsg(UINT uStringID, DWORD dwParam1, DWORD dwParam2)
{
    INT iRet;
    LPSTR pszTextString;

    pszTextString = FormatMessageString(uStringID, dwParam1, dwParam2);

    iRet = MessageBox(NULL, (pszTextString != NULL) ? pszTextString : "", g_szTitle, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2 | MB_SETFOREGROUND);

    if (pszTextString != NULL)
        LocalFree(pszTextString);

    return iRet;
}


LPSTR FormatMessageString(UINT uStringID, LPCSTR pcszParam1, LPCSTR pcszParam2)
{
    CHAR szBuf[512];

    if (LoadString(g_hInst, uStringID, szBuf, sizeof(szBuf)))
    {
        LPSTR pszTextString;

        if ((pszTextString = FormatString(szBuf, pcszParam1, pcszParam2)) != NULL)
            return pszTextString;
    }

    return NULL;
}


LPSTR FormatMessageString(UINT uStringID, DWORD dwParam1, DWORD dwParam2)
{
    CHAR szBuf[512];

    if (LoadString(g_hInst, uStringID, szBuf, sizeof(szBuf)))
    {
        LPSTR pszTextString;

        if ((pszTextString = FormatString(szBuf, dwParam1, dwParam2)) != NULL)
            return pszTextString;
    }

    return NULL;
}


LPSTR FormatString(LPCSTR pcszFormatString, ...)
{
    va_list vaArgs;
    LPSTR pszOutString = NULL;

    va_start(vaArgs, pcszFormatString);
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                  (LPCVOID) pcszFormatString, 0, 0, (PSTR) &pszOutString, 0, &vaArgs);
    va_end(vaArgs);

    return pszOutString;
}


LPSTR GetNextField(LPSTR *ppszData, LPCSTR pcszDeLims, DWORD dwFlags)
// If (dwFlags & IGNORE_QUOTES) is TRUE, then look for any char in pcszDeLims in *ppszData.  If found,
// replace it with the '\0' char and set *ppszData to point to the beginning of the next field and return
// pointer to current field.
//
// If (dwFlags & IGNORE_QUOTES) is FALSE, then look for any char in pcszDeLims outside of balanced quoted sub-strings
// in *ppszData.  If found, replace it with the '\0' char and set *ppszData to point to the beginning of
// the next field and return pointer to current field.
//
// If (dwFlags & REMOVE_QUOTES) is TRUE, then remove the surrounding quotes and replace two consecutive quotes by one.
//
// NOTE: If IGNORE_QUOTES and REMOVE_QUOTES are both specified, then IGNORE_QUOTES takes precedence over REMOVE_QUOTES.
//
// If you just want to remove the quotes from a string, call this function as
// GetNextField(&pszData, "\"" or "'" or "", REMOVE_QUOTES).
//
// If you call this function as GetNextField(&pszData, "\"" or "'" or "", 0), you will get back the
// entire pszData as the field.
//
{
    LPSTR pszRetPtr, pszPtr;
    BOOL fWithinQuotes = FALSE, fRemoveQuote;
    CHAR chQuote;

    if (ppszData == NULL  ||  *ppszData == NULL  ||  **ppszData == '\0')
        return NULL;

    for (pszRetPtr = pszPtr = *ppszData;  *pszPtr;  pszPtr = CharNext(pszPtr))
    {
        if (!(dwFlags & IGNORE_QUOTES)  &&  (*pszPtr == '"'  ||  *pszPtr == '\''))
        {
            fRemoveQuote = FALSE;

            if (*pszPtr == *(pszPtr + 1))           // two consecutive quotes become one
            {
                pszPtr++;

                if (dwFlags & REMOVE_QUOTES)
                    fRemoveQuote = TRUE;
                else
                {
                    // if pcszDeLims is '"' or '\'', then *pszPtr == pcszDeLims would
                    // be TRUE and we would break out of the loop against the design specs;
                    // to prevent this just continue
                    continue;
                }
            }
            else if (!fWithinQuotes)
            {
                fWithinQuotes = TRUE;
                chQuote = *pszPtr;                  // save the quote char

                fRemoveQuote = dwFlags & REMOVE_QUOTES;
            }
            else
            {
                if (*pszPtr == chQuote)             // match the correct quote char
                {
                    fWithinQuotes = FALSE;
                    fRemoveQuote = dwFlags & REMOVE_QUOTES;
                }
            }

            if (fRemoveQuote)
            {
                // shift the entire string one char to the left to get rid of the quote char
                MoveMemory(pszPtr, pszPtr + 1, lstrlen(pszPtr));
            }
        }

        // BUGBUG: Is type casting pszPtr to UNALIGNED necessary? -- copied it from ANSIStrChr
        // check if pszPtr is pointing to one of the chars in pcszDeLims
        if (!fWithinQuotes  &&
            ANSIStrChr(pcszDeLims, (WORD) (IsDBCSLeadByte(*pszPtr) ? *((UNALIGNED WORD *) pszPtr) : *pszPtr)) != NULL)
            break;
    }

    // NOTE: if fWithinQuotes is TRUE here, then we have an unbalanced quoted string; but we don't care!
    //       the entire string after the beginning quote becomes the field

    if (*pszPtr)                                    // pszPtr is pointing to a char in pcszDeLims
    {
        *ppszData = CharNext(pszPtr);               // save the pointer to the beginning of next field in *ppszData
        *pszPtr = '\0';                             // replace the DeLim char with the '\0' char
    }
    else
        *ppszData = pszPtr;                         // we have reached the end of the string; next call to this function
                                                    // would return NULL

    return pszRetPtr;
}


LPSTR Trim(LPSTR pszData)
// Trim the leading and trailing white space chars in pszData
{
    LPSTR pszRetPtr;

    if (pszData == NULL)
        return NULL;

    // trim the leading white space chars
    for ( ;  *pszData;  pszData = CharNext(pszData))
        if (!IsSpace(*pszData))
            break;

    // save the return ptr
    pszRetPtr = pszData;

    // go to the end and start trimming the trailing white space chars
    pszData += lstrlen(pszData);
    while ((pszData = CharPrev(pszRetPtr, pszData)) != pszRetPtr)
        if (!IsSpace(*pszData))
            break;

    if (*pszData)
    {
        pszData = CharNext(pszData);
        *pszData = '\0';
    }

    return pszRetPtr;
}


// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR FAR ANSIStrChr(LPCSTR lpStart, WORD wMatch)
{
    for ( ; *lpStart; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}


// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR FAR ANSIStrRChr(LPCSTR lpStart, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    for ( ; *lpStart; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}


// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cd\setup\version.h ===
#define OFFICIAL   1
#define FINAL      1

#define IEDKIT

/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the         *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values            *
 *                                                                          *
 ****************************************************************************/

/*XLATOFF*/
#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include "ver.h"
#endif 
/*XLATON*/

/*--------------------------------------------------------------*/
/*                                                              */
/*                    CHANGING VERSION?                         */
/*                                                              */
/*                      PLEASE READ!                            */
/*                                                              */
/* The version has BOTH hex and string representations.  Take   */
/* care that the string version components are PROPERLY         */
/* CONVERTED TO HEX and that the hex values are INSERTED INTO   */
/* THE CORRECT POSITION in the hex versions.                    */
/*                                                              */
/* Suppose the version was being defined as:                    */
/*                                                              */
/*           #define VERSION  "9.99.1234"                       */
/*                                                              */
/* The other string preresentations of the version would be:    */ 
/*                                                              */
/*           #define VER_PRODUCTVERSION_STR  "9.99.1234\0"      */
/*           #define VER_PRODUCTVERSION       9,99,0,1234       */
/*                                                              */
/* The hex versions would NOT be 0x0999????.  The correct       */
/* definitions are:                                             */
/*                                                              */
/*    #define VER_PRODUCTVERSION_BUILD 1234                     */
/*    #define VER_PRODUCTVERSION_DW    (0x09630000 | 1234)      */
/*    #define VER_PRODUCTVERSION_W     (0x0963)                 */
/*                                                              */
/* The last four digits of the build number should be modified  */
/* by the official builder for each build.                      */
/*                                                              */
/*--------------------------------------------------------------*/
#if defined(IEDKIT)

/*--------------------------------------------------------------*/
/* Version numbers for IE Distribution kit                      */
/*--------------------------------------------------------------*/

#define VERSION                     "3.0.0.0006"
#define VER_PRODUCTVERSION_STR      "3.0.0.0006\0"
#define VER_PRODUCTVERSION          3,0,0,6
#define VER_PRODUCTVERSION_BUILD    6
#define VER_PRODUCTVERSION_DW       (0x01000000 | 6)
#define VER_PRODUCTVERSION_W        (0x0100)
#endif


/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"

#define VER_PRODUCTNAME_STR         "Microsoft\256 Internet Explorer CD\0"

#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\cdinst\cdinst.h ===
// CDINST.H

// macro definitions
#define REMOVE_QUOTES           0x01
#define IGNORE_QUOTES           0x02

#define MAX_BUF_LEN             (32 * 1024)         // 32K - 1 is the size limit for a section in an INF

#define IsSpace(c)              ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')

#define PathIsFullPath(p)       ((p)[1] == ':'   &&  (p)[2] == '\\')
#define PathIsUNC(p)            ((p)[0] == '\\'  &&  (p)[1] == '\\')


// type definitions
typedef HRESULT (WINAPI * EXTRACTFILES)(LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags,
                                        LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved);


// prototype declarations for functions in cdinst.cpp
BOOL EnoughDiskSpace(LPCSTR pcszSrcRootDir, LPCSTR pcszDstRootDir, LPCSTR pcszIniFile, LPDWORD pdwSpaceReq, LPDWORD pdwSpaceFree);
BOOL GetFreeDiskSpace(LPCSTR pcszDir, LPDWORD pdwFreeSpace, LPDWORD pdwFlags);
DWORD FindSpaceRequired(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir);

VOID ParseIniLine(LPSTR pszLine, LPSTR *ppszFile, LPSTR *ppszSrcDir, LPSTR *ppszDstDir);

LPSTR GetDirPath(LPCSTR pcszRootDir, LPCSTR pcszSubDir, CHAR szDirPath[], DWORD cchBuffer, LPCSTR pcszIniFile);
DWORD ReplacePlaceholders(LPCSTR pszSrc, LPCSTR pszIns, LPSTR pszBuffer, DWORD cchBuffer);

VOID SetAttribsToNormal(LPCSTR pcszFile, LPCSTR pcszDir);

VOID CopyFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir, BOOL fQuiet);
VOID DelFiles(LPCSTR pcszFile, LPCSTR pcszDstDir);
VOID ExtractFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir, EXTRACTFILES pfnExtractFiles);
VOID MoveFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir);

// prototype declarations for functions in utils.cpp
VOID ParseCmdLine(LPSTR pszCmdLine);

DWORD ReadSectionFromInf(LPCSTR pcszSecName, LPSTR *ppszBuf, PDWORD pdwBufLen, LPCSTR pcszInfName);

BOOL PathExists(LPCSTR pcszDir);
BOOL FileExists(LPCSTR pcszFileName);
DWORD FileSize(LPCSTR pcszFile);
LPSTR AddPath(LPSTR pszPath, LPCSTR pcszFileName);
BOOL PathIsUNCServer(LPCSTR pcszPath);
BOOL PathIsUNCServerShare(LPCSTR pcszPath);
BOOL PathCreatePath(LPCSTR pcszPathToCreate);

VOID ErrorMsg(UINT uStringID);
VOID ErrorMsg(UINT uStringID, LPCSTR pcszParam1, LPCSTR pcszParam2);
INT ErrorMsg(UINT uStringID, DWORD dwParam1, DWORD dwParam2);
LPSTR FormatMessageString(UINT uStringID, LPCSTR pcszParam1, LPCSTR pcszParam2);
LPSTR FormatMessageString(UINT uStringID, DWORD dwParam1, DWORD dwParam2);
LPSTR FormatString(LPCSTR pcszFormatString, ...);

LPSTR GetNextField(LPSTR *ppszData, LPCSTR pcszDeLims, DWORD dwFlags);
LPSTR Trim(LPSTR pszData);

LPSTR FAR ANSIStrChr(LPCSTR lpStart, WORD wMatch);
LPSTR FAR ANSIStrRChr(LPCSTR lpStart, WORD wMatch);
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch);


// extern declaration of global variables
extern HINSTANCE g_hInst;
extern CHAR g_szTitle[];
extern CHAR g_szSrcDir[], g_szDstDir[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\adm.h ===
#ifndef _ADM_H_
#define _ADM_H_

class CDscrWnd
{
private:
    HWND  hWndMain;
    HWND  hWndDscrTitle;
    HWND  hWndDscrText;
    HFONT hFontDscrTitle;

public:
    CDscrWnd();
    ~CDscrWnd();
    void Create(HWND hWndParent, HWND hWndInsertAfter, int nXPos, int nYPos, int nWidth, int nHeight);
    void SetText(LPCTSTR pcszTitle, LPCTSTR pcszText, BOOL fUpdateWindowState = TRUE);
    void ShowWindow(BOOL fShow);
    void GetRect(RECT* lpRect);
    void MoveWindow(int nXPos, int nYPos, int nWidth, int nHeight);
};

#endif // _ADM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\adm.cpp ===
// adm.cpp

#include "precomp.h"
#include "admparse.h"
#include "adm.h"

typedef struct Category
{
    LPTSTR pszName;
    HWND hWnd;
    HKEY hKeyClass;
    LPVOID pData;
	BOOL fRSoPMode;
} ADMCategory;

typedef struct ADM
{
    LPTSTR pszName;
    TCHAR  szFileName[MAX_PATH];
    DWORD  dwAdm;
    LPVOID pData;
} ADMFile;

#define ADM_DSCRLEN         32767
#define ADM_DSCRLINELEN     100
#define ADM_TITLELEN        100

TCHAR g_szLogFileName[MAX_PATH];
HTREEITEM g_hPolicyRootItem = NULL; // only used by profile manager
int g_ADMClose, g_ADMCategory;

#define GetFirstPolicyItem(hTreeView)    ((g_hPolicyRootItem != NULL) ? TreeView_GetChild(hTreeView, g_hPolicyRootItem) : TreeView_GetRoot(hTreeView))
#define PolicyRoot()    ((g_hPolicyRootItem != NULL) ? g_hPolicyRootItem : NULL)
#define IsWizard()      ((g_hPolicyRootItem == NULL) ? TRUE : FALSE)

// private helper functions
static HFONT getBoldFont(HWND hWnd);
static BOOL isADMFileVisibleHelper(LPCTSTR pcszFileName, int nRole, DWORD dwPlatformId);
static BOOL loadADMFilesHelper(HWND hTreeView, HTREEITEM hPolicyRootItem,
                               LPCTSTR pcszADMFilePath, LPCTSTR pcszWorkDir,
                               DWORD dwPlatformId, int nRole,
                               int nIconADMClose, int nIconADMCategory);
static void deleteADMItemHelper(HWND hTreeView, HTREEITEM hParentItem, LPCTSTR pcszWorkDir,
                                LPCTSTR pcszInsFile, BOOL bDeleteFile, BOOL bSave);
static void deleteADMItemsHelper(HWND hTreeView, LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile,
                                 BOOL bSave);
static void getADMDescriptionTitle(LPCTSTR pcszFileName, LPTSTR pszDscrTitle);
static void getADMDescription(LPCTSTR pcszFileName, LPTSTR pszDscr);
static void importADMFileHelper(HWND hMainWnd, HWND hTreeView, LPCTSTR pcszADMFilePath,
                                LPCTSTR pcszWorkDir, int nRole, LPCTSTR pcszInsFile);
static void resetAdmFilesHelper(HWND hTreeView, LPCTSTR pcszWorkDir, BOOL bReset);
static void saveAdmFilesHelper(HWND hTreeView, LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile);
static INT_PTR CALLBACK logDialogProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM);
static BOOL getAdmFileListHelper(LPRESULTITEM* pResultItems, int* pnResultItems, int nRole);
static HTREEITEM addADMItemHelper(HWND hTreeView, LPCTSTR pcszADMFilePath, LPCTSTR pcszFileName,
                                  LPCTSTR pcszWorkDir, int nRole, BSTR bstrRSoPNamespace);

void WINAPI CreateADMWindow(HWND hOwner, HWND hWndInsertAfter, int nXPos, int nYPos,
                            int nWidth, int nHeight)
{
    CDscrWnd* pDscrWnd = new CDscrWnd;
    if (pDscrWnd != NULL)
    {
        SetWindowLongPtr(hOwner, GWLP_USERDATA, (LONG_PTR)pDscrWnd);
        pDscrWnd->Create(GetParent(hOwner), hWndInsertAfter, nXPos, nYPos, nWidth, nHeight);
    }
}

void WINAPI ShowADMWindow(HWND hOwner, BOOL fShow)
{
    CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hOwner, GWLP_USERDATA);
    
    if (pDscrWnd != NULL)
        pDscrWnd->ShowWindow(fShow);
}

void WINAPI MoveADMWindow(HWND hOwner, int nXPos, int nYPos, int nWidth, int nHeight)
{
    CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hOwner, GWLP_USERDATA);
    
    if (pDscrWnd != NULL)
        pDscrWnd->MoveWindow(nXPos, nYPos, nWidth, nHeight);
}

void WINAPI SetADMWindowTextA(HWND hOwner, LPCSTR pcszTitle, LPCSTR pcszText,
                              BOOL fUpdateWindowState /* = TRUE */)
{
    USES_CONVERSION;

    CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hOwner, GWLP_USERDATA);
    
    if (pDscrWnd != NULL)
        pDscrWnd->SetText(A2CT(pcszTitle), A2CT(pcszText), fUpdateWindowState);
}

void WINAPI SetADMWindowTextW(HWND hOwner, LPCWSTR pcwszTitle, LPCWSTR pcwszText,
                              BOOL fUpdateWindowState /* = TRUE */)
{
    USES_CONVERSION;

    CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hOwner, GWLP_USERDATA);
    
    if (pDscrWnd != NULL)
        pDscrWnd->SetText(W2CT(pcwszTitle), W2CT(pcwszText), fUpdateWindowState);
}

void WINAPI DestroyADMWindow(HWND hOwner)
{
    CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hOwner, GWLP_USERDATA);
    
    if (pDscrWnd != NULL)
    {
        delete pDscrWnd;
        SetWindowLongPtr(hOwner, GWLP_USERDATA, 0L);
    }
}

BOOL WINAPI IsADMFileVisibleA(LPCSTR pcszFileName, int nRole, DWORD dwPlatformId)
{
    USES_CONVERSION;

    return isADMFileVisibleHelper(A2CT(pcszFileName), nRole, dwPlatformId);
}

BOOL WINAPI IsADMFileVisibleW(LPCWSTR pcwszFileName, int nRole, DWORD dwPlatformId)
{
    USES_CONVERSION;

    return isADMFileVisibleHelper(W2CT(pcwszFileName), nRole, dwPlatformId);
}

BOOL WINAPI LoadADMFilesA(HWND hTreeView, HTREEITEM hPolicyRootItem, LPCSTR pcszADMFilePath,
                          LPCSTR pcszWorkDir, DWORD dwPlatformId, int nRole,
                          int nIconADMClose, int nIconADMCategory)
{
    USES_CONVERSION;

    return loadADMFilesHelper(hTreeView, hPolicyRootItem, A2CT(pcszADMFilePath),
        A2CT(pcszWorkDir), dwPlatformId, nRole, nIconADMClose, nIconADMCategory);
}

BOOL WINAPI LoadADMFilesW(HWND hTreeView, HTREEITEM hPolicyRootItem, LPCWSTR pcwszADMFilePath,
                          LPCWSTR pcwszWorkDir, DWORD dwPlatformId, int nRole,
                          int nIconADMClose, int nIconADMCategory)
{
    USES_CONVERSION;

    return loadADMFilesHelper(hTreeView, hPolicyRootItem, W2CT(pcwszADMFilePath),
        W2CT(pcwszWorkDir), dwPlatformId, nRole, nIconADMClose, nIconADMCategory);
}

void WINAPI DeleteADMItemA(HWND hTreeView, HTREEITEM hParentItem, LPCSTR pcszWorkDir,
                           LPCSTR pcszInsFile, BOOL bDeleteFile, BOOL bSave)
{
    USES_CONVERSION;

    deleteADMItemHelper(hTreeView, hParentItem, A2CT(pcszWorkDir), A2CT(pcszInsFile),
        bDeleteFile, bSave);
}

void WINAPI DeleteADMItemW(HWND hTreeView, HTREEITEM hParentItem, LPCWSTR pcwszWorkDir,
                           LPCWSTR pcwszInsFile, BOOL bDeleteFile, BOOL bSave)
{
    USES_CONVERSION;

    deleteADMItemHelper(hTreeView, hParentItem, W2CT(pcwszWorkDir), W2CT(pcwszInsFile),
        bDeleteFile, bSave);
}

void WINAPI DeleteADMItemsA(HWND hTreeView, LPCSTR pcszWorkDir, LPCSTR pcszInsFile,
                            BOOL bSave)
{
    USES_CONVERSION;

    deleteADMItemsHelper(hTreeView, A2CT(pcszWorkDir), A2CT(pcszInsFile), bSave);
}

void WINAPI DeleteADMItemsW(HWND hTreeView, LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile,
                            BOOL bSave)
{
    USES_CONVERSION;

    deleteADMItemsHelper(hTreeView, W2CT(pcwszWorkDir), W2CT(pcwszInsFile), bSave);
}

// Displays the description of the adm file or displays the category window
// depending on whether the selected item was an ADMFile Item or a category item.
void WINAPI DisplayADMItem(HWND hWnd, HWND hTreeView, LPTVITEM lpSelectedItem,
                           BOOL fShowDisabled)
{
    TV_ITEM tvitem;
    HWND hAdmWnd = NULL;
    RECT rect;
    RECT wndRect;
    HTREEITEM hParentItem = TreeView_GetParent(hTreeView, lpSelectedItem->hItem);
    int nWidth, nHeight;
    TCHAR szDscrTitle[ADM_TITLELEN];
    TCHAR szDscr[ADM_DSCRLEN];
    ADMFile* pADMFile;

    if(hParentItem != PolicyRoot())
    {   // item is a category
        ShowADMWindow(hTreeView, FALSE);
        if(lpSelectedItem->lParam != NULL)
        {
            ADMCategory* pADMCategory;

            tvitem.mask = TVIF_PARAM;
            tvitem.hItem = hParentItem;
            TreeView_GetItem(hTreeView, &tvitem);

            // get the cooridnates to display the window
            // the coordinates are the same as the static instruction window
            GetWindowRect(hWnd, &wndRect);

            if(!IsWizard())
            {
                wndRect.left += GetSystemMetrics(SM_CXFIXEDFRAME);
                wndRect.top += (GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYMENU) +
                                GetSystemMetrics(SM_CYFIXEDFRAME));
            }

            CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hTreeView, GWLP_USERDATA);
            if (pDscrWnd != NULL)
            {
                pDscrWnd->GetRect(&rect);
                
                rect.right = (rect.left - wndRect.left) + (rect.right - rect.left);
                rect.bottom = (rect.top - wndRect.top) + (rect.bottom - rect.top);
                rect.left = rect.left - wndRect.left;
                rect.top = rect.top - wndRect.top;
            }
            else
            {
                RECT rectTreeView;

                GetWindowRect(hTreeView, &rectTreeView);

                rect.left = rectTreeView.right - wndRect.left + 7;
                rect.top = rectTreeView.top - wndRect.top + 2;
                rect.right = (wndRect.right -  wndRect.left - 7 -
                               ((!IsWizard()) ? GetSystemMetrics(SM_CXFIXEDFRAME) : 0));
                rect.bottom = rect.top + rectTreeView.bottom - rectTreeView.top - 4;
            }

            nWidth = rect.right - rect.left;
            nHeight = rect.bottom - rect.top;

            pADMFile = (ADMFile*)tvitem.lParam;
            pADMCategory = (ADMCategory*)lpSelectedItem->lParam;

            // Display the window associated with the item/category
            CreateAdmUi(pADMFile->dwAdm, hWnd, rect.left, rect.top, nWidth, nHeight,
                WS_TABSTOP, 0, pADMCategory->pszName, pADMCategory->hKeyClass, &hAdmWnd,
                pADMFile->pData, &pADMCategory->pData, pADMCategory->fRSoPMode);
            pADMCategory->hWnd = hAdmWnd;

            if(fShowDisabled)
                EnableWindow(hAdmWnd, FALSE);
            else
                EnableWindow(hAdmWnd, TRUE);
        }
    }
    else
    {   // item is a adm file
        ShowADMWindow(hTreeView, TRUE);
        ZeroMemory(szDscrTitle, ADM_TITLELEN);
        ZeroMemory(szDscr, ADM_DSCRLEN);

        if(lpSelectedItem->lParam != NULL)
        {
            pADMFile = (ADMFile*)lpSelectedItem->lParam;
            getADMDescriptionTitle(pADMFile->szFileName, szDscrTitle);
            getADMDescription(pADMFile->szFileName, szDscr);
        }
        else
        {
            if(!IsWizard())
            {
                LoadString(g_hInst, IDS_POLICYBRANCHTITLE, szDscrTitle, ADM_TITLELEN);
                LoadString(g_hInst, IDS_POLICYBRANCHTEXT, szDscr, ADM_DSCRLEN);
            }
        }
        SetADMWindowText(hTreeView, szDscrTitle, szDscr);
    }
}

// Displays an ADM file description or category window depending
// on the type of the selected item
void WINAPI SelectADMItem(HWND hWnd, HWND hTreeView, LPTVITEM lpTVItem,
                          BOOL bSelect, BOOL fShowDisabled)
{
    HTREEITEM hParentItem;
    TCHAR szDscrTitle[ADM_TITLELEN];
    TCHAR szDscr[ADM_DSCRLEN];

    hParentItem = TreeView_GetParent(hTreeView, lpTVItem->hItem);

    if(bSelect == FALSE)
    {
        // if the previously selected item was a category item,
        // save the category information and destroy the window
        // associated with that category
        if(hParentItem != g_hPolicyRootItem)
        {
            if(lpTVItem->lParam != NULL)
                SaveADMItem(hTreeView, lpTVItem, ITEM_SAVE | ITEM_DESTROY);
        }
        else
            ShowADMWindow(hTreeView, FALSE);
    }
    else
    {
        if(hParentItem == NULL)
        {
            LoadString(g_hInst, IDS_POLICYBRANCHTITLE, szDscrTitle, ADM_TITLELEN);
            LoadString(g_hInst, IDS_POLICYBRANCHTEXT, szDscr, ADM_DSCRLEN);
            SetADMWindowText(hTreeView, szDscrTitle, szDscr);
            return;
        }
        // display the information for the newly selected item
        DisplayADMItem(hWnd, hTreeView, lpTVItem, fShowDisabled);
    }
}

void WINAPI ImportADMFileA(HWND hMainWnd, HWND hTreeView, LPCSTR pcszADMFilePath,
                           LPCSTR pcszWorkDir, int nRole, LPCSTR pcszInsFile)
{
    USES_CONVERSION;

    importADMFileHelper(hMainWnd, hTreeView, A2CT(pcszADMFilePath), A2CT(pcszWorkDir),
        nRole, A2CT(pcszInsFile));
}

void WINAPI ImportADMFileW(HWND hMainWnd, HWND hTreeView, LPCWSTR pcwszADMFilePath,
                           LPCWSTR pcwszWorkDir, int nRole, LPCWSTR pcwszInsFile)
{
    USES_CONVERSION;

    importADMFileHelper(hMainWnd, hTreeView, W2CT(pcwszADMFilePath), W2CT(pcwszWorkDir),
        nRole, W2CT(pcwszInsFile));
}


void WINAPI CheckForDupKeys(HWND hMainWnd, HWND hTreeView, HTREEITEM hItem,
                            BOOL bDispSuccessMsg)
{
    TV_ITEM tvitem;
    TV_ITEM tvitem1;
    HANDLE hFile;
    HRESULT hResult;
    TCHAR szMessage[MAX_PATH];
    BOOL bClearLog = TRUE;
    HTREEITEM hPolicyItem = GetFirstPolicyItem(hTreeView);
    TCHAR szRoot[MAX_PATH];
    TCHAR szTitle[MAX_PATH];

    tvitem.mask = TVIF_PARAM;
    tvitem.hItem = hItem;
    TreeView_GetItem(hTreeView, &tvitem);

    LoadString(g_hInst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));
    if(ISNULL(g_szLogFileName))
    {
        LPTSTR pLastSlash;
        DWORD dwSize = sizeof(szRoot);

        GetModuleFileName(GetModuleHandle(NULL), szRoot, MAX_PATH);
        if(ISNULL(szRoot))
            SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEAK6WIZ.EXE"), NULL, NULL, (LPVOID) szRoot, &dwSize);
        if(ISNONNULL(szRoot))
        {
            pLastSlash = StrRChr(szRoot, NULL, TEXT('\\'));
            if (pLastSlash)
                *(++pLastSlash) = 0;
            CharUpper(szRoot);
        }
        wnsprintf(g_szLogFileName, ARRAYSIZE(g_szLogFileName), TEXT("%sadmlog.txt"), szRoot);
    }

    do
    {
        tvitem1.mask = TVIF_PARAM;
        tvitem1.hItem = hPolicyItem;
        TreeView_GetItem(hTreeView, &tvitem1);

        hResult = CheckDuplicateKeys(((ADMFile*)tvitem.lParam)->dwAdm, ((ADMFile*)tvitem1.lParam)->dwAdm,
                                    g_szLogFileName, bClearLog);
        if(hResult != S_OK)
        {
            if(GetLastError() == STATUS_NO_MEMORY)
            {
                LoadString(g_hInst, IDS_MEMORY_ERROR, szMessage, ARRAYSIZE(szMessage));
            }
            else if(GetLastError() == ERROR_FILE_NOT_FOUND)
            {
                LoadString(g_hInst, IDS_FILE_ERROR, szMessage, ARRAYSIZE(szMessage));
            }
            MessageBox(hTreeView, szMessage, szTitle, MB_ICONINFORMATION|MB_OK);
            return;
        }
        bClearLog = FALSE;
    }while((hPolicyItem = TreeView_GetNextSibling(hTreeView, hPolicyItem)) != NULL); // get next item

    hFile = CreateFile( g_szLogFileName, GENERIC_READ, FILE_SHARE_READ,
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        LoadString(g_hInst, IDS_NO_DUPLICATEKEYS, szMessage, ARRAYSIZE(szMessage));
        MessageBox(hTreeView, szMessage, szTitle, MB_ICONINFORMATION|MB_OK);
        return;
    }

    if(GetFileSize( hFile, NULL ) == 0)
    {
        CloseHandle(hFile);
        if(bDispSuccessMsg)
        {
            LoadString(g_hInst, IDS_NO_DUPLICATEKEYS, szMessage, ARRAYSIZE(szMessage));
            MessageBox(hTreeView, szMessage, szTitle, MB_ICONINFORMATION|MB_OK);
        }
    }
    else
    {
        CloseHandle(hFile);

        DialogBox(g_hInst, MAKEINTRESOURCE(IDD_ERRORLOG), hMainWnd, logDialogProc);
    }
    SetFocus(hMainWnd);
}

void WINAPI ResetAdmFilesA(HWND hTreeView, LPCSTR pcszWorkDir, BOOL bReset)
{
    USES_CONVERSION;

    resetAdmFilesHelper(hTreeView, A2CT(pcszWorkDir), bReset);
}

void WINAPI ResetAdmFilesW(HWND hTreeView, LPCWSTR pcwszWorkDir, BOOL bReset)
{
    USES_CONVERSION;

    resetAdmFilesHelper(hTreeView, W2CT(pcwszWorkDir), bReset);
}

void WINAPI SaveAdmFilesA(HWND hTreeView, LPCSTR pcszWorkDir, LPCSTR pcszInsFile)
{
    USES_CONVERSION;

    saveAdmFilesHelper(hTreeView, A2CT(pcszWorkDir), A2CT(pcszInsFile));
}

void WINAPI SaveAdmFilesW(HWND hTreeView, LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile)
{
    USES_CONVERSION;

    saveAdmFilesHelper(hTreeView, W2CT(pcwszWorkDir), W2CT(pcwszInsFile));
}

BOOL WINAPI CanDeleteADM(HWND hTreeView, HTREEITEM hItem)
{
    TV_ITEM tvitem;
    int nDeleteLock = 0;

    tvitem.mask = TVIF_PARAM;
    tvitem.hItem = hItem;
    TreeView_GetItem(hTreeView, &tvitem);
    if(tvitem.lParam != NULL)
    {
        nDeleteLock = GetPrivateProfileInt(TEXT("IEAK"), TEXT("Lock"), 0,
                                           ((ADMFile*)tvitem.lParam)->szFileName);
    }
    return (BOOL) !nDeleteLock;
}

HWND WINAPI GetAdmWindowHandle(HWND hTreeView, HTREEITEM hItem)
{
    TV_ITEM tvitem;

    tvitem.mask = TVIF_PARAM;
    tvitem.hItem = hItem;
    if (TreeView_GetItem(hTreeView, &tvitem) == TRUE)
        return ((ADMCategory*)tvitem.lParam)->hWnd;
    else
        return NULL;
}

void WINAPI SaveADMItem(HWND hTreeView, LPTVITEM lpTVItem, DWORD dwFlags)
{
    if (lpTVItem != NULL && lpTVItem->lParam != NULL)
    {
        TVITEM tvitem;

        tvitem.mask = TVIF_PARAM;
        tvitem.hItem = TreeView_GetParent(hTreeView, lpTVItem->hItem);
        TreeView_GetItem(hTreeView, &tvitem);

        if (dwFlags)
        {
            DWORD  dwAdmFlags = 0;
            ADMFile* pADMFile = (ADMFile*)tvitem.lParam;
            ADMCategory* pADMCategory = (ADMCategory*)lpTVItem->lParam;

            if (pADMCategory != NULL)
            {
                if (HasFlag(dwFlags, ITEM_SAVE))
                    dwAdmFlags |= ADM_SAVE;
                if (HasFlag(dwFlags, ITEM_DESTROY))
                    dwAdmFlags |= ADM_DESTROY;
                AdmSaveData(pADMFile->dwAdm, pADMFile->pData, pADMCategory->pData, dwAdmFlags);

                if (HasFlag(dwFlags, ITEM_DESTROY))
                {
                    DestroyWindow(pADMCategory->hWnd);
                    pADMCategory->hWnd = NULL;
                    pADMCategory->pData = NULL;
                }
            }
        }
    }
}

BOOL WINAPI GetAdmFileListA(LPRESULTITEMA* pResultItemsArrayA, int* pnResultItems, int nRole)
{
    LPRESULTITEM pResultItemArray = NULL;
    BOOL fRet;

    fRet = getAdmFileListHelper(&pResultItemArray, pnResultItems, nRole);

    if (pResultItemArray != NULL)
    {
        int i;

        if ((i = *pnResultItems) != 0)
        {
            if ((*pResultItemsArrayA = (LPRESULTITEMA)CoTaskMemAlloc(i * sizeof(RESULTITEMA))) != NULL)
            {
                for (i--; i >= 0; i--)
                {
                    // must used StrLen manually here to figure out how many bytes to allocate!
                    
                    if (pResultItemArray[i].pszName != NULL)
                        (*pResultItemsArrayA)[i].pszName = 
                            (LPSTR)CoTaskMemAlloc((StrLen(pResultItemArray[i].pszName)+1)*2);
                    if (pResultItemArray[i].pszDesc != NULL)
                        (*pResultItemsArrayA)[i].pszDesc = 
                            (LPSTR)CoTaskMemAlloc((StrLen(pResultItemArray[i].pszDesc)+1)*2);
                    ResultItemT2A(&pResultItemArray[i], &(*pResultItemsArrayA)[i]);
                    if (pResultItemArray[i].pszName != NULL)
                        CoTaskMemFree(pResultItemArray[i].pszName);
                    if (pResultItemArray[i].pszDesc != NULL)
                        CoTaskMemFree(pResultItemArray[i].pszDesc);
                }
            }
        }

        CoTaskMemFree(pResultItemArray);
    }

    return fRet;
}

BOOL WINAPI GetAdmFileListW(LPRESULTITEMW* pResultItemsArrayW, int* pnResultItems, int nRole)
{
    LPRESULTITEM pResultItemArray = NULL;
    BOOL fRet;

    fRet = getAdmFileListHelper(&pResultItemArray, pnResultItems, nRole);

    if (pResultItemArray != NULL)
    {
        int i;

        if ((i = *pnResultItems) != 0)
        {
            if ((*pResultItemsArrayW = (LPRESULTITEMW)CoTaskMemAlloc(i * sizeof(RESULTITEMW))) != NULL)
            {
                for (i--; i >= 0; i--)
                {
                    // must used StrLen manually here to figure out how many bytes to allocate!
                    
                    if (pResultItemArray[i].pszName != NULL)
                        (*pResultItemsArrayW)[i].pszName = 
                            (LPWSTR)CoTaskMemAlloc((StrLen(pResultItemArray[i].pszName)+1) * sizeof(WCHAR));
                    if (pResultItemArray[i].pszDesc != NULL)
                        (*pResultItemsArrayW)[i].pszDesc = 
                            (LPWSTR)CoTaskMemAlloc((StrLen(pResultItemArray[i].pszDesc)+1) * sizeof(WCHAR));
                    ResultItemT2W(&pResultItemArray[i], &(*pResultItemsArrayW)[i]); 
                    if (pResultItemArray[i].pszName != NULL)
                        CoTaskMemFree(pResultItemArray[i].pszName);
                    if (pResultItemArray[i].pszDesc != NULL)
                        CoTaskMemFree(pResultItemArray[i].pszDesc);
                }
            }
        }

        CoTaskMemFree(pResultItemArray);
    }

    return fRet;
}

HTREEITEM WINAPI AddADMItemA(HWND hTreeView, LPCSTR pcszADMFilePath, LPCSTR pcszFileName,
                            LPCSTR pcszWorkDir, int nRole, BSTR bstrRSOPNamespace)
{
    USES_CONVERSION;

    return addADMItemHelper(hTreeView, A2CT(pcszADMFilePath), A2CT(pcszFileName), 
        A2CT(pcszWorkDir), nRole, bstrRSOPNamespace);
}

HTREEITEM WINAPI AddADMItemW(HWND hTreeView, LPCWSTR pcwszADMFilePath, LPCWSTR pcwszFileName,
                            LPCWSTR pcwszWorkDir, int nRole, BSTR bstrRSOPNamespace)
{
    USES_CONVERSION;

    return addADMItemHelper(hTreeView, W2CT(pcwszADMFilePath), W2CT(pcwszFileName), 
        W2CT(pcwszWorkDir), nRole, bstrRSOPNamespace);
}

// Converts the .adm filename to .inf filename and concatenates the
// appropriate path for the .inf file
static void getInfFileName(LPCTSTR pcszADMFileName, LPTSTR pszInfFileName, DWORD cchInfFile, LPCTSTR pcszWorkDir)
{
    TCHAR szBaseFileName[MAX_PATH];

    ZeroMemory(pszInfFileName, cchInfFile*sizeof(TCHAR));
    StrCpy(szBaseFileName, PathFindFileName(pcszADMFileName));
    PathRemoveExtension(szBaseFileName);
    if(ISNONNULL(pcszWorkDir))
        wnsprintf(pszInfFileName, cchInfFile, TEXT("%s\\%s.inf"), pcszWorkDir, szBaseFileName);
}

// Loads all the categories for a specified .adm file
static void loadCategories(HWND hTreeView, HTREEITEM hParentItem, DWORD dwAdm,
						   BOOL fRSoPMode)
{
    int nSize = 0;
    int nCategorySize = 0;
    TV_INSERTSTRUCT tvis;
    TCHAR szCategories[2048];
    TCHAR szCategory[1024];
    HKEY hKeyCurrentClass = HKEY_CURRENT_USER;

    // Get the category list. The category strings are concatenated into a
    // single string with '\0' as the seperator and the last string is
    // terminated with "\0\0"
    GetAdmCategories(dwAdm, szCategories, ARRAYSIZE(szCategories), &nSize);

    for(int nIndex = 0; nIndex < (nSize - 2); nIndex++)
    {
        memset(szCategory, 0, sizeof(szCategory));
        nCategorySize = 0;
        while(szCategories[nIndex] != TEXT('\0'))
        {
            szCategory[nCategorySize++] = szCategories[nIndex++];
        }

        if(StrCmpI(szCategory, TEXT("HKLM")) == 0)
        {
            hKeyCurrentClass = HKEY_LOCAL_MACHINE;
            continue;
        }
        else if(StrCmpI(szCategory, TEXT("HKCU")) == 0)
        {
            hKeyCurrentClass = HKEY_CURRENT_USER;
            continue;
        }

        ADMCategory* pCategory = (ADMCategory*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ADMCategory));
        if(pCategory == NULL) // not enough memory available
        {
            return;
        }
        memset(pCategory, 0, sizeof(ADMCategory));
        pCategory->pszName = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
            (lstrlen(szCategory) + 1)*sizeof(TCHAR));
        if(pCategory->pszName == NULL) // not enough memory available
        {
            HeapFree(GetProcessHeap(), 0, pCategory);
            return;
        }
        StrCpy(pCategory->pszName, szCategory);
        pCategory->hKeyClass = hKeyCurrentClass;
		pCategory->fRSoPMode = fRSoPMode;

        tvis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvis.item.pszText = pCategory->pszName;
        tvis.item.cchTextMax = lstrlen(pCategory->pszName);
        tvis.item.lParam = (LPARAM) pCategory;
        tvis.item.iImage = tvis.item.iSelectedImage = g_ADMCategory;

        tvis.hInsertAfter = (HTREEITEM) TVI_LAST;
        tvis.hParent = hParentItem;
        if(TreeView_InsertItem( hTreeView,  &tvis) == NULL)
        {   // insert failure
            HeapFree(GetProcessHeap(), 0, pCategory->pszName);
            HeapFree(GetProcessHeap(), 0, pCategory);
        }
    }
}

// Checks whether a particular .adm file is to be displayed in the tree view
// depending on the PLATFORM key in the IEAK section
static BOOL isADMFileVisibleHelper(LPCTSTR pcszFileName, int nRole, DWORD dwPlatformId)
{
    TCHAR szRoles[5];
    TCHAR szPlatform[10];

    ZeroMemory(szRoles,sizeof(szRoles));
    ZeroMemory(szPlatform, sizeof(szPlatform));

    if(IsWizard())
    {
        // if the Roles are not specified or are not of the proper format,
        // the adm file is assumed to be visible
        if(GetPrivateProfileString(TEXT("IEAK"), TEXT("Roles"), TEXT(""), szRoles, ARRAYSIZE(szRoles), pcszFileName) == 3)
        {
            if(!((szRoles[0] == TEXT('0') || szRoles[0] == TEXT('1')) &&
               (szRoles[1] == TEXT('0') || szRoles[1] == TEXT('1')) &&
               (szRoles[2] == TEXT('0') || szRoles[2] == TEXT('1')) &&
               ((szRoles[0] == TEXT('1') && nRole == ROLE_ICP)  ||  // ICP
               (szRoles[1] == TEXT('1') && nRole == ROLE_ISP)   ||  // ISP
               (szRoles[2] == TEXT('1') && nRole == ROLE_CORP))))   // Corp. Admin
            {
                return FALSE;
            }
        }
    }
    
    GetPrivateProfileString(TEXT("IEAK"), TEXT("Platform"), TEXT(""), szPlatform, ARRAYSIZE(szPlatform), pcszFileName);
    if(!((szPlatform[1] == TEXT('1') && dwPlatformId == PLATFORM_WIN32)   ||     // WIN32
       (szPlatform[3] == TEXT('1') && dwPlatformId == PLATFORM_W2K)))            // W2K
    {
        return FALSE;
    }

    return TRUE;
}

// Adds an item (.adm file) to the tree view
static HTREEITEM addADMItemHelper(HWND hTreeView, LPCTSTR pcszADMFilePath, LPCTSTR pcszFileName,
                                  LPCTSTR pcszWorkDir, int nRole, BSTR bstrRSOPNamespace)
{
    TV_INSERTSTRUCT tvis;
    HTREEITEM hItem = NULL;
    DWORD dwAdm = 0;
    TCHAR szADMFileName[MAX_PATH];
    TCHAR szOutputFile[MAX_PATH];
    TCHAR szTitle[ADM_TITLELEN];
    PathCombine(szADMFileName, pcszADMFilePath, pcszFileName);

    // check for the visibility of the adm file
    if(!IsADMFileVisible(szADMFileName, nRole, g_dwPlatformId))
        return NULL;

    ADMFile* pADMFile = (ADMFile*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ADMFile));
    if(pADMFile == NULL) // not enough memory available
    {
        return NULL;
    }
    ZeroMemory(pADMFile, sizeof(ADMFile));
    StrCpy(pADMFile->szFileName, szADMFileName);
    ZeroMemory(szTitle, sizeof(szTitle));
    GetPrivateProfileString(TEXT("Strings"), TEXT("IEAK_Title"), pcszFileName, szTitle,
        ARRAYSIZE(szTitle), pADMFile->szFileName);
    pADMFile->pszName = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
        (StrLen(szTitle) + 1)*sizeof(TCHAR));
    if(pADMFile->pszName == NULL) // not enough memory available
    {
        HeapFree(GetProcessHeap(), 0, pADMFile);
        return NULL;
    }
    StrCpy(pADMFile->pszName, szTitle);

    tvis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvis.item.pszText = pADMFile->pszName;
    tvis.item.cchTextMax = StrLen(pADMFile->pszName);
    tvis.item.lParam = (LPARAM) pADMFile;
    if (IsWizard())
    {
        tvis.item.mask |= TVIF_STATE;
        tvis.item.stateMask = tvis.item.state = TVIS_BOLD;
    }
    tvis.item.iImage = tvis.item.iSelectedImage = g_ADMClose;

    tvis.hInsertAfter = (HTREEITEM) TVI_LAST;
    tvis.hParent = PolicyRoot();

    getInfFileName(pADMFile->szFileName, szOutputFile, ARRAYSIZE(szOutputFile), pcszWorkDir);
    if(AdmInit(pADMFile->szFileName, szOutputFile, bstrRSOPNamespace, &dwAdm, &pADMFile->pData) == S_OK)
    {
        pADMFile->dwAdm = dwAdm;
        if((hItem = TreeView_InsertItem( hTreeView,  &tvis)) != NULL)
        {   // insert success
            loadCategories(hTreeView, hItem, dwAdm, (NULL == bstrRSOPNamespace) ? FALSE : TRUE);
        }
    }

    if(hItem == NULL)
    {
        HeapFree(GetProcessHeap(), 0, pADMFile->pszName);
        HeapFree(GetProcessHeap(), 0, pADMFile);
        hItem = NULL;
    }
    return hItem;
}

static void addAdmItems(HWND hTreeView, LPCTSTR pcszFileType, LPCTSTR pcszADMFilePath,
                        LPCTSTR pcszWorkDir, int nRole)
{
    WIN32_FIND_DATA FindFileData;
    TCHAR szFileName[MAX_PATH];

    PathCombine(szFileName, pcszADMFilePath, pcszFileType);

    HANDLE hFind = FindFirstFile(szFileName, &FindFileData);
    if(hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
			// addAdmItems is called from loadADMFiles which is never called in RSoP mode,
			// so just pass in FALSE always.
            addADMItemHelper(hTreeView, pcszADMFilePath, FindFileData.cFileName,
							pcszWorkDir, nRole, NULL);
        }while(FindNextFile(hFind, &FindFileData));
        FindClose(hFind);
    }
}

// Loads all the .adm files from a specific path
static BOOL loadADMFilesHelper(HWND hTreeView, HTREEITEM hPolicyRootItem,
                               LPCTSTR pcszADMFilePath, LPCTSTR pcszWorkDir,
                               DWORD dwPlatformId, int nRole,
                               int nIconADMClose, int nIconADMCategory)
{
    g_hPolicyRootItem = hPolicyRootItem;
    g_dwPlatformId = dwPlatformId;
    g_ADMClose = nIconADMClose;
    g_ADMCategory = nIconADMCategory;
    ZeroMemory(g_szLogFileName, sizeof(g_szLogFileName));

    addAdmItems(hTreeView, TEXT("*.adm"), pcszADMFilePath, pcszWorkDir, nRole);
    // add also files with .opa extension, Office requirement - 06/08/98
    addAdmItems(hTreeView, TEXT("*.opa"), pcszADMFilePath, pcszWorkDir, nRole);

    return TRUE;
}

// Returns the item handle for the requested filename if any
static HTREEITEM getADMItemHandle(HWND hTreeView, LPTSTR pszADMFileName)
{
    HTREEITEM hItem = NULL;
    TV_ITEM tvitem;

    hItem = GetFirstPolicyItem(hTreeView);
    while(hItem != NULL) // if items in the tree view
    {
        tvitem.mask = TVIF_PARAM;
        tvitem.hItem = hItem;
        TreeView_GetItem(hTreeView, &tvitem);
        if(tvitem.lParam != NULL &&
            StrCmp(((ADMFile*) tvitem.lParam)->szFileName, pszADMFileName) == 0)
        {
            return hItem;
        }
        hItem = TreeView_GetNextSibling(hTreeView, hItem); // get next item
    }
    return NULL;
}

// Deletes an item from the tree view and releases any memory
// allocated with that item
static void deleteADMItemHelper(HWND hTreeView, HTREEITEM hParentItem, LPCTSTR pcszWorkDir,
                                LPCTSTR pcszInsFile, BOOL bDeleteFile, BOOL bSave)
{
    ADMFile* pADMFile = NULL;
    ADMCategory* pADMCategory = NULL;
    HTREEITEM hItem = NULL;
    HTREEITEM hNextItem = NULL;
    TCHAR szRegistryData[MAX_PATH + 15];
    TCHAR szBaseFileName[_MAX_FNAME];
    TV_ITEM tvitem;
    TV_ITEM tvparentitem;
    TCHAR szOutputFile[MAX_PATH];

    tvparentitem.mask = TVIF_PARAM;
    tvparentitem.hItem = hParentItem;
    TreeView_GetItem(hTreeView, &tvparentitem);
    if(tvparentitem.lParam != NULL)
    {
        pADMFile = (ADMFile*) tvparentitem.lParam;
        hItem = TreeView_GetChild(hTreeView, hParentItem); // get child item
        while(hItem != NULL)
        {
            hNextItem = TreeView_GetNextSibling(hTreeView, hItem); // get next child item
            tvitem.mask = TVIF_PARAM;
            tvitem.hItem = hItem;
            TreeView_GetItem(hTreeView, &tvitem);
            if(tvitem.lParam != NULL)
            {
                pADMCategory = (ADMCategory*) tvitem.lParam;
                HeapFree(GetProcessHeap(), 0, pADMCategory->pszName);
                HeapFree(GetProcessHeap(), 0, pADMCategory);

                TreeView_DeleteItem(hTreeView, hItem);
            }
            hItem = hNextItem;
        }

        getInfFileName(pADMFile->szFileName, szOutputFile, ARRAYSIZE(szOutputFile),
            pcszWorkDir);
        StrCpy(szBaseFileName, PathFindFileName(szOutputFile));
        PathRemoveExtension(szBaseFileName);
        if(bDeleteFile == TRUE)
        {
            DeleteFile(pADMFile->szFileName);
            DeleteFile(szOutputFile);
            
        }
        else
        {
            if (bSave)
            {
                AdmFinished(pADMFile->dwAdm, szOutputFile, pADMFile->pData);
                if (PathFileExists(szOutputFile))
                {
                    wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                        TEXT("*,%s,DefaultInstall"), PathFindFileName(szOutputFile));
                    InsWriteString(IS_EXTREGINF, szBaseFileName, szRegistryData, pcszInsFile);

                    if (!InsIsSectionEmpty(TEXT("AddRegSection.HKLM"), szOutputFile))
                    {
                        wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                                  TEXT("%s,IEAKInstall.HKLM"), PathFindFileName(szOutputFile));
                        InsWriteString(IS_EXTREGINF_HKLM, szBaseFileName, szRegistryData, pcszInsFile);

                    }
                    if (!InsIsSectionEmpty(TEXT("AddRegSection.HKCU"), szOutputFile))
                    {
                        wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                                  TEXT("%s,IEAKInstall.HKCU"), PathFindFileName(szOutputFile));
                        InsWriteString(IS_EXTREGINF_HKCU, szBaseFileName, szRegistryData, pcszInsFile);

                    }
                }
            }
        }

        AdmClose(pADMFile->dwAdm, &pADMFile->pData, bDeleteFile);
        HeapFree(GetProcessHeap(), 0, pADMFile->pszName);
        HeapFree(GetProcessHeap(), 0, pADMFile);

        TreeView_DeleteItem(hTreeView, hParentItem);
        if(TreeView_GetCount(hTreeView) == 0) // if no items in the tree view
            SetADMWindowText(hTreeView, TEXT(""), TEXT(""));
    }
    WritePrivateProfileString(NULL, NULL, NULL, pcszInsFile);
}

// Deletes all the items from the tree view
static void deleteADMItemsHelper(HWND hTreeView, LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile,
                                 BOOL bSave)
{
    HTREEITEM hItem = GetFirstPolicyItem(hTreeView); // get policy fisrt item
    HTREEITEM hNextItem = NULL;
    HTREEITEM hSelectedItem = TreeView_GetSelection(hTreeView); // get selected item

    if(hSelectedItem != NULL)
    {
        TreeView_Select(hTreeView, NULL, TVGN_CARET);
    }

    while(hItem != NULL) // if items in the tree view
    {
        hNextItem = TreeView_GetNextSibling(hTreeView, hItem); // get next item
        deleteADMItemHelper(hTreeView, hItem, pcszWorkDir, pcszInsFile, FALSE, bSave);
        hItem = hNextItem;
    }
}

static void getADMDescriptionTitle(LPCTSTR pcszFileName, LPTSTR pszDscrTitle)
{
    GetPrivateProfileString(TEXT("Strings"), TEXT("IEAK_DescriptionTitle"), TEXT(""),
        pszDscrTitle, ADM_DSCRLINELEN, pcszFileName);
}

// Reads the description from the specified adm file
static void getADMDescription(LPCTSTR pcszFileName, LPTSTR pszDscr)
{
    DWORD dwSize = 0;
    TCHAR szDscrText[ADM_DSCRLEN];
    TCHAR szDscrKey[20];
    int nIndex = 0;

    int nDscrLines = GetPrivateProfileInt(TEXT("IEAK"), TEXT("NumOfDescLines"), 0, pcszFileName);

    *pszDscr = TEXT('\0');
    for(nIndex = 1; nIndex <= nDscrLines; nIndex++)
    {
        wnsprintf(szDscrKey, ARRAYSIZE(szDscrKey), TEXT("IEAK_Description%d"), nIndex);
        dwSize = GetPrivateProfileString(TEXT("Strings"), szDscrKey, NULL,
            szDscrText, ADM_DSCRLEN, pcszFileName);
        if (dwSize)
        {
            if(nIndex == 1)
                StrCpy(pszDscr, szDscrText);
            else
            {
                StrCat(pszDscr, TEXT("\r\n\r\n"));
                StrCat(pszDscr, szDscrText);
            }
        }
    }
}

// Imports ADM file from the directory specified by the user to the
// adm directory and calls addADMItemHelper to show the item on the tree list
static void importADMFileHelper(HWND hMainWnd, HWND hTreeView, LPCTSTR pcszADMFilePath,
                                LPCTSTR pcszWorkDir, int nRole, LPCTSTR pcszInsFile)
{
    HTREEITEM hItem = NULL;
    TCHAR szFileName[MAX_PATH]=TEXT("");
    LPTSTR pExt = NULL;
    TCHAR szADMFileName[MAX_PATH];
    TCHAR szMessage[512];
    TCHAR szTitle[MAX_PATH];

    LoadString(g_hDLLInst, IDS_ENGINE_TITLE, szTitle, ARRAYSIZE(szTitle));
    if( BrowseForFile( hTreeView, szFileName, ARRAYSIZE(szFileName), GFN_ADM ))
    {
        pExt = PathFindExtension(szFileName);
        if(pExt != NULL)
            pExt++;
        // Only .adm file extensions to be added to the list
        if(StrCmpI(pExt, TEXT("adm")) == 0 || StrCmpI(pExt, TEXT("opa")) == 0)
        {
            PathCombine(szADMFileName, pcszADMFilePath, PathFindFileName(szFileName));

            // if already there exists a file with the same name, prompt
            // the user for overwrite confirmation.
            if(!CopyFile(szFileName, szADMFileName, TRUE))
            {
                LoadString(g_hInst, IDS_ADMOVRWWARN, szMessage, ARRAYSIZE(szMessage));
                if(MessageBox(hTreeView, szMessage, szTitle, MB_ICONQUESTION|MB_YESNO) == IDYES)
                {
                    CopyFile(szFileName, szADMFileName, FALSE);
                    hItem = getADMItemHandle(hTreeView, szADMFileName);
                    if(hItem != NULL)
                    {
                        TreeView_Select(hTreeView, NULL, TVGN_CARET);
                        deleteADMItemHelper(hTreeView, hItem, pcszWorkDir, pcszInsFile,
                            FALSE, TRUE);
                    }

					// importADMFile is never called in RSoP mode,
					// so just pass in FALSE always.
                    hItem = addADMItemHelper(hTreeView, pcszADMFilePath,
                        PathFindFileName(szADMFileName), pcszWorkDir, nRole, NULL);
                    if(hItem != NULL)
                    {
                        TreeView_Select(hTreeView, hItem, TVGN_CARET);
                        CheckForDupKeys(hMainWnd, hTreeView, hItem, FALSE);
                    }
                }
            }
            else
            {
				// importADMFile is never called in RSoP mode,
				// so just pass in FALSE always.
                if((hItem = addADMItemHelper(hTreeView, pcszADMFilePath,
                    PathFindFileName(szADMFileName), pcszWorkDir, nRole, NULL)) != NULL)
                {
                    TreeView_Select(hTreeView, hItem, TVGN_CARET);
                    CheckForDupKeys(hMainWnd, hTreeView, hItem, FALSE);
                }
            }
        }
        else
        {
            LoadString(g_hInst, IDS_ADMINVALIDEXTN, szMessage, ARRAYSIZE(szMessage));
            MessageBox(hTreeView, szMessage, szTitle, MB_ICONINFORMATION|MB_OK);
        }
    }
}

static INT_PTR CALLBACK logDialogProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM)
{
    HANDLE hFile = NULL;
    HGLOBAL hFileMem = NULL;
    int nFileSize = 0;
    DWORD dwRead = 0;

    switch( msg )
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDC_LOGTEXT);

        hFile = CreateFile( g_szLogFileName, GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( hFile == INVALID_HANDLE_VALUE )
        {
            EndDialog(hDlg, 1);
            break;
        }

        nFileSize = GetFileSize( hFile, NULL );
        hFileMem = LocalAlloc( LPTR, nFileSize + 2);
        if( hFileMem != NULL )
        {
            if (ReadFile( hFile, (LPSTR) hFileMem, (DWORD) nFileSize, &dwRead, NULL)==TRUE)
                SetWindowTextA(GetDlgItem(hDlg, IDC_LOGTEXT), (LPCSTR) hFileMem);
            PostMessage(GetDlgItem(hDlg, IDC_LOGTEXT), EM_SETSEL, 0, 0L);
            LocalFree(hFileMem);
            hFileMem = NULL;
        }
        CloseHandle( hFile );
        break;

    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED && LOWORD( wParam ) == IDOK)
            EndDialog(hDlg, 1);
        break;

    default:
        return 0;
    }
    return 1;
}

//*********
// All the below functions is used only by the Profile Manager

static BOOL isPolicyTree(HWND hTreeView, HTREEITEM hItem)
{
    BOOL bRet = FALSE;
    HTREEITEM hParentItem = NULL;

    while(1)
    {
        hParentItem = TreeView_GetParent(hTreeView, hItem);
        if(hParentItem == NULL)
        {
            bRet = (hItem == g_hPolicyRootItem) ? TRUE : FALSE;
            break;
        }
        hItem = hParentItem;
    };

    return bRet;
}

static void resetAdmFilesHelper(HWND hTreeView, LPCTSTR pcszWorkDir, BOOL bReset)
{
    HTREEITEM hItem = TreeView_GetChild(hTreeView, g_hPolicyRootItem); // get first policy item
    HTREEITEM hNextItem = NULL;
    TV_ITEM tvitem;
    TCHAR szInfFile[MAX_PATH];
    HTREEITEM hSelectedItem = TreeView_GetSelection(hTreeView); // get selected item
    ADMFile* pADMFile = NULL;
    ADMCategory* pADMCategory = NULL;

    if(g_hPolicyRootItem == NULL) // no elements under policy item
        return;

    while(hItem != NULL) // if items in the tree view
    {
        hNextItem = TreeView_GetNextSibling(hTreeView, hItem); // get next item

        tvitem.mask = TVIF_PARAM;
        tvitem.hItem = hItem;
        TreeView_GetItem(hTreeView, &tvitem);

        pADMFile = (ADMFile*)tvitem.lParam;

        if (hSelectedItem != NULL &&
            TreeView_GetParent(hTreeView, hSelectedItem) == hItem)
        {
            TV_ITEM tvItem;

            tvItem.mask = TVIF_PARAM;
            tvItem.hItem = hSelectedItem;
            TreeView_GetItem(hTreeView, &tvItem);

            pADMCategory = (ADMCategory*)tvitem.lParam;
        }
        else
            pADMCategory = NULL;

        ZeroMemory(szInfFile, sizeof(szInfFile));
        if(bReset)
        {
            getInfFileName(pADMFile->szFileName, szInfFile,
                ARRAYSIZE(szInfFile), pcszWorkDir);
            if (pADMCategory != NULL)
                AdmReset(pADMFile->dwAdm, szInfFile, pADMFile->pData, pADMCategory->pData);
            else
                AdmReset(pADMFile->dwAdm, szInfFile, pADMFile->pData, NULL);
        }
        else
        {
            if (pADMCategory != NULL)
                AdmReset(pADMFile->dwAdm, NULL, pADMFile->pData, pADMCategory->pData);
            else
                AdmReset(pADMFile->dwAdm, NULL, pADMFile->pData, NULL);
        }

        hItem = hNextItem;
    }

    if(hSelectedItem != NULL && isPolicyTree(hTreeView, hSelectedItem) && hSelectedItem != g_hPolicyRootItem &&
        TreeView_GetParent(hTreeView, hSelectedItem) != g_hPolicyRootItem)
    {
        tvitem.mask = TVIF_PARAM;
        tvitem.hItem = hSelectedItem;
        TreeView_GetItem(hTreeView, &tvitem);
        
        pADMCategory = (ADMCategory*)tvitem.lParam;

        EnableWindow(pADMCategory->hWnd, TRUE);
    }
}

static void saveAdmFilesHelper(HWND hTreeView, LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile)
{
    HTREEITEM hItem = TreeView_GetChild(hTreeView, g_hPolicyRootItem); // get first policy item
    HTREEITEM hNextItem = NULL;
    TV_ITEM tvitem;
    TCHAR szInfFile[MAX_PATH];
    TCHAR szRegistryData[MAX_PATH + 15];
    TCHAR szBaseFileName[_MAX_FNAME];
    LPTSTR pExt = NULL;
    ADMFile* pADMFile;

    if(!IsAdmDirty() || g_hPolicyRootItem == NULL) // no elements under policy item
        return;

    while(hItem != NULL) // if items in the tree view
    {
        hNextItem = TreeView_GetNextSibling(hTreeView, hItem); // get next item

        tvitem.mask = TVIF_PARAM;
        tvitem.hItem = hItem;
        TreeView_GetItem(hTreeView, &tvitem);

        pADMFile = (ADMFile*)tvitem.lParam;
        
        ZeroMemory(szInfFile, sizeof(szInfFile));
        getInfFileName(pADMFile->szFileName, szInfFile,
            ARRAYSIZE(szInfFile), pcszWorkDir);
        StrCpy(szBaseFileName, PathFindFileName(szInfFile));
        PathRemoveExtension(szBaseFileName);

        AdmFinished(pADMFile->dwAdm, szInfFile, pADMFile->pData);
        if (PathFileExists(szInfFile))
        {
            pExt = PathFindExtension(szInfFile);
            wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                    TEXT("*,%s,DefaultInstall"), PathFindFileName(szInfFile));
            InsWriteString(IS_EXTREGINF, szBaseFileName, szRegistryData, pcszInsFile);

            if (!InsIsSectionEmpty(TEXT("AddRegSection.HKLM"), szInfFile))
            {
               wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                        TEXT("%s,IEAKInstall.HKLM"), PathFindFileName(szInfFile));
               InsWriteString(IS_EXTREGINF_HKLM, szBaseFileName, szRegistryData, pcszInsFile);
            }
            if (!InsIsSectionEmpty(TEXT("AddRegSection.HKCU"), szInfFile))
            {
               wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                        TEXT("%s,IEAKInstall.HKCU"), PathFindFileName(szInfFile));
               InsWriteString(IS_EXTREGINF_HKCU, szBaseFileName, szRegistryData, pcszInsFile);
            }
        }
        hItem = hNextItem;
    }
    WritePrivateProfileString(NULL, NULL, NULL, pcszInsFile);
}

//*********

// CDscrWnd
// This window is used to display the description title and text for the top level item selected in the treeview.

CDscrWnd::CDscrWnd()
{
    hWndMain      = NULL;
    hWndDscrTitle = NULL;
    hWndDscrText  = NULL;
    hFontDscrTitle = NULL;
}

CDscrWnd::~CDscrWnd()
{
    if (hFontDscrTitle != NULL)
    {
        DeleteObject(hFontDscrTitle);
        hFontDscrTitle = NULL;
    }

    if (hWndMain != NULL) //destroying the main window destroys its child windows
        DestroyWindow(hWndMain);
}

static WNDPROC g_lpfnDscrTextWndProc = NULL;

LRESULT CALLBACK DscrTextWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_GETDLGCODE)
        return (DLGC_WANTARROWS | DLGC_WANTCHARS);
    return (CallWindowProc(g_lpfnDscrTextWndProc, hWnd, uMsg, wParam, lParam));
}

void CDscrWnd::Create(HWND hWndParent, HWND hWndInsertAfter, int nXPos, int nYPos, int nWidth,
                      int nHeight)
{
    if (hWndMain != NULL) // already created
        return;

    // create the main window
    hWndMain = CreateWindowEx(WS_EX_CONTROLPARENT, TEXT("STATIC"), TEXT(""), WS_VISIBLE | WS_CHILD | WS_GROUP,
                              nXPos, nYPos, nWidth, nHeight, hWndParent, NULL, g_hInst, NULL);
    if (hWndMain == NULL)
        return;

    if (hWndInsertAfter != NULL)
        SetWindowPos(hWndMain, hWndInsertAfter, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

    // create the description title window
    hWndDscrTitle = CreateWindowEx(0, TEXT("STATIC"), TEXT(""), WS_VISIBLE | WS_CHILD | SS_LEFT | SS_NOPREFIX,
                                   0, 0, nWidth, 0, hWndMain, NULL, g_hInst, NULL );
    if (hWndDscrTitle == NULL)
        return;

    // change the font of the title to make it bold
    HDC        hDC = GetDC(hWndDscrTitle);

    if (hFontDscrTitle == NULL)
        hFontDscrTitle = getBoldFont(hWndDscrTitle);

    if (hFontDscrTitle)
        SelectObject(hDC, hFontDscrTitle);

    ReleaseDC(hWndDscrTitle, hDC);

    // create the description text window
    hWndDscrText = CreateWindowEx(0, TEXT("EDIT"), TEXT(""), WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_VSCROLL |
                                  ES_LEFT | ES_MULTILINE | ES_READONLY,
                                  0, 25, nWidth, 0, hWndMain, NULL, g_hInst, NULL );
    if (hWndDscrText == NULL)
        return;

    // change the font of the text to default gui font
    HFONT hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
    SendMessage(hWndDscrText, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));

    g_lpfnDscrTextWndProc = (WNDPROC) GetWindowLongPtr(hWndDscrText, GWLP_WNDPROC);
    SetWindowLongPtr(hWndDscrText, GWLP_WNDPROC, (LONG_PTR) DscrTextWndProc);
}

void CDscrWnd::ShowWindow(BOOL fShow)
{
    if (hWndMain != NULL)
    {
        if (fShow)
            ::ShowWindow(hWndMain, SW_SHOWNORMAL);
        else
            ::ShowWindow(hWndMain, SW_HIDE);
    }
}

void CDscrWnd::SetText(LPCTSTR pcszTitle, LPCTSTR pcszText, BOOL fUpdateWindowState)
{
    int nYPos = 0;
    HDC hDC = NULL;
    int nHeight = 0;
    int nWidth = 0;
    RECT rect;

    if (hWndMain == NULL)
        return;

    if (fUpdateWindowState)
        ::ShowWindow(hWndMain, SW_SHOWNORMAL);
    if (hWndDscrTitle != NULL)
    {
        if(pcszTitle == NULL || *pcszTitle == TEXT('\0'))
        {
            if (fUpdateWindowState)
                ::ShowWindow(hWndDscrTitle, SW_HIDE);
        }
        else
        {
            GetClientRect(GetParent(hWndDscrTitle), &rect);
            nWidth = rect.right;
            hDC = GetDC(hWndDscrTitle);
            nHeight = DrawText(hDC, pcszTitle, -1, &rect, DT_LEFT | DT_WORDBREAK | DT_CALCRECT);
            ReleaseDC(hWndDscrTitle, hDC);
            SetWindowPos(hWndDscrTitle, NULL, 0, 0, nWidth, nHeight, SWP_NOMOVE | SWP_NOZORDER);

            SetWindowText(hWndDscrTitle, pcszTitle);
            nYPos = nHeight + 5;
            if (fUpdateWindowState)
                ::ShowWindow(hWndDscrTitle, SW_SHOWNORMAL);
        }
    }

    if (hWndDscrText != NULL)
    {
        if (pcszText == NULL || *pcszText == TEXT('\0'))
        {
            if (fUpdateWindowState)
                ::ShowWindow(hWndDscrText, SW_HIDE);
        }
        else
        {
            GetClientRect(GetParent(hWndDscrText), &rect);
            SetWindowPos(hWndDscrText, NULL, 0, nYPos, rect.right, rect.bottom - nYPos, SWP_NOZORDER);

            SetWindowText(hWndDscrText, pcszText);
            if (fUpdateWindowState)
                ::ShowWindow(hWndDscrText, SW_SHOWNORMAL);
        }
    }
}

void CDscrWnd::GetRect(RECT* lpRect)
{
    ZeroMemory(lpRect, sizeof(RECT));
    if (hWndMain != NULL)
        GetWindowRect(hWndMain, lpRect);
}

void CDscrWnd::MoveWindow(int nXPos, int nYPos, int nWidth, int nHeight)
{
    TCHAR szDscrTitle[ADM_TITLELEN];
    TCHAR szDscr[ADM_DSCRLEN];

    if (hWndMain == NULL)
        return;

    ::MoveWindow(hWndMain, nXPos, nYPos, nWidth, nHeight, TRUE);

    ZeroMemory(szDscrTitle, ADM_TITLELEN);
    if (hWndDscrTitle != NULL)
        GetWindowText(hWndDscrTitle, szDscrTitle, ADM_TITLELEN);

    ZeroMemory(szDscr, ADM_DSCRLEN);
    if (hWndDscrText != NULL)
        GetWindowText(hWndDscrText, szDscr, ADM_DSCRLEN);

    SetText(szDscrTitle, szDscr, FALSE);
}

static HFONT getBoldFont(HWND hWnd)
{
    static HFONT hFont = NULL;
    LOGFONT    lf;
    TEXTMETRIC tm;
    HDC        hDC;
    int        nFontSize = 0;

    ZeroMemory(&lf, sizeof(lf));

    if (hFont == NULL)
    {
        if (GetFontInfo != NULL)
            GetFontInfo(lf.lfFaceName, &nFontSize);

        if (*(lf.lfFaceName) == TEXT('\0'))
        {
            StrCpy(lf.lfFaceName, TEXT("MS Sans Serif"));
            nFontSize = 10;
        }

        hDC = GetDC(hWnd);

        lf.lfHeight = -((nFontSize * GetDeviceCaps(hDC, LOGPIXELSY)) / 72);
        lf.lfWeight = FW_BOLD;

        GetTextMetrics(hDC, &tm);
        lf.lfCharSet = tm.tmCharSet;

        ReleaseDC(hWnd, hDC);

        hFont = CreateFontIndirect(&lf);
    }

    return hFont;
}

static BOOL getAdmFileListHelper(LPRESULTITEM* pResultItems, int* pnResultItems, int nRole)
{
    WIN32_FIND_DATA FindFileData;
    TCHAR szFileName[MAX_PATH];
    TCHAR szADMFilePath[MAX_PATH];
    int nAdmFiles = 0;
    int nAllocatedBuffer = 10;

    *pResultItems = (LPRESULTITEM) CoTaskMemAlloc(sizeof(RESULTITEM) * nAllocatedBuffer);
    if (*pResultItems == NULL)
    {
        ErrorMessageBox(NULL, IDS_MEMORY_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }

    // BUGBUG: for now assume the admfilepath
    GetWindowsDirectory(szADMFilePath, countof(szADMFilePath));
    PathAppend(szADMFilePath, TEXT("INF"));
    PathCombine(szFileName, szADMFilePath, TEXT("*.adm"));

    HANDLE hFind = FindFirstFile(szFileName, &FindFileData);
    if(hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            TCHAR szBuffer[MAX_PATH];
            LPRESULTITEM lpResultItem;

            PathCombine(szFileName, szADMFilePath, FindFileData.cFileName);

            if (InsIsSectionEmpty(TEXT("IEAK"), szFileName) ||
                !isADMFileVisibleHelper(szFileName, nRole, g_dwPlatformId))
                continue;

            if (nAdmFiles >= nAllocatedBuffer)
            {
                LPVOID lpTemp;

                nAllocatedBuffer += 5;
                lpTemp = CoTaskMemRealloc(*pResultItems, sizeof(RESULTITEM) * nAllocatedBuffer);
                if (lpTemp == NULL)
                {
                    ErrorMessageBox(NULL, IDS_MEMORY_ERROR, MB_ICONINFORMATION | MB_OK);
                    CoTaskMemFree(*pResultItems);
                    *pResultItems = NULL;
                    return FALSE;
                }

                *pResultItems = (LPRESULTITEM) lpTemp;
            }

            ZeroMemory(&((*pResultItems)[nAdmFiles]), sizeof((*pResultItems)[nAdmFiles]));

            GetPrivateProfileString(IS_STRINGS, TEXT("IEAK_Title"), szFileName, 
                                    szBuffer, countof(szBuffer), szFileName);

            lpResultItem = &((*pResultItems)[nAdmFiles]);

            if ((lpResultItem->pszName = (LPTSTR)CoTaskMemAlloc(StrCbFromSz(szBuffer))) != NULL)
                StrCpy(lpResultItem->pszName, szBuffer);

            if ((lpResultItem->pszDesc = (LPTSTR)CoTaskMemAlloc(StrCbFromSz(szFileName))) != NULL)
                StrCpy(lpResultItem->pszDesc, szFileName);

            nAdmFiles++;

        }while(FindNextFile(hFind, &FindFileData));
        FindClose(hFind);
    }

    *pnResultItems = nAdmFiles;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\channels.h ===
#ifndef __CHANNELS_H_
#define __CHANNELS_H_

#include <wininet.h>

typedef struct tag_channelA
{
    CHAR szTitle[MAX_PATH];
    CHAR szWebUrl[INTERNET_MAX_URL_LENGTH];
    CHAR szPreUrlPath[MAX_PATH];
    CHAR szIcon[MAX_PATH];
    CHAR szLogo[MAX_PATH];
    BOOL fCategory;
    BOOL fOffline;
    HWND hDlg;
} CHANNELA, *PCHANNELA;

typedef struct tag_channelW
{
    WCHAR szTitle[MAX_PATH];
    WCHAR szWebUrl[INTERNET_MAX_URL_LENGTH];
    WCHAR szPreUrlPath[MAX_PATH];
    WCHAR szIcon[MAX_PATH];
    WCHAR szLogo[MAX_PATH];
    BOOL fCategory;
    BOOL fOffline;
    HWND hDlg;
} CHANNELW, *PCHANNELW;

// TCHAR mappings

#ifdef UNICODE

#define CHANNEL                 CHANNELW
#define PCHANNEL                PCHANNELW

#else

#define CHANNEL                 CHANNELA
#define PCHANNEL                PCHANNELA

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\btoolbar.h ===
#ifndef _BTOOLBAR_H_
#define _BTOOLBAR_H_

#include <wininet.h>

typedef struct tag_btoolbarA
{
    CHAR szCaption[MAX_BTOOLBAR_TEXT_LENGTH+1];
    CHAR szAction[INTERNET_MAX_URL_LENGTH];
    CHAR szIcon[MAX_PATH];
    CHAR szHotIcon[MAX_PATH];
//  TCHAR szToolTipText[MAX_PATH];   // disable for IE5 since not implemented in browser
    BOOL fShow;
    BOOL fDeleted;
} BTOOLBARA, *PBTOOLBARA;

typedef struct tag_btoolbarW
{
    WCHAR szCaption[MAX_BTOOLBAR_TEXT_LENGTH+1];
    WCHAR szAction[INTERNET_MAX_URL_LENGTH];
    WCHAR szIcon[MAX_PATH];
    WCHAR szHotIcon[MAX_PATH];
//  TCHAR szToolTipText[MAX_PATH];   // disable for IE5 since not implemented in browser
    BOOL fShow;
    BOOL fDeleted;
} BTOOLBARW, *PBTOOLBARW;

// TCHAR mappings

#ifdef UNICODE

#define BTOOLBAR                BTOOLBARW
#define PBTOOLBAR               PBTOOLBARW

#else

#define BTOOLBAR                BTOOLBARA
#define PBTOOLBAR               PBTOOLBARA

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\btoolbar.cpp ===
#include "precomp.h"
#include "btoolbar.h"

static DWORD bToolbar_InitHelper(HWND hwndList, LPCTSTR pcszCustIns, LPCTSTR pcszAltDir, LPCTSTR pcszWorkDir);
static void bToolbar_SaveHelper(HWND hwndList, LPCTSTR pcszCustIns, LPCTSTR pcszBToolbarDir, DWORD dwMode);
static PBTOOLBAR findBToolbar(HWND hwndList);
static INT_PTR CALLBACK editBToolbarProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

DWORD WINAPI BToolbar_InitA(HWND hwndList, LPCSTR pcszCustIns, LPCSTR pcszAltDir, LPCSTR pcszWorkDir)
{
    USES_CONVERSION;

    return bToolbar_InitHelper(hwndList, A2CT(pcszCustIns), A2CT(pcszAltDir), A2CT(pcszWorkDir));
}

DWORD WINAPI BToolbar_InitW(HWND hwndList, LPCWSTR pcwszCustIns, LPCWSTR pcwszAltDir, LPCWSTR pcwszWorkDir)
{
    USES_CONVERSION;

    return bToolbar_InitHelper(hwndList, W2CT(pcwszCustIns), W2CT(pcwszAltDir), W2CT(pcwszWorkDir));
}

void WINAPI BToolbar_Remove(HWND hwndList)
{
    PBTOOLBAR pBToolbar;
    int i;

    i = ListBox_GetCurSel(hwndList);
    pBToolbar = (PBTOOLBAR)ListBox_GetItemData(hwndList, (WPARAM)i);
    pBToolbar->fDeleted = TRUE;
    ListBox_DeleteString(hwndList, (WPARAM)i);
    if (ListBox_SetCurSel(hwndList, (WPARAM)i) == LB_ERR)          // last item in the list
    {
        if (ListBox_SetCurSel(hwndList, (WPARAM)(i-1)) == LB_ERR)  // no more items left
        {
            int rgids[] = { IDC_EDITBTOOLBAR, IDC_REMOVEBTOOLBAR };

            EnsureDialogFocus(GetParent(hwndList), rgids, countof(rgids), IDC_ADDBTOOLBAR);
            DisableDlgItems  (GetParent(hwndList), rgids, countof(rgids));
        }
    }

    EnableWindow(GetDlgItem(GetParent(hwndList), IDC_ADDBTOOLBAR), TRUE);
}

void WINAPI BToolbar_Edit(HWND hwndList, BOOL fAdd)
{
    PBTOOLBAR pBToolbar;
    int i = -1;

    if (fAdd)
        pBToolbar = findBToolbar(hwndList);
    else
    {
        i = ListBox_GetCurSel(hwndList);
        pBToolbar = (PBTOOLBAR)ListBox_GetItemData(hwndList, (WPARAM)i);
    }

    if (pBToolbar == NULL)
    {
        if (fAdd) {
            // REVIEW: (andrewgu) from the code perspective it looks like this can only happen
            // when maximum number of toolbar buttons reached. if this is the case it's high time
            // to delete some.
            EnsureDialogFocus(GetParent(hwndList), IDC_ADDBTOOLBAR, IDC_REMOVEBTOOLBAR);
            DisableDlgItem   (GetParent(hwndList), IDC_ADDBTOOLBAR);
        }
        return;
    }

    if (DialogBoxParam( g_hInst, MAKEINTRESOURCE(IDD_BTOOLBARPOPUP),
        GetParent(hwndList), editBToolbarProc, (LPARAM)pBToolbar ) == IDOK)
    {
        if (!fAdd)
            ListBox_DeleteString(hwndList, (WPARAM)i);

        i = ListBox_AddString(hwndList, (LPARAM) pBToolbar->szCaption);
        ListBox_SetItemData(hwndList, (WPARAM)i, (LPARAM)pBToolbar);
        ListBox_SetCurSel(hwndList, (WPARAM)i);
        ListBox_SetTopIndex(hwndList, (WPARAM)i);
        EnableWindow(GetDlgItem(GetParent(hwndList), IDC_REMOVEBTOOLBAR), TRUE);
        EnableWindow(GetDlgItem(GetParent(hwndList), IDC_EDITBTOOLBAR), TRUE);
    }
}

void  WINAPI BToolbar_SaveA(HWND hwndList, LPCSTR pcszCustIns, LPCSTR pcszBToolbarDir, DWORD dwMode /*= IEM_NEUTRAL*/)
{
    USES_CONVERSION;

    bToolbar_SaveHelper(hwndList, A2CT(pcszCustIns), A2CT(pcszBToolbarDir), dwMode);
}

void  WINAPI BToolbar_SaveW(HWND hwndList, LPCWSTR pcwszCustIns, LPCWSTR pcwszBToolbarDir, DWORD dwMode /*= IEM_NEUTRAL*/)
{
    USES_CONVERSION;

    bToolbar_SaveHelper(hwndList, W2CT(pcwszCustIns), W2CT(pcwszBToolbarDir), dwMode);
}

static DWORD bToolbar_InitHelper(HWND hwndList, LPCTSTR pcszCustIns, LPCTSTR pcszAltDir, LPCTSTR pcszWorkDir)
{
    PBTOOLBAR pBToolbar;
    PBTOOLBAR paBToolbar;
    PBTOOLBAR paOldBToolbar;
    TCHAR szBToolbarTextParam[32];
    TCHAR szBToolbarIcoParam[32];
    TCHAR szBToolbarActionParam[32];
    TCHAR szBToolbarHotIcoParam[32];
//  TCHAR szBToolbarToolTextParam[32];
    TCHAR szBToolbarShowParam[32];
    int i, j;

    ASSERT(((pcszAltDir == NULL) && (pcszWorkDir == NULL)) || 
        ((pcszAltDir != NULL) && (pcszWorkDir != NULL)));

    ListBox_ResetContent(hwndList);

    if ((paBToolbar = (PBTOOLBAR)CoTaskMemAlloc(sizeof(BTOOLBAR) * MAX_BTOOLBARS)) == NULL)
        return 0;

    ZeroMemory(paBToolbar, sizeof(BTOOLBAR) * MAX_BTOOLBARS);

    for (i=0, pBToolbar = paBToolbar; i < MAX_BTOOLBARS; i++, pBToolbar++)
    {
        wnsprintf(szBToolbarTextParam, ARRAYSIZE(szBToolbarTextParam), TEXT("%s%i"), IK_BTCAPTION, i);
        wnsprintf(szBToolbarIcoParam, ARRAYSIZE(szBToolbarIcoParam), TEXT("%s%i"), IK_BTICON, i);
        wnsprintf(szBToolbarActionParam, ARRAYSIZE(szBToolbarActionParam), TEXT("%s%i"), IK_BTACTION, i);
        wnsprintf(szBToolbarHotIcoParam, ARRAYSIZE(szBToolbarHotIcoParam), TEXT("%s%i"), IK_BTHOTICO, i);
//      wnsprintf(szBToolbarToolTextParam, ARRAYSIZE(szBToolbarToolTextParam), TEXT("%s%i"), IK_BTTOOLTIP, i);
        wnsprintf(szBToolbarShowParam, ARRAYSIZE(szBToolbarShowParam), TEXT("%s%i"), IK_BTSHOW, i);

        if (GetPrivateProfileString(IS_BTOOLBARS, szBToolbarTextParam, TEXT(""),
            pBToolbar->szCaption, ARRAYSIZE(pBToolbar->szCaption), pcszCustIns) == 0)
            break;

        GetPrivateProfileString(IS_BTOOLBARS, szBToolbarIcoParam, TEXT(""), pBToolbar->szIcon, ARRAYSIZE(pBToolbar->szIcon), pcszCustIns);
        GetPrivateProfileString(IS_BTOOLBARS, szBToolbarActionParam, TEXT(""), pBToolbar->szAction, ARRAYSIZE(pBToolbar->szAction), pcszCustIns);
        GetPrivateProfileString(IS_BTOOLBARS, szBToolbarHotIcoParam, TEXT(""), pBToolbar->szHotIcon, ARRAYSIZE(pBToolbar->szHotIcon), pcszCustIns);
//      GetPrivateProfileString(IS_BTOOLBARS, szBToolbarToolTextParam, TEXT(""), pBToolbar->szToolTipText, ARRAYSIZE(pBToolbar->szToolTipText), pcszCustIns);
        pBToolbar->fShow = (BOOL)GetPrivateProfileInt(IS_BTOOLBARS, szBToolbarShowParam, 1, pcszCustIns);

        if (pcszAltDir != NULL)
        {
            MoveFileToWorkDir(PathFindFileName(pBToolbar->szIcon), pcszAltDir, pcszWorkDir);
            MoveFileToWorkDir(PathFindFileName(pBToolbar->szHotIcon), pcszAltDir, pcszWorkDir);
        }

        j = ListBox_AddString(hwndList, (LPARAM) pBToolbar->szCaption );
        ListBox_SetItemData(hwndList, (WPARAM)j, (LPARAM)pBToolbar);
    }

    paOldBToolbar = (PBTOOLBAR)SetWindowLongPtr(hwndList, GWLP_USERDATA, (LONG_PTR)paBToolbar);

    // delete previous allocation(mainly for profile manager)
    if (paOldBToolbar != NULL)
        CoTaskMemFree(paOldBToolbar);

    return i;
}

static void bToolbar_SaveHelper(HWND hwndList, LPCTSTR pcszCustIns, LPCTSTR pcszBToolbarDir, DWORD dwMode)
{
    TCHAR szBToolbarTextParam[32];
    TCHAR szBToolbarIcoParam[32];
    TCHAR szBToolbarActionParam[32];
    TCHAR szBToolbarHotIcoParam[32];
//  TCHAR szBToolbarToolTextParam[32];
    TCHAR szBToolbarShowParam[32];
    TCHAR szTempPath[MAX_PATH];
    PBTOOLBAR pBToolbar;
    PBTOOLBAR paBToolbar;
    GUID guid;
    int i, j;

    // create a temp path to copy all files to temporarily

    GetTempPath(countof(szTempPath), szTempPath);
    if (CoCreateGuid(&guid) == NOERROR)
    {
        TCHAR szGUID[128];

        CoStringFromGUID(guid, szGUID, countof(szGUID));
        PathAppend(szTempPath, szGUID);
    }
    else
        PathAppend(szTempPath, TEXT("IEAKTOOL"));

    PathCreatePath(szTempPath);

    WritePrivateProfileString(IS_BTOOLBARS, NULL, NULL, pcszCustIns);
    WritePrivateProfileString(NULL, NULL, NULL, pcszCustIns);

    paBToolbar = (PBTOOLBAR)GetWindowLongPtr(hwndList, GWLP_USERDATA);
    for (i = 0, j = 0, pBToolbar = paBToolbar; (i < MAX_BTOOLBARS) && (pBToolbar != NULL); i++, pBToolbar++ )
    {
        if (pBToolbar->fDeleted || ISNULL(pBToolbar->szCaption))
            continue;

        wnsprintf(szBToolbarTextParam, ARRAYSIZE(szBToolbarTextParam), TEXT("%s%i"), IK_BTCAPTION, j);
        wnsprintf(szBToolbarIcoParam, ARRAYSIZE(szBToolbarIcoParam), TEXT("%s%i"), IK_BTICON, j);
        wnsprintf(szBToolbarActionParam, ARRAYSIZE(szBToolbarActionParam), TEXT("%s%i"), IK_BTACTION, j);
        wnsprintf(szBToolbarHotIcoParam, ARRAYSIZE(szBToolbarHotIcoParam), TEXT("%s%i"), IK_BTHOTICO, j);
//      wnsprintf(szBToolbarToolTextParam, ARRAYSIZE(szBToolbarToolTextParam), TEXT("%s%i"), IK_BTTOOLTIP, j);
        wnsprintf(szBToolbarShowParam, ARRAYSIZE(szBToolbarShowParam), TEXT("%s%i"), IK_BTSHOW, j);

        WritePrivateProfileString(IS_BTOOLBARS, szBToolbarTextParam, pBToolbar->szCaption, pcszCustIns);
        WritePrivateProfileString(IS_BTOOLBARS, szBToolbarActionParam, pBToolbar->szAction, pcszCustIns);
        WritePrivateProfileString(IS_BTOOLBARS, szBToolbarIcoParam, pBToolbar->szIcon, pcszCustIns);
        WritePrivateProfileString(IS_BTOOLBARS, szBToolbarHotIcoParam, pBToolbar->szHotIcon, pcszCustIns);
//      WritePrivateProfileString(IS_BTOOLBARS, szBToolbarToolTextParam, pBToolbar->szToolTipText, pcszCustIns);
        WritePrivateProfileString(IS_BTOOLBARS, szBToolbarShowParam, pBToolbar->fShow ? TEXT("1") : TEXT("0"), pcszCustIns);

        if (PathFileExists(pBToolbar->szIcon))
            CopyFileToDir(pBToolbar->szIcon, szTempPath);
        else
        {
            TCHAR szFile[MAX_PATH];
            
            PathCombine(szFile, pcszBToolbarDir, PathFindFileName(pBToolbar->szIcon));
            CopyFileToDir(szFile, szTempPath);
        }

        if (PathFileExists(pBToolbar->szHotIcon))
            CopyFileToDir(pBToolbar->szHotIcon, szTempPath);
        else
        {
            TCHAR szFile[MAX_PATH];
            
            PathCombine(szFile, pcszBToolbarDir, PathFindFileName(pBToolbar->szHotIcon));
            CopyFileToDir(szFile, szTempPath);
        }
        j++;
    }

    // do not free for profile manager since we might still be on the page due to file save
    if (!HasFlag(dwMode, IEM_PROFMGR) && (paBToolbar != NULL))
    {
        CoTaskMemFree(paBToolbar);
        SetWindowLong(hwndList, GWLP_USERDATA, NULL);
    }

    PathRemovePath(pcszBToolbarDir);
    PathCreatePath(pcszBToolbarDir);
    CopyFileToDir(szTempPath, pcszBToolbarDir);
    PathRemovePath(szTempPath);
}

static PBTOOLBAR findBToolbar(HWND hwndList)
{
    PBTOOLBAR pBToolbar;
    int i;

    for (pBToolbar = (PBTOOLBAR)GetWindowLongPtr(hwndList, GWLP_USERDATA), i = 0; 
         (i < MAX_BTOOLBARS) && (pBToolbar != NULL); i++, pBToolbar++)
    {
        if (pBToolbar->fDeleted || ISNULL(pBToolbar->szCaption))
        {
            ZeroMemory(pBToolbar, sizeof (BTOOLBAR));
            pBToolbar->fShow = TRUE;
            return pBToolbar;
        }
    }

    return NULL;
}

static INT_PTR CALLBACK editBToolbarProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PBTOOLBAR pBToolbar;
    TCHAR szTemp[INTERNET_MAX_URL_LENGTH];

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pBToolbar = (PBTOOLBAR)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pBToolbar);
        EnableDBCSChars(hDlg, IDE_BTCAPTION);
        EnableDBCSChars(hDlg, IDE_BTACTION);
//      EnableDBCSChars(hDlg, IDE_BTTOOLTEXT);
        EnableDBCSChars(hDlg, IDE_BTICON);
        EnableDBCSChars(hDlg, IDE_BTHOTICON);

        Edit_LimitText(GetDlgItem(hDlg, IDE_BTCAPTION), MAX_BTOOLBAR_TEXT_LENGTH);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BTACTION), _MAX_FNAME);
//      Edit_LimitText(GetDlgItem(hDlg, IDE_BTTOOLTEXT), ARRAYSIZE(pBToolbar->szToolTipText)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BTICON), _MAX_FNAME);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BTHOTICON), _MAX_FNAME);

        SetDlgItemText(hDlg, IDE_BTCAPTION, pBToolbar->szCaption);
        SetDlgItemText(hDlg, IDE_BTACTION, pBToolbar->szAction);
//      SetDlgItemText(hDlg, IDE_BTTOOLTEXT, pBToolbar->szToolTipText);
        SetDlgItemText(hDlg, IDE_BTICON, pBToolbar->szIcon);
        SetDlgItemText(hDlg, IDE_BTHOTICON, pBToolbar->szHotIcon);
        CheckDlgButton(hDlg, IDC_BUTTONSTATE,
            pBToolbar->fShow ? BST_CHECKED : BST_UNCHECKED);
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDC_BROWSEBTICO:
            case IDC_BROWSEBTHOTICO:
                if (BrowseForFile(hDlg, szTemp, ARRAYSIZE(szTemp), GFN_ICO ))
                    SetDlgItemText(hDlg,
                        (LOWORD(wParam) == IDC_BROWSEBTICO) ? IDE_BTICON : IDE_BTHOTICON, szTemp);
                break;
            case IDC_BROWSEBTACTION:
                if (BrowseForFile(hDlg, szTemp, ARRAYSIZE(szTemp), GFN_EXE ))
                    SetDlgItemText(hDlg, IDE_BTACTION, szTemp);
                break;
            case IDCANCEL:
                EndDialog( hDlg, IDCANCEL );
                break;
            case IDOK:
                if (!CheckField(hDlg, IDE_BTCAPTION, FC_NONNULL) ||
                    !CheckField(hDlg, IDE_BTACTION, FC_NONNULL) ||
                    !CheckField(hDlg, IDE_BTHOTICON, FC_NONNULL | FC_FILE | FC_EXISTS) ||
                    !CheckField(hDlg, IDE_BTICON, FC_NONNULL | FC_FILE | FC_EXISTS))
                    break;

                pBToolbar = (PBTOOLBAR)GetWindowLongPtr(hDlg, DWLP_USER);
                GetDlgItemText(hDlg, IDE_BTCAPTION, pBToolbar->szCaption, ARRAYSIZE(pBToolbar->szCaption));
                GetDlgItemText(hDlg, IDE_BTACTION, pBToolbar->szAction, ARRAYSIZE(pBToolbar->szAction));
//              GetDlgItemText(hDlg, IDE_BTTOOLTEXT, pBToolbar->szToolTipText, ARRAYSIZE(pBToolbar->szToolTipText));
                GetDlgItemText(hDlg, IDE_BTICON, pBToolbar->szIcon, ARRAYSIZE(pBToolbar->szIcon));
                GetDlgItemText(hDlg, IDE_BTHOTICON, pBToolbar->szHotIcon, ARRAYSIZE(pBToolbar->szHotIcon));
                pBToolbar->fShow = (IsDlgButtonChecked(hDlg, IDC_BUTTONSTATE) == BST_CHECKED);

                EndDialog( hDlg, IDOK );
                break;
            }
            break;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\convert.cpp ===
#include "precomp.h"

// functions used internally by ieakeng to convert between ansi and unicode versions of
// various structs
// Note: these functions assume ptrs to buffers already have the buffers allocated.

LPNMTVGETINFOTIPW TVInfoTipA2W(LPNMTVGETINFOTIPA pTvInfoTipA, LPNMTVGETINFOTIPW pTvInfoTipW)
{
    pTvInfoTipW->cchTextMax = pTvInfoTipA->cchTextMax;
    pTvInfoTipW->hdr = pTvInfoTipA->hdr;
    pTvInfoTipW->hItem = pTvInfoTipA->hItem;
    pTvInfoTipW->lParam = pTvInfoTipA->lParam;
    A2Wbux(pTvInfoTipA->pszText, pTvInfoTipW->pszText);

    return pTvInfoTipW;
}

LPNMTVGETINFOTIPA TVInfoTipW2A(LPNMTVGETINFOTIPW pTvInfoTipW, LPNMTVGETINFOTIPA pTvInfoTipA)
{
    pTvInfoTipA->cchTextMax = pTvInfoTipW->cchTextMax;
    pTvInfoTipA->hdr = pTvInfoTipW->hdr;
    pTvInfoTipA->hItem = pTvInfoTipW->hItem;
    pTvInfoTipA->lParam = pTvInfoTipW->lParam;
    W2Abux(pTvInfoTipW->pszText, pTvInfoTipA->pszText);

    return pTvInfoTipA;
}

LPNMTVGETINFOTIP TVInfoTipSameToSame(LPNMTVGETINFOTIP pTvInfoTipIn,
                                     LPNMTVGETINFOTIP pTvInfoTipOut)
{
    pTvInfoTipOut->cchTextMax = pTvInfoTipIn->cchTextMax;
    pTvInfoTipOut->hdr = pTvInfoTipIn->hdr;
    pTvInfoTipOut->hItem = pTvInfoTipIn->hItem;
    pTvInfoTipOut->lParam = pTvInfoTipIn->lParam;
    StrCpy(pTvInfoTipOut->pszText, pTvInfoTipIn->pszText);

    return pTvInfoTipOut;
}

LPRESULTITEMW ResultItemA2W(LPRESULTITEMA pResultItemA, LPRESULTITEMW pResultItemW)
{
    pResultItemW->dwNameSpaceItem = pResultItemA->dwNameSpaceItem;
    pResultItemW->iDescID = pResultItemA->iDescID;
    pResultItemW->iDlgID = pResultItemA->iDlgID;
    pResultItemW->iImage = pResultItemA->iImage;
    pResultItemW->iNameID = pResultItemA->iNameID;
    A2Wbux(pResultItemA->pszName, pResultItemW->pszName);
    A2Wbux(pResultItemA->pszDesc, pResultItemW->pszDesc);
    pResultItemW->pfnDlgProc = pResultItemA->pfnDlgProc;

    return pResultItemW;
}

LPRESULTITEMA ResultItemW2A(LPRESULTITEMW pResultItemW, LPRESULTITEMA pResultItemA)
{
    pResultItemA->dwNameSpaceItem = pResultItemW->dwNameSpaceItem;
    pResultItemA->iDescID = pResultItemW->iDescID;
    pResultItemA->iDlgID = pResultItemW->iDlgID;
    pResultItemA->iImage = pResultItemW->iImage;
    pResultItemA->iNameID = pResultItemW->iNameID;
    W2Abux(pResultItemW->pszName, pResultItemA->pszName);
    W2Abux(pResultItemW->pszDesc, pResultItemA->pszDesc);
    pResultItemA->pfnDlgProc = pResultItemW->pfnDlgProc;

    return pResultItemA;
}

LPRESULTITEM ResultItemSameToSame(LPRESULTITEM pResultItemIn, LPRESULTITEM pResultItemOut)
{
    pResultItemOut->dwNameSpaceItem = pResultItemIn->dwNameSpaceItem;
    pResultItemOut->iDescID = pResultItemIn->iDescID;
    pResultItemOut->iDlgID = pResultItemIn->iDlgID;
    pResultItemOut->iImage = pResultItemIn->iImage;
    pResultItemOut->iNameID = pResultItemIn->iNameID;
    StrCpy(pResultItemOut->pszName, pResultItemIn->pszName);
    StrCpy(pResultItemOut->pszDesc, pResultItemIn->pszDesc);
    pResultItemOut->pfnDlgProc = pResultItemIn->pfnDlgProc;

    return pResultItemOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\connset.cpp ===
#include "precomp.h"
#include <rashelp.h>

#pragma warning(disable: 4201)                  // nonstandard extension used : nameless struct/union
#include <winineti.h>

// Implementation helper structures/routines declarations
BOOL importConnectSet(PCTSTR pszIns, PCTSTR pszTargetPath, PCTSTR pszCleanupPath, BOOL fImport,
    DWORD dwMode, PCTSTR pszPbkFile = NULL, HKEY hkRoot = NULL);

typedef struct tagRASSETPARAMS {
    PCTSTR pszExtractPath;
    PCTSTR pszIns;
    HANDLE hfileDat,
           hfileInf;
    BOOL   fInfFileNeeded,
           fIntranet;

    // support for legacy format in ie50
    struct {
        HANDLE hfileRas,
               hfileSet;
        UINT   nRasFileIndex;
    } lcy50;

} RASSETPARAMS, *PRASSETPARAMS;

BOOL rasMainEnumProc(PCWSTR pszNameW, LPARAM lParam);

BOOL exportRasSettings           (PCWSTR pszNameA, const PRASSETPARAMS pcrsp);
BOOL exportRasCredentialsSettings(PCWSTR pszNameA, const PRASSETPARAMS pcrsp);
BOOL exportWininetSettings       (PCWSTR pszNameA, const PRASSETPARAMS pcrsp);
BOOL exportOtherSettings         (PCWSTR pszNameA, const PRASSETPARAMS pcrsp);

void lcy50_Initialize           (PRASSETPARAMS prsp);
void lcy50_Uninitialize         (PRASSETPARAMS prsp);
BOOL lcy50_ExportRasSettings    (PCSTR pszNameA, const PRASSETPARAMS pcrsp);
BOOL lcy50_ExportWininetSettings(PCSTR pszNameA, const PRASSETPARAMS pcrsp);
void lcy50_CopySzToBlobA        (PBYTE *ppBlob, PCSTR pszStrA);

BOOL deleteScriptFiles(PCTSTR pszSettingsFile, PCTSTR pszExtractPath, PCTSTR pszIns);
void parseProxyToIns(PCTSTR pszProxy, PCTSTR pszIns);
void copySzToBlob(PBYTE *ppBlob, PCWSTR pszStrW);


BOOL WINAPI ImportConnectSetA(LPCSTR pcszIns, LPCSTR pcszTargetPath, LPCSTR pcszCleanupPath,
    BOOL fImport, DWORD dwMode, LPCSTR pcszPbkFile /*= NULL*/, HKEY hkRoot /*= NULL*/)
{
    USES_CONVERSION;

    return importConnectSet(A2CT(pcszIns), A2CT(pcszTargetPath), A2CT(pcszCleanupPath),
                            fImport, dwMode, A2CT(pcszPbkFile), hkRoot);
}

BOOL WINAPI ImportConnectSetW(LPCWSTR pcwszIns, LPCWSTR pcwszTargetPath, LPCWSTR pcwszCleanupPath,
    BOOL fImport, DWORD dwMode, LPCWSTR pcwszPbkFile /*= NULL*/, HKEY hkRoot /*= NULL*/)
{
    USES_CONVERSION;

    return importConnectSet(W2CT(pcwszIns), W2CT(pcwszTargetPath), W2CT(pcwszCleanupPath), 
                            fImport, dwMode, W2CT(pcwszPbkFile), hkRoot);
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

BOOL importConnectSet(PCTSTR pszIns, PCTSTR pszTargetPath, PCTSTR pszCleanupPath, BOOL fImport,
    DWORD dwMode, PCTSTR pszPbkFile /*= NULL*/, HKEY hkRoot /*= NULL*/)
{
    UNREFERENCED_PARAMETER(pszPbkFile);
    UNREFERENCED_PARAMETER(hkRoot);

    USES_CONVERSION;

    RASSETPARAMS rsp;
    TCHAR szTargetFile[MAX_PATH],
          szExtRegInfLine[MAX_PATH];
    DWORD dwAux,
          dwResult;
    BOOL  fResult,
          fAux;

    //----- Clear out previous settings -----
    PathCombine(szTargetFile, pszCleanupPath, CONNECT_RAS);
    deleteScriptFiles(szTargetFile, pszCleanupPath, pszIns);

    DeleteFileInDir(CS_DAT, pszCleanupPath);

    // delete legacy stuff if there
    DeleteFileInDir(CONNECT_RAS, pszCleanupPath);
    DeleteFileInDir(CONNECT_SET, pszCleanupPath);
    DeleteFileInDir(CONNECT_INF, pszCleanupPath);

    InsDeleteSection(IS_CONNECTSET, pszIns);
    InsDeleteKey    (IS_EXTREGINF,  IK_CONNECTSET, pszIns);

    if (!fImport)
        return TRUE;                            // bail if that's all we need

    //----- Initialization -----
    fResult = FALSE;

    ZeroMemory(&rsp, sizeof(rsp));
    rsp.pszExtractPath = pszTargetPath;
    rsp.pszIns         = pszIns;
    rsp.fIntranet      = HasFlag(dwMode, IEM_ADMIN);

    PathCombine(szTargetFile, pszTargetPath, CS_DAT);
    rsp.hfileDat = CreateNewFile(szTargetFile);
    if (INVALID_HANDLE_VALUE == rsp.hfileDat) {
        rsp.hfileDat = NULL;
        goto Exit;
    }

    if (RasIsInstalled()) {
        PathCombine(szTargetFile, pszTargetPath, CONNECT_INF);
        rsp.hfileInf = CreateNewFile(szTargetFile);
        if (INVALID_HANDLE_VALUE == rsp.hfileInf) {
            rsp.hfileInf = NULL;
            goto Exit;
        }
    }

    //----- Write initial information into output files -----
    dwAux = CS_VERSION_5X;
    WriteFile(rsp.hfileDat, &dwAux, sizeof(DWORD), &dwResult, NULL);

    if (rsp.hfileInf != NULL)
        WriteStringToFile(rsp.hfileInf, INF_PROLOG_CS, StrLen(INF_PROLOG_CS));

    lcy50_Initialize(&rsp);

    //----- Enumerate connections -----
    fResult = RasEnumEntriesCallback(NULL, rasMainEnumProc, (LPARAM)&rsp);
    if (!fResult)
        goto Exit;

    //----- Save global registry settings into the inf file -----
    if (rsp.hfileInf != NULL) {
        HKEY hk;

        if (ERROR_SUCCESS == SHOpenKeyHKCU(RK_INETSETTINGS, KEY_READ, &hk)) {
            if (S_OK == SHValueExists(hk, RV_ENABLESECURITYCHECK)) {
                ExportRegValue2Inf(hk, RV_ENABLESECURITYCHECK, TEXT("HKCU"), RK_INETSETTINGS, rsp.hfileInf);
                rsp.fInfFileNeeded = TRUE;
            }

            SHCloseKey(hk);
        }

        if (ERROR_SUCCESS == SHOpenKeyHKCU(RK_REMOTEACCESS, KEY_READ, &hk)) {
            if (S_OK == SHValueExists(hk, RV_INTERNETPROFILE)) {
                ExportRegValue2Inf(hk, RV_INTERNETPROFILE, TEXT("HKCU"), RK_REMOTEACCESS, rsp.hfileInf);
                rsp.fInfFileNeeded = TRUE;
            }

            SHCloseKey(hk);
        }

        if (rsp.fInfFileNeeded) {
            szExtRegInfLine[0] = TEXT('\0');
            wnsprintf(szExtRegInfLine, countof(szExtRegInfLine), TEXT("%s,") IS_DEFAULTINSTALL, CONNECT_INF);
            InsWriteString(IS_EXTREGINF, IK_CONNECTSET, szExtRegInfLine, pszIns);

            szExtRegInfLine[0] = TEXT('\0');
            wnsprintf(szExtRegInfLine, countof(szExtRegInfLine), TEXT("%s,") IS_IEAKINSTALL_HKCU, CONNECT_INF);
            InsWriteString(IS_EXTREGINF_HKCU, IK_CONNECTSET, szExtRegInfLine, pszIns);
        }
    }

    //----- Save global settings into the ins file -----
    InsWriteBool(IS_CONNECTSET, IK_OPTION, TRUE, pszIns);

    // NOTE: (andrewgu) have to do this instead of going through inf because it's impossible to
    // write to HKCC in the inf. and we have to write to HKCC, otherwise clients with intergated
    // shell are broken.
    dwAux    = sizeof(fAux);
    dwResult = SHGetValue(HKEY_CURRENT_USER, RK_INETSETTINGS, RV_ENABLEAUTODIAL, NULL, (LPBYTE)&fAux, &dwAux);
    if (dwResult == ERROR_SUCCESS)
        InsWriteBool(IS_CONNECTSET, IK_ENABLEAUTODIAL, fAux, pszIns);

    dwAux    = sizeof(fAux);
    dwResult = SHGetValue(HKEY_CURRENT_USER, RK_INETSETTINGS, RV_NONETAUTODIAL, NULL, (LPBYTE)&fAux, &dwAux);
    if (dwResult == ERROR_SUCCESS)
        InsWriteBool(IS_CONNECTSET, IK_NONETAUTODIAL, fAux, pszIns);

    fResult = TRUE;

Exit:
    lcy50_Uninitialize(&rsp);

    if (NULL != rsp.hfileInf) {
        CloseFile(rsp.hfileInf);

        if (!rsp.fInfFileNeeded)
            DeleteFileInDir(CONNECT_INF, pszTargetPath);
    }

    if (NULL != rsp.hfileDat)
        CloseFile(rsp.hfileDat);

    return fResult;
}


BOOL rasMainEnumProc(PCWSTR pszNameW, LPARAM lParam)
{
    USES_CONVERSION;

    PRASSETPARAMS pcrsp;
    BYTE   rgbName[2*sizeof(DWORD) + StrCbFromCch(RAS_MaxEntryName+1)];
    PCSTR  pszNameA;
    PBYTE  pCur;
    DWORD  cbName,
           dwAux;

    pcrsp = (const PRASSETPARAMS)lParam;
    ASSERT(NULL != pcrsp && NULL != pcrsp->hfileDat);

    //----- Connection name -----
    ZeroMemory(rgbName, sizeof(rgbName));
    pCur    = rgbName;
    cbName  = 2*sizeof(DWORD);
    cbName += (DWORD)((pszNameW != NULL) ? StrCbFromSzW(pszNameW) : sizeof(DWORD));

    *((PDWORD)pCur) = CS_STRUCT_HEADER;
    pCur += sizeof(DWORD);

    *((PDWORD)pCur) = cbName;
    pCur += sizeof(DWORD);

    copySzToBlob(&pCur, pszNameW);

    WriteFile(pcrsp->hfileDat, rgbName, cbName, &dwAux, NULL);

    //----- All other structures -----
    pszNameA = W2CA(pszNameW);

    if (NULL != pszNameW) {
        ASSERT(RasIsInstalled());

        exportRasSettings           (pszNameW, pcrsp);
        exportRasCredentialsSettings(pszNameW, pcrsp);
        exportWininetSettings       (pszNameW, pcrsp);
        exportOtherSettings         (pszNameW, pcrsp);

        lcy50_ExportRasSettings     (pszNameA, pcrsp);
        lcy50_ExportWininetSettings (pszNameA, pcrsp);
    }
    else {
        exportWininetSettings       (pszNameW, pcrsp);
        lcy50_ExportWininetSettings (pszNameA, pcrsp);
    }

    return TRUE;
}


BOOL exportRasSettings(PCWSTR pszNameW, const PRASSETPARAMS pcrsp)
{
    USES_CONVERSION;

    LPRASENTRYW preW;
    PBYTE pBlob, pCur;
    DWORD cbBlob, cbWritten,
          dwResult;

    ASSERT(RasIsInstalled());
    ASSERT(pszNameW != NULL);
    ASSERT(pcrsp != NULL && pcrsp->hfileDat != NULL);

    pBlob = NULL;

    //----- RAS structure -----
    dwResult = RasGetEntryPropertiesExW(pszNameW, (LPRASENTRYW *)&pBlob, &cbBlob);
    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    cbBlob += 2*sizeof(DWORD);
    pBlob   = (PBYTE)CoTaskMemRealloc(pBlob, cbBlob);
    if (pBlob == NULL)
        goto Exit;
    MoveMemory(pBlob + 2*sizeof(DWORD), pBlob, cbBlob - 2*sizeof(DWORD));

    //----- Header -----
    pCur = pBlob;

    *((PDWORD)pCur) = CS_STRUCT_RAS;
    pCur += sizeof(DWORD);

    *((PDWORD)pCur) = cbBlob;
    pCur += sizeof(DWORD);

    //----- Script file -----
    preW = (LPRASENTRYW)pCur;

    if (preW->szScript[0] != L'\0') {
        PCWSTR pszScriptW;

        pszScriptW = preW->szScript;
        if (preW->szScript[0] == L'[')
            pszScriptW = &preW->szScript[1];

        if (PathFileExistsW(pszScriptW)) {
            if (pszScriptW > preW->szScript)
                StrCpyW(preW->szScript, pszScriptW);

            CopyFileToDir(W2CT(preW->szScript), pcrsp->pszExtractPath);
        }
    }

    WriteFile(pcrsp->hfileDat, pBlob, cbBlob, &cbWritten, NULL);

Exit:
    if (pBlob != NULL)
        CoTaskMemFree(pBlob);

    return TRUE;
}

BOOL exportRasCredentialsSettings(PCWSTR pszNameW, const PRASSETPARAMS pcrsp)
{
    RASDIALPARAMSW rdpW;
    PCWSTR pszUserNameW, pszPasswordW, pszDomainW;
    PBYTE  pBlob, pCur;
    DWORD  cbBlob, cbWritten,
           dwResult;
    BOOL   fPassword;

    ASSERT(RasIsInstalled());
    ASSERT(pszNameW != NULL);
    ASSERT(pcrsp != NULL && pcrsp->hfileDat != NULL);

    pBlob = NULL;

    ZeroMemory(&rdpW, sizeof(rdpW));
    rdpW.dwSize = sizeof(rdpW);
    StrCpyW(rdpW.szEntryName, pszNameW);

    dwResult = RasGetEntryDialParamsWrap(&rdpW, &fPassword);
    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    pszUserNameW = (*rdpW.szUserName != TEXT('\0')) ? rdpW.szUserName : NULL;
    pszPasswordW = fPassword ? rdpW.szPassword : NULL;
    pszDomainW   = (*rdpW.szDomain != TEXT('\0')) ? rdpW.szDomain : NULL;

    //----- Figure out the size of the blob  -----
    // size of structure header
    cbBlob = 2*sizeof(DWORD);

    // size of essential information
    cbBlob += (DWORD)((pszUserNameW != NULL) ? StrCbFromSzW(pszUserNameW) : sizeof(DWORD));
    cbBlob += (DWORD)((pszPasswordW != NULL) ? StrCbFromSzW(pszPasswordW) : sizeof(DWORD));
    cbBlob += (DWORD)((pszDomainW   != NULL) ? StrCbFromSzW(pszDomainW)   : sizeof(DWORD));

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (pBlob == NULL)
        goto Exit;
    ZeroMemory(pBlob, cbBlob);

    //----- Copy information into the blob -----
    pCur = pBlob;

    // stucture header
    *((PDWORD)pCur) = CS_STRUCT_RAS_CREADENTIALS;
    pCur += sizeof(DWORD);

    *((PDWORD)pCur) = cbBlob;
    pCur += sizeof(DWORD);

    // essential information
    copySzToBlob(&pCur, pszUserNameW);
    copySzToBlob(&pCur, pszPasswordW);
    copySzToBlob(&pCur, pszDomainW);
    ASSERT(pCur == pBlob + cbBlob);

    WriteFile(pcrsp->hfileDat, pBlob, cbBlob, &cbWritten, NULL);

Exit:
    if (pBlob != NULL)
        CoTaskMemFree(pBlob);

    return TRUE;
}

BOOL exportWininetSettings(PCWSTR pszNameW, const PRASSETPARAMS pcrsp)
{
    USES_CONVERSION;

    INTERNET_PER_CONN_OPTION_LISTW list;
    INTERNET_PER_CONN_OPTIONW      rgOptions[7];
    PCWSTR pszAuxW;
    PBYTE  pBlob, pCur;
    DWORD  cbBlob, cbAux;
    UINT   i;

    ASSERT(pcrsp != NULL && pcrsp->hfileDat != NULL && pcrsp->pszIns != NULL);

    pBlob = NULL;

    ZeroMemory(&list, sizeof(list));
    list.dwSize        = sizeof(list);
    list.pszConnection = (PWSTR)pszNameW;

    ZeroMemory(rgOptions, sizeof(rgOptions));
    list.dwOptionCount = countof(rgOptions);
    list.pOptions      = rgOptions;

    list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    list.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
    list.pOptions[4].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    list.pOptions[5].dwOption = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;
    list.pOptions[6].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;

    if (!pcrsp->fIntranet)                      // autoconfig stuff should be ignored
        list.dwOptionCount = 3;

    cbAux = list.dwSize;
    if (FALSE == InternetQueryOptionW(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &cbAux))
        goto Exit;

    if (!pcrsp->fIntranet)                      // autoconfig stuff should be ignored
        list.pOptions[0].Value.dwValue &= PROXY_TYPE_PROXY;

    //----- Figure out the size of the blob -----
    // size of structure header
    cbBlob = 2*sizeof(DWORD);

    // size of INTERNET_PER_CONN_OPTION_LIST header
    cbBlob += sizeof(DWORD);                    // list.dwOptionCount

    // size of INTERNET_PER_CONN_xxx - all of list.pOptions
    for (i = 0; i < min(list.dwOptionCount, countof(rgOptions)); i++) {
        cbBlob += sizeof(DWORD);

        switch (list.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            pszAuxW  = list.pOptions[i].Value.pszValue;
            cbBlob  += (DWORD)((pszAuxW != NULL) ? StrCbFromSzW(pszAuxW) : sizeof(DWORD));
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        default:                        // everything else is also DWORD
            cbBlob += sizeof(DWORD);
            break;
        }
    }

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (pBlob == NULL)
        goto Exit;

    //----- Copy information into the blob -----
    ZeroMemory(pBlob, cbBlob);
    pCur = pBlob;

    // stucture header
    *((PDWORD)pCur) = CS_STRUCT_WININET;
    pCur += sizeof(DWORD);

    *((PDWORD)pCur) = cbBlob;
    pCur += sizeof(DWORD);

    // INTERNET_PER_CONN_OPTION_LIST header
    *((PDWORD)pCur) = list.dwOptionCount;       // list.dwOptionCount
    pCur += sizeof(DWORD);

    // INTERNET_PER_CONN_xxx - all of list.pOptions
    for (i = 0; i < min(list.dwOptionCount, countof(rgOptions)); i++) {
        *((PDWORD)pCur) = list.pOptions[i].dwOption;
        pCur += sizeof(DWORD);

        switch (list.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            copySzToBlob(&pCur, list.pOptions[i].Value.pszValue);
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        default:                        // everything else is also DWORD
            *((PDWORD)pCur) = list.pOptions[i].Value.dwValue;
            pCur += sizeof(DWORD);
            break;
        }
    }
    ASSERT(pCur == pBlob + cbBlob);

    WriteFile(pcrsp->hfileDat, pBlob, cbBlob, &cbAux, NULL);

    //----- Save LAN's autoconfig and proxy settings to the ins -----
    if (pszNameW == NULL) {
        ASSERT(list.pOptions[0].dwOption == INTERNET_PER_CONN_FLAGS);

        //_____ autoconfig _____
        if (pcrsp->fIntranet) {
            TCHAR szReloadDelayMins[33];

            InsWriteBool(IS_URL, IK_DETECTCONFIG,
                HasFlag(list.pOptions[0].Value.dwValue, PROXY_TYPE_AUTO_DETECT), pcrsp->pszIns);

            InsWriteBool(IS_URL, IK_USEAUTOCONF,
                HasFlag(list.pOptions[0].Value.dwValue, PROXY_TYPE_AUTO_PROXY_URL), pcrsp->pszIns);

            ASSERT(list.pOptions[3].dwOption == INTERNET_PER_CONN_AUTOCONFIG_URL);
            InsWriteString(IS_URL, IK_AUTOCONFURL, W2CT(list.pOptions[3].Value.pszValue), pcrsp->pszIns);

            ASSERT(list.pOptions[4].dwOption == INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL);
            InsWriteString(IS_URL, IK_AUTOCONFURLJS, W2CT(list.pOptions[4].Value.pszValue), pcrsp->pszIns);

            ASSERT(list.pOptions[5].dwOption == INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS);
            wnsprintf(szReloadDelayMins, countof(szReloadDelayMins), TEXT("%lu"), list.pOptions[5].Value.dwValue);
            InsWriteString(IS_URL, IK_AUTOCONFTIME, szReloadDelayMins, pcrsp->pszIns);
        }
        else { /* if (!pcrsp->fIntranet) */     // autoconfig stuff should be ignored
            InsDeleteKey(IS_URL, IK_DETECTCONFIG,  pcrsp->pszIns);
            InsDeleteKey(IS_URL, IK_USEAUTOCONF,   pcrsp->pszIns);
            InsDeleteKey(IS_URL, IK_AUTOCONFURL,   pcrsp->pszIns);
            InsDeleteKey(IS_URL, IK_AUTOCONFURLJS, pcrsp->pszIns);
            InsDeleteKey(IS_URL, IK_AUTOCONFTIME,  pcrsp->pszIns);
        }

        //_____ proxy and proxy bypass settings _____
        if (pcrsp->fIntranet || HasFlag(list.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY)) {
            InsWriteBool(IS_PROXY, IK_PROXYENABLE,
                HasFlag(list.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY), pcrsp->pszIns);

            ASSERT(list.pOptions[1].dwOption == INTERNET_PER_CONN_PROXY_SERVER);
            parseProxyToIns(W2CT(list.pOptions[1].Value.pszValue), pcrsp->pszIns);

            ASSERT(list.pOptions[2].dwOption == INTERNET_PER_CONN_PROXY_BYPASS);
            InsWriteString(IS_PROXY, IK_PROXYOVERRIDE, W2CT(list.pOptions[2].Value.pszValue), pcrsp->pszIns);
        }
        else                                    // proxy not customized, delete the section
            InsDeleteSection(IS_PROXY, pcrsp->pszIns);
    }

Exit:
    if (pBlob != NULL)
        CoTaskMemFree(pBlob);

    if (list.pOptions[1].Value.pszValue != NULL) // INTERNET_PER_CONN_PROXY_SERVER
        GlobalFree(list.pOptions[1].Value.pszValue);

    if (list.pOptions[2].Value.pszValue != NULL) // INTERNET_PER_CONN_PROXY_BYPASS
        GlobalFree(list.pOptions[2].Value.pszValue);

    if (list.pOptions[3].Value.pszValue != NULL) // INTERNET_PER_CONN_AUTOCONFIG_URL
        GlobalFree(list.pOptions[3].Value.pszValue);

    if (list.pOptions[4].Value.pszValue != NULL) // INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL
        GlobalFree(list.pOptions[4].Value.pszValue);

    return TRUE;
}

BOOL exportOtherSettings(PCWSTR pszNameW, const PRASSETPARAMS pcrsp)
{
    USES_CONVERSION;

    TCHAR  szKey[MAX_PATH];
    PCTSTR pszName;
    HKEY   hk;
    BOOL   fExported;

    ASSERT(pszNameW != NULL);
    ASSERT(pcrsp    != NULL && pcrsp->hfileInf != NULL && pcrsp->pszIns != NULL);

    fExported = FALSE;

    pszName = W2CT(pszNameW);
    wnsprintf(szKey, countof(szKey), RK_REMOTEACCESS_PROFILES TEXT("\\%s"), pszName);

    if (ERROR_SUCCESS != SHOpenKeyHKCU(szKey, KEY_READ, &hk))
        return TRUE;

    if (S_OK == SHValueExists(hk, RV_COVEREXCLUDE)) {
        ExportRegValue2Inf(hk, RV_COVEREXCLUDE, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    if (S_OK == SHValueExists(hk, RV_ENABLEAUTODISCONNECT)) {
        ExportRegValue2Inf(hk, RV_ENABLEAUTODISCONNECT, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    if (S_OK == SHValueExists(hk, RV_ENABLEEXITDISCONNECT)) {
        ExportRegValue2Inf(hk, RV_ENABLEEXITDISCONNECT, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    if (S_OK == SHValueExists(hk, RV_DISCONNECTIDLETIME)) {
        ExportRegValue2Inf(hk, RV_DISCONNECTIDLETIME, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    if (S_OK == SHValueExists(hk, RV_REDIALATTEMPTS)) {
        ExportRegValue2Inf(hk, RV_REDIALATTEMPTS, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    if (S_OK == SHValueExists(hk, RV_REDIALINTERVAL)) {
        ExportRegValue2Inf(hk, RV_REDIALINTERVAL, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    SHCloseKey(hk);

    if (fExported)
        WriteStringToFile(pcrsp->hfileInf, (LPCVOID)TEXT("\r\n"), 2);

    return TRUE;
}


void lcy50_Initialize(PRASSETPARAMS prsp)
{
    TCHAR szTargetFile[MAX_PATH];
    DWORD dwVersion,
          dwAux;

    ASSERT(NULL != prsp && NULL != prsp->pszExtractPath);

    ZeroMemory(&prsp->lcy50, sizeof(prsp->lcy50));
    dwVersion = CS_VERSION_50;

    if (RasIsInstalled()) {
        PathCombine(szTargetFile, prsp->pszExtractPath, CONNECT_RAS);
        prsp->lcy50.hfileRas = CreateNewFile(szTargetFile);

        if (INVALID_HANDLE_VALUE != prsp->lcy50.hfileRas)
            WriteFile(prsp->lcy50.hfileRas, &dwVersion, sizeof(DWORD), &dwAux, NULL);
        else
            prsp->lcy50.hfileRas = NULL;
    }

    PathCombine(szTargetFile, prsp->pszExtractPath, CONNECT_SET);
    prsp->lcy50.hfileSet = CreateNewFile(szTargetFile);
    if (INVALID_HANDLE_VALUE != prsp->lcy50.hfileSet)
        WriteFile(prsp->lcy50.hfileSet, &dwVersion, sizeof(DWORD), &dwAux, NULL);
    else
        prsp->lcy50.hfileSet = NULL;
}

void lcy50_Uninitialize(PRASSETPARAMS prsp)
{
    ASSERT(NULL != prsp && NULL != prsp->pszExtractPath);

    if (NULL != prsp->lcy50.hfileSet) {
        CloseFile(prsp->lcy50.hfileSet);
        prsp->lcy50.hfileSet = NULL;
    }

    if (NULL != prsp->lcy50.hfileRas) {
        CloseFile(prsp->lcy50.hfileRas);
        prsp->lcy50.hfileRas = NULL;

        if (prsp->lcy50.nRasFileIndex == 0)
            DeleteFileInDir(CONNECT_RAS, prsp->pszExtractPath);
    }
}

BOOL lcy50_ExportRasSettings(PCSTR pszNameA, const PRASSETPARAMS pcrsp)
{
    USES_CONVERSION;

    TCHAR szKeyName[16],
          szKeySize[16],
          szValueSize[16];
    PBYTE pBlob;
    DWORD cbBlob,
          dwResult;

    if (NULL == pcrsp->lcy50.hfileRas)
        return FALSE;

    ASSERT(RasIsInstalled());
    ASSERT(NULL != pszNameA);
    ASSERT(NULL != pcrsp && NULL != pcrsp->pszIns);

    pBlob    = NULL;
    dwResult = RasGetEntryPropertiesExA(pszNameA, (LPRASENTRYA *)&pBlob, &cbBlob);
    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    // NOTE: (andrewgu) need to write the size of the data in the ins file because it's variable.
    // it can change depending on alternate phone numbers list at the end of the RASENTRYA
    // structure.
    wnsprintf(szKeyName,   countof(szKeyName),   IK_CONNECTNAME, pcrsp->lcy50.nRasFileIndex);
    wnsprintf(szKeySize,   countof(szKeySize),   IK_CONNECTSIZE, pcrsp->lcy50.nRasFileIndex);
    wnsprintf(szValueSize, countof(szValueSize), TEXT("%lu"),    cbBlob);

    InsWriteString(IS_CONNECTSET, szKeyName, A2CT(pszNameA), pcrsp->pszIns);
    InsWriteString(IS_CONNECTSET, szKeySize, szValueSize,    pcrsp->pszIns);

    // NOTE: (andrewgu) no script file processing is needed here. it's been taken care of when
    // processing settings for the new format. connection is ulimately the same it's just stored
    // differently.

    WriteFile(pcrsp->lcy50.hfileRas, pBlob, cbBlob, &dwResult, NULL);
    pcrsp->lcy50.nRasFileIndex++;

Exit:
    if (NULL != pBlob)
        CoTaskMemFree(pBlob);

    return TRUE;
}

BOOL lcy50_ExportWininetSettings(PCSTR pszNameA, const PRASSETPARAMS pcrsp)
{
    INTERNET_PER_CONN_OPTION_LISTA listA;
    INTERNET_PER_CONN_OPTIONA      rgOptionsA[7];
    PCSTR pszAuxA;
    PBYTE pBlob, pCur;
    DWORD cbBlob, cbAux;
    UINT  i;

    if (NULL == pcrsp->lcy50.hfileSet)
        return FALSE;

    ASSERT(NULL != pcrsp && NULL != pcrsp->pszIns);

    pBlob = NULL;

    ZeroMemory(&listA, sizeof(listA));
    listA.dwSize        = sizeof(listA);
    listA.pszConnection = (PSTR)pszNameA;

    ZeroMemory(rgOptionsA, sizeof(rgOptionsA));
    listA.dwOptionCount = countof(rgOptionsA);
    listA.pOptions      = rgOptionsA;

    listA.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    listA.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    listA.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    listA.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
    listA.pOptions[4].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    listA.pOptions[5].dwOption = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;
    listA.pOptions[6].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;

    if (!pcrsp->fIntranet)                      // autoconfig stuff should be ignored
        listA.dwOptionCount = 3;

    cbAux = listA.dwSize;
    if (FALSE == InternetQueryOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listA, &cbAux))
        goto Exit;

    if (!pcrsp->fIntranet)                      // autoconfig stuff should be ignored
        listA.pOptions[0].Value.dwValue &= PROXY_TYPE_PROXY;

    //----- Figure out the size of the blob describing this connection -----

    // size of INTERNET_PER_CONN_OPTION_LIST header
    cbBlob  = sizeof(DWORD);                    // listA.dwSize
    pszAuxA = listA.pszConnection;              // listA.pszConnection
    cbBlob += (DWORD)((NULL != pszAuxA) ? StrCbFromSzA(pszAuxA) : sizeof(DWORD));
#ifdef _WIN64
    cbBlob = LcbAlignLcb(cbBlob);
#endif
    cbBlob += sizeof(DWORD);                    // listA.dwOptionCount

    // size of INTERNET_PER_CONN_xxx - all of listA.pOptions
    for (i = 0; i < min(listA.dwOptionCount, countof(rgOptionsA)); i++) {
        cbBlob += sizeof(DWORD);

        switch (listA.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            pszAuxA = listA.pOptions[i].Value.pszValue;
            cbBlob += (DWORD)((NULL != pszAuxA) ? StrCbFromSzA(pszAuxA) : sizeof(DWORD));
#ifdef _WIN64
            cbBlob = LcbAlignLcb(cbBlob);
#endif
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        default:                        // everything else is also DWORD
            cbBlob += sizeof(DWORD);
            break;
        }
    }

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (NULL == pBlob)
        goto Exit;

    //----- Copy connection information into the blob -----
    ZeroMemory(pBlob, cbBlob);
    pCur = pBlob;

    // INTERNET_PER_CONN_OPTION_LIST header
    *((PDWORD)pCur) = cbBlob;                        // listA.dwSize
    pCur += sizeof(DWORD);
    lcy50_CopySzToBlobA(&pCur, listA.pszConnection); // listA.pszConnection
#ifdef _WIN64
    pCur = MyPbAlignPb(pCur);
#endif

    *((PDWORD)pCur) = listA.dwOptionCount;           // listA.dwOptionCount
    pCur += sizeof(DWORD);

    // INTERNET_PER_CONN_xxx - all of listA.pOptions
    for (i = 0; i < min(listA.dwOptionCount, countof(rgOptionsA)); i++) {
        *((PDWORD)pCur) = listA.pOptions[i].dwOption;
        pCur += sizeof(DWORD);

        switch (listA.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            lcy50_CopySzToBlobA(&pCur, listA.pOptions[i].Value.pszValue);
#ifdef _WIN64
            pCur = MyPbAlignPb(pCur);
#endif
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        default:                        // everything else is also DWORD
            *((PDWORD)pCur) = listA.pOptions[i].Value.dwValue;
            pCur += sizeof(DWORD);
            break;
        }
    }
    ASSERT(pCur == pBlob + cbBlob);

    WriteFile(pcrsp->lcy50.hfileSet, pBlob, cbBlob, &cbAux, NULL);

    // NOTE: (andrewgu) no processing that saves LAN's autoconfig and proxy settings to the ins is
    // needed. this processing is performed when processing settings for the new format. the
    // information is ulimately the same it's just stored differently.

Exit:
    if (NULL != pBlob)
        CoTaskMemFree(pBlob);

    if (NULL != listA.pOptions[1].Value.pszValue) // INTERNET_PER_CONN_PROXY_SERVER
        GlobalFree(listA.pOptions[1].Value.pszValue);

    if (NULL != listA.pOptions[2].Value.pszValue) // INTERNET_PER_CONN_PROXY_BYPASS
        GlobalFree(listA.pOptions[2].Value.pszValue);

    if (NULL != listA.pOptions[3].Value.pszValue) // INTERNET_PER_CONN_AUTOCONFIG_URL
        GlobalFree(listA.pOptions[3].Value.pszValue);

    if (NULL != listA.pOptions[4].Value.pszValue) // INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL
        GlobalFree(listA.pOptions[4].Value.pszValue);

    return TRUE;
}

inline void lcy50_CopySzToBlobA(PBYTE *ppBlob, PCSTR pszStrA)
{
    ASSERT(ppBlob != NULL && *ppBlob != NULL);

    if (NULL == pszStrA) {
        *((PDWORD)(*ppBlob)) = (DWORD)NULL;
        *ppBlob += sizeof(DWORD);
    }
    else {
        StrCpyA((PSTR)(*ppBlob), pszStrA);
        *ppBlob += StrCbFromSzA(pszStrA);
    }
}


BOOL deleteScriptFiles(PCTSTR pszSettingsFile, PCTSTR pszExtractPath, PCTSTR pszIns)
{
    TCHAR  szScript[MAX_PATH],
           szKey[16];
    PBYTE  pBlob, pCur;
    HANDLE hFile;
    DWORD  dwVersion,
           cbBlob, cbAux;
    BOOL   fResult;

    if (pszSettingsFile == NULL || *pszSettingsFile == TEXT('\0') ||
        pszExtractPath  == NULL || *pszExtractPath  == TEXT('\0'))
        return FALSE;

    hFile   = NULL;
    pBlob   = NULL;
    fResult = FALSE;

    //----- Read settings file into internal memory buffer -----
    hFile = CreateFile(pszSettingsFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        hFile = NULL;
        goto Exit;
    }

    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    cbBlob = GetFileSize(hFile, NULL);
    if (cbBlob == 0xFFFFFFFF)
        goto Exit;

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (pBlob == NULL)
        goto Exit;
    ZeroMemory(pBlob, cbBlob);

    if (ReadFile(hFile, pBlob, cbBlob, &cbAux, NULL) != TRUE)
        goto Exit;

    dwVersion = *((PDWORD)pBlob);
    pCur      = pBlob + sizeof(DWORD);

    if (dwVersion == CS_VERSION_50) {
        LPRASENTRYA preA;
        PSTR pszScriptA;
        UINT i;

        //----- Parse through RAS connections information -----
        for (i = 0; TRUE; i++, pCur += cbAux) {

            //_____ Initialization _____
            wnsprintf(szKey, countof(szKey), IK_CONNECTNAME, i);
            if (InsKeyExists(IS_CONNECTSET, szKey, pszIns))
                break;

            wnsprintf(szKey, countof(szKey), IK_CONNECTSIZE, i);
            cbAux = InsGetInt(IS_CONNECTSET, szKey, 0, pszIns);
            if (cbAux == 0)
                goto Exit;

            //_____ Main processing _____
            preA = (LPRASENTRYA)pCur;

            if (preA->szScript[0] != '\0') {
                pszScriptA = preA->szScript;
                if (preA->szScript[0] == '[')
                    pszScriptA = &preA->szScript[1];

                A2Tbuf(pszScriptA, szScript, countof(szScript));
                DeleteFileInDir(PathFindFileName(szScript), pszExtractPath);
            }
        }
    }
    else if (dwVersion >= CS_VERSION_5X && dwVersion <= CS_VERSION_5X_MAX) {
        LPRASENTRYW preW;
        PWSTR pszScriptW;

        //----- Parse through all structures -----
        while (pCur < pBlob + cbBlob)
            switch (*((PDWORD)pCur)) {
            case CS_STRUCT_RAS:
                //_____ Main processing _____
                preW = (LPRASENTRYW)(pCur + 2*sizeof(DWORD));

                // preW->szScript
                if (preW->szScript[0] != L'\0') {
                    pszScriptW = preW->szScript;
                    if (preW->szScript[0] == L'[')
                        pszScriptW = &preW->szScript[1];

                    W2Tbuf(pszScriptW, szScript, countof(szScript));
                    DeleteFileInDir(PathFindFileName(szScript), pszExtractPath);
                }
                break;

            default:
                pCur += *((PDWORD)(pCur + sizeof(DWORD)));
            }
    }
    else {
        ASSERT(FALSE);
        goto Exit;
    }

    fResult = TRUE;

    //----- Cleanup -----
Exit:
    if (pBlob != NULL)
        CoTaskMemFree(pBlob);

    if (hFile != NULL)
        CloseFile(hFile);

    return fResult;
}

void parseProxyToIns(PCTSTR pszProxy, PCTSTR pszIns)
{
    struct {
        PCTSTR pszServer;
        PCTSTR pszKey;
        PCTSTR pszValue;
    } rgProxyMap[] = {
        { TEXT("http"),   IK_HTTPPROXY,   NULL },
        { TEXT("https"),  IK_SECPROXY,    NULL },
        { TEXT("ftp"),    IK_FTPPROXY,    NULL },
        { TEXT("gopher"), IK_GOPHERPROXY, NULL },
        { TEXT("socks"),  IK_SOCKSPROXY,  NULL }
    };

    TCHAR szProxy[MAX_PATH];
    PTSTR pszCur, pszToken, pszAux;
    UINT  i;
    BOOL  fSameProxy;

    if (pszProxy == NULL || *pszProxy == TEXT('\0') ||
        pszIns   == NULL || *pszIns   == TEXT('\0'))
        return;

    fSameProxy = (NULL == StrChr(pszProxy, TEXT('=')));
    InsWriteBool(IS_PROXY, IK_SAMEPROXY, fSameProxy, pszIns);

    if (fSameProxy) {
        InsWriteString(IS_PROXY, IK_HTTPPROXY, pszProxy, pszIns);
        return;
    }

    StrCpy(szProxy, pszProxy);
    for (pszCur  = szProxy;
         pszCur != NULL && *pszCur != TEXT('\0');
         pszCur  = (pszToken != NULL) ? (pszToken + 1) : NULL) {

        // strip out token in the from "server=value:port#;"
        pszToken = StrChr(pszCur, TEXT(';'));
        if (pszToken != NULL)
            *pszToken = TEXT('\0');

        // strip out the server part "server="
        pszAux = StrChr(pszCur, TEXT('='));
        if (pszAux == NULL) {
            ASSERT(FALSE);                      // no TEXT('=') in the token,
            continue;                           // continue
        }
        *pszAux = TEXT('\0');
        StrRemoveWhitespace(pszCur);

        for (i = 0; i < countof(rgProxyMap); i++)
            if (0 == StrCmpI(rgProxyMap[i].pszServer, pszCur))
                break;
        if (i >= countof(rgProxyMap))
            continue;                           // unknown server, continue

        StrRemoveWhitespace(pszAux + 1);
        rgProxyMap[i].pszValue = pszAux + 1;
    }

    for (i = 0; i < countof(rgProxyMap); i++)
        InsWriteString(IS_PROXY, rgProxyMap[i].pszKey, rgProxyMap[i].pszValue, pszIns);
}

inline void copySzToBlob(PBYTE *ppBlob, PCWSTR pszStrW)
{
    ASSERT(ppBlob != NULL && *ppBlob != NULL);

    if (pszStrW == NULL) {
        *((PDWORD)(*ppBlob)) = (DWORD)NULL;
        *ppBlob += sizeof(DWORD);
    }
    else {
        StrCpyW((PWSTR)(*ppBlob), pszStrW);
        *ppBlob += StrCbFromSzW(pszStrW);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\channels.cpp ===
#include "precomp.h"
#include "channels.h"

#define NSUBGRPS 10

static DWORD s_dwMode;

static void channels_InitHelper(HWND hDlg, LPCTSTR pcszAltDir, LPCTSTR pcszWorkDir, LPCTSTR pcszCustIns,
                                WORD idList, DWORD dwPlatformId, BOOL fIgnoreOffline);
static void channels_SaveHelper(HWND hwndList, LPCTSTR pcszChanDir, LPCTSTR pcszCustIns, DWORD dwMode);
static int importChannels(HWND hDlg);
static BOOL CALLBACK addEditChannel(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static PCHANNEL findFreeChannel(HWND hwndList);

void WINAPI Channels_InitA(HWND hDlg, LPCSTR pcszAltDir, LPCSTR pcszWorkDir, LPCSTR pcszCustIns,
                           WORD idList, DWORD dwPlatformId, BOOL fIgnoreOffline)
{
    USES_CONVERSION;

    channels_InitHelper(hDlg, A2CT(pcszAltDir), A2CT(pcszWorkDir), A2CT(pcszCustIns), idList,
        dwPlatformId, fIgnoreOffline);
}

void WINAPI Channels_InitW(HWND hDlg, LPCWSTR pcwszAltDir, LPCWSTR pcwszWorkDir, LPCWSTR pcwszCustIns, 
                           WORD idList, DWORD dwPlatformId, BOOL fIgnoreOffline)
{
    USES_CONVERSION;

    channels_InitHelper(hDlg, W2CT(pcwszAltDir), W2CT(pcwszWorkDir), W2CT(pcwszCustIns), 
        idList, dwPlatformId, fIgnoreOffline);
}

void WINAPI Channels_SaveA(HWND hwndList, LPCSTR pcszChanDir, LPCSTR pcszCustIns, DWORD dwMode /*= IEM_NEUTRAL*/)
{
    USES_CONVERSION;

    channels_SaveHelper(hwndList, A2CT(pcszChanDir), A2CT(pcszCustIns), dwMode);
}

void WINAPI Channels_SaveW(HWND hwndList, LPCWSTR pcwszChanDir, LPCWSTR pcwszCustIns, DWORD dwMode /*= IEM_NEUTRAL*/)
{
    USES_CONVERSION;

    channels_SaveHelper(hwndList, W2CT(pcwszChanDir), W2CT(pcwszCustIns), dwMode);
}

int WINAPI Channels_Import(HWND hDlg)
{
    int nChannels = 0;

    nChannels = importChannels(hDlg);
    if (nChannels == 0)
        ErrorMessageBox(hDlg, IDS_NOCHANNELSTOIMPORT);

    return nChannels;
}

BOOL WINAPI Channels_Remove(HWND hDlg)
{
    PCHANNEL pChan;
    int i;

    i = (INT) SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_GETCURSEL, 0, 0);
    pChan = (PCHANNEL)SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_GETITEMDATA, (WPARAM)i, 0);
    *pChan->szTitle = TEXT('\0');
    SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_DELETESTRING, (WPARAM)i, 0);

    // if add buttons have been disabled because we reached the max, then reenable them

    if (!IsWindowEnabled(GetDlgItem(hDlg, IDC_ADDCHANNEL)))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_ADDCHANNEL), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_ADDCATEGORY), TRUE);
    }

    if (SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_SETCURSEL, (WPARAM)i, 0) == LB_ERR)
    {
        if (SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_SETCURSEL, (WPARAM)(i-1), 0) == LB_ERR)
        {
            EnsureDialogFocus(hDlg, IDC_EDITCHANNEL, IDC_ADDCHANNEL);
            EnableWindow(GetDlgItem(hDlg, IDC_EDITCHANNEL), FALSE);
            EnsureDialogFocus(hDlg, IDC_REMOVECHANNEL, IDC_ADDCHANNEL);
            EnableWindow(GetDlgItem(hDlg, IDC_REMOVECHANNEL), FALSE);
        }
        else
            SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_SETTOPINDEX, (WPARAM)i, 0);
    }
    else
        SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_SETTOPINDEX, (WPARAM)i, 0);

    return TRUE;
}

static HRESULT xML_GetElementByIndex(IXMLElementCollection* pIXMLElementCollection, LONG nIndex,
                                     IXMLElement** ppIXMLElement)
{
    HRESULT hr;
    VARIANT var1, var2;

    if (!pIXMLElementCollection || !ppIXMLElement)
        return E_FAIL;

    VariantInit(&var1);
    VariantInit(&var2);

    var1.vt   = VT_I4;
    var1.lVal = nIndex;

    IDispatch* pIDispatch;

    hr = pIXMLElementCollection->item(var1, var2, &pIDispatch);

    if (SUCCEEDED(hr) && pIDispatch)
    {
        hr = pIDispatch->QueryInterface(IID_IXMLElement, (void**)ppIXMLElement);

        pIDispatch->Release();
    }
    else
    {
        *ppIXMLElement = NULL;
        hr = E_FAIL;
    }

    return hr;
}

static BOOL xML_ParseElement(IXMLElement * pIXMLElement, LPTSTR pszPath,
                             LPCWSTR pcwszImageTypeW, LPCTSTR pcszBaseUrl)
{
    HRESULT hr;
    BSTR bstrTagName;
    VARIANT var;
    WCHAR szImagePathW[MAX_PATH];
    TCHAR szFullUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szImageUrl[INTERNET_MAX_URL_LENGTH];
    INTERNET_CACHE_ENTRY_INFO *lpiceiInfo;
    DWORD dwSize = 0;

    USES_CONVERSION;

    hr = pIXMLElement->get_tagName(&bstrTagName);

    if (SUCCEEDED(hr) && bstrTagName)
    {
        if (StrCmpIW(bstrTagName, WSTR_LOGO) == 0)
        {
            VariantInit(&var);
            hr = pIXMLElement->getAttribute(WSTR_STYLE, &var);
            if ((SUCCEEDED(hr)) && (var.vt == VT_BSTR) && (var.bstrVal != NULL))
            {
                if ((StrCmpIW(var.bstrVal, pcwszImageTypeW) == 0) ||
                    ((StrCmpIW(pcwszImageTypeW, WSTR_IMAGEW) == 0) &&
                    (StrCmpIW(var.bstrVal, L"IMAGEWIDE") == 0)))
                {
                    VariantClear(&var);
                    hr = pIXMLElement->getAttribute(WSTR_HREF, &var);
                    if ((SUCCEEDED(hr)) && (var.vt == VT_BSTR) && (var.bstrVal != NULL))
                    {
                        W2Tbux(var.bstrVal, szImageUrl);
                        if (PathIsURL(szImageUrl)  ||  ISNULL(pcszBaseUrl))
                            StrCpy(szFullUrl, szImageUrl);
                        else
                        {
                            DWORD cbSize = sizeof(szFullUrl);

                            InternetCombineUrl(pcszBaseUrl, szImageUrl, szFullUrl, &cbSize, ICU_NO_ENCODE);
                        }

                        RetrieveUrlCacheEntryFile(szFullUrl, NULL, &dwSize, 0);
                        lpiceiInfo = (INTERNET_CACHE_ENTRY_INFO *)LocalAlloc(LPTR, dwSize);
                        if (RetrieveUrlCacheEntryFile(szFullUrl, lpiceiInfo, &dwSize, 0))
                        {
                            StrCpy(pszPath, lpiceiInfo->lpszLocalFileName);
                            LocalFree(lpiceiInfo);
                            UnlockUrlCacheEntryFile(szFullUrl, 0);
                            return TRUE;
                        }
                        else
                        {
                            LocalFree(lpiceiInfo);
                            hr = URLDownloadToCacheFileW(NULL, T2W(szFullUrl), szImagePathW, ARRAYSIZE(szImagePathW), 0, NULL);
                            if (SUCCEEDED(hr))
                            {
                                W2Tbux(szImagePathW, pszPath);
                                return TRUE;
                            }
                        }
                    }
                }
            }
        }
    }

    return FALSE;
}
// Takes a cdf url, downloads to the cache if necessary, and parses to
// find the image path in the cache(downloading again if necessary) for
// either wide logo, logo or image.  Returns FALSE if none specified

static BOOL getCdfImage(LPCTSTR szCdfUrl, LPTSTR szPath, LPCWSTR szImageTypeW)
{
    TCHAR szCdfUrlPath[INTERNET_MAX_URL_LENGTH];
    IXMLDocument* pIXMLDocument = NULL;
    IPersistStreamInit* pIPersistStreamInit = NULL;
    IStream* pIStream = NULL;
    IXMLElement *pRootElem = NULL;
    BOOL bLoad = FALSE;
    HRESULT hr = S_OK;
    INTERNET_CACHE_ENTRY_INFO *lpiceiInfo;
    DWORD dwSize = 0;

    RetrieveUrlCacheEntryFile(szCdfUrl, NULL, &dwSize, 0);
    lpiceiInfo = (INTERNET_CACHE_ENTRY_INFO *)LocalAlloc(LPTR, dwSize);
    if (RetrieveUrlCacheEntryFile(szCdfUrl, lpiceiInfo, &dwSize, 0))
    {
        StrCpy(szCdfUrlPath, lpiceiInfo->lpszLocalFileName);
        UnlockUrlCacheEntryFile(szCdfUrl, 0);
    }
    else
    {
        hr = URLDownloadToCacheFile(NULL, szCdfUrl, szCdfUrlPath, ARRAYSIZE(szCdfUrlPath), 0, NULL);
    }
    LocalFree(lpiceiInfo);

    if (!SUCCEEDED(hr))
    {
        return FALSE;
    }

    hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                          IID_IXMLDocument, (void**)&pIXMLDocument);

    // load the document

    if (SUCCEEDED(hr) && pIXMLDocument)
    {
        hr = pIXMLDocument->QueryInterface(IID_IPersistStreamInit,
                                          (void**)&pIPersistStreamInit);

        if (SUCCEEDED(hr) && pIPersistStreamInit)
        {
            hr = SHCreateStreamOnFile(szCdfUrlPath, STGM_READ, &pIStream);

            if (SUCCEEDED(hr) && pIStream)
            {
                hr = pIPersistStreamInit->Load(pIStream);
                pIStream->Release();
                bLoad = TRUE;
            }
            pIPersistStreamInit->Release();
        }
    }

    if (!bLoad)
    {
        if (pIXMLDocument)
            pIXMLDocument->Release();
        return FALSE;
    }

    // Now lets get the image

    hr = pIXMLDocument->get_root(&pRootElem);

    if (SUCCEEDED(hr) && pRootElem)
    {
        TCHAR szBaseUrl[INTERNET_MAX_URL_LENGTH];
        VARIANT var;
        IXMLElementCollection* pIXMLElementCollection;

        VariantInit(&var);

        *szBaseUrl = TEXT('\0');
        hr = pRootElem->getAttribute(WSTR_BASE, &var);
        if ((SUCCEEDED(hr)) && (var.vt == VT_BSTR) && (var.bstrVal != NULL))
            W2Tbux(var.bstrVal, szBaseUrl);

        hr = pRootElem->get_children(&pIXMLElementCollection);

        if (SUCCEEDED(hr) && pIXMLElementCollection)
        {
            LONG nCount;

            hr = pIXMLElementCollection->get_length(&nCount);

            if (SUCCEEDED(hr))
            {
                for (int i = 0; i < nCount; i++)
                {
                    IXMLElement* pIXMLElement;

                    hr = xML_GetElementByIndex(pIXMLElementCollection, i, &pIXMLElement);

                    if (SUCCEEDED(hr) && pIXMLElement)
                    {
                        if (xML_ParseElement(pIXMLElement, szPath, szImageTypeW, szBaseUrl))
                        {
                            pIXMLElement->Release();
                            hr = S_OK;
                            break;
                        }
                        pIXMLElement->Release();
                        hr = E_FAIL;
                    }
                }
            }
            pIXMLElementCollection->Release();
        }
        pRootElem->Release();
    }
    pIXMLDocument->Release();

    if (SUCCEEDED(hr))
        return TRUE;
    else
        return FALSE;
}

// This DlgProc handles the processing for all popups on all platforms
// Note that the narrow image, wide image, and icon resource id's are the
// same for channels and categories.

static BOOL CALLBACK addEditChannel(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szWrk[MAX_URL];
    TCHAR szTitle[MAX_PATH] = TEXT("");               // buffers used for validation
    TCHAR szPreUrlPath[MAX_PATH] = TEXT("");
    TCHAR szIcon[MAX_PATH] = TEXT("");
    TCHAR szLogo[MAX_PATH] = TEXT("");
    TCHAR szWebUrl[INTERNET_MAX_URL_LENGTH] = TEXT("");
    PCHANNEL pSelCh;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pSelCh = (PCHANNEL)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pSelCh);
        if (pSelCh->fCategory)
        {
            EnableDBCSChars(hDlg, IDC_CATEGORYHTML);
            EnableDBCSChars(hDlg, IDE_CATEGORYTITLE);
            SetDlgItemText(hDlg,  IDC_CATEGORYHTML,  pSelCh->szWebUrl);
            SetDlgItemText(hDlg,  IDE_CATEGORYTITLE, pSelCh->szTitle);
        }
        else
        {
            EnableDBCSChars(hDlg, IDE_CHANNELSRVURL2);
            EnableDBCSChars(hDlg, IDE_CHANNELTITLE2);
            SetDlgItemText(hDlg,  IDE_CHANNELSRVURL2, pSelCh->szWebUrl);
            SetDlgItemText(hDlg,  IDE_CHANNELTITLE2,  pSelCh->szTitle);
        }

        EnableDBCSChars(hDlg, IDC_CHANNELBITMAP2);
        EnableDBCSChars(hDlg, IDC_CHANNELICON2);
        SetDlgItemText(hDlg, IDC_CHANNELBITMAP2, pSelCh->szLogo);
        SetDlgItemText(hDlg, IDC_CHANNELICON2, pSelCh->szIcon);

        if (!pSelCh->fCategory)
        {
            EnableDBCSChars(hDlg, IDC_CHANNELURL2);
            SetDlgItemText(hDlg,  IDC_CHANNELURL2, pSelCh->szPreUrlPath);

            if (!HasFlag(s_dwMode, (IEM_CORP | IEM_PROFMGR)))
                DisableDlgItem(hDlg, IDC_CHANNELOFFL);

            else
                if (pSelCh->fOffline)
                    CheckDlgButton(hDlg, IDC_CHANNELOFFL, BST_CHECKED);
        }
        else
            ASSERT(!HasFlag(s_dwMode, IEM_ADMIN));
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDC_BROWSECHBMP2:
                GetDlgItemText(hDlg, IDC_CHANNELBITMAP2, szWrk, ARRAYSIZE(szWrk));
                if (BrowseForFile(hDlg, szWrk, ARRAYSIZE(szWrk), GFN_PICTURE))
                    SetDlgItemText(hDlg, IDC_CHANNELBITMAP2, szWrk);
                break;
            case IDC_BROWSECHICO2:
                GetDlgItemText(hDlg, IDC_CHANNELICON2, szWrk, ARRAYSIZE(szWrk));
                if (BrowseForFile(hDlg, szWrk, ARRAYSIZE(szWrk), GFN_ICO | GFN_PICTURE))
                    SetDlgItemText(hDlg, IDC_CHANNELICON2, szWrk);
                break;
            case IDC_BROWSECDF2:
                GetDlgItemText(hDlg, IDC_CHANNELURL2, szWrk, ARRAYSIZE(szWrk));
                if (BrowseForFile(hDlg, szWrk, ARRAYSIZE(szWrk), GFN_CDF))
                    SetDlgItemText(hDlg, IDC_CHANNELURL2, szWrk);
                break;
            case IDC_BROWSECATHTML:
                GetDlgItemText(hDlg, IDC_CATEGORYHTML, szWrk, ARRAYSIZE(szWrk));
                if (BrowseForFile(hDlg, szWrk, ARRAYSIZE(szWrk), GFN_LOCALHTM))
                    SetDlgItemText(hDlg, IDC_CATEGORYHTML, szWrk);
                break;
            case IDCANCEL:
                EndDialog( hDlg, IDCANCEL );
                break;
            case IDOK:
                pSelCh = (PCHANNEL)GetWindowLongPtr(hDlg, DWLP_USER);
                if (pSelCh->fCategory)
                {
                    GetDlgItemText( hDlg, IDE_CATEGORYTITLE, szTitle, ARRAYSIZE(szTitle) );
                    GetDlgItemText( hDlg, IDC_CATEGORYHTML, szWebUrl, ARRAYSIZE(szWebUrl) );
                }
                else
                {
                    GetDlgItemText( hDlg, IDE_CHANNELTITLE2, szTitle, ARRAYSIZE(szTitle) );
                    GetDlgItemText( hDlg, IDE_CHANNELSRVURL2, szWebUrl, ARRAYSIZE(szWebUrl) );
                }

                GetDlgItemText( hDlg, IDC_CHANNELBITMAP2, szLogo, ARRAYSIZE(szLogo) );
                GetDlgItemText( hDlg, IDC_CHANNELICON2, szIcon, ARRAYSIZE(szIcon) );
                if (!pSelCh->fCategory) {
                    GetDlgItemText(hDlg, IDC_CHANNELURL2, szPreUrlPath, ARRAYSIZE(szPreUrlPath));

                    pSelCh->fOffline = IsWindowEnabled(GetDlgItem(hDlg, IDC_CHANNELOFFL)) &&
                                         (IsDlgButtonChecked(hDlg, IDC_CHANNELOFFL) == BST_CHECKED);
                }

                if (pSelCh->fCategory)
                {
                    if (!CheckField(hDlg, IDE_CATEGORYTITLE, FC_NONNULL))
                        break;
                }
                else
                {
                    if (!CheckField(hDlg, IDE_CHANNELTITLE2, FC_NONNULL) ||
                        !CheckField(hDlg, IDE_CHANNELSRVURL2, FC_NONNULL | FC_URL))
                        break;
                }

                if (!CheckField(hDlg, IDC_CHANNELBITMAP2, FC_FILE | FC_EXISTS) ||
                    !CheckField(hDlg, IDC_CHANNELICON2, FC_FILE | FC_EXISTS) ||
                    (!pSelCh->fCategory && !CheckField(hDlg, IDC_CHANNELURL2, FC_FILE | FC_EXISTS)))
                    break;

                // make sure they're not adding a duplicate channel/category name

                if ((StrCmpI(pSelCh->szTitle, szTitle) != 0) &&
                    (ListBox_GetCount(GetDlgItem(pSelCh->hDlg, IDC_CHANNELLIST))) &&
                    (ListBox_FindStringExact(GetDlgItem(pSelCh->hDlg, IDC_CHANNELLIST), -1,
                    szTitle) != LB_ERR))
                {
                    ErrorMessageBox(hDlg, IDS_DUPCHAN);
                    break;
                }

                StrCpy(pSelCh->szTitle, szTitle);
                StrCpy(pSelCh->szWebUrl, szWebUrl);

                StrCpy(pSelCh->szPreUrlPath, szPreUrlPath);
                StrCpy(pSelCh->szIcon, szIcon);
                StrCpy(pSelCh->szLogo, szLogo);

                EndDialog( hDlg, IDOK );
                break;
            }
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

static PCHANNEL findFreeChannel(HWND hwndList)
{
    int i;
    PCHANNEL pChan;

    for (i=0, pChan=(PCHANNEL)GetWindowLongPtr(hwndList, GWLP_USERDATA);
         (i < MAX_CHAN) && (pChan != NULL); i++, pChan++)
    {
        if (ISNULL(pChan->szTitle))
        {
            ZeroMemory(pChan, sizeof(CHANNEL));
            return pChan;
        }
    }

    return NULL;
}

static void convertUrlToFile(LPTSTR pszUrl)
{
    TCHAR szFileName[MAX_PATH];
    LPTSTR pFile;

    if (ISNULL(pszUrl))
        return;

    if (StrCmpNI(pszUrl, TEXT("file:"), 5) != 0)
        return;
    else
    {
        pFile = pszUrl + 5;
        while ((*pFile == TEXT('/')) || (*pFile == TEXT(' ')))
        {
            pFile++;
        }
    }
    StrCpy(szFileName, pFile);
    StrCpy(pszUrl, szFileName);
}

static BOOL importAddChannel(HWND hDlg, LPTSTR pszDir, LPTSTR pszChan, PCHANNEL pChan, BOOL fCategory)
{
    TCHAR szDeskIni[MAX_PATH];
    DWORD dwSize = sizeof(pChan->szWebUrl);
    HKEY hkPreload;
    int i;

    if (ListBox_FindStringExact(GetDlgItem(hDlg, IDC_CHANNELLIST), -1,
        pszChan) != LB_ERR)
        return FALSE;

    PathCombine(szDeskIni, pszDir, TEXT("Desktop.Ini"));
    if (!PathFileExists(szDeskIni))
        return FALSE;

    pChan->szWebUrl[0] = TEXT('\0');
    if (fCategory)
    {
        GetPrivateProfileString(SHELLCLASSINFO, URL, TEXT(""), pChan->szWebUrl, ARRAYSIZE(pChan->szWebUrl), szDeskIni );
        GetPrivateProfileString(SHELLCLASSINFO, LOGO, TEXT(""), pChan->szLogo, ARRAYSIZE(pChan->szLogo), szDeskIni );
        GetPrivateProfileString(SHELLCLASSINFO, ICONFILE, TEXT(""), pChan->szIcon, ARRAYSIZE(pChan->szIcon), szDeskIni );

        // szWebUrl can be empty (this is valid according to the specs)
        if (ISNONNULL(pChan->szWebUrl))
        {
            // szWebUrl is an 8.3 name; construct the fully qualified path
            StrCpy(pChan->szPreUrlPath, pChan->szWebUrl);   // szPreUrlPath is used
                                                        // as a temp buffer
            StrCpy(pChan->szWebUrl, pszDir);
            PathAppend(pChan->szWebUrl, pChan->szPreUrlPath);
            pChan->szPreUrlPath[0] = TEXT('\0');
        }
    }
    else
    {
        GetPrivateProfileString(CHANNEL_SECT, CDFURL, TEXT(""), pChan->szWebUrl, ARRAYSIZE(pChan->szWebUrl), szDeskIni );
        GetPrivateProfileString(CHANNEL_SECT, LOGO, TEXT(""), pChan->szLogo, ARRAYSIZE(pChan->szLogo), szDeskIni );
        GetPrivateProfileString(CHANNEL_SECT, ICON, TEXT(""), pChan->szIcon, ARRAYSIZE(pChan->szIcon), szDeskIni );
        if (RegOpenKeyEx(HKEY_CURRENT_USER, PRELOAD_KEY, 0, KEY_DEFAULT_ACCESS, &hkPreload) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkPreload, pChan->szWebUrl, NULL, NULL, (LPBYTE)pChan->szPreUrlPath, &dwSize) != ERROR_SUCCESS)
                pChan->szPreUrlPath[0] = TEXT('\0');
            else
                convertUrlToFile(pChan->szPreUrlPath);  // strip "file://" from szPreUrlPath
            RegCloseKey(hkPreload);
        }
    }

    // categories do not need to have an .htm file according to the original channel spec
    if (!fCategory && ISNULL(pChan->szWebUrl))
    {
        ZeroMemory(pChan, sizeof(CHANNEL));
        return FALSE;
    }

    StrCpy(pChan->szTitle, pszChan);
    pChan->fCategory = fCategory;

    i = (INT) SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_ADDSTRING, 0, (LPARAM)pChan->szTitle);
    SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_SETITEMDATA, (WPARAM)i, (LPARAM)pChan);

    if (ISNULL(pChan->szLogo))
    {
        if (!getCdfImage(pChan->szWebUrl, pChan->szLogo, WSTR_IMAGE))
            pChan->szLogo[0] = TEXT('\0');
    }
    convertUrlToFile(pChan->szLogo);

    if (ISNULL(pChan->szIcon))
    {
        if (!getCdfImage(pChan->szWebUrl, pChan->szIcon, WSTR_ICON))
            pChan->szIcon[0] = TEXT('\0');
    }
    convertUrlToFile(pChan->szIcon);

    return TRUE;
}


static BOOL enumChannels(HWND hDlg, LPTSTR pszDir, LPTSTR pszCat, LPINT pnChannels)
{
    WIN32_FIND_DATA fd;
    TCHAR           szFindPath[MAX_PATH];
    HANDLE          hFind;
    BOOL            fCategory = FALSE;

    StrCpy(szFindPath, pszDir);
    PathAppend(szFindPath, TEXT("*.*"));
    hFind = FindFirstFile(szFindPath, &fd);
    if (hFind == INVALID_HANDLE_VALUE)
        return FALSE;

    do
    {
        TCHAR szSubChan[MAX_PATH];

        // NOTE: if pszCat is empty string (""), PathAppend doesn't prefix a
        // backslash in szSubChan
        StrCpy(szSubChan, pszCat);
        PathAppend(szSubChan, fd.cFileName);
        if ((StrCmp(fd.cFileName, TEXT(".")) != 0) &&
            (StrCmp(fd.cFileName, TEXT("..")) != 0) &&
            (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            TCHAR szSubDir[MAX_PATH];

            PathCombine(szSubDir, pszDir, fd.cFileName);
            fCategory = TRUE;
            if (!enumChannels(hDlg, szSubDir, szSubChan, pnChannels))
                return FALSE;
        }
    } while (FindNextFile(hFind, &fd));

	FindClose(hFind);

    if (ISNONNULL(pszCat))
    {
        PCHANNEL pChan = findFreeChannel(GetDlgItem(hDlg, IDC_CHANNELLIST));

        if (pChan == NULL)      // MAX_CHAN reached
        {
            EnsureDialogFocus(hDlg, IDC_ADDCHANNEL, IDC_REMOVECHANNEL);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDCHANNEL), FALSE);
            EnsureDialogFocus(hDlg, IDC_ADDCATEGORY, IDC_REMOVECHANNEL);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDCATEGORY), FALSE);
            return FALSE;
        }
        if (importAddChannel(hDlg, pszDir, pszCat, pChan, fCategory))
            (*pnChannels)++;
    }

    return TRUE;
}

static int importChannels(HWND hDlg)
{
    DWORD dwLength, dwType;
    TCHAR szChanPath[MAX_PATH];
    TCHAR szChannelsDir[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    HKEY hkFav;
    int  nChannels = 0;

    SetCursor(LoadCursor(NULL, IDC_WAIT) );

    // build path to current user favorites
    dwLength = MAX_PATH;
    if (RegOpenKeyEx( HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
            0, KEY_DEFAULT_ACCESS, &hkFav ) != ERROR_SUCCESS)
    {
        return 0;
    }

    if (RegQueryValueEx( hkFav, TEXT("Favorites"), NULL, &dwType, (LPBYTE) szChanPath, &dwLength ) != ERROR_SUCCESS)
    {
        RegCloseKey(hkFav);
        return 0;
    }
    RegCloseKey(hkFav);

    // write info about Regular Channels

    LoadString( g_hInst, IDS_CHANNELSDIR, szChannelsDir, ARRAYSIZE(szChannelsDir) );
    PathCombine(szTemp, szChanPath, szChannelsDir);

     // The following scenario would arise if you don't upgrade IE5 over IE4 and
    // add a channel.  In this case, IE5 would add the channel under the
    // Favorites folder itself (szChanPath contains the path to the Favorites
    // folder)

    if (!PathFileExists(szTemp))
        StrCpy(szTemp, szChanPath);

    enumChannels(hDlg, szTemp, TEXT(""), &nChannels);

    return nChannels;
}

static void channels_InitHelper(HWND hDlg, LPCTSTR pcszAltDir, LPCTSTR pcszWorkDir, LPCTSTR pcszCustIns,
                                WORD idList, DWORD dwPlatformId, BOOL fIgnoreOffline)
{
    TCHAR    szTempBuf[16];
    PCHANNEL paChannels;
    PCHANNEL paOldChannels;
    int      i;

    ASSERT(((pcszAltDir == NULL) && (pcszWorkDir == NULL)) || 
        ((pcszAltDir != NULL) && (pcszWorkDir != NULL)));

    g_dwPlatformId = dwPlatformId;

    SendDlgItemMessage(hDlg, idList, LB_RESETCONTENT, 0, 0);

    if ((paChannels = (PCHANNEL)CoTaskMemAlloc(sizeof(CHANNEL) * MAX_CHAN)) == NULL)
        return;

    ZeroMemory(paChannels, sizeof(CHANNEL) * MAX_CHAN);
    paOldChannels = (PCHANNEL)SetWindowLongPtr(GetDlgItem(hDlg, idList), GWLP_USERDATA, (LONG_PTR)paChannels);
    
    // delete previous allocation(mainly for profile manager)
    if (paOldChannels != NULL)
        CoTaskMemFree(paOldChannels);

    if (GetPrivateProfileSection(CHANNEL_ADD, szTempBuf, ARRAYSIZE(szTempBuf), pcszCustIns))
    {
        PCHANNEL pChan;
        TCHAR    szChTitleParm[16],
                 szChUrlParm[16],
                 szChPreUrlParm[32],
                 szChIconParm[32],
                 szChBmpParm[32],
                 szChOfflineParm[16];
        int      j;

        if (StrCmpI(szTempBuf, TEXT("No Channels")) == 0)
            return;

        for (i = 0, pChan = paChannels; i < MAX_CHAN; i++, pChan++)
        {
            wnsprintf(szChUrlParm, ARRAYSIZE(szChUrlParm),   TEXT("%s%u"),  CDFURL,  i);
            wnsprintf(szChTitleParm, ARRAYSIZE(szChTitleParm), TEXT("%s%u"),  CHTITLE, i);

            if (GetPrivateProfileString(CHANNEL_ADD, szChTitleParm, TEXT(""), pChan->szTitle, ARRAYSIZE(pChan->szTitle), pcszCustIns) == 0)
                break;

            GetPrivateProfileString(CHANNEL_ADD, szChUrlParm, TEXT(""), pChan->szWebUrl, ARRAYSIZE(pChan->szWebUrl), pcszCustIns);

            wnsprintf(szChPreUrlParm, ARRAYSIZE(szChPreUrlParm), TEXT("%s%u"), CHPREURLPATH, i);
            wnsprintf(szChIconParm, ARRAYSIZE(szChIconParm),   TEXT("%s%u"), CHICON,       i);
            wnsprintf(szChBmpParm, ARRAYSIZE(szChBmpParm),    TEXT("%s%u"), CHBMP,        i);

            GetPrivateProfileString(CHANNEL_ADD, szChPreUrlParm, TEXT(""), pChan->szPreUrlPath, ARRAYSIZE(pChan->szPreUrlPath), pcszCustIns);
            GetPrivateProfileString(CHANNEL_ADD, szChIconParm,TEXT(""), pChan->szIcon, ARRAYSIZE(pChan->szIcon), pcszCustIns);
            GetPrivateProfileString(CHANNEL_ADD, szChBmpParm, TEXT(""), pChan->szLogo, ARRAYSIZE(pChan->szLogo), pcszCustIns);

            pChan->fOffline = FALSE;
            if (!fIgnoreOffline) {
                wnsprintf(szChOfflineParm, ARRAYSIZE(szChOfflineParm), TEXT("%s%u"), IK_CHL_OFFLINE, i);
                pChan->fOffline = (BOOL)GetPrivateProfileInt(IS_CHANNEL_ADD, szChOfflineParm, (int)FALSE, pcszCustIns);
            }

            // delete the files from an alternative dir (desktop dir in profmgr, ieaklite dir
            // in wizard), making sure to copy them to the work dir first 

            if (pcszAltDir != NULL)
            {
                MoveFileToWorkDir(PathFindFileName(pChan->szPreUrlPath), pcszAltDir, pcszWorkDir, TRUE);
                MoveFileToWorkDir(PathFindFileName(pChan->szIcon), pcszAltDir, pcszWorkDir);
                MoveFileToWorkDir(PathFindFileName(pChan->szLogo), pcszAltDir, pcszWorkDir);
            }

            j = (int)SendDlgItemMessage( hDlg, idList, LB_ADDSTRING, 0, (LPARAM) pChan->szTitle);
            SendDlgItemMessage(hDlg, idList, LB_SETITEMDATA, (WPARAM)j, (LPARAM)pChan);
        }

        for (i = 0; i < MAX_CHAN; i++, pChan++)
        {
            wnsprintf(szChTitleParm, ARRAYSIZE(szChTitleParm), TEXT("%s%u"), CATTITLE, i);

            if (GetPrivateProfileString(CHANNEL_ADD, szChTitleParm, TEXT(""), pChan->szTitle, ARRAYSIZE(pChan->szTitle), pcszCustIns) == 0)
                break;

            pChan->fCategory = TRUE;
            wnsprintf(szChUrlParm, ARRAYSIZE(szChUrlParm),  TEXT("%s%u"), CATHTML, i);
            wnsprintf(szChIconParm, ARRAYSIZE(szChIconParm), TEXT("%s%u"), CATICON, i);
            wnsprintf(szChBmpParm, ARRAYSIZE(szChBmpParm),  TEXT("%s%u"), CATBMP,  i);

            GetPrivateProfileString(CHANNEL_ADD, szChUrlParm, TEXT(""), pChan->szWebUrl, ARRAYSIZE(pChan->szWebUrl), pcszCustIns);
            GetPrivateProfileString(CHANNEL_ADD, szChIconParm, TEXT(""), pChan->szIcon, ARRAYSIZE(pChan->szIcon), pcszCustIns);
            GetPrivateProfileString(CHANNEL_ADD, szChBmpParm, TEXT(""), pChan->szLogo, ARRAYSIZE(pChan->szLogo), pcszCustIns);
            pChan->fOffline = FALSE;

            // delete the files from the desktop dir
            if (pcszAltDir != NULL)
            {
                MoveFileToWorkDir(PathFindFileName(pChan->szWebUrl), pcszAltDir, pcszWorkDir, TRUE);
                MoveFileToWorkDir(PathFindFileName(pChan->szIcon), pcszAltDir, pcszWorkDir, TRUE);
                MoveFileToWorkDir(PathFindFileName(pChan->szLogo), pcszAltDir, pcszWorkDir, TRUE);
            }

            j = (int)SendDlgItemMessage( hDlg, idList, LB_ADDSTRING, 0, (LPARAM) pChan->szTitle);
            SendDlgItemMessage(hDlg, idList, LB_SETITEMDATA, (WPARAM)j, (LPARAM)pChan);
        }
    }

    SendDlgItemMessage(hDlg, idList, LB_SETCURSEL, (WPARAM)-1, 0);
}

static void writeIE4Info(HANDLE hInf, int index, PCHANNEL pChan)
{
    static const TCHAR c_szInfTitle[]      = TEXT("HKCU,\"%s\",\"Title\",,\"%s\"\r\n");
    static const TCHAR c_szInfURL_File[]   = TEXT("HKCU,\"%s\",\"URL\",,\"%s%%10%%\\web\\%s\"\r\n");
    static const TCHAR c_szInfURL_HTTP[]   = TEXT("HKCU,\"%s\",\"URL\",,\"%s\"\r\n");
    static const TCHAR c_szInfPreloadUrl[] = TEXT("HKCU,\"%s\",\"PreloadURL\",,\"%s%%10%%\\web\\%s\"\r\n");
    static const TCHAR c_szInfLogo_File[]  = TEXT("HKCU,\"%s\",\"Logo\",,\"%s%%10%%\\web\\%s\"\r\n");
    static const TCHAR c_szInfLogo_HTTP[]  = TEXT("HKCU,\"%s\",\"Logo\",,\"%s\"\r\n");
    static const TCHAR c_szInfIcon_File[]  = TEXT("HKCU,\"%s\",\"Icon\",,\"%s%%10%%\\web\\%s\"\r\n");
    static const TCHAR c_szInfIcon_HTTP[]  = TEXT("HKCU,\"%s\",\"Icon\",,\"%s\"\r\n");
    static const TCHAR c_szInfCategory[]   = TEXT("HKCU,\"%s\",\"Category\",65537,1\r\n");

    TCHAR szKey[MAX_PATH];
    TCHAR szInfLine[MAX_PATH];
    TCHAR szFileUrlPrefix[ARRAYSIZE(FILEPREFIX)] = TEXT("");
    DWORD dwSize;

    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%%ChannelKey%%\\ieakChl%u"), index);

    dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfTitle, szKey, pChan->szTitle);
    WriteStringToFile(hInf, szInfLine, dwSize);

    if (pChan->fCategory)
    {
        dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfCategory, szKey);
        WriteStringToFile(hInf, szInfLine, dwSize);
    }
    else
        StrCpy(szFileUrlPrefix, FILEPREFIX);

    // BUGBUG: (pritobla) For a category, szWebUrl can be empty; we should take care of this case
    if (PathIsFileOrFileURL(pChan->szWebUrl))
        dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfURL_File, szKey, szFileUrlPrefix, PathFindFileName(pChan->szWebUrl));
    else
        dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfURL_HTTP, szKey, pChan->szWebUrl);
    WriteStringToFile(hInf, szInfLine, dwSize);

    if (ISNONNULL(pChan->szPreUrlPath))
    {
        dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfPreloadUrl, szKey, szFileUrlPrefix, PathFindFileName(pChan->szPreUrlPath));
        WriteStringToFile(hInf, szInfLine, dwSize);
    }

    if (ISNONNULL(pChan->szLogo))
    {
        if (PathIsFileOrFileURL(pChan->szLogo))
            dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfLogo_File, szKey, szFileUrlPrefix, PathFindFileName(pChan->szLogo));
        else
            dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfLogo_HTTP, szKey, pChan->szLogo);
        WriteStringToFile(hInf, szInfLine, dwSize);
    }

    if (ISNONNULL(pChan->szIcon))
    {
        if (PathIsFileOrFileURL(pChan->szIcon))
            dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfIcon_File, szKey, szFileUrlPrefix, PathFindFileName(pChan->szIcon));
        else
            dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfIcon_HTTP, szKey, pChan->szIcon);
        WriteStringToFile(hInf, szInfLine, dwSize);
    }
}

// The ie4chnls.inf is not made as a template inf file because in the GPE context the
// template inf's will not be available.
static TCHAR szIE4Buf[] = TEXT("[Version]\r\n\
Signature=\"$CHICAGO$\"\r\n\
AdvancedINF=2.5\r\n\r\n\
[DefaultInstall]\r\n\
RequiredEngine=Setupapi,\"Couldn't find Setupapi.dll\"\r\n\
Delreg=IeakChan.DelReg\r\n\
Addreg=IeakChan.AddReg\r\n\
RegisterOCXs=IeakChan.Register\r\n\
DoShellRefresh=1\r\n\r\n\
[IeakChan.Register]\r\n\
%11%\\webcheck.dll,IN,Policy\r\n\r\n\
[IeakChan.DelReg]\r\n\
HKCU,\"Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\CompletedModifications\",\"ChannelDefault\",,,\r\n\r\n\
[Strings]\r\n\
DiskName=\"Channel Files\"\r\n\
ChannelKey=\"Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Modifications\\ChannelDefault\\AddChannels\"\r\n\
SubKey=\"Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Modifications\\ChannelDefault\\AddSubscriptions\"\r\n\
CleanKey=\"Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Modifications\\ChannelDefault\\RemoveAllChannels\"\r\n\r\n\0");

static void channels_SaveHelper(HWND hwndList, LPCTSTR pcszChanDir, LPCTSTR pcszCustIns, DWORD dwMode)
{
    PCHANNEL pChan;
    PCHANNEL paChannel;
    TCHAR    szIE4ChnlsInf[MAX_PATH],
             szChTitleParm[32],
             szChUrlParm[32],
             szChPreUrlParm[32],
             szChBmpParm[32],
             szChIconParm[32],
             szChPreUrlNameParm[32],
             szChBmpNameParm[32],
             szChOfflineParm[16],
             szChIconNameParm[32],
             szTempPath[MAX_PATH];
    LPTSTR   pWrk;
    HANDLE   hInf = NULL;
    DWORD    dwSize;
    int      i, j, k;
    BOOL     fChan = FALSE;
    GUID     guid;
    TCHAR    szChlSizeLine[MAX_PATH],
             szOemSizeLine[MAX_PATH];
    TCHAR    szChlSize[5];
    TCHAR    szOemSize[5];
    BYTE     bData;
    LPTSTR   pszBuf;
    HKEY     hk;

    // create a temp path to copy all files to temporarily

    GetTempPath(countof(szTempPath), szTempPath);
    if (CoCreateGuid(&guid) == NOERROR)
    {
        TCHAR szGUID[128];

        CoStringFromGUID(guid, szGUID, countof(szGUID));
        PathAppend(szTempPath, szGUID);
    }
    else
        PathAppend(szTempPath, TEXT("IEAKCHAN"));

    PathCreatePath(szTempPath);

    WritePrivateProfileString(CHANNEL_ADD, NULL, NULL, pcszCustIns);
    WritePrivateProfileString(NULL, NULL, NULL, pcszCustIns);

    PathCombine(szIE4ChnlsInf, szTempPath, TEXT("ie4chnls.inf"));

    //----- Prepare Channel Size and OEM Size -----
    StrCpy(szChlSize, TEXT("0x0B"));
    StrCpy(szOemSize, TEXT("0x00"));
    if (RegOpenKeyEx(HKEY_CURRENT_USER, DESKTOPKEY, 0, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS) {
        dwSize = sizeof(bData);
        if (RegQueryValueEx(hk, CHANNELSIZE, NULL, NULL, &bData, &dwSize) == ERROR_SUCCESS) {
            szChlSize[2] = TEXT('\0');
            AppendCommaHex(szChlSize, bData, 0);
        }

        dwSize = sizeof(bData);
        if (RegQueryValueEx(hk, OEMSIZE, NULL, NULL, &bData, &dwSize) == ERROR_SUCCESS) {
            szOemSize[2] = TEXT('\0');
            AppendCommaHex(szOemSize, bData, 0);
        }
        RegCloseKey(hk);
    }
    wnsprintf(szChlSizeLine, ARRAYSIZE(szChlSizeLine), REG_KEY_CHAN_SIZE, szChlSize);
    wnsprintf(szOemSizeLine, ARRAYSIZE(szOemSizeLine), REG_KEY_OEM_SIZE,  szOemSize);

    //----- Write the standard goo ---
    pszBuf = (LPTSTR)LocalAlloc(LPTR, INF_BUF_SIZE*sizeof(TCHAR));
    if (pszBuf == NULL)
        return;

    dwSize = wnsprintf(pszBuf, INF_BUF_SIZE, TEXT("\r\n[%s]\r\n%s\r\n%s\r\n\r\n"), IEAKCHANADDREG, szChlSizeLine, szOemSizeLine);

    hInf = CreateFile(szIE4ChnlsInf, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, NULL, NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        LocalFree(pszBuf);
        return;
    }

    SetFilePointer(hInf, 0, NULL, FILE_BEGIN);
    WriteStringToFile(hInf, szIE4Buf, ARRAYSIZE(szIE4Buf));
    SetFilePointer(hInf, 0, NULL, FILE_END);
    WriteStringToFile(hInf, pszBuf, dwSize);
    LocalFree(pszBuf);

    paChannel = (PCHANNEL)GetWindowLongPtr(hwndList, GWLP_USERDATA);

    for (i = 0, j = 0, k = 0, pChan = paChannel; (i < MAX_CHAN) && (pChan != NULL); i++, pChan++)
    {
        if (ISNULL(pChan->szTitle))
            continue;

        if (!pChan->fCategory)
        {
            fChan = TRUE;
            wnsprintf(szChTitleParm, ARRAYSIZE(szChTitleParm), TEXT("%s%u"),  CHTITLE, j);
            wnsprintf(szChUrlParm, ARRAYSIZE(szChUrlParm),   TEXT("%s%u"),  CDFURL,  j);

            WritePrivateProfileString(CHANNEL_ADD, szChTitleParm, pChan->szTitle, pcszCustIns);
            WritePrivateProfileString(CHANNEL_ADD, szChUrlParm,   pChan->szWebUrl, pcszCustIns);

            writeIE4Info(hInf, i, pChan);

            wnsprintf(szChPreUrlParm, ARRAYSIZE(szChPreUrlParm), TEXT("%s%u"), CHPREURLPATH, j);
            wnsprintf(szChIconParm, ARRAYSIZE(szChIconParm), TEXT("%s%u"), CHICON, j);
            wnsprintf(szChBmpParm, ARRAYSIZE(szChBmpParm), TEXT("%s%u"), CHBMP, j);
            wnsprintf(szChPreUrlNameParm, ARRAYSIZE(szChPreUrlNameParm), TEXT("%s%u"), CHPREURLNAME, j);
            wnsprintf(szChIconNameParm, ARRAYSIZE(szChIconNameParm), TEXT("%s%u"), CHICONNAME, j);
            wnsprintf(szChBmpNameParm, ARRAYSIZE(szChBmpNameParm), TEXT("%s%u"), CHBMPNAME, j);
            wnsprintf(szChOfflineParm, ARRAYSIZE(szChOfflineParm), TEXT("%s%u"), IK_CHL_OFFLINE, j);

            WritePrivateProfileString(CHANNEL_ADD, szChPreUrlParm, pChan->szPreUrlPath, pcszCustIns);
            pWrk = StrRChr(pChan->szPreUrlPath, NULL, TEXT('\\'));
            if (pWrk != NULL)
            {
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChPreUrlNameParm, pWrk, pcszCustIns );

                if (PathFileExists(pChan->szPreUrlPath))
                {
                    CopyFileToDir(pChan->szPreUrlPath, szTempPath);
                    CopyHtmlImgs(pChan->szPreUrlPath, szTempPath, NULL, NULL);
                }
                else
                {
                   TCHAR szFile[MAX_PATH];

                   PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szPreUrlPath));
                   CopyFileToDir(szFile, szTempPath);
                   CopyHtmlImgs(szFile, szTempPath, NULL, NULL);
                }
            }

            WritePrivateProfileString(CHANNEL_ADD, szChIconParm, pChan->szIcon, pcszCustIns);
            pWrk = StrRChr(pChan->szIcon, NULL, TEXT('\\'));
            if (pWrk != NULL)
            {
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChIconNameParm, pWrk, pcszCustIns );
                if (PathFileExists(pChan->szIcon))
                    CopyFileToDir(pChan->szIcon, szTempPath);
                else
                {
                   TCHAR szFile[MAX_PATH];

                   PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szIcon));
                   CopyFileToDir(szFile, szTempPath);
                }
            }

            WritePrivateProfileString(CHANNEL_ADD, szChBmpParm, pChan->szLogo, pcszCustIns);
            pWrk = StrRChr(pChan->szLogo, NULL, TEXT('\\'));
            if (pWrk)
            {
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChBmpNameParm, pWrk, pcszCustIns );
                
                if (PathFileExists(pChan->szLogo))
                    CopyFileToDir(pChan->szLogo, szTempPath);
                else
                {
                   TCHAR szFile[MAX_PATH];

                   PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szLogo));
                   CopyFileToDir(szFile, szTempPath);
                }
            }

            if (pChan->fOffline)
                // NOTE: (andrewgu) no need to write NULL on FALSE as the whole section was
                // wiped out up above.
                WritePrivateProfileString(IS_CHANNEL_ADD, szChOfflineParm, TEXT("1"), pcszCustIns);
            
            j++;
        }
        else
        {
            fChan = TRUE;
            wnsprintf(szChTitleParm, ARRAYSIZE(szChTitleParm), TEXT("%s%u"), CATTITLE, k);
            WritePrivateProfileString(CHANNEL_ADD, szChTitleParm, pChan->szTitle, pcszCustIns);

            writeIE4Info(hInf, i, pChan);

            wnsprintf(szChPreUrlParm, ARRAYSIZE(szChPreUrlParm), TEXT("%s%u"), CATHTML, k);
            wnsprintf(szChIconParm, ARRAYSIZE(szChIconParm), TEXT("%s%u"), CATICON, k);
            wnsprintf(szChBmpParm, ARRAYSIZE(szChBmpParm), TEXT("%s%u"), CATBMP, k);
            wnsprintf(szChPreUrlNameParm, ARRAYSIZE(szChPreUrlNameParm), TEXT("%s%u"), CATHTMLNAME, k);
            wnsprintf(szChIconNameParm, ARRAYSIZE(szChIconNameParm), TEXT("%s%u"), CATICONNAME, k);
            wnsprintf(szChBmpNameParm, ARRAYSIZE(szChBmpNameParm), TEXT("%s%u"), CATBMPNAME, k);

            WritePrivateProfileString(CHANNEL_ADD, szChPreUrlParm, pChan->szWebUrl, pcszCustIns);
            pWrk = StrRChr(pChan->szWebUrl, NULL, TEXT('\\'));
            if (pWrk != NULL)         // make sure we're not copying over the file as hidden/system
            {
                DWORD dwFileAttrib;

                dwFileAttrib = GetFileAttributes(pChan->szWebUrl);
                SetFileAttributes(pChan->szWebUrl, FILE_ATTRIBUTE_NORMAL);
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChPreUrlNameParm, pWrk, pcszCustIns );
                if (PathFileExists(pChan->szWebUrl))
                    CopyFileToDir(pChan->szWebUrl, szTempPath);
                else
                {
                    TCHAR szFile[MAX_PATH];
                    
                    PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szWebUrl));
                    CopyFileToDir(szFile, szTempPath);
                }
                SetFileAttributes(pChan->szWebUrl, dwFileAttrib);
            }

            WritePrivateProfileString(CHANNEL_ADD, szChIconParm, pChan->szIcon, pcszCustIns);
            pWrk = StrRChr(pChan->szIcon, NULL, TEXT('\\'));
            if (pWrk != NULL)
            {
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChIconNameParm, pWrk, pcszCustIns );
                if (PathFileExists(pChan->szIcon))
                    CopyFileToDir(pChan->szIcon, szTempPath);
                else
                {
                    TCHAR szFile[MAX_PATH];
                    
                    PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szIcon));
                    CopyFileToDir(szFile, szTempPath);
                }
            }

            WritePrivateProfileString(CHANNEL_ADD, szChBmpParm, pChan->szLogo, pcszCustIns);
            pWrk = StrRChr(pChan->szLogo, NULL, TEXT('\\'));
            if (pWrk != NULL)
            {
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChBmpNameParm, pWrk, pcszCustIns );
                if (PathFileExists(pChan->szLogo))
                    CopyFileToDir(pChan->szLogo, szTempPath);
                else
                {
                    TCHAR szFile[MAX_PATH];
                    
                    PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szLogo));
                    CopyFileToDir(szFile, szTempPath);
                }
            }

            k++;
        }
    }

    PathRemovePath(pcszChanDir);
        
    if (!fChan)
        WritePrivateProfileSection(CHANNEL_ADD, TEXT("No Channels\0"), pcszCustIns);
    else
    {
        // copy over all the files from the temp dir back to the working dir
        PathCreatePath(pcszChanDir);
        CopyFileToDir(szTempPath, pcszChanDir);
    }

    WritePrivateProfileString(NULL, NULL, NULL, pcszCustIns);

    CloseHandle(hInf);

    if (fChan)
    {
        TCHAR szBuf[MAX_PATH];

        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("*,ie4chnls.inf,%s"), DEFAULT_INSTALL);
        WritePrivateProfileString(EXTREGINF, TEXT("channels"), szBuf, pcszCustIns);
    }
    else
    {
        WritePrivateProfileString(EXTREGINF, TEXT("channels"), NULL, pcszCustIns);
        DeleteFile(szIE4ChnlsInf);
    }

    PathRemovePath(szTempPath);

    // do not free for profile manager since we might still be on the page due to file save
    if (!HasFlag(dwMode, IEM_PROFMGR) && (paChannel != NULL))
    {
        CoTaskMemFree(paChannel);
        SetWindowLong(hwndList, GWLP_USERDATA, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\dlgprocs.cpp ===
#include "precomp.h"

static void testURLHelper(LPCTSTR pcszUrl);
static void setProxyDlgHelper(HWND hDlg, LPCTSTR pcszProxy, DWORD dwIdName, DWORD dwIdPort,
                              BOOL fDef80);
static void getProxyDlgHelper(HWND hDlg, LPTSTR pszProxy, DWORD dwIdName, DWORD dwIdPort);
static void showBitmapHelper(HWND hControl, LPCTSTR pcszFileName, int nBitmapId, PHANDLE pBitmap);
static BOOL copyAnimBmpHelper(HWND hDlg, LPTSTR pszBmp, LPCTSTR pcszWorkDir,
                              LPCTSTR pcszNameStr, LPCTSTR pcszPathStr, LPCTSTR pcszInsFile);
static BOOL copyLogoBmpHelper(HWND hDlg, LPTSTR pszBmp, LPCTSTR pcszLogoStr,
                              LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile);
static BOOL copyWallPaperHelper(HWND hDlg, LPCTSTR pcszWallPaper, UINT nBitmapId,
                                LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile, BOOL fCopy);

void WINAPI TestURLA(LPCSTR pcszUrl)
{
    USES_CONVERSION;

    testURLHelper(A2CT(pcszUrl));
}

void WINAPI TestURLW(LPCWSTR pcwszUrl)
{
    USES_CONVERSION;

    testURLHelper(W2CT(pcwszUrl));
}

void WINAPI SetProxyDlgA(HWND hDlg, LPCSTR pcszProxy, DWORD dwIdName, DWORD dwIdPort, BOOL fDef80)
{
    USES_CONVERSION;

    setProxyDlgHelper(hDlg, A2CT(pcszProxy), dwIdName, dwIdPort, fDef80);
}

void WINAPI SetProxyDlgW(HWND hDlg, LPCWSTR pcwszProxy, DWORD dwIdName, DWORD dwIdPort, BOOL fDef80)
{
    USES_CONVERSION;

    setProxyDlgHelper(hDlg, W2CT(pcwszProxy), dwIdName, dwIdPort, fDef80);
}

void WINAPI GetProxyDlgA(HWND hDlg, LPSTR pszProxy, DWORD dwIdName, DWORD dwIdPort)
{
    TCHAR szProxyBuf[MAX_PATH];

    USES_CONVERSION;

    getProxyDlgHelper(hDlg, szProxyBuf, dwIdName, dwIdPort);
    T2Abux(szProxyBuf, pszProxy);
}

void WINAPI GetProxyDlgW(HWND hDlg, LPWSTR pwszProxy, DWORD dwIdName, DWORD dwIdPort)
{
    TCHAR szProxyBuf[MAX_PATH];

    USES_CONVERSION;

    getProxyDlgHelper(hDlg, szProxyBuf, dwIdName, dwIdPort);
    T2Wbux(szProxyBuf, pwszProxy);
}

HPALETTE WINAPI BuildPalette(HDC hdc)
{
    DWORD adw[257];
    int i,n;

    n = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)&adw[1]);

    for(i = 1; i < n; i++)
    {
        adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i]));
    }
    adw[0] = MAKELONG(0x300, n);

    return CreatePalette((LPLOGPALETTE)&adw[0]);
}

void WINAPI ShowBitmapA(HWND hControl, LPCSTR pcszFileName, int nBitmapId, PHANDLE pBitmap)
{
    USES_CONVERSION;

    showBitmapHelper(hControl, A2CT(pcszFileName), nBitmapId, pBitmap);
}

void WINAPI ShowBitmapW(HWND hControl, LPCWSTR pcwszFileName, int nBitmapId, PHANDLE pBitmap)
{
    USES_CONVERSION;

    showBitmapHelper(hControl, W2CT(pcwszFileName), nBitmapId, pBitmap);
}

BOOL WINAPI CopyAnimBmpA(HWND hDlg, LPSTR pszBmp, LPCSTR pcszWorkDir, LPCSTR pcszNameStr,
                         LPCSTR pcszPathStr, LPCSTR pcszInsFile)
{
    TCHAR szBmpBuf[MAX_PATH];
    BOOL fRet;

    USES_CONVERSION;

    A2Tbux(pszBmp, szBmpBuf);
    fRet = copyAnimBmpHelper(hDlg, szBmpBuf, A2CT(pcszWorkDir), A2CT(pcszNameStr), 
        A2CT(pcszPathStr), A2CT(pcszInsFile));
    T2Abux(szBmpBuf, pszBmp);

    return fRet;
}

BOOL WINAPI CopyAnimBmpW(HWND hDlg, LPWSTR pwszBmp, LPCWSTR pcwszWorkDir, LPCWSTR pcwszNameStr,
                         LPCWSTR pcwszPathStr, LPCWSTR pcwszInsFile)
{
    TCHAR szBmpBuf[MAX_PATH];
    BOOL fRet;

    USES_CONVERSION;

    W2Tbux(pwszBmp, szBmpBuf);
    fRet = copyAnimBmpHelper(hDlg, szBmpBuf, W2CT(pcwszWorkDir), W2CT(pcwszNameStr),
        W2CT(pcwszPathStr), W2CT(pcwszInsFile));
    T2Wbux(szBmpBuf, pwszBmp);

    return fRet;
}

BOOL WINAPI CopyLogoBmpA(HWND hDlg, LPSTR pszBmp, LPCSTR pcszLogoStr,
                         LPCSTR pcszWorkDir, LPCSTR pcszInsFile)
{
    TCHAR szBmpBuf[MAX_PATH];
    BOOL fRet;

    USES_CONVERSION;

    A2Tbux(pszBmp, szBmpBuf);
    fRet = copyLogoBmpHelper(hDlg, szBmpBuf, A2CT(pcszLogoStr), A2CT(pcszWorkDir),
        A2CT(pcszInsFile));
    T2Abux(szBmpBuf, pszBmp);

    return fRet;
}

BOOL WINAPI CopyLogoBmpW(HWND hDlg, LPWSTR pwszBmp, LPCWSTR pcwszLogoStr,
                         LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile)
{
    TCHAR szBmpBuf[MAX_PATH];
    BOOL fRet;

    USES_CONVERSION;

    W2Tbux(pwszBmp, szBmpBuf);
    fRet = copyLogoBmpHelper(hDlg, szBmpBuf, W2CT(pcwszLogoStr), W2CT(pcwszWorkDir),
        W2CT(pcwszInsFile));
    T2Wbux(szBmpBuf, pwszBmp);

    return fRet;
}

BOOL WINAPI CopyWallPaperA(HWND hDlg, LPCSTR pcszWallPaper, UINT nBitmapId,
                           LPCSTR pcszWorkDir, LPCSTR pcszInsFile, BOOL fCopy)
{
    USES_CONVERSION;

    return copyWallPaperHelper(hDlg, A2CT(pcszWallPaper), nBitmapId, A2CT(pcszWorkDir),
        A2CT(pcszInsFile), fCopy);
}

BOOL WINAPI CopyWallPaperW(HWND hDlg, LPCWSTR pcwszWallPaper, UINT nBitmapId,
                           LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile, BOOL fCopy)
{
    USES_CONVERSION;

    return copyWallPaperHelper(hDlg, W2CT(pcwszWallPaper), nBitmapId, W2CT(pcwszWorkDir),
        W2CT(pcwszInsFile), fCopy);
}

static void testURLHelper(LPCTSTR pcszUrl)
{
    TCHAR szCommand[MAX_PATH];
    DWORD cbSize;
    SHELLEXECUTEINFO shInfo;

    if(ISNULL(pcszUrl))
        return;

    // launch iexplore
    *szCommand = TEXT('\0');
    cbSize = sizeof(szCommand);
    SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE"),
                                    TEXT(""), NULL, (LPVOID) szCommand, &cbSize);

    ZeroMemory(&shInfo, sizeof(shInfo));
    shInfo.cbSize = sizeof(shInfo);
    shInfo.lpVerb = TEXT("open");
    if (*szCommand)
    {
        shInfo.lpFile = szCommand;
        shInfo.lpParameters = pcszUrl;
    }
    else
        shInfo.lpFile = pcszUrl;        // this will launch the program that's registered for "http"
    shInfo.nShow = SW_SHOWNORMAL;

    ShellExecuteEx(&shInfo);
}

static void setProxyDlgHelper(HWND hDlg, LPCTSTR pcszProxy, DWORD dwIdName, DWORD dwIdPort,
                              BOOL fDef80)
{
    TCHAR szProxName[MAX_PATH];
    LPTSTR pProxPort;

    StrCpy(szProxName, pcszProxy);
    pProxPort = StrRChr(szProxName, NULL, TEXT(':'));
    if(pProxPort && isdigit(*(pProxPort + 1)))
    {
        *pProxPort = TEXT('\0');
        pProxPort++;
    }
    else if(fDef80) pProxPort = TEXT("80");
    else pProxPort = TEXT("");
    SetDlgItemText(hDlg, dwIdName, szProxName);
    SetDlgItemText(hDlg, dwIdPort, pProxPort);
}

static void getProxyDlgHelper(HWND hDlg, LPTSTR pszProxy, DWORD dwIdName, DWORD dwIdPort)
{
    TCHAR szProxPort[16];
    LPTSTR pProxPort;
    BOOL fPortinprox = FALSE;

    GetDlgItemText(hDlg, dwIdName, pszProxy, MAX_PATH - 10);
    
    // this number needs to say in synch with the em_limittext's in the dlgproc's in 
    // wizard and snapin

    GetDlgItemText(hDlg, dwIdPort, szProxPort, 6);
    pProxPort = StrRChr(pszProxy, NULL, TEXT(':'));
    if (pProxPort && isdigit(*(pProxPort + 1))) fPortinprox = TRUE;
    if (!fPortinprox && StrLen(szProxPort) && StrLen(pszProxy))
    {
        StrCat(pszProxy, TEXT(":"));
        StrCat(pszProxy, szProxPort);
    }
}

static void showBitmapHelper(HWND hControl, LPCTSTR pcszFileName, int nBitmapId, PHANDLE pBitmap)
{
    BITMAP bmImage;
    HANDLE hImage = NULL;
    static HPALETTE hPalette = 0;
    HDC hDCMain;
    HDC hDCBitmap;
    RECT rect;

    if(hControl == NULL)
    {
        if(hPalette)
        {
            DeleteObject(hPalette);
            hPalette = 0;
        }
        return;
    }

    if(PathFileExists(pcszFileName) || nBitmapId)
    {
        if(nBitmapId)
        {
            hImage = LoadImage(g_hInst, MAKEINTRESOURCE(nBitmapId), IMAGE_BITMAP, 0, 0,
                LR_CREATEDIBSECTION);
        }
        else
        {
            hImage = LoadImage(NULL, pcszFileName, IMAGE_BITMAP, 0, 0,
                LR_LOADFROMFILE | LR_CREATEDIBSECTION);
        }
        if(hImage)
        {
            if(*pBitmap)
            {
                DeleteObject(*pBitmap);
                *pBitmap = NULL;
            }
            *pBitmap = hImage;
        }
    }
    else
        hImage = *pBitmap;


    if(hImage)
    {
        GetObject(hImage, sizeof(bmImage), &bmImage);

        hDCMain = GetDC(hControl);
        hDCBitmap = CreateCompatibleDC(hDCMain);
        SelectObject(hDCBitmap, hImage);
        if(hPalette == 0)
            hPalette = BuildPalette(hDCBitmap);
        SelectPalette(hDCMain, hPalette, FALSE);
        RealizePalette(hDCMain);
        GetClientRect(hControl, &rect);
        BitBlt(hDCMain, 0, 0, rect.right, rect.bottom, hDCBitmap, 0, 0, SRCCOPY);

        DeleteDC(hDCBitmap);
        ReleaseDC(hControl, hDCMain);
    }
}

static BOOL copyAnimBmpHelper(HWND hDlg, LPTSTR pszBmp, LPCTSTR pcszWorkDir,
                              LPCTSTR pcszNameStr, LPCTSTR pcszPathStr, LPCTSTR pcszInsFile)
{
    TCHAR szTemp[MAX_PATH];
    BOOL fBrandBmps = (IsDlgButtonChecked(hDlg, IDC_ANIMBITMAP) == BST_CHECKED);

    // delete the old file in the working dir
    if (fBrandBmps && 
        InsGetString(IS_ANIMATION, pcszNameStr, szTemp, countof(szTemp), pcszInsFile) && 
        ISNONNULL(szTemp))
        DeleteFileInDir(PathFindFileName(szTemp), pcszWorkDir);

    if (fBrandBmps && ISNONNULL(pszBmp))
        CopyFileToDir(pszBmp, pcszWorkDir);

    InsWriteString(IS_ANIMATION, pcszNameStr, PathFindFileName(pszBmp), pcszInsFile, 
        fBrandBmps, NULL, INSIO_TRISTATE | INSIO_PATH);

    InsWriteString(IS_ANIMATION, pcszPathStr, pszBmp, pcszInsFile, 
        fBrandBmps, NULL, INSIO_TRISTATE | INSIO_PATH);

    return TRUE;
}

static BOOL copyLogoBmpHelper(HWND hDlg, LPTSTR pszBmp, LPCTSTR pcszLogoStr,
                              LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile)
{
    TCHAR szTemp[MAX_PATH];
    BOOL fBrandBmps = (IsDlgButtonChecked(hDlg, IDC_BITMAPCHECK) == BST_CHECKED);

    // delete the old bitmap in the working dir
    if (fBrandBmps && 
        InsGetString(pcszLogoStr, TEXT("Name"), szTemp, countof(szTemp), pcszInsFile) && 
        ISNONNULL(szTemp))
        DeleteFileInDir(PathFindFileName(szTemp), pcszWorkDir);

    if (fBrandBmps && ISNONNULL(pszBmp))
        CopyFileToDir(pszBmp, pcszWorkDir);

    InsWriteString(pcszLogoStr, TEXT("Name"), PathFindFileName(pszBmp), pcszInsFile, 
        fBrandBmps, NULL, INSIO_TRISTATE | INSIO_PATH);

    InsWriteString(pcszLogoStr, TEXT("Path"), pszBmp, pcszInsFile, 
        fBrandBmps, NULL, INSIO_TRISTATE | INSIO_PATH);

    return TRUE;
}

static BOOL copyWallPaperHelper(HWND hDlg, LPCTSTR pcszWallPaper, UINT nBitmapId,
                                LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile, BOOL fCopy)
{
    TCHAR szDest[MAX_PATH];

    USES_CONVERSION;

    //clear the old data from the section
    WritePrivateProfileString(CUSTWALLPPR, NULL, NULL, pcszInsFile);

    if(fCopy)
    {
        if (!CheckField(hDlg, nBitmapId, FC_FILE | FC_EXISTS))
            return FALSE;

        WritePrivateProfileString( DESKTOP_OBJ_SECT, WLPPRPATH, pcszWallPaper, pcszInsFile );

        //delete old files from the working dir
        PathRemovePath(pcszWorkDir);
        CreateDirectory(pcszWorkDir, NULL);

        //copy new files to the working dir
        if(ISNONNULL(pcszWallPaper))
        {
            WritePrivateProfileString( DESKTOP_OBJ_SECT, OPTION, TEXT("1"), pcszInsFile );
            CopyFileToDir(pcszWallPaper, pcszWorkDir);
            WritePrivateProfileString( CUSTWALLPPR, NUMFILES, TEXT("1"), pcszInsFile);
            WritePrivateProfileString( CUSTWALLPPR, TEXT("file0"), PathFindFileName(pcszWallPaper), pcszInsFile);

            if(StrCmp(PathFindExtension(pcszWallPaper), TEXT(".htm")) == 0)
                CopyHtmlImgs(pcszWallPaper, pcszWorkDir, CUSTWALLPPR, pcszInsFile);
        }
        else
            WritePrivateProfileString( DESKTOP_OBJ_SECT, OPTION, TEXT("0"), pcszInsFile );
    }
    else //delete
    {
        //delete old files from the desktop dir ( if the files were saved )
        PathCombine(szDest, pcszWorkDir, PathFindFileName(pcszWallPaper));
        if(PathFileExists(szDest))
        {
            if(StrCmp(PathFindExtension(szDest), TEXT(".htm")) == 0)
                DeleteHtmlImgs(pcszWallPaper, pcszWorkDir, NULL, NULL);
            DeleteFile(szDest);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\exports.h ===
//
// EXPORTS.H
//

#ifndef _EXPORTS_H
#define _EXPORTS_H

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "ieaksie.h"

// IEM_xxx stands for Ieak Engine Mode
#define IEM_NEUTRAL 0x00000000                  // agnostic
#define IEM_ICP     0x00000000                  // wizard - icp mode
#define IEM_ISP     0x00000000                  // wizard - isp mode
#define IEM_CORP    0x00000001                  // wizard - corp
#define IEM_PROFMGR 0x00000002                  // profmgr
#define IEM_GP      0x00000004                  // gp (snapin)
#define IEM_ADMIN   0x00000007


// prototype declarations

// desktop.cpp
BOOL WINAPI ImportADTInfoA(LPCSTR pcszInsFile, LPCSTR pcszDeskWorkDir, LPCSTR pcszDeskInf, BOOL fImportADT);
BOOL WINAPI ImportADTInfoW(LPCWSTR pcszInsFile, LPCWSTR pcszDeskWorkDir, LPCWSTR pcszDeskInf, BOOL fImportADT);
BOOL WINAPI ShowDeskCpl(VOID);

// toolbar.cpp
BOOL WINAPI ImportToolbarInfoA(LPCSTR pcszInsFile, LPCSTR pcszToolbarWorkDir, LPCSTR pcszToolbarInf, BOOL fImportToolbars);
BOOL WINAPI ImportToolbarInfoW(LPCWSTR pcwszInsFile, LPCWSTR pcwszToolbarWorkDir, LPCWSTR pcwszToolbarInf, BOOL fImportToolbars);

// mccphtt.cpp
BOOL WINAPI CopyHttFileA(LPCSTR pcszInsFile, LPCSTR pcszHttWorkDir, LPCSTR pcszHttFile, LPCSTR pcszHttKey);
BOOL WINAPI CopyHttFileW(LPCWSTR pcwszInsFile, LPCWSTR pcwszHttWorkDir, LPCWSTR pcwszHttFile, LPCWSTR pcwszHttKey);

// seccerts.cpp
BOOL WINAPI ImportSiteCertA(LPCSTR pcszInsFile, LPCSTR pcszSCWorkDir, LPCSTR pcszSCInf, BOOL fImportSC);
BOOL WINAPI ImportSiteCertW(LPCWSTR pcwszInsFile, LPCWSTR pcwszSCWorkDir, LPCWSTR pcwszSCInf, BOOL fImportSC);
BOOL WINAPI ModifySiteCert(HWND hDlg);
BOOL WINAPI ImportAuthCodeA(LPCSTR pcszInsFile, LPCSTR pcszAuthWorkDir, LPCSTR pcszAuthInf, BOOL fImportAuth);
BOOL WINAPI ImportAuthCodeW(LPCWSTR pcwszInsFile, LPCWSTR pcwszAuthWorkDir, LPCWSTR pcwszAuthInf, BOOL fImportAuth);
BOOL WINAPI ModifyAuthCode(HWND hDlg);

// seczones.cpp
BOOL WINAPI ImportZonesA(LPCSTR pcszInsFile, LPCSTR pcszZonesWorkDir, LPCSTR pcszZonesInf, BOOL fImportZones);
BOOL WINAPI ImportZonesW(LPCWSTR pcwszInsFile, LPCWSTR pcwszZonesWorkDir, LPCWSTR pcwszZonesInf, BOOL fImportZones);
BOOL WINAPI ModifyZones(HWND hDlg);
BOOL WINAPI ImportRatingsA(LPCSTR pcszInsFile, LPCSTR pcszRatingsWorkDir, LPCSTR pcszRatingsInf, BOOL fImportRatings);
BOOL WINAPI ImportRatingsW(LPCWSTR pcwszInsFile, LPCWSTR pcwszRatingsWorkDir, LPCWSTR pcwszRatingsInf, BOOL fImportRatings);
BOOL WINAPI ModifyRatings(HWND hDlg);

// oe.cpp
BOOL WINAPI ImportLDAPBitmapA(LPCSTR pcszIns, LPCSTR pcszWorkDir, BOOL fImport);
BOOL WINAPI ImportLDAPBitmapW(LPCWSTR pcwszIns, LPCWSTR pcwszWorkDir, BOOL fImport);
BOOL WINAPI ImportOEInfoA(LPCSTR pcszIns, LPCSTR pcszWorkDir, BOOL fImport);
BOOL WINAPI ImportOEInfoW(LPCWSTR pcwszIns, LPCWSTR pcwszWorkDir, BOOL fImport);
BOOL WINAPI EncodeSignatureA(LPCSTR pcszFrom, LPSTR pszTo, BOOL fEncode);
BOOL WINAPI EncodeSignatureW(LPCWSTR pcwszFrom, LPWSTR pwszTo, BOOL fEncode);

// utils.cpp
#define FC_NONNULL      0x00000001
#define FC_URL          0x00000002
#define FC_NOSPACE      0x00000004
#define FC_NOCOLON      0x00000008
#define FC_PATH         0x00000010
#define FC_NOEXCHAR     0x00000020
#define FC_EXISTS       0x00000040
#define FC_FILE         (FC_PATH | 0x00000100)
#define FC_DIR          (FC_PATH | 0x00000200)
#define FC_NUMBER       0x00000080
BOOL WINAPI CheckField(HWND hDlg, int nIDDlgItem, DWORD dwFlags, LPARAM lParam = 0);

#define BMP_SMALLER     0x00000001   // bitmap file must have dimensions smaller than cx and cy
#define BMP_EXACT       0x00000002   // bitmap must be exact size specified

BOOL IsAnimBitmapFileValidA(HWND hDlg, UINT nID, LPSTR pszBuffer, PUINT pcch, UINT nIDTooBig,
                              UINT nIDTooSmall, long lBmpMinWidth, long lBmpMaxWidth);
BOOL IsAnimBitmapFileValidW(HWND hDlg, UINT nID, LPWSTR pszBuffer, PUINT pcch, UINT nIDTooBig,
                              UINT nIDTooSmall, long lBmpMinWidth, long lBmpMaxWidth);

BOOL WINAPI IsBitmapFileValidA(HWND hDlg, UINT nID, LPSTR pszBuffer, PUINT pcch, int cx,
                               int cy, UINT nIDTooBig, UINT nIDTooSmall, DWORD dwFlags = 0);
BOOL WINAPI IsBitmapFileValidW(HWND hDlg, UINT nID, LPWSTR pwszBuffer, PUINT pcch, int cx,
                               int cy, UINT nIDTooBig, UINT nIDTooSmall, DWORD dwFlags = 0);

BOOL WINAPI BrowseForFileA(HWND hDlg, LPSTR pszFileName, DWORD cchSize, DWORD dwFilterMasks,
                           LPCSTR pcszTitle = NULL);
BOOL WINAPI BrowseForFileW(HWND hDlg, LPWSTR pwszFileName, DWORD cchSize, DWORD dwFilterMasks,
                           LPCWSTR pcwszTitle = NULL);
BOOL WINAPI BrowseForFolderA(HWND hDlg, LPSTR pszFileName, LPCSTR pcszDesc = NULL);
BOOL WINAPI BrowseForFolderW(HWND hDlg, LPWSTR pwszFileName, LPCWSTR pcwszDesc = NULL);
void WINAPI ErrorMessageBox(HWND hWnd, UINT idErrorStr, DWORD dwFlags = 0);
void WINAPI ExportRegTree2InfA(HKEY hkSubKey, LPCSTR pcszRootKey, LPCSTR pcszSubKey,
                               HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI ExportRegTree2InfW(HKEY hkSubKey, LPCWSTR pcwszRootKey, LPCWSTR pcwszSubKey,
                               HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI ExportRegKey2InfA(HKEY hkSubKey, LPCSTR pcszRootKey, LPCSTR pcszSubKey,
                              HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI ExportRegKey2InfW(HKEY hkSubKey, LPCWSTR pcwszRootKey, LPCWSTR pcwszSubKey,
                              HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI ExportRegValue2InfA(HKEY hkSubKey, LPCSTR pcszValue, LPCSTR pcszRootKey,
                                LPCSTR pcszSubKey, HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI ExportRegValue2InfW(HKEY hkSubKey, LPCWSTR pcwszValue, LPCWSTR pcwszRootKey,
                                LPCWSTR pcwszSubKey, HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI SignFileA(LPCSTR pcszFilename, LPCSTR pcszDir, LPCSTR pcszIns,
                      LPSTR pszUnsignedFiles = NULL, LPCSTR pcszCustInf = NULL, BOOL fTest = FALSE);
void WINAPI SignFileW(LPCWSTR pcwszFilename, LPCWSTR pcwszDir, LPCWSTR pcwszIns,
                      LPWSTR pwszUnsignedFiles = NULL, LPCWSTR pcwszCustInf = NULL, BOOL fTest = FALSE);
void WINAPI DoReboot(HWND hwndUI);

void WINAPI ShowInetcpl(HWND hDlg, DWORD dwPages, DWORD dwMode = IEM_ADMIN);
void WINAPI SetLBWidth(HWND hLb);

// dlgprocs.cpp
void WINAPI TestURLA(LPCSTR pcszUrl);
void WINAPI TestURLW(LPCWSTR pcwszUrl);
void WINAPI SetProxyDlgA(HWND hDlg, LPCSTR pcszProxy, DWORD dwIdName, DWORD dwIdPort,
                         BOOL fDef80);
void WINAPI SetProxyDlgW(HWND hDlg, LPCWSTR pcwszProxy, DWORD dwIdName, DWORD dwIdPort,
                         BOOL fDef80);
void WINAPI GetProxyDlgA(HWND hDlg, LPSTR pszProxy, DWORD dwIdName, DWORD dwIdPort);
void WINAPI GetProxyDlgW(HWND hDlg, LPWSTR pwszProxy, DWORD dwIdName, DWORD dwIdPort);
HPALETTE WINAPI BuildPalette(HDC hdc);
void WINAPI ShowBitmapA(HWND hControl, LPCSTR pcszFileName, int nBitmapId, PHANDLE pBitmap);
void WINAPI ShowBitmapW(HWND hControl, LPCWSTR pcwszFileName, int nBitmapId, PHANDLE pBitmap);
BOOL WINAPI CopyAnimBmpA(HWND hDlg, LPSTR pszBmp, LPCSTR pcszWorkDir, LPCSTR pcszNameStr,
                         LPCSTR pcszPathStr, LPCSTR pcszInsFile);
BOOL WINAPI CopyAnimBmpW(HWND hDlg, LPWSTR pwszBmp, LPCWSTR pcwszWorkDir, LPCWSTR pcwszNameStr,
                         LPCWSTR pcwszPathStr, LPCWSTR pcwszInsFile);
BOOL WINAPI CopyLogoBmpA(HWND hDlg, LPSTR pszBmp, LPCSTR pcszLogoStr,
                         LPCSTR pcszWorkDir, LPCSTR pcszInsFile);
BOOL WINAPI CopyLogoBmpW(HWND hDlg, LPWSTR pwszBmp, LPCWSTR pcwszLogoStr,
                         LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile);
BOOL WINAPI CopyWallPaperA(HWND hDlg, LPCSTR pcszWallPaper, UINT nBitmapId,
                           LPCSTR pcszWorkDir, LPCSTR pcszInsFile, BOOL fCopy);
BOOL WINAPI CopyWallPaperW(HWND hDlg, LPCWSTR pcwszWallPaper, UINT nBitmapId,
                           LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile, BOOL fCopy);

// urls.cpp

void WINAPI InitializeStartSearchA(HWND hDlg, LPCSTR pcszInsFile, LPCSTR pcszServerFile);
void WINAPI InitializeStartSearchW(HWND hDlg, LPCWSTR pcwszInsFile, LPCWSTR pcwszServerFile);
BOOL WINAPI SaveStartSearchA(HWND hDlg, LPCSTR pcszInsFile, LPCSTR pcszServerFile,
                             BOOL *pfInsDirty = NULL, BOOL fCheckDirtyOnly = FALSE);
BOOL WINAPI SaveStartSearchW(HWND hDlg, LPCWSTR pcwszInsFile, LPCWSTR pcwszServerFile,
                             BOOL *pfInsDirty = NULL, BOOL fCheckDirtyOnly = FALSE);

// btoolbar.cpp
DWORD WINAPI BToolbar_InitA(HWND hwndList, LPCSTR pcszCustIns, LPCSTR pcszAltDir, LPCSTR pcszWorkDir);
DWORD WINAPI BToolbar_InitW(HWND hwndList, LPCWSTR pcwszCustIns, LPCWSTR pcwszAltDir, LPCWSTR pcwszWorkDir);
void  WINAPI BToolbar_Remove(HWND hwndList);
void  WINAPI BToolbar_Edit(HWND hwndList, BOOL fAdd);
void  WINAPI BToolbar_SaveA(HWND hwndList, LPCSTR pcszCustIns, LPCSTR pcszBToolbarDir, DWORD dwMode = IEM_NEUTRAL);
void  WINAPI BToolbar_SaveW(HWND hwndList, LPCWSTR pcwszCustIns, LPCWSTR pcwszBToolbarDir, DWORD dwMode = IEM_NEUTRAL);

// connset.cpp
BOOL WINAPI ImportConnectSetA(LPCSTR pcszIns, LPCSTR pcszTargetPath, LPCSTR pcszCleanupPath,
    BOOL fImport, DWORD dwMode, LPCSTR pcszPbkFile = NULL, HKEY hkRoot = NULL);
BOOL WINAPI ImportConnectSetW(LPCWSTR pcwszIns, LPCWSTR pcwszTargetPath, LPCWSTR pcwszCleanupPath,
    BOOL fImport, DWORD dwMode, LPCWSTR pcwszPbkFile = NULL, HKEY hkRoot = NULL);

// programs.cpp
BOOL WINAPI ImportProgramsA(LPCSTR pcszInsFile, LPCSTR pcszWorkDir, BOOL fImport);
BOOL WINAPI ImportProgramsW(LPCWSTR pcwszInsFile, LPCWSTR pcwszWorkDir, BOOL fImport);

// favsproc.cpp
BOOL WINAPI MigrateFavoritesA(LPCSTR pcszIns);
BOOL WINAPI MigrateFavoritesW(LPCWSTR pcwszIns);

void WINAPI MigrateToOldFavoritesA(LPCSTR pcszIns);
void WINAPI MigrateToOldFavoritesW(LPCWSTR pcwszIns);

int  WINAPI ImportFavoritesA(HWND htv, LPCSTR pcszDefInf, LPCSTR pcszIns, LPCSTR pcszFixPath,
                             LPCSTR pcszNewPath, BOOL fIgnoreOffline);
int  WINAPI ImportFavoritesW(HWND htv, LPCWSTR pcwszDefInf, LPCWSTR pcwszIns,
                             LPCWSTR pcwszFixPath, LPCWSTR pcwszNewPath, BOOL fIgnoreOffline);

int  WINAPI ImportQuickLinksA(HWND htv, LPCSTR pcszDefInf, LPCSTR pcszIns, LPCSTR pcszFixPath,
                              LPCSTR pcszNewPath, BOOL fIgnoreOffline);
int  WINAPI ImportQuickLinksW(HWND htv, LPCWSTR pcwszDefInf, LPCWSTR pcwszIns,
                              LPCWSTR pcwszFixPath, LPCWSTR pcwszNewPath, BOOL fIgnoreOffline);

BOOL WINAPI NewUrlA(HWND htv, LPCSTR pcszExtractPath, DWORD dwPlatformID, DWORD dwMode);
BOOL WINAPI NewUrlW(HWND htv, LPCWSTR pcwszExtractPath, DWORD dwPlatformID, DWORD dwMode);

BOOL WINAPI NewFolder(HWND htv);

BOOL WINAPI ModifyFavoriteA(HWND htv, HTREEITEM hti, LPCSTR  pcszExtractPath,  LPCSTR   pcszPrevExtractPath,  DWORD dwPlatformID, DWORD dwMode);
BOOL WINAPI ModifyFavoriteW(HWND htv, HTREEITEM hti, LPCWSTR pcwszExtractPath, LPCWSTR  pcwszPrevExtractPath, DWORD dwPlatformID, DWORD dwMode);

BOOL WINAPI DeleteFavoriteA(HWND htv, HTREEITEM hti, LPCSTR  pcszExtractPath);
BOOL WINAPI DeleteFavoriteW(HWND htv, HTREEITEM hti, LPCWSTR pcwszExtractPath);

BOOL WINAPI MoveUpFavorite  (HWND htv, HTREEITEM hti);
BOOL WINAPI MoveDownFavorite(HWND htv, HTREEITEM hti);

BOOL WINAPI IsFavoriteItem       (HWND htv, HTREEITEM hti);
UINT WINAPI GetFavoritesNumber   (HWND htv, BOOL fQL = FALSE);
UINT WINAPI GetFavoritesMaxNumber(BOOL fQL = FALSE);

int  WINAPI ImportFavoritesCmdA(HWND htv, LPCSTR pcszExtractPath);
int  WINAPI ImportFavoritesCmdW(HWND htv, LPCWSTR pcwszExtractPath);

void WINAPI ExportFavoritesA(HWND htv, LPCSTR pcszIns, LPCSTR pcszExtractPath, BOOL fFixUpPath);
void WINAPI ExportFavoritesW(HWND htv, LPCWSTR pcwszIns, LPCWSTR pcwszExtractPath, BOOL fFixUpPath);

void WINAPI ExportQuickLinksA(HWND htv, LPCSTR pcszIns, LPCSTR pcszExtractPath, BOOL fFixUpPath);
void WINAPI ExportQuickLinksW(HWND htv, LPCWSTR pcwszIns, LPCWSTR pcwszExtractPath, BOOL fFixUpPath);

void WINAPI GetFavoritesInfoTipA(LPNMTVGETINFOTIPA pGetInfoTipA);
void WINAPI GetFavoritesInfoTipW(LPNMTVGETINFOTIPW pGetInfoTipW);

BOOL WINAPI GetFavoriteUrlA(HWND htv, HTREEITEM hti, LPSTR pszUrl, DWORD cchSize);
BOOL WINAPI GetFavoriteUrlW(HWND htv, HTREEITEM hti, LPWSTR pwszUrl, DWORD cchSize);

void WINAPI ProcessFavSelChange(HWND hDlg, HWND hTv, LPNMTREEVIEW pnmtv);

// adm.cpp
void WINAPI CreateADMWindow(HWND hOwner, HWND hWndInsertAfter, int nXPos, int nYPos,
                            int nWidth, int nHeight);
void WINAPI ShowADMWindow(HWND hOwner, BOOL fShow);
void WINAPI MoveADMWindow(HWND hOwner, int nXPos, int nYPos, int nWidth, int nHeight);
void WINAPI SetADMWindowTextA(HWND hOwner, LPCSTR pcszTitle, LPCSTR pcszText,
                              BOOL fUpdateWindowState  = TRUE);
void WINAPI SetADMWindowTextW(HWND hOwner, LPCWSTR pcwszTitle, LPCWSTR pcwszText,
                              BOOL fUpdateWindowState = TRUE);
void WINAPI DestroyADMWindow(HWND hOwner);
BOOL WINAPI IsADMFileVisibleA(LPCSTR pcszFileName, int nRole, DWORD dwPlatformId);
BOOL WINAPI IsADMFileVisibleW(LPCWSTR pcwszFileName, int nRole, DWORD dwPlatformId);
BOOL WINAPI LoadADMFilesA(HWND hTreeView, HTREEITEM hPolicyRootItem, LPCSTR pcszADMFilePath,
                          LPCSTR pcszWorkDir, DWORD dwPlatformId, int nRole,
                          int nIconADMClose, int nIconADMCategory);
BOOL WINAPI LoadADMFilesW(HWND hTreeView, HTREEITEM hPolicyRootItem, LPCWSTR pcwszADMFilePath,
                          LPCWSTR pcwszWorkDir, DWORD dwPlatformId, int nRole,
                          int nIconADMClose, int nIconADMCategory);
void WINAPI DeleteADMItemA(HWND hTreeView, HTREEITEM hParentItem, LPCSTR pcszWorkDir,
                           LPCSTR pcszInsFile, BOOL bDeleteFile, BOOL bSave);
void WINAPI DeleteADMItemW(HWND hTreeView, HTREEITEM hParentItem, LPCWSTR pcwszWorkDir,
                           LPCWSTR pcwszInsFile, BOOL bDeleteFile, BOOL bSave);
void WINAPI DeleteADMItemsA(HWND hTreeView, LPCSTR pcszWorkDir, LPCSTR pcszInsFile,
                            BOOL bSave);
void WINAPI DeleteADMItemsW(HWND hTreeView, LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile,
                            BOOL bSave);
void WINAPI DisplayADMItem(HWND hWnd, HWND hTreeView, LPTVITEM lpSelectedItem,
                           BOOL fShowDisabled);
void WINAPI SelectADMItem(HWND hMainWnd, HWND hTreeView, LPTVITEM lpTVItem,
                          BOOL bSelect, BOOL fShowDisabled);
void WINAPI ImportADMFileA(HWND hMainWnd, HWND hTreeView, LPCSTR pcszADMFilePath,
                           LPCSTR pcszWorkDir, int nRole, LPCSTR pcszInsFile);
void WINAPI ImportADMFileW(HWND hMainWnd, HWND hTreeView, LPCWSTR pcwszADMFilePath,
                           LPCWSTR pcwszWorkDir, int nRole, LPCWSTR pcwszInsFile);
void WINAPI CheckForDupKeys(HWND hMainWnd, HWND hTreeView, HTREEITEM hItem,
                            BOOL bDispSuccessMsg);
void WINAPI ResetAdmFilesA(HWND hTreeView, LPCSTR pcszWorkDir, BOOL bReset);
void WINAPI ResetAdmFilesW(HWND hTreeView, LPCWSTR pcwszWorkDir, BOOL bReset);
void WINAPI SaveAdmFilesA(HWND hTreeView, LPCSTR pcszWorkDir, LPCSTR pcszInsFile);
void WINAPI SaveAdmFilesW(HWND hTreeView, LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile);
BOOL WINAPI CanDeleteADM(HWND hTreeView, HTREEITEM hItem);
HWND WINAPI GetAdmWindowHandle(HWND hTreeView, HTREEITEM hItem);
BOOL WINAPI AdmDirty();
void WINAPI ClearAdmDirtyFlag();

// these #defines is also used in insedit.dll

#define ITEM_SAVE       0x00000001
#define ITEM_DESTROY    0x00000002
#define ITEM_CHECKDIRTY 0x00000004

void WINAPI SaveADMItem(HWND hTreeView, LPTVITEM lpTVItem, DWORD dwFlags);
BOOL WINAPI GetAdmFileListA(LPRESULTITEMA* pResultItemsArrayA, int* pnResultItems, int nRole);
BOOL WINAPI GetAdmFileListW(LPRESULTITEMW* pResultItemsArrayW, int* pnResultItems, int nRole);
HTREEITEM WINAPI AddADMItemA(HWND hTreeView, LPCSTR pcszADMFilePath, LPCSTR pcszFileName,
                            LPCSTR pcszWorkDir, int nRole, BSTR bstrRSOPNamespace);
HTREEITEM WINAPI AddADMItemW(HWND hTreeView, LPCWSTR pcwszADMFilePath, LPCWSTR pcwszFileName,
                            LPCWSTR pcwszWorkDir, int nRole, BSTR bstrRSOPNamespace);

// version.cpp
int WINAPI CheckVerA(LPCSTR pcszPrevVer, LPCSTR pcszNewVer);
int WINAPI CheckVerW(LPCWSTR pcwszPrevVer, LPCWSTR pcwszNewVer);
void WINAPI GenerateNewVersionStrA(LPCSTR pcszInsFile, LPSTR pszNewVersionStr);
void WINAPI GenerateNewVersionStrW(LPCWSTR pcwszInsFile, LPWSTR pwszNewVersionStr);
void WINAPI SetOrClearVersionInfoA(LPCSTR pcszInsFile, DWORD dwCabType, LPCSTR pcszCabName,
                            LPCSTR pcszCabsURLPath, LPSTR pszNewVersionStr, BOOL fSet);
void WINAPI SetOrClearVersionInfoW(LPCWSTR pcwszInsFile, DWORD dwCabType, LPCWSTR pcwszCabName,
                            LPCWSTR pcwszCabsURLPath, LPWSTR pwszNewVersionStr, BOOL fSet);
void WINAPI GetBaseFileNameA(LPCSTR pcszFile, LPSTR pszBaseFileName, INT cchSize);
void WINAPI GetBaseFileNameW(LPCWSTR pcwszFile, LPWSTR pwszBaseFileName, INT cchSize);

// TCHAR mappings for functions

#ifdef UNICODE                                                  //UNICODE

#define ImportADTInfo           ImportADTInfoW                  // desktop.cpp

#define ImportToolbarInfo       ImportToolbarInfoW              // toolbar.cpp

#define CopyHttFile             CopyHttFileW                    // mccphtt.cpp

#define ImportSiteCert          ImportSiteCertW                 // seccerts.cpp
#define ImportAuthCode          ImportAuthCodeW

#define ImportZones             ImportZonesW                    // seczones.cpp
#define ImportRatings           ImportRatingsW

#define ImportLDAPBitmap        ImportLDAPBitmapW               // oe.cpp
#define ImportOEInfo            ImportOEInfoW
#define EncodeSignature         EncodeSignatureW

#define BrowseForFile           BrowseForFileW                  // utils.cpp
#define BrowseForFolder         BrowseForFolderW
#define ExportRegTree2Inf       ExportRegTree2InfW
#define ExportRegKey2Inf        ExportRegKey2InfW
#define ExportRegValue2Inf      ExportRegValue2InfW
#define IsAnimBitmapFileValid   IsAnimBitmapFileValidW
#define IsBitmapFileValid       IsBitmapFileValidW
#define SignFile                SignFileW

#define TestURL                 TestURLW                        // dlgprocs.cpp
#define SetProxyDlg             SetProxyDlgW
#define GetProxyDlg             GetProxyDlgW
#define ShowBitmap              ShowBitmapW
#define CopyAnimBmp             CopyAnimBmpW
#define CopyLogoBmp             CopyLogoBmpW
#define CopyWallPaper           CopyWallPaperW

#define InitializeStartSearch   InitializeStartSearchW          // urls.cpp
#define SaveStartSearch         SaveStartSearchW

#define BToolbar_Init           BToolbar_InitW                  // btoolbar.cpp
#define BToolbar_Save           BToolbar_SaveW

#define ImportConnectSet        ImportConnectSetW               // connset.cpp

#define ImportPrograms          ImportProgramsW                 // programs.cpp

#define MigrateFavorites        MigrateFavoritesW               // favsproc.cpp
#define MigrateToOldFavorites   MigrateToOldFavoritesW
#define ImportFavorites         ImportFavoritesW
#define ImportQuickLinks        ImportQuickLinksW
#define NewUrl                  NewUrlW
#define ModifyFavorite          ModifyFavoriteW
#define DeleteFavorite          DeleteFavoriteW
#define ImportFavoritesCmd      ImportFavoritesCmdW
#define ExportFavorites         ExportFavoritesW
#define ExportQuickLinks        ExportQuickLinksW
#define GetFavoritesInfoTip     GetFavoritesInfoTipW
#define GetFavoriteUrl          GetFavoriteUrlW

#define SetADMWindowText        SetADMWindowTextW               // adm.cpp
#define IsADMFileVisible        IsADMFileVisibleW
#define LoadADMFiles            LoadADMFilesW
#define DeleteADMItem           DeleteADMItemW
#define DeleteADMItems          DeleteADMItemsW
#define ImportADMFile           ImportADMFileW
#define ResetAdmFiles           ResetAdmFilesW
#define SaveAdmFiles            SaveAdmFilesW
#define GetAdmFileList          GetAdmFileListW
#define AddADMItem              AddADMItemW

#define CheckVer                CheckVerW                       // version.cpp
#define GenerateNewVersionStr   GenerateNewVersionStrW
#define SetOrClearVersionInfo   SetOrClearVersionInfoW
#define GetBaseFileName         GetBaseFileNameW

#else   //----------------------------------------------------  !UNICODE

#define ImportADTInfo           ImportADTInfoA                  // desktop.cpp

#define ImportToolbarInfo       ImportToolbarInfoA              // toolbar.cpp

#define CopyHttFile             CopyHttFileA                    // mccphtt.cpp

#define ImportSiteCert          ImportSiteCertA                 // seccerts.cpp
#define ImportAuthCode          ImportAuthCodeA

#define ImportZones             ImportZonesA                    // seczones.cpp
#define ImportRatings           ImportRatingsA

#define ImportLDAPBitmap        ImportLDAPBitmapA               // oe.cpp
#define ImportOEInfo            ImportOEInfoA
#define EncodeSignature         EncodeSignatureA

#define BrowseForFile           BrowseForFileA                  // utils.cpp
#define BrowseForFolder         BrowseForFolderA
#define ExportRegTree2Inf       ExportRegTree2InfA
#define ExportRegKey2Inf        ExportRegKey2InfA
#define ExportRegValue2Inf      ExportRegValue2InfA
#define IsAnimBitmapFileValid   IsAnimBitmapFileValidA
#define IsBitmapFileValid       IsBitmapFileValidA
#define SignFile                SignFileA

#define TestURL                 TestURLA                        // dlgprocs.cpp
#define SetProxyDlg             SetProxyDlgA
#define GetProxyDlg             GetProxyDlgA
#define ShowBitmap              ShowBitmapA
#define CopyAnimBmp             CopyAnimBmpA
#define CopyLogoBmp             CopyLogoBmpA
#define CopyWallPaper           CopyWallPaperA

#define InitializeStartSearch   InitializeStartSearchA          // urls.cpp
#define SaveStartSearch         SaveStartSearchA

#define BToolbar_Init           BToolbar_InitA                  // btoolbar.cpp
#define BToolbar_Save           BToolbar_SaveA

#define ImportConnectSet        ImportConnectSetA               // connset.cpp

#define ImportPrograms          ImportProgramsA                 // programs.cpp

#define MigrateFavorites        MigrateFavoritesA               // favsproc.cpp
#define MigrateToOldFavorites   MigrateToOldFavoritesA
#define ImportFavorites         ImportFavoritesA
#define ImportQuickLinks        ImportQuickLinksA
#define NewUrl                  NewUrlA
#define ModifyFavorite          ModifyFavoriteA
#define DeleteFavorite          DeleteFavoriteA
#define ImportFavoritesCmd      ImportFavoritesCmdA
#define ExportFavorites         ExportFavoritesA
#define ExportQuickLinks        ExportQuickLinksA
#define GetFavoritesInfoTip     GetFavoritesInfoTipA
#define GetFavoriteUrl          GetFavoriteUrlA

#define SetADMWindowText        SetADMWindowTextA               // adm.cpp
#define IsADMFileVisible        IsADMFileVisibleA
#define LoadADMFiles            LoadADMFilesA
#define DeleteADMItem           DeleteADMItemA
#define DeleteADMItems          DeleteADMItemsA
#define ImportADMFile           ImportADMFileA
#define ResetAdmFiles           ResetAdmFilesA
#define SaveAdmFiles            SaveAdmFilesA
#define GetAdmFileList          GetAdmFileListA
#define AddADMItem              AddADMItemA

#define CheckVer                CheckVerA                       // version.cpp
#define GenerateNewVersionStr   GenerateNewVersionStrA
#define SetOrClearVersionInfo   SetOrClearVersionInfoA
#define GetBaseFileName         GetBaseFileNameA

#endif

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _EXPORTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\desktop.cpp ===
//
// DESKTOP.CPP
//

#include "precomp.h"


// prototype declarations
static BOOL ImportADTInfoHelper(LPCTSTR pcszInsFile, LPCTSTR pcszDeskWorkDir, LPCTSTR pcszDeskInf, BOOL fImportADT);
static BOOL ImportDesktopComps(LPCTSTR pcszInsFile, LPCTSTR pcszDeskWorkDir, LPCTSTR pcszDeskInf, BOOL fImportADTComps);
static BOOL ImportWallpaperInfo(LPCTSTR pcszInsFile, LPCTSTR pcszWallpaperWorkDir, BOOL fImportWallpaper);
static BOOL RunningOnWin98();

BOOL WINAPI ImportADTInfoA(LPCSTR pcszInsFile, LPCSTR pcszDeskWorkDir, LPCSTR pcszDeskInf, BOOL fImportADT)
{
    USES_CONVERSION;

    return ImportADTInfoHelper(A2CT(pcszInsFile), A2CT(pcszDeskWorkDir), A2CT(pcszDeskInf), fImportADT);
}

BOOL WINAPI ImportADTInfoW(LPCWSTR pcwszInsFile, LPCWSTR pcwszDeskWorkDir, LPCWSTR pcwszDeskInf, BOOL fImportADT)
{
    USES_CONVERSION;

    return ImportADTInfoHelper(W2CT((LPWSTR)pcwszInsFile), W2CT((LPWSTR)pcwszDeskWorkDir), W2CT((LPWSTR)pcwszDeskInf), fImportADT);
}

BOOL WINAPI ShowDeskCpl(VOID)
{
    BOOL bRet = FALSE;
    HKEY hkPol;
    DWORD dwOldScrSav = 0, dwOldAppearance = 0, dwOldSettings = 0;

    // display desk.cpl (right-click->properties on the desktop) but hide the ScreenSaver, Appearance and Settings
    // tabs by setting their corresponding reg values to 1
    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_SYSTEM, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_DEFAULT_ACCESS, NULL, &hkPol, NULL) == ERROR_SUCCESS)
    {
        DWORD dwData = 1;
        DWORD cbSize;

        // save the old values before setting them to 1

        cbSize = sizeof(dwOldScrSav);
        RegQueryValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSCRSAVPAGE, NULL, NULL, (LPBYTE) &dwOldScrSav, &cbSize);
        RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSCRSAVPAGE, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));

        cbSize = sizeof(dwOldAppearance);
        RegQueryValueEx(hkPol, REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE, NULL, NULL, (LPBYTE) &dwOldAppearance, &cbSize);
        RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));

        cbSize = sizeof(dwOldSettings);
        RegQueryValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSETTINGSPAGE, NULL, NULL, (LPBYTE) &dwOldSettings, &cbSize);

        // if we are running on Win98, because of a bug in desk.cpl, if all the restrictions for the tabs in Display properties
        // are set to 1, the Web tab doesn't show up.  Workaround for this bug is to not set the SettingsPage to 1.
        if (!IsOS(OS_MEMPHIS))
            RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSETTINGSPAGE, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));

        RegCloseKey(hkPol);
    }

    bRet = RunAndWaitA("rundll32.exe shell32.dll,Control_RunDLL desk.cpl", NULL, SW_SHOW);

    // restore the original values
    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_SYSTEM, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_DEFAULT_ACCESS, NULL, &hkPol, NULL) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSCRSAVPAGE, 0, REG_DWORD,
                            (CONST BYTE *) &dwOldScrSav, sizeof(dwOldScrSav));

        RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE, 0, REG_DWORD,
                            (CONST BYTE *) &dwOldAppearance, sizeof(dwOldAppearance));

        RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSETTINGSPAGE, 0, REG_DWORD,
                            (CONST BYTE *) &dwOldSettings, sizeof(dwOldSettings));

        RegCloseKey(hkPol);
    }

    return bRet;
}


static BOOL ImportADTInfoHelper(LPCTSTR pcszInsFile, LPCTSTR pcszDeskWorkDir, LPCTSTR pcszDeskInf, BOOL fImportADT)
{
    BOOL bRet = TRUE;

    if (pcszInsFile == NULL  ||  pcszDeskWorkDir == NULL  ||  pcszDeskInf == NULL)
        return FALSE;

    bRet = ImportDesktopComps(pcszInsFile, pcszDeskWorkDir, pcszDeskInf, fImportADT)  &&  bRet;
    bRet = ImportWallpaperInfo(pcszInsFile, pcszDeskWorkDir, fImportADT)  &&  bRet;

    return bRet;
}

static BOOL ImportDesktopComps(LPCTSTR pcszInsFile, LPCTSTR pcszDeskWorkDir, LPCTSTR pcszDeskInf, BOOL fImportADTComps)
{
    BOOL bRet = FALSE;
    HKEY hkDesk;

    // Before processing anything, first clear out the entries in the INS file and delete work dirs

    // clear out the entries in the INS file that correspond to importing Active Desktop components
    InsWriteBool(DESKTOP_OBJ_SECT, IMPORT_DESKTOP, FALSE, pcszInsFile);
    InsWriteString(EXTREGINF, DESKTOP, NULL, pcszInsFile);

    // blow away the pcszDeskWorkDir and pcszDeskInf
    PathRemovePath(pcszDeskWorkDir);
    PathRemovePath(pcszDeskInf);

    if (!fImportADTComps)
        return TRUE;

                
    InsWriteBool(DESKTOP_OBJ_SECT, IMPORT_DESKTOP, TRUE, pcszInsFile);
            
    // Import the Active Desktop components
    if (RegOpenKeyEx(HKEY_CURRENT_USER, KEY_DESKTOP_COMP, 0, KEY_DEFAULT_ACCESS, &hkDesk) == ERROR_SUCCESS)
    {
        TCHAR szFullInfName[MAX_PATH];
        HANDLE hInf;

        if (PathIsFileSpec(pcszDeskInf))                        // create DESKTOP.INF under pcszDeskWorkDir
            PathCombine(szFullInfName, pcszDeskWorkDir, pcszDeskInf);
        else
            StrCpy(szFullInfName, pcszDeskInf);

        // create DESKTOP.INF file
        if ((hInf = CreateNewFile(szFullInfName)) != INVALID_HANDLE_VALUE)
        {
            DWORD dwType, dwOldGeneralFlags, dwGeneralFlags, cbSize;
            TCHAR szSubKey[MAX_PATH];
            DWORD dwIndex, cchSize;
            BOOL fUpdateIns = FALSE;
            
            dwOldGeneralFlags = 0;
            cbSize = sizeof(dwOldGeneralFlags);
            RegQueryValueEx(hkDesk, GEN_FLAGS, NULL, &dwType, (LPBYTE) &dwOldGeneralFlags, &cbSize);

            dwGeneralFlags = dwOldGeneralFlags | RD_DIRTY;
            RegSetValueEx(hkDesk, GEN_FLAGS, 0, dwType, (CONST BYTE *) &dwGeneralFlags, sizeof(dwGeneralFlags));

            // first, write the standard goo - [Version], [DefaultInstall], etc. - to DESKTOP.INF
            WriteStringToFile(hInf, (LPCVOID) DESK_INF_ADD, StrLen(DESK_INF_ADD));

            ExportRegKey2Inf(hkDesk, TEXT("HKCU"), KEY_DESKTOP_COMP, hInf);
            WriteStringToFile(hInf, (LPCVOID) TEXT("\r\n"), 2);

            // restore the original value for GEN_FLAGS
            RegSetValueEx(hkDesk, GEN_FLAGS, 0, dwType, (CONST BYTE *) &dwOldGeneralFlags, sizeof(dwOldGeneralFlags));

            // for each desktop component that's enumerated, spit out its information to DESKTOP.INF and
            // if it's a local file, copy it to pcszDeskWorkDir
            for (dwIndex = 0, cchSize = ARRAYSIZE(szSubKey);
                    RegEnumKeyEx(hkDesk, dwIndex, szSubKey, &cchSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
                    dwIndex++, cchSize = ARRAYSIZE(szSubKey))
            {
                HKEY hkSub;

                if (RegOpenKeyEx(hkDesk, szSubKey, 0, KEY_DEFAULT_ACCESS, &hkSub) == ERROR_SUCCESS)
                {
                    TCHAR szDeskCompFile[MAX_URL];
                    TCHAR szFullSubkey[MAX_PATH];
                    BOOL fRestoreSource = FALSE;

                    // get the name of the component from SOURCE
                    *szDeskCompFile = TEXT('\0');
                    cbSize = sizeof(szDeskCompFile);
                    RegQueryValueEx(hkSub, SOURCE, NULL, NULL, (LPBYTE) szDeskCompFile, &cbSize);

                    if (PathIsLocalPath(szDeskCompFile)  &&  PathFileExists(szDeskCompFile)  &&  !PathIsDirectory(szDeskCompFile))
                    {
                        // During branding time, all the local files get copied into the
                        // "<windows>\web" dir; so temporarily set the SOURCE in the registry
                        // to point to this location before it's exported to DESKTOP.INF

                        if (CopyFileToDir(szDeskCompFile, pcszDeskWorkDir))
                        {
                            TCHAR szNewPath[MAX_URL];

                            // if the file is a .htm file, then copy all the IMG SRC's specified in it to pcszDeskWorkDir
                            if (PathIsExtension(szDeskCompFile, TEXT(".htm"))  ||  PathIsExtension(szDeskCompFile, TEXT(".html")))
                                CopyHtmlImgs(szDeskCompFile, pcszDeskWorkDir, NULL, NULL);

                            wnsprintf(szNewPath, ARRAYSIZE(szNewPath), TEXT("%%25%%\\Web\\%s"), PathFindFileName(szDeskCompFile));

                            fRestoreSource = TRUE;

                            RegSetValueEx(hkSub, SOURCE, 0, REG_SZ, (CONST BYTE *)szNewPath, (DWORD)StrCbFromSz(szNewPath));
                            RegSetValueEx(hkSub, SUBSCRIBEDURL, 0, REG_SZ, (CONST BYTE *)szNewPath, (DWORD)StrCbFromSz(szNewPath));
                        }
                    }

                    // dump the registry info for this component to DESKTOP.INF
                    wnsprintf(szFullSubkey, ARRAYSIZE(szFullSubkey), TEXT("%s\\%s"), KEY_DESKTOP_COMP, szSubKey);
                    ExportRegKey2Inf(hkSub, TEXT("HKCU"), szFullSubkey, hInf);
                    WriteStringToFile(hInf, (LPCVOID) TEXT("\r\n"), 2);

                    fUpdateIns = TRUE;

                    if (fRestoreSource)
                    {
                        RegSetValueEx(hkSub, SOURCE, 0, REG_SZ, (CONST BYTE *)szDeskCompFile, (DWORD)StrCbFromSz(szDeskCompFile));
                        RegSetValueEx(hkSub, SUBSCRIBEDURL, 0, REG_SZ, (CONST BYTE *)szDeskCompFile, (DWORD)StrCbFromSz(szDeskCompFile));
                    }

                    RegCloseKey(hkSub);
                }
            }

            CloseFile(hInf);

            if (fUpdateIns)
            {
                TCHAR szBuf[MAX_PATH];
                
                // update the INS file
                wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("*,%s,DefaultInstall"), PathFindFileName(pcszDeskInf));
                WritePrivateProfileString(EXTREGINF, DESKTOP, szBuf, pcszInsFile);

                bRet = TRUE;
            }
            else
            {
                PathRemovePath(pcszDeskWorkDir);
                PathRemovePath(szFullInfName);
            }
        }

        RegCloseKey(hkDesk);
    }

    return bRet;
}


static BOOL ImportWallpaperInfo(LPCTSTR pcszInsFile, LPCTSTR pcszWallpaperWorkDir, BOOL fImportWallpaper)
{
    BOOL bRet = FALSE;
    HKEY hkDesk;

    // Before processing anything, first clear out the entries in the INS file

    // delete the WALLPAPER section in the INS file
    WritePrivateProfileString(WALLPAPER, NULL, NULL, pcszInsFile);

    if (!fImportWallpaper)
        return TRUE;

    // Import the wallpaper information
    if (RegOpenKeyEx(HKEY_CURRENT_USER, KEY_DESKTOP_GEN, 0, KEY_DEFAULT_ACCESS, &hkDesk) == ERROR_SUCCESS)
    {
        DWORD cbSize;
        TCHAR szWallpaperFile[MAX_PATH];

        *szWallpaperFile = TEXT('\0');
        cbSize = sizeof(szWallpaperFile);
        if (RegQueryValueEx(hkDesk, WALLPAPER, NULL, NULL, (LPBYTE) szWallpaperFile, &cbSize) != ERROR_SUCCESS  ||
            *szWallpaperFile == TEXT('\0'))
        {
            // try reading the information from BACKUPWALLPAPER
            cbSize = sizeof(szWallpaperFile);
            RegQueryValueEx(hkDesk, BACKUPWALLPAPER, NULL, NULL, (LPBYTE) szWallpaperFile, &cbSize);
        }

        // During branding time, all the wallpaper files specified in the INS file will
        // get copied into whatever dir that's specified in the registry or if not found,
        // into "<windows>\web\wallpaper"

        // BUGBUG: even if szWallpaperFile points to a UNC or network path, we will still copy the files
        // to pcszWallpaperWorkDir and during branding time, would get copied into the client's machine

        if (CopyFileToDirEx(szWallpaperFile, pcszWallpaperWorkDir, WALLPAPER, pcszInsFile))
        {
            TCHAR szBuf[16];
            DWORD dwPos = 0;

            // if the file is a local .htm file, then copy all the IMG SRC's specified in it to pcszWallpaperWorkDir
            if (PathIsExtension(szWallpaperFile, TEXT(".htm"))  ||  PathIsExtension(szWallpaperFile, TEXT(".htm")))
                CopyHtmlImgs(szWallpaperFile, pcszWallpaperWorkDir, WALLPAPER, pcszInsFile);

            cbSize = sizeof(dwPos);
            RegQueryValueEx(hkDesk, COMPONENTPOS, NULL, NULL, (LPBYTE) &dwPos, &cbSize);

            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%lu"), dwPos);

            // update the INS file
            WritePrivateProfileString(DESKTOP_OBJ_SECT, OPTION, TEXT("1"), pcszInsFile);
            WritePrivateProfileString(WALLPAPER, COMPONENTPOS, szBuf, pcszInsFile);

            bRet = TRUE;
        }

        RegCloseKey(hkDesk);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\favsproc.cpp ===
#include "precomp.h"
#include <olectl.h>

// Implementation helper structures/routines declarations
typedef struct tagFAVLIST {
    LPFAVSTRUC pfs;
    int        cElements;
} FAVLIST, (FAR *LPFAVLIST);

typedef struct tagPERCONTROLDATA {
    FAVLIST flFavorites;
    FAVLIST flQuickLinks;
} PERCONTROLDATA, (FAR *LPPERCONTROLDATA);

typedef struct tagAEFAVPARAMS {
    LPFAVSTRUC pfs;
    BOOL       fQL;

    HWND       hwndErrorParent;
    HWND       htv;
    HTREEITEM  hti;
    LPCTSTR    pszExtractPath;
    LPCTSTR    pszPrevExtractPath;

    DWORD      dwPlatformID;
    DWORD      dwMode;
} AEFAVPARAMS, (FAR *LPAEFAVPARAMS);

static BOOL migrateFavoritesHelper(LPCTSTR pszIns);
static void migrateToOldFavoritesHelper(LPCTSTR pszIns);
static int  importFavoritesHelper(HWND htv, LPCTSTR pszDefInf, LPCTSTR pszIns,
    LPCTSTR pszFixPath, LPCTSTR pszNewPath, BOOL fIgnoreOffline);
static int  importQuickLinksHelper(HWND htv, LPCTSTR pszDefInf, LPCTSTR pszIns,
    LPCTSTR pszFixPath, LPCTSTR pszNewPath, BOOL fIgnoreOffline);
static BOOL newUrlHelper(HWND htv, LPCTSTR pszExtractPath, DWORD dwPlatformID, DWORD dwMode);
static BOOL modifyFavoriteHelper(HWND htv, HTREEITEM hti, LPCTSTR pszExtractPath, LPCTSTR pszPrevExtractPath,
                                 DWORD dwPlatformID, DWORD dwMode);
static BOOL deleteFavoriteHelper(HWND htv, HTREEITEM hti, LPCTSTR pszExtractPath);
static int importFavoritesCmdHelper(HWND htv, LPCTSTR pszExtractPath);
static void exportFavoritesHelper(HWND htv, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fFixUpPath = TRUE);
static void exportQuickLinksHelper(HWND htv, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fFixUpPath = TRUE);
static void getFavoritesInfoTipHelper(LPNMTVGETINFOTIP pGetInfoTip);
static BOOL getFavoriteUrlHelper(HWND htv, HTREEITEM hti, LPTSTR pszUrl);

static int importItems(HWND htv, LPCTSTR pszDefInf, LPCTSTR pszIns, LPCTSTR pszFixPath, LPCTSTR pszNewPath,
                       BOOL fIgnoreOffline, BOOL fQL = FALSE);

static INT_PTR CALLBACK addEditFavoriteDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

static LPFAVSTRUC getItem       (HWND htv, HTREEITEM hti);
static LPFAVSTRUC getFolderItem (HWND htv, HTREEITEM hti);
static LPFAVSTRUC findByName    (HWND htv, HTREEITEM hti, LPCTSTR pszName);
static LPFAVSTRUC findPath      (HWND htv, HTREEITEM hti, LPCTSTR pszFolders);
static HRESULT    isFavoriteItem(HWND htv, HTREEITEM hti);

static LPFAVSTRUC createFolderItems(HWND htv, HTREEITEM hti, LPCTSTR pszFolders);
static BOOL       importPath (HWND htv, HTREEITEM htiFrom, HTREEITEM *phtiAfter);
static void       importPath (HWND htv, HTREEITEM hti, LPCTSTR pszFilesPath, LPCTSTR pszExtractPath, LPCTSTR pszReserved = NULL);
static int        exportItems(HWND htv, HTREEITEM hti, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fFixUpPath = TRUE);

BOOL    extractIcon(LPCTSTR pszIconFile, int iIconIndex, LPCTSTR pszExtractPath, LPTSTR pszResult, UINT cchResult);
static LPCTSTR getLinksPath(LPTSTR pszPath, UINT cchPath = 0);

static LPTSTR encodeFavName(LPTSTR pszFavName, LPCTSTR pszIns);
static LPTSTR decodeFavName(LPTSTR pszFavName, LPCTSTR pszIns);


/////////////////////////////////////////////////////////////////////////////
// SFav constructors and destructors

SFav::SFav()
{
    wType = FTYPE_UNUSED;

    pszName     = NULL;
    pszPath     = NULL;
    pszUrl      = NULL;
    pszIconFile = NULL;
    fOffline    = FALSE;

    pTvItem = NULL;
}

SFav::~SFav()
{
    Delete();
}


/////////////////////////////////////////////////////////////////////////////
// SFav properties

HRESULT SFav::Load(UINT nIndex, LPCTSTR pszIns, BOOL fQL /*= FALSE*/,
    LPCTSTR pszFixPath /*= NULL*/, LPCTSTR pszNewPath /*= NULL*/, BOOL fIgnoreOffline /*= FALSE*/)
{
    TCHAR   szKey[32];
    LPCTSTR pszSection, pszKeyFmt;

    if (pszIns == NULL)
        return E_INVALIDARG;

    if (!fQL) {
        pszSection = IS_FAVORITESEX;
        pszKeyFmt  = IK_TITLE_FMT;
    }
    else {
        pszSection = IS_URL;
        pszKeyFmt  = IK_QUICKLINK_NAME;
    }

    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    if (InsIsKeyEmpty(pszSection, szKey, pszIns))
        return S_FALSE;

    wType = FTYPE_URL;
    if (!Expand())
        return E_OUTOFMEMORY;

    // Title
    pszKeyFmt = (!fQL ? IK_TITLE_FMT : IK_QUICKLINK_NAME);
    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    InsGetString(pszSection, szKey, pszName, MAX_PATH, pszIns);
    if (*pszName == TEXT('\0'))
        goto Fail;

    // URL
    pszKeyFmt = (!fQL ? IK_URL_FMT : IK_QUICKLINK_URL);
    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    InsGetString(pszSection, szKey, pszUrl, INTERNET_MAX_URL_LENGTH, pszIns);
    if (*pszUrl == TEXT('\0'))
        goto Fail;

    // Icon file (never required)
    pszKeyFmt = (!fQL ? IK_ICON_FMT : IK_QUICKLINK_ICON);
    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    InsGetString(pszSection, szKey, pszIconFile, INTERNET_MAX_URL_LENGTH, pszIns);

    if (*pszIconFile != TEXT('\0') && !PathIsURL(pszIconFile)) {
        BOOL fTryToFix;

        fTryToFix = FALSE;
        if (pszFixPath == NULL)
            fTryToFix = TRUE;

        else
            if (PathIsPrefix(pszFixPath, pszIconFile))
                fTryToFix = !PathFileExists(pszIconFile);

        if (fTryToFix && pszNewPath != NULL) {
            TCHAR szNewPath[MAX_PATH];

            PathCombine(szNewPath, pszNewPath, PathFindFileName(pszIconFile));
            StrCpy(pszIconFile, szNewPath);
            if (!PathFileExists(pszIconFile))
                *pszIconFile = TEXT('\0');
        }
    }

    // Make available offline flag
    fOffline = FALSE;
    if (!fIgnoreOffline) {
        pszKeyFmt = (!fQL ? IK_OFFLINE_FMT : IK_QUICKLINK_OFFLINE);
        wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
        fOffline  = InsGetBool(pszSection, szKey, FALSE, pszIns);
    }

    SetTVI();
    Shrink();
    return S_OK;

Fail:
    Delete();
    return E_FAIL;
}

HRESULT SFav::Load(LPCTSTR pszName, LPCTSTR pszFavorite, LPCTSTR pszExtractPath,
    ISubscriptionMgr2 *psm /*= NULL*/, BOOL fIgnoreOffline /*= FALSE*/)
{
    TCHAR szIconFile[INTERNET_MAX_URL_LENGTH];

    USES_CONVERSION;

    if (pszFavorite == NULL)
        return E_INVALIDARG;

    wType = FTYPE_URL;
    if (!Expand())
        return E_OUTOFMEMORY;

    // Title
    if (pszName == NULL)
        pszName = PathFindFileName(pszFavorite);
    else
        ASSERT(StrStrI(pszFavorite, pszName) != NULL);
    StrCpy(SFav::pszName, pszName);
    PathRenameExtension(SFav::pszName, DOT_URL);

    // URL
    InsGetString(IS_INTERNETSHORTCUT, IK_URL, pszUrl, INTERNET_MAX_URL_LENGTH, pszFavorite);
    if (*pszUrl == TEXT('\0'))
        goto Fail;

    // Icon file
    InsGetString(IS_INTERNETSHORTCUT, IK_ICONFILE, szIconFile, countof(szIconFile), pszFavorite);
    if (szIconFile[0] != TEXT('\0')) {
        int iIconIndex;

        iIconIndex = GetPrivateProfileInt(IS_INTERNETSHORTCUT, IK_ICONINDEX, 1, pszFavorite);
        ::extractIcon(szIconFile, iIconIndex, pszExtractPath, pszIconFile, INTERNET_MAX_URL_LENGTH);
    }

    // Make available offline flag
    fOffline = FALSE;
    if (!fIgnoreOffline) {
        HRESULT hr;
        BOOL    fOwnSubMgr;

        fOwnSubMgr = FALSE;
        if (psm == NULL) {
            hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *)&psm);
            if (SUCCEEDED(hr))
                fOwnSubMgr = TRUE;
        }

        if (psm != NULL) {
            hr = psm->IsSubscribed(T2W(pszUrl), &fOffline);
            if (FAILED(hr))
                fOffline = FALSE;
        }

        if (fOwnSubMgr)
            psm->Release();
    }

    SetTVI();
    Shrink();
    return S_OK;

Fail:
    Delete();
    return E_FAIL;
}

HRESULT SFav::Add(HWND htv, HTREEITEM hti)
{
    SFav            *pfsFolder;
    TV_INSERTSTRUCT tvins;
    HTREEITEM       htiParent;

    if (hti == NULL)
        hti = TreeView_GetSelection(htv);

    pfsFolder = NULL;
    if (wType == FTYPE_URL) {
        TCHAR   szFolders[MAX_PATH];
        LPTSTR  pszFile;

        pszFile = PathFindFileName(pszName);
        if (pszFile > pszName) {
            *(pszFile-1) = TEXT('\0');
            StrCpy(szFolders, pszName);
            StrCpy(pszName, pszFile);

            pfsFolder = ::createFolderItems(htv, hti, szFolders);
            if (pfsFolder == NULL)
                goto Fail;
        }
    }

    SetTVI();

    if (pfsFolder == NULL)
        pfsFolder = ::getFolderItem(htv, hti);
    if (pfsFolder != NULL) {
        if (pfsFolder->pTvItem == NULL || pfsFolder->pTvItem->hItem == NULL)
            goto Fail;

        htiParent = pfsFolder->pTvItem->hItem;
    }
    else
        htiParent = TVI_ROOT;

    ZeroMemory(&tvins, sizeof(tvins));
    tvins.hParent      = htiParent;
    tvins.hInsertAfter = TVI_LAST;

    CopyMemory(&tvins.item, pTvItem, sizeof(TV_ITEM));
    pTvItem->hItem = TreeView_InsertItem(htv, &tvins);

    pTvItem->mask  = TVIF_HANDLE | TVIF_STATE;
    TreeView_GetItem(htv, pTvItem);

    if (pfsFolder != NULL)
        TreeView_Expand(htv, htiParent, TVE_EXPAND);

    TreeView_SelectItem(htv, pTvItem->hItem);

    //----- Increment the number of items -----
    LPPERCONTROLDATA ppcd;
    LPFAVLIST        pfl;

    ppcd = (LPPERCONTROLDATA)GetWindowLongPtr(htv, GWLP_USERDATA);
    ASSERT (NULL != ppcd);

    pfl = (S_OK == ::isFavoriteItem(htv, pTvItem->hItem)) ? &ppcd->flFavorites : &ppcd->flQuickLinks;
    pfl->cElements++;

    return S_OK;

Fail:
    Delete();
    return FALSE;
}

// NOTE: (andrewgu) can also be used to clear the entry in case of quick links
HRESULT SFav::Save(HWND htv, UINT nIndex, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fQL /*= FALSE*/,
    BOOL fFixUpPath /*= TRUE*/)
{
    TCHAR   szAux[INTERNET_MAX_URL_LENGTH],
            szKey[32];
    LPCTSTR pszSection, pszKeyFmt,
            pszAux;

    if (pszIns == NULL)
        return E_INVALIDARG;

    // Name
    if (!fQL) {
        if (wType != FTYPE_URL)
            return E_UNEXPECTED;

        GetPath(htv, szAux);
        PathAppend(szAux, pszName);
        
        if (!PathIsExtension(szAux, DOT_URL))
            StrCat(szAux, DOT_URL);

        pszAux = szAux;
        ASSERT(*pszAux != TEXT('\0'));

        pszSection = IS_FAVORITESEX;
        pszKeyFmt  = IK_TITLE_FMT;
    }
    else {
        if (pszName != NULL && wType != FTYPE_URL)
            return E_UNEXPECTED;

        pszAux = NULL;
        if (pszName != NULL) {
            StrCpy(szAux, pszName);

        if (!PathIsExtension(szAux, DOT_URL))
            StrCat(szAux, DOT_URL);

            pszAux = szAux;
            ASSERT(*pszAux != TEXT('\0'));
        }

        pszSection = IS_URL;
        pszKeyFmt  = IK_QUICKLINK_NAME;
    }
    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    WritePrivateProfileString(pszSection, szKey, pszAux, pszIns);

    // URL
    if (!fQL) {
        ASSERT(pszUrl != NULL && *pszUrl != TEXT('\0'));

        pszKeyFmt = IK_URL_FMT;
    }
    else {
        if (pszName != NULL)
            { ASSERT(pszUrl != NULL && *pszUrl != TEXT('\0')); }

        else
            { ASSERT(pszUrl == NULL); }

        pszKeyFmt = IK_QUICKLINK_URL;
    }
    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    WritePrivateProfileString(pszSection, szKey, pszUrl, pszIns);

    // Icon file
    if (!fQL) {
        ASSERT(pszIconFile == NULL || *pszIconFile != TEXT('\0'));

        pszKeyFmt = IK_ICON_FMT;
    }
    else {
        if (pszName != NULL && pszIconFile != NULL)
            { ASSERT(*pszIconFile != TEXT('\0')); }

        else
            { ASSERT(pszIconFile == NULL); }

        pszKeyFmt = IK_QUICKLINK_ICON;
    }

    pszAux = NULL;
    if (pszIconFile != NULL) {
        ::extractIcon(pszIconFile, 1, pszExtractPath, szAux, countof(szAux));
        if (szAux[0] != TEXT('\0'))
            if (PathIsPrefix(pszExtractPath, szAux))
                pszAux = szAux;

            else {
                TCHAR szDest[MAX_PATH];

                ASSERT(PathFileExists(szAux));
                PathCombine(szDest, pszExtractPath, PathFindFileName(szAux));
                CopyFile(szAux, szDest, FALSE);
                SetFileAttributes(szDest, FILE_ATTRIBUTE_NORMAL);

                // (pritobla): fFixUpPath should be always TRUE if called by the IEAK
                // Wizard or the Profile Manager.  The only case when it would
                // be FALSE is when called by OPKWIZ.  They want to keep the path
                // to the icon files what the user entered because they don't use our
                // Wizard/ProfMgr logic of temp dirs.
                pszAux = fFixUpPath ? szDest : szAux;
            }
    }
    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    WritePrivateProfileString(pszSection, szKey, pszAux, pszIns);

    // Make available offline flag
    pszAux    = NULL;
    pszKeyFmt = !fQL ? IK_OFFLINE_FMT : IK_QUICKLINK_OFFLINE;
    if (!fQL) {
        if (fOffline)
            pszAux = TEXT("1");
    }
    else
        if (pszName != NULL && fOffline)
            pszAux = TEXT("1");
    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    WritePrivateProfileString(pszSection, szKey, pszAux, pszIns);

    return S_OK;
}

void SFav::SetTVI()
{
    if (!Expand(FF_TVI))
        return;

    if (wType == FTYPE_URL)
        wnsprintf(pTvItem->pszText, MAX_PATH + 3 + INTERNET_MAX_URL_LENGTH, TEXT("%s = %s"), pszName, pszUrl);
    else
        StrCpy(pTvItem->pszText, pszName);

    pTvItem->cchTextMax = StrLen(pTvItem->pszText) + 1;
    pTvItem->mask       = TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_STATE | TVIF_TEXT;
    pTvItem->lParam     = (LPARAM)this;
}


/////////////////////////////////////////////////////////////////////////////
// SFav operations

SFav* SFav::CreateNew(HWND htv, BOOL fQL /*= FALSE*/)
{
    SFav* pfsFirst;

    pfsFirst = GetFirst(htv, fQL);
    if (pfsFirst == NULL)
        return NULL;

    for (UINT i = 0; i < SFav::GetMaxNumber(fQL); i++)
        if ((pfsFirst + i)->wType == FTYPE_UNUSED)
            break;
    if (i >= SFav::GetMaxNumber(fQL))
        return NULL;

    return (pfsFirst + i);
}

SFav* SFav::GetFirst(HWND htv, BOOL fQL /*= FALSE*/)
{
    LPPERCONTROLDATA ppcd;
    LPFAVLIST        pfl;

    ppcd = (LPPERCONTROLDATA)GetWindowLongPtr(htv, GWLP_USERDATA);

    //----- Allocate per-control memory -----
    if (NULL == ppcd) {
        ppcd = (LPPERCONTROLDATA)CoTaskMemAlloc(sizeof(PERCONTROLDATA));
        if (NULL == ppcd)
            return NULL;
        ZeroMemory(ppcd, sizeof(PERCONTROLDATA));

        SetWindowLongPtr(htv, GWLP_USERDATA, (LONG_PTR)ppcd);
    }

    pfl = !fQL ? &ppcd->flFavorites : &ppcd->flQuickLinks;
    if (NULL == pfl->pfs) {
        pfl->pfs = (LPFAVSTRUC)CoTaskMemAlloc(sizeof(FAVSTRUC) * SFav::GetMaxNumber(fQL));
        if (NULL == pfl->pfs)
            return NULL;
        ZeroMemory(pfl->pfs, sizeof(FAVSTRUC) * SFav::GetMaxNumber(fQL));
    }

    return pfl->pfs;
}

SFav* SFav::GetNext(HWND htv, BOOL fQL /*= FALSE*/) const
{
    SFav* pfsFirst;
    UINT  nCur;

    pfsFirst = GetFirst(htv, fQL);
    if (pfsFirst == NULL)
        return NULL;

    for (nCur = (UINT)(this - pfsFirst + 1); nCur < GetMaxNumber(fQL); nCur++)
        if ((pfsFirst + nCur)->wType != FTYPE_UNUSED)
            break;

    return (nCur < GetMaxNumber(fQL) ? (pfsFirst + nCur) : NULL);
}

void SFav::Free(HWND htv, BOOL fQL, LPCTSTR pszExtractPath /*= NULL*/)
{
    if (pszIconFile != NULL && pszExtractPath != NULL)
        if (PathIsPrefix(pszExtractPath, pszIconFile)) {
            SetFileAttributes(pszIconFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(pszIconFile);
        }

    if (htv != NULL && pTvItem != NULL && pTvItem->hItem != NULL)
        TreeView_DeleteItem(htv, pTvItem->hItem);
    Delete();

    //----- Decrement the number of items -----
    LPPERCONTROLDATA ppcd;
    LPFAVLIST        pfl;

    ppcd = (LPPERCONTROLDATA)GetWindowLongPtr(htv, GWLP_USERDATA);
    ASSERT (NULL != ppcd);

    pfl = !fQL ? &ppcd->flFavorites : &ppcd->flQuickLinks;
    ASSERT(pfl->cElements > 0);
    pfl->cElements--;

    //----- Free per-control memory -----
    if (0 == pfl->cElements) {
        CoTaskMemFree(pfl->pfs);

        // switch to the other one
        pfl = fQL ? &ppcd->flFavorites : &ppcd->flQuickLinks;
        if (0 == pfl->cElements) {
            CoTaskMemFree(ppcd);
            SetWindowLongPtr(htv, GWLP_USERDATA, NULL);
        }
    }
}

UINT SFav::GetNumber(HWND htv, BOOL fQL /*= FALSE*/)
{
    LPPERCONTROLDATA ppcd;

    ppcd = (LPPERCONTROLDATA)GetWindowLongPtr(htv, GWLP_USERDATA);
    if (NULL == ppcd)
        return 0;

    return (!fQL ? ppcd->flFavorites.cElements : ppcd->flQuickLinks.cElements);
}

UINT SFav::GetMaxNumber(BOOL fQL /*= FALSE*/)
{
    return (!fQL ? NUM_FAVS : NUM_LINKS) + 1;
}

BOOL SFav::Expand(WORD wFlags /*= FF_DEFAULT*/)
{
    BOOL fZeroInit;

    if (wFlags == FF_DEFAULT) {
        if (wType != FTYPE_URL && wType != FTYPE_FOLDER)
            goto Fail;

        wFlags  = (wType == FTYPE_URL) ? (WORD)(FF_NAME | FF_URL | FF_ICON) : (WORD)FF_NAME;
        wFlags |= FF_TVI;
    }

    if (HasFlag(wFlags, FF_NAME)) {
        fZeroInit = (pszName == NULL || *pszName == TEXT('\0'));

        pszName   = (LPTSTR)CoTaskMemRealloc(pszName, MAX_PATH*sizeof(TCHAR));
        if (pszName == NULL)
            goto Fail;

        if (fZeroInit)
            ZeroMemory(pszName, MAX_PATH);
    }

    if (HasFlag(wFlags, FF_PATH)) {
        fZeroInit = (pszPath == NULL || *pszPath == TEXT('\0'));

        pszPath = (LPTSTR)CoTaskMemRealloc(pszPath, MAX_PATH*sizeof(TCHAR));
        if (pszPath == NULL)
            goto Fail;

        if (fZeroInit)
            ZeroMemory(pszPath, MAX_PATH);
    }

    if (HasFlag(wFlags, FF_URL)) {
        fZeroInit = (pszUrl == NULL || *pszUrl == TEXT('\0'));

        pszUrl = (LPTSTR)CoTaskMemRealloc(pszUrl, INTERNET_MAX_URL_LENGTH*sizeof(TCHAR));
        if (pszUrl == NULL)
            goto Fail;

        if (fZeroInit)
            ZeroMemory(pszUrl, INTERNET_MAX_URL_LENGTH);
    }
    else
        if (wType == FTYPE_FOLDER)
            if (pszUrl != NULL) {
                CoTaskMemFree(pszUrl);
                pszUrl = NULL;
            }

    if (HasFlag(wFlags, FF_ICON)) {
        fZeroInit = (pszIconFile == NULL || *pszIconFile == TEXT('\0'));

        pszIconFile = (LPTSTR)CoTaskMemRealloc(pszIconFile, INTERNET_MAX_URL_LENGTH*sizeof(TCHAR));
        if (pszIconFile == NULL)
            goto Fail;

        if (fZeroInit)
            ZeroMemory(pszIconFile, INTERNET_MAX_URL_LENGTH);
    }
    else
        if (wType == FTYPE_FOLDER)
            if (pszIconFile != NULL) {
                CoTaskMemFree(pszIconFile);
                pszIconFile = NULL;
            }

    if (HasFlag(wFlags, FF_TVI)) {
        UINT nTreeViewTextLen;

        fZeroInit = TRUE;
        if (pTvItem == NULL) {
            pTvItem = (LPTV_ITEM)CoTaskMemAlloc(sizeof(TV_ITEM));
            if (pTvItem == NULL)
                goto Fail;
            ZeroMemory(pTvItem, sizeof(TV_ITEM));
        }
        else
            fZeroInit = (pTvItem->pszText == NULL || *pTvItem->pszText == TEXT('\0'));

        nTreeViewTextLen = (UINT)((wType == FTYPE_URL) ? (MAX_PATH + 3 + INTERNET_MAX_URL_LENGTH) : MAX_PATH);
        pTvItem->pszText = (LPTSTR)CoTaskMemRealloc(pTvItem->pszText, nTreeViewTextLen*sizeof(TCHAR));
        if (pTvItem->pszText == NULL)
            goto Fail;

        if (fZeroInit)
            ZeroMemory(pTvItem->pszText, nTreeViewTextLen);
    }

    return TRUE;

Fail:
    Delete();
    return FALSE;
}

void SFav::Shrink(WORD wFlags /*= FF_ALL*/)
{
    UINT nLen;

    if (HasFlag(wFlags, FF_NAME) && pszName != NULL) {
        nLen    = (*pszName != TEXT('\0')) ? (StrLen(pszName) + 1) : 0;
        pszName = (LPTSTR)CoTaskMemRealloc(pszName, nLen * sizeof(TCHAR));
        ASSERT(pszName != NULL);                // should not be empty
    }

    if (HasFlag(wFlags, FF_PATH) && pszPath != NULL) {
        nLen    = (*pszPath != TEXT('\0')) ? (StrLen(pszPath) + 1) : 0;
        pszPath = (LPTSTR)CoTaskMemRealloc(pszPath, nLen * sizeof(TCHAR));
        ASSERT(pszPath == NULL);                // not used
    }

    if (HasFlag(wFlags, FF_URL) && pszUrl != NULL) {
        nLen   = (*pszUrl != TEXT('\0')) ? (StrLen(pszUrl) + 1) : 0;
        pszUrl = (LPTSTR)CoTaskMemRealloc(pszUrl, nLen * sizeof(TCHAR));
        ASSERT((wType == FTYPE_FOLDER && pszUrl == NULL) || pszUrl != NULL);
    }

    if (HasFlag(wFlags, FF_ICON) && pszIconFile != NULL) {
        nLen        = (*pszIconFile != TEXT('\0')) ? (StrLen(pszIconFile) + 1) : 0;
        pszIconFile = (LPTSTR)CoTaskMemRealloc(pszIconFile, nLen * sizeof(TCHAR));
    }

    if (HasFlag(wFlags, FF_TVI) && pTvItem != NULL && pTvItem->pszText != NULL) {
        pTvItem->pszText = (LPTSTR)CoTaskMemRealloc(pTvItem->pszText,
            (StrLen(pTvItem->pszText) + 1) * sizeof(TCHAR));
        ASSERT(pTvItem->pszText != NULL);
    }
}

void SFav::Delete(WORD wFlags /*= FF_ALL*/)
{
    if (HasFlag(wFlags, FF_NAME) && pszName != NULL) {
        CoTaskMemFree(pszName);
        pszName = NULL;
    }

    if (HasFlag(wFlags, FF_PATH) && pszPath != NULL) {
        CoTaskMemFree(pszPath);
        pszPath = NULL;
    }

    if (HasFlag(wFlags, FF_URL) && pszUrl != NULL) {
        CoTaskMemFree(pszUrl);
        pszUrl = NULL;
    }

    if (HasFlag(wFlags, FF_ICON) && pszIconFile != NULL) {
        CoTaskMemFree(pszIconFile);
        pszIconFile = NULL;
    }

    if (HasFlag(wFlags, FF_TVI) && pTvItem != NULL) {
        if (pTvItem->pszText != NULL) {
            CoTaskMemFree(pTvItem->pszText);
            pTvItem->pszText = NULL;
        }

        CoTaskMemFree(pTvItem);
        pTvItem = NULL;
    }

    if (wFlags == FF_ALL)
        wType = FTYPE_UNUSED;
}

BOOL SFav::GetPath(HWND htv, LPTSTR pszResult, UINT cchResult /*= 0*/) const
{
    SFav       *pfs;
    HTREEITEM  htiCur, htiNext;
    TCHAR      szPath[MAX_PATH],
               szAux [MAX_PATH];

    if (pTvItem == NULL || pTvItem->hItem == NULL)
        return FALSE;

    if (pszResult == NULL)
        return FALSE;
    *pszResult = TEXT('\0');

    if (cchResult == 0)
        cchResult = MAX_PATH;

    szPath[0] = szAux[0] = TEXT('\0');
    for (htiCur = TreeView_GetParent(htv, pTvItem->hItem), htiNext = TreeView_GetParent(htv, htiCur);
         htiNext != NULL;
         htiCur = htiNext, htiNext = TreeView_GetParent(htv, htiCur)) {

        pfs = ::getItem(htv, htiCur);
        if (pfs == NULL)
            break;

        ASSERT(pfs->wType == FTYPE_FOLDER);
        PathCombine(szAux, pfs->pszName, szPath);
        StrCpy(szPath, szAux);
    }
    if (htiNext != NULL)
        return FALSE;

    if (cchResult <= (UINT)StrLen(szPath))
        return FALSE;

    StrCpy(pszResult, szPath);
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Exported routines

BOOL WINAPI MigrateFavoritesA(LPCSTR pszIns)
{
    USES_CONVERSION;

    return migrateFavoritesHelper(A2CT(pszIns));
}

BOOL WINAPI MigrateFavoritesW(LPCWSTR pcwszIns)
{
    USES_CONVERSION;

    return migrateFavoritesHelper(W2CT(pcwszIns));
}

void WINAPI MigrateToOldFavoritesA(LPCSTR pszIns)
{
    USES_CONVERSION;

    migrateToOldFavoritesHelper(A2CT(pszIns));
}

void WINAPI MigrateToOldFavoritesW(LPCWSTR pcwszIns)
{
    USES_CONVERSION;

    migrateToOldFavoritesHelper(W2CT(pcwszIns));
}

int  WINAPI ImportFavoritesA(HWND htv, LPCSTR pszDefInf, LPCSTR pszIns, LPCSTR pszFixPath,
                             LPCSTR pszNewPath, BOOL fIgnoreOffline)
{
    USES_CONVERSION;

    return importFavoritesHelper(htv, A2CT(pszDefInf), A2CT(pszIns), A2CT(pszFixPath),
        A2CT(pszNewPath), fIgnoreOffline);
}

int  WINAPI ImportFavoritesW(HWND htv, LPCWSTR pcwszDefInf, LPCWSTR pcwszIns,
                             LPCWSTR pcwszFixPath, LPCWSTR pcwszNewPath, BOOL fIgnoreOffline)
{
    USES_CONVERSION;

    return importFavoritesHelper(htv, W2CT(pcwszDefInf), W2CT(pcwszIns), W2CT(pcwszFixPath),
        W2CT(pcwszNewPath), fIgnoreOffline);
}

int  WINAPI ImportQuickLinksA(HWND htv, LPCSTR pszDefInf, LPCSTR pszIns, LPCSTR pszFixPath,
                              LPCSTR pszNewPath, BOOL fIgnoreOffline)
{
    USES_CONVERSION;

    return importQuickLinksHelper(htv, A2CT(pszDefInf), A2CT(pszIns), A2CT(pszFixPath),
        A2CT(pszNewPath), fIgnoreOffline);
}

int  WINAPI ImportQuickLinksW(HWND htv, LPCWSTR pcwszDefInf, LPCWSTR pcwszIns,
                              LPCWSTR pcwszFixPath, LPCWSTR pcwszNewPath, BOOL fIgnoreOffline)
{
    USES_CONVERSION;

    return importQuickLinksHelper(htv, W2CT(pcwszDefInf), W2CT(pcwszIns), W2CT(pcwszFixPath),
        W2CT(pcwszNewPath), fIgnoreOffline);
}

BOOL WINAPI NewUrlA(HWND htv, LPCSTR pszExtractPath, DWORD dwPlatformID, DWORD dwMode)
{
    USES_CONVERSION;

    return newUrlHelper(htv, A2CT(pszExtractPath), dwPlatformID, dwMode);
}

BOOL WINAPI NewUrlW(HWND htv, LPCWSTR pcwszExtractPath, DWORD dwPlatformID, DWORD dwMode)
{
    USES_CONVERSION;

    return newUrlHelper(htv, W2CT(pcwszExtractPath), dwPlatformID, dwMode);
}

BOOL WINAPI NewFolder(HWND htv)
{
    LPFAVSTRUC  pfsNew;
    AEFAVPARAMS aefp;
    int         iResult;

    ASSERT(isFavoriteItem(htv, TreeView_GetSelection(htv)) == S_OK);

    pfsNew = pfsNew->CreateNew(htv);
    if (pfsNew == NULL)
        goto Fail;

    pfsNew->wType = FTYPE_FOLDER;

    ZeroMemory(&aefp, sizeof(aefp));
    aefp.pfs             = pfsNew;
    aefp.fQL             = FALSE;
    aefp.hwndErrorParent = GetParent(htv);
    aefp.htv             = htv;
    aefp.hti             = TreeView_GetSelection(htv);
    aefp.pszExtractPath  = NULL;
    aefp.dwPlatformID    = PLATFORM_WIN32;
    aefp.dwMode          = IEM_CORP;

    iResult = (int) DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_FAVPOPUP), GetParent(htv),
        addEditFavoriteDlgProc, (LPARAM)&aefp);
    if (iResult == IDCANCEL)
        goto Fail;

    pfsNew->Add(htv, NULL);
    return TRUE;

Fail:
    if (pfsNew != NULL)
        pfsNew->Delete();

    return FALSE;
}

BOOL WINAPI ModifyFavoriteA(HWND htv, HTREEITEM hti, LPCSTR pszExtractPath, LPCSTR pszPrevExtractPath,
                            DWORD dwPlatformID, DWORD dwMode)
{
    USES_CONVERSION;

    return modifyFavoriteHelper(htv, hti, A2CT(pszExtractPath), A2CT(pszPrevExtractPath), dwPlatformID, dwMode);
}

BOOL WINAPI ModifyFavoriteW(HWND htv, HTREEITEM hti, LPCWSTR pcwszExtractPath, LPCWSTR pcwszPrevExtractPath,
                            DWORD dwPlatformID, DWORD dwMode)
{
    USES_CONVERSION;

    return modifyFavoriteHelper(htv, hti, W2CT(pcwszExtractPath), W2CT(pcwszPrevExtractPath), dwPlatformID, dwMode);
}

BOOL WINAPI DeleteFavoriteA(HWND htv, HTREEITEM hti, LPCSTR pszExtractPath)
{
    USES_CONVERSION;

    return deleteFavoriteHelper(htv, hti, A2CT(pszExtractPath));
}

BOOL WINAPI DeleteFavoriteW(HWND htv, HTREEITEM hti, LPCWSTR pcwszExtractPath)
{
    USES_CONVERSION;

    return deleteFavoriteHelper(htv, hti, W2CT(pcwszExtractPath));
}

BOOL WINAPI MoveUpFavorite(HWND htv, HTREEITEM hti)
{
    HTREEITEM htiBrother1, htiBrother2;

    htiBrother1 = TreeView_GetPrevSibling(htv, hti);
    if (htiBrother1 == NULL)
        return FALSE;

    htiBrother2 = TreeView_GetPrevSibling(htv, htiBrother1);
    if (htiBrother2 == NULL)
        htiBrother2 = TVI_FIRST;

    if (!importPath(htv, hti, &htiBrother2))
        return FALSE;
    ASSERT(htiBrother2 != NULL);

    TreeView_SelectItem(htv, htiBrother2);
    TreeView_DeleteItem(htv, hti);
    TreeView_EnsureVisible(htv, htiBrother2);
    return TRUE;
}

BOOL WINAPI MoveDownFavorite(HWND htv, HTREEITEM hti)
{
    HTREEITEM htiBrother;

    htiBrother = TreeView_GetNextSibling(htv, hti);
    if (htiBrother == NULL)
        return FALSE;

    if (!importPath(htv, hti, &htiBrother))
        return FALSE;
    ASSERT(htiBrother != NULL);

    TreeView_SelectItem(htv, htiBrother);
    TreeView_DeleteItem(htv, hti);
    TreeView_EnsureVisible(htv, htiBrother);
    return TRUE;
}

BOOL WINAPI IsFavoriteItem(HWND htv, HTREEITEM hti)
{
    return (isFavoriteItem(htv, hti) == S_OK);
}

UINT WINAPI GetFavoritesNumber(HWND htv, BOOL fQL /*= FALSE*/)
{
    return SFav::GetNumber(htv, fQL);
}

UINT WINAPI GetFavoritesMaxNumber(BOOL fQL /*= FALSE*/)
{
    return SFav::GetMaxNumber(fQL);
}

int  WINAPI ImportFavoritesCmdA(HWND htv, LPCSTR pszExtractPath)
{
    USES_CONVERSION;

    return importFavoritesCmdHelper(htv, A2CT(pszExtractPath));
}

int  WINAPI ImportFavoritesCmdW(HWND htv, LPCWSTR pcwszExtractPath)
{
    USES_CONVERSION;

    return importFavoritesCmdHelper(htv, W2CT(pcwszExtractPath));
}

void WINAPI ExportFavoritesA(HWND htv, LPCSTR pszIns, LPCSTR pszExtractPath, BOOL fFixUpPath)
{
    USES_CONVERSION;

    exportFavoritesHelper(htv, A2CT(pszIns), A2CT(pszExtractPath), fFixUpPath);
}

void WINAPI ExportFavoritesW(HWND htv, LPCWSTR pcwszIns, LPCWSTR pcwszExtractPath, BOOL fFixUpPath)
{
    USES_CONVERSION;

    exportFavoritesHelper(htv, W2CT(pcwszIns), W2CT(pcwszExtractPath), fFixUpPath);
}

void WINAPI ExportQuickLinksA(HWND htv, LPCSTR pszIns, LPCSTR pszExtractPath, BOOL fFixUpPath)
{
    USES_CONVERSION;

    exportQuickLinksHelper(htv, A2CT(pszIns), A2CT(pszExtractPath), fFixUpPath);
}

void WINAPI ExportQuickLinksW(HWND htv, LPCWSTR pcwszIns, LPCWSTR pcwszExtractPath, BOOL fFixUpPath)
{
    USES_CONVERSION;

    exportQuickLinksHelper(htv, W2CT(pcwszIns), W2CT(pcwszExtractPath), fFixUpPath);
}

void WINAPI GetFavoritesInfoTipA(LPNMTVGETINFOTIPA pGetInfoTipA)
{
    NMTVGETINFOTIP GetInfoTip;

    ZeroMemory(&GetInfoTip, sizeof(GetInfoTip));
    GetInfoTip.pszText = (LPTSTR)LocalAlloc(LPTR, pGetInfoTipA->cchTextMax * sizeof(TCHAR));
    if (GetInfoTip.pszText != NULL)
    {
        getFavoritesInfoTipHelper(TVInfoTipA2T(pGetInfoTipA, &GetInfoTip));
        TVInfoTipT2A(&GetInfoTip, pGetInfoTipA);
        LocalFree(GetInfoTip.pszText);
    }
}

void WINAPI GetFavoritesInfoTipW(LPNMTVGETINFOTIPW pGetInfoTipW)
{
    NMTVGETINFOTIP GetInfoTip;

    ZeroMemory(&GetInfoTip, sizeof(GetInfoTip));
    GetInfoTip.pszText = (LPTSTR)LocalAlloc(LPTR, pGetInfoTipW->cchTextMax * sizeof(TCHAR));
    if (GetInfoTip.pszText != NULL)
    {
        getFavoritesInfoTipHelper(TVInfoTipW2T(pGetInfoTipW, &GetInfoTip));
        TVInfoTipT2W(&GetInfoTip, pGetInfoTipW);
        LocalFree(GetInfoTip.pszText);
    }
}

BOOL WINAPI GetFavoriteUrlA(HWND htv, HTREEITEM hti, LPSTR pszUrl, DWORD cchSize)
{
    LPTSTR pszUrlBuf = (LPTSTR)LocalAlloc(LPTR, cchSize * sizeof(TCHAR));
    BOOL fRet;

    if (pszUrlBuf == NULL)
        fRet = FALSE;
    else
    {
        fRet = getFavoriteUrlHelper(htv, hti, pszUrlBuf);
        if (fRet)
            T2Abux(pszUrlBuf, pszUrl);

        LocalFree(pszUrlBuf);
    }

    return fRet;
}

BOOL WINAPI GetFavoriteUrlW(HWND htv, HTREEITEM hti, LPWSTR pwszUrl, DWORD cchSize)
{
    LPTSTR pszUrlBuf = (LPTSTR)LocalAlloc(LPTR, cchSize * sizeof(TCHAR));
    BOOL fRet;

    if (pszUrlBuf == NULL)
        fRet = FALSE;
    else
    {
        fRet = getFavoriteUrlHelper(htv, hti, pszUrlBuf);
        if (fRet)
            T2Wbux(pszUrlBuf, pwszUrl);

        LocalFree(pszUrlBuf);
    }

    return fRet;
}

void WINAPI ProcessFavSelChange(HWND hDlg, HWND hTv, LPNMTREEVIEW pnmtv)
{
    LPFAVSTRUC pfs;

    if (HasFlag(pnmtv->itemNew.state, TVIS_BOLD)) {
        int rgids[] = { IDC_MODIFY, IDC_REMOVE, IDC_TESTFAVURL, IDC_FAVUP, IDC_FAVDOWN };

        EnsureDialogFocus(hDlg, rgids, countof(rgids), IDC_ADDURL);
        DisableDlgItems  (hDlg, rgids, countof(rgids));
    }
    else {
        EnableDlgItem(hDlg, IDC_MODIFY);
        EnableDlgItem(hDlg, IDC_REMOVE);

        pfs = (LPFAVSTRUC)pnmtv->itemNew.lParam;
        if (pfs != NULL)
            EnableDlgItem2(hDlg, IDC_TESTFAVURL, (pfs->wType == FTYPE_URL));

        if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_FAVONTOP)) {
            EnableDlgItem2(hDlg, IDC_FAVUP,   (NULL != TreeView_GetPrevSibling(hTv, pnmtv->itemNew.hItem)));
            EnableDlgItem2(hDlg, IDC_FAVDOWN, (NULL != TreeView_GetNextSibling(hTv, pnmtv->itemNew.hItem)));
        }
    }

    EnableDlgItem2(hDlg, IDC_ADDFOLDER, IsFavoriteItem(hTv, pnmtv->itemNew.hItem));
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

static BOOL migrateFavoritesHelper(LPCTSTR pszIns)
{
    TCHAR   szTitle[MAX_PATH],
            szUrl[INTERNET_MAX_URL_LENGTH],
            szKey[32];
    LPCTSTR pszTitle;
    LPTSTR  pszBuffer;
    HANDLE  hIns;
    DWORD   dwInsSize;
    UINT    i;

    // figure out if there are any favorites at all
    // NOTE: (andrewgu) szUrl serves as a mere buffer in the processing below.
    wnsprintf(szKey, countof(szKey), IK_TITLE_FMT, 1);
    if (InsIsKeyEmpty(IS_FAVORITESEX, szKey, pszIns)) {
        if (InsIsSectionEmpty(IS_FAVORITES, pszIns))
            return TRUE;
    }
    else
        return TRUE;

    WritePrivateProfileString(NULL, NULL, NULL, pszIns);
    hIns = CreateFile(pszIns, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hIns == INVALID_HANDLE_VALUE)
        return FALSE;

    dwInsSize = GetFileSize(hIns, NULL);
    ASSERT(dwInsSize != 0xFFFFFFFF);
    CloseHandle(hIns);

    pszBuffer = (LPTSTR)CoTaskMemAlloc(dwInsSize*sizeof(TCHAR));
    if (pszBuffer == NULL)
        return FALSE;
    ZeroMemory(pszBuffer, dwInsSize);

    GetPrivateProfileString(IS_FAVORITES, NULL, TEXT(""), pszBuffer, (UINT)dwInsSize, pszIns);
    ASSERT(*pszBuffer != TEXT('\0'));

    for (i = 1, pszTitle = pszBuffer; *pszTitle != TEXT('\0'); pszTitle += StrLen(pszTitle) + 1, i++) {
        InsGetString(IS_FAVORITES, pszTitle, szUrl, countof(szUrl), pszIns);

        wnsprintf(szKey, countof(szKey), IK_TITLE_FMT, i);
        StrCpy(szTitle, pszTitle);
        decodeFavName(szTitle, pszIns);
        WritePrivateProfileString(IS_FAVORITESEX, szKey, szTitle, pszIns);

        wnsprintf(szKey, countof(szKey), IK_URL_FMT, i);
        WritePrivateProfileString(IS_FAVORITESEX, szKey, szUrl, pszIns);
    }

    CoTaskMemFree(pszBuffer);
    return TRUE;
}

static void migrateToOldFavoritesHelper(LPCTSTR pszIns)
{
    TCHAR szTitle[MAX_PATH],
          szUrl[INTERNET_MAX_URL_LENGTH],
          szKey[32];

    WritePrivateProfileString(IS_FAVORITES, NULL, NULL, pszIns);

    for (UINT i = 1; TRUE; i++) {
        wnsprintf(szKey, countof(szKey), IK_TITLE_FMT, i);
        InsGetString(IS_FAVORITESEX, szKey, szTitle, countof(szTitle), pszIns);
        if (szTitle[0] == TEXT('\0'))
            break;

        wnsprintf(szKey, countof(szKey), IK_URL_FMT, i);
        InsGetString(IS_FAVORITESEX, szKey, szUrl, countof(szUrl), pszIns);

        encodeFavName(szTitle, pszIns);
        WritePrivateProfileString(IS_FAVORITES, szTitle, szUrl, pszIns);
    }

    WritePrivateProfileString(NULL, NULL, NULL, pszIns);
}

static int importFavoritesHelper(HWND htv, LPCTSTR pszDefInf, LPCTSTR pszIns,
                                 LPCTSTR pszFixPath, LPCTSTR pszNewPath, BOOL fIgnoreOffline)
{
    return importItems(htv, pszDefInf, pszIns, pszFixPath, pszNewPath, fIgnoreOffline);
}

static int importQuickLinksHelper(HWND htv, LPCTSTR pszDefInf, LPCTSTR pszIns,
                                  LPCTSTR pszFixPath, LPCTSTR pszNewPath, BOOL fIgnoreOffline)
{
    return importItems(htv, pszDefInf, pszIns, pszFixPath, pszNewPath, fIgnoreOffline, TRUE);
}

static BOOL newUrlHelper(HWND htv, LPCTSTR pszExtractPath, DWORD dwPlatformID, DWORD dwMode)
{
    LPFAVSTRUC  pfsNew;
    AEFAVPARAMS aefp;
    HTREEITEM   htiSel;
    int         iResult;
    BOOL        fQL;

    htiSel = TreeView_GetSelection(htv);
    fQL    = (isFavoriteItem(htv, htiSel) != S_OK);

    pfsNew = pfsNew->CreateNew(htv, fQL);
    if (pfsNew == NULL)
        goto Fail;

    pfsNew->wType = FTYPE_URL;

    ZeroMemory(&aefp, sizeof(aefp));
    aefp.pfs             = pfsNew;
    aefp.fQL             = fQL;
    aefp.hwndErrorParent = GetParent(htv);
    aefp.htv             = htv;
    aefp.hti             = htiSel;
    aefp.pszExtractPath  = pszExtractPath;
    aefp.dwPlatformID    = dwPlatformID;
    aefp.dwMode          = dwMode;

    iResult = (int) DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_FAVPOPUP), GetParent(htv),
        addEditFavoriteDlgProc, (LPARAM)&aefp);

    if (iResult == IDCANCEL)
        goto Fail;

    pfsNew->Add(htv, htiSel);
    return TRUE;

Fail:
    if (pfsNew != NULL)
        pfsNew->Delete();

    return FALSE;
}

static BOOL modifyFavoriteHelper(HWND htv, HTREEITEM hti, LPCTSTR pszExtractPath, LPCTSTR pszPrevExtractPath,
                                 DWORD dwPlatformID, DWORD dwMode)
{
    LPFAVSTRUC  pfs;
    AEFAVPARAMS aefp;
    int         iResult;

    pfs = getItem(htv, hti);
    if (pfs == NULL)
        return FALSE;

    ZeroMemory(&aefp, sizeof(aefp));
    aefp.pfs             = pfs;
    aefp.fQL             = FALSE;
    aefp.hwndErrorParent = GetParent(htv);
    aefp.htv             = htv;
    aefp.hti             = TreeView_GetParent(htv, hti);
    aefp.pszExtractPath  = pszExtractPath;
    aefp.pszPrevExtractPath = pszPrevExtractPath;
    aefp.dwPlatformID    = dwPlatformID;
    aefp.dwMode          = dwMode;

    iResult = (int) DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_FAVPOPUP), GetParent(htv),
        addEditFavoriteDlgProc, (LPARAM)&aefp);

    if (iResult == IDCANCEL)
        return FALSE;

    if (pfs->pTvItem != NULL) {
        TreeView_SetItem(htv, pfs->pTvItem);

        if (pfs->pTvItem->hItem != NULL)
            TreeView_SelectItem(htv, pfs->pTvItem->hItem);
    }

    return TRUE;
}

static BOOL deleteFavoriteHelper(HWND htv, HTREEITEM hti, LPCTSTR pszExtractPath)
{
    LPFAVSTRUC pfs;
    HTREEITEM  htiChild;

    htiChild = TreeView_GetChild(htv, hti);
    if (htiChild != NULL) {
        HTREEITEM htiSibling;

        while ((htiSibling = TreeView_GetNextSibling(htv, htiChild)) != NULL)
            deleteFavoriteHelper(htv, htiSibling, pszExtractPath);

        deleteFavoriteHelper(htv, htiChild, pszExtractPath);
    }

    pfs = getItem(htv, hti);
    if (pfs == NULL)
        return FALSE;

    pfs->Free(htv, (isFavoriteItem(htv, hti) != S_OK), pszExtractPath);
    return TRUE;
}

static int importFavoritesCmdHelper(HWND htv, LPCTSTR pszExtractPath)
{
    LPFAVSTRUC pfsFolder;
    TCHAR      szFolder[MAX_PATH],
               szTitle[MAX_PATH];

    pfsFolder = getFolderItem(htv, TreeView_GetSelection(htv));
    if (pfsFolder == NULL || pfsFolder->pTvItem == NULL || pfsFolder->pTvItem->hItem == NULL)
        return 0;

    LoadString(g_hInst, IDS_BROWSEIMPORT, szTitle, countof(szTitle));
    if (!BrowseForFolder(htv, szFolder, szTitle))
        return 0;

    if (szFolder[0] == TEXT('\0'))
        return 0;

    importPath     (htv, pfsFolder->pTvItem->hItem, szFolder, pszExtractPath);
    TreeView_Expand(htv, pfsFolder->pTvItem->hItem, TVE_EXPAND);

    return pfsFolder->GetNumber(htv);
}

static void exportFavoritesHelper(HWND htv, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fFixUpPath /*= TRUE */)
{
    LPFAVSTRUC pfs;
    int        i;

    WritePrivateProfileString(IS_FAVORITESEX, NULL, NULL, pszIns);

    pfs = pfs->GetFirst(htv);
    if (pfs == NULL || pfs->pTvItem == NULL || pfs->pTvItem->hItem == NULL)
        return;

    i = exportItems(htv, pfs->pTvItem->hItem, pszIns, pszExtractPath, fFixUpPath);

    // if no favorites, write out a flag so we don't repopulate with default favorites next time around
    InsWriteBool(IS_BRANDING, IK_NOFAVORITES, (i == 1), pszIns);
}

static void exportQuickLinksHelper(HWND htv, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fFixUpPath /*= TRUE */)
{
    LPFAVSTRUC pfs;
    int        i;

    pfs = pfs->GetFirst(htv, TRUE);
    if (pfs == NULL || pfs->pTvItem == NULL || pfs->pTvItem->hItem == NULL)
        return;

    i = exportItems(htv, pfs->pTvItem->hItem, pszIns, pszExtractPath, fFixUpPath);

    // if no links, write out a flag so we don't repopulate with default links next time around
    InsWriteBool(IS_BRANDING, IK_NOLINKS, (i == 1), pszIns);

    // clear out any stuff that might be left over
    SFav favEmpty;
    for (i = (i >= 0) ? i : 1; (UINT)i < pfs->GetMaxNumber(TRUE); i++)
        favEmpty.Save(NULL, i, pszIns, NULL, TRUE, fFixUpPath);
}

static void getFavoritesInfoTipHelper(LPNMTVGETINFOTIP pGetInfoTip)
{
    LPFAVSTRUC pfs;
    static TCHAR s_szFormat[80],
        s_szAbsent[30],
        s_szOfflineOn[30], s_szOfflineOff[30],
        s_szEllipsis[] = TEXT("...");

    TCHAR            szBuffer[2 * MAX_PATH],
        rgszAux [4][30];
    LPCTSTR          rgpszAux[4];


    if (s_szFormat[0] == TEXT('\0')) {
        LoadString(g_hInst, IDS_FAVS_TOOLTIPFORMAT, s_szFormat,     countof(s_szFormat));
        LoadString(g_hInst, IDS_FAVS_ABSENT,        s_szAbsent,     countof(s_szAbsent));
        LoadString(g_hInst, IDS_FAVS_OFFLINE,       s_szOfflineOn,  countof(s_szAbsent));
        LoadString(g_hInst, IDS_FAVS_NOOFFLINE,     s_szOfflineOff, countof(s_szOfflineOff));
    }

    ASSERT(pGetInfoTip != NULL);

    pfs = (LPFAVSTRUC)pGetInfoTip->lParam;
    if (pfs == NULL || pfs->wType != FTYPE_URL)
    {
        StrCpyN(pGetInfoTip->pszText, pfs != NULL ? pfs->pszName : TEXT(""), pGetInfoTip->cchTextMax);
        return;
    }

    ASSERT(pfs->pszName != NULL && pfs->pszUrl != NULL);
    rgpszAux[0] = pfs->pszName;
    rgpszAux[1] = pfs->pszUrl;
    rgpszAux[2] = pfs->pszIconFile;
    rgpszAux[3] = pfs->fOffline ? s_szOfflineOn : s_szOfflineOff;

    for (UINT i = 0; i < countof(rgszAux); i++)
    {
        if (rgpszAux[i] == NULL)
            StrCpy(rgszAux[i], s_szAbsent);
        else
        {
            if (StrLen(rgpszAux[i]) < countof(rgszAux[i]))
                StrCpy(rgszAux[i], rgpszAux[i]);
            else
            {
                StrCpyN(rgszAux[i], rgpszAux[i], countof(rgszAux[i]) - countof(s_szEllipsis) + 1);
                StrCpy(&rgszAux[i][countof(rgszAux[i]) - countof(s_szEllipsis)], s_szEllipsis);
            }
        }
    }
    wnsprintf(szBuffer, countof(szBuffer), s_szFormat, rgszAux[0], rgszAux[1], rgszAux[2],
        rgszAux[3]);
    StrCpyN(pGetInfoTip->pszText, szBuffer, pGetInfoTip->cchTextMax);
}

static BOOL getFavoriteUrlHelper(HWND htv, HTREEITEM hti, LPTSTR pszUrl)
{
    LPFAVSTRUC pfs = getItem(htv, hti);
    BOOL fRet = FALSE;

    if ((pfs != NULL) && (pfs->pszUrl != NULL))
    {
        fRet = TRUE;
        StrCpy(pszUrl, pfs->pszUrl);
    }

    return fRet;
}

int importItems(HWND htv, LPCTSTR pszDefInf, LPCTSTR pszIns, LPCTSTR pszFixPath, LPCTSTR pszNewPath,
                BOOL fIgnoreOffline, BOOL fQL /*= FALSE */)
{
    LPFAVSTRUC pfs, pfsCur;
    TCHAR      szKey[32];
    UINT       i;

    pfs = pfs->GetFirst(htv, fQL);
    if (pfs != NULL && pfs->pTvItem != NULL && pfs->pTvItem->hItem != NULL) {
        DeleteFavorite(htv, pfs->pTvItem->hItem, pszNewPath);
        ASSERT(pfs->GetNumber(htv, fQL) == 0);
    }

    pfs = pfs->CreateNew(htv, fQL);
    if (pfs == NULL)
        return 0;
    ASSERT(pfs == pfs->GetFirst(htv, fQL));

    pfs->wType = FTYPE_FOLDER;
    if (!pfs->Expand())
        return 0;

    LoadString(g_hInst, fQL ? IDS_LINKS : IDS_FAVFOLDER, pfs->pszName, MAX_PATH);

    pfs->SetTVI();
    pfs->pTvItem->stateMask = pfs->pTvItem->state = TVIS_BOLD;
    pfs->Shrink();

    TreeView_SelectItem(htv, NULL);
    pfs->Add(htv, NULL);
    ASSERT(pfs->pTvItem != NULL && pfs->pTvItem->hItem != NULL);

    for (i = 1; TRUE; i++) {
        pfsCur = pfs->CreateNew(htv, fQL);
        if (pfsCur == NULL)
            break;

        if (pfsCur->Load(i, pszIns, fQL, pszFixPath, pszNewPath, fIgnoreOffline) != S_OK)
            break;

        pfsCur->Add(htv, pfs->pTvItem->hItem);
    }

    // NOTE: (andrewgu) this is an ugly special case when there are no quick links in the ins.
    // it's a brief version of SFav::Load which only loads name and url fields. there are two
    // alternative ways of doing this with SFav::Load. one is to special case the section to
    // IS_STRINGS if extension of pszIns is *.inf, another is to make the section an in-parameter
    // of SFav::Load.
    if (i == 1 && !InsGetBool(IS_BRANDING, fQL ? IK_NOLINKS : IK_NOFAVORITES, FALSE, pszIns))
        for (; TRUE; i++) {
            pfsCur = pfsCur->CreateNew(htv, fQL);
            if (pfsCur == NULL)
                break;

            pfsCur->wType = FTYPE_URL;
            if (!pfsCur->Expand())
                return pfs->GetNumber(htv, fQL);

            *pfsCur->pszIconFile = TEXT('\0');

            wnsprintf(szKey, countof(szKey), fQL ? IK_QUICKLINK_NAME : IK_TITLE_FMT, i);
            InsGetSubstString(fQL ? IS_URL : IS_FAVORITESEX, szKey, pfsCur->pszName, MAX_PATH, pszDefInf);
            if (*pfsCur->pszName == TEXT('\0')) {
                pfsCur->Delete();
                break;
            }
            StrCat(pfsCur->pszName, DOT_URL);

            wnsprintf(szKey, countof(szKey), fQL ? IK_QUICKLINK_URL : IK_URL_FMT, i);
            InsGetSubstString(fQL ? IS_URL : IS_FAVORITESEX, szKey, pfsCur->pszUrl, INTERNET_MAX_URL_LENGTH, pszDefInf);
            ASSERT(*pfsCur->pszUrl != TEXT('\0'));

            pfsCur->SetTVI();
            pfsCur->Shrink();
            pfsCur->Add(htv, pfs->pTvItem->hItem);
        }

    TreeView_Expand(htv, pfs->pTvItem->hItem, TVE_EXPAND);
    return pfs->GetNumber(htv, fQL);
}

INT_PTR CALLBACK addEditFavoriteDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPAEFAVPARAMS paefp;
    LPFAVSTRUC    pfs;
    TCHAR szName[MAX_PATH],
          szIconFile[INTERNET_MAX_URL_LENGTH];
    HWND  hCtrl;
    BOOL  fResult,
          fEnable, fWasEnabled;

    fResult = FALSE;
    switch (message) {
    case WM_INITDIALOG:
        paefp = (LPAEFAVPARAMS)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)paefp);

        //----- Initialize contols -----
        EnableDBCSChars(hDlg, IDE_FAVNAME);
        EnableDBCSChars(hDlg, IDE_FAVURL);
        EnableDBCSChars(hDlg, IDE_FAVICON);

        Edit_LimitText(GetDlgItem(hDlg, IDE_FAVNAME), _MAX_FNAME);
        Edit_LimitText(GetDlgItem(hDlg, IDE_FAVURL),  INTERNET_MAX_URL_LENGTH-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_FAVICON), _MAX_FNAME);

        //----- Initialize SFav structure associated with this dialog -----
        fResult = (paefp == NULL || (paefp->pfs != NULL ? !paefp->pfs->Expand() : TRUE));
        if (fResult) {
            EndDialog(hDlg, IDCANCEL);
            break;
        }
        pfs = paefp->pfs;

        //----- Initialize contols (Part II) -----
        if (paefp->dwPlatformID != PLATFORM_WIN32) {
            EnableWindow(GetDlgItem(hDlg, IDC_FAVICON),       FALSE);
            EnableWindow(GetDlgItem(hDlg, IDE_FAVICON),       FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_FAVICONBROWSE), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_AVAILOFFLINE),  FALSE);
        }
        else
            if (!HasFlag(paefp->dwMode, (IEM_CORP | IEM_PROFMGR)) && pfs->wType == FTYPE_URL)
                EnableWindow(GetDlgItem(hDlg, IDC_AVAILOFFLINE), FALSE);

        if (pfs->wType == FTYPE_FOLDER) {
            EnableWindow(GetDlgItem(hDlg, IDC_FAVURL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDE_FAVURL), FALSE);

            if (paefp->dwPlatformID == PLATFORM_WIN32) {
                EnableWindow(GetDlgItem(hDlg, IDC_FAVICON),       FALSE);
                EnableWindow(GetDlgItem(hDlg, IDE_FAVICON),       FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_FAVICONBROWSE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_AVAILOFFLINE),  FALSE);
            }
            else {
                ASSERT(!IsWindowEnabled(GetDlgItem(hDlg, IDC_FAVICON)));
                ASSERT(!IsWindowEnabled(GetDlgItem(hDlg, IDE_FAVICON)));
                ASSERT(!IsWindowEnabled(GetDlgItem(hDlg, IDC_FAVICONBROWSE)));
                ASSERT(!IsWindowEnabled(GetDlgItem(hDlg, IDC_AVAILOFFLINE)));
            }
        }

        //----- Populate controls -----
        if (pfs->pszName == NULL || *pfs->pszName == TEXT('\0')) {
            UINT nID;

            if (pfs->wType == FTYPE_URL)
                nID = (!paefp->fQL ? IDS_NEW : IDS_NEWQL);

            else {
                ASSERT(pfs->wType == FTYPE_FOLDER);
                nID = IDS_NEWFOLDER;
            }

            LoadString(g_hInst, nID, pfs->pszName, MAX_PATH);
        }
        SetDlgItemText(hDlg, IDE_FAVNAME, pfs->pszName);

        if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_FAVURL)))
            ;
        else {
            if (pfs->pszUrl == NULL || *pfs->pszUrl == TEXT('\0'))
                StrCpy(pfs->pszUrl, TEXT("http://www."));

            SetDlgItemText(hDlg, IDE_FAVURL, pfs->pszUrl);
        }

        if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_FAVICON)))
            ;
        else
            if (pfs->pszIconFile != NULL && *pfs->pszIconFile != TEXT('\0'))
                SetDlgItemText(hDlg, IDE_FAVICON, pfs->pszIconFile);

        if (!IsWindowEnabled(GetDlgItem(hDlg, IDC_AVAILOFFLINE)))
            ;
        else
            if (pfs->fOffline)
                CheckDlgButton(hDlg, IDC_AVAILOFFLINE, BST_CHECKED);

        fResult = TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDE_FAVNAME:
        case IDE_FAVURL:
        case IDE_FAVICON:
            switch (HIWORD(wParam)) {
            case EN_CHANGE:
                paefp = (LPAEFAVPARAMS)GetWindowLongPtr(hDlg, DWLP_USER);

                hCtrl       = GetDlgItem(hDlg, IDOK);
                fWasEnabled = IsWindowEnabled(hCtrl);

                fEnable = (GetWindowTextLength(GetDlgItem(hDlg, IDE_FAVNAME)) > 0);
                if (paefp->pfs->wType == FTYPE_URL)
                    fEnable &= (GetWindowTextLength(GetDlgItem(hDlg, IDE_FAVURL)) > 0);

                if (fEnable != fWasEnabled)
                    EnableWindow(hCtrl, fEnable);

                fResult = TRUE;
                break;
            }
            break;

        case IDC_FAVICONBROWSE:
            GetDlgItemText(hDlg, IDE_FAVICON, szIconFile, countof(szIconFile));

            if (!BrowseForFile(hDlg, szIconFile, countof(szIconFile), GFN_ICO))
                break;

            SetDlgItemText(hDlg, IDE_FAVICON, szIconFile);
            fResult = TRUE;
            break;

        case IDOK:
            paefp = (LPAEFAVPARAMS)GetWindowLongPtr(hDlg, DWLP_USER);

            if (!CheckField(hDlg, IDE_FAVNAME, FC_NONNULL | FC_PATH, PIVP_FILENAME_ONLY)) {
                fResult = FALSE;
                break;
            }

            if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_FAVURL)))
                ;
            else
                if (!CheckField(hDlg, IDE_FAVURL, FC_NONNULL | FC_URL)) {
                    fResult = FALSE;
                    break;
                }

            if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_FAVICON)))
                ;
            else
                if (!CheckField(hDlg, IDE_FAVICON, FC_URL | FC_FILE | FC_EXISTS)) {
                    fResult = FALSE;
                    break;
                }

            GetDlgItemText(hDlg, IDE_FAVNAME, szName, countof(szName));
            StrRemoveWhitespace(szName);
            pfs = findByName(paefp->htv, paefp->hti, szName);
            if (pfs != NULL && pfs != paefp->pfs) {
                HWND hCtrl;

                ErrorMessageBox(paefp->hwndErrorParent, IDS_FAV_ERR_DUPLICATE);
                hCtrl = GetDlgItem(hDlg, IDE_FAVNAME);
                Edit_SetSel(hCtrl, 0, -1);
                SetFocus(hCtrl);

                fResult = FALSE;
                break;
            }

            pfs = paefp->pfs;                   // reassign pfs back to paefp->pfs
            ASSERT(pfs->pszName != NULL);
            StrCpy(pfs->pszName, szName);

            if (pfs->pszUrl != NULL)
                if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_FAVURL)))
                    *pfs->pszUrl = TEXT('\0');

                else {
                    GetDlgItemText(hDlg, IDE_FAVURL, pfs->pszUrl, INTERNET_MAX_URL_LENGTH);
                    StrRemoveWhitespace(pfs->pszUrl);
                }

            if (pfs->pszIconFile != NULL)
                if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_FAVICON)))
                    *pfs->pszIconFile = TEXT('\0');

                else {
                    GetDlgItemText(hDlg, IDE_FAVICON, szIconFile, countof(szIconFile));
                    StrRemoveWhitespace(szIconFile);

                    ASSERT(paefp->pszExtractPath != NULL);

                    if (*pfs->pszIconFile != TEXT('\0') && StrCmpI(szIconFile, pfs->pszIconFile) != 0)
                    {
                        if (PathIsPrefix(paefp->pszPrevExtractPath, pfs->pszIconFile))
                            DeleteFile(pfs->pszIconFile);
                        else
                            DeleteFileInDir(pfs->pszIconFile, paefp->pszExtractPath);
                    }
                    
                    extractIcon(szIconFile, 1, paefp->pszExtractPath, pfs->pszIconFile, INTERNET_MAX_URL_LENGTH);
                }

            pfs->fOffline = IsWindowEnabled(GetDlgItem(hDlg, IDC_AVAILOFFLINE)) &&
                            (IsDlgButtonChecked(hDlg, IDC_AVAILOFFLINE) == BST_CHECKED);

            pfs->SetTVI();
            EndDialog(hDlg, IDOK);
            fResult = TRUE;
            break;

        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            fResult = TRUE;
            break;
        }
        break;

    case WM_DESTROY:
        paefp = (LPAEFAVPARAMS)GetWindowLongPtr(hDlg, DWLP_USER);

        if (paefp != NULL && paefp->pfs != NULL)
            paefp->pfs->Shrink();
        break;
    }

    return fResult;
}


LPFAVSTRUC getItem(HWND htv, HTREEITEM hti)
{
    LPFAVSTRUC pfsResult;
    TV_ITEM    tvi;

    if (htv == NULL || hti == NULL)
        return NULL;

    ZeroMemory(&tvi, sizeof(tvi));
    tvi.mask  = TVIF_PARAM;
    tvi.hItem = hti;
    TreeView_GetItem(htv, &tvi);

    pfsResult = (LPFAVSTRUC)tvi.lParam;
    if (pfsResult == NULL || pfsResult->pTvItem == NULL || pfsResult->pTvItem->hItem == NULL)
        return NULL;
    ASSERT(pfsResult->pTvItem->hItem == hti);

    return pfsResult;
}

LPFAVSTRUC getFolderItem(HWND htv, HTREEITEM hti)
{
    LPFAVSTRUC pfsResult;

    if (htv == NULL || hti == NULL)
        return NULL;

    pfsResult = getItem(htv, hti);
    if (pfsResult == NULL)
        return NULL;

    if (pfsResult->wType != FTYPE_FOLDER) {
        pfsResult = getItem(htv, TreeView_GetParent(htv, hti));
        if (pfsResult == NULL)
            return NULL;
    }
    ASSERT(pfsResult->wType == FTYPE_FOLDER);

    return pfsResult;
}

LPFAVSTRUC findByName(HWND htv, HTREEITEM hti, LPCTSTR pszName)
{
    LPFAVSTRUC pfs;
    HTREEITEM  htiCur;
    TCHAR      szFolders[MAX_PATH];
    LPTSTR     pszFile;

    if (pszName == NULL)
        return NULL;

    StrCpy(szFolders, pszName);
    pszFile = PathFindFileName(szFolders);

    if (pszFile == szFolders)
        pfs = getFolderItem(htv, hti);

    else {
        *(pszFile-1) = TEXT('\0');
        pszName = pszFile;

        pfs = findPath(htv, hti, szFolders);
    }

    if (pfs == NULL || pfs->pTvItem == NULL || pfs->pTvItem->hItem == NULL)
        return NULL;

    for (htiCur = TreeView_GetChild(htv, pfs->pTvItem->hItem);
         htiCur != NULL;
         htiCur = TreeView_GetNextSibling(htv, htiCur)) {

        pfs = getItem(htv, htiCur);
        if (pfs == NULL || pfs->pTvItem == NULL || pfs->pTvItem->hItem == NULL)
            return NULL;

        if (StrCmpI(pfs->pszName, pszName) == 0)
            break;
    }

    return (htiCur != NULL ? pfs : NULL);
}

LPFAVSTRUC findPath(HWND htv, HTREEITEM hti, LPCTSTR pszFolders)
{
    LPFAVSTRUC pfsFirst,
               pfsCur;
    HTREEITEM  htiCur;
    TCHAR      szPathChunk[MAX_PATH];
    LPCTSTR    pszCur, pszNext;

    pfsFirst = pfsFirst->GetFirst(htv);
    if (pfsFirst == NULL)
        return NULL;

    if (hti != NULL) {
        pfsCur = getFolderItem(htv, hti);
        if (pfsCur == NULL)
            return NULL;
    }
    else
        pfsCur = pfsFirst;

    if (pfsCur->pTvItem == NULL || pfsCur->pTvItem->hItem == NULL)
        return NULL;

    if (pszFolders == NULL)
        return pfsCur;

    htiCur = pfsCur->pTvItem->hItem;
    for (pszCur = pszFolders, pszNext = PathFindNextComponent(pszCur);
         pszNext != NULL;
         pszCur = pszNext,    pszNext = PathFindNextComponent(pszCur)) {

        ASSERT(pszNext-1 > pszCur);
        StrCpyN(szPathChunk, pszCur, (int)(pszNext-pszCur) + (*pszNext != TEXT('\0') ? 0 : 1));

        // determine if there is an object already for this path chunk
        pfsCur = findByName(htv, htiCur, szPathChunk);
        if (pfsCur == NULL                ||
            pfsCur->wType != FTYPE_FOLDER ||
            pfsCur->pTvItem == NULL || pfsCur->pTvItem->hItem == NULL)
            return NULL;
    }

    return (pszNext == NULL ? pfsCur : NULL);
}

HRESULT isFavoriteItem(HWND htv, HTREEITEM hti)
{
    LPFAVSTRUC pfs;
    HTREEITEM  htiCur, htiNext;

    if (htv == NULL || hti == NULL)
        return E_INVALIDARG;

    for (htiCur = TreeView_GetParent(htv, hti), htiNext = TreeView_GetParent(htv, htiCur);
         htiNext != NULL;
         htiCur = htiNext, htiNext = TreeView_GetParent(htv, htiCur))
        ;

    if (htiCur == NULL)
        htiCur = hti;

    pfs = getItem(htv, htiCur);
    if (pfs == NULL)
        return E_FAIL;

    return (pfs == pfs->GetFirst(htv) ? S_OK : S_FALSE);
}

LPFAVSTRUC createFolderItems(HWND htv, HTREEITEM hti, LPCTSTR pszFolders)
{
    LPFAVSTRUC pfs;
    HTREEITEM  htiCur;
    TCHAR      szPathChunk[MAX_PATH];
    LPCTSTR    pszCur, pszNext;

    if (pszFolders == NULL)
        return NULL;

    pfs = getFolderItem(htv, hti);
    if (pfs == NULL)
        return NULL;

    if (pfs->pTvItem == NULL || pfs->pTvItem->hItem == NULL)
        return NULL;

    htiCur = pfs->pTvItem->hItem;
    for (pszCur = pszFolders, pszNext = PathFindNextComponent(pszCur);
         pszNext != NULL;
         pszCur = pszNext,    pszNext = PathFindNextComponent(pszCur)) {

        ASSERT(pszNext-1 > pszCur);
        StrCpyN(szPathChunk, pszCur, (int)(pszNext-pszCur) + (*pszNext != TEXT('\0') ? 0 : 1));

        // determine if there is an object already for this path chunk
        pfs = findByName(htv, htiCur, szPathChunk);
        if (pfs != NULL) {
            if (pfs->wType != FTYPE_FOLDER)
                return NULL;

            if (pfs->pTvItem == NULL || pfs->pTvItem->hItem == NULL)
                return NULL;

            htiCur = pfs->pTvItem->hItem;
            continue;
        }

        // create this path chunk as SFav object
        pfs = pfs->CreateNew(htv);
        if (pfs == NULL)
            return NULL;

        pfs->wType = FTYPE_FOLDER;
        if (!pfs->Expand())
            return NULL;

        StrCpy(pfs->pszName, szPathChunk);
        pfs->SetTVI();
        pfs->Shrink();
        pfs->Add(htv, htiCur);

        ASSERT(pfs->pTvItem != NULL && pfs->pTvItem->hItem != NULL);
        htiCur = pfs->pTvItem->hItem;
    }

    return pfs;
}

BOOL importPath(HWND htv, HTREEITEM htiFrom, HTREEITEM *phtiAfter)
{
    LPFAVSTRUC      pfs;
    TV_INSERTSTRUCT tvins;
    TV_ITEM         tvi;
    HTREEITEM       htiFromCur, htiToCur,
                    htiParent,  htiChild,
                    *phtiQueueFrom, *phtiQueueTo;
    HRESULT         hr;
    UINT            nNumber,
                    nFromHead, nFromTail,
                    nToHead,   nToTail;
    BOOL            fQL,
                    fResult;

    if (phtiAfter == NULL || *phtiAfter == NULL)
        return FALSE;

    hr = isFavoriteItem(htv, htiFrom);
    if (FAILED(hr))
        return FALSE;
    fQL = (hr != S_OK);

    // REVIEW: (andrewgu) actually, if we are to support this at all there needs to be a better
    // default.
    pfs = pfs->GetFirst(htv, fQL);
    if (pfs == NULL || pfs->pTvItem == NULL || pfs->pTvItem->hItem == NULL)
        return FALSE;

    if (htiFrom == NULL) {
        htiFrom = pfs->pTvItem->hItem;
        ASSERT(*phtiAfter != TVI_FIRST);
    }

    fResult   = FALSE;
    nNumber   = pfs->GetNumber(htv, fQL);
    nFromHead = nFromTail = 0;
    nToHead   = nToTail   = 0;

    // intialize queues
    phtiQueueTo = NULL;
    phtiQueueFrom = new HTREEITEM[nNumber];
    if (phtiQueueFrom == NULL)
        goto Exit;
    ZeroMemory(phtiQueueFrom, sizeof(HTREEITEM) * nNumber);

    phtiQueueTo = new HTREEITEM[nNumber];
    if (phtiQueueTo == NULL)
        goto Exit;
    ZeroMemory(phtiQueueTo, sizeof(HTREEITEM) * nNumber);

    // put first element into the From queue, migrate it over
    *(phtiQueueFrom + nFromTail++) = htiFrom;

    ZeroMemory(&tvi, sizeof(tvi));
    tvi.mask  = TVIF_CHILDREN | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_STATE;
    tvi.hItem = htiFrom;
    TreeView_GetItem(htv, &tvi);

    pfs = (LPFAVSTRUC)tvi.lParam;
    if (pfs == NULL || pfs->pTvItem == NULL || pfs->pTvItem->hItem == NULL)
        goto Exit;
    tvi.mask      |= TVIF_TEXT;
    tvi.hItem      = NULL;
    tvi.pszText    = pfs->pTvItem->pszText;
    tvi.cchTextMax = StrLen(pfs->pTvItem->pszText) + 1;

    if (*phtiAfter == TVI_FIRST || *phtiAfter == TVI_LAST)
        htiParent = TreeView_GetParent(htv, htiFrom);
    else
        htiParent = TreeView_GetParent(htv, *phtiAfter);

    ZeroMemory(&tvins, sizeof(tvins));
    tvins.hParent      = htiParent;
    tvins.hInsertAfter = *phtiAfter;
    CopyMemory(&tvins.item, &tvi, sizeof(tvi));
    pfs->pTvItem->hItem = TreeView_InsertItem(htv, &tvins);

    pfs->pTvItem->mask = TVIF_HANDLE | TVIF_STATE;
    TreeView_GetItem(htv, pfs->pTvItem);

    ZeroMemory(&tvi, sizeof(tvi));
    tvi.mask   = TVIF_PARAM;
    tvi.hItem  = htiFrom;
    tvi.lParam = NULL;
    TreeView_SetItem(htv, &tvi);

    *(phtiQueueTo + nToTail++) = pfs->pTvItem->hItem;

    // breadth-first graph traversion, non-recursive version
    while (nFromHead < nFromTail) {
        htiFromCur = *(phtiQueueFrom + nFromHead++);
        htiToCur   = *(phtiQueueTo   + nToHead++);
        ASSERT(htiFromCur != NULL && htiToCur != NULL);

        for (htiChild = TreeView_GetChild(htv, htiFromCur);
             htiChild != NULL;
             htiChild = TreeView_GetNextSibling(htv, htiChild)) {

            *(phtiQueueFrom + nFromTail++) = htiChild;
            ASSERT(nFromTail < nNumber);

            ZeroMemory(&tvi, sizeof(tvi));
            tvi.mask  = TVIF_CHILDREN | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_STATE;
            tvi.hItem = htiChild;
            TreeView_GetItem(htv, &tvi);

            pfs = (LPFAVSTRUC)tvi.lParam;
            if (pfs == NULL || pfs->pTvItem == NULL || pfs->pTvItem->hItem == NULL)
                goto Exit;
            tvi.mask      |= TVIF_TEXT;
            tvi.hItem      = NULL;
            tvi.pszText    = pfs->pTvItem->pszText;
            tvi.cchTextMax = StrLen(pfs->pTvItem->pszText) + 1;

            ZeroMemory(&tvins, sizeof(tvins));
            tvins.hParent      = htiToCur;
            tvins.hInsertAfter = TVI_LAST;
            CopyMemory(&tvins.item, &tvi, sizeof(tvi));
            pfs->pTvItem->hItem = TreeView_InsertItem(htv, &tvins);

            pfs->pTvItem->mask = TVIF_HANDLE | TVIF_STATE;
            TreeView_GetItem(htv, pfs->pTvItem);

            ZeroMemory(&tvi, sizeof(tvi));
            tvi.mask   = TVIF_PARAM;
            tvi.hItem  = htiChild;
            tvi.lParam = NULL;
            TreeView_SetItem(htv, &tvi);

            *(phtiQueueTo + nToTail++) = pfs->pTvItem->hItem;
            ASSERT(nToTail < nNumber);
        }
    }

    ASSERT(nFromHead == nFromTail && nToHead == nFromHead && nToHead == nToTail);
    fResult = TRUE;

    // NOTE: (andrewgu) nFromHead is used is a mere counter here.
    for (nFromHead = 0; nFromHead < nNumber; nFromHead++) {
        if (*(phtiQueueFrom + nFromHead) == NULL)
            break;

        ZeroMemory(&tvi, sizeof(tvi));
        tvi.mask  = TVIF_STATE;
        tvi.hItem = *(phtiQueueFrom + nFromHead);
        TreeView_GetItem(htv, &tvi);

        if (HasFlag(tvi.state, TVIS_EXPANDED))
            TreeView_Expand(htv, *(phtiQueueTo + nFromHead), TVE_EXPAND);
    }

Exit:
    *phtiAfter = fResult ? *phtiQueueTo : NULL;

    delete[] phtiQueueFrom;
    delete[] phtiQueueTo;

    return fResult;
}

void importPath(HWND htv, HTREEITEM hti, LPCTSTR pszFilesPath, LPCTSTR pszExtractPath, LPCTSTR pszReserved /*= NULL*/)
{
    static LPCTSTR s_pszBasePath;
    static BOOL    s_fMaxReached;

    ISubscriptionMgr2 *psm;
    WIN32_FIND_DATA   fd;
    LPFAVSTRUC pfs;
    TCHAR      szPath[MAX_PATH],
               szLinksPath[MAX_PATH];
    HANDLE     hFindFile;
    HRESULT    hr;
    BOOL       fQL,
               fIgnoreOffline;

    //----- Setup globals -----
    if (NULL == pszReserved) {
        s_pszBasePath = pszFilesPath;
        s_fMaxReached = FALSE;
    }

    if (s_fMaxReached)
        return;

    if (NULL == pszFilesPath)
        return;

    hr = isFavoriteItem(htv, hti);
    if (FAILED(hr))
        return;
    fQL = (S_OK != hr);

    szLinksPath[0] = TEXT('\0');
    if (!fQL)
        getLinksPath(szLinksPath);

    fIgnoreOffline = FALSE;
    psm            = NULL;

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *)&psm);
    if (FAILED(hr))
        fIgnoreOffline = TRUE;

    PathCombine(szPath, pszFilesPath, TEXT("*.*"));
    hFindFile = FindFirstFile(szPath, &fd);
    if (INVALID_HANDLE_VALUE == hFindFile)
        return;

    do {
        PathCombine(szPath, pszFilesPath, fd.cFileName);

        if (HasFlag(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            // skip "." and ".." sub-directories
            if (0 == StrCmp(fd.cFileName, TEXT(".")) || 0 == StrCmp(fd.cFileName, TEXT("..")))
                continue;

            // skip folders if importing under quick links
            if (fQL)
                continue;

            // magic trick for quick links
            if (0 == StrCmpI(szPath, szLinksPath)) {
                pfs = pfs->GetFirst(htv, TRUE);
                if (NULL == pfs || NULL == pfs->pTvItem || NULL == pfs->pTvItem->hItem)
                    continue;

                importPath(htv, pfs->pTvItem->hItem, szPath, pszExtractPath, szPath);
                continue;
            }

            importPath(htv, hti, szPath, pszExtractPath, s_pszBasePath);
        }
        else { /* it's a file */
            // skip all file with extensions other than *.url
            if (!PathIsExtension(fd.cFileName, DOT_URL))
                continue;

            if (NULL == pszReserved)
                pszReserved = pszFilesPath;
            ASSERT(StrLen(pszReserved) <= StrLen(pszFilesPath));

            // determine if there is an object already for this
            pfs = findByName(htv, hti, &szPath[StrLen(pszReserved) + 1]);
            if (NULL != pfs) {
                if (FTYPE_URL != pfs->wType   ||
                    NULL      == pfs->pTvItem || NULL == pfs->pTvItem->hItem)
                    break;

                pfs->Free(htv, fQL, pszExtractPath);
            }

            pfs = pfs->CreateNew(htv, fQL);
            if (NULL == pfs) {
                if (pfs->GetNumber(htv, fQL) == pfs->GetMaxNumber(fQL)) {
                    ErrorMessageBox(GetParent(htv), IDS_FAV_ERR_NOTALL);
                    s_fMaxReached = TRUE;
                }
                break;
            }

            hr = pfs->Load(&szPath[StrLen(pszReserved) + (PathHasBackslash(pszReserved) ? 0 : 1)], szPath, pszExtractPath, psm, fIgnoreOffline);
            if (FAILED(hr))
                break;

            pfs->Add(htv, hti);
        }
    } while (!s_fMaxReached && FindNextFile(hFindFile, &fd));
    FindClose(hFindFile);
}

int exportItems(HWND htv, HTREEITEM hti, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fFixUpPath /*= TRUE */)
{
    struct SVisited {
        HTREEITEM hti;
        BOOL      fVisited;
    } *pVisited;

    LPFAVSTRUC pfs;
    HTREEITEM  htiCur, htiChild,
               *phtiStack;
    HRESULT    hr;
    UINT       i, j, nNumber,
               nStack;
    BOOL       fQL;

    if (pszIns == NULL)
        return -1;

    hr = isFavoriteItem(htv, hti);
    if (FAILED(hr))
        return -1;
    fQL = (hr != S_OK);

    pfs = getFolderItem(htv, hti);
    if (pfs == NULL || pfs->pTvItem == NULL || pfs->pTvItem->hItem == NULL)
        return -1;

    nNumber = pfs->GetNumber(htv, fQL);
    nStack  = 0;

    // intialize stack
    phtiStack = new HTREEITEM[nNumber];
    if (phtiStack == NULL)
        return -1;
    ZeroMemory(phtiStack, sizeof(HTREEITEM) * nNumber);

    *phtiStack = pfs->pTvItem->hItem;
    nStack++;

    // initialize visited array
    pVisited = new SVisited[nNumber];
    if (pVisited == NULL)
    {
        delete [] phtiStack;
        return -1;
    }
    for (i = 0; pfs != NULL; i++, pfs = pfs->GetNext(htv, fQL)) {
        (pVisited + i)->hti      = (pfs->pTvItem != NULL && pfs->pTvItem->hItem != NULL) ? pfs->pTvItem->hItem : NULL;
        (pVisited + i)->fVisited = FALSE;
    }
    ASSERT(i == nNumber);

    // mark root as visited
    for (i = 0; i < nNumber; i++)
        if ((pVisited + i)->hti == *phtiStack)
            break;
    ASSERT(i < nNumber);
    (pVisited + i)->fVisited = TRUE;

    for (j = 1; nStack > 0; ) {
        htiCur = *(phtiStack + nStack-1);

        // determine if there are non-visited children
        for (htiChild = TreeView_GetChild(htv, htiCur);
             htiChild != NULL;
             htiChild = TreeView_GetNextSibling(htv, htiChild)) {

            for (i = 0; i < nNumber; i++)
                if ((pVisited + i)->hti == htiChild)
                    break;
            if (i < nNumber && !(pVisited + i)->fVisited)
                break;
        }

        if (htiChild != NULL) {
            // add non-visited child to the stack
            *(phtiStack + nStack) = htiChild;
            nStack++;

            ASSERT((pVisited + i)->hti == htiChild);
            (pVisited + i)->fVisited = TRUE;

            pfs = getItem(htv, htiChild);
            if (pfs == NULL || pfs->wType != FTYPE_URL)
                continue;

            pfs->Save(htv, j++, pszIns, pszExtractPath, fQL, fFixUpPath);
        }
        else
            // all visited -> pop
            *(phtiStack + --nStack) = NULL;
    }

    delete[] phtiStack;
    delete[] pVisited;

    return j;
}

BOOL extractIcon(LPCTSTR pszIconFile, int iIconIndex, LPCTSTR pszExtractPath, LPTSTR pszResult, UINT cchResult)
{
    TCHAR   szExtractedFile[MAX_PATH];
    HRESULT hr;
    UINT    i;
    BOOL    fURL;

    if (pszIconFile == NULL || pszExtractPath == NULL || pszResult == NULL)
        return FALSE;
    *pszResult = TEXT('\0');

    if (cchResult == 0)
        cchResult = MAX_PATH;

    fURL = PathIsURL(pszIconFile);
    if (fURL) {
        PathCombine(szExtractedFile, pszExtractPath, PathFindFileName(pszIconFile));

        hr = URLDownloadToFile(NULL, pszIconFile, szExtractedFile, 0L, NULL);
        if (FAILED(hr))
            return FALSE;
    }
    else {
        static LPCTSTR rgpszCopyExt[] = {
            DOT_ICO,
            DOT_URL
        };
        static LPCTSTR rgpszExtractExt[] = {
            DOT_EXE,
            DOT_DLL
        };

        IStream  *pStm;
        IPicture *pPic;
        PICTDESC pd;
        LPCTSTR  pszExt;
        LPVOID   pIcon;
        HANDLE   hFile;
        HGLOBAL  hmem;
        HICON    hicon;
        HRESULT  hr;
        DWORD    dwWritten;
        LONG     cbIcon;

        // if it's an icon file just copy it
        pszExt = PathFindExtension(pszIconFile);
        for (i = 0; i < countof(rgpszCopyExt); i++)
            if (StrCmpI(pszExt, rgpszCopyExt[i]) == 0)
                break;
        if (i < countof(rgpszCopyExt)) {
            StrCpy(szExtractedFile, pszIconFile);
            goto Exit;
        }

        // if it doesn't have extension from which icon can be extracted bail out
        for (i = 0; i < countof(rgpszExtractExt); i++)
            if (StrCmpI(pszExt, rgpszExtractExt[i]) == 0)
                break;
        if (i >= countof(rgpszExtractExt))
            return FALSE;

        // extract icons
        ExtractIconEx(pszIconFile, iIconIndex, &hicon, NULL, 1);
        if (hicon == NULL)
            return FALSE;

        hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
        if (FAILED(hr)) {
            DestroyIcon(hicon);
            return FALSE;
        }

        ZeroMemory(&pd, sizeof(pd));
        pd.cbSizeofstruct = sizeof(pd);
        pd.picType        = PICTYPE_ICON;
        pd.icon.hicon     = hicon;

        hr = OleCreatePictureIndirect(&pd, IID_IPicture, TRUE, (LPVOID *)&pPic);
        if (FAILED(hr)) {
            DestroyIcon(hicon);
            return FALSE;
        }

        hr = pPic->SaveAsFile(pStm, TRUE, &cbIcon);
        pPic->Release();
        if (FAILED(hr)) {
            pStm->Release();
            return FALSE;
        }

        // generate a unique icon name
        do {
            GetTempFileName(pszExtractPath, PREFIX_ICON, 0, szExtractedFile);
            DeleteFile(szExtractedFile);
            PathRenameExtension(szExtractedFile, DOT_ICO);
        } while (PathFileExists(szExtractedFile));

        hFile = CreateFile(szExtractedFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            pStm->Release();
            return FALSE;
        }

        GetHGlobalFromStream(pStm, &hmem);
        ASSERT(hmem != NULL);
        pIcon = GlobalLock(hmem);
        ASSERT(pIcon != NULL);

        WriteFile(hFile, pIcon, cbIcon, &dwWritten, NULL);
        CloseHandle(hFile);

        GlobalUnlock(hmem);
        pStm->Release();
    }

Exit:
    if (cchResult <= (UINT)StrLen(szExtractedFile))
        return FALSE;

    StrCpy(pszResult, szExtractedFile);
    return TRUE;
}

LPCTSTR getLinksPath(LPTSTR pszPath, UINT cchPath /*= 0*/)
{
    LPITEMIDLIST pidl;
    TCHAR        szPath[MAX_PATH],
                 szLinks[MAX_PATH];
    HRESULT      hr;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (cchPath == 0)
        cchPath = MAX_PATH;

    hr = SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &pidl);
    if (FAILED(hr))
        return NULL;

    hr = SHGetPathFromIDList(pidl, szPath) ? S_OK : E_FAIL;
    CoTaskMemFree(pidl);
    if (FAILED(hr))
        return NULL;
    ASSERT(szPath[0] != TEXT('\0'));

    szLinks[0] = TEXT('\0');
    LoadString(g_hInst, IDS_LINKS, szLinks, countof(szLinks));
    if (szLinks[0] == TEXT('\0'))
        return NULL;

    PathAppend(szPath, szLinks);
    if (cchPath <= (UINT)StrLen(szPath))
        return NULL;

    StrCpy(pszPath, szPath);
    return pszPath;
}

LPTSTR encodeFavName(LPTSTR pszFavName, LPCTSTR pszIns)
{
    TCHAR  szWrk[MAX_PATH],
           chWrk;
    LPTSTR pszFrom;
    LPTSTR pszTo;
    BOOL   fEncodeFavs;

    StrCpy(szWrk, pszFavName);
    pszFrom     = szWrk;
    pszTo       = pszFavName;
    fEncodeFavs = FALSE;

    while (*pszFrom != TEXT('\0')) {
        switch(chWrk = *pszFrom++) {
        case TEXT('['):
            fEncodeFavs = TRUE;
            *pszTo++ = TEXT('%');
            *pszTo++ = TEXT('(');
            break;

        case TEXT(']'):
            fEncodeFavs = TRUE;
            *pszTo++ = TEXT('%');
            *pszTo++ = TEXT(')');
            break;

        case TEXT('='):
            fEncodeFavs = TRUE;
            *pszTo++ = TEXT('%');
            *pszTo++ = TEXT('-');
            break;

        case TEXT('%'):
            fEncodeFavs = TRUE;
            *pszTo++ = TEXT('%');
            *pszTo++ = TEXT('%');
            break;

        default:
            *pszTo++ = chWrk;
            break;
        }
    }

    *pszTo = TEXT('\0');

    InsWriteBool(IS_BRANDING, IK_FAVORITES_ENCODE, fEncodeFavs, pszIns);
    return pszFavName;
}

LPTSTR decodeFavName(LPTSTR pszFavName, LPCTSTR pszIns)
{
    TCHAR  szWrk[MAX_PATH],
           chWrk;
    LPTSTR pszFrom;
    LPTSTR pszTo;

    if (!InsGetBool(IS_BRANDING, IK_FAVORITES_ENCODE, FALSE, pszIns))
        return pszFavName;

    StrCpy(szWrk, pszFavName);
    pszFrom = szWrk;
    pszTo   = pszFavName;
    while((*pszFrom != TEXT('\0')) && ((chWrk = *pszFrom++) != TEXT('\0'))) {
        if (chWrk != TEXT('%'))
            *pszTo++ = chWrk;

        else {
            switch(chWrk = *pszFrom++) {
            case TEXT('('): *pszTo++ = TEXT('['); break;
            case TEXT(')'): *pszTo++ = TEXT(']'); break;
            case TEXT('-'): *pszTo++ = TEXT('='); break;
            case TEXT('%'): *pszTo++ = TEXT('%'); break;

            case TEXT('/'):
#ifndef _UNICODE
                *pszTo++ = IsDBCSLeadByte(*(pszTo - 1)) ? TEXT('\\') : TEXT('/');
#else
                *pszTo++ = TEXT('/');
#endif
                break;

            default:
                *pszTo++ = TEXT('%');
                *pszTo++ = chWrk;
                break;
            }
        }
    }

    *pszTo = TEXT('\0');
    return pszFavName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\favsproc.h ===
#ifndef __FAVORITES_H_
#define __FAVORITES_H_

#include <commctrl.h>
#include <subsmgr.h>

#define NUM_FAVS 200
#define NUM_LINKS 50

#define FTYPE_UNUSED 0
#define FTYPE_FOLDER 1
#define FTYPE_URL    2

#define FF_DEFAULT 0x0000
#define FF_NAME    0x0001
#define FF_PATH    0x0002
#define FF_URL     0x0004
#define FF_ICON    0x0008
#define FF_TVI     0x0010
#define FF_ALL     0x001F

struct SFav
{
// Constructors and destructors
public:
    SFav();
    ~SFav();

// Attiributes
public:
    WORD wType;

    LPTSTR pszName;
    LPTSTR pszPath;
    LPTSTR pszUrl;
    LPTSTR pszIconFile;
    BOOL   fOffline;

    LPTV_ITEM pTvItem;

// Properties
public:
    HRESULT Load(UINT nIndex, LPCTSTR pszIns, BOOL fQL = FALSE,
        LPCTSTR pszFixPath = NULL, LPCTSTR pszNewPath = NULL, BOOL fIgnoreOffline = FALSE);
    HRESULT Load(LPCTSTR pszName, LPCTSTR pszFavorite, LPCTSTR pszExtractPath,
        ISubscriptionMgr2 *psm = NULL, BOOL fIgnoreOffline = FALSE);
    HRESULT Add (HWND htv, HTREEITEM hti);
    HRESULT Save(HWND htv, UINT nIndex, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fQL = FALSE,
        BOOL fFixUpPath = TRUE);

    void SetTVI();

// Operations
public:
    static SFav* CreateNew   (HWND htv, BOOL fQL = FALSE);
    static SFav* GetFirst    (HWND htv, BOOL fQL = FALSE);
    SFav*        GetNext     (HWND htv, BOOL fQL = FALSE) const;
    void         Free        (HWND htv, BOOL fQL, LPCTSTR pszExtractPath = NULL);
    static UINT  GetNumber   (HWND htv, BOOL fQL = FALSE);
    static UINT  GetMaxNumber(BOOL fQL = FALSE);

    BOOL Expand(WORD wFlags = FF_DEFAULT);
    void Shrink(WORD wFlags = FF_ALL);
    void Delete(WORD wFlags = FF_ALL);

    BOOL GetPath(HWND htv, LPTSTR pszResult, UINT cchResult = 0) const;
};
typedef SFav FAVSTRUC, *LPFAVSTRUC;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\ieakeng.cpp ===
//
// IEAKENG.CPP
//

#include "precomp.h"


// prototype declarations


// global variables
HINSTANCE g_hInst;
HINSTANCE g_hDLLInst;
DWORD g_dwPlatformId = PLATFORM_WIN32;
BOOL g_fRunningOnNT;

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD dwReason, LPVOID)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
        OSVERSIONINFOA osviA;

        // The DLL is being loaded for the first time by a given process.
        // Perform per-process initialization here.  If the initialization
        // is successful, return TRUE; if unsuccessful, return FALSE.

        // Initialize the global variable holding the hinstance.
        g_hDLLInst = hDLLInst;

        g_hInst = LoadLibrary(TEXT("ieakui.dll"));
        if (g_hInst == NULL)
        {
            TCHAR   szTitle[MAX_PATH],
                    szMsg[MAX_PATH];

            LoadString(g_hDLLInst, IDS_ENGINE_TITLE, szTitle, ARRAYSIZE(szTitle));
            LoadString(g_hDLLInst, IDS_IEAKUI_LOADERROR, szMsg, ARRAYSIZE(szMsg));
            MessageBox(NULL, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
            return FALSE;
        }

        osviA.dwOSVersionInfoSize = sizeof(osviA);
        GetVersionExA(&osviA);
        if (VER_PLATFORM_WIN32_NT == osviA.dwPlatformId)
            g_fRunningOnNT = TRUE;

        DisableThreadLibraryCalls(g_hInst);

        break;
    }

    case DLL_PROCESS_DETACH:
        // The DLL is being unloaded by a given process.  Do any
        // per-process clean up here, such as undoing what was done in
        // DLL_PROCESS_ATTACH.  The return value is ignored.

        if(g_hInst)
            FreeLibrary(g_hInst);

        break;

    case DLL_THREAD_ATTACH:
        // A thread is being created in a process that has already loaded
        // this DLL.  Perform any per-thread initialization here.  The
        // return value is ignored.

        // Initialize the global variable holding the hinstance.
        // NOTE: this is probably taken care of already by DLL_PROCESS_ATTACH.
        g_hDLLInst = hDLLInst;

        break;

    case DLL_THREAD_DETACH:
        // A thread is exiting cleanly in a process that has already
        // loaded this DLL.  Perform any per-thread clean up here.  The
        // return value is ignored.

        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\mccphtt.cpp ===
//
// MCCPHTT.CPP
//

#include "precomp.h"

static BOOL copyHttFileHelper(LPCTSTR pcszInsFile, LPCTSTR pcszHttWorkDir, LPCTSTR pcszHttFile, LPCTSTR pcszHttKey);

BOOL WINAPI CopyHttFileA(LPCSTR pcszInsFile, LPCSTR pcszHttWorkDir, LPCSTR pcszHttFile, LPCSTR pcszHttKey)
{
    USES_CONVERSION;

    return copyHttFileHelper(A2CT(pcszInsFile), A2CT(pcszHttWorkDir), A2CT(pcszHttFile), A2CT(pcszHttKey));
}

BOOL WINAPI CopyHttFileW(LPCWSTR pcwszInsFile, LPCWSTR pcwszHttWorkDir, LPCWSTR pcwszHttFile, LPCWSTR pcwszHttKey)
{
    USES_CONVERSION;

    return copyHttFileHelper(W2CT(pcwszInsFile), W2CT(pcwszHttWorkDir), W2CT(pcwszHttFile), W2CT(pcwszHttKey));
}

static BOOL copyHttFileHelper(LPCTSTR pcszInsFile, LPCTSTR pcszHttWorkDir, LPCTSTR pcszHttFile, LPCTSTR pcszHttKey)
{
    BOOL bRet = FALSE;
    TCHAR szOldHttFile[MAX_PATH];

    if (pcszInsFile == NULL  ||  pcszHttWorkDir == NULL  ||  pcszHttFile == NULL  ||  pcszHttKey == NULL)
        return FALSE;

    // read the old entry for pcszHttKey
    GetPrivateProfileString(DESKTOP_OBJ_SECT, pcszHttKey, TEXT(""), szOldHttFile, ARRAYSIZE(szOldHttFile), pcszInsFile);

    // delete the old htt file and all the imgs, if any, in it from pcszHttWorkDir
    if (*szOldHttFile)
    {
        DeleteHtmlImgs(szOldHttFile, pcszHttWorkDir, NULL, NULL);
        DeleteFileInDir(szOldHttFile, pcszHttWorkDir);

        // clear out the entries in the INS file that correspond to this htt file
        WritePrivateProfileString(DESKTOP_OBJ_SECT, pcszHttKey, NULL, pcszInsFile);
    }

    // copy the htt file and all the imgs, if any, in it to pcszHttWorkDir
    if (*pcszHttFile  &&  CopyFileToDir(pcszHttFile, pcszHttWorkDir))
    {
        CopyHtmlImgs(pcszHttFile, pcszHttWorkDir, NULL, NULL);

        WritePrivateProfileString(DESKTOP_OBJ_SECT, pcszHttKey, pcszHttFile, pcszInsFile);
        WritePrivateProfileString(DESKTOP_OBJ_SECT, OPTION, TEXT("1"), pcszInsFile);

        bRet = TRUE;
    }

    return (*pcszHttFile == TEXT('\0'))  ||  bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\ieakeng.h ===
//
// IEAKENG.H
//

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


// macro definitions


// type definitions

// seccerts.cpp
typedef BOOL WINCRYPT32API (WINAPI * CERTGETENHANCEDKEYUSAGE)(PCCERT_CONTEXT, DWORD, PCERT_ENHKEY_USAGE, DWORD *);
typedef HCERTSTORE WINCRYPT32API (WINAPI * CERTOPENSTORE)(LPCSTR, DWORD, HCRYPTPROV, DWORD, const void *);
typedef HCERTSTORE WINCRYPT32API (WINAPI * CERTOPENSYSTEMSTOREA)(HCRYPTPROV, LPCSTR);
typedef BOOL WINCRYPT32API (WINAPI * CERTCLOSESTORE)(HCERTSTORE, DWORD);
typedef PCCERT_CONTEXT WINCRYPT32API (WINAPI * CERTENUMCERTIFICATESINSTORE)(HCERTSTORE, PCCERT_CONTEXT);
typedef BOOL WINCRYPT32API (WINAPI * CERTADDCERTIFICATECONTEXTTOSTORE)(HCERTSTORE, PCCERT_CONTEXT, DWORD, PCCERT_CONTEXT *);
typedef BOOL WINCRYPT32API (WINAPI * CERTSAVESTORE)(HCERTSTORE, DWORD, DWORD, DWORD, void *, DWORD);


// prototype declarations

// sitecert.cpp
BOOL CopyStore(LPCSTR lpSrc, LPCSTR lpDst, BOOL fSrcSysStore, BOOL fDstSysStore);


// extern declarations

// ieakeng.cpp
extern HINSTANCE g_hInst;
extern HINSTANCE g_hDLLInst;
extern DWORD g_dwPlatformId;
extern BOOL g_fUseShortFileName;
extern BOOL g_fRunningOnNT;

// seccerts.cpp
extern CERTGETENHANCEDKEYUSAGE pfnCertGetEnhancedKeyUsage;
extern CERTOPENSTORE pfnCertOpenStore;
extern CERTOPENSYSTEMSTOREA pfnCertOpenSystemStoreA;
extern CERTCLOSESTORE pfnCertCloseStore;
extern CERTENUMCERTIFICATESINSTORE pfnCertEnumCertificatesInStore;
extern CERTADDCERTIFICATECONTEXTTOSTORE pfnCertAddCertificateContextToStore;
extern CERTSAVESTORE pfnCertSaveStore;


#ifdef __cplusplus
}
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_
//
// PCH.H
//
/////////////////////////////////////////////////////////////////////////
//
//  ATL / OLE HACKHACK
//
//  Include <w95wraps.h> before anything else that messes with names.
//  Although everybody gets the wrong name, at least it's *consistently*
//  the wrong name, so everything links.
//
//  NOTE:  This means that while debugging you will see functions like
//  ShellExecuteExWrapW when you expected to see
//  ShellExecuteExW.
//
#include <w95wraps.h>

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <wininet.h>
#include <regstr.h>
#include <advpub.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <wincrypt.h>
#include <inetcpl.h>
#include <inetreg.h>

#include <iedkbrnd.h>
#include "..\ieakutil\ieakutil.h"

#include "..\ieakui\common.h"
#include "..\ieakui\resource.h"
#include "..\ieakui\wizard.h"
#include "..\ieakui\insdll.h"
#include "..\ieakui\legacy.h"

#include "ieakeng.h"
#include "favsproc.h"
#include "exports.h"
#include "utils.h"
#include "resource.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\oe.cpp ===
#include "precomp.h"

static BOOL importLDAPBitmapHelper(LPCTSTR pcszIns, LPCTSTR pcszWorkDir, BOOL fImport);
static BOOL importOEInfoHelper(LPCTSTR pcszIns, LPCTSTR pcszWorkDir, BOOL fImport);
static BOOL encodeSignatureHelper(LPCTSTR pcszFrom, LPTSTR pszTo, BOOL fEncode);
static void decodeSig(LPCTSTR pcszFrom, LPTSTR pszTo);
static void encodeSig(LPCTSTR pcszFrom, LPTSTR pszTo);

BOOL WINAPI ImportLDAPBitmapA(LPCSTR pcszIns, LPCSTR pcszWorkDir, BOOL fImport)
{
    USES_CONVERSION;

    return importLDAPBitmapHelper(A2CT(pcszIns), A2CT(pcszWorkDir), fImport);
}

BOOL WINAPI ImportLDAPBitmapW(LPCWSTR pcwszIns, LPCWSTR pcwszWorkDir, BOOL fImport)
{
    USES_CONVERSION;

    return importLDAPBitmapHelper(W2CT(pcwszIns), W2CT(pcwszWorkDir), fImport);
}

BOOL WINAPI ImportOEInfoA(LPCSTR pcszIns, LPCSTR pcszWorkDir, BOOL fImport)
{
    USES_CONVERSION;

    return importOEInfoHelper(A2CT(pcszIns), A2CT(pcszWorkDir), fImport);
}

BOOL WINAPI ImportOEInfoW(LPCWSTR pcwszIns, LPCWSTR pcwszWorkDir, BOOL fImport)
{
    USES_CONVERSION;

    return importOEInfoHelper(W2CT(pcwszIns), W2CT(pcwszWorkDir), fImport);
}

BOOL WINAPI EncodeSignatureA(LPCSTR pcszFrom, LPSTR pszTo, BOOL fEncode)
{
    LPTSTR pszBuf = (LPTSTR)LocalAlloc(LPTR, 1024 * sizeof(TCHAR));
    BOOL fRet = FALSE;

    USES_CONVERSION;

    if (pszBuf != NULL)
    {
        fRet = encodeSignatureHelper(A2CT(pcszFrom), pszBuf, fEncode);
        T2Abux(pszBuf, pszTo);
    }

    return fRet;
}

BOOL WINAPI EncodeSignatureW(LPCWSTR pcwszFrom, LPWSTR pwszTo, BOOL fEncode)
{
    LPTSTR pszBuf = (LPTSTR)LocalAlloc(LPTR, 1024 * sizeof(TCHAR));
    BOOL fRet = FALSE;

    USES_CONVERSION;

    if (pszBuf != NULL)
    {
        fRet = encodeSignatureHelper(W2CT(pcwszFrom), pszBuf, fEncode);
        T2Wbux(pszBuf, pwszTo);
    }

    LocalFree(pszBuf);  //bug 14001, forgot to free temp buffer
    return fRet;
}

static BOOL importLDAPBitmapHelper(LPCTSTR pcszIns, LPCTSTR pcszWorkDir, BOOL fImport)
{
    TCHAR szLDAPBitmap[MAX_PATH];
    BOOL  fSuccess = TRUE;

    if (pcszIns == NULL || pcszWorkDir == NULL)
        return FALSE;

    if (fImport)
        PathRemovePath(pcszWorkDir);

    GetPrivateProfileString(IS_LDAP, IK_BITMAP, TEXT(""), szLDAPBitmap, countof(szLDAPBitmap), pcszIns);
    if (szLDAPBitmap[0] != TEXT('\0')) {
        if (fImport) {
            ASSERT(PathFileExists(szLDAPBitmap));
            fSuccess = CopyFileToDir(szLDAPBitmap, pcszWorkDir);
        }
        else {
            DeleteFileInDir(szLDAPBitmap, pcszWorkDir);
            WritePrivateProfileString(IS_LDAP, IK_BITMAP, NULL, pcszIns);
        }
    }

    return fSuccess;
}

static BOOL importOEInfoHelper(LPCTSTR pcszIns, LPCTSTR pcszWorkDir, BOOL fImport)
{
    TCHAR szInfopane[INTERNET_MAX_URL_LENGTH],
          szInfopaneBmp[MAX_PATH],
          szHTMLPath[MAX_PATH];
    BOOL  fSuccess;

    if (pcszIns == NULL || pcszWorkDir == NULL)
        return FALSE;

    if (fImport)
        PathRemovePath(pcszWorkDir);

    fSuccess = TRUE;

    GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANE, TEXT(""), szInfopane, countof(szInfopane), pcszIns);
    if (szInfopane[0] != TEXT('\0') && !PathIsURL(szInfopane)) {
        if (fImport) {
            ASSERT(PathFileExists(szInfopane));
            if (CopyFileToDir(szInfopane, pcszWorkDir))
                CopyHtmlImgs(szInfopane, pcszWorkDir, NULL, NULL);
            else
                fSuccess = FALSE;
        }
        else {
            TCHAR szTemp[MAX_PATH];

            PathCombine(szTemp, pcszWorkDir, PathFindFileName(szInfopane));
            if (PathFileExists(szTemp)) {
                DeleteHtmlImgs(szTemp, pcszWorkDir, NULL, NULL);
                DeleteFileInDir(szTemp, pcszWorkDir);
            }
        }
    }

    GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANEBMP, TEXT(""), szInfopaneBmp, countof(szInfopaneBmp), pcszIns);
    if (szInfopaneBmp[0] != TEXT('\0')) {
        if (fImport) {
            ASSERT(PathFileExists(szInfopaneBmp));
            fSuccess = CopyFileToDir(szInfopaneBmp, pcszWorkDir) && fSuccess;
        }
        else
            DeleteFileInDir(szInfopaneBmp, pcszWorkDir);
    }

    GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEMESSAGE, TEXT(""), szHTMLPath, countof(szHTMLPath), pcszIns);
    if (szHTMLPath[0] != TEXT('\0')) {
        if (fImport) {
            ASSERT(PathFileExists(szHTMLPath));
            if (CopyFileToDir(szHTMLPath, pcszWorkDir))
                CopyHtmlImgs(szHTMLPath, pcszWorkDir, NULL, NULL);
            else
                fSuccess = FALSE;
        }
        else {
            TCHAR szTemp[MAX_PATH];

            PathCombine(szTemp, pcszWorkDir, PathFindFileName(szHTMLPath));
            if (PathFileExists(szTemp)) {
                DeleteHtmlImgs(szTemp, pcszWorkDir, NULL, NULL);
                DeleteFileInDir(szTemp, pcszWorkDir);
            }
        }
    }

    if (!fImport) {
        WritePrivateProfileString(IS_INTERNETMAIL, IK_INFOPANE,       NULL, pcszIns);
        WritePrivateProfileString(IS_INTERNETMAIL, IK_INFOPANEBMP,    NULL, pcszIns);
        WritePrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEMESSAGE, NULL, pcszIns);
    }

    return fSuccess;
}

static BOOL encodeSignatureHelper(LPCTSTR pcszFrom, LPTSTR pszTo, BOOL fEncode)
{
    if (fEncode)
        encodeSig(pcszFrom, pszTo);
    else
        decodeSig(pcszFrom, pszTo);

    return TRUE;
}


static void decodeSig(LPCTSTR pszFrom, LPTSTR pszTo)
{
    if (pszFrom == NULL || pszTo == NULL)
        return;

    while (*pszFrom != TEXT('\0'))
#ifndef UNICODE
        if (IsDBCSLeadByte(*pszFrom)) {
            *pszTo++ = *pszFrom++;
            *pszTo++ = *pszFrom++;
        }
        else
#endif
            if (*pszFrom != TEXT('\\'))
                *(pszTo++) = *(pszFrom++);
            else {
                pszFrom++;
                if (*pszFrom == TEXT('n')) {
                    *pszTo++ = (TCHAR)0x0D;
                    *pszTo++ = (TCHAR)0x0A;
                    pszFrom++;
                }
                else
                    if (*pszFrom == TEXT('\\')) {
                        *pszTo++ = TEXT('\\');
                        pszFrom++;
                    }
                    else
                        *pszTo++ = *pszFrom++;
            }

    *pszTo = TEXT('\0');
}

static void encodeSig(LPCTSTR pszFrom, LPTSTR pszTo)
{
    if (pszFrom == NULL || pszTo == NULL)
        return;

    while (*pszFrom != TEXT('\0'))
#ifndef UNICODE
        if (IsDBCSLeadByte(*pszFrom)) {
            *pszTo++ = *pszFrom++;
            *pszTo++ = *pszFrom++;
        }
        else
#endif
            if ((*pszFrom == TEXT('\r')) || (*pszFrom == TEXT('\n'))) {
                *pszTo++ = TEXT('\\');
                *pszTo++ = TEXT('n');
                pszFrom++;

                if ((*pszFrom == TEXT('\r')) || (*pszFrom == TEXT('\n')))
                    pszFrom++;
            }
            else {
                if (*pszFrom == TEXT('\\'))
                    *pszTo++ = TEXT('\\');

                *pszTo++ = *pszFrom++;
            }

    *pszTo = TEXT('\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\programs.cpp ===
//
// PROGRAMS.CPP
//

#include "precomp.h"

static BOOL importProgramsHelper(LPCTSTR pcszInsFile, LPCTSTR pcszWorkDir, BOOL fImport);

BOOL WINAPI ImportProgramsA(LPCSTR pcszInsFile, LPCSTR pcszWorkDir, BOOL fImport)
{
    USES_CONVERSION;

    return importProgramsHelper(A2CT(pcszInsFile), A2CT(pcszWorkDir), fImport);
}
BOOL WINAPI ImportProgramsW(LPCWSTR pcwszInsFile, LPCWSTR pcwszWorkDir, BOOL fImport)
{
    USES_CONVERSION;

    return importProgramsHelper(W2CT(pcwszInsFile), W2CT(pcwszWorkDir), fImport);
}

void ExportProgram(HKEY hkClientKey, HANDLE hFile, LPCTSTR pcszProgramType)
{
    HKEY hk;
    TCHAR szKey[MAX_PATH];

    PathCombine(szKey, RK_CLIENT, pcszProgramType);

    if (SHOpenKey(hkClientKey, pcszProgramType, KEY_READ, &hk) == ERROR_SUCCESS)
        ExportRegValue2Inf(hk, NULL, TEXT("HKLM"), szKey, hFile);
}

void ExportHTMLEditor(HANDLE hFile, BOOL fHKLM)
{
    HKEY hk;
    DWORD dwIndex, dwSize;
    TCHAR szSubKey[MAX_PATH];

    if (fHKLM)
    {
        if (SHOpenKeyHKLM(RK_HTMLEDIT, KEY_DEFAULT_ACCESS, &hk) != ERROR_SUCCESS)
            return;
    }
    else
    {
        if (SHOpenKeyHKCU(RK_HTMLEDIT, KEY_DEFAULT_ACCESS, &hk) != ERROR_SUCCESS)
            return;
    }

    // this value is needed for the edit button and menu item in IE

    ExportRegValue2Inf(hk, TEXT("Description"), fHKLM ? TEXT("HKLM") : TEXT("HKCU"), RK_HTMLEDIT, hFile);

    dwIndex = 0;
    dwSize = ARRAYSIZE(szSubKey);
    while (RegEnumKeyEx(hk, dwIndex, szSubKey, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        HKEY hkSub;
        TCHAR szKey[MAX_PATH];

        PathCombine(szKey, RK_HTMLEDIT, szSubKey);

        if (SHOpenKey(hk, szSubKey, KEY_DEFAULT_ACCESS, &hkSub) == ERROR_SUCCESS)
            ExportRegTree2Inf(hkSub, fHKLM ? TEXT("HKLM") : TEXT("HKCU"), szKey, hFile, TRUE);

        dwSize = ARRAYSIZE(szSubKey);
        dwIndex++;
    }
}

static BOOL importProgramsHelper(LPCTSTR pcszInsFile, LPCTSTR pcszWorkDir, BOOL fImport)
{
    HANDLE hFile;
    TCHAR szProgramsFile[MAX_PATH];

    // clear out extreginf entry
    WritePrivateProfileString(EXTREGINF, IK_PROGRAMS, NULL, pcszInsFile);
    WritePrivateProfileString(IS_EXTREGINF_HKLM, IK_PROGRAMS, NULL, pcszInsFile);
    WritePrivateProfileString(IS_EXTREGINF_HKCU, IK_PROGRAMS, NULL, pcszInsFile);

    // clear any old inf out of working dir
    PathCombine(szProgramsFile, pcszWorkDir, TEXT("programs.inf"));
    DeleteFile(szProgramsFile);

    if (!fImport)
        return TRUE;

    if ((hFile = CreateNewFile(szProgramsFile)) != INVALID_HANDLE_VALUE)
    {
        TCHAR szBuf[MAX_PATH];
        HKEY hkPrograms;

        WriteStringToFile(hFile, (LPCVOID) PROGRAMS_INF_ADD, StrLen(PROGRAMS_INF_ADD));

        // do HKLM stuff first

        // export all defaults except for HTML editor which is in a different place
        if (SHOpenKeyHKLM(RK_CLIENT, KEY_READ, &hkPrograms) == ERROR_SUCCESS)
        {
            ExportProgram(hkPrograms, hFile, TEXT("Calendar"));
            ExportProgram(hkPrograms, hFile, TEXT("Contacts"));
            ExportProgram(hkPrograms, hFile, TEXT("Internet Call"));
            ExportProgram(hkPrograms, hFile, TEXT("Mail"));
            ExportProgram(hkPrograms, hFile, TEXT("News"));
            RegCloseKey(hkPrograms);
        }

        // need to look in both HKCU AND HKLM for html editor info

        ExportHTMLEditor(hFile, TRUE);

        // need to export mailto: protocol stuff in HKCR

        if (SHOpenKeyHKCR(TEXT("mailto"), KEY_READ, &hkPrograms) == ERROR_SUCCESS)
        {
            ExportRegTree2Inf(hkPrograms, TEXT("HKCR"), TEXT("mailto"), hFile, TRUE);
            RegCloseKey(hkPrograms);
        }
        
        // now do HKCU stuff

        WriteStringToFile(hFile, INF_IEAKADDREG_HKCU, StrLen(INF_IEAKADDREG_HKCU));

        // whether or not to check if IE is default browser value

        if (SHOpenKeyHKCU(RK_IE_MAIN, KEY_READ, &hkPrograms) == ERROR_SUCCESS)
        {
            ExportRegValue2Inf(hkPrograms, TEXT("Check_Associations"), TEXT("HKCU"), RK_IE_MAIN,
                hFile);
            RegCloseKey(hkPrograms);
        }
        
        ExportHTMLEditor(hFile, FALSE);

        CloseHandle(hFile);

        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("*,%s,DefaultInstall"), PathFindFileName(szProgramsFile));
        WritePrivateProfileString(EXTREGINF, IK_PROGRAMS, szBuf, pcszInsFile);
        
        if (!InsIsSectionEmpty(IS_IEAKADDREG_HKLM, szProgramsFile))
        {
            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("*,%s,IEAKInstall.HKLM"), PathFindFileName(szProgramsFile));
            WritePrivateProfileString(IS_EXTREGINF_HKLM, IK_PROGRAMS, szBuf, pcszInsFile);
        }

        if (!InsIsSectionEmpty(IS_IEAKADDREG_HKCU, szProgramsFile))
        {
            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("*,%s,IEAKInstall.HKCU"), PathFindFileName(szProgramsFile));
            WritePrivateProfileString(IS_EXTREGINF_HKCU, IK_PROGRAMS, szBuf, pcszInsFile);
        }
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ieakeng.rc
//

// String table
#define IDS_ENGINE_TITLE        1001
#define IDS_IEAKUI_LOADERROR    1011

#define IDS_CF_EMPTY_FIELD      2001
#define IDS_CF_INVALID_URL      2002
#define IDS_CF_CHAR             2003
#define IDS_CF_WILD             2004
#define IDS_CF_RELATIVE         2005
#define IDS_CF_FIRST_CHAR       2006
#define IDS_CF_PRESLASH         2007
#define IDS_CF_SPACE            2008
#define IDS_CF_FWDSLASH         2009
#define IDS_CF_COLON            2010
#define IDS_CF_DRIVE            2011
#define IDS_CF_SEPARATOR        2012
#define IDS_CF_DBCS             2013
#define IDS_CF_0x5C             2014
#define IDS_CF_DOESNT_EXIST     2015
#define IDS_CF_NOT_FOLDER       2016
#define IDS_CF_NOT_FILE         2017
#define IDS_CF_UNKNOWN          2018
#define IDS_CF_INVALID_SPACE    2019
#define IDS_CF_INVALID_COLON    2020
#define IDS_CF_EXCHAR           2021
#define IDS_CF_INVALID_NUMBER   2022


#define IDS_IMAGES_FILTER       2100
#define IDS_HTMLDOC_FILTER      2101
#define IDS_URL_FILTER          2102
#define IDS_CDF_FILTER          2103
#define IDS_MYCOMP_FILTER       2104
#define IDS_CONTROLP_FILTER     2105
#define IDS_PVK_FILTER          2106
#define IDS_SPC_FILTER          2107
#define IDS_TXT_FILTER          2108
#define IDS_ICO_FILTER          2109
#define IDS_EXE_FILTER          2110
#define IDS_INS_FILTER          2111
#define IDS_ADM_FILTER          2112
#define IDS_CERTIFICATE_FILTER  2113
#define IDS_BMP_FILTER          2114
#define IDS_CAB_FILTER          2115
#define IDS_SCRIPT_FILTER       2116
#define IDS_RULES_FILTER        2117
#define IDS_ISP_FILTER          2118
#define IDS_WAV_FILTER          2119
#define IDS_GIF_FILTER          2120

#define IDS_COMP_MYCOMP         2140
#define IDS_COMP_CONTROLP       2141
#define IDS_COMP_WALLPAPER      2142
#define IDS_COMP_FILEHTML       2143
#define IDS_COMP_FILEBMP        2144
#define IDS_COMP_PVK            2145
#define IDS_COMP_SPC            2146
#define IDS_COMP_TXT            2147
#define IDS_COMP_ICO            2148
#define IDS_COMP_EXE            2149
#define IDS_COMP_CDF            2150
#define IDS_COMP_IMAGES         2151
#define IDS_COMP_CERT           2152
#define IDS_COMP_ADM            2153
#define IDS_COMP_INSFILE        2154
#define IDS_COMP_CAB            2155
#define IDS_COMP_SCRIPT         2156
#define IDS_COMP_RULES          2157
#define IDS_COMP_ISP            2158
#define IDS_COMP_WAV            2159
#define IDS_COMP_GIF            2160

#define IDS_RESTARTYESNO        104

#define IDS_FAV_ERR_NOTALL      20001
#define IDS_FAV_ERR_DUPLICATE   20002
#define IDS_NOCHANNELSTOIMPORT  20003

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         1001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\toolbar.cpp ===
//
// TOOLBAR.CPP
//

#include "precomp.h"

static BOOL importToolbarInfoHelper(LPCTSTR pcszInsFile, LPCTSTR pcszToolbarWorkDir, LPCTSTR pcszToolbarInf,
                                    BOOL fImportToolbars);

BOOL WINAPI ImportToolbarInfoA(LPCSTR pcszInsFile, LPCSTR pcszToolbarWorkDir, LPCSTR pcszToolbarInf,
                               BOOL fImportToolbars)
{
    USES_CONVERSION;

    return importToolbarInfoHelper(A2CT(pcszInsFile), A2CT(pcszToolbarWorkDir),
        A2CT(pcszToolbarInf), fImportToolbars);
}

BOOL WINAPI ImportToolbarInfoW(LPCWSTR pcwszInsFile, LPCWSTR pcwszToolbarWorkDir, LPCWSTR pcwszToolbarInf,
                               BOOL fImportToolbars)
{
    USES_CONVERSION;

    return importToolbarInfoHelper(W2CT(pcwszInsFile), W2CT(pcwszToolbarWorkDir),
        W2CT(pcwszToolbarInf), fImportToolbars);
}

static BOOL importQuickLaunchFiles(LPCTSTR pszSourceFileOrPath, LPCTSTR pszTargetPath,
                                   LPCTSTR pcszToolbarInf, LPCTSTR pszIns)
{
    LPTSTR pszAuxFile;
    BOOL   fResult;

    if (!PathFileExists(pszSourceFileOrPath))
        return FALSE;

    fResult = TRUE;
    if (!PathIsDirectory(pszSourceFileOrPath)) { // file
        TCHAR szTargetFile[MAX_PATH];
        TCHAR szBuf[16];
        UINT  nNumFiles;

        fResult = PathCreatePath(pszTargetPath);
        if (!fResult)
            return FALSE;

        pszAuxFile = PathFindFileName(pszSourceFileOrPath);
        PathCombine(szTargetFile, pszTargetPath, pszAuxFile);
        SetFileAttributes(szTargetFile, FILE_ATTRIBUTE_NORMAL);

        fResult = CopyFile(pszSourceFileOrPath, szTargetFile, FALSE);
        if (!fResult)
            return FALSE;

        //----- Update the ins file -----

        nNumFiles = (UINT)GetPrivateProfileInt(QUICKLAUNCH, IK_NUMFILES, 0, pszIns);
        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%u"), ++nNumFiles);
        WritePrivateProfileString(QUICKLAUNCH, IK_NUMFILES, szBuf, pszIns);

        ASSERT(nNumFiles > 0);
        wnsprintf(szBuf, ARRAYSIZE(szBuf), FILE_TEXT, nNumFiles - 1);
        WritePrivateProfileString(QUICKLAUNCH, szBuf, pszAuxFile, pszIns);
    }
    else {                                       // directory
        // BUGBUG: Won't copy files in sub-dirs under pszSourceFileOrPath
        WIN32_FIND_DATA fd;
        TCHAR  szSourceFile[MAX_PATH];
        TCHAR szLnkDesc[MAX_PATH];
        TCHAR szLnkFile[MAX_PATH];
        HANDLE hFindFile;

        StrCpy(szSourceFile, pszSourceFileOrPath);
        PathAddBackslash(szSourceFile);

        // remember the pos where the filename would get copied
        pszAuxFile = szSourceFile + lstrlen(szSourceFile);
        StrCpy(pszAuxFile, TEXT("*.*"));

        if (LoadString(g_hInst, IDS_IELNK, szLnkDesc, ARRAYSIZE(szLnkDesc)) == 0)
            StrCpy(szLnkDesc, TEXT("Launch Internet Explorer Browser"));

        StrCpy(szLnkFile, szLnkDesc);
        StrCat(szLnkFile, TEXT(".lnk"));

        // copy all the files in pszSourceFileOrPath to pszTargetPath
        hFindFile = FindFirstFile(szSourceFile, &fd);
        if (hFindFile != INVALID_HANDLE_VALUE) {
            fResult = TRUE;
            do {
                // skip ".", ".." and all sub-dirs
                if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    continue;

                if (StrCmpI(fd.cFileName, szLnkFile) == 0)
                {
                    TCHAR szLnkTitle[MAX_PATH];
                    TCHAR szQLName[64];
                    TCHAR szInfSect[MAX_PATH*4];

                    if (LoadString(g_hInst, IDS_IE, szLnkTitle, ARRAYSIZE(szLnkTitle)) == 0)
                        StrCpy(szLnkTitle, TEXT("Internet Explorer"));
                    if (LoadString(g_hInst, IDS_QUICK_LAUNCH, szQLName, ARRAYSIZE(szQLName)) == 0)
                        StrCpy(szQLName, TEXT("Quick Launch"));

                    ZeroMemory(szInfSect, sizeof(szInfSect));
                    wnsprintf(szInfSect, ARRAYSIZE(szInfSect), BROWSERLNKSECT, szQLName, szLnkDesc, szLnkTitle);
                    WritePrivateProfileSection(TEXT("AddQuick.Links"), szInfSect, pcszToolbarInf);
                    WritePrivateProfileString(DEFAULTINSTALL, UPDATE_INIS, TEXT("AddQuick.Links"), pcszToolbarInf);
                    WritePrivateProfileSection(TEXT("MSIExploreDestinationSecWin"), TEXT("49000=MSIExploreLDIDSection,5\r\n49050=QuickLinksLDIDSection,5\r\n\0\0"),
                        pcszToolbarInf);
                    WritePrivateProfileString(DEFAULTINSTALL, TEXT("CustomDestination"), TEXT("MSIExploreDestinationSecWin"), pcszToolbarInf);
                    WritePrivateProfileSection(TEXT("MSIExploreLDIDSection"), TEXT("\"HKLM\",\"SOFTWARE\\Microsoft\\IE Setup\\Setup\",\"Path\",\"Internet Explorer 4.0\",\"%24%\\%PROGRAMF%\"\r\n\0\0"),
                        pcszToolbarInf);
                    WritePrivateProfileSection(TEXT("QuickLinksLDIDSection"), TEXT("\"HKCU\",\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\",\"AppData\",\"Internet Explorer 4.0\",\"%25%\\Application Data\"\r\n\0\0"),
                        pcszToolbarInf);
                    WritePrivateProfileString(NULL, NULL, NULL, pcszToolbarInf);
                    WritePrivateProfileString(QUICKLAUNCH, IK_KEEPIELNK, TEXT("1"), pszIns);
                    continue;
                }
                StrCpy(pszAuxFile, fd.cFileName);

                // keep going even if copying of a file fails, but return FALSE in case of error
                fResult = fResult && importQuickLaunchFiles(szSourceFile, pszTargetPath, pcszToolbarInf, pszIns);
            } while (FindNextFile(hFindFile, &fd));

            FindClose(hFindFile);
        }
    }

    return fResult;
}

static BOOL importToolbarInfoHelper(LPCTSTR pcszInsFile, LPCTSTR pcszToolbarWorkDir, LPCTSTR pcszToolbarInf,
                                    BOOL fImportToolbars)
{
    BOOL bRet = FALSE;
    HKEY hkToolbar;

    if (pcszInsFile == NULL  ||  pcszToolbarWorkDir == NULL  ||  pcszToolbarInf == NULL)
        return FALSE;

    // Before processing anything, first clear out the entries in the INS file and delete work dirs

    // clear out the entries in the INS file that correspond to importing toolbars
    WritePrivateProfileString(DESKTOP_OBJ_SECT, IMPORT_TOOLBARS, TEXT("0"), pcszInsFile);
    WritePrivateProfileString(EXTREGINF, TOOLBARS, NULL, pcszInsFile);

    // delete the QUICKLAUNCH section in the INS file
    WritePrivateProfileString(QUICKLAUNCH, NULL, NULL, pcszInsFile);

    // blow away the pcszToolbarWorkDir and pcszToolbarInf
    PathRemovePath(pcszToolbarWorkDir);
    PathRemovePath(pcszToolbarInf);

    if (!fImportToolbars)
        return TRUE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, KEY_TOOLBAR_VAL, 0, KEY_DEFAULT_ACCESS, &hkToolbar) == ERROR_SUCCESS)
    {
        TCHAR szQuickLaunchPath[MAX_PATH];
        DWORD cbSize = sizeof(szQuickLaunchPath);

        // prepare the quick launch folder path
        if (SHGetValue(HKEY_CURRENT_USER, SHELLFOLDERS_KEY, APPDATA_VALUE, NULL, (LPBYTE) szQuickLaunchPath, &cbSize) == ERROR_SUCCESS)
        {
            TCHAR szFullInfName[MAX_PATH];
            HANDLE hInf;

            // "Quick Launch" name is localizable; so read it from the resource
            if (LoadString(g_hInst, IDS_QUICK_LAUNCH, szFullInfName, ARRAYSIZE(szFullInfName)) == 0)
                StrCpy(szFullInfName, TEXT("Quick Launch"));
            PathAppend(szQuickLaunchPath, TEXT("Microsoft\\Internet Explorer"));
            PathAppend(szQuickLaunchPath, szFullInfName);

            if (PathIsFileSpec(pcszToolbarInf))                     // create TOOLBAR.INF under pcszToolbarWorkDir
                PathCombine(szFullInfName, pcszToolbarWorkDir, pcszToolbarInf);
            else
                StrCpy(szFullInfName, pcszToolbarInf);

            // create TOOLBAR.INF file
            if ((hInf = CreateNewFile(szFullInfName)) != INVALID_HANDLE_VALUE)
            {
                DWORD_PTR dwRes;
                TCHAR szBuf[MAX_PATH];

                SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, (LPARAM) SAVE_TASKBARS,
                                            SMTO_NORMAL | SMTO_ABORTIFHUNG , 20000, &dwRes);

                // first, write the standard goo - [Version], [DefaultInstall], etc. - to TOOLBAR.INF
                WriteStringToFile(hInf, (LPCVOID) INF_ADD, StrLen(INF_ADD));

                ExportRegKey2Inf(hkToolbar, TEXT("HKCU"), KEY_TOOLBAR_VAL, hInf);
                WriteStringToFile(hInf, (LPCVOID) TEXT("\r\n"), 2);

                CloseFile(hInf);

                // copy all the quick launch files from the quick launch folder to pcszToolbarWorkDir
                importQuickLaunchFiles(szQuickLaunchPath, pcszToolbarWorkDir, szFullInfName, pcszInsFile);

                // update the INS file
                WritePrivateProfileString(DESKTOP_OBJ_SECT, IMPORT_TOOLBARS, TEXT("1"), pcszInsFile);
                WritePrivateProfileString(DESKTOP_OBJ_SECT, OPTION, TEXT("1"), pcszInsFile);
                wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("*,%s,") IS_DEFAULTINSTALL, PathFindFileName(pcszToolbarInf));
                WritePrivateProfileString(IS_EXTREGINF, TOOLBARS, szBuf, pcszInsFile);

                bRet = TRUE;
            }
        }

        RegCloseKey(hkToolbar);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\seczones.cpp ===
//
// SECZONES.CPP
//

#include "precomp.h"

#include <urlmon.h>
#include <wininet.h>
#ifdef WINNT
#include <winineti.h>
#endif // WINNT

#include "SComPtr.h"

#define REGSTR_PATH_SECURITY_LOCKOUT  TEXT("Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define REGSTR_VAL_HKLM_ONLY          TEXT("Security_HKLM_only")

// prototype declarations
static BOOL importZonesHelper(LPCTSTR pcszInsFile, LPCTSTR pcszZonesWorkDir, LPCTSTR pcszZonesInf, BOOL fImportZones);
static BOOL importRatingsHelper(LPCTSTR pcszInsFile, LPCTSTR pcszRatingsWorkDir, LPCTSTR pcszRatingsInf, BOOL fImportRatings);
static BOOL ratingsInRegistry(VOID);


BOOL WINAPI ImportZonesA(LPCSTR pcszInsFile, LPCSTR pcszZonesWorkDir, LPCSTR pcszZonesInf, BOOL fImportZones)
{
    USES_CONVERSION;

    return importZonesHelper(A2CT(pcszInsFile), A2CT(pcszZonesWorkDir), A2CT(pcszZonesInf), fImportZones);
}

BOOL WINAPI ImportZonesW(LPCWSTR pcwszInsFile, LPCWSTR pcwszZonesWorkDir, LPCWSTR pcwszZonesInf, BOOL fImportZones)
{
    USES_CONVERSION;

    return importZonesHelper(W2CT(pcwszInsFile), W2CT(pcwszZonesWorkDir), W2CT(pcwszZonesInf), fImportZones);
}

BOOL WINAPI ModifyZones(HWND hDlg)
{
    typedef HRESULT (WINAPI * ZONESREINIT)(DWORD);
    //typedef VOID (WINAPI * LAUNCHSECURITYDIALOGEX)(HWND, DWORD, DWORD);

    BOOL fRet;
    HINSTANCE hUrlmon, hInetCpl;
    ZONESREINIT pfnZonesReInit;
    //LAUNCHSECURITYDIALOGEX pfnLaunchSecurityDialogEx;
    HKEY hkPol;
    DWORD dwOldHKLM, dwOldOptEdit, dwOldZoneMap;

    fRet = FALSE;

    hUrlmon  = NULL;
    hInetCpl = NULL;

    hkPol = NULL;

    dwOldHKLM    = 0;
    dwOldOptEdit = 0;
    dwOldZoneMap = 0;

    if ((hUrlmon = LoadLibrary(TEXT("urlmon.dll"))) == NULL)
        goto Exit;

    if ((hInetCpl = LoadLibrary(TEXT("inetcpl.cpl"))) == NULL)
        goto Exit;

    if ((pfnZonesReInit = (ZONESREINIT) GetProcAddress(hUrlmon, "ZonesReInit")) == NULL)
        goto Exit;

//    if ((pfnLaunchSecurityDialogEx = (LAUNCHSECURITYDIALOGEX) GetProcAddress(hInetCpl, "LaunchSecurityDialogEx")) == NULL)
//        goto Exit;

    fRet = TRUE;

    SHOpenKeyHKLM(REG_KEY_INET_POLICIES, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkPol);

    // if zones related restrictions are set, save the values and then delete them
    if (hkPol != NULL)
    {
        dwOldHKLM    = RegSaveRestoreDWORD(hkPol, REG_VAL_HKLM_ONLY, 0);
        dwOldOptEdit = RegSaveRestoreDWORD(hkPol, REG_VAL_OPT_EDIT,  0);
        dwOldZoneMap = RegSaveRestoreDWORD(hkPol, REG_VAL_ZONE_MAP,  0);

        pfnZonesReInit(0);              // call into URLMON.DLL to force it to read the current settings
    }

    // call into INETCPL.CPL to modify the zones settings
    //pfnLaunchSecurityDialogEx(hDlg, 1, LSDFLAG_FORCEUI);
    
    ShowInetcpl(hDlg,INET_PAGE_SECURITY|INET_PAGE_PRIVACY);
    
    // restore the original values
    if (hkPol != NULL)
    {
        RegSaveRestoreDWORD(hkPol, REG_VAL_HKLM_ONLY, dwOldHKLM);
        RegSaveRestoreDWORD(hkPol, REG_VAL_OPT_EDIT,  dwOldOptEdit);
        RegSaveRestoreDWORD(hkPol, REG_VAL_ZONE_MAP,  dwOldZoneMap);

        pfnZonesReInit(0);              // call into URLMON.DLL to force it to read the current settings
    }

Exit:
    if (hUrlmon != NULL)
        FreeLibrary(hUrlmon);

    if (hInetCpl != NULL)
        FreeLibrary(hInetCpl);

    if (hkPol != NULL)
        SHCloseKey(hkPol);

    return fRet;
}

BOOL WINAPI ImportRatingsA(LPCSTR pcszInsFile, LPCSTR pcszRatingsWorkDir, LPCSTR pcszRatingsInf, BOOL fImportRatings)
{
    USES_CONVERSION;

    return importRatingsHelper(A2CT(pcszInsFile), A2CT(pcszRatingsWorkDir), A2CT(pcszRatingsInf), fImportRatings);
}

BOOL WINAPI ImportRatingsW(LPCWSTR pcwszInsFile, LPCWSTR pcwszRatingsWorkDir, LPCWSTR pcwszRatingsInf, BOOL fImportRatings)
{
    USES_CONVERSION;

    return importRatingsHelper(W2CT(pcwszInsFile), W2CT(pcwszRatingsWorkDir), W2CT(pcwszRatingsInf), fImportRatings);
}

BOOL WINAPI ModifyRatings(HWND hDlg)
{
    typedef HRESULT (WINAPI * RATINGSETUPUI)(HWND, LPCSTR);

    BOOL fRet;
    HINSTANCE hMSRating;
    RATINGSETUPUI pfnRatingSetupUI;

    fRet = FALSE;

    hMSRating = NULL;

    if ((hMSRating = LoadLibrary(TEXT("msrating.dll"))) == NULL)
        goto Exit;

    if ((pfnRatingSetupUI = (RATINGSETUPUI) GetProcAddress(hMSRating, "RatingSetupUI")) == NULL)
        goto Exit;

    fRet = TRUE;

    // call into msrating.dll to modify the ratings
    pfnRatingSetupUI(hDlg, NULL);

Exit:
    if (hMSRating != NULL)
        FreeLibrary(hMSRating);

    return fRet;
}

/////////////////////////////////////////////////////////////////////
static void importPrivacyForRSOP(LPCTSTR szFile)
{
	__try
	{
		BOOL fAdvanced = FALSE;

        DWORD dwTemplate;
        DWORD dwError = PrivacyGetZonePreferenceW(
                            URLZONE_INTERNET,
                            PRIVACY_TYPE_FIRST_PARTY,
                            &dwTemplate,
                            NULL,
                            NULL);

        if(ERROR_SUCCESS == dwError && PRIVACY_TEMPLATE_ADVANCED == dwTemplate)
            fAdvanced = TRUE;


		// AdvancedSettings
		TCHAR szInt[32];
		wnsprintf(szInt, countof(szInt), TEXT("%d"), fAdvanced ? 1 : 0);
		WritePrivateProfileString(IK_PRIVACY, IK_PRIV_ADV_SETTINGS, szInt, szFile);


        //
        // Figure out first party setting and session
        //
		dwTemplate = PRIVACY_TEMPLATE_CUSTOM;
        WCHAR szBuffer[MAX_PATH];  
        // MAX_PATH is sufficent for advanced mode setting strings, MaxPrivacySettings is overkill.
        DWORD dwBufferSize = ARRAYSIZE(szBuffer);
        dwError = PrivacyGetZonePreferenceW(
		                URLZONE_INTERNET,
				        PRIVACY_TYPE_FIRST_PARTY,
						&dwTemplate,
						szBuffer,
						&dwBufferSize);
	    if (ERROR_SUCCESS != dwError)
		    dwTemplate = PRIVACY_TEMPLATE_CUSTOM;

		// store settings in INF file
		// FirstPartyType
		wnsprintf(szInt, countof(szInt), TEXT("%lu"), dwTemplate);
		WritePrivateProfileString(IK_PRIVACY, IK_PRIV_1PARTY_TYPE, szInt, szFile);
		// FirstPartyTypeText
		if (ERROR_SUCCESS == dwError && fAdvanced && dwBufferSize > 0)
			WritePrivateProfileString(IK_PRIVACY, IK_PRIV_1PARTY_TYPE_TEXT, szBuffer, szFile);


        //
        // Figure out third party setting
        //
		dwTemplate = PRIVACY_TEMPLATE_CUSTOM;
		dwBufferSize = ARRAYSIZE(szBuffer);
        dwBufferSize = ARRAYSIZE( szBuffer);
        dwError = PrivacyGetZonePreferenceW(
							URLZONE_INTERNET,
							PRIVACY_TYPE_THIRD_PARTY,
							&dwTemplate,
							szBuffer,
							&dwBufferSize);
	    if(dwError != ERROR_SUCCESS)
		    dwTemplate = PRIVACY_TEMPLATE_CUSTOM;

		// ThirdPartyType
		wnsprintf(szInt, countof(szInt), TEXT("%lu"), dwTemplate);
		WritePrivateProfileString(IK_PRIVACY, IK_PRIV_3PARTY_TYPE, szInt, szFile);
		// ThirdPartyTypeText
		if (ERROR_SUCCESS == dwError && fAdvanced && dwBufferSize > 0)
			WritePrivateProfileString(IK_PRIVACY, IK_PRIV_3PARTY_TYPE_TEXT, szBuffer, szFile);
	}
	__except(TRUE)
	{
	}
}

/////////////////////////////////////////////////////////////////////
static void importZonesForRSOP(LPCTSTR szFile)
{
        __try
        {
                // both the security mgr & the zone mgr must be created
                ComPtr<IInternetZoneManager> pZoneMgr = NULL;
                ComPtr<IInternetSecurityManager> pSecMan = NULL;
                HRESULT hr = CoCreateInstance(CLSID_InternetZoneManager, NULL, CLSCTX_INPROC_SERVER,
                                                         IID_IInternetZoneManager, (void**) &pZoneMgr);
                if (SUCCEEDED(hr))
                {
                        hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                                                                IID_IInternetSecurityManager, (void**) &pSecMan);
                }

                // Write out zone mappings & attributes
                if (SUCCEEDED(hr))
                {
                        DWORD dwEnum = 0, dwCount = 0;
                        hr = pZoneMgr->CreateZoneEnumerator(&dwEnum, &dwCount, 0L);
                        if (SUCCEEDED(hr) && dwCount > 0)
                        {
                                TCHAR szSection[32];
                                TCHAR szMapping[32];
                                TCHAR szInt[32];

                                for (UINT nZone = 0; nZone < dwCount; nZone++)
                                {
                                        for (int nHKLM = 0; nHKLM < 2; nHKLM++)
                                        {
                                                HKEY hkZones = NULL;

                                                TCHAR szZIndex[MAX_PATH];
                                                wnsprintf(szZIndex, countof(szZIndex), REG_KEY_ZONES TEXT("\\%lu"), nZone);
                                                if (0 == nHKLM)
                                                {
                                                        SHOpenKeyHKLM(szZIndex, KEY_READ, &hkZones);
                                                        wnsprintf(szSection, countof(szSection), IK_ZONE_HKCU_FMT, nZone);
                                                }
                                                else
                                                {
                                                        SHOpenKeyHKCU(szZIndex, KEY_READ, &hkZones);
                                                        wnsprintf(szSection, countof(szSection), IK_ZONE_HKLM_FMT, nZone);
                                                }

                                                // write out zone attributes
                                                TCHAR szTemp[MAX_PATH]; // MAX_ZONE_PATH && MAX_ZONE_DESCRIPTION = MAX_PATH = 260
                                                DWORD dwSize = sizeof(szTemp);
                                                if (NULL != hkZones)
                                                {
                                                        if (ERROR_SUCCESS == RegQueryValueEx(hkZones, IK_DISPLAYNAME, NULL, NULL, (LPBYTE)szTemp, &dwSize))
                                                        {
                                                                WritePrivateProfileString(szSection, IK_DISPLAYNAME, szTemp, szFile);
                                                                dwSize = sizeof(szTemp);
                                                        }
                                                        if (ERROR_SUCCESS == RegQueryValueEx(hkZones, IK_DESCRIPTION, NULL, NULL, (LPBYTE)szTemp, &dwSize))
                                                        {
                                                                WritePrivateProfileString(szSection, IK_DESCRIPTION, szTemp, szFile);
                                                                dwSize = sizeof(szTemp);
                                                        }
                                                        if (ERROR_SUCCESS == RegQueryValueEx(hkZones, IK_ICONPATH, NULL, NULL, (LPBYTE)szTemp, &dwSize))
                                                        {
                                                                WritePrivateProfileString(szSection, IK_ICONPATH, szTemp, szFile);
                                                                dwSize = sizeof(szTemp);
                                                        }

                                                        DWORD dwTemp = 0;
                                                        dwSize = sizeof(dwTemp);
                                                        if (ERROR_SUCCESS == RegQueryValueEx(hkZones, IK_MINLEVEL, NULL, NULL, (LPBYTE)&dwTemp, &dwSize))
                                                        {
                                                                wnsprintf(szInt, countof(szInt), TEXT("%lu"), dwTemp);
                                                                WritePrivateProfileString(szSection, IK_MINLEVEL, szInt, szFile);
                                                        }
                                                        if (ERROR_SUCCESS == RegQueryValueEx(hkZones, IK_RECOMMENDLEVEL, NULL, NULL, (LPBYTE)&dwTemp, &dwSize))
                                                        {
                                                                wnsprintf(szInt, countof(szInt), TEXT("%lu"), dwTemp);
                                                                WritePrivateProfileString(szSection, IK_RECOMMENDLEVEL, szInt, szFile);
                                                        }
                                                        if (ERROR_SUCCESS == RegQueryValueEx(hkZones, IK_CURLEVEL, NULL, NULL, (LPBYTE)&dwTemp, &dwSize))
                                                        {
                                                                wnsprintf(szInt, countof(szInt), TEXT("%lu"), dwTemp);
                                                                WritePrivateProfileString(szSection, IK_CURLEVEL, szInt, szFile);
                                                        }
                                                        if (ERROR_SUCCESS == RegQueryValueEx(hkZones, IK_FLAGS, NULL, NULL, (LPBYTE)&dwTemp, &dwSize))
                                                        {
                                                                wnsprintf(szInt, countof(szInt), TEXT("%lu"), dwTemp);
                                                                WritePrivateProfileString(szSection, IK_FLAGS, szInt, szFile);
                                                        }
                                                }

                                                // write out action values
                                                if (NULL != hkZones)
                                                {
                                                        TCHAR szActKey[32];
                                                        TCHAR szActValue[64];

                                                        DWORD dwURLAction[] = 
                                                                { URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY,
                                                                        URLACTION_ACTIVEX_RUN,
                                                                        URLACTION_CHANNEL_SOFTDIST_PERMISSIONS,
                                                                        URLACTION_COOKIES,
                                                                        URLACTION_COOKIES_SESSION,
                                                                        URLACTION_CREDENTIALS_USE,
                                                                        URLACTION_CLIENT_CERT_PROMPT,
                                                                        URLACTION_CROSS_DOMAIN_DATA,
                                                                        URLACTION_DOWNLOAD_SIGNED_ACTIVEX,
                                                                        URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX,
                                                                        URLACTION_HTML_FONT_DOWNLOAD,
                                                                        URLACTION_HTML_SUBFRAME_NAVIGATE,
                                                                        URLACTION_HTML_SUBMIT_FORMS,
                                                                        URLACTION_HTML_JAVA_RUN,
                                                                        URLACTION_HTML_USERDATA_SAVE,
                                                                        URLACTION_JAVA_PERMISSIONS,
                                                                        URLACTION_SCRIPT_JAVA_USE,
                                                                        URLACTION_SCRIPT_PASTE,
                                                                        URLACTION_SCRIPT_RUN,
                                                                        URLACTION_SCRIPT_SAFE_ACTIVEX,
                                                                        URLACTION_SHELL_FILE_DOWNLOAD,
                                                                        URLACTION_SHELL_INSTALL_DTITEMS,
                                                                        URLACTION_SHELL_MOVE_OR_COPY,
                                                                        URLACTION_SHELL_VERB,
                                                                        URLACTION_SHELL_WEBVIEW_VERB,
                                                                        0 };

                                                        DWORD dwSetting = 0;
                                                        DWORD dwSetSize = sizeof(dwSetting);

                                                        long nAction = 0;
                                                        long nStoredAction = 0;
                                                        while (0 != dwURLAction[nAction])
                                                        {
                                                                wnsprintf(szTemp, countof(szTemp), TEXT("%lX"), dwURLAction[nAction]);
                                                                if (ERROR_SUCCESS == RegQueryValueEx(hkZones, szTemp, NULL, NULL,
                                                                                                                                        (LPBYTE)&dwSetting, &dwSetSize))
                                                                {
                                                                        wnsprintf(szActKey, countof(szActKey), IK_ACTIONVALUE_FMT, nStoredAction);
                                                                        wnsprintf(szActValue, countof(szActValue), TEXT("%s:%lu"), szTemp, dwSetting);

                                                                        WritePrivateProfileString(szSection, szActKey, szActValue, szFile);
                                                                        nStoredAction++;
                                                                }

                                                                nAction++;
                                                        }
                                                }

                                                // write out zone mappings
                                                DWORD dwZone = 0;
                                                hr = pZoneMgr->GetZoneAt(dwEnum, nZone, &dwZone);
                                                ComPtr<IEnumString> pEnumString = NULL;
                                                hr = pSecMan->GetZoneMappings(dwZone, &pEnumString, 0);
                                                if (SUCCEEDED(hr))
                                                {
                                                        UINT nMapping = 0;
                                                        _bstr_t bstrSetting;

                                                        for(int i = 0; ;i++)
                                                        {
                                                            TCHAR szBuffer[MAX_PATH];
                                                            wnsprintf(szMapping, countof(szMapping), IK_MAPPING_FMT, i);
                                                            if(GetPrivateProfileString(szSection, szMapping, TEXT(""), szBuffer, MAX_PATH, szFile))
                                                            {
                                                                WritePrivateProfileString(szSection, szMapping, NULL, szFile);
                                                            }
                                                            else
                                                            {
                                                                break;
                                                            }

                                                        }

                                                        while (S_OK == hr)
                                                        {
                                                                wnsprintf(szMapping, countof(szMapping), IK_MAPPING_FMT, nMapping);
                                                                nMapping++;

                                                                // There should only be one object returned from this query.
                                                                BSTR bstrVal = NULL;
                                                                ULONG uReturned = (ULONG)-1L;
                                                                hr = pEnumString->Next(1L, &bstrVal, &uReturned);
                                                                if (SUCCEEDED(hr) && 1 == uReturned)
                                                                {
                                                                        bstrSetting = bstrVal;
                                                                        WritePrivateProfileString(szSection, szMapping, (LPCTSTR)bstrSetting, szFile);
                                                                }
                                                        }
                                                }
                                        }
                                }

                                wnsprintf(szInt, countof(szInt), TEXT("%lu"), dwCount);
                                WritePrivateProfileString(SECURITY_IMPORTS, IK_ZONES, szInt, szFile);
                                if(IEHardened())
                                {
                                    wnsprintf(szInt, countof(szInt), TEXT("%lu"), 1);
                                    WritePrivateProfileString(SECURITY_IMPORTS, IK_IEESC, szInt, szFile);
                                }
                                else
                                {
                                    wnsprintf(szInt, countof(szInt), TEXT("%lu"), 0);
                                    WritePrivateProfileString(SECURITY_IMPORTS, IK_IEESC, szInt, szFile);
                                }

                        }
                }
        }
        __except(TRUE)
        {
        }
}

/////////////////////////////////////////////////////////////////////
static BOOL importZonesHelper(LPCTSTR pcszInsFile, LPCTSTR pcszZonesWorkDir, LPCTSTR pcszZonesInf, BOOL fImportZones)
{
    BOOL bRet = FALSE;
    HKEY hkZones = NULL, hkZoneMap = NULL;
    HKEY hkInetSettings = NULL, hkP3P = NULL;

    if (pcszInsFile == NULL  ||  pcszZonesInf == NULL)
        return FALSE;

    // Before processing anything, first clear out the entries in the INS file and delete work dirs

    // clear out the entries in the INS file that correspond to importing security zones
    InsDeleteKey(SECURITY_IMPORTS, TEXT("ImportSecZones"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF,      TEXT("SecZones"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF_HKLM, TEXT("SecZones"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF_HKCU, TEXT("SecZones"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF_ESC,      TEXT("SecZones"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF_ESC_HKLM, TEXT("SecZones"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF_ESC_HKCU, TEXT("SecZones"), pcszInsFile);

    // blow away the pcszZonesWorkDir and pcszZonesInf
    if (pcszZonesWorkDir != NULL)
        PathRemovePath(pcszZonesWorkDir);
    PathRemovePath(pcszZonesInf);

    if (!fImportZones)
        return TRUE;

    // looks like there is some problem with setting the REG_VAL_HKLM_ONLY key;
    // so we'll import the settings from HKCU
    SHOpenKeyHKCU(REG_KEY_ZONES,   KEY_DEFAULT_ACCESS, &hkZones);
    SHOpenKeyHKCU(REG_KEY_ZONEMAP, KEY_DEFAULT_ACCESS, &hkZoneMap);
    SHOpenKeyHKCU(KEY_INET_SETTINGS,   KEY_DEFAULT_ACCESS, &hkInetSettings);
    SHOpenKeyHKCU(REG_KEY_P3P,   KEY_DEFAULT_ACCESS, &hkP3P);

    if (hkZones != NULL  &&  hkZoneMap != NULL)
    {
        TCHAR szFullInfName[MAX_PATH];
        HANDLE hInf;

        if (pcszZonesWorkDir != NULL  &&  PathIsFileSpec(pcszZonesInf)) // create SECZONES.INF under pcszZonesWorkDir
            PathCombine(szFullInfName, pcszZonesWorkDir, pcszZonesInf);
        else
            StrCpy(szFullInfName, pcszZonesInf);

        // create SECZONES.INF file
        if ((hInf = CreateNewFile(szFullInfName)) != INVALID_HANDLE_VALUE)
        {
            TCHAR szBuf[MAX_PATH];

            // first, write the standard goo - [Version], [DefaultInstall], etc. - to SECZONES.INF
            WriteStringToFile(hInf, (LPCVOID) ZONES_INF_ADD, StrLen(ZONES_INF_ADD));
            ExportRegTree2Inf(hkZones,   TEXT("HKLM"), REG_KEY_ZONES,   hInf);
            ExportRegTree2Inf(hkZoneMap, TEXT("HKLM"), REG_KEY_ZONEMAP, hInf);

            // write [AddReg.HKCU]
            WriteStringToFile(hInf, (LPCVOID) ZONES_INF_ADDREG_HKCU, StrLen(ZONES_INF_ADDREG_HKCU));
            ExportRegTree2Inf(hkZones,   TEXT("HKCU"), REG_KEY_ZONES,   hInf);
            ExportRegTree2Inf(hkZoneMap, TEXT("HKCU"), REG_KEY_ZONEMAP, hInf);

            // Import P3P settings
            if (hkInetSettings != NULL && hkP3P != NULL)
            {
                ExportRegValue2Inf(hkInetSettings, TEXT("PrivacyAdvanced"), TEXT("HKCU"), KEY_INET_SETTINGS, hInf);
                ExportRegTree2Inf(hkP3P, TEXT("HKCU"), REG_KEY_P3P, hInf);
            }

            CloseHandle(hInf);

            BOOL fHarden = IEHardened();

            // update the INS file
            InsWriteBool(SECURITY_IMPORTS, TEXT("ImportSecZones"), TRUE, pcszInsFile);
            wnsprintf(szBuf, countof(szBuf), TEXT("*,%s,") IS_DEFAULTINSTALL, PathFindFileName(pcszZonesInf));
            
            if(fHarden)
            {
                WritePrivateProfileString(IS_EXTREGINF_ESC, TEXT("SecZones"), szBuf, pcszInsFile);
            }
            else
            {
                WritePrivateProfileString(IS_EXTREGINF, TEXT("SecZones"), szBuf, pcszInsFile);
            }


            // write to new ExtRegInf.HKLM and ExtRegInf.HKCU sections
            if (!InsIsSectionEmpty(IS_IEAKADDREG_HKLM, szFullInfName))
            {
                wnsprintf(szBuf, countof(szBuf), TEXT("%s,") IS_IEAKINSTALL_HKLM, PathFindFileName(pcszZonesInf));
               
                if(fHarden)
                {
                    WritePrivateProfileString(IS_EXTREGINF_ESC_HKLM, TEXT("SecZones"), szBuf, pcszInsFile);
                }
                else
                {
                    WritePrivateProfileString(IS_EXTREGINF_HKLM, TEXT("SecZones"), szBuf, pcszInsFile);
                }

            }

            if (!InsIsSectionEmpty(IS_IEAKADDREG_HKCU, szFullInfName))
            {
                wnsprintf(szBuf, countof(szBuf), TEXT("%s,") IS_IEAKINSTALL_HKCU, PathFindFileName(pcszZonesInf));
                
                if(fHarden)
                {
                    WritePrivateProfileString(IS_EXTREGINF_ESC_HKCU, TEXT("SecZones"), szBuf, pcszInsFile);
                }
                else
                {
                    WritePrivateProfileString(IS_EXTREGINF_HKCU, TEXT("SecZones"), szBuf, pcszInsFile);
                }

            }

            bRet = TRUE;
        }

        // create SECZRSOP.INF file
        TCHAR szZRSOPInfFile[MAX_PATH];
        StrCpy(szZRSOPInfFile, szFullInfName);
        PathRemoveFileSpec(szZRSOPInfFile);
        StrCat(szZRSOPInfFile, TEXT("\\seczrsop.inf"));

        importZonesForRSOP(szZRSOPInfFile);
		importPrivacyForRSOP(szZRSOPInfFile);
    }
    SHCloseKey(hkZones);
    SHCloseKey(hkZoneMap);
    SHCloseKey(hkInetSettings);
    SHCloseKey(hkP3P);

    return bRet;
}

#define PICSRULES_APPROVEDSITES     0

#define PICSRULES_ALWAYS            1
#define PICSRULES_NEVER             0

//This indicates which member is valid in a PICSRulesPolicy
//Class
enum PICSRulesPolicyAttribute
{
    PR_POLICY_NONEVALID,
    PR_POLICY_REJECTBYURL,
    PR_POLICY_ACCEPTBYURL,
    PR_POLICY_REJECTIF,
    PR_POLICY_ACCEPTIF,
    PR_POLICY_REJECTUNLESS,
    PR_POLICY_ACCEPTUNLESS
};

/////////////////////////////////////////////////////////////////////
static void importRatingsForRSOP(HKEY hkRat, LPCTSTR szFile)
{
        __try
        {
                TCHAR szSection[32] = IK_FF_GENERAL;
        TCHAR szKey[32];
                TCHAR szInt[32];

                // write out ratings system filenames
                // not sure why, but code below only loops through 10
        TCHAR szTemp[MAX_PATH];
                DWORD cbSize = 0;
                for (int nFile = 0; nFile < 10; nFile++)
                {
            wnsprintf(szKey, countof(szKey), IK_FILENAME_FMT, nFile);

            cbSize = sizeof(szTemp);
            if (RegQueryValueEx(hkRat, szKey, NULL, NULL, (LPBYTE) szTemp, &cbSize) != ERROR_SUCCESS)
                break;

                        WritePrivateProfileString(szSection, szKey, szTemp, szFile);
                }

                // write out checked values from General tab
                HKEY hkDef = NULL;
                DWORD dwTemp = 0;
                if (ERROR_SUCCESS == SHOpenKey(hkRat, TEXT(".Default"), KEY_DEFAULT_ACCESS, &hkDef))
                {
                        cbSize = sizeof(dwTemp);
                        if (ERROR_SUCCESS == RegQueryValueEx(hkDef, VIEW_UNKNOWN_RATED_SITES,
                                                                                                NULL, NULL, (LPBYTE)&dwTemp, &cbSize))
                        {
                                wnsprintf(szInt, countof(szInt), TEXT("%lu"), dwTemp);
                                WritePrivateProfileString(szSection, VIEW_UNKNOWN_RATED_SITES, szInt, szFile);
                        }

                        cbSize = sizeof(dwTemp);
                        if (ERROR_SUCCESS == RegQueryValueEx(hkDef, PASSWORD_OVERRIDE_ENABLED,
                                                                                                NULL, NULL, (LPBYTE)&dwTemp, &cbSize))
                        {
                                wnsprintf(szInt, countof(szInt), TEXT("%lu"), dwTemp);
                                WritePrivateProfileString(szSection, PASSWORD_OVERRIDE_ENABLED, szInt, szFile);
                        }
                }

                // write out always viewable & never viewable sites from the approved sites tab
                // See msrating.dll for src
                HKEY hkUser = NULL;
                HKEY hkPRPolicy = NULL;
                DWORD nPolicies = 0;
                cbSize = sizeof(dwTemp);

                HRESULT hr = SHOpenKey(hkRat, TEXT("PICSRules\\.Default"), KEY_DEFAULT_ACCESS, &hkUser);
                if (ERROR_SUCCESS == hr)
                {
                        hr = SHOpenKey(hkUser, TEXT("0\\PRPolicy"), KEY_DEFAULT_ACCESS, &hkPRPolicy);
                        if (ERROR_SUCCESS == hr)
                        {
                                hr = RegQueryValueEx(hkPRPolicy, TEXT("PRNumPolicy"), NULL, NULL,
                                                                        (LPBYTE)&nPolicies, &cbSize);
                        }
                }

                if (ERROR_SUCCESS == hr)
                {
                        TCHAR szNumber[MAX_PATH];
                        HKEY hkItem = NULL;
                        HKEY hkPolicySub = NULL;
                        DWORD dwAttrib = PR_POLICY_NONEVALID;
                        DWORD nExpressions = 0;

                        long nApproved = 0;
                        long nDisapproved = 0;
                        for (DWORD nItem = 0; nItem < nPolicies; nItem++)
                        {
                                wnsprintf(szNumber, countof(szNumber), TEXT("%d"), nItem);
                                hr = SHOpenKey(hkPRPolicy, szNumber, KEY_DEFAULT_ACCESS, &hkItem);
                                if (ERROR_SUCCESS == hr)
                                {
                                        cbSize = sizeof(dwAttrib);
                                        hr = RegQueryValueEx(hkItem, TEXT("PRPPolicyAttribute"), NULL, NULL,
                                                                                                (LPBYTE)&dwAttrib, &cbSize);
                                }

                                if (ERROR_SUCCESS == hr)
                                        hr = SHOpenKey(hkItem, TEXT("PRPPolicySub"), KEY_DEFAULT_ACCESS, &hkPolicySub);

                                if (ERROR_SUCCESS == hr)
                                {
                                        cbSize = sizeof(nExpressions);
                                        hr = RegQueryValueEx(hkPolicySub, TEXT("PRNumURLExpressions"), NULL, NULL,
                                                                                                (LPBYTE)&nExpressions, &cbSize);
                                }

                                if (ERROR_SUCCESS == hr)
                                {
                                        HKEY hByURLKey = NULL;
                                        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
                                        for (DWORD nExp = 0; nExp < nExpressions; nExp++)
                                        {
                                                wnsprintf(szNumber, countof(szNumber), TEXT("%d"), nExp);
                                                hr = SHOpenKey(hkPolicySub, szNumber, KEY_DEFAULT_ACCESS, &hByURLKey);
                                                cbSize = sizeof(szURL);
                                                if (ERROR_SUCCESS == hr)
                                                {
                                                        hr = RegQueryValueEx(hByURLKey, TEXT("PRBUUrl"), NULL, NULL,
                                                                                        (LPBYTE)szURL, &cbSize);
                                                }

                                                if (ERROR_SUCCESS == hr)
                                                {
                                                        if (PR_POLICY_REJECTBYURL == dwAttrib)
                                                        {
                                                                wnsprintf(szKey, countof(szKey), IK_DISAPPROVED_FMT, nDisapproved++);
                                                                WritePrivateProfileString(szSection, szKey, szURL, szFile);
                                                        }
                                                        else if (PR_POLICY_ACCEPTBYURL == dwAttrib)
                                                        {
                                                                wnsprintf(szKey, countof(szKey), IK_APPROVED_FMT, nApproved++);
                                                                WritePrivateProfileString(szSection, szKey, szURL, szFile);
                                                        }
                                                }
                                        }
                                }
                        }
                }

                // write out select ratings bureau
                cbSize = sizeof(szTemp);
                if (ERROR_SUCCESS == RegQueryValueEx(hkRat, IK_BUREAU, NULL, NULL,
                                                                                        (LPBYTE)szTemp, &cbSize))
                {
                        WritePrivateProfileString(szSection, IK_BUREAU, szTemp, szFile);
                }
        }
        __except(TRUE)
        {
        }
}

/////////////////////////////////////////////////////////////////////
static BOOL importRatingsHelper(LPCTSTR pcszInsFile, LPCTSTR pcszRatingsWorkDir, LPCTSTR pcszRatingsInf, BOOL fImportRatings)
{
    BOOL bRet = FALSE;
    HKEY hkRat = NULL;
    BOOL bRatLoadedAsHive = FALSE;

    if (pcszInsFile == NULL  ||  pcszRatingsInf == NULL)
        return FALSE;

    // Before processing anything, first clear out the entries in the INS file and delete work dirs

    // clear out the entries in the INS file that correspond to importing ratings
    InsDeleteKey(SECURITY_IMPORTS, TEXT("ImportRatings"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF,      TEXT("Ratings"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF_HKLM, TEXT("Ratings"), pcszInsFile);

    // blow away the pcszRatingsWorkDir and pcszRatingsInf
    if (pcszRatingsWorkDir != NULL)
        PathRemovePath(pcszRatingsWorkDir);
    PathRemovePath(pcszRatingsInf);

    if (!fImportRatings)
        return TRUE;

    if (ratingsInRegistry())
    {
        SHOpenKeyHKLM(REG_KEY_RATINGS, KEY_DEFAULT_ACCESS, &hkRat);
    }
    else
    {
        TCHAR szRatFile[MAX_PATH];

        GetSystemDirectory(szRatFile, countof(szRatFile));
        PathAppend(szRatFile, TEXT("ratings.pol"));

        if (RegLoadKey(HKEY_LOCAL_MACHINE, POLICYDATA, szRatFile) == ERROR_SUCCESS)
        {
            bRatLoadedAsHive = TRUE;
            SHOpenKeyHKLM(REG_KEY_POLICY_DATA, KEY_DEFAULT_ACCESS, &hkRat);
        }
    }

    if (hkRat != NULL)
    {
        TCHAR szFullInfName[MAX_PATH];
        HANDLE hInf;

        if (pcszRatingsWorkDir != NULL  &&  PathIsFileSpec(pcszRatingsInf)) // create RATINGS.INF under pcszRatingsWorkDir
            PathCombine(szFullInfName, pcszRatingsWorkDir, pcszRatingsInf);
        else
            StrCpy(szFullInfName, pcszRatingsInf);

        // create RATINGS.INF file
        if ((hInf = CreateNewFile(szFullInfName)) != INVALID_HANDLE_VALUE)
        {
            INT i;
            HKEY hkDef;
            TCHAR szSysDir[MAX_PATH];

            WriteStringToFile(hInf, RATINGS_INF_ADD, StrLen(RATINGS_INF_ADD));

            // convert the system path to %11% ldid
            for (i = 0;  i < 10;  i++)
            {
                TCHAR szNameParm[16];
                TCHAR szFileName[MAX_PATH];
                DWORD cbSize;

                wnsprintf(szNameParm, countof(szNameParm), TEXT("FileName%i"), i);

                cbSize = sizeof(szFileName);
                if (RegQueryValueEx(hkRat, szNameParm, NULL, NULL, (LPBYTE) szFileName, &cbSize) != ERROR_SUCCESS)
                    break;

                if (PathIsFullPath(szFileName))
                {
                    TCHAR szEncFileName[MAX_PATH];

                    // BUBBUG: Should we check if the path is really the system dir?
                    wnsprintf(szEncFileName, countof(szEncFileName), TEXT("%%11%%\\%s"), PathFindFileName(szFileName));

                    RegSetValueEx(hkRat, szNameParm, 0, REG_SZ, (CONST BYTE *)szEncFileName, (DWORD)StrCbFromSz(szEncFileName));
                }
            }

            RegFlushKey(hkRat);
            ExportRegKey2Inf(hkRat, TEXT("HKLM"), REG_KEY_RATINGS, hInf);
            WriteStringToFile(hInf, (LPCVOID) TEXT("\r\n"), 2);

            if (SHOpenKey(hkRat, TEXT(".Default"), KEY_DEFAULT_ACCESS, &hkDef) == ERROR_SUCCESS)
            {
                TCHAR szDefault[MAX_PATH];

                wnsprintf(szDefault, countof(szDefault), TEXT("%s\\.Default"), REG_KEY_RATINGS);
                ExportRegTree2Inf(hkDef, TEXT("HKLM"), szDefault, hInf);

                SHCloseKey(hkDef);
            }

            // new IE5 specific key

            if (SHOpenKey(hkRat, TEXT("PICSRules"), KEY_DEFAULT_ACCESS, &hkDef) == ERROR_SUCCESS)
            {
                TCHAR szRules[MAX_PATH];

                wnsprintf(szRules, countof(szRules), TEXT("%s\\PICSRules"), REG_KEY_RATINGS);
                ExportRegTree2Inf(hkDef, TEXT("HKLM"), szRules, hInf);

                SHCloseKey(hkDef);
            }

            if (bRatLoadedAsHive)
            {
                HKEY hkRatsInReg;

                // eventhough ratings has been loaded as a hive, the password is still in the registry
                if (SHOpenKeyHKLM(REG_KEY_RATINGS, KEY_DEFAULT_ACCESS, &hkRatsInReg) == ERROR_SUCCESS)
                {
                    ExportRegKey2Inf(hkRatsInReg, TEXT("HKLM"), REG_KEY_RATINGS, hInf);

                    SHCloseKey(hkRatsInReg);
                }

                // browser ratings code does some weird stuff with their hive, so we have to go to
                // the right level to get the new IE5 PICSRules key

                if (SHOpenKey(hkRat, REG_KEY_RATINGS TEXT("\\PICSRules"), KEY_DEFAULT_ACCESS, &hkRatsInReg) == ERROR_SUCCESS)
                {
                    TCHAR szRules[MAX_PATH];

                    wnsprintf(szRules, countof(szRules), TEXT("%s\\PICSRules"), REG_KEY_RATINGS);
                    ExportRegTree2Inf(hkDef, TEXT("HKLM"), szRules, hInf);

                    SHCloseKey(hkDef);
                }
            }

            CloseHandle(hInf);

            // update the INS file
            InsWriteBool(SECURITY_IMPORTS, TEXT("ImportRatings"), TRUE, pcszInsFile);
            wnsprintf(szSysDir, countof(szSysDir), TEXT("*,%s,") IS_DEFAULTINSTALL, PathFindFileName(pcszRatingsInf));
            WritePrivateProfileString(IS_EXTREGINF, TEXT("Ratings"), szSysDir, pcszInsFile);

            // write to new ExtRegInf.HKLM section
            if (!InsIsSectionEmpty(TEXT("AddReg.HKLM"), szFullInfName))
            {
                wnsprintf(szSysDir, countof(szSysDir), TEXT("%s,IEAKInstall.HKLM"), PathFindFileName(pcszRatingsInf));
                WritePrivateProfileString(IS_EXTREGINF_HKLM, TEXT("Ratings"), szSysDir, pcszInsFile);
            }

            bRet = TRUE;

            // restore the %11% ldid paths to the system dir
            GetSystemDirectory(szSysDir, countof(szSysDir));
            for (i = 0;  i < 10;  i++)
            {
                TCHAR szNameParm[16];
                TCHAR szEncFileName[MAX_PATH];
                DWORD cbSize;

                wnsprintf(szNameParm, countof(szNameParm), TEXT("FileName%i"), i);

                cbSize = sizeof(szEncFileName);
                if (RegQueryValueEx(hkRat, szNameParm, NULL, NULL, (LPBYTE) szEncFileName, &cbSize) != ERROR_SUCCESS)
                    break;

                if (PathIsFullPath(szEncFileName))
                {
                    TCHAR szFileName[MAX_PATH];

                    PathCombine(szFileName, szSysDir, PathFindFileName(szEncFileName));

                    RegSetValueEx(hkRat, szNameParm, 0, REG_SZ, (CONST BYTE *)szFileName, (DWORD)StrCbFromSz(szFileName));
                }
            }

            RegFlushKey(hkRat);
        }


                // create RATRSOP.INF file
                TCHAR szRRSOPInfFile[MAX_PATH];
                StrCpy(szRRSOPInfFile, szFullInfName);
                PathRemoveFileSpec(szRRSOPInfFile);
                StrCat(szRRSOPInfFile, TEXT("\\ratrsop.inf"));

                importRatingsForRSOP(hkRat, szRRSOPInfFile);

        SHCloseKey(hkRat);
    }

    if (bRatLoadedAsHive)
        RegUnLoadKey(HKEY_LOCAL_MACHINE, POLICYDATA);

    return bRet;
}


static BOOL ratingsInRegistry(VOID)
{
    BOOL fRet = TRUE;

    if (g_fRunningOnNT)
        return fRet;

    if (fRet)
    {
        HKEY hk;

        fRet = FALSE;

        if (SHOpenKeyHKLM(TEXT("System\\CurrentControlSet\\Control\\Update"), KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
        {
            DWORD dwData, cbSize;

            cbSize = sizeof(dwData);
            if (RegQueryValueEx(hk, TEXT("UpdateMode"), 0, NULL, (LPBYTE) &dwData, &cbSize) == ERROR_SUCCESS  &&  dwData)
                fRet = TRUE;

            SHCloseKey(hk);
        }
    }

    if (fRet)
    {
        HKEY hk;

        fRet = FALSE;

        if (SHOpenKeyHKLM(TEXT("Network\\Logon"), KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
        {
            DWORD dwData, cbSize;

            cbSize = sizeof(dwData);
            if (RegQueryValueEx(hk, TEXT("UserProfiles"), 0, NULL, (LPBYTE) &dwData, &cbSize) == ERROR_SUCCESS  &&  dwData)
                fRet = TRUE;

            SHCloseKey(hk);
        }
    }

    if (fRet)
    {
        HKEY hk;

        fRet = FALSE;

        if (SHOpenKeyHKLM(REG_KEY_RATINGS, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
        {
            HKEY hkRatDef;

            if (SHOpenKey(hk, TEXT(".Default"), KEY_DEFAULT_ACCESS, &hkRatDef) == ERROR_SUCCESS)
            {
                fRet = TRUE;
                SHCloseKey(hkRatDef);
            }

            SHCloseKey(hk);
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\seccerts.cpp ===
//
// SECCERTS.CPP
//

#include "precomp.h"
#include <wintrust.h>
#include <wintrustp.h>
#include <cryptui.h>

static BOOL importSiteCertHelper(LPCTSTR pcszInsFile, LPCTSTR pcszSCWorkDir, LPCTSTR pcszSCInf, BOOL fImportSC);
static BOOL importAuthCodeHelper(LPCTSTR pcszInsFile, LPCTSTR pcszAuthWorkDir, LPCTSTR pcszAuthInf, BOOL fImportAuth);

BOOL WINAPI ImportSiteCertA(LPCSTR pcszInsFile, LPCSTR pcszSCWorkDir, LPCSTR pcszSCInf, BOOL fImportSC)
{
    USES_CONVERSION;

    return importSiteCertHelper(A2CT(pcszInsFile), A2CT(pcszSCWorkDir), A2CT(pcszSCInf), fImportSC);
}

BOOL WINAPI ImportSiteCertW(LPCWSTR pcwszInsFile, LPCWSTR pcwszSCWorkDir, LPCWSTR pcwszSCInf, BOOL fImportSC)
{
    USES_CONVERSION;

    return importSiteCertHelper(W2CT(pcwszInsFile), W2CT(pcwszSCWorkDir), W2CT(pcwszSCInf), fImportSC);
}

BOOL WINAPI ModifySiteCert(HWND hDlg)
{
    typedef DWORD (WINAPI * CRYPTUIDLGCERTMGR)(PCCRYPTUI_CERT_MGR_STRUCT);

    BOOL fRet;
    HINSTANCE hCryptUI;
    CRYPTUIDLGCERTMGR lpfnCryptUIDlgCertMgr;
    CRYPTUI_CERT_MGR_STRUCT ccm;

    fRet = FALSE;

    hCryptUI = NULL;

    if ((hCryptUI = LoadLibrary(TEXT("cryptui.dll"))) == NULL)
        goto Exit;

    if ((lpfnCryptUIDlgCertMgr = (CRYPTUIDLGCERTMGR) GetProcAddress(hCryptUI, "CryptUIDlgCertMgr")) == NULL)
        goto Exit;

    fRet = TRUE;

    // call into cryptui.dll to modify the certs
    ZeroMemory(&ccm, sizeof(ccm));
    ccm.dwSize = sizeof(ccm);
    ccm.hwndParent = hDlg;
    lpfnCryptUIDlgCertMgr(&ccm);

Exit:
    if (hCryptUI != NULL)
        FreeLibrary(hCryptUI);

    return fRet;
}

BOOL WINAPI ImportAuthCodeA(LPCSTR pcszInsFile, LPCSTR pcszAuthWorkDir, LPCSTR pcszAuthInf, BOOL fImportAuth)
{
    USES_CONVERSION;

    return importAuthCodeHelper(A2CT(pcszInsFile), A2CT(pcszAuthWorkDir), A2CT(pcszAuthInf), fImportAuth);
}

BOOL WINAPI ImportAuthCodeW(LPCWSTR pcwszInsFile, LPCWSTR pcwszAuthWorkDir, LPCWSTR pcwszAuthInf, BOOL fImportAuth)
{
    USES_CONVERSION;

    return importAuthCodeHelper(W2CT(pcwszInsFile), W2CT(pcwszAuthWorkDir), W2CT(pcwszAuthInf), fImportAuth);
}

BOOL WINAPI ModifyAuthCode(HWND hDlg)
{
    HINSTANCE hWinTrust = NULL;
    HINSTANCE hSoftPub = NULL;
    BOOL fRet = FALSE;

        
    //Thanks to a change from the crypto team, this needs to behave differently on whistler
    if (IsOS(OS_WHISTLERORGREATER))
    {
        typedef BOOL (WINAPI * OPENPERSONALTRUSTDBDIALOGEX)(HWND,DWORD,PVOID);

        OPENPERSONALTRUSTDBDIALOGEX pfnOpenPersonalTrustDBDialogEx;

        hWinTrust = NULL;
        hSoftPub = NULL;

        if ((hWinTrust = LoadLibrary(TEXT("wintrust.dll"))) == NULL)
            goto Exit;

        if ((pfnOpenPersonalTrustDBDialogEx = (OPENPERSONALTRUSTDBDIALOGEX) GetProcAddress(hWinTrust, "OpenPersonalTrustDBDialogEx")) == NULL)
            goto Exit;
        
        fRet = TRUE;
        DWORD dwFlags = WT_TRUSTDBDIALOG_ONLY_PUB_TAB_FLAG|WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG|WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG;

        // call into wintrust.dll/softpub.dll to modify the certs
        pfnOpenPersonalTrustDBDialogEx(hDlg,dwFlags,NULL);
    }
    else
    {
        typedef BOOL (WINAPI * OPENPERSONALTRUSTDBDIALOG)(HWND);

        HINSTANCE hWinTrust, hSoftPub;
        
        OPENPERSONALTRUSTDBDIALOG pfnOpenPersonalTrustDBDialog;

        hWinTrust = NULL;
        hSoftPub = NULL;

        if ((hWinTrust = LoadLibrary(TEXT("wintrust.dll"))) == NULL)
            goto Exit;

        if ((pfnOpenPersonalTrustDBDialog = (OPENPERSONALTRUSTDBDIALOG) GetProcAddress(hWinTrust, "OpenPersonalTrustDBDialog")) == NULL)
        {
            FreeLibrary(hWinTrust);
            hWinTrust = NULL;

            // We can also find the same function on NT machines (and possibly future Win9x's)
            // in SOFTPUB.DLL, so make another check there too
            if ((hSoftPub = LoadLibrary(TEXT("softpub.dll"))) == NULL)
                goto Exit;
            if ((pfnOpenPersonalTrustDBDialog = (OPENPERSONALTRUSTDBDIALOG) GetProcAddress(hSoftPub, "OpenPersonalTrustDBDialog")) == NULL)
                goto Exit;
        }
        
        fRet = TRUE;

        // call into wintrust.dll/softpub.dll to modify the certs
        pfnOpenPersonalTrustDBDialog(hDlg);

    }

Exit:
    if (hWinTrust != NULL)
        FreeLibrary(hWinTrust);

    if (hSoftPub != NULL)
        FreeLibrary(hSoftPub);

    return fRet;
}

static BOOL importSiteCertHelper(LPCTSTR pcszInsFile, LPCTSTR pcszSCWorkDir, LPCTSTR pcszSCInf, BOOL fImportSC)
{
    BOOL bRet = FALSE;
    TCHAR szFullInfName[MAX_PATH];
    HANDLE hInf;

    if (pcszInsFile == NULL  ||  pcszSCInf == NULL)
        return FALSE;

    // Before processing anything, first clear out the entries in the INS file and delete work dirs

    // clear out the entries in the INS file that correspond to importing security certificates
    InsDeleteKey(SECURITY_IMPORTS, TEXT("ImportSiteCert"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF,      TEXT("SiteCert"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF_HKLM, TEXT("SiteCert"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF_HKCU, TEXT("SiteCert"), pcszInsFile);

    // blow away the pcszSCWorkDir and pcszSCInf
    if (pcszSCWorkDir != NULL)
        PathRemovePath(pcszSCWorkDir);
    PathRemovePath(pcszSCInf);

    if (!fImportSC)
        return TRUE;

    if (pcszSCWorkDir != NULL  &&  PathIsFileSpec(pcszSCInf))   // create SITECERT.INF under pcszSCWorkDir
        PathCombine(szFullInfName, pcszSCWorkDir, pcszSCInf);
    else
        StrCpy(szFullInfName, pcszSCInf);

    // create SITECERT.INF file
    if ((hInf = CreateNewFile(szFullInfName)) != INVALID_HANDLE_VALUE)
    {
        TCHAR szBuf[MAX_PATH];
        HKEY hkSite1 = NULL, hkSite2 = NULL;

        // first, write the standard goo - [Version], [DefaultInstall], etc. - to SITECERT.INF
        WriteStringToFile(hInf, (LPCVOID) SC_INF_ADD, StrLen(SC_INF_ADD));

        SHOpenKeyHKLM(REG_KEY_SITECERT1, KEY_DEFAULT_ACCESS, &hkSite1);
        SHOpenKeyHKLM(REG_KEY_SITECERT2, KEY_DEFAULT_ACCESS, &hkSite2);
        if (hkSite1 != NULL  &&  hkSite2 != NULL)
        {
            ExportRegTree2Inf(hkSite1, TEXT("HKLM"), REG_KEY_SITECERT1, hInf);
            ExportRegTree2Inf(hkSite2, TEXT("HKLM"), REG_KEY_SITECERT2, hInf);

            bRet = TRUE;
        }
        SHCloseKey(hkSite1);
        SHCloseKey(hkSite2);

        SHOpenKeyHKCU(REG_KEY_SITECERT1, KEY_DEFAULT_ACCESS, &hkSite1);
        SHOpenKeyHKCU(REG_KEY_SITECERT2, KEY_DEFAULT_ACCESS, &hkSite2);
        if (hkSite1 != NULL  &&  hkSite2 != NULL)
        {
            // write [AddReg.HKCU]
            WriteStringToFile(hInf, (LPCVOID) SC_INF_ADDREG_HKCU, StrLen(SC_INF_ADDREG_HKCU));
            ExportRegTree2Inf(hkSite1, TEXT("HKCU"), REG_KEY_SITECERT1, hInf);
            ExportRegTree2Inf(hkSite2, TEXT("HKCU"), REG_KEY_SITECERT2, hInf);

            bRet = TRUE;
        }
        SHCloseKey(hkSite1);
        SHCloseKey(hkSite2);

        CloseHandle(hInf);

        // update the INS file
        InsWriteBool(SECURITY_IMPORTS, TEXT("ImportSiteCert"), TRUE, pcszInsFile);
        wnsprintf(szBuf, countof(szBuf), TEXT("*,%s,") IS_DEFAULTINSTALL, PathFindFileName(pcszSCInf));
        WritePrivateProfileString(IS_EXTREGINF, TEXT("SiteCert"), szBuf, pcszInsFile);

        // write to new ExtRegInf.HKLM and ExtRegInf.HKCU sections
        if (!InsIsSectionEmpty(IS_IEAKADDREG_HKLM, szFullInfName))
        {
            wnsprintf(szBuf, countof(szBuf), TEXT("%s,") IS_IEAKINSTALL_HKLM, PathFindFileName(pcszSCInf));
            WritePrivateProfileString(IS_EXTREGINF_HKLM, TEXT("SiteCert"), szBuf, pcszInsFile);
        }

        if (!InsIsSectionEmpty(IS_IEAKADDREG_HKCU, szFullInfName))
        {
            wnsprintf(szBuf, countof(szBuf), TEXT("%s,") IS_IEAKINSTALL_HKCU, PathFindFileName(pcszSCInf));
            WritePrivateProfileString(IS_EXTREGINF_HKCU, TEXT("SiteCert"), szBuf, pcszInsFile);
        }
    }

    return bRet;
}

static BOOL importAuthCodeHelper(LPCTSTR pcszInsFile, LPCTSTR pcszAuthWorkDir, LPCTSTR pcszAuthInf, BOOL fImportAuth)
{
    BOOL bRet = FALSE;
    HKEY hkAuth;

    if (pcszInsFile == NULL  ||  pcszAuthInf == NULL)
        return FALSE;

    // Before processing anything, first clear out the entries in the INS file and delete work dirs

    // clear out the entries in the INS file that correspond to importing authenticode settings
    InsDeleteKey(SECURITY_IMPORTS, TEXT("ImportAuthCode"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF,      TEXT("AuthCode"), pcszInsFile);
    InsDeleteKey(IS_EXTREGINF_HKLM, TEXT("AuthCode"), pcszInsFile);

    // blow away the pcszAuthWorkDir and pcszAuthInf
    if (pcszAuthWorkDir != NULL)
        PathRemovePath(pcszAuthWorkDir);
    PathRemovePath(pcszAuthInf);

    if (!fImportAuth)
        return TRUE;

    if (SHOpenKeyHKCU(REG_KEY_AUTHENTICODE, KEY_DEFAULT_ACCESS, &hkAuth) == ERROR_SUCCESS)
    {
        TCHAR szFullInfName[MAX_PATH];
        HANDLE hInf;

        if (pcszAuthWorkDir != NULL  &&  PathIsFileSpec(pcszAuthInf))   // create AUTHCODE.INF under pcszAuthWorkDir
            PathCombine(szFullInfName, pcszAuthWorkDir, pcszAuthInf);
        else
            StrCpy(szFullInfName, pcszAuthInf);

        // create AUTHCODE.INF file
        if ((hInf = CreateNewFile(szFullInfName)) != INVALID_HANDLE_VALUE)
        {
            TCHAR szBuf[MAX_PATH];

            // first, write the standard goo - [Version], [DefaultInstall], etc. - to AUTHCODE.INF
            WriteStringToFile(hInf, (LPCVOID) AUTH_INF_ADD, StrLen(AUTH_INF_ADD));

            ExportRegTree2Inf(hkAuth, TEXT("HKCU"), REG_KEY_AUTHENTICODE, hInf);

            CloseHandle(hInf);

            // update the INS file
            InsWriteBool(SECURITY_IMPORTS, TEXT("ImportAuthCode"), TRUE, pcszInsFile);
            wnsprintf(szBuf, countof(szBuf), TEXT("*,%s,") IS_DEFAULTINSTALL, PathFindFileName(pcszAuthInf));
            WritePrivateProfileString(IS_EXTREGINF, TEXT("AuthCode"), szBuf, pcszInsFile);

            // write to new ExtRegInf.HKCU section
            if (!InsIsSectionEmpty(IS_IEAKADDREG_HKCU, szFullInfName))
            {
                wnsprintf(szBuf, countof(szBuf), TEXT("%s,") IS_IEAKINSTALL_HKCU, PathFindFileName(pcszAuthInf));
                WritePrivateProfileString(IS_EXTREGINF_HKCU, TEXT("AuthCode"), szBuf, pcszInsFile);
            }

            bRet = TRUE;
        }

        SHCloseKey(hkAuth);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

// macro definitions
#define MAX_URL INTERNET_MAX_URL_LENGTH

//WIn64 macros
#ifdef _WIN64
#if defined (_AMD64_) || defined (_IA64_)
#define ALIGNTYPE           LARGE_INTEGER
#else
#define ALIGNTYPE           DWORD
#endif
#define	ALIGN               ((ULONG) (sizeof(ALIGNTYPE) - 1))
#define LcbAlignLcb(lcb)    (((lcb) + ALIGN) & ~ALIGN)
#define PbAlignPb(pb)       ((LPBYTE) ((((DWORD) (pb)) + ALIGN) & ~ALIGN))
#define	MYALIGN             ((POINTER_64_INT) (sizeof(ALIGNTYPE) - 1))
#define MyPbAlignPb(pb)     ((LPBYTE) ((((POINTER_64_INT) (pb)) + MYALIGN) & ~MYALIGN))
#else //!WIN64
#define LcbAlignLcb(lcb)    (lcb)
#define PbAlignPb(pb)       (pb)
#define MyPbAlignPb(pb)     (pb)
#endif 

// prototype declarations

#define IsBitmapFile(hDlg, nID) (IsBitmapFileValid((hDlg), (nID), NULL, NULL, 0, 0, 0, 0))
void    AppendCommaHex(LPTSTR pszBuf, BYTE bData, DWORD dwFlags);
void    MoveFileToWorkDir(LPCTSTR pcszFile, LPCTSTR pcszSrcDir, LPCTSTR pcszWorkDir, BOOL fHTM = FALSE);

// conversion functions between ansi and unicode in convert.cpp

LPNMTVGETINFOTIPW TVInfoTipA2W(LPNMTVGETINFOTIPA pTvInfoTipA, LPNMTVGETINFOTIPW pTvInfoTipW);
LPNMTVGETINFOTIPA TVInfoTipW2A(LPNMTVGETINFOTIPW pTvInfoTipW, LPNMTVGETINFOTIPA pTvInfoTipA);
LPNMTVGETINFOTIP  TVInfoTipSameToSame(LPNMTVGETINFOTIP pTvInfoTipIn,
                                      LPNMTVGETINFOTIP pTvInfoTipOut);

LPRESULTITEMW ResultItemA2W(LPRESULTITEMA pResultItemA, LPRESULTITEMW pResultItemW);
LPRESULTITEMA ResultItemW2A(LPRESULTITEMW pResultItemW, LPRESULTITEMA pResultItemA);
LPRESULTITEM ResultItemSameToSame(LPRESULTITEM pResultItemIn, LPRESULTITEM pResultItemOut);

#ifdef UNICODE

#define TVInfoTipT2W(pTvInfoTip, pTvInfoTipW) TVInfoTipSameToSame((pTvInfoTip), (pTvInfoTipW))
#define TVInfoTipW2T(pTvInfoTipW, pTvInfoTip) TVInfoTipSameToSame((pTvInfoTipW), (pTvInfoTip))

#define TVInfoTipT2A(pTvInfoTip, pTvInfoTipA) TVInfoTipW2A((pTvInfoTip), (pTvInfoTipA))
#define TVInfoTipA2T(pTvInfoTipA, pTvInfoTip) TVInfoTipA2W((pTvInfoTipA), (pTvInfoTip))

#define ResultItemT2W(pResultItem, pResultItemW) ResultItemSameToSame((pResultItem), (pResultItemW))
#define ResultItemW2T(pResultItemW, pResultItem) ResultItemSameToSame((pResultItemW), (pResultItem))

#define ResultItemT2A(pResultItem, pResultItemA) ResultItemW2A((pResultItem), (pResultItemA))
#define ResultItemA2T(pResultItemA, pResultItem) ResultItemA2W((pResultItemA), (pResultItem))

#else

#define TVInfoTipT2W(pTvInfoTip, pTvInfoTipW) TVInfoTipA2W((pTvInfoTip), (pTvInfoTipW))
#define TVInfoTipW2T(pTvInfoTipW, pTvInfoTip) TVInfoTipW2A((pTvInfoTipW), (pTvInfoTip))

#define TVInfoTipT2A(pTvInfoTip, pTvInfoTipA) TVInfoTipSameToSame((pTvInfoTip), (pTvInfoTipA))
#define TVInfoTipA2T(pTvInfoTipA, pTvInfoTip) TVInfoTipSameToSame((pTvInfoTipA), (pTvInfoTip))

#define ResultItemT2W(pResultItem, pResultItemW) ResultItemA2W((pResultItem), (pResultItemW))
#define ResultItemW2T(pResultItemW, pResultItem) ResultItemW2A((pResultItemW), (pResultItem))

#define ResultItemT2A(pResultItem, pResultItemA) ResultItemSameToSame((pResultItem), (pResultItemA))
#define ResultItemA2T(pResultItemA, pResultItem) ResultItemSameToSame((pResultItemA), (pResultItem))

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\utils.cpp ===
//
// UTILS.CPP
//
#include "precomp.h"

static BOOL isAnimBitmapFileValidHelper(HWND hDlg, UINT nID, LPTSTR pszBuffer, PUINT pcch, UINT nIDTooBig,
                              UINT nIDTooSmall, long lBmpMinWidth, long lBmpMaxWidth);
static BOOL isBitmapFileValidHelper(HWND hDlg, UINT nID, LPTSTR pszBuffer, PUINT pcch,
                                    int cx, int cy, UINT nIDTooBig, UINT nIDTooSmall, DWORD dwFlags);
static BOOL browseForFileHelper(HWND hDlg, LPTSTR pszFileName, DWORD cchSize, DWORD dwFilterMasks,
                                LPCTSTR pcszTitle);
static BOOL browseForFolderHelper(HWND hDlg, LPTSTR pszFileName, LPCTSTR pcszDesc);
static void exportRegTree2InfHelper(HKEY hk, LPCTSTR pszHive, LPCTSTR pszKey, HANDLE hInf, BOOL fUseLdids);
static void exportRegValue2InfHelper(HKEY hkSubKey, LPCTSTR pcszValue, LPCTSTR pcszRootKey, LPCTSTR pcszSubKey, HANDLE hInf, BOOL fUseLdids);
static void exportRegKey2InfHelper(HKEY hkSubKey, LPCTSTR pcszRootKey, LPCTSTR pcszSubKey, HANDLE hInf, BOOL fUseLdids);
static void signFileHelper(LPCTSTR pcszFilename, LPCTSTR pcszDir, LPCTSTR pcszIns, LPTSTR pszUnsignedFiles, LPCTSTR pcszCustInf, BOOL fTest);

BOOL WINAPI CheckField(HWND hDlg, int nIDDlgItem, DWORD dwFlags, LPARAM lParam /*= 0*/)
{
    TCHAR szField[INTERNET_MAX_URL_LENGTH];
    HWND  hCtrl;
    UINT  nID, nStartPos;

    hCtrl = GetDlgItem(hDlg, nIDDlgItem);
    if (hCtrl == NULL)
        return FALSE;

    szField[0] = TEXT('\0');
    GetWindowText(hCtrl, szField, countof(szField));
    StrRemoveWhitespace(szField);

    nID = nStartPos = 0;
    if (HasFlag(dwFlags, FC_NONNULL)) {
        if (szField[0] == TEXT('\0')) {
            nID       = IDS_CF_EMPTY_FIELD;
            nStartPos = 0;
        }
    }
    else
        if (szField[0] == TEXT('\0'))
            return TRUE;

    if (nID == 0 && HasFlag(dwFlags, FC_URL))
        if (!PathIsURL(szField)) {
            nID       = IDS_CF_INVALID_URL;
            nStartPos = 0;
        }

    if (nID == 0 && HasFlag(dwFlags, FC_NOSPACE)) {
        LPCTSTR pszChar;

        for (pszChar = szField; *pszChar; pszChar = CharNext(pszChar))
            if (IsSpace(*pszChar)) {
                nID = IDS_CF_INVALID_SPACE;
                nStartPos = 0;
            }
    }

    if (nID == 0 && HasFlag(dwFlags, FC_NOCOLON)) {
        if (StrChr(szField, TEXT(':'))) {
            nID = IDS_CF_INVALID_COLON;
            nStartPos = 0;
        }
    }

    if (nID == 0 && HasFlag(dwFlags, FC_NUMBER)) {
        int nLen = StrLen(szField);

        for (int nIndex = 0; nIndex < nLen; nIndex++) {
            if (!(szField[nIndex] >= TEXT('0') && szField[nIndex] <= TEXT('9'))) {
                nID = IDS_CF_INVALID_NUMBER;
                nStartPos = nIndex;
                break;
            }
        }
    }

    if (!(nID == 0 && HasFlag(dwFlags, FC_URL)) &&
         (nID == 0 || HasFlag(dwFlags, FC_URL)) && HasFlag(dwFlags, FC_PATH)) {
        LPCTSTR pszError;
        DWORD   dwResult = PIVP_VALID;

        ASSERT(HasFlag(dwFlags, FC_URL) ? nID != 0 : TRUE);

        nID = nStartPos = 0;
        SetFlag(&dwFlags, FC_PATH, FALSE);

        if (HasFlag(dwFlags, FC_FILE))
        {
            if (HasFlag(dwFlags, FC_EXISTS))
                SetFlag((LPDWORD)&lParam, PIVP_FILE_ONLY);
        }
        else if (HasFlag(dwFlags, FC_DIR))
        {
            if (HasFlag(dwFlags, FC_EXISTS))
                SetFlag((LPDWORD)&lParam, PIVP_FOLDER_ONLY);
        }

        dwResult = PathIsValidPathEx(szField, (DWORD) lParam, &pszError);

        // check for extended character in the field
        if (dwResult == PIVP_VALID) {
            if (HasFlag(dwFlags, FC_FILE))
            {
                SetFlag((LPDWORD)&lParam, PIVP_FILE_ONLY, FALSE);
                if (HasFlag(dwFlags, FC_NOEXCHAR))
                    SetFlag((LPDWORD)&lParam, (PIVP_FILENAME_ONLY | PIVP_EXCHAR_INVALID));
                else
                    SetFlag((LPDWORD)&lParam, (PIVP_FILENAME_ONLY | PIVP_0x5C_INVALID));

                dwResult = PathIsValidPathEx(PathFindFileName(szField), (DWORD) lParam, &pszError);
            }
            else if (HasFlag(dwFlags, FC_DIR))
            {
                if (HasFlag(dwFlags, FC_NOEXCHAR))
                    dwResult = PathIsValidPathEx(szField, PIVP_EXCHAR_INVALID, &pszError);
            }
        }

        if (dwResult != PIVP_VALID) {
            static struct {
                DWORD dwError;
                UINT  nID;
            } rgMap[] = {
                { PIVP_CHAR,         IDS_CF_CHAR         },
                { PIVP_WILD,         IDS_CF_WILD         },
                { PIVP_RELATIVE,     IDS_CF_RELATIVE     },
                { PIVP_FIRST_CHAR,   IDS_CF_FIRST_CHAR   },
                { PIVP_PRESLASH,     IDS_CF_PRESLASH     },
                { PIVP_SPACE,        IDS_CF_SPACE        },
                { PIVP_FWDSLASH,     IDS_CF_FWDSLASH     },
                { PIVP_COLON,        IDS_CF_COLON        },
                { PIVP_DRIVE,        IDS_CF_DRIVE        },
                { PIVP_SEPARATOR,    IDS_CF_SEPARATOR    },
                { PIVP_DBCS,         IDS_CF_DBCS         },
                { PIVP_0x5C,         IDS_CF_0x5C         },
                { PIVP_DOESNT_EXIST, IDS_CF_DOESNT_EXIST },
                { PIVP_NOT_FILE,     IDS_CF_NOT_FILE     },
                { PIVP_NOT_FOLDER,   IDS_CF_NOT_FOLDER   },
                { PIVP_EXCHAR,       IDS_CF_EXCHAR       },
                { 0,                 IDS_CF_UNKNOWN      }
            };

            ASSERT(pszError >= szField);
            for (UINT i = 0; i < countof(rgMap)-1; i++)
                if (dwResult == rgMap[i].dwError)
                    break;
            ASSERT(i < countof(rgMap));

            nID       = rgMap[i].nID;
            nStartPos = (pszError != NULL ? (int)(pszError - szField) : 0);
        }
    }

    if (nID != 0) {
        ErrorMessageBox(hDlg, nID);
        Edit_SetSel(hCtrl, nStartPos, -1);
        SetFocus(hCtrl);

        return FALSE;
    }

    return TRUE;
}

BOOL WINAPI IsAnimBitmapFileValidA(HWND hDlg, UINT nID, LPSTR pszBuffer, PUINT pcch, UINT nIDTooBig,
                                   UINT nIDTooSmall, long lBmpMinWidth, long lBmpMaxWidth)
{
    LPTSTR pszBuf;
    BOOL  fRet;

    USES_CONVERSION;

    if ((pcch != NULL) && (*pcch != 0))
        pszBuf = (LPTSTR)LocalAlloc(LPTR, (*pcch) * sizeof(TCHAR));
    else
        pszBuf = (LPTSTR)LocalAlloc(LPTR, MAX_PATH * sizeof(TCHAR));

    if (pszBuf == NULL)
        fRet = FALSE;
    else
    {
        A2Tbux(pszBuffer, pszBuf);
        fRet = isAnimBitmapFileValidHelper(hDlg, nID, pszBuf, pcch, nIDTooBig, nIDTooSmall, lBmpMinWidth, lBmpMaxWidth);
        T2Abux(pszBuf, pszBuffer);
        LocalFree(pszBuf);
    }

    return fRet;
}

BOOL WINAPI IsAnimBitmapFileValidW(HWND hDlg, UINT nID, LPWSTR pwszBuffer, PUINT pcch, UINT nIDTooBig,
                                   UINT nIDTooSmall, long lBmpMinWidth, long lBmpMaxWidth)
{
    LPTSTR pszBuf;
    BOOL  fRet;

    USES_CONVERSION;

    if ((pcch != NULL) && (*pcch != 0))
        pszBuf = (LPTSTR)LocalAlloc(LPTR, (*pcch) * sizeof(TCHAR));
    else
        pszBuf = (LPTSTR)LocalAlloc(LPTR, MAX_PATH * sizeof(TCHAR));

    if (pszBuf == NULL)
        fRet = FALSE;
    else
    {
        W2Tbux(pwszBuffer, pszBuf);
        fRet = isAnimBitmapFileValidHelper(hDlg, nID, pszBuf, pcch, nIDTooBig, nIDTooSmall, lBmpMinWidth, lBmpMaxWidth);
        T2Wbux(pszBuf, pwszBuffer);
        LocalFree(pszBuf);
    }

    return fRet;
}

BOOL WINAPI IsBitmapFileValidA(HWND hDlg, UINT nID, LPSTR pszBuffer, PUINT pcch, int cx, int cy,
                               UINT nIDTooBig, UINT nIDTooSmall, DWORD dwFlags /*= 0 */)
{
    LPTSTR pszBuf;
    BOOL  fRet;

    USES_CONVERSION;

    if ((pcch != NULL) && (*pcch != 0))
        pszBuf = (LPTSTR)LocalAlloc(LPTR, (*pcch) * sizeof(TCHAR));
    else
        pszBuf = (LPTSTR)LocalAlloc(LPTR, MAX_PATH * sizeof(TCHAR));

    if (pszBuf == NULL)
        fRet = FALSE;
    else
    {
        A2Tbux(pszBuffer, pszBuf);
        fRet = isBitmapFileValidHelper(hDlg, nID, pszBuf, pcch, cx, cy, nIDTooBig, nIDTooSmall, dwFlags);
        T2Abux(pszBuf, pszBuffer);
        LocalFree(pszBuf);
    }

    return fRet;
}

BOOL WINAPI IsBitmapFileValidW(HWND hDlg, UINT nID, LPWSTR pwszBuffer, PUINT pcch, int cx, int cy,
                               UINT nIDTooBig, UINT nIDTooSmall, DWORD dwFlags /*= 0 */)
{
    LPTSTR pszBuf;
    BOOL  fRet;

    USES_CONVERSION;

    if ((pcch != NULL) && (*pcch != 0))
        pszBuf = (LPTSTR)LocalAlloc(LPTR, (*pcch) * sizeof(TCHAR));
    else
        pszBuf = (LPTSTR)LocalAlloc(LPTR, MAX_PATH * sizeof(TCHAR));

    if (pszBuf == NULL)
        fRet = FALSE;
    else
    {
        W2Tbux(pwszBuffer, pszBuf);
        fRet = isBitmapFileValidHelper(hDlg, nID, pszBuf, pcch, cx, cy, nIDTooBig, nIDTooSmall, dwFlags);
        T2Wbux(pszBuf, pwszBuffer);
        LocalFree(pszBuf);
    }

    return fRet;
}

void WINAPI SetLBWidth(HWND hLb)
{
    HDC hDc = GetDC( hLb );
    LONG wMax = 0;
    SIZE sText;
    POINT point;
    int i;
    int nItems = (int) SendMessage( hLb, LB_GETCOUNT, 0, 0 );
    for (i = 0; i < nItems ; i++ )
    {
        TCHAR szText[MAX_PATH];
        SendMessage(hLb, LB_GETTEXT, i, (LPARAM) szText);
        GetTextExtentPoint32( hDc, szText, StrLen(szText), &sText );
        if (sText.cx > wMax) wMax = sText.cx;
    }

    point.y=0;
    point.x=wMax;

    LPtoDP(hDc,&point,1);  //TODO: this is still not exactly what we want--why does it have extra space???!!

    SendMessage( hLb, LB_SETHORIZONTALEXTENT, point.x, 0 );
    ReleaseDC(hLb, hDc);
}

BOOL WINAPI BrowseForFileA(HWND hDlg, LPSTR pszFileName, DWORD cchSize, DWORD dwFilterMasks, LPCSTR pcszTitle /* = NULL */)
{
    LPTSTR pszBuf = (LPTSTR)LocalAlloc(LPTR, cchSize * sizeof(TCHAR));
    BOOL  fRet;

    USES_CONVERSION;

    if (pszBuf == NULL)
        fRet = FALSE;
    else
    {
        A2Tbux(pszFileName, pszBuf);
        fRet = browseForFileHelper(hDlg, pszBuf, cchSize, dwFilterMasks,
            (pcszTitle == NULL) ? NULL : A2CT(pcszTitle));
        T2Abux(pszBuf, pszFileName);
        LocalFree(pszBuf);
    }

    return fRet;
}

BOOL WINAPI BrowseForFileW(HWND hDlg, LPWSTR pwszFileName, DWORD cchSize, DWORD dwFilterMasks, LPCWSTR pcwszTitle /*= NULL */)
{
    LPTSTR pszBuf = (LPTSTR)LocalAlloc(LPTR, cchSize * sizeof(TCHAR));
    BOOL  fRet;

    USES_CONVERSION;

    if (pszBuf == NULL)
        fRet = FALSE;
    else
    {
        W2Tbux(pwszFileName, pszBuf);
        fRet = browseForFileHelper(hDlg, pszBuf, cchSize, dwFilterMasks,
            (pcwszTitle == NULL) ? NULL : W2CT(pcwszTitle));
        T2Wbux(pszBuf, pwszFileName);
        LocalFree(pszBuf);
    }

    return fRet;
}

BOOL WINAPI BrowseForFolderA(HWND hDlg, LPSTR pszFileName, LPCSTR pcszDesc /*= NULL */)
{
    TCHAR szFileName[MAX_PATH];
    BOOL fRet;

    USES_CONVERSION;

    fRet = browseForFolderHelper(hDlg, szFileName, (pcszDesc == NULL) ? NULL : A2CT(pcszDesc));
    T2Abux(szFileName, pszFileName);
    return fRet;
}

BOOL WINAPI BrowseForFolderW(HWND hDlg, LPWSTR pwszFileName, LPCWSTR pcwszDesc /* = NULL */)
{
    TCHAR szFileName[MAX_PATH];
    BOOL fRet;

    USES_CONVERSION;

    fRet = browseForFolderHelper(hDlg, szFileName, (pcwszDesc == NULL) ? NULL : W2CT(pcwszDesc));
    T2Wbux(szFileName, pwszFileName);

    return fRet;
}

void WINAPI ExportRegTree2InfA(HKEY hkSubKey, LPCSTR pcszRootKey, LPCSTR pcszSubKey, HANDLE hInf, BOOL fUseLdids /*= FALSE */)
{
    USES_CONVERSION;

    exportRegTree2InfHelper(hkSubKey, A2CT(pcszRootKey), A2CT(pcszSubKey), hInf, fUseLdids);
}

void WINAPI ExportRegTree2InfW(HKEY hkSubKey, LPCWSTR pcwszRootKey, LPCWSTR pcwszSubKey, HANDLE hInf, BOOL fUseLdids /*= FALSE */)
{
    USES_CONVERSION;

    exportRegTree2InfHelper(hkSubKey, W2CT(pcwszRootKey), W2CT(pcwszSubKey), hInf, fUseLdids);
}

void WINAPI ExportRegKey2InfA(HKEY hkSubKey, LPCSTR pcszRootKey, LPCSTR pcszSubKey, HANDLE hInf, BOOL fUseLdids /*= FALSE */)
{
    USES_CONVERSION;

    exportRegKey2InfHelper(hkSubKey, A2CT(pcszRootKey), A2CT(pcszSubKey), hInf, fUseLdids);
}

void WINAPI ExportRegKey2InfW(HKEY hkSubKey, LPCWSTR pcwszRootKey, LPCWSTR pcwszSubKey, HANDLE hInf, BOOL fUseLdids /*= FALSE */)
{
    USES_CONVERSION;

    exportRegKey2InfHelper(hkSubKey, W2CT(pcwszRootKey), W2CT(pcwszSubKey), hInf, fUseLdids);
}

void WINAPI ExportRegValue2InfA(HKEY hkSubKey, LPCSTR pcszValue, LPCSTR pcszRootKey, LPCSTR pcszSubKey, HANDLE hInf, BOOL fUseLdids /* = FALSE */)
{
    USES_CONVERSION;

    exportRegValue2InfHelper(hkSubKey, A2CT(pcszValue), A2CT(pcszRootKey), A2CT(pcszSubKey), hInf, fUseLdids);
}

void WINAPI ExportRegValue2InfW(HKEY hkSubKey, LPCWSTR pcwszValue, LPCWSTR pcwszRootKey, LPCWSTR pcwszSubKey, HANDLE hInf, BOOL fUseLdids /* = FALSE */)
{
    USES_CONVERSION;

    exportRegValue2InfHelper(hkSubKey, W2CT(pcwszValue), W2CT(pcwszRootKey), W2CT(pcwszSubKey), hInf, fUseLdids);
}

void AppendCommaHex(LPTSTR pszBuf, BYTE bData, DWORD dwFlags)
{
    CHAR szData[2] = "0";
    CHAR c1;

    USES_CONVERSION;

    if (dwFlags & 0x0001)
        StrCat(pszBuf, TEXT(","));

    c1 = (CHAR)('0' + ((bData >> 4) & 0x0f));
    if (c1 > '9')
        c1 += 'A' - '9' - 1;
    *szData = c1;

    StrCat(pszBuf, A2T(szData));

    c1 = (CHAR)('0' + (bData & 0x0f));
    if (c1 > '9')
        c1 += 'A' - '9' - 1;
    *szData = c1;

    StrCat(pszBuf, A2T(szData));
}

void WINAPI SignFileA(LPCSTR pcszFilename, LPCSTR pcszDir, LPCSTR pcszIns, LPSTR pszUnsignedFiles /* = NULL */, LPCSTR pcszCustInf /* = NULL */, BOOL fTest /* = FALSE */)
{
    LPTSTR pszBuf = NULL;

    USES_CONVERSION;

    // allocate enough to for one file along with carriage return, new line and null termination
    // we'll manually append to the end of unsigned files to save on thunking

    if (pszUnsignedFiles != NULL)
        pszBuf = (LPTSTR)LocalAlloc(LPTR, (MAX_PATH + 3)*sizeof(TCHAR));

    signFileHelper(A2CT(pcszFilename), A2CT(pcszDir), A2CT(pcszIns), pszBuf,
        (pcszCustInf == NULL) ? NULL : A2CT(pcszCustInf), fTest);

    if (pszBuf != NULL)
    {
        StrCatA(pszUnsignedFiles, T2A(pszBuf));
        LocalFree(pszBuf);
    }
}

void WINAPI SignFileW(LPCWSTR pcwszFilename, LPCWSTR pcwszDir, LPCWSTR pcwszIns, LPWSTR pwszUnsignedFiles /* = NULL */, LPCWSTR pcwszCustInf /* = NULL */, BOOL fTest /* = FALSE */)
{
    LPTSTR pszBuf = NULL;

    USES_CONVERSION;

    // allocate enough to for one file along with carriage return, new line and null termination
    // we'll manually append to the end of unsigned files to save on thunking

    if (pwszUnsignedFiles != NULL)
        pszBuf = (LPTSTR)LocalAlloc(LPTR, (MAX_PATH + 3)*sizeof(TCHAR));

    signFileHelper(W2CT(pcwszFilename), W2CT(pcwszDir), W2CT(pcwszIns), pszBuf,
        (pcwszCustInf == NULL) ? NULL : W2CT(pcwszCustInf), fTest);

    if (pszBuf != NULL)
    {
        StrCatW(pwszUnsignedFiles, T2W(pszBuf));
        LocalFree(pszBuf);
    }
}

void MoveFileToWorkDir(LPCTSTR pcszFile, LPCTSTR pcszSrcDir, LPCTSTR pcszWorkDir, BOOL fHTM /* = FALSE */)
{
    TCHAR szFile[MAX_PATH];

    PathCombine(szFile, pcszWorkDir, pcszFile);
    
    if (!PathFileExists(szFile))
    {
        PathCombine(szFile, pcszSrcDir, pcszFile);

        if (PathFileExists(szFile))
        {
            CopyFileToDir(szFile, pcszWorkDir);
            if (fHTM)
                CopyHtmlImgs(szFile, pcszWorkDir, NULL, NULL);
        }
    }

    if (fHTM)
        DeleteHtmlImgs(szFile, pcszSrcDir, NULL, NULL);

    DeleteFileInDir(pcszFile, pcszSrcDir);
}

static BOOL isAnimBitmapFileValidHelper(HWND hDlg, UINT nID, LPTSTR pszBuffer, PUINT pcch, UINT nIDTooBig,
                              UINT nIDTooSmall, long lBmpMinWidth, long lBmpMaxWidth)
{
    TCHAR  szFile[MAX_PATH];
    HANDLE hBmp;
    HWND   hCtrl;
    BITMAP bmLarge;
    UINT   nLen,
           nIDError = 0;

    if (!CheckField(hDlg, nID, FC_FILE | FC_EXISTS))
        return FALSE;

    nLen = GetDlgItemText(hDlg, nID, szFile, ARRAYSIZE(szFile));

    //----- Set "out" and "in-out parameters" -----
    if (pszBuffer != NULL)
        if (pcch != NULL) {
            StrCpyN(pszBuffer, szFile, *pcch);
            *pcch = nLen;
        }
        else
            StrCpy(pszBuffer, szFile);          // no checking for size

    if (nLen == 0)
        return TRUE;                            // consider valid

    hCtrl = GetDlgItem(hDlg, nID);

    //----- Check that this is a bitmap -----
    hBmp = LoadImage(NULL, szFile, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION);
    if (hBmp == NULL) {
        ErrorMessageBox(hDlg, IDS_INVALIDBITMAP);

        SendMessage(hCtrl, EM_SETSEL, 0, -1);
        SetFocus(hCtrl);
        return FALSE;
    }
    
    //----- Check the dimensions -----
    GetObject(hBmp, sizeof(BITMAP), &bmLarge);
    DeleteObject(hBmp);
    
    if (bmLarge.bmWidth > lBmpMaxWidth)
        nIDError = nIDTooBig;
    else if (bmLarge.bmWidth < lBmpMinWidth)
        nIDError = nIDTooSmall;
    else if (bmLarge.bmBitsPixel > 8)
        nIDError = IDS_TOOMANYCOLORS;

    if (nIDError != 0)
    {
        ErrorMessageBox(hDlg, nIDError);

        SendMessage(hCtrl, EM_SETSEL, 0, -1);
        SetFocus(hCtrl);
        return FALSE;
    }
    
    return TRUE;
}

// isBitmapFileValidHelper
// Verifies that file is a valid bitmap. Also optionally checks the dimenstions of this
// bitmap if in-parameters cx and cy are not 0s.
//
// Returns: obvious;
//
// Used by: in dialog procedures mostly in OnOK sort of handlers
//
static BOOL isBitmapFileValidHelper(HWND hDlg, UINT nID, LPTSTR pszBuffer, PUINT pcch,
                                    int cx, int cy, UINT nIDTooBig, UINT nIDTooSmall,
                                    DWORD dwFlags /* = 0 */)
{
    TCHAR  szFile[MAX_PATH] = TEXT("");
    BITMAP bm;
    HANDLE hBmp;
    HWND   hCtrl;
    UINT   nLen,
           nIDError = 0;

    if (!CheckField(hDlg, nID, FC_FILE | FC_EXISTS))
        return FALSE;

    nLen = GetDlgItemText(hDlg, nID, szFile, ARRAYSIZE(szFile));

    //----- Set "out" and "in-out parameters" -----
    if (pszBuffer != NULL)
        if (pcch != NULL) {
            StrCpyN(pszBuffer, szFile, *pcch);
            *pcch = nLen;
        }
        else
            StrCpy(pszBuffer, szFile);          // no checking for size

    if (nLen == 0)
        return TRUE;                            // consider valid

    // backdoor
    if ((GetKeyState(VK_SHIFT) & 0x8000) > 0)
        return TRUE;

    hCtrl = GetDlgItem(hDlg, nID);

    //----- Check that this is a bitmap -----
    // Note. The docs say that LR_LOADFROMFILE is not supported on NT?
    hBmp = LoadImage(NULL, szFile, IMAGE_BITMAP, 0, 0,
        LR_LOADFROMFILE | LR_CREATEDIBSECTION);

    if (hBmp == NULL) {
        ErrorMessageBox(hDlg, IDS_INVALIDBITMAP);

        SendMessage(hCtrl, EM_SETSEL, 0, -1);
        SetFocus(hCtrl);
        return FALSE;
    }

    if (cx == 0 && cy == 0) {
        DeleteObject(hBmp);
        return TRUE;
    }

    GetObject(hBmp, sizeof(BITMAP), &bm);
    DeleteObject(hBmp);                         // no longer needed

    //----- Check the dimensions if interested -----

    if (dwFlags & BMP_EXACT)
    {
        if ((bm.bmWidth > cx) || (bm.bmHeight > cy))
            nIDError = nIDTooBig;
        else if ((bm.bmWidth < cx) || (bm.bmHeight < cy))
            nIDError = nIDTooSmall;
    }
    else
    {    
        LONG cxBigTolerance,   cyBigTolerance,
             cxSmallTolerance = 0, cySmallTolerance = 0;

        // Note. The current tolearne is 10%.
        ASSERT(cx > 0 && cy > 0);

        if (dwFlags & BMP_SMALLER)
        {
            cxBigTolerance = cx;
            cyBigTolerance = cy;
        }
        else
        {
            cxBigTolerance   = cx + cx/10;
            cyBigTolerance   = cy + cy/10;
            cxSmallTolerance = cx - cx/10;
            cySmallTolerance = cy - cy/10;
        }
        ASSERT(cxSmallTolerance >= 0 && cySmallTolerance >= 0);

        if (bm.bmWidth > cxBigTolerance || bm.bmHeight > cyBigTolerance)
            nIDError = nIDTooBig;
        else if (!(dwFlags & BMP_SMALLER) &&
            (bm.bmWidth < cxSmallTolerance || bm.bmHeight < cySmallTolerance))
            nIDError = nIDTooSmall;
    }

    if ((nIDError==0) && (bm.bmBitsPixel > 8))
        nIDError = IDS_TOOMANYCOLORS;

    if (nIDError != 0) {
        ErrorMessageBox(hDlg, nIDError);

        SendMessage(hCtrl, EM_SETSEL, 0, -1);
        SetFocus(hCtrl);
        return FALSE;
    }

    return TRUE;
}

typedef struct tagFILTERS
{
    DWORD dwFilterMask;
    UINT uFilterId;
    UINT uDescId;
} FILTERS;


// order that filters show up in browse dialog is based on order in this array

static FILTERS s_afFilters[] =
{
    { GFN_CDF,         IDS_CDF_FILTER,         IDS_COMP_CDF      },
    { GFN_ICO,         IDS_ICO_FILTER,         IDS_COMP_ICO      },
    { GFN_PICTURE,     IDS_IMAGES_FILTER,      IDS_COMP_IMAGES   },
    { GFN_LOCALHTM,    IDS_HTMLDOC_FILTER,     IDS_COMP_FILEHTML },
    { GFN_MYCOMP,      IDS_MYCOMP_FILTER,      IDS_COMP_MYCOMP   },
    { GFN_CONTROLP,    IDS_CONTROLP_FILTER,    IDS_COMP_CONTROLP },
    { GFN_CERTIFICATE, IDS_CERTIFICATE_FILTER, IDS_COMP_CERT     },
    { GFN_BMP,         IDS_BMP_FILTER,         IDS_COMP_FILEBMP  },
    { GFN_ADM,         IDS_ADM_FILTER,         IDS_COMP_ADM      },
    { GFN_INS,         IDS_INS_FILTER,         IDS_COMP_INSFILE  },
    { GFN_PVK,         IDS_PVK_FILTER,         IDS_COMP_PVK      },
    { GFN_SPC,         IDS_SPC_FILTER,         IDS_COMP_SPC      },
    { GFN_SCRIPT,      IDS_SCRIPT_FILTER,      IDS_COMP_SCRIPT   },
    { GFN_TXT,         IDS_TXT_FILTER,         IDS_COMP_TXT      },
    { GFN_EXE,         IDS_EXE_FILTER,         IDS_COMP_EXE      },
    { GFN_CAB,         IDS_CAB_FILTER,         IDS_COMP_CAB      },
    { GFN_RULES,       IDS_RULES_FILTER,       IDS_COMP_RULES    },
    { GFN_ISP,         IDS_ISP_FILTER,         IDS_COMP_ISP      },
    { GFN_WAV,         IDS_WAV_FILTER,         IDS_COMP_WAV      },
    { GFN_GIF,         IDS_GIF_FILTER,         IDS_COMP_GIF      }
};

static BOOL browseForFileHelper(HWND hDlg, LPTSTR pszFileName, DWORD cchSize, DWORD dwFilterMasks,
                                LPCTSTR pcszTitle /* = NULL */)
{
    OPENFILENAME ofn;
    TCHAR szTitle[MAX_PATH];
    TCHAR szBrowseDir[MAX_PATH];
    TCHAR szFilter[MAX_PATH];
    static TCHAR szDefaultDir[MAX_PATH];

    if (pszFileName == NULL)
        return FALSE;

    ZeroMemory((PVOID) &ofn, sizeof(ofn));

    // initialize the relevant fields in ofn
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;

    if (pcszTitle == NULL || ISNULL(pcszTitle))
    {
        if (LoadString(g_hInst, IDS_BROWSE, szTitle, ARRAYSIZE(szTitle)))
            ofn.lpstrTitle = szTitle;
    }
    else
        ofn.lpstrTitle = pcszTitle;

    // initialize the InitialDir field
    if (*pszFileName)
    {
        StrCpy(szBrowseDir, pszFileName);
        if (PathIsUNCServer(szBrowseDir)  ||
                ((PathIsDirectory(szBrowseDir) || PathRemoveFileSpec(szBrowseDir))  &&  PathFileExists(szBrowseDir)))
            ofn.lpstrInitialDir = szBrowseDir;
    }
    else if (*szDefaultDir)
    {
        ofn.lpstrInitialDir = szDefaultDir;
    }
    else {
        if (!FAILED(SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, szBrowseDir)))  //default to my docs
             ofn.lpstrInitialDir = szBrowseDir;
    }


    *pszFileName = TEXT('\0');
    ofn.lpstrFile = pszFileName;
    ofn.nMaxFile = cchSize;

    // set the filter
    if (dwFilterMasks)
    {
        LPTSTR pszFilter;
        INT cchFilter, cchRead;

        // load the description for the filter
        pszFilter = szFilter;
        cchFilter = ARRAYSIZE(szFilter) - 1;        // room for the final second nul char
        for (int i = 0;  i < ARRAYSIZE(s_afFilters);  i++)
        {
            if (dwFilterMasks & s_afFilters[i].dwFilterMask)
            {
                cchRead = LoadString(g_hDLLInst, s_afFilters[i].uDescId, pszFilter, cchFilter);
                cchFilter -= cchRead + 1;
                // filter description
                if ((cchRead != 0)  && (cchFilter != 0))
                {
                    pszFilter += cchRead;
                    *pszFilter++ = TEXT('\0');
                }

                cchRead = LoadString(g_hDLLInst, s_afFilters[i].uFilterId, pszFilter, cchFilter);
                cchFilter -= cchRead + 1;
                // filter extensions
                if ((cchRead != 0)  && (cchFilter != 0))
                {
                    pszFilter += cchRead;
                    *pszFilter++ = TEXT('\0');
                }
            }
        }

        // double nul terminate the string.
        *pszFilter = TEXT('\0');

        ofn.lpstrFilter = szFilter;
    }

    BOOL bRetVal = GetOpenFileName(&ofn);
    //save the dir so we return here.
    StrCpy(szDefaultDir,ofn.lpstrFile);
    PathRemoveFileSpec(szDefaultDir);

    return bRetVal;
}

static BOOL browseForFolderHelper(HWND hDlg, LPTSTR pszFileName, LPCTSTR pcszDesc)
{
    LPITEMIDLIST pId;
    BROWSEINFO bInfo;

    ZeroMemory(&bInfo, sizeof(bInfo));
    bInfo.hwndOwner = hDlg;
    bInfo.pidlRoot = NULL;
    bInfo.ulFlags = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS;
    bInfo.pszDisplayName = pszFileName;
    if (pcszDesc)
        bInfo.lpszTitle = pcszDesc;
    pId = SHBrowseForFolder(&bInfo);
    if (!pId)
        return FALSE;

    SHGetPathFromIDList(pId, pszFileName);

    // BUGBUG: <oliverl> shoule we free pId?
    return TRUE;
}

void WINAPI ErrorMessageBox(HWND hWnd, UINT idErrorStr, DWORD dwFlags /* = 0 */)
{
    TCHAR szTitle[MAX_PATH],
          szMsg[MAX_PATH];

    if (LoadString(g_hDLLInst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle)) == 0)
        LoadString(g_hInst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));

    if (LoadString(g_hDLLInst, idErrorStr, szMsg, ARRAYSIZE(szMsg)) == 0)
        LoadString(g_hInst, idErrorStr, szMsg, ARRAYSIZE(szMsg));

    MessageBox(hWnd, szMsg, szTitle,
        dwFlags ? dwFlags : MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
}

static void exportRegTree2InfHelper(HKEY hk, LPCTSTR pszHive, LPCTSTR pszKey, HANDLE hInf, BOOL fUseLdids)
// Export all the value names and sub-keys under pcszSubKey to hInf as AddReg lines
{
    TCHAR szSubKey[MAX_PATH],
          szFullSubKey[MAX_PATH];
    DWORD dwIndex = 0;
    DWORD dwSub   = countof(szSubKey);

    exportRegKey2InfHelper(hk, pszHive, pszKey, hInf, fUseLdids);
    while (RegEnumKeyEx(hk, dwIndex, szSubKey, &dwSub, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
        HKEY hkSub;

        if (RegOpenKeyEx(hk, szSubKey, 0, KEY_ENUMERATE_SUB_KEYS | KEY_READ, &hkSub) == ERROR_SUCCESS) {
            wnsprintf(szFullSubKey, ARRAYSIZE(szFullSubKey), TEXT("%s\\%s"), pszKey, szSubKey);
            exportRegTree2InfHelper(hkSub, pszHive, szFullSubKey, hInf, fUseLdids);
            WriteStringToFile(hInf, (LPCVOID) TEXT("\r\n"), 2);
            RegCloseKey(hkSub);
        }

        dwIndex++;
        dwSub = countof(szSubKey);
    }
}

static const TCHAR c_szSzType[]     = TEXT("%s,\"%s\",%s,,\"%s\"");
static const TCHAR c_szDwordType[]  = TEXT("%s,\"%s\",%s,0x10001");
static const TCHAR c_szBinaryType[] = TEXT("%s,\"%s\",%s,1");

static void exportRegValue2InfHelper(HKEY hkSubKey, LPCTSTR pcszValue, LPCTSTR pcszRootKey, LPCTSTR pcszSubKey, HANDLE hInf, BOOL fUseLdids)
{
    TCHAR szInfLine[(4 * MAX_URL) + MAX_PATH];
    BYTE  rgbData[2*MAX_URL];
    DWORD cbData,
          dwType;
    LONG  lResult;
    int   i, j, k;

    cbData = 2*MAX_URL;
    lResult = RegQueryValueEx(hkSubKey, pcszValue, NULL, &dwType, rgbData, &cbData);
    if ((lResult != ERROR_SUCCESS) || ((pcszValue == NULL) && (cbData <= 1)))
        return;

    switch (dwType) {
    case REG_EXPAND_SZ:

        // use shlwapi API to get the expanded value, then fall through to write addreg
        // entry to inf as REG_SZ

        lResult = SHQueryValueEx(hkSubKey, pcszValue, NULL, &dwType, rgbData, &cbData);
        if ((lResult != ERROR_SUCCESS) || ((pcszValue == NULL) && (cbData <= 1)))
            return;

    case REG_SZ:
        if (fUseLdids)
            PathReplaceWithLDIDs((LPTSTR)rgbData);

        wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szSzType, pcszRootKey, pcszSubKey,
            (pcszValue == NULL) ? TEXT("") : pcszValue, (LPCTSTR)rgbData);
        break;

    case REG_DWORD:
        wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szDwordType, pcszRootKey, pcszSubKey, pcszValue);
        for (i = 0;  i < 4;  i++)
            AppendCommaHex(szInfLine, rgbData[i], 1);
        break;

    case REG_BINARY:
    default:
        wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szBinaryType, pcszRootKey, pcszSubKey, pcszValue);
        for (i = 0, j = k = StrLen(szInfLine); 
             i < (int)cbData && k < countof(szInfLine); i++, j += 3, k += 3) {
            AppendCommaHex(szInfLine, rgbData[i], 1);

            if (j >= 240) {
                StrCat(szInfLine, TEXT("\\\r\n"));
                j = 0;
                k += 3;
            }
        }
        break;
    }

    StrCat(szInfLine, TEXT("\r\n"));
    WriteStringToFile(hInf, szInfLine, StrLen(szInfLine));
}

static void exportRegKey2InfHelper(HKEY hkSubKey, LPCTSTR pcszRootKey, LPCTSTR pcszSubKey, HANDLE hInf, BOOL fUseLdids)
// Export all the value names under pcszSubKey to hInf as AddReg lines
{
    DWORD dwIndex;
    TCHAR szValue[MAX_PATH];
    DWORD cchValue, dwType;

    for (dwIndex = 0, cchValue = countof(szValue);
         RegEnumValue(hkSubKey, dwIndex, szValue, &cchValue, NULL, &dwType, NULL, NULL) == ERROR_SUCCESS;
         dwIndex++,   cchValue = countof(szValue))
        exportRegValue2InfHelper(hkSubKey, szValue, pcszRootKey, pcszSubKey, hInf, fUseLdids);
}

/////////////////////////////////////////////////////////////////////////////
// Private routines (non-exported)

static void signFileHelper(LPCTSTR pcszFilename, LPCTSTR pcszDir, LPCTSTR pcszIns, LPTSTR pszUnsignedFiles, LPCTSTR pcszCustInf, BOOL fTest)
{
    DWORD dwExitCode=0, dwLen;
    static BOOL s_fFirst = TRUE;
    TCHAR szDesc[MAX_PATH];
    TCHAR szPVKPath[MAX_PATH];
    TCHAR szSPCPath[MAX_PATH];
    TCHAR szInfoUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szTimeUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szDest[MAX_PATH];
    TCHAR szCmd[INTERNET_MAX_URL_LENGTH + MAX_PATH];

    // note that pcszDir is only passed in as NULL if we're test signing something

    if (!InsGetString(IS_CABSIGN, IK_PVK, szPVKPath, countof(szPVKPath), pcszIns) ||
        !InsGetString(IS_CABSIGN, IK_SPC, szSPCPath, countof(szSPCPath), pcszIns))
        return;

    if (s_fFirst && !fTest)
    {
        s_fFirst = FALSE;

        if (pcszCustInf != NULL)
        {
            if (InsGetString(IS_CABSIGN, RV_COMPANYNAME, szDesc, countof(szDesc), pcszIns))
            {
                HKEY hKey;

                if(RegOpenKeyEx(HKEY_CURRENT_USER, RK_TRUSTKEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
                {
                    TCHAR szKey[MAX_PATH];
                    TCHAR szValue[MAX_PATH];
                    DWORD dwValueKey,dwValue;
                    int iEntry=0;

                    dwValueKey=countof(szKey);
                    dwValue=sizeof(szValue);

                    ZeroMemory(szCmd, sizeof(szCmd));
                    if(RegEnumValue(hKey, 0, szKey, &dwValueKey, NULL, NULL, (BYTE *) szValue, &dwValue) == ERROR_SUCCESS)
                    {
                        do
                        {
                            if(StrCmpI(szValue, szDesc) == 0)
                            {
                                wnsprintf(szInfoUrl, ARRAYSIZE(szInfoUrl), CABSIGN_INF_ADD, szKey, szValue);
                                StrCat(szCmd, szInfoUrl);
                            }
                            iEntry++;
                            dwValueKey=countof(szKey);
                            dwValue=sizeof(szValue);

                        } while (RegEnumValue(hKey, iEntry, szKey, &dwValueKey, NULL, NULL, (BYTE *) szValue, &dwValue) != ERROR_NO_MORE_ITEMS);
                    }

                    RegCloseKey(hKey);
                    if (ISNONNULL(szCmd))
                    {
                        InsDeleteSection(TEXT("IEAK.Company.reg"), pcszCustInf);
                        WritePrivateProfileSection(TEXT("IEAK.Company.reg"), szCmd, pcszCustInf);
                        InsFlushChanges(pcszCustInf);
                    }
                }
            }
        }

        if (pcszDir != NULL)
        {
            PathCombine(szDest, pcszDir, PathFindFileName(szPVKPath));
            CopyFile(szPVKPath, szDest, FALSE);
            PathCombine(szDest, pcszDir, PathFindFileName(szSPCPath));
            CopyFile(szSPCPath, szDest, FALSE);
        }
    }

    InsGetString(IS_CABSIGN, IK_NAME, szDesc, countof(szDesc), pcszIns);

    if (pcszDir != NULL)
        PathCombine(szDest, pcszDir, TEXT("SIGNCODE.EXE"));
    else
    {
        StrCpy(szDest, pcszFilename);
        PathRemoveFileSpec(szDest);
        CopyFileToDir(szPVKPath, szDest);
        CopyFileToDir(szSPCPath, szDest);
        PathAppend(szDest, TEXT("signcode.exe"));
    }
        
    
    wnsprintf(szCmd, countof(szCmd), TEXT("\"%s\" -spc \"%s\" -v \"%s\" -n \"%s\""), 
        szDest, PathFindFileName(szSPCPath), PathFindFileName(szPVKPath), szDesc);

    if ((pcszDir != NULL) &&
        InsGetString(IS_CABSIGN, IK_CSURL, szInfoUrl, countof(szInfoUrl), pcszIns))
    {
        dwLen = StrLen(szCmd);
        wnsprintf(szCmd + dwLen, countof(szCmd) - dwLen, TEXT(" -i \"%s\""), szInfoUrl);
    }

    if ((pcszDir != NULL) &&
        InsGetString(IS_CABSIGN, IK_CSTIME, szTimeUrl, countof(szTimeUrl), pcszIns))
    {
        dwLen = StrLen(szCmd);
        wnsprintf(szCmd + dwLen, countof(szCmd) - dwLen, TEXT(" -t \"%s\""), szTimeUrl);
    }

    dwLen = StrLen(szCmd);
    wnsprintf(szCmd + dwLen, countof(szCmd) - dwLen, TEXT(" \"%s\""), PathFindFileName(pcszFilename));

    if (pcszDir == NULL)
        PathRemoveFileSpec(szDest);

    if (!RunAndWait(szCmd, (pcszDir == NULL) ? szDest : pcszDir, SW_HIDE, &dwExitCode) 
        || (dwExitCode == -1))
    {
        if (pszUnsignedFiles != NULL)
        {
            StrCat(pszUnsignedFiles, TEXT("\r\n"));
            StrCat(pszUnsignedFiles, pcszFilename);
        }
    }

    if (pcszDir == NULL)
    {
        DeleteFileInDir(szPVKPath, szDest);
        DeleteFileInDir(szSPCPath, szDest);
    }
}

void WINAPI DoReboot(HWND hwndUI)
{
    TCHAR szMsg[MAX_PATH];
    TCHAR szTitle[128];

    LoadString(g_hInst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));
    LoadString(g_hDLLInst, IDS_RESTARTYESNO, szMsg, ARRAYSIZE(szMsg));

    if (MessageBox(hwndUI, szMsg, szTitle, MB_YESNO) == IDNO)
        return;

    if (IsOS(OS_NT))
    {
        HANDLE hToken;
        TOKEN_PRIVILEGES tkp;

        // get a token from this process
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        {
            // get the LUID for the shutdown privilege
            LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            //get the shutdown privilege for this proces
            AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);
        }

        ExitWindowsEx(EWX_REBOOT, 0);
    }
    else
        ExitWindowsEx(EWX_REBOOT, 0);
}

void WINAPI ShowInetcpl(HWND hDlg, DWORD dwPages, DWORD dwMode /*= IEM_ADMIN*/)
{
    HKEY hkInetcpl = NULL;
    HINSTANCE hInetcpl = NULL;
    DWORD dwGeneral = 0, dwSecurity = 0, dwContent = 0,
          dwConnect = 0, dwPrograms = 0, dwAdvanced = 0,
          dwPrivacy = 0, dwIEAK = 0, dwAutoconfig = 0;

    // set restrictions to disable pages we aren't interested in,
    // tracking whether or not we set or cleared the restriction
    if (SHCreateKeyHKCU(RK_INETCPL, KEY_DEFAULT_ACCESS, &hkInetcpl) == ERROR_SUCCESS)
    {
        dwGeneral   = RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_GENERALTAB,
                            (dwPages & INET_PAGE_GENERAL) ? 0 : 1);

        dwSecurity  = RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_SECURITYTAB,
                            (dwPages & INET_PAGE_SECURITY) ? 0 : 1);

        dwContent   = RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_CONTENTTAB,
                            (dwPages & INET_PAGE_CONTENT) ? 0 : 1);

        dwConnect   = RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_CONNECTIONSTAB,
                            (dwPages & INET_PAGE_CONNECTION) ? 0 : 1);

        dwPrivacy  = RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_PRIVACYTAB,
                            (dwPages & INET_PAGE_PRIVACY) ? 0 : 1);

        dwPrograms  = RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_PROGRAMSTAB,
                            (dwPages & INET_PAGE_PROGRAMS) ? 0 : 1);

        dwAdvanced  = RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_ADVANCEDTAB,
                            (dwPages & INET_PAGE_ADVANCED) ? 0 : 1);

        dwIEAK      = RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_IEAK, 1);

        // always set restriction to disable autoconfig exposure in inetcpl if we're not
        // running in corp mode
        if (!HasFlag(dwMode, IEM_ADMIN))
            dwAutoconfig = RegSaveRestoreDWORD(hkInetcpl, TEXT("Autoconfig"), 1);
    }

    if ((hInetcpl = LoadLibrary(TEXT("inetcpl.cpl"))) != NULL)
    {
        typedef BOOL (WINAPI * LAUNCHINTERNETCONTROLPANEL)(HWND hDlg);
        LAUNCHINTERNETCONTROLPANEL pLaunchInternetControlPanel;

        if ((pLaunchInternetControlPanel = (LAUNCHINTERNETCONTROLPANEL)
                    GetProcAddress(hInetcpl, "LaunchInternetControlPanel")) != NULL)
            pLaunchInternetControlPanel(hDlg);

        FreeLibrary(hInetcpl);
    }

    if (hkInetcpl != NULL)
    {
        // reset the restrictions that we set, in this case we'll be passing in FALSE for those
        // we set which will clear the value, and TRUE for those we didn't set which will leave
        // them as set

        RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_GENERALTAB,     dwGeneral);
        RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_SECURITYTAB,    dwSecurity);
        RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_CONTENTTAB,     dwContent);
        RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_CONNECTIONSTAB, dwConnect);
        RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_PROGRAMSTAB,    dwPrograms);
        RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_PRIVACYTAB,     dwPrivacy);
        RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_ADVANCEDTAB,    dwAdvanced);
        RegSaveRestoreDWORD(hkInetcpl, REGSTR_VAL_INETCPL_IEAK,           dwIEAK);

        if (!HasFlag(dwMode, IEM_ADMIN))
            RegSaveRestoreDWORD(hkInetcpl, TEXT("Autoconfig"), dwAutoconfig);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\urls.cpp ===
#include "precomp.h"

static void initializeStartSearchHelper(HWND hDlg, LPCTSTR pcszInsFile, LPCTSTR pcszServerFile);
static BOOL saveStartSearchHelper(HWND hDlg, LPCTSTR pcszInsFile, LPCTSTR pcszServerFile, BOOL *pfInsDirty,
                                  BOOL fCheckDirtyOnly);

void WINAPI InitializeStartSearchA(HWND hDlg, LPCSTR pcszInsFile, LPCSTR pcszServerFile)
{
    USES_CONVERSION;

    initializeStartSearchHelper(hDlg, A2CT(pcszInsFile), A2CT(pcszServerFile));
}

void WINAPI InitializeStartSearchW(HWND hDlg, LPCWSTR pcwszInsFile, LPCWSTR pcwszServerFile)
{
    USES_CONVERSION;

    initializeStartSearchHelper(hDlg, W2CT(pcwszInsFile), W2CT(pcwszServerFile));
}

BOOL WINAPI SaveStartSearchA(HWND hDlg, LPCSTR pcszInsFile, LPCSTR pcszServerFile, BOOL *pfInsDirty /*= NULL */,
                             BOOL fCheckDirtyOnly /* = FALSE */)
{
    USES_CONVERSION;

    return saveStartSearchHelper(hDlg, A2CT(pcszInsFile), A2CT(pcszServerFile), pfInsDirty, fCheckDirtyOnly);
}

BOOL WINAPI SaveStartSearchW(HWND hDlg, LPCWSTR pcwszInsFile, LPCWSTR pcwszServerFile, BOOL *pfInsDirty /* = NULL */,
                             BOOL fCheckDirtyOnly /* = FALSE */)
{
    USES_CONVERSION;

    return saveStartSearchHelper(hDlg, W2CT(pcwszInsFile), W2CT(pcwszServerFile), pfInsDirty, fCheckDirtyOnly);
}

static void initializeStartSearchHelper(HWND hDlg, LPCTSTR pcszInsFile, LPCTSTR pcszServerFile)
{
    SetDlgItemTextFromIns(hDlg, IDE_STARTPAGE, IDC_STARTPAGE, IS_URL, IK_HOMEPAGE, pcszInsFile,
        pcszServerFile, INSIO_TRISTATE);

    EnableDlgItem2(hDlg, IDC_STARTPAGE_TXT, (IsDlgButtonChecked(hDlg, IDC_STARTPAGE) == BST_CHECKED));

    SetDlgItemTextFromIns(hDlg, IDE_SEARCHPAGE, IDC_SEARCHPAGE, IS_URL, IK_SEARCHPAGE, pcszInsFile,
        pcszServerFile, INSIO_TRISTATE);

    EnableDlgItem2(hDlg, IDC_SEARCHPAGE_TXT, (IsDlgButtonChecked(hDlg, IDC_SEARCHPAGE) == BST_CHECKED));

    SetDlgItemTextFromIns(hDlg, IDE_CUSTOMSUPPORT, IDC_CUSTOMSUPPORT, IS_URL, IK_HELPPAGE, pcszInsFile,
        pcszServerFile, INSIO_TRISTATE);

    EnableDlgItem2(hDlg, IDC_CUSTOMSUPPORT_TXT, (IsDlgButtonChecked(hDlg, IDC_CUSTOMSUPPORT) == BST_CHECKED));
}


static BOOL saveStartSearchHelper(HWND hDlg, LPCTSTR pcszInsFile, LPCTSTR pcszServerFile, BOOL *pfInsDirty /* = NULL */,
                                  BOOL fCheckDirtyOnly /* = FALSE */)
{
    TCHAR szStart[INTERNET_MAX_URL_LENGTH];
    TCHAR szSearch[INTERNET_MAX_URL_LENGTH];
    TCHAR szSupport[INTERNET_MAX_URL_LENGTH];
    TCHAR szTemp[INTERNET_MAX_URL_LENGTH];
    BOOL  fStart, fSearch, fSupport, fTemp;

    fStart = GetDlgItemTextTriState(hDlg, IDE_STARTPAGE, IDC_STARTPAGE, szStart, countof(szStart));
    if (pfInsDirty != NULL  &&  *pfInsDirty == FALSE)
    {
        InsGetString(IS_URL, IK_HOMEPAGE, szTemp, countof(szTemp), pcszInsFile, NULL, &fTemp);
        if (fStart != fTemp || StrCmpI(szTemp, szStart) != 0)
            *pfInsDirty = TRUE;
    }

    fSearch = GetDlgItemTextTriState(hDlg, IDE_SEARCHPAGE, IDC_SEARCHPAGE, szSearch, countof(szSearch));
    if (pfInsDirty != NULL  &&  *pfInsDirty == FALSE)
    {
        InsGetString(IS_URL, IK_SEARCHPAGE, szTemp, countof(szTemp), pcszInsFile, NULL, &fTemp);
        if (fSearch != fTemp || StrCmpI(szTemp, szSearch) != 0)
            *pfInsDirty = TRUE;
    }

    fSupport = GetDlgItemTextTriState(hDlg, IDE_CUSTOMSUPPORT, IDC_CUSTOMSUPPORT, szSupport, 
        countof(szSupport));
    if (pfInsDirty != NULL  &&  *pfInsDirty == FALSE)
    {
        InsGetString(IS_URL, IK_HELPPAGE, szTemp, countof(szTemp), pcszInsFile, NULL, &fTemp);
        if (fSupport != fTemp || StrCmpI(szTemp, szSupport) != 0)
            *pfInsDirty = TRUE;
    }

    if (!fCheckDirtyOnly)
    {
        InsWriteString(IS_URL, IK_HOMEPAGE, szStart, pcszInsFile, fStart, pcszServerFile, 
            INSIO_TRISTATE);
        InsWriteString(IS_URL, IK_SEARCHPAGE, szSearch, pcszInsFile, fSearch, pcszServerFile,
            INSIO_TRISTATE);
        InsWriteString(IS_URL, IK_HELPPAGE, szSupport, pcszInsFile, fSupport, pcszServerFile,
            INSIO_TRISTATE);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakeng\version.cpp ===
#include "precomp.h"

static int checkVerHelper(LPCTSTR pcszPrevVer, LPCTSTR pcszNewVer);
static void generateNewVersionStrHelper(LPCTSTR pcszInsFile, LPTSTR pszNewVersionStr);
static void setOrClearVersionInfoHelper(LPCTSTR pcszInsFile, DWORD dwCabType, LPCTSTR pcszCabName, 
                                        LPCTSTR pcszCabsURLPath, LPTSTR pszNewVersionStr, BOOL fSet);
static void getBaseFileNameHelper(LPCTSTR pcszFile, LPTSTR pszBaseFileName, INT cchSize);

// iRet >  0  ==>  PrevVer is higher than NewVersion
// iRet == 0  ==>  PrevVer is the same as NewVersion
// iRet <  0  ==>  PrevVer is lower than NewVersion

int WINAPI CheckVerA(LPCSTR pcszPrevVer, LPCSTR pcszNewVer)
{
    USES_CONVERSION;

    return checkVerHelper(A2CT(pcszPrevVer), A2CT(pcszNewVer));
}

int WINAPI CheckVerW(LPCWSTR pcwszPrevVer, LPCWSTR pcwszNewVer)
{
    USES_CONVERSION;

    return checkVerHelper(W2CT(pcwszPrevVer), W2CT(pcwszNewVer));
}

void WINAPI GenerateNewVersionStrA(LPCSTR pcszInsFile, LPSTR pszNewVersionStr)
{
    TCHAR szNewVerStr[32];

    USES_CONVERSION;

    generateNewVersionStrHelper(A2CT(pcszInsFile), szNewVerStr);
    T2Abux(szNewVerStr, pszNewVersionStr);
}

void WINAPI GenerateNewVersionStrW(LPCWSTR pcwszInsFile, LPWSTR pwszNewVersionStr)
{
    TCHAR szNewVerStr[32];

    USES_CONVERSION;

    generateNewVersionStrHelper(W2CT(pcwszInsFile), szNewVerStr);
    T2Wbux(szNewVerStr, pwszNewVersionStr);
}

void WINAPI SetOrClearVersionInfoA(LPCSTR pcszInsFile, DWORD dwCabType, LPCSTR pcszCabName, 
                            LPCSTR pcszCabsURLPath, LPSTR pszNewVersionStr, BOOL fSet)
{
    TCHAR szNewVerStr[32];

    USES_CONVERSION;

    A2Tbux(pszNewVersionStr, szNewVerStr);
    setOrClearVersionInfoHelper(A2CT(pcszInsFile), dwCabType, A2CT(pcszCabName),
        A2CT(pcszCabsURLPath), szNewVerStr, fSet);
    T2Abux(szNewVerStr, pszNewVersionStr);
}

void WINAPI SetOrClearVersionInfoW(LPCWSTR pcwszInsFile, DWORD dwCabType, LPCWSTR pcwszCabName, 
                            LPCWSTR pcwszCabsURLPath, LPWSTR pwszNewVersionStr, BOOL fSet)
{
    TCHAR szNewVerStr[32];

    USES_CONVERSION;

    W2Tbux(pwszNewVersionStr, szNewVerStr);
    setOrClearVersionInfoHelper(W2CT(pcwszInsFile), dwCabType, W2CT(pcwszCabName),
        W2CT(pcwszCabsURLPath), szNewVerStr, fSet);
    T2Wbux(szNewVerStr, pwszNewVersionStr);
}

void WINAPI GetBaseFileNameA(LPCSTR pcszFile, LPSTR pszBaseFileName, INT cchSize)
{
    LPTSTR pszBuf = (LPTSTR)CoTaskMemAlloc(StrCbFromCch(cchSize));

    USES_CONVERSION;

    if (pszBuf != NULL)
    {
        getBaseFileNameHelper(A2CT(pcszFile), pszBuf, cchSize);
        T2Abux(pszBuf, pszBaseFileName);
        CoTaskMemFree(pszBuf);
    }
}

void WINAPI GetBaseFileNameW(LPCWSTR pcwszFile, LPWSTR pwszBaseFileName, INT cchSize)
{
    LPTSTR pszBuf = (LPTSTR)CoTaskMemAlloc(StrCbFromCch(cchSize));

    USES_CONVERSION;

    if (pszBuf != NULL)
    {
        getBaseFileNameHelper(W2CT(pcwszFile), pszBuf, cchSize);
        T2Wbux(pszBuf, pwszBaseFileName);
        CoTaskMemFree(pszBuf);
    }
}

/* stolen from webcheck
// PRIVATE VERSION HANDLING CODE - REVIEW THIS CODE SHOULD HAVE BEEN STOLEN
// FROM SETUP
*/
typedef struct _MYVERSION
{
    DWORD dw1;  /* most sig version number  */
    DWORD dw2;
    DWORD dw3;
    DWORD dw4;  /* least sig version number  */
} MYVERSION;

static int compareDW(DWORD dw1, DWORD dw2)
{
    if (dw1 > dw2)
        return 1;
    if (dw1 < dw2)
        return -1;

    return 0;
}

static int compareVersion(MYVERSION * pv1, MYVERSION * pv2)
{
    int rv;

    rv = compareDW(pv1->dw1, pv2->dw1);

    if (rv == 0)
    {
        rv = compareDW(pv1->dw2, pv2->dw2);

        if (rv == 0)
        {
            rv = compareDW(pv1->dw3, pv2->dw3);

            if (rv == 0)
            {
                rv = compareDW(pv1->dw4, pv2->dw4);
            }
        }
    }

    return rv;
}

static void getDWORDFromStringAndAdvancePtr(DWORD *pdw, LPTSTR *psz)
{
    LPTSTR pszTemp;

    if ((!(*psz)) || (!StrToIntEx(*psz, 0, (int *)pdw)))
    {
        *pdw = TEXT('\0');
        return;
    }

    // look for period separator first, then comma

    pszTemp  = StrChr(*psz, TEXT('.'));

    if (pszTemp != NULL)
        *psz = pszTemp;
    else
        *psz = StrChr(*psz, TEXT(','));

    if (*psz)
        (*psz)++;

    return;
}

static void getVersionFromString(MYVERSION *pver, LPTSTR psz)
{
    getDWORDFromStringAndAdvancePtr(&pver->dw1, &psz);
    getDWORDFromStringAndAdvancePtr(&pver->dw2, &psz);
    getDWORDFromStringAndAdvancePtr(&pver->dw3, &psz);
    getDWORDFromStringAndAdvancePtr(&pver->dw4, &psz);
}

// end of stolen code

static int checkVerHelper(LPCTSTR pcszPrevVer, LPCTSTR pcszNewVer)
{
    MYVERSION verOldVer, verNewVer;

    getVersionFromString(&verOldVer, (LPTSTR)pcszPrevVer);
    getVersionFromString(&verNewVer, (LPTSTR)pcszNewVer);

    return compareVersion(&verOldVer, &verNewVer);
}

static void incrementDotVer(LPTSTR pszVerStr)
{
    LPTSTR pszT = pszVerStr;
    DWORD dwYear, dwMonth, dwDay, dwDotVer;
    
    getDWORDFromStringAndAdvancePtr(&dwYear, &pszT);
    getDWORDFromStringAndAdvancePtr(&dwMonth, &pszT);
    getDWORDFromStringAndAdvancePtr(&dwDay, &pszT);
    getDWORDFromStringAndAdvancePtr(&dwDotVer, &pszT);
    
    if (++dwDotVer > 99)
    {
        // this case should never arise
    }
    
    wnsprintf(pszVerStr, 32, TEXT("%04d.%02d.%02d.%02d"), dwYear, dwMonth, dwDay, dwDotVer);
}

static void generateNewVersionStrHelper(LPCTSTR pcszInsFile, LPTSTR pszNewVersionStr)
{
    TCHAR szPrevVerStr[32];
    SYSTEMTIME st;
    
    GetPrivateProfileString(BRANDING, INSVERKEY, TEXT(""), szPrevVerStr, ARRAYSIZE(szPrevVerStr), pcszInsFile);
    
    GetLocalTime(&st);
    wnsprintf(pszNewVersionStr, 32, TEXT("%04d.%02d.%02d.%02d"), st.wYear, st.wMonth, st.wDay, 0);

    if (ISNONNULL(szPrevVerStr))
    {
        int iRet = CheckVer(szPrevVerStr, pszNewVersionStr);
        
        // iRet >  0  ==>  PrevVer is higher than NewVersion
        // iRet == 0  ==>  PrevVer is the same as NewVersion
        // iRet <  0  ==>  PrevVer is lower than NewVersion
        
        if (iRet >= 0)
        {
            if (iRet > 0)
                StrCpy(pszNewVersionStr, szPrevVerStr);
            
            incrementDotVer(pszNewVersionStr);
        }
    }
}

static void setOrClearVersionInfoHelper(LPCTSTR pcszInsFile, DWORD dwCabType, LPCTSTR pcszCabName, 
                                        LPCTSTR pcszCabsURLPath, LPTSTR pszNewVersionStr, BOOL fSet)
{
    LPCTSTR pcszSection = NULL, pcszKey = NULL;
    TCHAR szCabInfoLine[INTERNET_MAX_URL_LENGTH + 128];
    LPTSTR pszCurField, pszNextField;
    TCHAR szCabURL[INTERNET_MAX_URL_LENGTH];
    TCHAR szExpiration[16];
    TCHAR szFlags[16];

    switch (dwCabType)
    {
    case CAB_TYPE_CONFIG:
        pcszSection = CUSTBRNDSECT;
        pcszKey = CUSTBRNDNAME;
        break;

    case CAB_TYPE_DESKTOP:
        pcszSection = CUSTDESKSECT;
        pcszKey = CUSTDESKNAME;
        break;

    case CAB_TYPE_CHANNELS:
        pcszSection = CUSTCHANSECT;
        pcszKey = CUSTCHANNAME;
        break;
    }

    if (pcszSection == NULL  ||  pcszKey == NULL)
        return;

    if (fSet)
    {
        // save the info before deleting it
        if (GetPrivateProfileString(pcszSection, pcszKey, TEXT(""), szCabInfoLine, ARRAYSIZE(szCabInfoLine), pcszInsFile) == 0)
            GetPrivateProfileString(CUSTOMVERSECT, pcszKey, TEXT(""), szCabInfoLine, ARRAYSIZE(szCabInfoLine), pcszInsFile);
    }

    // clear out the version information in the INS file
    WritePrivateProfileString(pcszSection, NULL, NULL, pcszInsFile);
    WritePrivateProfileString(CUSTOMVERSECT, pcszKey, NULL, pcszInsFile);

    if (!fSet)
        return;

    *szCabURL = *szExpiration = *szFlags = TEXT('\0');

    if (ISNONNULL(szCabInfoLine))
    {
        // parse the szCabInfoLine
        pszCurField = szCabInfoLine;
        if ((pszNextField = StrChr(pszCurField, TEXT(','))) != NULL)
        {
            *pszNextField++ = TEXT('\0');
            StrCpy(szCabURL, pszCurField);

            pszCurField = pszNextField;
            if ((pszNextField = StrChr(pszCurField, TEXT(','))) != NULL)
            {
                *pszNextField++ = TEXT('\0');

                pszCurField = pszNextField;
                if ((pszNextField = StrChr(pszCurField, TEXT(','))) != NULL)
                {
                    *pszNextField++ = TEXT('\0');
                    StrCpy(szExpiration, pszCurField);

                    pszCurField = pszNextField;
                    if ((pszNextField = StrChr(pszCurField, TEXT(','))) != NULL)
                    {
                        *pszNextField++ = TEXT('\0');
                        StrCpy(szFlags, pszCurField);
                    }
                    else
                        StrCpy(szFlags, pszCurField);
                }
                else
                    StrCpy(szExpiration, pszCurField);
            }
        }
        else
            StrCpy(szCabURL, pszCurField);
    }

    // initialize autoconfig URL
    StrCpy(szCabURL, pcszCabsURLPath);
    PathRemoveBackslash(szCabURL);
    if (ISNONNULL(szCabURL)  &&  szCabURL[StrLen(szCabURL) - 1] != TEXT('/'))
        StrCat(szCabURL, TEXT("/"));
    StrCat(szCabURL, pcszCabName);

    generateNewVersionStrHelper(pcszInsFile, pszNewVersionStr);

    if (ISNULL(szExpiration))
        StrCpy(szExpiration, TEXT("-1"));           // never expires

    // write the new version info line
    wnsprintf(szCabInfoLine, ARRAYSIZE(szCabInfoLine), TEXT("%s,%s,%s,%s"), szCabURL, pszNewVersionStr, szExpiration, szFlags);
    WritePrivateProfileString(pcszSection, pcszKey, szCabInfoLine, pcszInsFile);
}

static void getBaseFileNameHelper(LPCTSTR pcszFile, LPTSTR pszBaseFileName, INT cchSize)
{
    TCHAR szFile[MAX_PATH];
    LPTSTR lpszFileName = NULL;
    
    if (pcszFile == NULL  ||  ISNULL(pcszFile))
        return;
    
    StrCpy(szFile, pcszFile);
    lpszFileName = PathFindFileName(szFile);
    PathRemoveExtension(lpszFileName);
    StrCpyN(pszBaseFileName, lpszFileName, cchSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakfont\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ieakeng.rc
//
#define IDS_TITLE           1
#define IDS_INVALID_DIR     2
#define IDS_INVALID_INIFILE 3
#define IDS_ADDFONT_ERROR   4

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakinst\ieakinst.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <regstr.h>
#include <advpub.h>
#include "resource.h"
#include <ntverp.h>      //these are for
#include <common.ver>    //ver_productversion_str
#include "..\inc\iedkbrnd.h"
#include "..\ieakutil\ieakutil.h"

#define OS_WIN95    0
#define OS_WINNT3X  1
#define OS_WINNT40  2
#define OS_WINNT50  3

#define UPGRADE_OLD         1   // indicates upgrading from an older version of IEAK. Example: 501 to 5.5
#define UPGRADE_EXISTING    2   // indicates upgrading between builds of newer version. Example: 5.5(old) to 5.5(new)
#define INSTALL_NEW         3   // indicates first time installation
#define INSTALL_SIDEBYSIDE  4   // indicates install side by side. Example: 501 & 5.5 exists in different directory

#define ADVPACKDLL      TEXT("advpack.dll")
#define IEAKWIZEXE      TEXT("ieakwiz.exe")
#define IEAK6WIZEXE     TEXT("ieak6wiz.exe")

#define HasFlag(dwFlags, dwMask) (((DWORD)(dwFlags) & (DWORD)(dwMask)) != 0L)

#define ErrorMessageBox1(hWnd, idErrorStr, dwFlags) \
            ErrorMessageBox(hWnd, idErrorStr, NULL, dwFlags)

#define ErrorMessageBox2(hWnd, pcszMsg, dwFlags) \
            ErrorMessageBox(hWnd, 0, pcszMsg, dwFlags)

typedef HRESULT (WINAPI *RUNSETUPCOMMAND) (HWND, LPCSTR, LPCSTR, LPCSTR, LPCSTR, HANDLE *, DWORD, LPVOID);
static TCHAR g_szRUNSETUPCOMMAND[] = TEXT("RunSetupCommand");

// global variables
HINSTANCE   g_hInstance;
TCHAR       g_szCurrentDir[MAX_PATH];
TCHAR       g_szInf[MAX_PATH];
HRESULT     g_hResult;
BOOL        g_fQuietMode;
int         g_dwType = INTRANET;
//

int WINAPI ErrorMessageBox(HWND hWnd, UINT idErrorStr, LPCTSTR pcszMsg, DWORD dwFlags)
    {
    int nRetVal = IDOK;

    if (!g_fQuietMode)
    {
        TCHAR szTitle[MAX_PATH];

        LoadString(g_hInstance, IDS_TITLE, szTitle, countof(szTitle));

        if (pcszMsg != NULL)
        {
            nRetVal = MessageBox(hWnd, pcszMsg, szTitle, dwFlags | MB_APPLMODAL | MB_SETFOREGROUND);
        }
        else
        {
            TCHAR szMsg[MAX_PATH];

            LoadString(g_hInstance, idErrorStr, szMsg, countof(szMsg));
            nRetVal = MessageBox(hWnd, szMsg, szTitle, dwFlags | MB_APPLMODAL | MB_SETFOREGROUND);
        }
    }

    return nRetVal;
}

void EnableDBCSChar(HWND hDlg, int iCtrlID)
{
    static HFONT s_hfontSys = NULL;

    LOGFONT lf;
    HDC     hDC;
    HWND    hwndCtrl = GetDlgItem(hDlg, iCtrlID);
    HFONT   hFont;
    int     cyLogPixels;

    hDC = GetDC(NULL);
    if (hDC == NULL)
        return;

    cyLogPixels = GetDeviceCaps(hDC, LOGPIXELSY);
    ReleaseDC(NULL, hDC);

    if (s_hfontSys == NULL)
    {
        LOGFONT lfTemp;
        HFONT   hfontDef = (HFONT)GetStockObject(DEFAULT_GUI_FONT);

        GetObject(hfontDef, sizeof(lfTemp), &lfTemp);
        hFont = GetWindowFont(hwndCtrl);
        if (hFont != NULL)
            if (GetObject(hFont, sizeof(LOGFONT), (PVOID)&lf))
            {
                StrCpy(lf.lfFaceName, lfTemp.lfFaceName);
                lf.lfQuality        = lfTemp.lfQuality;
                lf.lfPitchAndFamily = lfTemp.lfPitchAndFamily;
                lf.lfCharSet        = lfTemp.lfCharSet;

                s_hfontSys = CreateFontIndirect(&lf);
            }
    }

    if (iCtrlID == 0xFFFF)
        return;

    if (s_hfontSys != NULL)
        SetWindowFont(hwndCtrl, s_hfontSys, FALSE);
}

BOOL IsFullPath(LPCTSTR pcszPath)
{
    if ((pcszPath == NULL) || (lstrlen(pcszPath) < 3) || !PathIsValidPath(pcszPath))
        return FALSE;

    return TRUE;
}

BOOL CreateFullPath(LPCTSTR pcszPath)
{
    TCHAR   szPath[MAX_PATH];
    LPTSTR  pszPoint = NULL;
    BOOL    fLastDir = FALSE;

    if (!IsFullPath(pcszPath))
        return FALSE;

    StrCpy(szPath, pcszPath);

    if (lstrlen(szPath) > 3)
    {
        LPTSTR  szTemp;

        szTemp = CharPrev(szPath, szPath + lstrlen(szPath)) ;
        if (szTemp > szPath && *szTemp == TEXT('\\'))
            *szTemp = TEXT('\0');
    }

    // If it's a UNC path, seek up to the first share name.
    if (szPath[0] == TEXT('\\') && szPath[1] == TEXT('\\'))
    {
        pszPoint = &szPath[2];
        for (int nCount = 0; nCount < 2; nCount++)
        {
            while (*pszPoint != TEXT('\\'))
            {
                if (*pszPoint == TEXT('\0'))
                {
                    // Share name missing? Else, nothing after share name!
                    if (nCount == 0)
                        return FALSE;

                    return TRUE;
                }
                pszPoint = CharNext(pszPoint);
            }
        }
        pszPoint = CharNext(pszPoint);
    }
    else
    {
        // Otherwise, just point to the beginning of the first directory
        pszPoint = &szPath[3];
    }

    while (*pszPoint != TEXT('\0'))
    {
        while (*pszPoint != TEXT('\\') && *pszPoint != TEXT('\0'))
            pszPoint = CharNext(pszPoint);

        if (*pszPoint == TEXT('\0'))
            fLastDir = TRUE;

        *pszPoint = TEXT('\0');

        if (GetFileAttributes(szPath) == 0xFFFFFFFF)
        {
            if (!CreateDirectory(szPath, NULL))
                return FALSE;
        }

        if (fLastDir)
            break;

        *pszPoint = TEXT('\\');
        pszPoint = CharNext(pszPoint);
    }

    return TRUE;
}

DWORD FolderSize(LPCTSTR pszFolderName)
{
    DWORD dwSize = 0;
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;
    TCHAR szFile[MAX_PATH];

    if (pszFolderName == NULL  ||  *pszFolderName == TEXT('\0'))
        return dwSize;

    PathCombine(szFile, pszFolderName, TEXT("*"));

    if ((hFindFile = FindFirstFile(szFile, &fileData)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                dwSize += fileData.nFileSizeLow;
        } while (FindNextFile(hFindFile, &fileData));

        FindClose(hFindFile);
    }

    // convert bytes to KB
    dwSize = dwSize >> 10;

    return dwSize;
}

DWORD GetSpace(LPCTSTR pcszPath)
{
    DWORD   dwSecsPerCluster  = 0;
    DWORD   dwBytesPerSector  = 0;
    DWORD   dwFreeClusters    = 0;
    DWORD   dwTotalClusters   = 0;
    DWORD   dwClusterSize     = 0;
    DWORD   dwFreeBytes       = 0;

    if(*pcszPath == TEXT('\0'))
       return 0;

    if (!GetDiskFreeSpace(pcszPath, &dwSecsPerCluster, &dwBytesPerSector, &dwFreeClusters, &dwTotalClusters))
        return 0;

    dwClusterSize = dwBytesPerSector * dwSecsPerCluster;
    dwFreeBytes = MulDiv(dwClusterSize, dwFreeClusters, 1024);
    return dwFreeBytes;
}

BOOL HasEnoughSpace(HWND hDlg, LPCTSTR pcszPath, DWORD dwNeedSize, LPDWORD pdwPadSize)
{
    TCHAR   szDrive[MAX_PATH];
    DWORD   dwFreeBytes = 0;
    DWORD   dwVolFlags, dwMaxCompLen;

    // set to zero to indicate to caller that the given drive can not be checked.
    if (pdwPadSize)
        *pdwPadSize = 0;

    if (dwNeedSize == 0)
        return TRUE;

    // If you are here, we expect that the caller have validated the path which
    // has the Fullpath directory name
    //
    if (pcszPath[1] == TEXT(':'))
        StrCpyN(szDrive, pcszPath, 4);
    else if (pcszPath[0] == TEXT('\\') && pcszPath[1] == TEXT('\\'))
        return TRUE; //no way to get it
    else
        return FALSE; // you should not get here, if so, we don't know how to check it.

    if ((dwFreeBytes = GetSpace(szDrive)) == 0)
    {
        TCHAR   szMsg[MAX_PATH];
        LPTSTR  pMsg;

        LoadString(g_hInstance, IDS_ERR_GET_DISKSPACE, szMsg, countof(szMsg));
        pMsg = FormatString(szMsg, szDrive);
        ErrorMessageBox2(hDlg, pMsg, MB_ICONEXCLAMATION | MB_OK);
        LocalFree(pMsg);
        return FALSE;
    }

    // find out if the drive is compressed
    if (!GetVolumeInformation(szDrive, NULL, 0, NULL, &dwMaxCompLen, &dwVolFlags, NULL, 0))
    {
        TCHAR   szMsg[MAX_PATH];
        LPTSTR  pMsg;

        LoadString(g_hInstance, IDS_ERR_GETVOLINFOR, szMsg, countof(szMsg));
        pMsg = FormatString(szMsg, szDrive);
        ErrorMessageBox2(hDlg, pMsg, MB_ICONEXCLAMATION | MB_OK);
        LocalFree(pMsg);
        return FALSE;
    }

    if (pdwPadSize)
        *pdwPadSize = dwNeedSize;

    if ((dwVolFlags & FS_VOL_IS_COMPRESSED))
    {
        dwNeedSize = dwNeedSize + dwNeedSize/4;
        if (pdwPadSize)
            *pdwPadSize = dwNeedSize;
    }

    if (dwNeedSize > dwFreeBytes)
        return FALSE;
    else
        return TRUE;
}

BOOL IsValidDir(LPCTSTR pcszPath)
{
    DWORD  dwAttribs;
    HANDLE hFile;
    TCHAR  szTestFile[MAX_PATH];

    PathCombine(szTestFile, pcszPath, TEXT("TMP4352$.TMP"));
    DeleteFile(szTestFile);
    hFile = CreateFile(szTestFile, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    CloseHandle(hFile);

    dwAttribs = GetFileAttributes(pcszPath);
    if ((dwAttribs != 0xFFFFFFFF) && (dwAttribs & FILE_ATTRIBUTE_DIRECTORY))
        return TRUE;

    return FALSE;
}

BOOL BrowseForDir(HWND hParent, LPCTSTR pszTitle, LPTSTR pszDir)
{
    BROWSEINFO   bi;
    LPITEMIDLIST pidl;

    ZeroMemory(&bi, sizeof(bi));

    bi.hwndOwner      = hParent;
    bi.pidlRoot       = NULL;
    bi.pszDisplayName = pszDir;
    bi.lpszTitle      = pszTitle;
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;

    pidl = SHBrowseForFolder(&bi);
    if(pidl)
    {
        SHGetPathFromIDList(pidl, pszDir);
        //SHFree(pidl);
        return TRUE;
    }

    return FALSE;
}

int GetOSVersion()
{
    OSVERSIONINFO verinfo;      // Version Check
    int nOSVersion;

    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&verinfo) == FALSE)
        return -1;

    switch (verinfo.dwPlatformId)
    {
        case VER_PLATFORM_WIN32_WINDOWS:    // Win95
            nOSVersion = OS_WIN95;
            break;

        case VER_PLATFORM_WIN32_NT:         // Win NT
            nOSVersion = OS_WINNT40;

            if (verinfo.dwMajorVersion <= 3)
                nOSVersion = OS_WINNT3X;
            else if (verinfo.dwMajorVersion >= 5)
                nOSVersion = OS_WINNT50;
            break;

        default:
            nOSVersion = -1;
            break;
    }

    return nOSVersion;
}

BOOL GetProgramFilesDir(LPTSTR pszPrgfDir, DWORD cchSize)
{
    int nOSVersion;
    DWORD dwType,
          cbSize;

    nOSVersion = GetOSVersion();

    *pszPrgfDir = 0;

    if (nOSVersion >= OS_WINNT50)
    {
        if (GetEnvironmentVariable(TEXT("ProgramFiles"), pszPrgfDir, cchSize))
            return TRUE;
    }

    dwType = REG_SZ;
    cbSize = cchSize * sizeof(TCHAR);
    if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, TEXT("ProgramFilesDir"), &dwType, (LPVOID) pszPrgfDir, &cbSize) == ERROR_SUCCESS)
    {
        if (nOSVersion >= OS_WINNT40)
        {
            TCHAR szSysDrv[5] = { 0 };

            // combine reg value and systemDrive to get the acurate ProgramFiles dir
            if (GetEnvironmentVariable(TEXT("SystemDrive"), szSysDrv, countof(szSysDrv)) && *szSysDrv)
                *pszPrgfDir = *szSysDrv;
        }

        return TRUE;
    }

    return FALSE;
}

void SHCopyKey(HKEY hkFrom, HKEY hkTo)
{
    TCHAR szData[1024],
          szValue[MAX_PATH];
    DWORD dwSize, dwVal, dwSizeData, dwType;
    HKEY  hkSubkeyFrom, hkSubkeyTo;

    dwVal      = 0;
    dwSize     = countof(szValue);
    dwSizeData = sizeof(szData);
    while (ERROR_SUCCESS == RegEnumValue(hkFrom, dwVal++, szValue, &dwSize, NULL, &dwType, (LPBYTE)szData, &dwSizeData)) {
        RegSetValueEx(hkTo, szValue, 0, dwType, (LPBYTE)szData, dwSizeData);
        dwSize     = countof(szValue);
        dwSizeData = sizeof(szData);
    }

    dwVal = 0;
    while (ERROR_SUCCESS == RegEnumKey(hkFrom, dwVal++, szValue, countof(szValue)))
        if (ERROR_SUCCESS == RegOpenKeyEx(hkFrom, szValue, 0, KEY_READ | KEY_WRITE, &hkSubkeyFrom))
            if (RegCreateKeyEx(hkTo, szValue, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hkSubkeyTo, NULL) == ERROR_SUCCESS)
                SHCopyKey(hkSubkeyFrom, hkSubkeyTo);
}

void SHCopyValue(HKEY hkFrom, HKEY hkTo, LPCTSTR pcszSubKey, LPCTSTR pcszValue)
{
    TCHAR szBuffer[MAX_PATH];
    DWORD dwType, cbBuffer;

    dwType = REG_SZ;
    cbBuffer = sizeof(szBuffer);
    if (SHGetValue(hkFrom, pcszSubKey, pcszValue, &dwType, (LPVOID)szBuffer, &cbBuffer) == ERROR_SUCCESS)
    {
        cbBuffer = lstrlen(szBuffer) * sizeof(TCHAR);
        SHSetValue(hkTo, pcszSubKey, pcszValue, dwType, (LPCVOID)szBuffer, cbBuffer);
    }
}

HRESULT InstallIEAK(HWND hDlg, LPCTSTR pcszPath, int nUpgrade, DWORD dwMode)
{
    HINSTANCE   hAdvPackDll;
    TCHAR       szPath[MAX_PATH],
                szTitle[MAX_PATH],
                szInf[MAX_PATH];
    RUNSETUPCOMMAND pRunSetupCommand;
    HRESULT     hResult = S_OK;

    PathCombine(szPath, g_szCurrentDir, ADVPACKDLL);

    hAdvPackDll = LoadLibrary(szPath);
    if (hAdvPackDll == NULL)
    {
        TCHAR   szMsg[MAX_PATH];
        LPTSTR  pMsg;

        LoadString(g_hInstance, IDS_ERR_LOAD_DLL, szMsg, countof(szMsg));
        pMsg = FormatString(szMsg, ADVPACKDLL);
        ErrorMessageBox2(hDlg, pMsg, MB_ICONEXCLAMATION | MB_OK);
        LocalFree(pMsg);
        return E_FAIL;
    }

    pRunSetupCommand = (RUNSETUPCOMMAND) GetProcAddress(hAdvPackDll, g_szRUNSETUPCOMMAND);
    if (pRunSetupCommand == NULL)
    {
        TCHAR   szMsg[MAX_PATH];
        LPTSTR  pMsg;

        LoadString(g_hInstance, IDS_ERR_GET_PROC_ADDR, szMsg, countof(szMsg));
        pMsg = FormatString(szMsg, g_szRUNSETUPCOMMAND);
        ErrorMessageBox2(hDlg, pMsg, MB_ICONEXCLAMATION | MB_OK);
        LocalFree(pMsg);

        FreeLibrary(hAdvPackDll);
        return E_FAIL;
    }

    LoadString(g_hInstance, IDS_TITLE, szTitle, countof(szTitle));

    PathCombine(szInf, g_szCurrentDir, g_szInf);

    if (*pcszPath != TEXT('\0'))
    {
        SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\IEAK6"), TEXT("InstallPath"),
                   REG_SZ, pcszPath, lstrlen(pcszPath) * sizeof(TCHAR));
    }

    ShowWindow(hDlg, SW_HIDE);

    if (nUpgrade == UPGRADE_OLD)
    {
        pRunSetupCommand(hDlg, szInf, TEXT("ClearOldSettings"), g_szCurrentDir, szTitle,
                         NULL, RSC_FLAG_INF | RSC_FLAG_QUIET, 0);
    }

    hResult = pRunSetupCommand(hDlg, szInf, NULL, g_szCurrentDir, szTitle,
                            NULL, (RSC_FLAG_INF | (g_fQuietMode ? RSC_FLAG_QUIET : 0)), 0);

    if (hResult == S_OK)
    {
        BOOL  fUpdate = TRUE;
        
        if (nUpgrade == UPGRADE_OLD || nUpgrade == INSTALL_SIDEBYSIDE)
        {
            HKEY hkSrc, hkDest;
                
            hkSrc = hkDest = NULL;
            if ((RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\IEAK"), 0, KEY_READ | KEY_WRITE, &hkSrc) == ERROR_SUCCESS) &&
                (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\IEAK6"), 0, KEY_READ | KEY_WRITE, &hkDest) == ERROR_SUCCESS))
            {
                if (nUpgrade == UPGRADE_OLD)
                {
                    // copy all the values from old location to the new location
                    SHCopyKey(hkSrc, hkDest);
                }
                else    // INSTALL_SIDEBYSIDE
                {
                    SHCopyValue(hkSrc, hkDest, TEXT("Main"), TEXT("Company"));
                    SHCopyValue(hkSrc, hkDest, TEXT("Main"), TEXT("KeyCode"));
                    fUpdate = FALSE;
                }
            }
        
            if (hkSrc != NULL)
                RegCloseKey(hkSrc);

            if (hkDest != NULL)
                RegCloseKey(hkDest);

            if (nUpgrade == UPGRADE_OLD)
                SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\IEAK"));
        }
        else if (nUpgrade == UPGRADE_EXISTING)
        {
            TCHAR szOldWizPath[MAX_PATH];
            DWORD dwType = REG_SZ;
            DWORD cbSize = sizeof(szOldWizPath);

            // if ieak501 exists in another location, do not update the AppPaths\ieakwiz.exe key
            if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\IEAKWIZ.EXE"), NULL, &dwType,
                           (LPVOID)szOldWizPath, &cbSize) == ERROR_SUCCESS)
            {
                if (StrCmpI(PathFindFileName(szOldWizPath), IEAKWIZEXE) == 0)
                    fUpdate = FALSE;
            }
        }

        if (fUpdate)
        {
            TCHAR szOldWizPath[MAX_PATH];

            SHSetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\IEAKWIZ.EXE"), TEXT("Path"), REG_SZ,
                       pcszPath, lstrlen(pcszPath) * sizeof(TCHAR));

            PathCombine(szOldWizPath, pcszPath, IEAK6WIZEXE);
            SHSetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\IEAKWIZ.EXE"), NULL, REG_SZ, 
                       szOldWizPath, lstrlen(szOldWizPath) * sizeof(TCHAR));
        }
        HKEY hKey;
        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\IEAK"),NULL,NULL,NULL,KEY_SET_VALUE,NULL,&hKey,NULL) == ERROR_SUCCESS)
        {
            RegSetValueEx(hKey,TEXT("Version"),NULL,REG_SZ,(LPBYTE)VER_PRODUCTVERSION_STR,(lstrlen(VER_PRODUCTVERSION_STR)+1) * sizeof(TCHAR));
            RegSetValueEx(hKey,TEXT("Mode"),NULL,REG_DWORD,g_fQuietMode ? (CONST BYTE *) &g_dwType : (CONST BYTE *) &dwMode,sizeof(DWORD));
        }
    }

    return hResult;
}

void CenterWindow(HWND hwnd)
{
    int nScreenx;
    int nScreeny;
    int nHeight, nWidth, x, y;
    RECT rect;

    nScreenx = GetSystemMetrics(SM_CXSCREEN);
    nScreeny = GetSystemMetrics(SM_CYSCREEN);

    GetWindowRect(hwnd, &rect);

    nWidth = rect.right - rect.left;
    nHeight = rect.bottom - rect.top;
    x = (nScreenx / 2) - (nWidth / 2);
    y = (nScreeny / 2) - (nHeight / 2);

    SetWindowPos(hwnd, HWND_TOP, x, y, nWidth, nHeight, SWP_NOZORDER);
}

void InitPath(HWND hDlg, LPTSTR pszDefaultPath, LPBOOL pnUpgrade)
{
    TCHAR szPath[MAX_PATH];
    DWORD dwType, cbSize;
    int   nUpgrade = INSTALL_NEW;

    *szPath = TEXT('\0');

    // check for the upgrade path
    dwType = REG_SZ;
    cbSize = sizeof(szPath);
    *szPath = TEXT('\0');
    if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\IEAK6WIZ.EXE"),
               TEXT("Path"), &dwType, (LPVOID) szPath, &cbSize) != ERROR_SUCCESS)
    {
        dwType = REG_SZ;
        cbSize = sizeof(szPath);
        if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\IEAKWIZ.EXE"),
                   NULL, &dwType, (LPVOID) szPath, &cbSize) == ERROR_SUCCESS)
        {
            DWORD dwAttribs;

            dwAttribs = GetFileAttributes(szPath);

            if (dwAttribs != 0xFFFFFFFF && !(dwAttribs & FILE_ATTRIBUTE_DIRECTORY))
            {
                if (!g_fQuietMode && ErrorMessageBox1(hDlg, IDS_IEAK_UPGRADE, MB_ICONQUESTION | MB_YESNO) == IDNO)
                    nUpgrade = INSTALL_SIDEBYSIDE;
                else
                {
                    PathRemoveFileSpec(szPath);
                    nUpgrade = UPGRADE_OLD;
                }
            }
        }

        if (nUpgrade == INSTALL_NEW || nUpgrade == INSTALL_SIDEBYSIDE)
        {
            // default to "Program Files\IEAK6"
            if (!GetProgramFilesDir(szPath, countof(szPath)))
                LoadString(g_hInstance, IDS_PROGRAMFILES_PATH, szPath, countof(szPath));

            PathAppend(szPath, TEXT("IEAK6"));
        }
    }
    else
        nUpgrade = UPGRADE_EXISTING;

    if (pszDefaultPath != NULL)
        StrCpy(pszDefaultPath, szPath);

    if (pnUpgrade != NULL)
        *pnUpgrade = nUpgrade;
}

BOOL ProcessPath(HWND hDlg, LPTSTR pcszPath, LPTSTR pcszDefaultPath, int nUpgrade)
{
    TCHAR szMsg[MAX_PATH],
          szTitle[MAX_PATH];
    BOOL  fClear = FALSE;
    DWORD dwTemp = 0;
    DWORD dwAttribs;

    if (*pcszPath == TEXT('\0') || !IsFullPath(pcszPath))
    {
        ErrorMessageBox1(hDlg, IDS_ERR_EMPTY_PATH, MB_ICONINFORMATION | MB_OK);
        return FALSE;
    }

    // if installing side by side, make sure that the destination path is different than that of the earlier IEAK
    if (nUpgrade == INSTALL_SIDEBYSIDE)
    {
        DWORD dwType, cbSize;
        TCHAR szIEAKOldPath[MAX_PATH];

        dwType = REG_SZ;
        cbSize = sizeof(szIEAKOldPath);
        if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\IEAKWIZ.EXE"),
                   TEXT("Path"), &dwType, (LPVOID) szIEAKOldPath, &cbSize) == ERROR_SUCCESS)
        {
            if (StrCmpI(pcszPath, szIEAKOldPath) == 0)
            {
                ErrorMessageBox1(hDlg, IDS_SPECIFY_DIFFERENT_PATH, MB_ICONINFORMATION | MB_OK);
                return FALSE;
            }
        }
    }

    while (!HasEnoughSpace(hDlg, pcszPath, FolderSize(g_szCurrentDir), &dwTemp))
    {
        if (dwTemp && !g_fQuietMode)
        {
            TCHAR   szMsg[MAX_PATH];
            LPTSTR  pMsg;
            int     nResult;

            LoadString(g_hInstance, IDS_ERR_NO_SPACE_INST, szMsg, countof(szMsg));
            pMsg = FormatString(szMsg, dwTemp);
            nResult = ErrorMessageBox2(hDlg, pMsg, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2);
            LocalFree(pMsg);

            if (nResult == IDNO)
                return FALSE;
        }
        else // given drive cannot be checked, error has been posted. no further needed or its quiet mode
            return FALSE;
    }

    dwAttribs = GetFileAttributes(pcszPath);
    if (dwAttribs == 0xFFFFFFFF)
    {
        // If this new entry is different from the original, then prompt the user.
        if (StrCmpI(pcszPath, pcszDefaultPath) != 0 && !g_fQuietMode)
        {
            TCHAR   szMsg[MAX_PATH];
            LPTSTR  pMsg;
            int     nResult;

            LoadString(g_hInstance, IDS_CREATE_DIR, szMsg, countof(szMsg));
            pMsg = FormatString(szMsg, pcszPath);
            nResult = ErrorMessageBox2(hDlg, pMsg, MB_ICONQUESTION | MB_YESNO);
            LocalFree(pMsg);
            if (nResult == IDNO)
                return FALSE;
        }

        if (!CreateFullPath(pcszPath))
        {
            TCHAR   szMsg[MAX_PATH];
            LPTSTR  pMsg;

            LoadString(g_hInstance, IDS_ERR_CREATE_DIR, szMsg, countof(szMsg));
            pMsg = FormatString(szMsg, pcszPath);
            ErrorMessageBox2(hDlg, pMsg, MB_ICONEXCLAMATION | MB_OK);
            LocalFree(pMsg);
            return FALSE;
        }
    }

    if (!IsValidDir(pcszPath))
    {
        TCHAR   szMsg[MAX_PATH];
        LPTSTR  pMsg;

        LoadString(g_hInstance, IDS_ERR_INVALID_DIR, szMsg, countof(szMsg));
        pMsg = FormatString(szMsg, pcszPath);
        ErrorMessageBox2(hDlg, pMsg, MB_ICONEXCLAMATION | MB_OK);
        LocalFree(pMsg);
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK ConfirmDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_INITDIALOG:
        {
            TCHAR szTmp[1024];
            DWORD dwMode;
            dwMode = (DWORD)GetWindowLongPtr(GetParent(hDlg),GWLP_USERDATA);
            switch (dwMode)
            {
                case REDIST:
                    LoadString(g_hInstance,IDS_ICP,szTmp,countof(szTmp));
                    break;
                case BRANDED:
                    LoadString(g_hInstance,IDS_ISP,szTmp,countof(szTmp));
                    break;
                case INTRANET:
                default:
                    LoadString(g_hInstance,IDS_CORP,szTmp,countof(szTmp));
                    break;
            }
            SetDlgItemText(hDlg,IDC_STATICLICENSE,szTmp);
            return TRUE;
        }

        case WM_COMMAND:
            switch (wParam)
            {
                case IDOK:
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }

    }
    return FALSE;

}

INT_PTR CALLBACK DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static TCHAR szDefaultPath[MAX_PATH];
    static int   nUpgrade;
    static DWORD dwMode = BRANDED;  //default mode

    switch(msg)
    {
        case WM_INITDIALOG:
        {
            EnableDBCSChar(hDlg, IDE_INSTALLDIR);
            InitPath(hDlg, szDefaultPath, &nUpgrade);
            SetDlgItemText(hDlg, IDE_INSTALLDIR, szDefaultPath);
            CenterWindow(hDlg);
            switch (dwMode) 
            {
                case REDIST:
                    CheckDlgButton(hDlg,IDC_ICP,TRUE);  
                    break;
                case BRANDED:
                    CheckDlgButton(hDlg,IDC_ISP,TRUE);  
                    break;
                case INTRANET:
                default:
                    CheckDlgButton(hDlg,IDC_INTRA,TRUE); 
                    break;
            }

            if(nUpgrade == UPGRADE_OLD)
            {
                ShowWindow(hDlg, SW_HIDE);
                PostMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDOK, BN_CLICKED), 0L);
            }

            return TRUE;
        }

        case WM_COMMAND:
            switch (wParam)
            {
                case IDC_BROWSE:
                {
                    TCHAR szPath[MAX_PATH];

                    GetDlgItemText(hDlg, IDE_INSTALLDIR, szPath, countof(szPath));

                    TCHAR szInstructions[MAX_PATH];
                    LoadString(g_hInstance,IDS_INSTALLINSTR,szInstructions,countof(szInstructions));

                    if (BrowseForDir(hDlg, szInstructions, szPath))
                        SetDlgItemText(hDlg, IDE_INSTALLDIR, szPath);

                    return TRUE;
                }

                case IDC_ICP:
                    dwMode = REDIST;
                    break;

                case IDC_ISP:
                    dwMode = BRANDED;
                    break;

                case IDC_INTRA:
                    dwMode = INTRANET;
                    break;

                case IDOK:
                {
                    TCHAR szPath[MAX_PATH];

                    SetWindowLongPtr(hDlg,GWLP_USERDATA,dwMode);
                
                    if (!DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CONFIRMLICENSE), hDlg, ConfirmDlgProc))
                        return TRUE;  //keep trying

                    GetDlgItemText(hDlg, IDE_INSTALLDIR, szPath, countof(szPath));
                    if (!ProcessPath(hDlg, szPath, szDefaultPath, nUpgrade))
                        return TRUE;
                        
                    g_hResult = InstallIEAK(hDlg, szPath, nUpgrade, dwMode);
                    EndDialog(hDlg, TRUE);
                    return TRUE;
                }

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }
            break;

        case WM_CLOSE:
            EndDialog(hDlg, FALSE);
            return TRUE;
    }

    return FALSE;
}

HRESULT SilentInstallIEAK()
{
    TCHAR szPath[MAX_PATH];
    int   nUpgrade;
    
    InitPath(NULL, szPath, &nUpgrade);

    if (!ProcessPath(NULL, szPath, szPath, nUpgrade))
        return E_FAIL;

    return InstallIEAK(NULL, szPath, nUpgrade, 0 /*default type goes here*/);
}

//  Reads the next word in the string pszData and copies it into szWord
//  Returns a pointer to the next character after the word
LPTSTR ReadWord(LPTSTR pszData, LPTSTR szWord, int cchLength)
{
    int i;
    int nIndex;

    ZeroMemory(szWord, cchLength*sizeof(TCHAR));

    // remove whitespace
    i = StrSpn(pszData, TEXT(" \n\t\x0d\x0a"));
    pszData += i;

    i = StrCSpn(pszData, TEXT(" \n\t\x0d\x0a"));
    if(i > cchLength)       // make sure we dont overrun our buffer
        i = cchLength - 1;

    StrCpyN(szWord, pszData, i+1);

    pszData += i;
    return pszData;
}

void ParseCmdLine(LPTSTR lpCmdLine)
{
    LPTSTR  pParam;
    TCHAR   szWord[MAX_PATH];

    *g_szInf = TEXT('\0');
    g_fQuietMode = FALSE;

    pParam = lpCmdLine;

    while ((pParam - lpCmdLine) < lstrlen(lpCmdLine))
    {
        pParam = ReadWord(pParam, szWord, countof(szWord));

        if (*szWord != TEXT('\0'))
        {
            if (szWord[0] == TEXT('/') && (szWord[1] == TEXT('q') || szWord[1] == TEXT('Q')))
                g_fQuietMode = TRUE;
            else if (szWord[0] == TEXT('/') && (szWord[1] == TEXT('m') || szWord[1] == TEXT('M')))
            {
                switch (szWord[3])
                {
                    case TEXT('B'):
                    case TEXT('b'):
                        g_dwType = BRANDED;
                        break;

                    case TEXT('r'):
                    case TEXT('R'):
                        g_dwType = REDIST;
                        break;

                    case TEXT('I'):
                    case TEXT('i'):
                    default:
                        g_dwType = INTRANET;
                        break;
                }
            }
            else if (*g_szInf == TEXT('\0'))
                StrCpy(g_szInf, szWord);
        }
    }
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow)
{
    g_hResult = S_OK;
    g_hInstance = hInstance;

    ParseCmdLine(lpCmdLine);

    GetModuleFileName(GetModuleHandle(NULL), g_szCurrentDir, MAX_PATH);
    PathRemoveFileSpec(g_szCurrentDir);

    if (!IsNTAdmin())
    {
        if (!g_fQuietMode)
        {
            TCHAR szError[MAX_PATH];
            LoadString(hInstance,IDS_ERR_NOTADMIN,szError,countof(szError));
            MessageBox(NULL,szError,NULL,MB_ICONSTOP);
        }
        g_hResult = E_ACCESSDENIED;
    }
    else
    {
        if (g_fQuietMode)
            g_hResult = SilentInstallIEAK();
        else
        {
            if (!DialogBox(hInstance, MAKEINTRESOURCE(IDD_INSTALLDIR), NULL, DlgProc))
                g_hResult = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }

    return g_hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\about.h ===
#ifndef _ABOUT_H_
#define _ABOUT_H_

// {5A7B63E0-F9BC-11d2-BBE5-00C04F86AE3B}
DEFINE_GUID(CLSID_AboutIEAKSnapinExt, 0x5a7b63e0, 0xf9bc, 0x11d2, 0xbb, 0xe5, 0x0, 0xc0, 0x4f, 0x86, 0xae, 0x3b);

//
// CAboutIEAKSnapinExt class
//

class CAboutIEAKSnapinExt : public ISnapinAbout
{

public:
    CAboutIEAKSnapinExt();
    ~CAboutIEAKSnapinExt();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented ISnapinAbout interface members
    //

    STDMETHODIMP         GetSnapinDescription(LPOLESTR *lpDescription);
    STDMETHODIMP         GetProvider(LPOLESTR *lpName);
    STDMETHODIMP         GetSnapinVersion(LPOLESTR *lpVersion);
    STDMETHODIMP         GetSnapinImage(HICON *hAppIcon);
    STDMETHODIMP         GetStaticFolderImage(HBITMAP *hSmallImage,
                                              HBITMAP *hSmallImageOpen,
                                              HBITMAP *hLargeImage,
                                              COLORREF *cMask);

private:

    ULONG    m_cRef;
    HBITMAP  m_hSmallImage;
    HBITMAP  m_hSmallImageOpen;
    HBITMAP  m_hLargeImage;
    HICON    m_hAppIcon;

};

class CAboutIEAKSnapinExtCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CAboutIEAKSnapinExtCF();
    ~CAboutIEAKSnapinExtCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


#endif // _ABOUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\adm.cpp ===
#include "precomp.h"
#include <admparse.h>

#include "rsop.h"

#define NUM_ICONS 3

int g_ADMOpen, g_ADMClose, g_ADMCategory;

extern HINSTANCE g_hUIInstance;


// Creates image list, adds 3 icons to it, and associates the image
// list with the treeview control.
LRESULT InitImageList(HWND hTreeView)
{
    HIMAGELIST  hWndImageList;
    HICON       hIcon;

    hWndImageList = ImageList_Create(GetSystemMetrics (SM_CXSMICON),
                                     GetSystemMetrics (SM_CYSMICON),
                                     TRUE, NUM_ICONS, 3);
    if(!hWndImageList)
    {
        return FALSE;
    }

    hIcon = LoadIcon(g_hUIInstance, MAKEINTRESOURCE(IDI_ICON2));
    g_ADMOpen = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    hIcon = LoadIcon(g_hUIInstance, MAKEINTRESOURCE(IDI_ICON3));
    g_ADMClose = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    hIcon = LoadIcon(g_hUIInstance, MAKEINTRESOURCE(IDI_ICON4));
    g_ADMCategory = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    // Fail if not all images were added.
    if (ImageList_GetImageCount(hWndImageList) < NUM_ICONS)
    {
        // ERROR: Unable to add all images to image list.
        return FALSE;
    }

    // Associate image list with treeView control.
    TreeView_SetImageList(hTreeView, hWndImageList, TVSIL_NORMAL);
    return TRUE;
}

static void AddIconsToNodes(HWND hTreeView, HTREEITEM hParentItem)
{
    TV_ITEM     tvItem;
    HTREEITEM   hItem;

    hItem = TreeView_GetChild(hTreeView, hParentItem);

    while(hItem != NULL)
    {
        tvItem.hItem            = hItem;
        tvItem.mask             = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvItem.iImage           = g_ADMCategory;
        tvItem.iSelectedImage   = g_ADMCategory;

        TreeView_SetItem(hTreeView, &tvItem);
        
        hItem = TreeView_GetNextSibling(hTreeView, hItem); // get next item
    }
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK AdmDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	// Retrieve Property Sheet Page info for each call into dlg proc.
	LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    TV_ITEM         tvItem, tvItem1;
    HTREEITEM       hItem, hParentItem;
    RECT            rectDlg, rectInstr, rectDscr;
    RECT            rectButton, rectTreeView;
    static TCHAR    szWorkDir[MAX_PATH];
    HWND            hTreeView = GetDlgItem(hDlg, IDC_ADMTREE);
    LPNM_TREEVIEW   lpNMTreeView = (LPNM_TREEVIEW)lParam;

    UNREFERENCED_PARAMETER(wParam);

    switch (message)
    {
        case WM_INITDIALOG:
            SetPropSheetCookie(hDlg, lParam);

            EnableDBCSChars(hDlg, IDC_ADMTREE);

            InitImageList(hTreeView);

#ifdef UNICODE
            TreeView_SetUnicodeFormat(hTreeView, TRUE);
#else
            TreeView_SetUnicodeFormat(hTreeView, FALSE);
#endif

            HideDlgItem(hDlg, IDC_ADMIMPORT);
            HideDlgItem(hDlg, IDC_ADMDELETE);

            // strech the treeview to cover the area of the buttons
            GetWindowRect(GetDlgItem(hDlg, IDC_ADMIMPORT), &rectButton);
            GetWindowRect(hTreeView, &rectTreeView);

            SetWindowPos(hTreeView, HWND_TOP, 0, 0, rectTreeView.right - rectTreeView.left,
                         (rectTreeView.bottom - rectTreeView.top) + (rectButton.bottom - rectTreeView.bottom),
                         SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW);
            break;

		case WM_DESTROY:
			//TODO: UNCOMMENT
//			if (psCookie->pCS->IsRSoP())
//				DestroyDlgRSoPData(hDlg);
			break;

        case WM_HELP:   // F1
            ShowHelpTopic(hDlg);
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code)
            {
                case PSN_HELP:
                    ShowHelpTopic(hDlg);
                    break;

                case PSN_SETACTIVE:
                    CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\ADM"), szWorkDir);

                    GetWindowRect(hDlg, &rectDlg);
                    GetWindowRect(GetDlgItem(hDlg, IDC_ADMINSTR), &rectInstr);
            
                    rectDscr.left   = rectInstr.left - rectDlg.left + 1;
                    rectDscr.top    = rectInstr.top - rectDlg.top + 1;
                    rectDscr.right  = rectDscr.left + (rectInstr.right - rectInstr.left) - 2;
                    rectDscr.bottom = rectDscr.top + (rectInstr.bottom - rectInstr.top) - 2;
            
                    CreateADMWindow(hTreeView, GetDlgItem(hDlg, IDC_ADMINSTR), rectDscr.left,
                                    rectDscr.top, rectDscr.right - rectDscr.left, 
                                    rectDscr.bottom - rectDscr.top);
                    
                    {
                        TCHAR szAdmFilePath[MAX_PATH];
                        TCHAR szAdmFileName[MAX_PATH];
                        CNewCursor cur(IDC_WAIT);

                        StrCpy(szAdmFilePath, GetCurrentAdmFile(hDlg));
                        StrCpy(szAdmFileName, PathFindFileName(szAdmFilePath));
                        PathRemoveFileSpec(szAdmFilePath);
                        
						BSTR bstrNamespace = NULL;
						if (psCookie->pCS->IsRSoP())
							bstrNamespace = psCookie->pCS->GetRSoPNamespace();

                        hItem = AddADMItem(hTreeView, szAdmFilePath, szAdmFileName,
											szWorkDir, ROLE_CORP, bstrNamespace);
                        if (hItem != NULL)
                        {
                            AddIconsToNodes(hTreeView, hItem);
                            TreeView_Expand(hTreeView, hItem, TVE_EXPAND);
                            TreeView_SelectItem(hTreeView, hItem);
                        }
                    }
                    break;

                case PSN_APPLY:
					if (psCookie->pCS->IsRSoP())
						return FALSE;
					else
					{
						if (!AcquireWriteCriticalSection(hDlg))
						{
							SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
							break;
						}
                    
						// save the contents and delete the tree item
						DeleteADMItems(hTreeView, szWorkDir, GetInsFile(hDlg), TRUE);
						TreeView_DeleteAllItems(hTreeView);
                    
						DestroyADMWindow(hTreeView);

						if (PathIsDirectoryEmpty(szWorkDir))
							PathRemovePath(szWorkDir);

						// Copy this ADM file to the same dir as the INF files so we can
						// use the two files to display results from RSoP.
						CopyFileToDirEx(GetCurrentAdmFile(hDlg), szWorkDir);

						SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt, TRUE);
					}
                    break;

                case PSN_QUERYCANCEL:
                    DeleteADMItems(hTreeView, szWorkDir, GetInsFile(hDlg), FALSE);
                    TreeView_DeleteAllItems(hTreeView);

                    DestroyADMWindow(hTreeView);

                    if (PathIsDirectoryEmpty(szWorkDir))
                        PathRemovePath(szWorkDir);

                    break;

                case TVN_SELCHANGED:
                    hParentItem = TreeView_GetParent(hTreeView, lpNMTreeView->itemNew.hItem);
                    
                    // save and remove the previous item
                    SelectADMItem(hDlg, hTreeView, &lpNMTreeView->itemOld, FALSE, FALSE);
                    
                    // display the information for the newly selected item
                    DisplayADMItem(hDlg, hTreeView, &lpNMTreeView->itemNew, FALSE);
                    break;

                case TVN_ITEMEXPANDED:
                    tvItem.mask = TVIF_IMAGE;
                    tvItem.hItem = lpNMTreeView->itemNew.hItem;
                    TreeView_GetItem(hTreeView, &tvItem);

                    // If tree item is EXPANDING (opening up) and
                    // current icon == CloseFolder, change icon to OpenFolder
                    if((lpNMTreeView->action == TVE_EXPAND) &&
                        (tvItem.iImage == g_ADMClose))
                    {
                        tvItem1.hItem = lpNMTreeView->itemNew.hItem;
                        tvItem1.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                        tvItem1.iImage = g_ADMOpen;
                        tvItem1.iSelectedImage = g_ADMOpen;

                        TreeView_SetItem(hTreeView, &tvItem1);
                    }

                    // If tree item is COLLAPSING (closing up) and
                    // current icon == OpenFolder, change icon to CloseFolder
                    else if((lpNMTreeView->action == TVE_COLLAPSE) &&
                        (tvItem.iImage == g_ADMOpen))
                    {
                        tvItem1.hItem = lpNMTreeView->itemNew.hItem;
                        tvItem1.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                        tvItem1.iImage = g_ADMClose;
                        tvItem1.iSelectedImage = g_ADMClose;

                        TreeView_SetItem(hTreeView, &tvItem1);
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\about.cpp ===
#include "precomp.h"
#include <wingdi.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CAboutIEAKSnapinExt implementation                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CAboutIEAKSnapinExt::CAboutIEAKSnapinExt()
{
    InterlockedIncrement(&g_cRefThisDll);
    m_cRef = 1;

    // BUGBUG: <oliverl> need to change images here
    m_hSmallImage = (HBITMAP) LoadImage(g_hInstance, MAKEINTRESOURCE(IDB_IEAKSIEHELPABT_16),
                                        IMAGE_BITMAP, 16, 16, LR_DEFAULTCOLOR);

    m_hSmallImageOpen = m_hSmallImage;

    m_hLargeImage = (HBITMAP) LoadImage(g_hInstance, MAKEINTRESOURCE(IDB_IEAKSIEHELPABT_32),
                                        IMAGE_BITMAP, 32, 32, LR_DEFAULTCOLOR);

    m_hAppIcon =        LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_HELPABOUT));
}

CAboutIEAKSnapinExt::~CAboutIEAKSnapinExt()
{
    if (m_hSmallImage != NULL)
        DeleteObject(m_hSmallImage);

    if (m_hLargeImage != NULL)
        DeleteObject(m_hLargeImage);

    if (m_hAppIcon != NULL)
        DestroyIcon(m_hAppIcon);

    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CAboutIEAKSnapinExt object implementation (IUnknown)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CAboutIEAKSnapinExt::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_ISnapinAbout))
    {
        *ppv = (LPSNAPABOUT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CAboutIEAKSnapinExt::AddRef (void)
{
    return ++m_cRef;
}

ULONG CAboutIEAKSnapinExt::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CAboutIEAKSnapinExt object implementation (ISnapinAbout)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAboutIEAKSnapinExt::GetSnapinDescription(LPOLESTR *lpDescription)
{
    LPWSTR lpBufferW;

    if ((lpBufferW = (LPWSTR)CoTaskMemAlloc(StrCbFromCchW(MAX_PATH))) != NULL)
    {
        LoadString (g_hInstance, IDS_SNAPIN_DESC, lpBufferW, MAX_PATH);
        *lpDescription = (LPOLESTR)lpBufferW;
    }

    return S_OK;
}

STDMETHODIMP CAboutIEAKSnapinExt::GetProvider(LPOLESTR *lpName)
{
    LPWSTR lpBufferW;

    

    if ((lpBufferW = (LPWSTR)CoTaskMemAlloc(StrCbFromCchW(64))) != NULL)
    {
        LoadString (g_hInstance, IDS_PROVIDER_NAME, lpBufferW, 64);
        *lpName = (LPOLESTR)lpBufferW;
    }

    return S_OK;
}

STDMETHODIMP CAboutIEAKSnapinExt::GetSnapinVersion(LPOLESTR *lpVersion)
{
    LPWSTR lpBufferW;

    if ((lpBufferW = (LPWSTR)CoTaskMemAlloc (StrCbFromCchW(64))) != NULL)
    {
        LoadString (g_hInstance, IDS_SNAPIN_VERSION, lpBufferW, 64);
        *lpVersion = (LPOLESTR)lpBufferW;
    }

    return S_OK;
}

STDMETHODIMP CAboutIEAKSnapinExt::GetSnapinImage(HICON *hAppIcon)
{
    

    *hAppIcon = m_hAppIcon;

    return S_OK;
}

STDMETHODIMP CAboutIEAKSnapinExt::GetStaticFolderImage(HBITMAP *hSmallImage,
                                                  HBITMAP *hSmallImageOpen,
                                                  HBITMAP *hLargeImage,
                                                  COLORREF *cMask)
{

    *hSmallImage = m_hSmallImage;
    *hSmallImageOpen = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    *cMask = RGB(255, 0, 255);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CAboutIEAKSnapinExtCF::CAboutIEAKSnapinExtCF()
{
    m_cRef++;
    InterlockedIncrement(&g_cRefThisDll);
}

CAboutIEAKSnapinExtCF::~CAboutIEAKSnapinExtCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CAboutIEAKSnapinExtCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CAboutIEAKSnapinExtCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CAboutIEAKSnapinExtCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CAboutIEAKSnapinExtCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    CAboutIEAKSnapinExt *pAboutGPE = new CAboutIEAKSnapinExt(); // ref count == 1

    if (!pAboutGPE)
        return E_OUTOFMEMORY;

    HRESULT hr = pAboutGPE->QueryInterface(riid, ppvObj);
    pAboutGPE->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CAboutIEAKSnapinExtCF::LockServer(BOOL fLock)
{
    UNREFERENCED_PARAMETER(fLock);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakfont\ieakfont.cpp ===
#include <windows.h>
#include "resource.h"


#define countof(a)     (sizeof(a)/sizeof((a)[0]))


void InstallFonts(HINSTANCE hInst, LPCTSTR pcszIniPath);
void AddFont(HINSTANCE hInst, LPCTSTR pcszFontName, LPCTSTR pcszFontFile);

BOOL FileExists(LPCSTR lpcszFileName);
LPSTR AddPath(LPSTR lpszPath, LPCSTR lpcszFileName);
LPCSTR GetFileName(LPCSTR lpcszFilePath);

LPSTR FAR ANSIStrRChr(LPCSTR lpStart, WORD wMatch);
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch);


int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
    /*
     * Scan, and skip over, subsequent characters until
     * another double-quote or a null is encountered.
     */
    while ( *++pszCmdLine && (*pszCmdLine
         != '\"') );
    /*
     * If we stopped on a double-quote (usual case), skip
     * over it.
     */
    if ( *pszCmdLine == '\"' )
        pszCmdLine++;
    }
    else {
    while (*pszCmdLine > ' ')
        pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
    pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}


int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow)
{
    TCHAR szIniPath[MAX_PATH];
    LPTSTR pszPtr;
    TCHAR szTitle[MAX_PATH];
    TCHAR szMsg[MAX_PATH];
    TCHAR szError[MAX_PATH];

    LoadString(hInst, IDS_TITLE, szTitle, countof(szTitle));

    *szIniPath = '\0';
    GetModuleFileName(NULL, szIniPath, countof(szIniPath));
    if (*szIniPath == TEXT('\0'))
    {
        LoadString(hInst, IDS_INVALID_DIR, szError, countof(szError));
        MessageBox(NULL, szError, szTitle, MB_OK | MB_SETFOREGROUND);
        return 1;
    }

    if ((pszPtr = ANSIStrRChr(szIniPath,'\\')) != NULL)
        pszPtr++;
    else
        pszPtr = szIniPath;
    lstrcpy(pszPtr, TEXT("ieakfont.ini"));

    if (!FileExists(szIniPath))
    {
        LoadString(hInst, IDS_INVALID_INIFILE, szMsg, countof(szMsg));
        wsprintf(szError, szMsg, szIniPath);
        MessageBox(NULL, szError, szTitle, MB_OK | MB_SETFOREGROUND);
        return 1;
    }
    
    InstallFonts(hInst, szIniPath);

    return 1;
}


void InstallFonts(HINSTANCE hInst, LPCTSTR pcszIniPath)
{
    int nFonts = 0;
    TCHAR szFontDir[MAX_PATH];

    // get the fonts directory
    GetWindowsDirectory(szFontDir, countof(szFontDir));
    AddPath(szFontDir, "FONTS");

    // get the font filenames to be installed from the ini file
    nFonts = GetPrivateProfileInt(TEXT("FONTS"), TEXT("NUMFONTS"), 0, pcszIniPath);

    for (int nIndex = 0; nIndex < nFonts; nIndex++)
    {
        TCHAR szKey[10];
        TCHAR szFontStr[MAX_PATH];

        wsprintf(szKey, TEXT("FONT%d"), nIndex + 1);
        if (GetPrivateProfileString(TEXT("FONTS"), szKey, TEXT(""), szFontStr, countof(szFontStr), pcszIniPath))
        {
            TCHAR szFontFile[MAX_PATH];
            TCHAR szFontName[MAX_PATH];

            lstrcpy(szFontFile, szFontDir);
            AddPath(szFontFile, szFontStr);

            wsprintf(szKey, TEXT("FONTNAME%d"), nIndex + 1);
            GetPrivateProfileString(TEXT("FONTS"), szKey, szFontStr, szFontName, countof(szFontName), pcszIniPath);

            // REVIEW: (a-saship) by the time this api call happens all parameters are validated and not empty.
            // AddFont itself doesn't validate in-parameters.
            AddFont(hInst, szFontName, szFontFile);
        }
    }
}


void AddFont(HINSTANCE hInst, LPCTSTR pcszFontName, LPCTSTR pcszFontFile)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szMsg[MAX_PATH];
    TCHAR szError[MAX_PATH];
    TCHAR szFontFileName[MAX_PATH];
    TCHAR szKeyName[MAX_PATH];
    HKEY hkFontsKey;

    LoadString(hInst, IDS_TITLE, szTitle, countof(szTitle));
    lstrcpy(szFontFileName, GetFileName(pcszFontFile));

    if (!AddFontResource(pcszFontFile))
    {
        LoadString(hInst, IDS_ADDFONT_ERROR, szMsg, countof(szMsg));
        wsprintf(szError, szMsg, szFontFileName);
        MessageBox(NULL, szError, szTitle, MB_OK | MB_SETFOREGROUND);
        return;
    }

    SendMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0L);

    // make it permanent by adding it to the registry
    if ((GetVersion() & 0x80000000) == 0) // if NT
        lstrcpy(szKeyName, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts"));
    else
        lstrcpy(szKeyName, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Fonts"));

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkFontsKey, NULL) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkFontsKey, pcszFontName, 0, REG_SZ, (CONST BYTE *) szFontFileName, lstrlen(szFontFileName) + 1);
        RegCloseKey(hkFontsKey);
    }
}


BOOL FileExists(LPCSTR lpcszFileName)
{
    DWORD dwAttrib = GetFileAttributes(lpcszFileName);

    if (dwAttrib == (DWORD) -1)
        return FALSE;

    return !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
}


LPSTR AddPath(LPSTR lpszPath, LPCSTR lpcszFileName)
{
    LPSTR lpszPtr;

    if (lpszPath == NULL)
        return NULL;

    lpszPtr = lpszPath + lstrlen(lpszPath);
    if (lpszPtr > lpszPath  &&  *CharPrev(lpszPath, lpszPtr) != '\\')
        *lpszPtr++ = '\\';

    if (lpcszFileName != NULL)
        lstrcpy(lpszPtr, lpcszFileName);
    else
        *lpszPtr = '\0';

    return lpszPath;
}


LPCSTR GetFileName(LPCSTR lpcszFilePath)
// Return the name of the file alone from lpcszFilePath
{
    LPCSTR lpcszFileName = ANSIStrRChr(lpcszFilePath, '\\');

    return (lpcszFileName == NULL ? lpcszFilePath : lpcszFileName + 1);
}


// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR FAR ANSIStrRChr(LPCSTR lpStart, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    for ( ; *lpStart; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}


// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakinst\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ieakinst.rc
//
#define IDD_INSTALLDIR                  101
#define IDE_INSTALLDIR                  111
#define IDC_BROWSE                      112
#define IDC_ICP                         113
#define IDC_ISP                         114
#define IDC_INTRA                       115
#define IDS_TITLE                       151
#define IDS_ERR_EMPTY_PATH              152
#define IDS_ERR_NO_SPACE_INST           153
#define IDS_CREATE_DIR                  154
#define IDS_ERR_CREATE_DIR              155
#define IDS_ERR_INVALID_DIR             156
#define IDS_ERR_GET_DISKSPACE           157
#define IDS_ERR_GETVOLINFOR             158
#define IDS_ERR_BADOS                   159
#define IDS_ERR_GET_PROC_ADDR           160
#define IDS_PROGRAMFILES_PATH           161
#define IDS_IEAK_UPGRADE                162
#define IDS_SPECIFY_DIFFERENT_PATH      163
#define IDS_ICP                         164
#define IDS_ISP                         165
#define IDS_CORP                        166
#define IDS_ERR_NOTADMIN                167
#define IDS_ERR_LOAD_DLL                169
#define IDD_CONFIRMLICENSE              170
#define IDS_INSTALLINSTR                171
#define IDC_STATICLICENSE               1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        173
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\btoolbar.cpp ===
#include "precomp.h"

#include "rsop.h"
#include <comdef.h>
#include <tchar.h>
#include "btoolbar.h"

static INT_PTR CALLBACK editBToolbarRSoPProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


///////////////////////////////////////////////////////////
DWORD InitToolbarDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    DWORD dwRet = 0;
    BOOL bDelete = false, 
         bBkgnd  = false;
    __try
    {
        // First go through all PS objects and look for deleteExistingToolbarButtons
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();

            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                // deleteExistingToolbarButtons field
                _variant_t vtValue;
                if (!bDelete)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"deleteExistingToolbarButtons", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        if ((bool)vtValue)
                            CheckDlgButton(hDlg, IDC_DELETEBTOOLBARS, BST_CHECKED);

                        bDelete = true;
                    }
                }

                // toolbarBackgroundBitmap field
                _bstr_t bstrValue;
                if (!bBkgnd)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"toolbarBackgroundBitmapPath", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        bstrValue = vtValue;
                        BOOL bChecked = (bstrValue.length() > 0);
                        SetDlgItemTextTriState(hDlg, IDE_TOOLBARBMP, IDC_BG_CUSTOM, (LPTSTR)bstrValue, bChecked);
                        bBkgnd = true;
                    }
                }

                // no need to process other GPOs since enabled properties have been found
                if (bBkgnd && bDelete)
                    break; 
            }
        }
        EnableDlgItem2(hDlg, IDC_DELETEBTOOLBARS, FALSE);


        // Now go through all Toolbar objects and populate the list box
        bstrClass = L"RSOP_IEToolbarButton";
        CPSObjData **paTBObj = NULL;
        long nTBObjects = 0;
        hr = pDRD->GetArrayOfPSObjects(bstrClass, L"rsopPrecedence",
                                        &paTBObj, &nTBObjects);
        if (SUCCEEDED(hr))
        {
            HWND hwndList = GetDlgItem(hDlg, IDC_BTOOLBARLIST);
            ListBox_ResetContent(hwndList);

            PBTOOLBAR paBToolbar = (PBTOOLBAR)CoTaskMemAlloc(sizeof(BTOOLBAR) * MAX_BTOOLBARS);
            if (paBToolbar != NULL)
            {
                ZeroMemory(paBToolbar, sizeof(BTOOLBAR) * MAX_BTOOLBARS);

                // For each button returned from any GPO
                long nObj;
                PBTOOLBAR pBToolbar;
                for (nObj = 0, pBToolbar = paBToolbar; nObj < nTBObjects;
                    nObj++, pBToolbar++)
                {
                    _bstr_t bstrGPOName = L" (";
                    bstrGPOName += pDRD->GetGPONameFromPSAssociation(paTBObj[nObj]->pObj,L"rsopPrecedence") + L")";

                    // caption field
                    _variant_t vtValue;
                    hr = paTBObj[nObj]->pObj->Get(L"caption", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        _bstr_t bstrValue = vtValue;
                        _bstr_t bstrEntry = bstrValue + bstrGPOName;

                        StrCpy(pBToolbar->szCaption, (LPCTSTR)bstrValue);

                        // iconPath field
                        hr = paTBObj[nObj]->pObj->Get(L"iconPath", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            bstrValue = vtValue;
                            StrCpy(pBToolbar->szIcon, (LPCTSTR)bstrValue);
                        }

                        // actionPath field
                        hr = paTBObj[nObj]->pObj->Get(L"actionPath", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            bstrValue = vtValue;
                            StrCpy(pBToolbar->szAction, (LPCTSTR)bstrValue);
                        }

                        // hotIconPath field
                        hr = paTBObj[nObj]->pObj->Get(L"hotIconPath", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            bstrValue = vtValue;
                            StrCpy(pBToolbar->szHotIcon, (LPCTSTR)bstrValue);
                        }

                        // showOnToolbarByDefault field
                        hr = paTBObj[nObj]->pObj->Get(L"showOnToolbarByDefault", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                            pBToolbar->fShow = (bool)vtValue ? TRUE : FALSE;

                        int nItem = ListBox_AddString(hwndList, (LPCTSTR)bstrEntry);
                        ListBox_SetItemData(hwndList, (WPARAM)nItem, (LPARAM)pBToolbar);
                    }
                }

                dwRet = nObj;

                PBTOOLBAR paOldBToolbar = (PBTOOLBAR)SetWindowLongPtr(hwndList, GWLP_USERDATA, (LONG_PTR)paBToolbar);

                // delete previous allocation(mainly for profile manager)
                if (paOldBToolbar != NULL)
                    CoTaskMemFree(paOldBToolbar);
            }

            CoTaskMemFree(paTBObj);
        }
    }
    __except(TRUE)
    {
    }

    return dwRet;
}

/////////////////////////////////////////////////////////////////////
HRESULT InitBToolbarPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

                // deleteExistingToolbarButtons field
                BOOL bDeleteExisting = FALSE;
                _variant_t vtValue;
                hr = paPSObj[nObj]->pObj->Get(L"deleteExistingToolbarButtons", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    bDeleteExisting = (bool)vtValue ? TRUE : FALSE;

                // toolbarButtons field
                long nTBCount = 0;
                hr = paPSObj[nObj]->pObj->Get(L"toolbarButtons", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    nTBCount = vtValue;

                _bstr_t bstrSetting;
                if (bDeleteExisting || nTBCount > 0)
                {
                    TCHAR szTemp[MAX_PATH];

                    if (bDeleteExisting)
                        LoadString(g_hInstance, IDS_BTOOLBAR_DEL_SETTING, szTemp, countof(szTemp));
                    else
                        LoadString(g_hInstance, IDS_BTOOLBAR_SETTING, szTemp, countof(szTemp));

                    TCHAR szSetting[MAX_PATH];
                    wnsprintf(szSetting, countof(szSetting), szTemp, nTBCount);
                    bstrSetting = szSetting;
                }
                else
                    bstrSetting = GetDisabledString();

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

///////////////////////////////////////////////////////////
INT_PTR CALLBACK BToolbarsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
    TCHAR szToolbarBmp[MAX_PATH];
    TCHAR szWorkDir[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    BOOL  fToolbarBmp;
    LPVOID lpVoid;
    INT iBackground;

    switch( msg )
    {
    case WM_SETFONT:
        //a change to mmc requires us to do this logic for all our property pages that use common controls
        INITCOMMONCONTROLSEX iccx;
        iccx.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccx.dwICC = ICC_ANIMATE_CLASS  | ICC_BAR_CLASSES  | ICC_LISTVIEW_CLASSES  |ICC_TREEVIEW_CLASSES;
        InitCommonControlsEx(&iccx);
        break;

    case WM_INITDIALOG:
        SetPropSheetCookie(hDlg, lParam);

// ---- Toolbar background
        EnableDBCSChars(hDlg, IDE_TOOLBARBMP);
        Edit_LimitText(GetDlgItem(hDlg, IDE_TOOLBARBMP), countof(szToolbarBmp) - 1);

// ---- Toolbar bitmaps


// ---- Toolbar buttons
        EnableDBCSChars(hDlg, IDC_BTOOLBARLIST);

        // find out if this dlg is in RSoP mode
        psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        if (psCookie->pCS->IsRSoP())
        {
            TCHAR szView[64];
            LoadString(g_hInstance, IDS_VIEW, szView, countof(szView));
            SetDlgItemText(hDlg, IDC_EDITBTOOLBAR, szView);

            EnableDlgItem2(hDlg, IDC_ADDBTOOLBAR, FALSE);
            EnableDlgItem2(hDlg, IDC_REMOVEBTOOLBAR, FALSE);

            EnableDlgItem2(hDlg, IDC_BGIE6, FALSE);
            EnableDlgItem2(hDlg, IDC_BG_CUSTOM, FALSE);
            EnableDlgItem2(hDlg, IDC_BROWSETBB, FALSE);
            EnableDlgItem2(hDlg, IDE_TOOLBARBMP, FALSE);
            EnableDlgItem2(hDlg, IDC_BTOOLBARLIST, FALSE);

            EnableDlgItem2(hDlg, IDE_TOOLBARBMP, FALSE);

            
            CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
            if (pDRD)
            {
                if (0 == InitToolbarDlgInRSoPMode(hDlg, pDRD))
                    EnableDlgItem2(hDlg, IDC_EDITBTOOLBAR, FALSE);
                else
                    ListBox_SetCurSel(GetDlgItem(hDlg, IDC_BTOOLBARLIST), (WPARAM)0);
            }
        }
        else
        {
            if (0 == BToolbar_Init(GetDlgItem(hDlg, IDC_BTOOLBARLIST), GetInsFile(hDlg), NULL, NULL))
            {
                EnsureDialogFocus(hDlg, IDC_REMOVEBTOOLBAR, IDC_ADDBTOOLBAR);
                EnsureDialogFocus(hDlg, IDC_EDITBTOOLBAR, IDC_ADDBTOOLBAR);
                EnableDlgItem2(hDlg, IDC_EDITBTOOLBAR, FALSE);
                EnableDlgItem2(hDlg, IDC_REMOVEBTOOLBAR, FALSE);
            }
            else
                ListBox_SetCurSel(GetDlgItem(hDlg, IDC_BTOOLBARLIST), (WPARAM)0);

            ReadBoolAndCheckButton(IS_BTOOLBARS, IK_BTDELETE, FALSE, GetInsFile(hDlg), hDlg, IDC_DELETEBTOOLBARS);

            // ---- Toolbar background -------------------------------------------------------------------------
            InsGetString(IS_BRANDING, TOOLBAR_BMP, szToolbarBmp, countof(szToolbarBmp), GetInsFile(hDlg), NULL, &fToolbarBmp);

            SetDlgItemTextTriState(hDlg, IDE_TOOLBARBMP, IDC_BG_CUSTOM, szToolbarBmp, fToolbarBmp);
            CheckDlgButton(hDlg, IDC_BGIE6, fToolbarBmp ? BST_UNCHECKED : BST_CHECKED );
            EnableDlgItem2(hDlg, IDC_BROWSETBB, fToolbarBmp);
        }
        break;

    case WM_DESTROY:
    {
        if (psCookie->pCS->IsRSoP())
            DestroyDlgRSoPData(hDlg);

        HWND hwndList = GetDlgItem(hDlg, IDC_BTOOLBARLIST);
        PBTOOLBAR paBToolbar = (PBTOOLBAR)GetWindowLongPtr(hwndList, GWLP_USERDATA);
        if (NULL != paBToolbar)
            CoTaskMemFree(paBToolbar);
        break;
    }

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_ADDBTOOLBAR:
            BToolbar_Edit(GetDlgItem(hDlg, IDC_BTOOLBARLIST), TRUE);
            break;

        case IDC_REMOVEBTOOLBAR:
            BToolbar_Remove(GetDlgItem(hDlg, IDC_BTOOLBARLIST));
            break;

        case IDC_EDITBTOOLBAR:
        {
            HWND hwndList = GetDlgItem(hDlg, IDC_BTOOLBARLIST);
            if (psCookie->pCS->IsRSoP())
            {
                int i = ListBox_GetCurSel(hwndList);
                PBTOOLBAR pBToolbar = (PBTOOLBAR)ListBox_GetItemData(hwndList, (WPARAM)i);
                if (pBToolbar != NULL)
                {
                    DialogBoxParam( g_hUIInstance, MAKEINTRESOURCE(IDD_BTOOLBARPOPUP),
                        GetParent(hwndList), editBToolbarRSoPProc, (LPARAM)pBToolbar );
                }
            }
            else
                BToolbar_Edit(hwndList, FALSE);
            break;
        }

// ---- Toolbar background ---------------------------------------------------------------
        case IDC_BGIE6:
        case IDC_BG_CUSTOM:
            fToolbarBmp = IsDlgButtonChecked(hDlg,IDC_BG_CUSTOM);
            EnableDlgItem2(hDlg, IDE_TOOLBARBMP,     fToolbarBmp);
            EnableDlgItem2(hDlg, IDC_BROWSETBB,      fToolbarBmp);
            break;

        case IDC_BROWSETBB:
            GetDlgItemText(hDlg, IDE_TOOLBARBMP, szToolbarBmp, countof(szToolbarBmp));
            if (BrowseForFile(hDlg, szToolbarBmp, countof(szToolbarBmp), GFN_BMP))
                SetDlgItemText(hDlg, IDE_TOOLBARBMP, szToolbarBmp);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:   // F1
        ShowHelpTopic(hDlg);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        TCHAR szMsgTitle[1024];
        TCHAR szMsgText[1024];
        int nStatus;

        
        case PSN_HELP:
            ShowHelpTopic(hDlg);
            break;

        case PSN_APPLY:
            if (psCookie->pCS->IsRSoP())
            {
                // On OK or Apply in RSoP mode, just free up memory for toolbar array - no
                // longer needed.
                HWND hwndList = GetDlgItem(hDlg, IDC_BTOOLBARLIST);
                if ((lpVoid = (LPVOID)GetWindowLongPtr(hwndList, GWLP_USERDATA)) != NULL)
                {
                    CoTaskMemFree(lpVoid);
                    SetWindowLongPtr(hwndList, GWLP_USERDATA, 0);
                }
                return FALSE;
            }
            else
            {
// ---- Toolbar background -------------------------------------------------------------------------
                iBackground = IsDlgButtonChecked(hDlg, IDC_BGIE6) ? 0 : 2;

                fToolbarBmp = GetDlgItemTextTriState(hDlg, IDE_TOOLBARBMP, IDC_BG_CUSTOM, szToolbarBmp, countof(szToolbarBmp));
                if ((iBackground==2) &&  !IsBitmapFileValid(hDlg, IDE_TOOLBARBMP, szToolbarBmp, NULL, 0, 0, 0, 0))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                IsTriStateValid(hDlg, IDE_TOOLBARBMP, IDC_BG_CUSTOM, &nStatus, 
                            res2Str(IDS_QUERY_CLEARSETTING, szMsgText, countof(szMsgText)),
                            res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)));
            
                if (nStatus == TS_CHECK_ERROR || !AcquireWriteCriticalSection(hDlg))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    break;
                }

                // ---- Toolbar buttons ----------------------------------------------------------------------------

                CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\TOOLBMP"), szWorkDir);

                // BUGBUG: <oliverl> revisit this in IE6 when we have server-side file

                // delete the old bitmap file
                InsGetString(IS_BRANDING, TOOLBAR_BMP, szTemp, countof(szTemp), GetInsFile(hDlg));
                if (*szTemp)
                    DeleteFileInDir(szTemp, szWorkDir);

                // copy the new bitmap file
                if (fToolbarBmp  &&  *szToolbarBmp)
                    CopyFileToDir(szToolbarBmp, szWorkDir);

                if (PathIsDirectoryEmpty(szWorkDir))
                    PathRemovePath(szWorkDir);

                InsWriteString(IS_BRANDING, TOOLBAR_BMP, szToolbarBmp, GetInsFile(hDlg), 
                    fToolbarBmp, NULL, INSIO_TRISTATE);

                CheckButtonAndWriteBool(hDlg, IDC_DELETEBTOOLBARS, IS_BTOOLBARS, IK_BTDELETE, GetInsFile(hDlg));

                CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\BTOOLBAR"), szWorkDir);

                BToolbar_Save(GetDlgItem(hDlg, IDC_BTOOLBARLIST), GetInsFile(hDlg), szWorkDir);

                SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
            }
            break;

        case PSN_QUERYCANCEL:
            // user canceled, need to free up memory for toolbar array

            if ((lpVoid = (LPVOID)GetWindowLongPtr(GetDlgItem(hDlg, IDC_BTOOLBARLIST), GWLP_USERDATA)) != NULL)
            {
                CoTaskMemFree(lpVoid);
                SetWindowLongPtr(GetDlgItem(hDlg, IDC_BTOOLBARLIST), GWLP_USERDATA, 0);
            }
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////
HRESULT InitToolbarBmpPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    return InitGenericPrecedencePage(pDRD, hwndList, L"toolbarBackgroundBitmapPath");
}

///////////////////////////////////////////////////////////
static INT_PTR CALLBACK editBToolbarRSoPProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PBTOOLBAR pBToolbar;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pBToolbar = (PBTOOLBAR)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pBToolbar);
        EnableDBCSChars(hDlg, IDE_BTCAPTION);
        EnableDBCSChars(hDlg, IDE_BTACTION);
        EnableDBCSChars(hDlg, IDE_BTICON);
        EnableDBCSChars(hDlg, IDE_BTHOTICON);

        Edit_LimitText(GetDlgItem(hDlg, IDE_BTCAPTION), MAX_BTOOLBAR_TEXT_LENGTH);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BTACTION), _MAX_FNAME);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BTICON), _MAX_FNAME);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BTHOTICON), _MAX_FNAME);

        SetDlgItemText(hDlg, IDE_BTCAPTION, pBToolbar->szCaption);
        SetDlgItemText(hDlg, IDE_BTACTION, pBToolbar->szAction);
        SetDlgItemText(hDlg, IDE_BTICON, pBToolbar->szIcon);
        SetDlgItemText(hDlg, IDE_BTHOTICON, pBToolbar->szHotIcon);
        CheckDlgButton(hDlg, IDC_BUTTONSTATE,
            pBToolbar->fShow ? BST_CHECKED : BST_UNCHECKED);

        EnableDlgItem2(hDlg, IDE_BTCAPTION, FALSE);
        EnableDlgItem2(hDlg, IDE_BTACTION, FALSE);
        EnableDlgItem2(hDlg, IDE_BTICON, FALSE);
        EnableDlgItem2(hDlg, IDE_BTHOTICON, FALSE);
        EnableDlgItem2(hDlg, IDC_BROWSEBTACTION, FALSE);
        EnableDlgItem2(hDlg, IDC_BROWSEBTICO, FALSE);
        EnableDlgItem2(hDlg, IDC_BROWSEBTHOTICO, FALSE);
        EnableDlgItem2(hDlg, IDC_BUTTONSTATE, FALSE);
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDCANCEL:
                EndDialog( hDlg, IDCANCEL );
                break;
            case IDHELP:
                ShowHelpTopic(hDlg);
            case IDOK:
                EndDialog( hDlg, IDOK );
                break;
            }
            break;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\animbmp.cpp ===
#include "precomp.h"

#include <comdef.h>
#include "rsop.h"

///////////////////////////////////////////////////////////
void InitAnimBmpDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
	__try
	{
		_bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
		HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass);
		if (SUCCEEDED(hr))
		{
			CPSObjData **paPSObj = pDRD->GetPSObjArray();
			long nPSObjects = pDRD->GetPSObjCount();

			BOOL bBrandAnimHandled = FALSE;
			for (long nObj = 0; nObj < nPSObjects; nObj++)
			{
				// customizeAnimatedBitmaps field
				if (!bBrandAnimHandled)
				{
					_variant_t vtValue;
					hr = paPSObj[nObj]->pObj->Get(L"customizeAnimatedBitmaps", 0, &vtValue, NULL, NULL);
					BOOL fBrandAnim = FALSE;
					if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					{
						fBrandAnim = vtValue.boolVal ? TRUE : FALSE;
						bBrandAnimHandled = TRUE;
					}

					if (fBrandAnim)
					{
						CheckDlgButton(hDlg, IDC_ANIMBITMAP, BST_CHECKED);

						// smallAnimatedBitmapPath field
						hr = paPSObj[nObj]->pObj->Get(L"smallAnimatedBitmapPath", 0, &vtValue, NULL, NULL);
						if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
						{
							_bstr_t bstrVal = vtValue;
							SetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, (LPCTSTR)bstrVal);
						}

						// largeAnimatedBitmapPath field
						hr = paPSObj[nObj]->pObj->Get(L"largeAnimatedBitmapPath", 0, &vtValue, NULL, NULL);
						if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
						{
							_bstr_t bstrVal = vtValue;
							SetDlgItemText(hDlg, IDE_BIGANIMBITMAP, (LPCTSTR)bstrVal);
						}
					}
				}

				// no need to process other GPOs since enabled properties have been found
				if (bBrandAnimHandled)
					break;
			}
		}
	}
	__except(TRUE)
	{
	}
}

/////////////////////////////////////////////////////////////////////
HRESULT InitSmallBmpPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
	return InitGenericPrecedencePage(pDRD, hwndList, L"smallAnimatedBitmapPath");
}

/////////////////////////////////////////////////////////////////////
HRESULT InitLargeBmpPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
	return InitGenericPrecedencePage(pDRD, hwndList, L"largeAnimatedBitmapPath");
}

///////////////////////////////////////////////////////////
INT_PTR CALLBACK AnimBmpDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
	LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    TCHAR szLargeBmp[MAX_PATH];
    TCHAR szSmallBmp[MAX_PATH];
    TCHAR szWorkDir[MAX_PATH];
    BOOL  fBrandAnim;
    int   nStatus;

    switch(msg)
    {
    case WM_SETFONT:
        //a change to mmc requires us to do this logic for all our property pages that use common controls
        INITCOMMONCONTROLSEX iccx;
        iccx.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccx.dwICC = ICC_ANIMATE_CLASS  | ICC_BAR_CLASSES  | ICC_LISTVIEW_CLASSES  |ICC_TREEVIEW_CLASSES;
        InitCommonControlsEx(&iccx);
        break;

    case WM_INITDIALOG:
        SetPropSheetCookie(hDlg, lParam);

        EnableDBCSChars(hDlg, IDE_SMALLANIMBITMAP);
        EnableDBCSChars(hDlg, IDE_BIGANIMBITMAP);

		// find out if this dlg is in RSoP mode
		psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
		if (psCookie->pCS->IsRSoP())
		{
			EnableDlgItem2(hDlg, IDC_ANIMBITMAP, FALSE);
			EnableDlgItem2(hDlg, IDC_BROWSEBIG, FALSE);
			EnableDlgItem2(hDlg, IDE_BIGANIMBITMAP, FALSE);
			EnableDlgItem2(hDlg, IDC_BROWSESMALL, FALSE);
			EnableDlgItem2(hDlg, IDE_SMALLANIMBITMAP, FALSE);

			CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
			InitAnimBmpDlgInRSoPMode(hDlg, pDRD);
		}
		else
		{
			Edit_LimitText(GetDlgItem(hDlg, IDE_SMALLANIMBITMAP), countof(szSmallBmp) - 1);
			Edit_LimitText(GetDlgItem(hDlg, IDE_BIGANIMBITMAP), countof(szLargeBmp) - 1);
		}
        break;

	case WM_DESTROY:
		if (psCookie->pCS->IsRSoP())
			DestroyDlgRSoPData(hDlg);
		break;

    case WM_COMMAND:
        if (BN_CLICKED != GET_WM_COMMAND_CMD(wParam, lParam))
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_BROWSEBIG:
                GetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szLargeBmp, countof(szLargeBmp));
                if(BrowseForFile(hDlg, szLargeBmp, countof(szLargeBmp), GFN_BMP))
                    SetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szLargeBmp);
                break;

            case IDC_BROWSESMALL:
                GetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmallBmp, countof(szSmallBmp));
                if(BrowseForFile(hDlg, szSmallBmp, countof(szSmallBmp), GFN_BMP))
                    SetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmallBmp);
                break;

            case IDC_ANIMBITMAP:
                fBrandAnim = (IsDlgButtonChecked(hDlg, IDC_ANIMBITMAP) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_BIGANIMBITMAP, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BROWSEBIG, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BIGANIMBITMAP_TXT, fBrandAnim);
                EnableDlgItem2(hDlg, IDE_SMALLANIMBITMAP, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BROWSESMALL, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_SMALLANIMBITMAP_TXT, fBrandAnim);
                break;

            default:
                return FALSE;
        }
        break;

    case WM_HELP:   // F1
        ShowHelpTopic(hDlg);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
            TCHAR szMsgTitle[1024];
            TCHAR szMsgText[1024];
            
            case PSN_HELP:
                ShowHelpTopic(hDlg);
                break;

            case PSN_SETACTIVE:
				// don't do any of this stuff in RSoP mode
				if (!psCookie->pCS->IsRSoP())
				{
					// load information from ins file
					SetDlgItemTextFromIns(hDlg, IDE_BIGANIMBITMAP, IDC_ANIMBITMAP, IS_ANIMATION,
						TEXT("Big_Path"), GetInsFile(hDlg), NULL, INSIO_TRISTATE);

					SetDlgItemTextFromIns(hDlg, IDE_SMALLANIMBITMAP, IDC_ANIMBITMAP, IS_ANIMATION,
						TEXT("Small_Path"), GetInsFile(hDlg), NULL, INSIO_TRISTATE);

					fBrandAnim = (IsDlgButtonChecked(hDlg, IDC_ANIMBITMAP) == BST_CHECKED);
					EnableDlgItem2(hDlg, IDC_BROWSEBIG, fBrandAnim);
					EnableDlgItem2(hDlg, IDC_BIGANIMBITMAP_TXT, fBrandAnim);
					EnableDlgItem2(hDlg, IDC_BROWSESMALL, fBrandAnim);
					EnableDlgItem2(hDlg, IDC_SMALLANIMBITMAP_TXT, fBrandAnim);
				}
				break;

            case PSN_APPLY:
				if (psCookie->pCS->IsRSoP())
					return FALSE;
				else
				{
					CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\ANIMBMP"), szWorkDir);

					fBrandAnim = (IsDlgButtonChecked(hDlg, IDC_ANIMBITMAP) == BST_CHECKED);
                
					GetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmallBmp, countof(szSmallBmp));
					GetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szLargeBmp, countof(szLargeBmp));

					if (fBrandAnim && (!IsAnimBitmapFileValid(hDlg, IDE_SMALLANIMBITMAP, szSmallBmp, NULL, IDS_TOOBIG22, IDS_TOOSMALL22, 22, 22) ||
						!IsAnimBitmapFileValid(hDlg, IDE_BIGANIMBITMAP, szLargeBmp, NULL, IDS_TOOBIG38, IDS_TOOSMALL38, 38, 38)))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
						break;
					}

					nStatus = TS_CHECK_OK;
					IsTriStateValid(hDlg, IDE_SMALLANIMBITMAP, IDC_ANIMBITMAP, &nStatus,
									res2Str(IDS_QUERY_CLEARSETTING, szMsgText, countof(szMsgText)),
									res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)));
					IsTriStateValid(hDlg, IDE_BIGANIMBITMAP, IDC_ANIMBITMAP, &nStatus,
									szMsgText, szMsgTitle);
                
					if (nStatus == TS_CHECK_ERROR ||                        
						!AcquireWriteCriticalSection(hDlg))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
						break;
					}

					CopyAnimBmp(hDlg, szSmallBmp, szWorkDir, IK_SMALLBITMAP, TEXT("Small_Path"), GetInsFile(hDlg));
					CopyAnimBmp(hDlg, szLargeBmp, szWorkDir, IK_LARGEBITMAP, TEXT("Big_Path"), GetInsFile(hDlg));

					InsWriteBool(IS_ANIMATION, IK_DOANIMATION, fBrandAnim, GetInsFile(hDlg));

					if (PathIsDirectoryEmpty(szWorkDir))
						PathRemovePath(szWorkDir);
                
					SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
				}
				break;

            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\cabsign.cpp ===
#include "precomp.h"
#include <cryptui.h>

static void displaySignHelp();

INT_PTR CALLBACK CabSignProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    TCHAR szDesc[MAX_PATH];
    TCHAR szPVKPath[MAX_PATH];
    TCHAR szSPCPath[MAX_PATH];
    TCHAR szInfoUrl[INTERNET_MAX_URL_LENGTH];
    LPCTSTR pcszInsFile;

    switch( msg )
    {
    case WM_SETFONT:
        //a change to mmc requires us to do this logic for all our property pages that use common controls
        INITCOMMONCONTROLSEX iccx;
        iccx.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccx.dwICC = ICC_ANIMATE_CLASS  | ICC_BAR_CLASSES  | ICC_LISTVIEW_CLASSES  |ICC_TREEVIEW_CLASSES;
        InitCommonControlsEx(&iccx);
        break;

    case WM_INITDIALOG:

        //hide csadd per bug 27041
        ShowWindow(GetDlgItem(hDlg, IDC_CSADD), SW_HIDE);

        pcszInsFile = (LPCTSTR)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pcszInsFile);
        EnableDBCSChars(hDlg, IDE_CSPVK);
        EnableDBCSChars(hDlg, IDE_CSSPC);
        EnableDBCSChars(hDlg, IDE_CSURL);
        EnableDBCSChars(hDlg, IDE_CSDESC);
        GetPrivateProfileString(IS_CABSIGN, IK_PVK, TEXT(""), szPVKPath, ARRAYSIZE(szPVKPath), pcszInsFile);
        GetPrivateProfileString(IS_CABSIGN, IK_SPC, TEXT(""), szSPCPath, ARRAYSIZE(szSPCPath), pcszInsFile);
        GetPrivateProfileString(IS_CABSIGN, IK_CSURL, TEXT(""), szInfoUrl, ARRAYSIZE(szInfoUrl), pcszInsFile);
        GetPrivateProfileString(IS_CABSIGN, IK_NAME, TEXT(""), szDesc, ARRAYSIZE(szDesc), pcszInsFile);
        
        SetDlgItemText(hDlg, IDE_CSPVK, szPVKPath);
        SetDlgItemText(hDlg, IDE_CSSPC, szSPCPath);
        SetDlgItemText(hDlg, IDE_CSURL, szInfoUrl);
        SetDlgItemText(hDlg, IDE_CSDESC, szDesc);
        EnableWindow(GetDlgItem(hDlg, IDC_CSCOMP), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CSCOMP_TXT), FALSE);
        break;

    case WM_COMMAND:
        if (BN_CLICKED != GET_WM_COMMAND_CMD(wParam, lParam))
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_BROWSECSPVK:
            GetDlgItemText( hDlg, IDE_CSPVK, szPVKPath, ARRAYSIZE(szPVKPath));
            if( BrowseForFile( hDlg, szPVKPath, ARRAYSIZE(szPVKPath), GFN_PVK ))
                SetDlgItemText( hDlg, IDE_CSPVK, szPVKPath );
            break;
        case IDC_BROWSECSSPC:
            GetDlgItemText( hDlg, IDE_CSSPC, szSPCPath, ARRAYSIZE(szSPCPath));
            if( BrowseForFile( hDlg, szSPCPath, ARRAYSIZE(szSPCPath), GFN_SPC ))
                SetDlgItemText( hDlg, IDE_CSSPC, szSPCPath );
            break;

        default:
            return FALSE;
        }
        break;
    
    case WM_HELP:
        displaySignHelp();
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_HELP:
            displaySignHelp();
            break;

        case PSN_APPLY:
            pcszInsFile = (LPCTSTR)GetWindowLongPtr(hDlg, DWLP_USER);

            GetDlgItemText(hDlg, IDE_CSPVK, szPVKPath, ARRAYSIZE(szPVKPath));
            GetDlgItemText(hDlg, IDE_CSSPC, szSPCPath, ARRAYSIZE(szSPCPath));
            GetDlgItemText(hDlg, IDE_CSURL, szInfoUrl, ARRAYSIZE(szInfoUrl));
            GetDlgItemText(hDlg, IDE_CSDESC, szDesc, ARRAYSIZE(szDesc));

            if (ISNONNULL(szPVKPath) || ISNONNULL(szSPCPath)
                || ISNONNULL(szInfoUrl) || ISNONNULL(szDesc))
            {
                if (!CheckField(hDlg, IDE_CSSPC, FC_NONNULL | FC_FILE | FC_EXISTS) ||
                    !CheckField(hDlg, IDE_CSPVK, FC_NONNULL | FC_FILE | FC_EXISTS) ||
                    !CheckField(hDlg, IDE_CSDESC, FC_NONNULL) || !CheckField(hDlg, IDE_CSURL, FC_URL))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    break;
                }
            }
            
            WritePrivateProfileString(IS_CABSIGN, IK_PVK, szPVKPath, pcszInsFile);
            WritePrivateProfileString(IS_CABSIGN, IK_SPC, szSPCPath, pcszInsFile);
            WritePrivateProfileString(IS_CABSIGN, IK_CSURL, szInfoUrl, pcszInsFile);
            WritePrivateProfileString(IS_CABSIGN, IK_NAME, szDesc, pcszInsFile);
            break;

        default:
            return FALSE;
        }
        break;
    
    default:
        return FALSE;
    }
    
    return TRUE;
}

static void displaySignHelp()
{
    WCHAR wszHelpTopic[MAX_PATH];
    
    StrCpy(wszHelpTopic, HELP_FILENAME TEXT("::/"));
    StrCat(wszHelpTopic, TEXT("wiz3_9.htm"));
    MMCPropertyHelp((LPOLESTR)wszHelpTopic);
}

void SignCabFile(LPCTSTR pcszFilename, LPCTSTR pcszIns, LPTSTR pszUnsignedFiles)
{
    TCHAR   szPVKPath[MAX_PATH];
    TCHAR   szSPCPath[MAX_PATH];
    TCHAR   szDesc[MAX_PATH];
    TCHAR   szInfoUrl[INTERNET_MAX_URL_LENGTH];
    
    CRYPTUI_WIZ_DIGITAL_SIGN_INFO           signInfo;
    CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO  signCertPvkInfo;
    CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO  signPvkFileInfo;
    CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO  signExtInfo;

    USES_CONVERSION;

    if (GetPrivateProfileString(IS_CABSIGN, IK_PVK, TEXT(""), szPVKPath, ARRAYSIZE(szPVKPath), pcszIns) == 0||
        GetPrivateProfileString(IS_CABSIGN, IK_SPC, TEXT(""), szSPCPath, ARRAYSIZE(szSPCPath), pcszIns) == 0)
        return;

    GetPrivateProfileString(IS_CABSIGN, IK_NAME, TEXT(""), szDesc, ARRAYSIZE(szDesc), pcszIns);
    GetPrivateProfileString(IS_CABSIGN, IK_CSURL, TEXT(""), szInfoUrl, ARRAYSIZE(szInfoUrl), pcszIns);

    ZeroMemory(&signInfo,        sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO));
    ZeroMemory(&signCertPvkInfo, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO));
    ZeroMemory(&signPvkFileInfo, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO));
    ZeroMemory(&signExtInfo,     sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO));

    signPvkFileInfo.dwSize                  = sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO);
    signPvkFileInfo.pwszPvkFileName         = T2W(szPVKPath);
    signPvkFileInfo.pwszProvName            = NULL;
    signPvkFileInfo.dwProvType              = PROV_RSA_FULL;

    signCertPvkInfo.dwSize                  = sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO);
    signCertPvkInfo.pwszSigningCertFileName = T2W(szSPCPath);
    signCertPvkInfo.dwPvkChoice             = CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE;
    signCertPvkInfo.pPvkFileInfo            = &signPvkFileInfo;

    signExtInfo.dwSize                      = sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO);
    signExtInfo.dwAttrFlags                 = 0;
    signExtInfo.pwszDescription             = T2CW(szDesc);
    signExtInfo.pwszMoreInfoLocation        = T2CW(szInfoUrl);
    signExtInfo.pszHashAlg                  = szOID_RSA_MD5;

    signInfo.dwSize                         = sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO);
    signInfo.dwSubjectChoice                = CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE;
    signInfo.pwszFileName                   = T2CW((LPTSTR)pcszFilename);
    signInfo.dwSigningCertChoice            = CRYPTUI_WIZ_DIGITAL_SIGN_PVK;
    signInfo.pSigningCertPvkInfo            = &signCertPvkInfo;
    signInfo.dwAdditionalCertChoice         = CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT;
    signInfo.pSignExtInfo                   = &signExtInfo;

    if (!CryptUIWizDigitalSign(CRYPTUI_WIZ_NO_UI, NULL, NULL, &signInfo, NULL))
    {
        if (pszUnsignedFiles != NULL)
        {
            StrCat(pszUnsignedFiles, TEXT("\r\n"));
            StrCat(pszUnsignedFiles, pcszFilename);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\channels.cpp ===
#include "precomp.h"

#include "rsop.h"
#include "channels.h"

#include <tchar.h>

static BOOL CALLBACK addEditChannelRSoPProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


/////////////////////////////////////////////////////////////////////
DWORD AddItemsToList(HWND hwndList, CDlgRSoPData *pDRD, BSTR bstrTempClass,
					 BOOL bCategory, PCHANNEL paChannels)
{
	DWORD dwRet = 0;
	__try
	{
		_bstr_t bstrClass = bstrTempClass;
		CPSObjData **paObj = NULL;
		long nObjects = 0;
		HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass, L"rsopPrecedence",
												&paObj, &nObjects);
		if (SUCCEEDED(hr))
		{
			// For each button returned from any GPO
			long nObj;
			PCHANNEL pChan;
			for (nObj = 0, pChan = paChannels; nObj < nObjects; nObj++, pChan++)
			{
				_bstr_t bstrGPOName = L" (";
				bstrGPOName += pDRD->GetGPONameFromPSAssociation(paObj[nObj]->pObj,
																L"rsopPrecedence") +
								L")";


				pChan->fCategory = bCategory;

				// title field
				_variant_t vtValue;
				hr = paObj[nObj]->pObj->Get(L"title", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
				{
					_bstr_t bstrValue = vtValue;
					_bstr_t bstrEntry = bstrValue + bstrGPOName;

					StrCpy(pChan->szTitle, (LPCTSTR)bstrValue);

					if (bCategory)
					{
						// categoryHTMLPage field
						hr = paObj[nObj]->pObj->Get(L"categoryHTMLPage", 0, &vtValue, NULL, NULL);
						if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
						{
							bstrValue = vtValue;
							StrCpy(pChan->szWebUrl, (LPCTSTR)bstrValue);
						}
					}
					else
					{
						// channelDefinitionURL field
						hr = paObj[nObj]->pObj->Get(L"channelDefinitionURL", 0, &vtValue, NULL, NULL);
						if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
						{
							bstrValue = vtValue;
							StrCpy(pChan->szWebUrl, (LPCTSTR)bstrValue);
						}

						// channelDefinitionFilePath field
						hr = paObj[nObj]->pObj->Get(L"channelDefinitionFilePath", 0, &vtValue, NULL, NULL);
						if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
						{
							bstrValue = vtValue;
							StrCpy(pChan->szPreUrlPath, (LPCTSTR)bstrValue);
						}

						// makeAvailableOffline
						hr = paObj[nObj]->pObj->Get(L"makeAvailableOffline", 0, &vtValue, NULL, NULL);
						if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
							pChan->fOffline = (bool)vtValue ? TRUE : FALSE;

					}

					// iconPath field
					hr = paObj[nObj]->pObj->Get(L"iconPath", 0, &vtValue, NULL, NULL);
					if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					{
						bstrValue = vtValue;
						StrCpy(pChan->szIcon, (LPCTSTR)bstrValue);
					}

					// narrowImagePath field
					hr = paObj[nObj]->pObj->Get(L"narrowImagePath", 0, &vtValue, NULL, NULL);
					if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					{
						bstrValue = vtValue;
						StrCpy(pChan->szLogo, (LPCTSTR)bstrValue);
					}

					int nItem = (int)SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)((LPCTSTR)bstrEntry));
					SendMessage(hwndList, LB_SETITEMDATA, (WPARAM)nItem, (LPARAM)pChan);
				}
			}

			dwRet = nObj;

			CoTaskMemFree(paObj);
		}
	}
	__except(TRUE)
	{
	}
	return dwRet;
}

/////////////////////////////////////////////////////////////////////
DWORD InitChannelsDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
	DWORD dwRet = 0;
	__try
	{
		// First go through all PS objects and look for channels data
		_bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
		HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass);
		if (SUCCEEDED(hr))
		{
			CPSObjData **paPSObj = pDRD->GetPSObjArray();
			long nPSObjects = pDRD->GetPSObjCount();

			BOOL bDeleteHandled = FALSE;
			BOOL bEnableHandled = FALSE;
			for (long nObj = 0; nObj < nPSObjects; nObj++)
			{
				// deleteExistingChannels field
				_variant_t vtValue;
				if (!bDeleteHandled)
				{
					hr = paPSObj[nObj]->pObj->Get(L"deleteExistingChannels", 0, &vtValue, NULL, NULL);
					if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					{
						if ((bool)vtValue)
							CheckDlgButton(hDlg, IDC_DELETECHANNELS, BST_CHECKED);
						bDeleteHandled = TRUE;
					}
				}

				// enableDesktopChannelBarByDefault field
				if (!bEnableHandled)
				{
					hr = paPSObj[nObj]->pObj->Get(L"enableDesktopChannelBarByDefault", 0, &vtValue, NULL, NULL);
					if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					{
						if ((bool)vtValue)
							CheckDlgButton(hDlg, IDC_CHANBARON, BST_CHECKED);
						bEnableHandled = TRUE;
					}
				}

				// no need to process other GPOs since enabled properties have been found
				if (bDeleteHandled && bEnableHandled)
					break;
			}
		}

		EnableDlgItem2(hDlg, IDC_DELETECHANNELS, FALSE);
		EnableDlgItem2(hDlg, IDC_CHANBARON, FALSE);
		EnableDlgItem2(hDlg, IDC_DELETELINKS, FALSE);


		// Now go through all Channel & Category objects and populate the list
		HWND hwndList = GetDlgItem(hDlg, IDC_CHANNELLIST);
		SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_RESETCONTENT, 0, 0);

		PCHANNEL paChannels = (PCHANNEL)CoTaskMemAlloc(sizeof(CHANNEL) * MAX_CHAN);
		if (NULL != paChannels)
		{
			ZeroMemory(paChannels, sizeof(CHANNEL) * MAX_CHAN);
			PCHANNEL paOldChannels = (PCHANNEL)SetWindowLongPtr(hwndList, GWLP_USERDATA, (LONG_PTR)paChannels);

			// delete previous allocation(mainly for profile manager)
			if (paOldChannels != NULL)
				CoTaskMemFree(paOldChannels);

			AddItemsToList(hwndList, pDRD, L"RSOP_IEChannelItem", FALSE, paChannels);
			AddItemsToList(hwndList, pDRD, L"RSOP_IECategoryItem", TRUE, paChannels);
		}

		SendMessage(hwndList, LB_SETCURSEL, (WPARAM)-1, 0);


		EnableDlgItem2(hDlg, IDC_ADDCATEGORY, FALSE);
		EnableDlgItem2(hDlg, IDC_ADDCHANNEL, FALSE);
		EnableDlgItem2(hDlg, IDC_REMOVECHANNEL, FALSE);
		EnableDlgItem2(hDlg, IDC_EDITCHANNEL, FALSE);
		EnableDlgItem2(hDlg, IDC_IMPORTCHAN, FALSE);
	}
	__except(TRUE)
	{
	}
	return dwRet;
}


/////////////////////////////////////////////////////////////////////
HRESULT InitChanDeletePrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
	HRESULT hr = NOERROR;
	__try
	{
		_bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
		hr = pDRD->GetArrayOfPSObjects(bstrClass);
		if (SUCCEEDED(hr))
		{
			CPSObjData **paPSObj = pDRD->GetPSObjArray();
			long nPSObjects = pDRD->GetPSObjCount();
			for (long nObj = 0; nObj < nPSObjects; nObj++)
			{
				_bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

				// deleteExistingChannels field
				BOOL bDelete = FALSE;
				_variant_t vtValue;
				hr = paPSObj[nObj]->pObj->Get(L"deleteExistingChannels", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					bDelete = (bool)vtValue ? TRUE : FALSE;

				_bstr_t bstrSetting;
				if (bDelete)
				{
					TCHAR szTemp[MAX_PATH];
					LoadString(g_hInstance, IDS_DELETE_CHAN_SETTING, szTemp, countof(szTemp));
					bstrSetting = szTemp;
				}
				else
					bstrSetting = GetDisabledString();

				InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
			}
		}
	}
	__except(TRUE)
	{
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT InitChanEnablePrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
	HRESULT hr = NOERROR;
	__try
	{
		_bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
		hr = pDRD->GetArrayOfPSObjects(bstrClass);
		if (SUCCEEDED(hr))
		{
			CPSObjData **paPSObj = pDRD->GetPSObjArray();
			long nPSObjects = pDRD->GetPSObjCount();
			for (long nObj = 0; nObj < nPSObjects; nObj++)
			{
				_bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

				// enableDesktopChannelBarByDefault field
				BOOL bEnable = FALSE;
				_variant_t vtValue;
				hr = paPSObj[nObj]->pObj->Get(L"enableDesktopChannelBarByDefault", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					bEnable = (bool)vtValue ? TRUE : FALSE;

				_bstr_t bstrSetting;
				if (bEnable)
				{
					TCHAR szTemp[MAX_PATH];
					LoadString(g_hInstance, IDS_ENABLE_CHBAR_SETTING, szTemp, countof(szTemp));
					bstrSetting = szTemp;
				}
				else
					bstrSetting = GetDisabledString();

				InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
			}
		}
	}
	__except(TRUE)
	{
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT InitChannelsPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
	HRESULT hr = NOERROR;
	__try
	{
		_bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
		hr = pDRD->GetArrayOfPSObjects(bstrClass);
		if (SUCCEEDED(hr))
		{
			CPSObjData **paPSObj = pDRD->GetPSObjArray();
			long nPSObjects = pDRD->GetPSObjCount();

			for (long nObj = 0; nObj < nPSObjects; nObj++)
			{
				_bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

				// channels field
				long nChan = 0, nCat = 0;
				_variant_t vtValue;
				hr = paPSObj[nObj]->pObj->Get(L"channels", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					nChan = vtValue;

				// categories field
				hr = paPSObj[nObj]->pObj->Get(L"categories", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					nCat = vtValue;

				_bstr_t bstrSetting;
				if (nChan > 0 || nCat > 0)
				{
					TCHAR szTemp[MAX_PATH];

					LoadString(g_hInstance, IDS_CHAN_AND_CAT_SETTING, szTemp, countof(szTemp));

					TCHAR szSetting[MAX_PATH];
					wnsprintf(szSetting, countof(szSetting), szTemp, nChan, nCat);
					bstrSetting = szSetting;
				}
				else
					bstrSetting = GetDisabledString();

				InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
			}
		}
	}
	__except(TRUE)
	{
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////
BOOL CALLBACK addEditChannelRSoPProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
	{
		PCHANNEL pSelCh = (PCHANNEL)lParam;
		if (pSelCh->fCategory)
		{
			EnableDBCSChars(hDlg, IDC_CATEGORYHTML);
			EnableDBCSChars(hDlg, IDE_CATEGORYTITLE);
			SetDlgItemText(hDlg,  IDC_CATEGORYHTML,  pSelCh->szWebUrl);
			SetDlgItemText(hDlg,  IDE_CATEGORYTITLE, pSelCh->szTitle);

			EnableDlgItem2(hDlg, IDC_CATEGORYHTML, FALSE);
			EnableDlgItem2(hDlg, IDE_CATEGORYTITLE, FALSE);
			EnableDlgItem2(hDlg, IDC_BROWSECATHTML, FALSE);
		}
		else
		{
			EnableDBCSChars(hDlg, IDE_CHANNELSRVURL2);
			EnableDBCSChars(hDlg, IDE_CHANNELTITLE2);
			SetDlgItemText(hDlg,  IDE_CHANNELSRVURL2, pSelCh->szWebUrl);
			SetDlgItemText(hDlg,  IDE_CHANNELTITLE2,  pSelCh->szTitle);

			EnableDlgItem2(hDlg, IDE_CHANNELSRVURL2, FALSE);
			EnableDlgItem2(hDlg, IDE_CHANNELTITLE2, FALSE);
			EnableDlgItem2(hDlg, IDC_BROWSECDF2, FALSE);
		}

		EnableDBCSChars(hDlg, IDC_CHANNELBITMAP2);
		EnableDBCSChars(hDlg, IDC_CHANNELICON2);
		SetDlgItemText(hDlg, IDC_CHANNELBITMAP2, pSelCh->szLogo);
		SetDlgItemText(hDlg, IDC_CHANNELICON2, pSelCh->szIcon);

		EnableDlgItem2(hDlg, IDC_CHANNELBITMAP2, FALSE);
		EnableDlgItem2(hDlg, IDC_CHANNELICON2, FALSE);
		EnableDlgItem2(hDlg, IDC_BROWSECHICO2, FALSE);
		EnableDlgItem2(hDlg, IDC_BROWSECHBMP2, FALSE);

		if (!pSelCh->fCategory)
		{
			EnableDBCSChars(hDlg, IDC_CHANNELURL2);
			SetDlgItemText(hDlg,  IDC_CHANNELURL2, pSelCh->szPreUrlPath);

			if (pSelCh->fOffline)
				CheckDlgButton(hDlg, IDC_CHANNELOFFL, BST_CHECKED);

			EnableDlgItem2(hDlg, IDC_CHANNELURL2, FALSE);
			EnableDlgItem2(hDlg, IDC_CHANNELOFFL, FALSE);
		}

		break;
	}

	case WM_COMMAND:
		switch(HIWORD(wParam))
		{
		case BN_CLICKED:
			switch (LOWORD(wParam))
			{
			case IDCANCEL:
				EndDialog( hDlg, IDCANCEL );
				break;
			case IDOK:
				EndDialog( hDlg, IDOK );
				break;
			}
			break;
		}
		break;

	default:
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\compdata.h ===
//
// CComponentData class
//

#include "wbemcli.h"
#include "SComPtr.h"

class CComponentData:
    public IComponentData,
    public IPersistStreamInit,
    public ISnapinHelp,
    public IExtendContextMenu
{
    friend class CDataObject;
    friend class CSnapIn;

protected:
    ULONG                m_cRef;
    HWND		         m_hwndFrame;
    LPCONSOLENAMESPACE   m_pScope;
    LPCONSOLE            m_pConsole;
    HSCOPEITEM           m_hRoot;
    HSCOPEITEM           m_ahChildren[NUM_NAMESPACE_ITEMS];
    LPGPEINFORMATION     m_pGPTInformation;
    LPIEAKMMCCOOKIE      m_lpCookieList;
    BOOL                 m_fOneTimeApply;   // flag on whether to apply GPO once or always
    TCHAR                m_szInsFile[MAX_PATH]; // current path to ins file in current GPO
    HANDLE                  m_hLock;           // handle to our lock file in the GPO

public:
    CComponentData(BOOL bIsRSoP);
    ~CComponentData();


    STDMETHODIMP            SetInsFile();
    LPCTSTR                 GetInsFile() {return m_szInsFile;}
    STDMETHODIMP_(HANDLE)   GetLockHandle();
    STDMETHODIMP            SetLockHandle(HANDLE hLock);
    STDMETHODIMP            SignalPolicyChanged(BOOL bMachine, BOOL bAdd, GUID *pGuidExtension,
                                             GUID *pGuidSnapin);

	//
	// RSoP implementation methods
	//
	BOOL IsRSoP() {return m_bIsRSoP;}
	BSTR GetRSoPNamespace() {return m_bstrRSoPNamespace;}


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Implemented IComponentData methods
    //

    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);
    
    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP            AddMenuItems(LPDATAOBJECT lpDataObject, 
                                LPCONTEXTMENUCALLBACK piCallback, long  *pInsertionAllowed);
    STDMETHODIMP            Command(long lCommandID, LPDATAOBJECT lpDataObject);

    //
    // Implemented IPersistStreamInit interface members
    //

    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);


    //
    // Implemented ISnapinHelp interface members
    //

    STDMETHODIMP         GetHelpTopic(LPOLESTR *lpCompiledHelpFile);

    BOOL IsPlanningMode() { return m_bPlanningMode;}


private:
    HRESULT EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);

    //
    // RSoP implementation methods & variables
    //
    BOOL IsRSoPViewInPreferenceMode();

    BOOL m_bIsRSoP;
    BOOL m_bPlanningMode;

    IRSOPInformation *m_pRSOPInformation;
    BSTR m_bstrRSoPNamespace;
};



//
// ComponentData class factory
//


class CComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CComponentDataCF(BOOL bIsRSoP);
    ~CComponentDataCF();

	BOOL IsRSoP() {return m_bIsRSoP;}


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);

private:
	BOOL m_bIsRSoP;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\cookie.h ===
#ifndef __IEAKSIE_COOKIE_H__
#define __IEAKSIE_COOKIE_H__

// used for passing info to our dlgprocs on a per dlg basis, need to have this because
// we can have multiple windows open at once(concurrency in the same process so no
// globals/static) as well as multiple dialogs open at once(limited info can be stored in
// CSnapIn itself). 

typedef struct _PROPSHEETCOOKIE
{
    CSnapIn * pCS;
    LPRESULTITEM lpResultItem;
} PROPSHEETCOOKIE, *LPPROPSHEETCOOKIE;

#endif //__IEAKSIE_COOKIE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\compdata.cpp ===
#include "precomp.h"

#include <comdef.h>
#include "wbemcli.h"

extern INT_PTR CALLBACK SaveDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern void ExportSettings();
extern GUID g_guidRSoPSnapinExt;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CComponentData::CComponentData(BOOL bIsRSoP):
		m_bIsRSoP(bIsRSoP),
		m_pRSOPInformation(NULL),
		m_bstrRSoPNamespace(NULL)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
    m_hwndFrame = NULL;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_pGPTInformation = NULL;
    m_lpCookieList = NULL;
    m_hLock = INVALID_HANDLE_VALUE;
}

CComponentData::~CComponentData()
{
	if (NULL != m_bstrRSoPNamespace)
		SysFreeString(m_bstrRSoPNamespace);

    DeleteCookieList(m_lpCookieList);

    if (m_pScope != NULL)
    {
        m_pScope->Release();
    }

    if (m_pConsole != NULL)
    {
        m_pConsole->Release();
    }

    if (m_pGPTInformation != NULL)
    {
        m_pGPTInformation->Release();
    }

    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IUnknown)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (LPSNAPINHELP)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CComponentData::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IComponentData)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    HBITMAP bmp32x32;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (LPVOID *)&m_pScope);

    if (FAILED(hr))
        return hr;


    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_IEAKSNAPINEXT_16));
    bmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_IEAKSNAPINEXT_32));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(bmp16x16),
                      reinterpret_cast<LONG_PTR *>(bmp32x32),
                       0, RGB(255, 0, 255));

    lpScopeImage->Release();

    return S_OK;
}

STDMETHODIMP CComponentData::Destroy(VOID)
{
    return S_OK;
}

STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CSnapIn *pSnapIn;


    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CSnapIn(this);

    if (pSnapIn == NULL)
        return E_OUTOFMEMORY;


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI


    return hr;
}

STDMETHODIMP CComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CDataObject *pDataObject;
    LPIEAKDATAOBJECT pIEAKDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private IEAKDataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IIEAKDataObject, (LPVOID *)&pIEAKDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return (hr);
    }

    pIEAKDataObject->SetType(type);
    pIEAKDataObject->SetCookie(cookie);
    pIEAKDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

STDMETHODIMP CComponentData::AddMenuItems(LPDATAOBJECT lpDataObject, 
                                   LPCONTEXTMENUCALLBACK piCallback, long  *pInsertionAllowed)
{
    LPIEAKDATAOBJECT pIEAKDataObject;

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IIEAKDataObject,
        (LPVOID *)&pIEAKDataObject)))
    {
        HRESULT hr = S_OK;
            
        pIEAKDataObject->Release();

        // check insertion point so we don't insert ourselves twice in the result pane

        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            TCHAR szMenuItem[128];
            TCHAR szDescription[256];
            CONTEXTMENUITEM item;

            LoadString(g_hInstance, IDS_CONTEXT_EXPORT, szMenuItem, ARRAYSIZE(szMenuItem));
            LoadString(g_hInstance, IDS_CONTEXT_EXPORT_DESC, szDescription, ARRAYSIZE(szDescription));
            
            item.strName = szMenuItem;
            item.strStatusBarText = szDescription;
            item.lCommandID = IDM_CONTEXTSAVE;
            item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
            item.fFlags = 0;
            item.fSpecialFlags = 0;
            
            hr = piCallback->AddItem(&item);

            // if in RSOP mode, these 2 menu choices aren't allowed
            if (!IsRSoP())
            {
                LoadString(g_hInstance, IDS_CONTEXT_ONCE, szMenuItem, ARRAYSIZE(szMenuItem));
                LoadString(g_hInstance, IDS_CONTEXT_ONCE_DESC, szDescription, ARRAYSIZE(szDescription));
            
                item.strName = szMenuItem;
                item.strStatusBarText = szDescription;
                item.lCommandID = IDM_CONTEXTONCE;
                item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                m_fOneTimeApply = !InsIsKeyEmpty(IS_BRANDING, IK_GPE_ONETIME_GUID, m_szInsFile);
                item.fFlags = m_fOneTimeApply ? MF_CHECKED : MF_UNCHECKED;
                item.fSpecialFlags = 0;
            
                hr = piCallback->AddItem(&item);

                LoadString(g_hInstance, IDS_CONTEXT_RESET, szMenuItem, ARRAYSIZE(szMenuItem));
                LoadString(g_hInstance, IDS_CONTEXT_RESET_DESC, szDescription, ARRAYSIZE(szDescription));
            
                item.strName = szMenuItem;
                item.strStatusBarText = szDescription;
                item.lCommandID = IDM_CONTEXTRESET;
                item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                item.fFlags = PathFileExists(m_szInsFile) ?  MF_ENABLED : MF_GRAYED;
                item.fSpecialFlags = 0;
            
                hr = piCallback->AddItem(&item);
            }
        }
        
        return (hr);
    }

    return S_FALSE;
}


STDMETHODIMP CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
		case MMCN_EXPAND:
			if (TRUE == arg)
			{
				if (IsRSoP())
				{
					if (!m_pRSOPInformation)
					{
						//
						// Query for the IRSOPInformation interface
						//
						lpDataObject->QueryInterface(IID_IRSOPInformation, (LPVOID *)&m_pRSOPInformation);
						if (NULL != m_pRSOPInformation)
						{
                            DWORD dwFlags;
                            if(SUCCEEDED(m_pRSOPInformation->GetFlags(&dwFlags)))
                            {
                                m_bPlanningMode = (dwFlags != RSOP_INFO_FLAG_DIAGNOSTIC_MODE);
                            }
							// 350 is a magic number - reason for the size?
						#define MAX_NAMESPACE_SIZE 350
							LPOLESTR szNamespace = (LPOLESTR) LocalAlloc (LPTR, MAX_NAMESPACE_SIZE * sizeof(TCHAR));
							if (NULL != szNamespace)
							{
								//
								// Retreive the namespace from the main snap-in
								//
								if (S_OK == m_pRSOPInformation->GetNamespace(GPO_SECTION_USER,
																			szNamespace,
																			MAX_NAMESPACE_SIZE))
								{
									m_bstrRSoPNamespace = SysAllocString(szNamespace);
								}
							}
						}
					}

					if (NULL != m_bstrRSoPNamespace)
					{
						hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
					}
				}
				else
				{
					if (NULL == m_pGPTInformation)
						lpDataObject->QueryInterface(IID_IGPEInformation, (LPVOID *)&m_pGPTInformation);

					if (NULL != m_pGPTInformation)
						hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
				}
			}
			break;
        
        case MMCN_REMOVE_CHILDREN:
        {
            //
            // In RSoP, we may get called to refresh the scope pane when the query
            // is re-executed -- if this happens, current nodes will be removed and
            // we must reset all of our cached information.  We reset the relevant
            // information below
            //

            if (IsRSoP() && (m_pRSOPInformation != NULL) )
            {
                m_pRSOPInformation->Release();
                SysFreeString(m_bstrRSoPNamespace);
        
                m_hRoot = NULL;

                m_bstrRSoPNamespace = NULL;
                m_pRSOPInformation = NULL;
            }
        }
        break;

		default:
			break;
    }

    return hr;
}

HRESULT CComponentData::SetInsFile()
{
    if (m_pGPTInformation != NULL)
    {
        m_pGPTInformation->GetFileSysPath(GPO_SECTION_USER, m_szInsFile, ARRAYSIZE(m_szInsFile));
        
        PathAppend(m_szInsFile, IEAK_SUBDIR);
        
        if (!PathFileExists(m_szInsFile))
            PathCreatePath(m_szInsFile);
        
        PathAppend(m_szInsFile, INS_NAME);
    }
    else
    {
        if (!IsRSoP())
        {
            ASSERT(FALSE);
        }
    }

    return S_OK;
}


STDMETHODIMP CComponentData::Command(long lCommandID, LPDATAOBJECT lpDataObject)
{
    LPIEAKDATAOBJECT pIEAKDataObject;
    HANDLE hMutex;

    if (FAILED(lpDataObject->QueryInterface(IID_IIEAKDataObject,
        (LPVOID *)&pIEAKDataObject)))
    {
        return S_FALSE;
    }
    
    pIEAKDataObject->Release();

    // set the ins file
            
    SetInsFile();

    // read in our flag variables
            
    switch (lCommandID)
    {
        case IDM_CONTEXTSAVE:
            // allow only one save at a time
            hMutex = CreateMutex(NULL, TRUE, TEXT("IEAKGPEContextMenu.Mutex"));
            
            if ((hMutex != NULL) && (GetLastError() == ERROR_ALREADY_EXISTS))
            {
                CloseHandle(hMutex);
                SIEErrorMessageBox(NULL, IDS_ERROR_CONTEXTMENU);
            }
            else
            {
                if ((lCommandID == IDM_CONTEXTSAVE) &&
                    (DialogBoxParam(g_hUIInstance, MAKEINTRESOURCE(IDD_SAVEAS), NULL,
                    SaveDlgProc, (LPARAM)m_szInsFile) == 0))
                {
                    if (AcquireWriteCriticalSection(NULL, this, FALSE))
                    {
                        ExportSettings();
                        ReleaseWriteCriticalSection(this, FALSE, FALSE);
                    }
                }
                
                if (hMutex != NULL)
                    CloseHandle(hMutex);
            }
            break;

        case IDM_CONTEXTONCE:
            if (PathFileExists(m_szInsFile))
            {
                SIEErrorMessageBox(NULL, IDS_ERROR_NEEDRESET);
            }
            else if (AcquireWriteCriticalSection(NULL, this, TRUE))
            {
                m_fOneTimeApply = !m_fOneTimeApply;
                if (!m_fOneTimeApply)
                {
                    InsDeleteKey(IS_BRANDING, IK_GPE_ONETIME_GUID, m_szInsFile);
                    m_pScope->DeleteItem(m_ahChildren[ADM_NAMESPACE_ITEM], TRUE);
                }
                else
                {
                    TCHAR szGuid[128];
                    GUID guid;
                    SCOPEDATAITEM item;
                    LPIEAKMMCCOOKIE lpCookie = (LPIEAKMMCCOOKIE)CoTaskMemAlloc(sizeof(IEAKMMCCOOKIE));
                    
                    lpCookie->lpItem =  ULongToPtr(ADM_NAMESPACE_ITEM);
                    lpCookie->lpParentItem = this;
                    lpCookie->pNext = NULL;
                    AddItemToCookieList(&(m_lpCookieList), lpCookie);
                    
                    item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
                    item.displayname = MMC_CALLBACK;
                    item.nImage = 6;
                    item.nOpenImage = 6;
                    item.nState = 0;
                    item.cChildren = g_NameSpace[ADM_NAMESPACE_ITEM].cChildren;
                    item.lParam = (LPARAM)lpCookie;
                    item.relativeID = m_ahChildren[0];
                    
                    m_pScope->InsertItem(&item);
                    m_ahChildren[ADM_NAMESPACE_ITEM] = item.ID;
                    
                    if (CoCreateGuid(&guid) == NOERROR)
                        CoStringFromGUID(guid, szGuid, countof(szGuid));
                    else
                        szGuid[64] = TEXT('\0');
                    
                    InsWriteString(IS_BRANDING, IK_GPE_ONETIME_GUID, szGuid, m_szInsFile);
                }
                InsFlushChanges(m_szInsFile);
                ReleaseWriteCriticalSection(this, TRUE, FALSE);
            }
            break;
            
        case IDM_CONTEXTRESET:
            if ((SIEErrorMessageBox(NULL, IDS_RESET_WARN, MB_SETFOREGROUND | MB_YESNO) == IDYES) &&
                (AcquireWriteCriticalSection(NULL, this, TRUE)))
            {
                TCHAR szFilePath[MAX_PATH];
                LPTSTR pszFile;
                BOOL fPreferenceMode;

                // delete the advanced node if it's showing in preference mode

                fPreferenceMode = !InsIsKeyEmpty(IS_BRANDING, IK_GPE_ONETIME_GUID, m_szInsFile);
                if (fPreferenceMode)
                    m_pScope->DeleteItem(m_ahChildren[ADM_NAMESPACE_ITEM], TRUE);

                StrCpy(szFilePath, m_szInsFile);
                DeleteFile(szFilePath);
                PathRemoveFileSpec(szFilePath);
                pszFile = PathAddBackslash(szFilePath);
                
                // we have the GPO path now, but we can't just do a delnode because we
                // have to leave the cookie file


                StrCpy(pszFile, IEAK_GPE_BRANDING_SUBDIR);
                PathRemovePath(szFilePath, ADN_DEL_UNC_PATHS);
                StrCpy(pszFile, IEAK_GPE_DESKTOP_SUBDIR);
                PathRemovePath(szFilePath, ADN_DEL_UNC_PATHS);
                ReleaseWriteCriticalSection(this, TRUE, !fPreferenceMode, FALSE, TRUE, 
                    &g_guidClientExt, IsRSoP() ? &g_guidRSoPSnapinExt : &g_guidSnapinExt);
            }
            break;
            
        default:
            return E_INVALIDARG;
    }

    return S_OK;
}


STDMETHODIMP CComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DWORD dwIndex;

    if (pItem == NULL)
        return E_POINTER;

    dwIndex = PtrToUlong(((LPIEAKMMCCOOKIE)pItem->lParam)->lpItem);

    if (dwIndex >= NUM_NAMESPACE_ITEMS)
        pItem->displayname = NULL;
    else
        CreateBufandLoadString(g_hInstance, g_NameSpace[dwIndex].iNameID,
            &g_NameSpace[dwIndex].pszName, &pItem->displayname, MAX_DISPLAYNAME_SIZE);

    return S_OK;
}

STDMETHODIMP CComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPIEAKDATAOBJECT pIEAKDataObjectA, pIEAKDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private IEAKDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IIEAKDataObject,
                                            (LPVOID *)&pIEAKDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IIEAKDataObject,
                                            (LPVOID *)&pIEAKDataObjectB)))
    {
        pIEAKDataObjectA->Release();
        return S_FALSE;
    }

    pIEAKDataObjectA->GetCookie(&cookie1);
    pIEAKDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
        hr = S_OK;
    else
    {
        LPIEAKMMCCOOKIE lpCookie1 = (LPIEAKMMCCOOKIE)cookie1;
        LPIEAKMMCCOOKIE lpCookie2 = (LPIEAKMMCCOOKIE)cookie2;
        if ((lpCookie1->lpItem == lpCookie2->lpItem)&& 
            (lpCookie1->lpParentItem == lpCookie2->lpParentItem))
            hr = S_OK;
    }


    pIEAKDataObjectA->Release();
    pIEAKDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (IPersistStreamInit)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_FAIL;
    }

		if (IsRSoP())
			*pClassID = CLSID_IEAKRSoPSnapinExt;
		else
			*pClassID = CLSID_IEAKSnapinExt;

    return S_OK;
}

STDMETHODIMP CComponentData::IsDirty(VOID)
{
    return S_FALSE;
}

STDMETHODIMP CComponentData::Load(IStream *pStm)
{
    UNREFERENCED_PARAMETER(pStm);

    return S_OK;
}


STDMETHODIMP CComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    UNREFERENCED_PARAMETER(pStm);
    UNREFERENCED_PARAMETER(fClearDirty);

    return S_OK;
}


STDMETHODIMP CComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DWORD dwSize = 0;


    if (pcbSize == NULL)
    {
        return E_FAIL;
    }

    ULISet32(*pcbSize, dwSize);

    return S_OK;
}

STDMETHODIMP CComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (ISnapinHelp)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    static TCHAR s_szHelpPath[MAX_PATH] = TEXT("");

    USES_CONVERSION;

    if (lpCompiledHelpFile == NULL)        
        return E_POINTER;    
    
    if (ISNULL(s_szHelpPath))
    {
        if (0 == GetWindowsDirectory(s_szHelpPath, countof(s_szHelpPath)))
            return E_UNEXPECTED;
        PathAppend(s_szHelpPath, TEXT("Help\\") HELP_FILENAME);

        ASSERT(PathFileExists(s_szHelpPath));
    }
    
    if ((*lpCompiledHelpFile = (LPOLESTR)CoTaskMemAlloc((StrLen(s_szHelpPath)+1) * sizeof(WCHAR))) == NULL)
        return E_OUTOFMEMORY;

    StrCpyW(*lpCompiledHelpFile, T2OLE(s_szHelpPath));

    return S_OK;
}
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CComponentData object implementation (Internal functions)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    SCOPEDATAITEM item;
    HRESULT hr;
    DWORD dwIndex, i;
    BOOL fShowAdv = FALSE;

    UNREFERENCED_PARAMETER(lpDataObject);

    if (m_hRoot == NULL)
        m_hRoot = hParent;


    if (m_hRoot == hParent)
    {
        LPIEAKMMCCOOKIE lpCookie = (LPIEAKMMCCOOKIE)CoTaskMemAlloc(sizeof(IEAKMMCCOOKIE));
        
        lpCookie->lpItem =  0;
        lpCookie->lpParentItem = this;
        lpCookie->pNext = NULL;
        AddItemToCookieList(&m_lpCookieList, lpCookie);

        item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
        item.displayname = MMC_CALLBACK;
        item.nImage = 0;
        item.nOpenImage = 0;
        item.nState = 0;
        item.cChildren = g_NameSpace[0].cChildren;
        item.lParam = (LPARAM)lpCookie;
        item.relativeID =  hParent;

        m_pScope->InsertItem (&item);
        m_ahChildren[0] = item.ID;

        return S_OK;
    }
    else
    {
        item.mask = SDI_PARAM;
        item.ID = hParent;

        hr = m_pScope->GetItem (&item);

        if (FAILED(hr))
            return hr;

        dwIndex = PtrToUlong(((LPIEAKMMCCOOKIE)item.lParam)->lpItem);
    }

    if (m_pGPTInformation != NULL)
    {
        TCHAR szInsFile[MAX_PATH];

        m_pGPTInformation->GetFileSysPath(GPO_SECTION_USER, szInsFile, ARRAYSIZE(szInsFile));
        
        PathAppend(szInsFile, IEAK_SUBDIR TEXT("\\") INS_NAME);
        fShowAdv = !InsIsKeyEmpty(IS_BRANDING, IK_GPE_ONETIME_GUID, szInsFile);
    }
	else if (m_bIsRSoP)
	{
		if (g_NameSpace[1].dwParent == dwIndex)
			fShowAdv = IsRSoPViewInPreferenceMode();
	}

    // start with 1 so we don't reinsert the top level root node

    for (i = 1; i < NUM_NAMESPACE_ITEMS; i++)
    {
        if ((g_NameSpace[i].dwParent == dwIndex) && 
            (fShowAdv || (i != ADM_NAMESPACE_ITEM)))
        {
            LPIEAKMMCCOOKIE lpCookie = (LPIEAKMMCCOOKIE)CoTaskMemAlloc(sizeof(IEAKMMCCOOKIE));

            lpCookie->lpItem =  ULongToPtr(i);
            lpCookie->lpParentItem = this;
            lpCookie->pNext = NULL;
            AddItemToCookieList(&m_lpCookieList, lpCookie);

            item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            item.displayname = MMC_CALLBACK;
            item.nImage = i;
            item.nOpenImage = i;
            item.nState = 0;
            item.cChildren = g_NameSpace[i].cChildren;
            item.lParam = (LPARAM)lpCookie;
            item.relativeID =  hParent;

            m_pScope->InsertItem (&item);
            m_ahChildren[i] = item.ID;
        }
    }

    return S_OK;
}

HANDLE CComponentData::GetLockHandle()
{
    return m_hLock;
}

HRESULT CComponentData::SetLockHandle(HANDLE hLock)
{
    m_hLock = hLock;
    return S_OK;
}

HRESULT CComponentData::SignalPolicyChanged(BOOL bMachine, BOOL bAdd, GUID *pGuidExtension,
                                     GUID *pGuidSnapin)
{
    return m_pGPTInformation->PolicyChanged(bMachine, bAdd, pGuidExtension, pGuidSnapin);
}

///////////////////////////////////////////////////////////////////////////////
BOOL CComponentData::IsRSoPViewInPreferenceMode()
{
	BOOL bRet = FALSE;
	__try
	{
		ASSERT(m_bIsRSoP);
		if (NULL != m_bstrRSoPNamespace)
		{
			HRESULT hr = NOERROR;
			ComPtr<IWbemServices> pWbemServices = NULL;

			// Connect to the namespace using the locator's
			// ConnectServer method
			ComPtr<IWbemLocator> pIWbemLocator = NULL;
			if (CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
								 IID_IWbemLocator, (LPVOID *) &pIWbemLocator) == S_OK)
			{
				hr = pIWbemLocator->ConnectServer(m_bstrRSoPNamespace, NULL, NULL,
															0L, 0L, NULL, NULL,
															&pWbemServices);

				if (SUCCEEDED(hr))
				{
				}
				else
				{
					ASSERT(0);
				}

				pIWbemLocator = NULL;
			}
			else
			{
				ASSERT(0);
			}

			// If any RSOP_IEAKPolicySetting instance is in preference mode, stop and
			// return TRUE;
			if (NULL != pWbemServices)
			{
				_bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
				ComPtr<IEnumWbemClassObject> pObjEnum = NULL;
				hr = pWbemServices->CreateInstanceEnum(bstrClass,
														WBEM_FLAG_FORWARD_ONLY,
														NULL, &pObjEnum);
				if (SUCCEEDED(hr))
				{
					// Final Next wil return WBEM_S_FALSE
					while (WBEM_S_NO_ERROR == hr)
					{
						// There should only be one object returned from this query.
						ULONG uReturned = (ULONG)-1L;
						ComPtr<IWbemClassObject> pPSObj = NULL;
						hr = pObjEnum->Next(10000L, 1, &pPSObj, &uReturned);
						if (SUCCEEDED(hr) && 1 == uReturned)
						{
							_variant_t vtPrecMode;
							hr = pPSObj->Get(L"preferenceMode", 0, &vtPrecMode, NULL, NULL);
							if (SUCCEEDED(hr) && VT_BOOL == vtPrecMode.vt)
							{
								if ((bool)vtPrecMode)
								{
									bRet = TRUE;
									break;
								}
							}
						}
					}
				}
			}
		}
	}
	__except(TRUE)
	{
	}
	return bRet;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CComponentDataCF::CComponentDataCF(BOOL bIsRSoP):
		m_bIsRSoP(bIsRSoP)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CComponentDataCF::~CComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CComponentData *pComponentData = new CComponentData(m_bIsRSoP); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CComponentDataCF::LockServer(BOOL fLock)
{
    UNREFERENCED_PARAMETER(fLock);

    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object creation (IClassFactory)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CreateComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    if (IsEqualCLSID (rclsid, CLSID_IEAKSnapinExt)) 
    {
        CComponentDataCF *pComponentDataCF = new CComponentDataCF(FALSE);   // ref == 1

        if (pComponentDataCF == NULL)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_IEAKRSoPSnapinExt)) 
    {
        CComponentDataCF *pComponentDataCF = new CComponentDataCF(TRUE);   // ref == 1

        if (pComponentDataCF == NULL)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_AboutIEAKSnapinExt)) 
    {
        CAboutIEAKSnapinExtCF *pAboutIEAKSnapinExtCF = new CAboutIEAKSnapinExtCF(); // ref == 1

        if (pAboutIEAKSnapinExtCF == NULL)
            return E_OUTOFMEMORY;

        hr = pAboutIEAKSnapinExtCF->QueryInterface(riid, ppv);

        pAboutIEAKSnapinExtCF->Release();     // release initial ref

        return hr;
    }

    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\context.cpp ===
#include "precomp.h"

#define WM_SAVE_COMPLETE    WM_USER+101

extern INT_PTR CALLBACK CabSignProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
extern void SignCabFile(LPCTSTR pcszFilename, LPCTSTR pcszIns, LPTSTR pszUnsignedFiles);

static TCHAR s_szConfigCabName[MAX_PATH] = TEXT("");
static TCHAR s_szDesktopCabName[MAX_PATH] = TEXT("");
static TCHAR s_szCurrInsPath[MAX_PATH] = TEXT("");
static TCHAR s_szCabsURLPath[INTERNET_MAX_URL_LENGTH] = TEXT("");
static TCHAR s_szNewVersionStr[32] = TEXT("");
static TCHAR s_szInsFile[MAX_PATH] = TEXT("");

static INT_PTR CALLBACK displaySaveDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
static BOOL doCompressCabFile(LPVOID lpVoid);
static void compressCabFile();
static BOOL createCab(LPCTSTR pcszCabPath, LPCTSTR pcszCabName, LPTSTR pszUnsignedFiles);
static void getDefaultCabName(DWORD dwCabType, LPCTSTR pcszPrefix, LPTSTR pszCabName);
static void getCabNameFromINS(LPCTSTR pcszInsFile, DWORD dwCabType, LPTSTR pszCabFullFileName, LPTSTR pszCabInfoLine = NULL);
static void updateCabName(HWND hDlg, UINT nCtrlID, DWORD dwCabType, LPCTSTR pcszPrefix, LPCTSTR pcszInsFile);
static BOOL makeDDFFile(LPCTSTR pcszSrcDir, LPCTSTR pcszDDF);
static BOOL CanOverwriteFiles(HWND hDlg);

BOOL BrowseForSave(HWND hWnd, LPTSTR szFilter, LPTSTR szFileName, int nSize, LPTSTR szDefExt)
{
    OPENFILENAME ofn;
    TCHAR szDir[MAX_PATH];
    LPTSTR lpExt;

    StrCpy(szDir, szFileName);
    lpExt = PathFindExtension(szFileName);
    if (*lpExt != TEXT('\0'))
    {
        StrCpy(szFileName, PathFindFileName(szDir));
        PathRemoveFileSpec(szDir);
    }
    else
        *szFileName = TEXT('\0');
    
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = g_hUIInstance;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = nSize;
    ofn.lpstrFileTitle = NULL;
    ofn.lpstrInitialDir = szDir;
    ofn.lpstrTitle = NULL;
    ofn.Flags = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = szDefExt;

    return GetSaveFileName(&ofn);
}


void ExportSettings()
{   
    if (PathFileExists(s_szCurrInsPath))
    {
        TCHAR szTempInsFile[MAX_PATH];
        TCHAR szCabInfoLine[INTERNET_MAX_URL_LENGTH + 128];

        // create a copy of the .INS file -> .TMP file in the temp directory
        GetTempPath(countof(szTempInsFile), szTempInsFile);
        PathAppend(szTempInsFile, TEXT("install.tmp"));
        CopyFile(s_szInsFile, szTempInsFile, FALSE);

        // save away old version sections, if any into the temp INS file
        if (GetPrivateProfileString(CUSTOMVERSECT, CUSTBRNDNAME, TEXT(""), szCabInfoLine, ARRAYSIZE(szCabInfoLine), s_szCurrInsPath))
            WritePrivateProfileString(CUSTOMVERSECT, CUSTBRNDNAME, szCabInfoLine, szTempInsFile);
        
        if (GetPrivateProfileString(CUSTBRNDSECT, CUSTBRNDNAME, TEXT(""), szCabInfoLine, ARRAYSIZE(szCabInfoLine), s_szCurrInsPath))
            WritePrivateProfileString(CUSTBRNDSECT, CUSTBRNDNAME, szCabInfoLine, szTempInsFile);
        
        if (GetPrivateProfileString(CUSTOMVERSECT, CUSTDESKNAME, TEXT(""), szCabInfoLine, ARRAYSIZE(szCabInfoLine), s_szCurrInsPath))
            WritePrivateProfileString(CUSTOMVERSECT, CUSTDESKNAME, szCabInfoLine, szTempInsFile);
        
        if (GetPrivateProfileString(CUSTDESKSECT, CUSTDESKNAME, TEXT(""), szCabInfoLine, ARRAYSIZE(szCabInfoLine), s_szCurrInsPath))
            WritePrivateProfileString(CUSTDESKSECT, CUSTDESKNAME, szCabInfoLine, szTempInsFile);
       
        if (GetPrivateProfileString(BRANDING, INSVERKEY, TEXT(""), szCabInfoLine, ARRAYSIZE(szCabInfoLine), s_szCurrInsPath))
            WritePrivateProfileString(BRANDING, INSVERKEY, szCabInfoLine, szTempInsFile);

        // copy temp INS file to destination path
        CopyFile(szTempInsFile, s_szCurrInsPath, FALSE);

        // delete the temp INS file
        DeleteFile(szTempInsFile);
    }
    else
    {
        TCHAR szDir[MAX_PATH];

        StrCpy(szDir, s_szCurrInsPath);
        PathRemoveFileSpec(szDir);
        PathCreatePath(szDir);

        // copy INS file to destination path
        CopyFile(s_szInsFile, s_szCurrInsPath, FALSE);
    }
        
    DialogBox(g_hUIInstance, MAKEINTRESOURCE(IDD_DISPLAYSAVE), NULL, displaySaveDlgProc);
}


INT_PTR CALLBACK SaveDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szInsFile[MAX_PATH];
    TCHAR szCabsURL[INTERNET_MAX_URL_LENGTH];
    TCHAR szPrefix[MAX_PATH];
    TCHAR szCabName[MAX_PATH];
    TCHAR szCabPath[MAX_PATH];
    HWND hCtrl;
    TCHAR szMsgText[1024];
    TCHAR szMsgTitle[1024];

    UNREFERENCED_PARAMETER(lParam);

    switch(uMsg)
    {
    case WM_SETFONT:
        //a change to mmc requires us to do this logic for all our property pages that use common controls
        INITCOMMONCONTROLSEX iccx;
        iccx.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccx.dwICC = ICC_ANIMATE_CLASS  | ICC_BAR_CLASSES  | ICC_LISTVIEW_CLASSES  |ICC_TREEVIEW_CLASSES;
        InitCommonControlsEx(&iccx);
        break;

    case WM_INITDIALOG:
        StrCpy(s_szInsFile, (LPCTSTR)lParam);

        DisableDBCSChars(hDlg, IDE_CABSURL);       

        EnableDBCSChars(hDlg, IDE_INSFILE);
        EnableDBCSChars(hDlg, IDE_CAB1NAME);
        EnableDBCSChars(hDlg, IDE_CAB2NAME);
        
        ShowWindow(GetDlgItem(hDlg, IDC_ADVANCEDSIGN), SW_SHOW);

        CreateWorkDir(s_szInsFile, IEAK_GPE_BRANDING_SUBDIR, szCabPath);
        if (PathIsDirectoryEmpty(szCabPath))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_CAB1TEXT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDE_CAB1NAME), FALSE);
        }

        CreateWorkDir(s_szInsFile, IEAK_GPE_DESKTOP_SUBDIR, szCabPath);
        if (PathIsDirectoryEmpty(szCabPath))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_CAB2TEXT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDE_CAB2NAME), FALSE);
        }

        if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB1NAME)) && 
            !IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB2NAME)))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_CABSURLTEXT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDE_CABSURL), FALSE);
        }

        //----------------- InsFile
        if (ISNULL(s_szCurrInsPath))
        {
            DWORD   dwType = REG_SZ;
            DWORD   dwSize = sizeof(s_szCurrInsPath);

            SHGetValue(HKEY_CURRENT_USER, RK_IEAK TEXT("\\SIE"), TEXT("LastOpenedFile"),
                       &dwType, s_szCurrInsPath, &dwSize);
        }

        if (ISNONNULL(s_szCurrInsPath))
        {
            SetDlgItemText(hDlg, IDE_INSFILE, s_szCurrInsPath);

            GetBaseFileName(s_szCurrInsPath, szPrefix, ARRAYSIZE(szPrefix));
            if(StrCmpI(szPrefix, TEXT("install")) == 0)
                StrCpy(szPrefix, TEXT("Default"));
        }
        else
            *szPrefix           = TEXT('\0');

        if (!PathFileExists(s_szCurrInsPath))
        {
            *s_szCabsURLPath    = TEXT('\0');
            *s_szConfigCabName  = TEXT('\0');
            *s_szDesktopCabName = TEXT('\0');
            *s_szNewVersionStr  = TEXT('\0');
        }

        //----------------- CabsURLPath
        if (ISNONNULL(s_szCabsURLPath))
            SetDlgItemText(hDlg, IDE_CABSURL, s_szCabsURLPath);

        if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB1NAME)))
        {
            if (ISNULL(s_szConfigCabName))
                getDefaultCabName(CAB_TYPE_CONFIG, szPrefix, szCabName);
            else
                getDefaultCabName(CAB_TYPE_CONFIG, s_szConfigCabName, szCabName);
            SetDlgItemText(hDlg, IDE_CAB1NAME, szCabName);
        }

        if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB2NAME)))
        {
            if (ISNULL(s_szDesktopCabName))
                getDefaultCabName(CAB_TYPE_DESKTOP, szPrefix, szCabName);
            else
                getDefaultCabName(CAB_TYPE_DESKTOP, s_szDesktopCabName, szCabName);
            SetDlgItemText(hDlg, IDE_CAB2NAME, szCabName);
        }

        //----------------- Version
        if (ISNULL(s_szNewVersionStr))
            GenerateNewVersionStr(s_szCurrInsPath, s_szNewVersionStr);
        SetDlgItemText(hDlg, IDC_CABVERSION, s_szNewVersionStr);

        SetFocus(GetDlgItem(hDlg, IDE_INSFILE));
        return FALSE;

    case WM_COMMAND:
        switch (wParam)
        {
        case IDOK:
            if (GetDlgItemText(hDlg, IDE_INSFILE, szInsFile, ARRAYSIZE(szInsFile))
                && ((StrCmpI(PathFindExtension(szInsFile), TEXT(".ins")) == 0) ||
                (StrCmpI(PathFindExtension(szInsFile), TEXT(".INS")) == 0)))  //looks weird, but hack is needed for turkish locale
            {
                if (IsFileCreatable(szInsFile))
                {
                    *szCabsURL = TEXT('\0');
                    if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_CABSURL)) ||
                        (GetDlgItemText(hDlg, IDE_CABSURL, szCabsURL, ARRAYSIZE(szCabsURL))
                        && PathIsURL(szCabsURL)))
                    {
                        if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB1NAME)) ||
                            GetDlgItemText(hDlg, IDE_CAB1NAME, szCabName, ARRAYSIZE(szCabName)))
                        {
                            if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB2NAME)) ||
                                GetDlgItemText(hDlg, IDE_CAB2NAME, szCabName, ARRAYSIZE(szCabName)))
                            {
                                if(!CanOverwriteFiles(hDlg))
                                    return TRUE;
                            
                                StrCpy(s_szCurrInsPath, szInsFile);
                                StrCpy(s_szCabsURLPath, szCabsURL);
                            
                                GetDlgItemText(hDlg, IDE_CAB1NAME, s_szConfigCabName, ARRAYSIZE(s_szConfigCabName));
                                GetDlgItemText(hDlg, IDE_CAB2NAME, s_szDesktopCabName, ARRAYSIZE(s_szDesktopCabName));

                                // set the last opened INS file in the registry
                                SHSetValue(HKEY_CURRENT_USER, RK_IEAK TEXT("\\SIE"), TEXT("LastOpenedFile"),
                                           REG_SZ, s_szCurrInsPath, sizeof(s_szCurrInsPath));
                            
                                EndDialog(hDlg, 0);
                                break;
                            }
                            else
                                hCtrl = GetDlgItem(hDlg, IDE_CAB2NAME);
                        }
                        else
                            hCtrl = GetDlgItem(hDlg, IDE_CAB1NAME);
                    
                        MessageBox(hDlg, res2Str(IDS_MUSTSPECIFYNAME, szMsgText, countof(szMsgText)),\
                                   res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)), MB_OK);
                        SendMessage(hCtrl, EM_SETSEL, 0, -1);
                        SetFocus(hCtrl);
                    }
                    else
                    {
                        hCtrl = GetDlgItem(hDlg, IDE_CABSURL);
                    
                        MessageBox(hDlg, res2Str(IDS_MUSTSPECIFYURL, szMsgText, countof(szMsgText)),
                                   res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)), MB_OK);
                        SendMessage(hCtrl, EM_SETSEL, 0, -1);
                        SetFocus(hCtrl);
                    }
                }
                else
                {
                    MessageBox(hDlg, res2Str(IDS_CANTCREATEFILE, szMsgText, countof(szMsgText)),
                               res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)), MB_OK);
                    SendMessage(hCtrl = GetDlgItem(hDlg, IDE_INSFILE), EM_SETSEL, 0, -1);
                    SetFocus(hCtrl);
                }
            }
            else
            {
                hCtrl = GetDlgItem(hDlg, IDE_INSFILE);
                
                MessageBox(hDlg, res2Str(IDS_MUSTSPECIFYINS, szMsgText, countof(szMsgText)),
                           res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)), MB_OK);
                SendMessage(hCtrl, EM_SETSEL, 0, -1);
                SetFocus(hCtrl);
            }
            return TRUE;
            
        case IDCANCEL:
            EndDialog(hDlg, -1);
            break;

        case IDC_ADVANCEDSIGN:
        {
            PROPSHEETPAGE psp;
            HPROPSHEETPAGE hPage;
            PROPSHEETHEADER psph;

            psp.dwSize = sizeof(PROPSHEETPAGE);
            psp.dwFlags = PSP_HASHELP;
            psp.hInstance = g_hUIInstance;
            psp.pszTemplate = MAKEINTRESOURCE(IDD_CABSIGN);
            psp.lParam = (LPARAM)s_szInsFile;
            psp.pfnDlgProc = CabSignProc;
            hPage = CreatePropertySheetPage(&psp);

            ZeroMemory(&psph, sizeof(psph));
            psph.dwSize = sizeof(PROPSHEETHEADER);
            psph.hwndParent = hDlg;
            psph.hInstance = g_hUIInstance;
            psph.nPages = 1;
            psph.phpage = &hPage;
            psph.pszCaption = MAKEINTRESOURCE(IDS_CABSIGN);

            PropertySheet(&psph);
            break;
        }
        case IDC_INSBROWSE:
            *s_szCurrInsPath = TEXT('\0');
            GetDlgItemText(hDlg, IDE_INSFILE, s_szCurrInsPath, ARRAYSIZE(s_szCurrInsPath));

            if (BrowseForSave(hDlg, NULL, s_szCurrInsPath, ARRAYSIZE(s_szCurrInsPath), NULL))
                SetDlgItemText(hDlg, IDE_INSFILE, s_szCurrInsPath);

            //send the killfocus msg, since this is how we notice changes
            SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDE_INSFILE, EN_KILLFOCUS), (LPARAM)GetDlgItem(hDlg, IDE_INSFILE));
            
            return TRUE;
        }

        if (LOWORD(wParam) == IDE_INSFILE && HIWORD(wParam) == EN_KILLFOCUS &&
            IsWindowEnabled(GetDlgItem(hDlg, IDE_CABSURL)))
        {
            GetDlgItemText(hDlg, IDE_INSFILE, szInsFile, ARRAYSIZE(szInsFile));
            if(*szInsFile != TEXT('\0') && StrCmpI(PathFindExtension(szInsFile), TEXT(".ins")) == 0)
            {
                GetBaseFileName(szInsFile, szPrefix, ARRAYSIZE(szPrefix));
                if(StrCmpI(szPrefix, TEXT("install")) == 0)
                    StrCpy(szPrefix, TEXT("Default"));

                GetPrivateProfileString(BRANDING, CABSURLPATH, TEXT(""), szCabsURL,
                                        countof(szCabsURL), szInsFile);
                if (ISNONNULL(szCabsURL))
                    SetDlgItemText(hDlg, IDE_CABSURL, szCabsURL);
                
                if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB1NAME)))
                    updateCabName(hDlg, IDE_CAB1NAME, CAB_TYPE_CONFIG, szPrefix, szInsFile);

                if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB2NAME)))
                    updateCabName(hDlg, IDE_CAB2NAME, CAB_TYPE_DESKTOP, szPrefix, szInsFile);
            }
        }
        
        break;
    }

    return FALSE;
}

static INT_PTR CALLBACK displaySaveDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    static HANDLE s_hThread;
    DWORD dwThread;
    TCHAR szMsgTitle[1024];

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    switch( msg )
    {
    case WM_INITDIALOG:
        SetWindowText(hDlg, res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)));
        Animate_Open( GetDlgItem( hDlg, IDC_ANIMATE ), IDA_GEARS );
        Animate_Play( GetDlgItem( hDlg, IDC_ANIMATE ), 0, -1, -1 );
        if((s_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) doCompressCabFile, (LPVOID) hDlg, 0, &dwThread)) == NULL)
        {
            compressCabFile();
            EndDialog(hDlg, 1);
        }
        break;

    case WM_SAVE_COMPLETE:
        EndDialog(hDlg, 1);
        break;

    case WM_DESTROY:
        if (s_hThread != NULL)
            CloseHandle(s_hThread);
        break;

    default:
        return 0;
    }

    return 1;
}

static BOOL doCompressCabFile(LPVOID lpVoid)
{
    HWND hDlg = (HWND) lpVoid;

    compressCabFile();
    PostMessage(hDlg, WM_SAVE_COMPLETE, 0, 0L);
    return TRUE;
}

static void compressCabFile()
{
    TCHAR szCabPath[MAX_PATH];
    TCHAR szType[8];
    TCHAR szUnsignedFiles[MAX_PATH * 2] = TEXT("");

    //-------------------- Config
    
    CreateWorkDir(s_szInsFile, IEAK_GPE_BRANDING_SUBDIR, szCabPath);
    
    if (createCab(szCabPath, s_szConfigCabName, szUnsignedFiles))
        SetOrClearVersionInfo(s_szCurrInsPath, CAB_TYPE_CONFIG, s_szConfigCabName, 
            s_szCabsURLPath, s_szNewVersionStr, SET);
    else
        SetOrClearVersionInfo(s_szCurrInsPath, CAB_TYPE_CONFIG, s_szConfigCabName, 
            s_szCabsURLPath, s_szNewVersionStr, CLEAR);

    //-------------------- Desktop
    
    CreateWorkDir(s_szInsFile, IEAK_GPE_DESKTOP_SUBDIR, szCabPath);

    if (createCab(szCabPath, s_szDesktopCabName, szUnsignedFiles))
        SetOrClearVersionInfo(s_szCurrInsPath, CAB_TYPE_DESKTOP, s_szDesktopCabName, 
            s_szCabsURLPath, s_szNewVersionStr, SET);
    else
        SetOrClearVersionInfo(s_szCurrInsPath, CAB_TYPE_DESKTOP, s_szDesktopCabName, 
            s_szCabsURLPath, s_szNewVersionStr, CLEAR);

    WritePrivateProfileString(BRANDING, CABSURLPATH, s_szCabsURLPath, s_szCurrInsPath);
    WritePrivateProfileString(BRANDING, INSVERKEY, s_szNewVersionStr, s_szCurrInsPath);

    // write the type as INTRANET so that the branding DLL extracts and processes the cabs in the CUSTOM dir
    wnsprintf(szType, countof(szType), TEXT("%u"), INTRANET);
    WritePrivateProfileString(BRANDING, TEXT("Type"), szType, s_szCurrInsPath);

    if (ISNONNULL(szUnsignedFiles))
    {
        TCHAR szMessage[MAX_PATH*3];
        TCHAR szMsg[64];
        
        LoadString(g_hUIInstance, IDS_CABSIGN_ERROR, szMsg, ARRAYSIZE(szMsg));
        wnsprintf(szMessage, ARRAYSIZE(szMessage), szMsg, szUnsignedFiles);
        MessageBox(NULL, szMessage, TEXT(""), MB_OK | MB_SETFOREGROUND);
    }
}

static BOOL createCab(LPCTSTR pcszCabPath, LPCTSTR pcszCabName, LPTSTR pszUnsignedFiles)
{
    TCHAR szCmd[MAX_PATH*4];
    TCHAR szDest[MAX_PATH];
    TCHAR szDDF[MAX_PATH];
    TCHAR szTempPath[MAX_PATH];

    if (!PathFileExists(pcszCabPath) || PathIsDirectoryEmpty(pcszCabPath))
        return FALSE;

    // create a temporary cab folder
    GetTempPath(countof(szTempPath), szTempPath);
    PathAppend(szTempPath, TEXT("SIE"));
    PathCreatePath(szTempPath);

    PathCombine(szDDF, szTempPath, TEXT("folder.ddf"));
    
    if (!makeDDFFile(pcszCabPath, szDDF))
        return FALSE;
    
    wnsprintf(szCmd, countof(szCmd), 
              TEXT("MAKECAB.EXE /D CabinetName1=\"%s\" /D DiskDirectory1=\"%s\" /F %s"),
              pcszCabName, szTempPath, szDDF);

    RunAndWait(szCmd, szTempPath, SW_HIDE);
    
    // if the cab file exist in the destination path set the attribute to normal
    StrCpy(szDest, s_szCurrInsPath);
    PathRemoveFileSpec(szDest);
    PathAppend(szDest, pcszCabName);
    if (PathFileExists(szDest))
        SetFileAttributes(szDest, FILE_ATTRIBUTE_NORMAL);

    PathAppend(szTempPath, pcszCabName);

    CopyFile(szTempPath, szDest, FALSE);
    
    SignCabFile(szDest, s_szCurrInsPath, pszUnsignedFiles);

    // remove the temporary folder
    PathRemovePath(szDDF);

    return TRUE;
}

static void getDefaultCabName(DWORD dwCabType, LPCTSTR pcszPrefix, LPTSTR pszCabName)
{
    TCHAR szActualPrefix[MAX_PATH];
    
    *pszCabName = TEXT('\0');
    
    if (pcszPrefix == NULL || *pcszPrefix == TEXT('\0'))
        return;

    if (StrChr(pcszPrefix, '.') != NULL)
    {
        StrCpy(pszCabName, pcszPrefix);
        return;
    }
    
    StrCpy(szActualPrefix, pcszPrefix);
    
    switch(dwCabType)
    {
    case CAB_TYPE_CONFIG:
        wnsprintf(pszCabName, MAX_PATH, TEXT("%s_config.cab"), szActualPrefix);
        break;
        
    case CAB_TYPE_DESKTOP:
        wnsprintf(pszCabName, MAX_PATH, TEXT("%s_desktop.cab"), szActualPrefix);
        break;
    }
}

static void getCabNameFromINS(LPCTSTR pcszInsFile, DWORD dwCabType, LPTSTR pszCabFullFileName, LPTSTR pszCabInfoLine /* = NULL*/)
{
    LPCTSTR pcszSection = NULL, pcszKey = NULL;
    TCHAR szCabFilePath[MAX_PATH];
    TCHAR szCabName[MAX_PATH];
    TCHAR szCabInfoLine[INTERNET_MAX_URL_LENGTH + 128];

    if (pcszInsFile == NULL || *pcszInsFile == TEXT('\0') || pszCabFullFileName == NULL)
        return;
    
    *pszCabFullFileName = TEXT('\0');

    if (pszCabInfoLine != NULL)
        *pszCabInfoLine = TEXT('\0');

    switch (dwCabType)
    {
    case CAB_TYPE_CONFIG:
        pcszSection = CUSTBRNDSECT;
        pcszKey = CUSTBRNDNAME;
        break;

    case CAB_TYPE_DESKTOP:
        pcszSection = CUSTDESKSECT;
        pcszKey = CUSTDESKNAME;
        break;
    }

    if (pcszSection == NULL || pcszKey == NULL)
        return;

    StrCpy(szCabFilePath, pcszInsFile);
    PathRemoveFileSpec(szCabFilePath);

    if (GetPrivateProfileString(pcszSection, pcszKey, TEXT(""), szCabInfoLine, ARRAYSIZE(szCabInfoLine), pcszInsFile) == 0)
        GetPrivateProfileString(CUSTOMVERSECT, pcszKey, TEXT(""), szCabInfoLine, ARRAYSIZE(szCabInfoLine), pcszInsFile);

    if (*szCabInfoLine)
    {
        LPTSTR pszT;

        if ((pszT = StrChr(szCabInfoLine, TEXT(','))) != NULL)
            *pszT = TEXT('\0');

        if ((pszT = PathFindFileName(szCabInfoLine)) > szCabInfoLine)
        {
            // cab URL path is specified
            *(pszT - 1) = TEXT('\0');           // nul the '/' char
        }

        StrCpy(szCabName, pszT);
        PathCombine(pszCabFullFileName, szCabFilePath, szCabName);

        if (pszCabInfoLine)
            StrCpy(pszCabInfoLine, szCabInfoLine);
    }
}

static void updateCabName(HWND hDlg, UINT nCtrlID, DWORD dwCabType, LPCTSTR pcszPrefix, LPCTSTR pcszInsFile)
{
    TCHAR   szTempCabName[MAX_PATH];
    BOOL    fCabName = FALSE;

    *szTempCabName = TEXT('\0');
    if (PathFileExists(pcszInsFile))
    {
        getCabNameFromINS(pcszInsFile, dwCabType, szTempCabName);
        
        if (ISNONNULL(szTempCabName))
        {
            SetDlgItemText(hDlg, nCtrlID, PathFindFileName(szTempCabName));
            fCabName = TRUE;
        }
    }
    else
        GetDlgItemText(hDlg, nCtrlID, szTempCabName, countof(szTempCabName));

    if (!fCabName)
    {
        TCHAR   szCabSuffix[MAX_PATH];
        TCHAR   szCabName[MAX_PATH];

        if (dwCabType == CAB_TYPE_CONFIG)
            StrCpy(szCabSuffix, TEXT("_config.cab"));
        else if (dwCabType == CAB_TYPE_DESKTOP)
            StrCpy(szCabSuffix, TEXT("_desktop.cab"));
        
        if (ISNULL(szTempCabName) || StrStrI(szTempCabName, szCabSuffix) != NULL)
        {
            getDefaultCabName(dwCabType, pcszPrefix, szCabName);
            SetDlgItemText(hDlg, nCtrlID, szCabName);
        }
    }
}

#define BUFFER_SIZE     1024

HRESULT pepFileEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL*/)
{
    LPTSTR pListBuffer = NULL;
    static DWORD s_dwBuffer = 0;
    DWORD dwLen;

    UNREFERENCED_PARAMETER(prgdwControl);

    ASSERT(pszPath != NULL && pfd != NULL && lParam != NULL);

    // if its is a directory name, we have nothing to do with it
    if (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        return S_OK;

    pListBuffer = *((LPTSTR*)lParam);
    if (pListBuffer == NULL)    // allocate buffer for the first time
    {
        s_dwBuffer = BUFFER_SIZE;
        
        pListBuffer = (LPTSTR)CoTaskMemAlloc(s_dwBuffer);
        if (pListBuffer == NULL)
            return E_OUTOFMEMORY;

        *((LPTSTR*)lParam) = pListBuffer;
        ZeroMemory(pListBuffer, s_dwBuffer);
    }

    // if not enough memory reallocate
    // StrCbFromSz adds 1 extra unit, accounting 2 units for double quotes,
    // add 3 extra unit for the \r\n and the NULL character
    if (StrCbFromSz(pListBuffer) + StrCbFromSz(pszPath) + StrCbFromCch(3) > s_dwBuffer)
    {
        LPVOID lpTemp;

        s_dwBuffer += BUFFER_SIZE;

        lpTemp = CoTaskMemRealloc(pListBuffer, s_dwBuffer);
        if (lpTemp == NULL)
            return E_OUTOFMEMORY;
        
        pListBuffer = (LPTSTR)lpTemp;
        *((LPTSTR*)lParam) = pListBuffer;

        ZeroMemory(pListBuffer + StrCchFromCb(s_dwBuffer - BUFFER_SIZE), BUFFER_SIZE);
    }

    // append the string to buffer
    dwLen = StrLen(pListBuffer);
    wnsprintf(pListBuffer + dwLen, StrCchFromCb(s_dwBuffer) - dwLen , TEXT("\"%s\"\r\n"), pszPath);

    return S_OK;
}

static BOOL makeDDFFile(LPCTSTR pcszSrcDir, LPCTSTR pcszDDF)
{
    HANDLE  hDDF;
    LPTSTR  pFileList = NULL;
    BOOL    fRetVal = FALSE;
    HRESULT hrResult;

    hDDF = CreateFile(pcszDDF, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL, NULL);

    if (hDDF == INVALID_HANDLE_VALUE)
        return fRetVal;

    hrResult = PathEnumeratePath(pcszSrcDir, PEP_DEFAULT,
                pepFileEnumProc, (LPARAM)&pFileList);
    
    if (pFileList != NULL)
    {
        TCHAR   szMsgText[1024];
        TCHAR   szMsgTitle[1024];
        
        if (hrResult == S_OK)
            fRetVal = WriteStringToFile(hDDF, pFileList, StrLen(pFileList));
        else if (hrResult == E_OUTOFMEMORY)
            MessageBox(NULL, res2Str(IDS_MEMORY_ERROR, szMsgText, countof(szMsgText)),
                       res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)), MB_OK);
        
        CoTaskMemFree(pFileList);
    }
        
    CloseHandle(hDDF);

    return fRetVal;
}

static BOOL CanOverwriteFiles(HWND hDlg)
{
    TCHAR szExistingFiles[MAX_PATH*5];
    TCHAR szTemp[MAX_PATH];
    TCHAR szDir[MAX_PATH];
    TCHAR szFile[MAX_PATH];
    TCHAR szReadOnlyFiles[MAX_PATH*5];

    *szExistingFiles = TEXT('\0');
    *szReadOnlyFiles = TEXT('\0');
    // check for file already exists in the destination directory.
    GetDlgItemText(hDlg, IDE_INSFILE, szTemp, ARRAYSIZE(szTemp));
    if (PathFileExists(szTemp))
    {
        StrCat(szExistingFiles, szTemp);
        StrCat(szExistingFiles, TEXT("\r\n"));

        if (IsFileReadOnly(szTemp))
            StrCpy(szReadOnlyFiles, szExistingFiles);
    }

    StrCpy(szDir, szTemp);
    PathRemoveFileSpec(szDir);
    
    if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB1NAME)))
    {
        GetDlgItemText(hDlg, IDE_CAB1NAME, szTemp, ARRAYSIZE(szTemp));
        PathCombine(szFile, szDir, szTemp);
        if (PathFileExists(szFile))
        {
            StrCat(szExistingFiles, szFile);
            StrCat(szExistingFiles, TEXT("\r\n"));

            if (IsFileReadOnly(szFile))
            {
                StrCat(szReadOnlyFiles, szFile);
                StrCat(szReadOnlyFiles, TEXT("\r\n"));
            }
        }
    }
    
    if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB2NAME)))
    {
        GetDlgItemText(hDlg, IDE_CAB2NAME, szTemp, ARRAYSIZE(szTemp));
        PathCombine(szFile, szDir, szTemp);
        if (PathFileExists(szFile))
        {
            StrCat(szExistingFiles, szFile);
            StrCat(szExistingFiles, TEXT("\r\n"));

            if (IsFileReadOnly(szFile))
            {
                StrCat(szReadOnlyFiles, szFile);
                StrCat(szReadOnlyFiles, TEXT("\r\n"));
            }
        }
    }
    
    if (*szReadOnlyFiles != TEXT('\0'))
    {
        TCHAR szMsg[MAX_PATH*6];
        TCHAR szMsgText[MAX_PATH];
        TCHAR szMsgTitle[MAX_PATH];

        wnsprintf(szMsg, countof(szMsg), res2Str(IDS_FILE_READONLY, szMsgText, countof(szMsgText)), szReadOnlyFiles);
        MessageBox(hDlg, szMsg, res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)), MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }

    if (*szExistingFiles != TEXT('\0'))
    {
        TCHAR szMsg[MAX_PATH*6];
        TCHAR szMsgText[MAX_PATH];
        TCHAR szMsgTitle[MAX_PATH];

        wnsprintf(szMsg, countof(szMsg), res2Str(IDS_FILE_ALREADY_EXISTS, szMsgText, countof(szMsgText)), szExistingFiles);
        if (MessageBox(hDlg, szMsg, res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)), 
                       MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2) == IDNO)
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\cs.cpp ===
#include "precomp.h"

#include <inetcpl.h>

#include "rsop.h"
#include "resource.h"

#include <tchar.h>

// Private forward decalarations
static void pxyEnableDlgItems(HWND hDlg, BOOL fSame, BOOL fUseProxy);

static INT_PTR CALLBACK importConnSettingsRSoPProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

// defines for tree view image list
#define BITMAP_WIDTH    16
#define BITMAP_HEIGHT   16
#define CONN_BITMAPS    2
#define IMAGE_LAN       0
#define IMAGE_MODEM     1

/////////////////////////////////////////////////////////////////////
void InitCSDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    __try
    {
        BOOL bImport = FALSE;
        _bstr_t bstrClass = L"RSOP_IEConnectionSettings";
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass, L"rsopPrecedence");
        if (SUCCEEDED(hr))
        {
            CPSObjData **paCSObj = pDRD->GetCSObjArray();
            long nCSObjects = pDRD->GetCSObjCount();

            BOOL bImportHandled = FALSE;
            BOOL bDeleteHandled = FALSE;
            for (long nObj = 0; nObj < nCSObjects; nObj++)
            {
                // importCurrentConnSettings field
                _variant_t vtValue;
                if (!bImportHandled)
                {
                    hr = paCSObj[nObj]->pObj->Get(L"importCurrentConnSettings", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        bImport = (bool)vtValue ? TRUE : FALSE;
                        CheckRadioButton(hDlg, IDC_CSNOIMPORT, IDC_CSIMPORT,
                                        (bool)vtValue ? IDC_CSIMPORT : IDC_CSNOIMPORT);
                        bImportHandled = TRUE;

                        DWORD dwCurGPOPrec = GetGPOPrecedence(paCSObj[nObj]->pObj, L"rsopPrecedence");
                        pDRD->SetImportedConnSettPrec(dwCurGPOPrec);
                    }
                }

                // deleteExistingConnSettings field
                if (!bDeleteHandled)
                {
                    hr = paCSObj[nObj]->pObj->Get(L"deleteExistingConnSettings", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        CheckDlgButton(hDlg, IDC_DELCONNECT, BST_CHECKED);
                        bDeleteHandled = TRUE;
                    }
                }

                // no need to process other GPOs since enabled properties have been found
                if (bImportHandled && bDeleteHandled)
                    break;
            }
        }

        EnableDlgItem2(hDlg, IDC_CSNOIMPORT, FALSE);
        EnableDlgItem2(hDlg, IDC_CSIMPORT, FALSE);
        EnableDlgItem2(hDlg, IDC_MODIFYCONNECT, bImport);

        EnableDlgItem2(hDlg, IDC_DELCONNECT, FALSE);
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
HRESULT InitCSPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEConnectionSettings";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paCSObj = pDRD->GetCSObjArray();
            long nCSObjects = pDRD->GetCSObjCount();
            for (long nObj = 0; nObj < nCSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPSAssociation(paCSObj[nObj]->pObj,
                                                                        L"rsopPrecedence");

                // importCurrentConnSettings field
                BOOL bImport = FALSE;
                _variant_t vtValue;
                hr = paCSObj[nObj]->pObj->Get(L"importCurrentConnSettings", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    bImport = (bool)vtValue ? TRUE : FALSE;

                // deleteExistingConnSettings field
                BOOL bDelete = FALSE;
                hr = paCSObj[nObj]->pObj->Get(L"deleteExistingConnSettings", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    bDelete = (bool)vtValue ? TRUE : FALSE;

                _bstr_t bstrSetting;
                UINT iSettingString = 0;
                WCHAR wszTemp[128];
                if (bImport && bDelete)
                    iSettingString = IDS_CS_IMP_DEL_SETTING;
                else if (bImport)
                    iSettingString = IDS_CS_IMPORT_SETTING;
                else if (bDelete)
                    iSettingString = IDS_CS_DELETE_SETTING;
                else
                    bstrSetting = GetDisabledString();

                if (iSettingString > 0)
                {
                    LoadString(g_hInstance, iSettingString, wszTemp, countof(wszTemp));
                    bstrSetting = wszTemp;
                }

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
void InitAutoConfigDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEConnectionSettings";
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass, L"rsopPrecedence");
        if (SUCCEEDED(hr))
        {
            CPSObjData **paCSObj = pDRD->GetCSObjArray();
            long nCSObjects = pDRD->GetCSObjCount();

            BOOL bDetectHandled = FALSE;
            BOOL bEnableHandled = FALSE;
            for (long nObj = 0; nObj < nCSObjects; nObj++)
            {
                // autoDetectConfigSettings field
                _variant_t vtValue;
                if (!bDetectHandled)
                {
                    hr = paCSObj[nObj]->pObj->Get(L"autoDetectConfigSettings", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        CheckDlgButton(hDlg, IDC_AUTODETECT, BST_CHECKED);
                        bDetectHandled = TRUE;
                    }
                }

                // autoConfigEnable field
                if (!bEnableHandled)
                {
                    hr = paCSObj[nObj]->pObj->Get(L"autoConfigEnable", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        CheckDlgButton(hDlg, IDC_YESAUTOCON, BST_CHECKED);
                        bEnableHandled = TRUE;

                        // autoConfigTime
                        hr = paCSObj[nObj]->pObj->Get(L"autoConfigTime", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            TCHAR szTime[10] = _T("");
                            wnsprintf(szTime, countof(szTime), _T("%ld"), (long)vtValue);
                            SetDlgItemText(hDlg, IDE_AUTOCONFIGTIME, szTime);
                        }

                        // autoConfigURL
                        _bstr_t bstrValue;
                        hr = paCSObj[nObj]->pObj->Get(L"autoConfigURL", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            bstrValue = vtValue;
                            SetDlgItemText(hDlg, IDE_AUTOCONFIGURL, (LPCTSTR)bstrValue);
                        }

                        // autoProxyURL
                        hr = paCSObj[nObj]->pObj->Get(L"autoProxyURL", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            bstrValue = vtValue;
                            SetDlgItemText(hDlg, IDE_AUTOPROXYURL, (LPCTSTR)bstrValue);
                        }

                    }
                }

                // no need to process other GPOs since enabled properties have been found
                if (bDetectHandled && bEnableHandled)
                    break;
            }
        }

        EnableDlgItem2(hDlg, IDC_AUTODETECT, FALSE);

        EnableDlgItem2(hDlg, IDC_YESAUTOCON, FALSE);
        EnableDlgItem2(hDlg, IDE_AUTOCONFIGTIME, FALSE);
        EnableDlgItem2(hDlg, IDE_AUTOCONFIGURL, FALSE);
        EnableDlgItem2(hDlg, IDE_AUTOPROXYURL, FALSE);
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
HRESULT InitAutoDetectCfgPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEConnectionSettings";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paCSObj = pDRD->GetCSObjArray();
            long nCSObjects = pDRD->GetCSObjCount();
            for (long nObj = 0; nObj < nCSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPSAssociation(paCSObj[nObj]->pObj,
                                                                        L"rsopPrecedence");

                // autoDetectConfigSettings field
                BOOL bDetect = FALSE;
                _variant_t vtValue;
                hr = paCSObj[nObj]->pObj->Get(L"autoDetectConfigSettings", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    bDetect = (bool)vtValue ? TRUE : FALSE;

                _bstr_t bstrSetting;
                if (bDetect)
                    bstrSetting = GetEnabledString();
                else
                    bstrSetting = GetDisabledString();

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT InitAutoCfgEnablePrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEConnectionSettings";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paCSObj = pDRD->GetCSObjArray();
            long nCSObjects = pDRD->GetCSObjCount();
            for (long nObj = 0; nObj < nCSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPSAssociation(paCSObj[nObj]->pObj,
                                                                        L"rsopPrecedence");

                // autoConfigEnable field
                BOOL bEnable = FALSE;
                _variant_t vtValue;
                hr = paCSObj[nObj]->pObj->Get(L"autoConfigEnable", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    bEnable = (bool)vtValue ? TRUE : FALSE;

                _bstr_t bstrSetting;
                if (bEnable)
                    bstrSetting = GetEnabledString();
                else
                    bstrSetting = GetDisabledString();

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
void InitProxyDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEConnectionSettings";
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass, L"rsopPrecedence");
        if (SUCCEEDED(hr))
        {
            CPSObjData **paCSObj = pDRD->GetCSObjArray();
            long nCSObjects = pDRD->GetCSObjCount();

            for (long nObj = 0; nObj < nCSObjects; nObj++)
            {
                // enableProxy field
                _variant_t vtValue;
                hr = paCSObj[nObj]->pObj->Get(L"enableProxy", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                {
                    if ((bool)vtValue)
                        CheckDlgButton(hDlg, IDC_YESPROXY, BST_CHECKED);

                    // httpProxyServer
                    _bstr_t bstrValue;
                    hr = paCSObj[nObj]->pObj->Get(L"httpProxyServer", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        bstrValue = vtValue;
                        SetProxyDlg(hDlg, (LPCTSTR)bstrValue, IDE_HTTPPROXY, IDE_HTTPPORT, TRUE);
                    }

                    // useSameProxy
                    hr = paCSObj[nObj]->pObj->Get(L"useSameProxy", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        if ((bool)vtValue)
                        {
                            CheckDlgButton(hDlg, IDC_SAMEFORALL, BST_CHECKED);

                            SetProxyDlg(hDlg, (LPCTSTR)bstrValue, IDE_FTPPROXY,    IDE_FTPPORT,    TRUE);
                            SetProxyDlg(hDlg, (LPCTSTR)bstrValue, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE);
                            SetProxyDlg(hDlg, (LPCTSTR)bstrValue, IDE_SECPROXY,    IDE_SECPORT,    TRUE);
                            SetProxyDlg(hDlg, (LPCTSTR)bstrValue, IDE_SOCKSPROXY,  IDE_SOCKSPORT,  FALSE);
                        }
                        else
                        {
                            // ftpProxyServer
                            hr = paCSObj[nObj]->pObj->Get(L"ftpProxyServer", 0, &vtValue, NULL, NULL);
                            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                            {
                                bstrValue = vtValue;
                                SetProxyDlg(hDlg, (LPCTSTR)bstrValue, IDE_FTPPROXY,    IDE_FTPPORT,    TRUE);
                            }

                            // gopherProxyServer
                            hr = paCSObj[nObj]->pObj->Get(L"gopherProxyServer", 0, &vtValue, NULL, NULL);
                            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                            {
                                bstrValue = vtValue;
                                SetProxyDlg(hDlg, (LPCTSTR)bstrValue, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE);
                            }

                            // secureProxyServer
                            hr = paCSObj[nObj]->pObj->Get(L"secureProxyServer", 0, &vtValue, NULL, NULL);
                            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                            {
                                bstrValue = vtValue;
                                SetProxyDlg(hDlg, (LPCTSTR)bstrValue, IDE_SECPROXY,    IDE_SECPORT,    TRUE);
                            }

                            // socksProxyServer
                            hr = paCSObj[nObj]->pObj->Get(L"socksProxyServer", 0, &vtValue, NULL, NULL);
                            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                            {
                                bstrValue = vtValue;
                                SetProxyDlg(hDlg, (LPCTSTR)bstrValue, IDE_SOCKSPROXY,  IDE_SOCKSPORT,  FALSE);
                            }
                        }
                    }

                    // proxyOverride
                    hr = paCSObj[nObj]->pObj->Get(L"proxyOverride", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        bstrValue = vtValue;

                        TCHAR szProxy[MAX_PATH];
                        StrCpy(szProxy, (LPCTSTR)bstrValue);

                        if (TEXT('\0') == szProxy[0])
                            StrCpy(szProxy, LOCALPROXY);

                        LPTSTR pszLocal = StrStr(szProxy, LOCALPROXY);
                        if (NULL != pszLocal)
                        {
                            if (pszLocal == szProxy)
                            {
                                LPTSTR pszSemicolon = pszLocal + countof(LOCALPROXY)-1;
                                if (TEXT(';') == *pszSemicolon)
                                    pszSemicolon++;

                                StrCpy(pszLocal, pszSemicolon);
                            }
                            else if (TEXT('\0') == *(pszLocal + countof(LOCALPROXY)-1))
                                *(pszLocal - 1) = TEXT('\0');

                            CheckDlgButton(hDlg, IDC_DISPROXYLOCAL, TRUE);
                        }
                        SetDlgItemText(hDlg, IDE_DISPROXYADR, szProxy);
                    }

                    break;
                }
            }
        }

        EnableDlgItem2(hDlg, IDC_YESPROXY, FALSE);
        EnableDlgItem2(hDlg, IDC_SAMEFORALL, FALSE);

        EnableDlgItem2(hDlg, IDE_HTTPPROXY, FALSE);
        EnableDlgItem2(hDlg, IDE_HTTPPORT, FALSE);
        EnableDlgItem2(hDlg, IDE_FTPPROXY, FALSE);
        EnableDlgItem2(hDlg, IDE_FTPPORT, FALSE);
        EnableDlgItem2(hDlg, IDE_GOPHERPROXY, FALSE);
        EnableDlgItem2(hDlg, IDE_GOPHERPORT, FALSE);
        EnableDlgItem2(hDlg, IDE_SECPROXY, FALSE);
        EnableDlgItem2(hDlg, IDE_SECPORT, FALSE);
        EnableDlgItem2(hDlg, IDE_SOCKSPROXY, FALSE);
        EnableDlgItem2(hDlg, IDE_SOCKSPORT, FALSE);

        EnableDlgItem2(hDlg, IDC_DISPROXYLOCAL, FALSE);
        EnableDlgItem2(hDlg, IDE_DISPROXYADR, FALSE);
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
HRESULT InitProxyPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEConnectionSettings";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paCSObj = pDRD->GetCSObjArray();
            long nCSObjects = pDRD->GetCSObjCount();
            for (long nObj = 0; nObj < nCSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPSAssociation(paCSObj[nObj]->pObj,
                                                                        L"rsopPrecedence");

                // enableProxy field
                BOOL bEnable = FALSE;
                _variant_t vtValue;
                hr = paCSObj[nObj]->pObj->Get(L"enableProxy", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    bEnable = (bool)vtValue ? TRUE : FALSE;

                _bstr_t bstrSetting;
                if (bEnable)
                    bstrSetting = GetEnabledString();
                else
                    bstrSetting = GetDisabledString();

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK ConnectSetDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    TCHAR szWorkDir[MAX_PATH];
    BOOL  fImport;

    switch (msg) {
    case WM_INITDIALOG:
        SetPropSheetCookie(hDlg, lParam);

        // find out if this dlg is in RSoP mode
        psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        if (psCookie->pCS->IsRSoP())
        {
            TCHAR szViewSettings[128];
            LoadString(g_hInstance, IDS_VIEW_SETTINGS, szViewSettings, countof(szViewSettings));
            SetDlgItemText(hDlg, IDC_MODIFYCONNECT, szViewSettings);

            CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
                        if (pDRD)
                           InitCSDlgInRSoPMode(hDlg, pDRD);
        }
        break;

    case WM_DESTROY:
        if (psCookie->pCS->IsRSoP())
            DestroyDlgRSoPData(hDlg);
        break;

    case WM_COMMAND:
        if (BN_CLICKED != GET_WM_COMMAND_CMD(wParam, lParam))
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_CSNOIMPORT:
            DisableDlgItem(hDlg, IDC_MODIFYCONNECT);
            break;

        case IDC_CSIMPORT:
            EnableDlgItem(hDlg, IDC_MODIFYCONNECT);
            break;

        case IDC_MODIFYCONNECT:
            if (psCookie->pCS->IsRSoP())
            {
                CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
                if (NULL != pDRD)
                {
                    CreateINetCplLookALikePage(hDlg, IDD_IMPORTEDCONNSETTINGS,
                                                importConnSettingsRSoPProc, (LPARAM)pDRD);
                }
            }
            else
                ShowInetcpl(hDlg, INET_PAGE_CONNECTION);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_SETACTIVE:
            // don't do any of this stuff in RSoP mode
            if (!psCookie->pCS->IsRSoP())
            {
                fImport = InsGetBool(IS_CONNECTSET, IK_OPTION, FALSE, GetInsFile(hDlg));
                CheckRadioButton(hDlg, IDC_CSNOIMPORT, IDC_CSIMPORT, fImport ? IDC_CSIMPORT : IDC_CSNOIMPORT);
                EnableDlgItem2  (hDlg, IDC_MODIFYCONNECT, fImport);

                ReadBoolAndCheckButton(IS_CONNECTSET, IK_DELETECONN, FALSE, GetInsFile(hDlg), hDlg, IDC_DELCONNECT);
            }
            break;

        case PSN_HELP:
            ShowHelpTopic(hDlg);
            break;

        case PSN_APPLY:
            if (psCookie->pCS->IsRSoP())
                return FALSE;
            else
            {
                CNewCursor cur(IDC_WAIT);

                CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\cs"), szWorkDir);
                fImport = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_CSIMPORT));

                if (!AcquireWriteCriticalSection(hDlg)) {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    break;
                }

                ImportConnectSet(GetInsFile(hDlg), szWorkDir, szWorkDir, fImport, IEM_GP);
                CheckButtonAndWriteBool(hDlg, IDC_DELCONNECT, IS_CONNECTSET, IK_DELETECONN, GetInsFile(hDlg));

                if (PathIsDirectoryEmpty(szWorkDir))
                    PathRemovePath(szWorkDir);

                SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        ShowHelpTopic(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK AutoconfigDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    TCHAR szAutoConfigURL[INTERNET_MAX_URL_LENGTH],
          szAutoProxyURL[INTERNET_MAX_URL_LENGTH],
          szAutoConfigTime[7];
    BOOL  fDetectConfig,
          fUseAutoConfig;

    switch (msg) {
    case WM_INITDIALOG:
    {
        SetPropSheetCookie(hDlg, lParam);

        // find out if this dlg is in RSoP mode
        psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        BOOL bIsRSoP = psCookie->pCS->IsRSoP();
        if (bIsRSoP)
        {
            CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
            if (pDRD)
                InitAutoConfigDlgInRSoPMode(hDlg, pDRD);
        }
        else
        {
            // warn the user that settings on this page will override imported connection settings
            if (InsGetBool(IS_CONNECTSET, IK_OPTION, FALSE, GetInsFile(hDlg)))
                ErrorMessageBox(hDlg, IDS_CONNECTSET_WARN);

            DisableDBCSChars(hDlg, IDE_AUTOCONFIGTIME);
        }

            EnableDBCSChars(hDlg, IDE_AUTOCONFIGURL);
            EnableDBCSChars(hDlg, IDE_AUTOPROXYURL);

        if (!bIsRSoP)
        {
            Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOCONFIGTIME), countof(szAutoConfigTime) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOCONFIGURL),  countof(szAutoConfigURL)  - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOPROXYURL),   countof(szAutoProxyURL)   - 1);
        }
        break;
    }

    case WM_DESTROY:
        if (psCookie->pCS->IsRSoP())
            DestroyDlgRSoPData(hDlg);
        break;

    case WM_COMMAND:
        if (BN_CLICKED != GET_WM_COMMAND_CMD(wParam, lParam))
            return FALSE;

        switch(GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_YESAUTOCON:
            fUseAutoConfig = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_YESAUTOCON));

            EnableDlgItem2(hDlg, IDE_AUTOCONFIGTIME,    fUseAutoConfig);
            EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT2,   fUseAutoConfig);
            EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT3,   fUseAutoConfig);
            EnableDlgItem2(hDlg, IDE_AUTOCONFIGURL,     fUseAutoConfig);
            EnableDlgItem2(hDlg, IDC_AUTOCONFIGURL_TXT, fUseAutoConfig);
            EnableDlgItem2(hDlg, IDE_AUTOPROXYURL,      fUseAutoConfig);
            EnableDlgItem2(hDlg, IDC_AUTOPROXYURL_TXT,  fUseAutoConfig);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_SETACTIVE:
            // don't do any of this stuff in RSoP mode
            if (!psCookie->pCS->IsRSoP())
            {
                fDetectConfig = InsGetBool(IS_URL, IK_DETECTCONFIG, TRUE, GetInsFile(hDlg));
                CheckDlgButton(hDlg, IDC_AUTODETECT, fDetectConfig  ? BST_CHECKED : BST_UNCHECKED);

                fUseAutoConfig = InsGetBool(IS_URL, IK_USEAUTOCONF,  FALSE, GetInsFile(hDlg));
                CheckDlgButton(hDlg, IDC_YESAUTOCON, fUseAutoConfig ? BST_CHECKED : BST_UNCHECKED);

                InsGetString(IS_URL, IK_AUTOCONFTIME, szAutoConfigTime, countof(szAutoConfigTime), GetInsFile(hDlg));
                SetDlgItemText(hDlg, IDE_AUTOCONFIGTIME, szAutoConfigTime);
                EnableDlgItem2(hDlg, IDE_AUTOCONFIGTIME, fUseAutoConfig);
                EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT2, fUseAutoConfig);
                EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT3, fUseAutoConfig);

                InsGetString(IS_URL, IK_AUTOCONFURL, szAutoConfigURL, countof(szAutoConfigURL), GetInsFile(hDlg));
                SetDlgItemText(hDlg, IDE_AUTOCONFIGURL, szAutoConfigURL);
                EnableDlgItem2(hDlg, IDE_AUTOCONFIGURL, fUseAutoConfig);
                EnableDlgItem2(hDlg, IDC_AUTOCONFIGURL_TXT, fUseAutoConfig);

                InsGetString(IS_URL, IK_AUTOCONFURLJS, szAutoProxyURL, countof(szAutoProxyURL), GetInsFile(hDlg));
                SetDlgItemText(hDlg, IDE_AUTOPROXYURL, szAutoProxyURL);
                EnableDlgItem2(hDlg, IDE_AUTOPROXYURL, fUseAutoConfig);
                EnableDlgItem2(hDlg, IDC_AUTOPROXYURL_TXT, fUseAutoConfig);
            }
            break;

        case PSN_HELP:
            ShowHelpTopic(hDlg);
            break;

        case PSN_APPLY:
            if (psCookie->pCS->IsRSoP())
                return FALSE;
            else
            {
                fDetectConfig  = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_AUTODETECT));
                fUseAutoConfig = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_YESAUTOCON));

                GetDlgItemText(hDlg, IDE_AUTOCONFIGTIME, szAutoConfigTime, countof(szAutoConfigTime));
                GetDlgItemText(hDlg, IDE_AUTOCONFIGURL,  szAutoConfigURL,  countof(szAutoConfigURL));
                GetDlgItemText(hDlg, IDE_AUTOPROXYURL,   szAutoProxyURL,   countof(szAutoProxyURL));

                // do error checking
                if (fUseAutoConfig) {
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDE_AUTOCONFIGTIME)) &&
                        !CheckField(hDlg, IDE_AUTOCONFIGTIME, FC_NUMBER)) {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }

                    if (*szAutoConfigURL == TEXT('\0') && *szAutoProxyURL == TEXT('\0')) {
                        ErrorMessageBox(hDlg, IDS_AUTOCONFIG_NULL);
                        SetFocus(GetDlgItem(hDlg, IDE_AUTOCONFIGURL));
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }

                    if (!CheckField(hDlg, IDE_AUTOCONFIGURL, FC_URL) ||
                        !CheckField(hDlg, IDE_AUTOPROXYURL,  FC_URL)) {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }
                }

                // write the values to the ins file
                if (!AcquireWriteCriticalSection(hDlg)) {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    break;
                }

                InsWriteBoolEx(IS_URL, IK_DETECTCONFIG,  fDetectConfig,    GetInsFile(hDlg));
                InsWriteBoolEx(IS_URL, IK_USEAUTOCONF,   fUseAutoConfig,   GetInsFile(hDlg));
                InsWriteString(IS_URL, IK_AUTOCONFTIME,  szAutoConfigTime, GetInsFile(hDlg));
                InsWriteString(IS_URL, IK_AUTOCONFURL,   szAutoConfigURL,  GetInsFile(hDlg));
                InsWriteString(IS_URL, IK_AUTOCONFURLJS, szAutoProxyURL,   GetInsFile(hDlg));

                SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        ShowHelpTopic(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK ProxyDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    TCHAR szProxy[MAX_PATH];
    PTSTR pszLocal;
    BOOL  fSameProxy,
          fUseProxy,
          fLocal;

    switch (msg) {
    case WM_INITDIALOG:
    {
        SetPropSheetCookie(hDlg, lParam);

        // find out if this dlg is in RSoP mode
        psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        BOOL bIsRSoP = psCookie->pCS->IsRSoP();
        if (bIsRSoP)
        {
            CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
            if (pDRD)
                InitProxyDlgInRSoPMode(hDlg, pDRD);
        }
        else
        {
            // warn the user that settings on this page will override imported connection settings
            if (InsGetBool(IS_CONNECTSET, IK_OPTION, FALSE, GetInsFile(hDlg)))
                ErrorMessageBox(hDlg, IDS_CONNECTSET_WARN);
        }

        EnableDBCSChars(hDlg, IDE_HTTPPROXY);
        EnableDBCSChars(hDlg, IDE_SECPROXY);
        EnableDBCSChars(hDlg, IDE_FTPPROXY);
        EnableDBCSChars(hDlg, IDE_GOPHERPROXY);
        EnableDBCSChars(hDlg, IDE_SOCKSPROXY);
        EnableDBCSChars(hDlg, IDE_DISPROXYADR);

        if (!bIsRSoP)
        {
            Edit_LimitText(GetDlgItem(hDlg, IDE_HTTPPORT),   5);
            Edit_LimitText(GetDlgItem(hDlg, IDE_FTPPORT),    5);
            Edit_LimitText(GetDlgItem(hDlg, IDE_GOPHERPORT), 5);
            Edit_LimitText(GetDlgItem(hDlg, IDE_SECPORT),    5);
            Edit_LimitText(GetDlgItem(hDlg, IDE_SOCKSPORT),  5);
            Edit_LimitText(GetDlgItem(hDlg, IDE_DISPROXYADR),(MAX_PATH - 11)); //size of <local>, etc
        }
        break;
    }

    case WM_DESTROY:
        if (psCookie->pCS->IsRSoP())
            DestroyDlgRSoPData(hDlg);
        break;

    case WM_COMMAND:
        fSameProxy = fUseProxy = fLocal = FALSE;
        if (BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam)) {
            fSameProxy = IsDlgButtonChecked(hDlg, IDC_SAMEFORALL);
            fUseProxy  = IsDlgButtonChecked(hDlg, IDC_YESPROXY);
            fLocal     = IsDlgButtonChecked(hDlg, IDC_DISPROXYLOCAL);
        }

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_SAMEFORALL:
            if (BN_CLICKED != GET_WM_COMMAND_CMD(wParam, lParam))
                return FALSE;

            GetProxyDlg(hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT);
            if (fSameProxy) {
                SetProxyDlg(hDlg, szProxy, IDE_HTTPPROXY,   IDE_HTTPPORT,   TRUE);
                SetProxyDlg(hDlg, szProxy, IDE_FTPPROXY,    IDE_FTPPORT,    TRUE);
                SetProxyDlg(hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE);
                SetProxyDlg(hDlg, szProxy, IDE_SECPROXY,    IDE_SECPORT,    TRUE);
                SetProxyDlg(hDlg, szProxy, IDE_SOCKSPROXY,  IDE_SOCKSPORT,  FALSE);
            }
            // fallthrough

        case IDC_YESPROXY:
            if (BN_CLICKED != GET_WM_COMMAND_CMD(wParam, lParam))
                return FALSE;

            pxyEnableDlgItems(hDlg, fSameProxy, fUseProxy);
            break;

        case IDE_HTTPPROXY:
        case IDE_HTTPPORT:
            if (EN_UPDATE != GET_WM_COMMAND_CMD(wParam, lParam))
                return FALSE;

            if (fSameProxy) {
                GetProxyDlg(hDlg, szProxy, IDE_HTTPPROXY,   IDE_HTTPPORT);

                SetProxyDlg(hDlg, szProxy, IDE_FTPPROXY,    IDE_FTPPORT,    TRUE);
                SetProxyDlg(hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE);
                SetProxyDlg(hDlg, szProxy, IDE_SECPROXY,    IDE_SECPORT,    TRUE);
                SetProxyDlg(hDlg, szProxy, IDE_SOCKSPROXY,  IDE_SOCKSPORT,  FALSE);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_SETACTIVE:
            // don't do any of this stuff in RSoP mode
            if (!psCookie->pCS->IsRSoP())
            {
                fUseProxy = InsGetBool(IS_PROXY, IK_PROXYENABLE, FALSE, GetInsFile(hDlg));
                CheckDlgButton(hDlg, IDC_YESPROXY, fUseProxy);

                fSameProxy = InsGetBool(IS_PROXY, IK_SAMEPROXY, TRUE, GetInsFile(hDlg));
                CheckDlgButton(hDlg, IDC_SAMEFORALL, fSameProxy);

                InsGetString(IS_PROXY, IK_HTTPPROXY, szProxy, countof(szProxy), GetInsFile(hDlg));

                if (fSameProxy) {
                    SetProxyDlg(hDlg, szProxy, IDE_HTTPPROXY,   IDE_HTTPPORT,   TRUE);
                    SetProxyDlg(hDlg, szProxy, IDE_FTPPROXY,    IDE_FTPPORT,    TRUE);
                    SetProxyDlg(hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE);
                    SetProxyDlg(hDlg, szProxy, IDE_SECPROXY,    IDE_SECPORT,    TRUE);
                    SetProxyDlg(hDlg, szProxy, IDE_SOCKSPROXY,  IDE_SOCKSPORT,  FALSE);
                }
                else {
                    SetProxyDlg(hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT, TRUE);

                    InsGetString(IS_PROXY, IK_FTPPROXY, szProxy, countof(szProxy), GetInsFile(hDlg));
                    SetProxyDlg(hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE);

                    InsGetString(IS_PROXY, IK_GOPHERPROXY, szProxy, countof(szProxy), GetInsFile(hDlg));
                    SetProxyDlg(hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE);

                    InsGetString(IS_PROXY, IK_SECPROXY, szProxy, countof(szProxy), GetInsFile(hDlg));
                    SetProxyDlg(hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE);

                    InsGetString(IS_PROXY, IK_SOCKSPROXY, szProxy, countof(szProxy), GetInsFile(hDlg));
                    if (TEXT('\0') != szProxy[0])
                        SetProxyDlg(hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE);
                }

                InsGetString(IS_PROXY, IK_PROXYOVERRIDE, szProxy, countof(szProxy), GetInsFile(hDlg));
                if (TEXT('\0') == szProxy[0])
                    StrCpy(szProxy, LOCALPROXY);

                pszLocal = StrStr(szProxy, LOCALPROXY);
                fLocal   = FALSE;
                if (NULL != pszLocal) {
                    if (pszLocal == szProxy) {
                        PTSTR pszSemicolon;

                        pszSemicolon = pszLocal + countof(LOCALPROXY)-1;
                        if (TEXT(';') == *pszSemicolon)
                            pszSemicolon++;

                        StrCpy(pszLocal, pszSemicolon);
                    }
                    else if (TEXT('\0') == *(pszLocal + countof(LOCALPROXY)-1))
                        *(pszLocal - 1) = TEXT('\0');

                    fLocal = TRUE;
                }
                CheckDlgButton(hDlg, IDC_DISPROXYLOCAL, fLocal);

                SetDlgItemText(hDlg, IDE_DISPROXYADR, szProxy);
                pxyEnableDlgItems(hDlg, fSameProxy, fUseProxy);
            }
            break;

        case PSN_HELP:
            ShowHelpTopic(hDlg);
            break;

        case PSN_APPLY:
            if (psCookie->pCS->IsRSoP())
                return FALSE;
            else
            {
                if (!CheckField(hDlg, IDE_HTTPPORT,   FC_NUMBER) ||
                    !CheckField(hDlg, IDE_FTPPORT,    FC_NUMBER) ||
                    !CheckField(hDlg, IDE_GOPHERPORT, FC_NUMBER) ||
                    !CheckField(hDlg, IDE_SECPORT,    FC_NUMBER) ||
                    !CheckField(hDlg, IDE_SOCKSPORT,  FC_NUMBER))
                    return TRUE;

                fUseProxy  = IsDlgButtonChecked(hDlg, IDC_YESPROXY);
                fSameProxy = IsDlgButtonChecked(hDlg, IDC_SAMEFORALL);
                fLocal     = IsDlgButtonChecked(hDlg, IDC_DISPROXYLOCAL);

                if (!AcquireWriteCriticalSection(hDlg)) {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    break;
                }

                InsWriteBoolEx(IS_PROXY, IK_PROXYENABLE, fUseProxy, GetInsFile(hDlg));

                GetProxyDlg(hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT);
                InsWriteString(IS_PROXY, IK_HTTPPROXY, szProxy, GetInsFile(hDlg));

                GetProxyDlg(hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT);
                InsWriteString(IS_PROXY, IK_FTPPROXY, szProxy, GetInsFile(hDlg));

                GetProxyDlg(hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT);
                InsWriteString(IS_PROXY, IK_GOPHERPROXY, szProxy, GetInsFile(hDlg));

                GetProxyDlg(hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT);
                InsWriteString(IS_PROXY, IK_SECPROXY, szProxy, GetInsFile(hDlg));

                GetProxyDlg(hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT);
                InsWriteString(IS_PROXY, IK_SOCKSPROXY, szProxy, GetInsFile(hDlg));

                InsWriteBoolEx(IS_PROXY, IK_SAMEPROXY, fSameProxy, GetInsFile(hDlg));

                GetDlgItemText(hDlg, IDE_DISPROXYADR, szProxy, countof(szProxy));
                if (fLocal) {
                    if (TEXT('\0') != szProxy[0]) {
                        TCHAR szAux[MAX_PATH];

                        StrRemoveAllWhiteSpace(szProxy);
                        wnsprintf(szAux, countof(szAux), TEXT("%s;%s"), szProxy, LOCALPROXY);
                        InsWriteQuotedString(IS_PROXY, IK_PROXYOVERRIDE, szAux, GetInsFile(hDlg));
                    }
                    else 
                        InsWriteString(IS_PROXY, IK_PROXYOVERRIDE, LOCALPROXY, GetInsFile(hDlg));
                }
                else
                    InsWriteString(IS_PROXY, IK_PROXYOVERRIDE, szProxy, GetInsFile(hDlg));

                SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        ShowHelpTopic(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

static void pxyEnableDlgItems(HWND hDlg, BOOL fSame, BOOL fUseProxy)
{
    EnableDlgItem2(hDlg, IDC_FTPPROXY1,     !fSame && fUseProxy);
    EnableDlgItem2(hDlg, IDE_FTPPROXY,      !fSame && fUseProxy);
    EnableDlgItem2(hDlg, IDE_FTPPORT,       !fSame && fUseProxy);
    EnableDlgItem2(hDlg, IDC_SECPROXY1,     !fSame && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SECPROXY,      !fSame && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SECPORT,       !fSame && fUseProxy);
    EnableDlgItem2(hDlg, IDC_GOPHERPROXY1,  !fSame && fUseProxy);
    EnableDlgItem2(hDlg, IDE_GOPHERPROXY,   !fSame && fUseProxy);
    EnableDlgItem2(hDlg, IDE_GOPHERPORT,    !fSame && fUseProxy);
    EnableDlgItem2(hDlg, IDC_SOCKSPROXY1,   !fSame && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SOCKSPROXY,    !fSame && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SOCKSPORT,     !fSame && fUseProxy);

    EnableDlgItem2(hDlg, IDC_HTTPPROXY1,    fUseProxy);
    EnableDlgItem2(hDlg, IDE_HTTPPROXY,     fUseProxy);
    EnableDlgItem2(hDlg, IDE_HTTPPORT,      fUseProxy);
    EnableDlgItem2(hDlg, IDC_DISPROXYADR1,  fUseProxy);
    EnableDlgItem2(hDlg, IDE_DISPROXYADR,   fUseProxy);
    EnableDlgItem2(hDlg, IDC_DISPROXYLOCAL, fUseProxy);
    EnableDlgItem2(hDlg, IDC_SAMEFORALL,    fUseProxy);
}

//*******************************************************************
// CODE FROM INETCPL
//*******************************************************************

/////////////////////////////////////////////////////////////////////
void InitImportedConnSettingsDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    __try
    {
        if (NULL != pDRD->ConnectToNamespace())
        {
            // get our stored precedence value
            DWORD dwCurGPOPrec = pDRD->GetImportedConnSettPrec();

            // create the object path of the program settings for this GPO
            WCHAR wszObjPath[128];
            wnsprintf(wszObjPath, countof(wszObjPath),
                        L"RSOP_IEConnectionSettings.rsopID=\"IEAK\",rsopPrecedence=%ld", dwCurGPOPrec);
            _bstr_t bstrObjPath = wszObjPath;

            // get the RSOP_IEProgramSettings object and its properties
            ComPtr<IWbemServices> pWbemServices = pDRD->GetWbemServices();
            ComPtr<IWbemClassObject> pPSObj = NULL;
            HRESULT hr = pWbemServices->GetObject(bstrObjPath, 0L, NULL, (IWbemClassObject**)&pPSObj, NULL);
            if (SUCCEEDED(hr))
            {
                // defaultDialUpConnection field
                _variant_t vtValue;
                _bstr_t bstrDefault;
                hr = pPSObj->Get(L"defaultDialUpConnection", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                {
                    bstrDefault = vtValue;
                    if (bstrDefault.length() > 0)
                        SetDlgItemText(hDlg, IDC_DIAL_DEF_ISP, (LPCTSTR)bstrDefault);
                }

                // dialUpState field
                hr = pPSObj->Get(L"dialUpState", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                {
                    if (1 == (long)vtValue)
                        CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, IDC_DIALUP_ON_NONET);
                    else if (2 == (long)vtValue)
                        CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, IDC_DIALUP);
                    else
                        CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, IDC_DIALUP_NEVER);
                }

                // dialUpConnections field
                hr = pPSObj->Get(L"dialUpConnections", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                {
                    HWND hwndTree = GetDlgItem(hDlg, IDC_CONN_LIST);
                    ASSERT(hwndTree);

                    // init tvi and tvins
                    TVITEM tvi;
                    TVINSERTSTRUCT tvins;
                    tvi.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
                    tvi.lParam = 0;

                    tvins.hInsertAfter = (HTREEITEM)TVI_SORT;
                    tvins.hParent = TVI_ROOT;

                    // clear list
                    TreeView_DeleteAllItems(hwndTree);

                    SAFEARRAY *psa = vtValue.parray;
                    //-------------------------------
                    // Get the upper and lower bounds of the Names array
                    long lLower = 0;
                    long lUpper = 0;
                    hr = SafeArrayGetLBound(psa, 1, &lLower);
                    if (SUCCEEDED(hr))
                        hr = SafeArrayGetUBound(psa, 1, &lUpper);

                    // check the case of no instances or a null array
                    if (SUCCEEDED(hr) && lUpper >= lLower)
                    {
                        _bstr_t bstrName;
                        HTREEITEM hFirst = NULL, hDefault = NULL;
                        for (long lItem = lLower; lItem <= lUpper; lItem++) 
                        {
                            BSTR bstrValue = NULL;
                            hr = SafeArrayGetElement(psa, &lItem, (void*)&bstrValue);
                            if (SUCCEEDED(hr))
                            {
                                bstrName = bstrValue;

                                tvi.pszText = (LPTSTR)(LPCTSTR)bstrName;
                                tvi.iImage = IMAGE_MODEM;
                                tvi.iSelectedImage = IMAGE_MODEM;
                                tvi.lParam = lItem;

                                tvins.item = tvi;
                                HTREEITEM hItem = TreeView_InsertItem(hwndTree, &tvins);
                                if (0 == lItem)
                                    hFirst = hItem;
                                if (NULL != hItem && bstrName == bstrDefault)
                                    hDefault = hItem;
                            }
                        }

                        // select default or first entry if there is one
                        if(NULL != hDefault)
                            TreeView_Select(hwndTree, hDefault, TVGN_CARET);
                        else if (NULL != hFirst)
                            TreeView_Select(hwndTree, hFirst, TVGN_CARET);
                    }
                }
            }
        }
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK importConnSettingsRSoPProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = FALSE;
    switch (uMsg) {
    case WM_INITDIALOG:
    {
        // create image list for tree view
        HIMAGELIST himl = ImageList_Create(BITMAP_WIDTH, BITMAP_HEIGHT, ILC_COLOR | ILC_MASK, CONN_BITMAPS, 4 );
        HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_LAN));
        ImageList_AddIcon(himl, hIcon);
        hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_PHONE));
        ImageList_AddIcon(himl, hIcon);

        TreeView_SetImageList(GetDlgItem(hDlg, IDC_CONN_LIST), himl, TVSIL_NORMAL);

        // init the data
        CDlgRSoPData *pDRD = (CDlgRSoPData*)((LPPROPSHEETPAGE)lParam)->lParam;
        InitImportedConnSettingsDlgInRSoPMode(hDlg, pDRD);

        // init other controls
        CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, IDC_DIALUP_NEVER);
        ShowWindow(GetDlgItem(hDlg, IDC_ENABLE_SECURITY), SW_HIDE); // only for 95 machines

        // disable everything
        EnableDlgItem2(hDlg, IDC_CONNECTION_WIZARD, FALSE);

        EnableDlgItem2(hDlg, IDC_DIALUP_ADD, FALSE);
        EnableDlgItem2(hDlg, IDC_DIALUP_REMOVE, FALSE);
        EnableDlgItem2(hDlg, IDC_MODEM_SETTINGS, FALSE);

        EnableDlgItem2(hDlg, IDC_DIALUP_NEVER, FALSE);
        EnableDlgItem2(hDlg, IDC_DIALUP_ON_NONET, FALSE);
        EnableDlgItem2(hDlg, IDC_DIALUP, FALSE);

        EnableDlgItem2(hDlg, IDC_SET_DEFAULT, FALSE);
        EnableDlgItem2(hDlg, IDC_ENABLE_SECURITY, FALSE);
        EnableDlgItem2(hDlg, IDC_CON_SHARING, FALSE);
        EnableDlgItem2(hDlg, IDC_LAN_SETTINGS, FALSE);

        fResult = TRUE;
        break;
    }

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            EndDialog(hDlg, IDOK);
            fResult = TRUE;
            break;

        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            fResult = TRUE;
            break;
        }
        break;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\layout.cpp ===
#include "precomp.h"

// {2D0A4070-FB48-11d1-8722-00A0C9B0EB4F}
DEFINE_GUID(NODEID_IEAKSnapinExtNameSpace, 0x2d0a4070, 0xfb48, 0x11d1, 0x87, 0x22, 0x0, 0xa0, 0xc9, 0xb0, 0xeb, 0x4f);

//
// Result pane items for the nodes with no result pane items
//
RESULTITEM g_ResultUndefined[] =
{
    { 1, 0, 0, 0, NULL, NULL, 0, NULL }
};

//
// Result pane items for the Browser UI Settings node
//
RESULTITEM g_ResultBrowser[] =
{
    { 1, IDS_BTITLE,     -1,                IDS_BTITLE_DESC,    IDD_BTITLE,    1, NULL, NULL, 
        NULL,             TitleDlgProc,     TEXT("wiz4_0.htm")  },
    { 1, IDS_CUSTICON2,  -1,                IDS_CUSTICON_DESC,  IDD_CUSTICON,  1, NULL, NULL,
        NULL,             LogoDlgProc,      TEXT("wiz4_1.htm") },
    { 1, IDS_BTOOLBAR,   IDS_BTOOLBAR_PREF, IDS_BTOOLBAR_DESC,  IDD_BTOOLBARS, 1, NULL, NULL,
        NULL,             BToolbarsDlgProc, TEXT("wiz4_0a.htm") }
};

//
// Result pane items for the Connection Settings node
//
RESULTITEM g_ResultConnection[] =
{
    { 2, IDS_CONNECTSET,      IDS_CONNECTSET_PREF,      IDS_CONNECTSET_DESC,      IDD_CONNECTSET, 
        2, NULL, NULL, NULL,              ConnectSetDlgProc, TEXT("wiz4_11.htm") },
    { 2, IDS_QUERYAUTOCONFIG, IDS_QUERYAUTOCONFIG_PREF, IDS_QUERYAUTOCONFIG_DESC, IDD_QUERYAUTOCONFIG, 
        2, NULL, NULL, NULL,              AutoconfigDlgProc, TEXT("wiz4_10.htm") },
    { 2, IDS_PROXY2,          IDS_PROXY_PREF,           IDS_PROXY_DESC,           IDD_PROXY,           
        2, NULL, NULL, NULL,              ProxyDlgProc,      TEXT("wiz4_12.htm") },
    { 2, IDS_UASTRDLG2,       -1,                       IDS_UASTRDLG_DESC,        IDD_UASTRDLG,
        2, NULL, NULL, NULL,              UserAgentDlgProc,  TEXT("wiz4_9.htm")  }
};

//
// Result pane items for the URLs node
//
RESULTITEM g_ResultUrls[] =
{
    { 3, IDS_FAVORITES2,   IDS_FAVORITES_PREF,  IDS_FAVORITES_DESC,   IDD_FAVORITES,   3, 
        NULL, NULL, NULL,             FavoritesDlgProc, TEXT("wiz4_3.htm") },
    { 3, IDS_STARTSEARCH2, IDS_STARTSEARCH_PREF,IDS_STARTSEARCH_DESC, IDD_STARTSEARCH, 3, 
        NULL, NULL, NULL,             UrlsDlgProc,      TEXT("wiz4_2.htm") }
};

//
// Result pane items for the Security node
//
RESULTITEM g_ResultSecurity[] =
{
    { 4, IDS_SECURITY,     IDS_SECURITY_PREF,       IDS_SECURITY_DESC, IDD_SECURITY1,    4, 
        NULL, NULL, NULL,             SecurityZonesDlgProc, TEXT("wiz4_17.htm") },
    { 4, IDS_SECURITYAUTH, IDS_SECURITYAUTH_PREF,   IDS_AUTHCODE_DESC, IDD_SECURITYAUTH, 4, 
        NULL, NULL, NULL,             SecurityAuthDlgProc,  TEXT("wiz4_16.htm") }
};

//
// Result pane items for the Programs node
//
RESULTITEM g_ResultPrograms[] =
{
    { 5, IDS_PROGRAMS, IDS_PROGRAMS_PREF, IDS_PROGRAMS_DESC, IDD_PROGRAMS, 5, NULL, NULL, NULL,
                  ProgramsDlgProc, TEXT("wiz5_0a.htm ") }
};

//
// Namespace (scope) items
/*  structure prototype for easy reference
typedef struct _NAMESPACEITEM
{
    DWORD           dwParent;
    INT             iNameID;
    INT             iDescID;
    LPTSTR          pszName;
    LPTSTR          pszDesc;
    INT             cChildren;
    INT             cResultItems;
    LPRESULTITEM    pResultItems;
    const GUID      *pNodeID;
} NAMESPACEITEM,    *LPNAMESPACEITEM;
//
// Be sure to update NUM_NAMESPACE_ITEMS define in layout.h if you add / remove from this
// array and leave IDS_ADMGRP_NAME as the last name space item
*/

NAMESPACEITEM g_NameSpace[] =
{
    { (DWORD)-1, IDS_SIE_NAME, IDS_SIE_DESC, NULL, NULL, 1,
      0, g_ResultUndefined, &NODEID_IEAKSnapinExtNameSpace },                            // Root
    { 0, IDS_BROWSERGRP_NAME, IDS_BROWSERGRP_DESC, NULL, NULL, 0,
      countof(g_ResultBrowser), g_ResultBrowser, &NODEID_IEAKSnapinExtNameSpace },       // Browser UI
    { 0, IDS_CONNGRP_NAME, IDS_CONNGRP_DESC, NULL, NULL, 0,
      countof(g_ResultConnection), g_ResultConnection, &NODEID_IEAKSnapinExtNameSpace }, // Connection Settings
    { 0, IDS_URLSGRP_NAME, IDS_URLSGRP_DESC, NULL, NULL, 0,
      countof(g_ResultUrls), g_ResultUrls,  &NODEID_IEAKSnapinExtNameSpace },            // Urls
    { 0, IDS_SECURITYGRP_NAME, IDS_SECURITYGRP_DESC, NULL, NULL, 0,
      countof(g_ResultSecurity), g_ResultSecurity, &NODEID_IEAKSnapinExtNameSpace },     // Security
    { 0, IDS_PROGGRP_NAME, IDS_PROGGRP_DESC, NULL, NULL, 0,
      countof(g_ResultPrograms), g_ResultPrograms, &NODEID_IEAKSnapinExtNameSpace },     // Programs
    { 0, IDS_ADMGRP_NAME, IDS_ADMGRP_DESC, NULL, NULL, 0,
      0, NULL, &NODEID_IEAKSnapinExtNameSpace }                                          // Adms
};


// private forward declarations

static void cleanUpResultItemsArray(LPRESULTITEM lpResultItemArray, INT cResultItems);

// exported functions

BOOL CreateBufandLoadString(HINSTANCE hInst, INT iResId, LPTSTR * ppGlobalStr,
                            LPTSTR * ppMMCStrPtr, DWORD cchMax)
{
    TCHAR szBuffer[MAX_PATH];
    BOOL  fRet = FALSE;

    UNREFERENCED_PARAMETER(cchMax);
    ASSERT(cchMax <= countof(szBuffer));

    EnterCriticalSection(&g_LayoutCriticalSection);

    if (*ppGlobalStr == NULL)
    {
        if (LoadString(hInst, iResId, szBuffer, cchMax) != 0)
        {
            if ((*ppGlobalStr = (LPTSTR)CoTaskMemAlloc(StrCbFromSz(szBuffer))) != NULL)
            {
                StrCpy(*ppGlobalStr, szBuffer);
                fRet = TRUE;
            }
        }
    }

    *ppMMCStrPtr = *ppGlobalStr;

    LeaveCriticalSection(&g_LayoutCriticalSection);
    return fRet;
}

void CleanUpGlobalArrays()
{
    EnterCriticalSection(&g_LayoutCriticalSection);

    for (int i = 0; i < NUM_NAMESPACE_ITEMS; i++)
    {
        if (g_NameSpace[i].pResultItems != NULL)
            cleanUpResultItemsArray(g_NameSpace[i].pResultItems, g_NameSpace[i].cResultItems);

        if (g_NameSpace[i].pszName != NULL)
        {
            CoTaskMemFree(g_NameSpace[i].pszName);
            g_NameSpace[i].pszName = NULL;
        }

        if (g_NameSpace[i].pszDesc != NULL)
        {
            CoTaskMemFree(g_NameSpace[i].pszDesc);
            g_NameSpace[i].pszDesc = NULL;
        }
    }

    if (g_NameSpace[ADM_NAMESPACE_ITEM].pResultItems != NULL)
    {
        CoTaskMemFree(g_NameSpace[ADM_NAMESPACE_ITEM].pResultItems);
        g_NameSpace[ADM_NAMESPACE_ITEM].pResultItems = NULL;
    }

    LeaveCriticalSection(&g_LayoutCriticalSection);
}

void DeleteCookieList(LPIEAKMMCCOOKIE lpCookieList)
{
    if (lpCookieList != NULL)
    {
        LPIEAKMMCCOOKIE lpCookiePtr1, lpCookiePtr2;

        for (lpCookiePtr1 = lpCookieList, lpCookiePtr2 = lpCookiePtr1->pNext; 
             (lpCookiePtr2 != NULL); 
             lpCookiePtr1 = lpCookiePtr2, lpCookiePtr2 = lpCookiePtr1->pNext)
            CoTaskMemFree(lpCookiePtr1);

        CoTaskMemFree(lpCookiePtr1);
    }
}

void AddItemToCookieList(LPIEAKMMCCOOKIE *ppCookieList, LPIEAKMMCCOOKIE lpCookieItem)
{
    if (*ppCookieList == NULL)
        *ppCookieList = lpCookieItem;
    else
    {
        LPIEAKMMCCOOKIE lpCookieList = *ppCookieList;

        while (lpCookieList->pNext != NULL)
            lpCookieList = lpCookieList->pNext;

        lpCookieList->pNext = lpCookieItem;
    }
}
// private helper functions

static void cleanUpResultItemsArray(LPRESULTITEM lpResultItemArray, INT cResultItems)
{
    for (int i = 0; i < cResultItems; i++)
    {
        if (lpResultItemArray[i].pszName != NULL)
        {
            CoTaskMemFree(lpResultItemArray[i].pszName);
            lpResultItemArray[i].pszName = NULL;
        }

        if (lpResultItemArray[i].pszNamePref != NULL)
        {
            CoTaskMemFree(lpResultItemArray[i].pszNamePref);
            lpResultItemArray[i].pszNamePref = NULL;
        }

        if (lpResultItemArray[i].pszDesc != NULL)
        {
            CoTaskMemFree(lpResultItemArray[i].pszDesc);
            lpResultItemArray[i].pszDesc = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\ieaksie.cpp ===
#include "precomp.h"

//
// Global variables for this DLL
//

LONG g_cRefThisDll = 0;
HINSTANCE g_hInstance;
HINSTANCE g_hUIInstance;
CRITICAL_SECTION g_LayoutCriticalSection;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
       g_hInstance = hInstance;
       if ((g_hUIInstance = LoadLibrary(TEXT("ieakui.dll"))) == NULL)
           return FALSE;

       DisableThreadLibraryCalls(hInstance);
       InitializeCriticalSection(&g_LayoutCriticalSection);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        CleanUpGlobalArrays();

        if (g_hUIInstance != NULL)
        {
            FreeLibrary(g_hUIInstance);
            g_hUIInstance = NULL;
        }

        DeleteCriticalSection(&g_LayoutCriticalSection);
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return (CreateComponentDataClassFactory (rclsid, riid, ppv));
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

const TCHAR c_szSnapInLocation[] = TEXT("%SystemRoot%\\System32\\ieaksie.dll");
const TCHAR c_szThreadingModel[] = TEXT("Apartment");

STDAPI DllRegisterServer(void)
{
    TCHAR szSnapInKey[64];
    TCHAR szRSoPSnapInKey[64];
    TCHAR szSubKey[MAX_PATH];
    TCHAR szName[128];
    TCHAR szNameIndirect[MAX_PATH];
    TCHAR szRSoPName[128];
    TCHAR szGUID[64];
    DWORD dwDisp, dwIndex;
    LONG lResult;
    HKEY hKey;


    //
    // Register Help About
    //

    StringFromGUID2(CLSID_AboutIEAKSnapinExt, szGUID, countof(szGUID));
    LoadString(g_hInstance, IDS_ABOUT_NAME, szName, countof(szName));
    wnsprintf(szSubKey, countof(szSubKey), TEXT("CLSID\\%s"), szGUID);
    lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                             &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) 
        return SELFREG_E_CLASS;

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szName, (DWORD)StrCbFromSz(szName));

    RegCloseKey (hKey);


    wnsprintf(szSubKey, countof(szSubKey), TEXT("CLSID\\%s\\InProcServer32"), szGUID);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)c_szSnapInLocation, (DWORD)StrCbFromSz(c_szSnapInLocation));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)c_szThreadingModel,
        (DWORD)StrCbFromSz(c_szThreadingModel));

    RegCloseKey (hKey);

    StringFromGUID2(CLSID_IEAKSnapinExt, szSnapInKey, countof(szSnapInKey));
        StringFromGUID2(CLSID_IEAKRSoPSnapinExt, szRSoPSnapInKey, countof(szRSoPSnapInKey));

    //
    // Register SnapIn in HKEY_CLASSES_ROOT
    //

    LoadString (g_hInstance, IDS_SIE_NAME, szName, 100);
    LoadString(g_hInstance,  IDS_NAME_INDIRECT, szNameIndirect, countof(szNameIndirect));
    wnsprintf (szSubKey, countof(szSubKey), TEXT("CLSID\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szName, (DWORD)StrCbFromSz(szName));

    RegCloseKey (hKey);


    wnsprintf (szSubKey, countof(szSubKey), TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)c_szSnapInLocation, (DWORD)StrCbFromSz(c_szSnapInLocation));

    RegCloseKey (hKey);



    //
    // Register RSoP SnapIn in HKEY_CLASSES_ROOT
    //

    StrCpy (szRSoPName, szName);
    StrCat (szRSoPName, TEXT(" - RSoP"));
    wnsprintf (szSubKey, countof(szSubKey), TEXT("CLSID\\%s"), szRSoPSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szRSoPName, (DWORD)StrCbFromSz(szRSoPName));
    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)c_szThreadingModel,
        (DWORD)StrCbFromSz(c_szThreadingModel));

    RegCloseKey (hKey);


    wnsprintf (szSubKey, countof(szSubKey), TEXT("CLSID\\%s\\InProcServer32"), szRSoPSnapInKey);
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)c_szSnapInLocation, (DWORD)StrCbFromSz(c_szSnapInLocation));

    RegCloseKey (hKey);



    //
    // Register SnapIn with MMC
    //

    wnsprintf (szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szName, (DWORD)StrCbFromSz(szName));

    //kirstenf: namestringindirect needs to be set for MUI support (Bug 17944)
    RegSetValueEx (hKey, TEXT("NameStringIndirect"),0,REG_SZ,(LPBYTE)szNameIndirect,(DWORD)StrCbFromSz(szNameIndirect));

    RegSetValueEx (hKey, TEXT("About"), 0, REG_SZ, (LPBYTE) szGUID, (DWORD)StrCbFromSz(szGUID));

    RegCloseKey (hKey);


    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2(*g_NameSpace[dwIndex].pNodeID, szGUID, countof(szGUID));

        wnsprintf (szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
                  szSnapInKey, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS)
            return SELFREG_E_CLASS;

        RegCloseKey (hKey);
    }


    //
    // Register RSoP SnapIn with MMC
    //

    wnsprintf (szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szRSoPSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szName, (DWORD)StrCbFromSz(szName));
    
    //kirstenf: namestringindirect needs to be set for MUI support (Bug 17944)
    RegSetValueEx (hKey, TEXT("NameStringIndirect"),0,REG_SZ,(LPBYTE)szNameIndirect,(DWORD)StrCbFromSz(szNameIndirect));

    StringFromGUID2(CLSID_AboutIEAKSnapinExt, szGUID, countof(szGUID));
    RegSetValueEx (hKey, TEXT("About"), 0, REG_SZ, (LPBYTE) szGUID, (DWORD)StrCbFromSz(szGUID));

    RegCloseKey (hKey);


    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2(*g_NameSpace[dwIndex].pNodeID, szGUID, countof(szGUID));

        wnsprintf (szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
                  szSnapInKey, szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS)
            return SELFREG_E_CLASS;

        RegCloseKey (hKey);
    }


    //
    // Register in the NodeTypes key
    //

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2(*g_NameSpace[dwIndex].pNodeID, szGUID, countof(szGUID));

        wnsprintf (szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS)
            return SELFREG_E_CLASS;

        RegCloseKey (hKey);
    }


    //
    // Register as an extension for various nodes
    //

    StringFromGUID2(NODEID_User, szGUID, countof(szGUID));

    wnsprintf (szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szName, (DWORD)StrCbFromSz(szName));

    RegCloseKey (hKey);

    //
    // Register RSoP as an extension for various nodes
    //

    StringFromGUID2(NODEID_RSOPUser, szGUID, countof(szGUID));

    wnsprintf (szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueEx (hKey, szRSoPSnapInKey, 0, REG_SZ, (LPBYTE)szName, (DWORD)StrCbFromSz(szName));

    RegCloseKey (hKey);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    TCHAR szSnapInKey[50];
    TCHAR szRSoPSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    DWORD dwIndex;

    StringFromGUID2(CLSID_AboutIEAKSnapinExt, szSnapInKey, countof(szSnapInKey));

    wnsprintf(szSubKey, countof(szSubKey), TEXT("CLSID\\%s"), szSnapInKey);
    SHDeleteKey(HKEY_CLASSES_ROOT, szSubKey);

    StringFromGUID2(CLSID_IEAKSnapinExt, szSnapInKey, countof(szSnapInKey));

    wnsprintf(szSubKey, countof(szSubKey), TEXT("CLSID\\%s"), szSnapInKey);
    SHDeleteKey(HKEY_CLASSES_ROOT, szSubKey);

    StringFromGUID2(CLSID_IEAKRSoPSnapinExt, szRSoPSnapInKey, countof(szRSoPSnapInKey));

    wnsprintf(szSubKey, countof(szSubKey), TEXT("CLSID\\%s"), szRSoPSnapInKey);
    SHDeleteKey(HKEY_CLASSES_ROOT, szSubKey);

    wnsprintf(szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    SHDeleteKey(HKEY_LOCAL_MACHINE, szSubKey);

    wnsprintf(szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szRSoPSnapInKey);
    SHDeleteKey(HKEY_LOCAL_MACHINE, szSubKey);

    for (dwIndex = 0; dwIndex < NUM_NAMESPACE_ITEMS; dwIndex++)
    {
        StringFromGUID2(*g_NameSpace[dwIndex].pNodeID, szGUID, countof(szGUID));
        wnsprintf(szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
        SHDeleteKey(HKEY_LOCAL_MACHINE, szSubKey);
    }


    StringFromGUID2(NODEID_User, szGUID, countof(szGUID));
    wnsprintf(szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    SHDeleteValue(HKEY_LOCAL_MACHINE, szSubKey, szSnapInKey);

    StringFromGUID2(NODEID_RSOPUser, szGUID, countof(szGUID));
    wnsprintf(szSubKey, countof(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    SHDeleteValue(HKEY_LOCAL_MACHINE, szSubKey, szRSoPSnapInKey);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\dataobj.cpp ===
#include "precomp.h"


unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject implementation                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CDataObject::CDataObject(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CDataObject::~CDataObject()
{
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IIEAKDataObject))
    {
        *ppv = (LPIEAKDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (IDataObject)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CDataObject object implementation (Internal functions)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
    {
        LPRESULTITEM lpResultItem = (LPRESULTITEM)((LPIEAKMMCCOOKIE)m_cookie)->lpItem;
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    }
    else
        pGUID = g_NameSpace[PtrToUlong(((LPIEAKMMCCOOKIE)m_cookie)->lpItem)].pNodeID;

    // Create the node type object in GUID format
    return Create((LPVOID)pGUID, sizeof(GUID), lpMedium);

}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
    {
        LPRESULTITEM lpResultItem = (LPRESULTITEM)((LPIEAKMMCCOOKIE)m_cookie)->lpItem;
        pGUID = g_NameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    }
    else
        pGUID = g_NameSpace[PtrToUlong(((LPIEAKMMCCOOKIE)m_cookie)->lpItem)].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2(*pGUID, szNodeType, ARRAYSIZE(szNodeType));

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    TCHAR  szDisplayName[100];

    LoadString(g_hInstance, IDS_SIE_NAME, szDisplayName, ARRAYSIZE(szDisplayName));

    return Create((LPVOID)szDisplayName, (lstrlen(szDisplayName) + 1) * sizeof(TCHAR), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
	if (m_pcd->IsRSoP())
		return Create((LPVOID)&CLSID_IEAKRSoPSnapinExt, sizeof(CLSID), lpMedium);
	else
		return Create((LPVOID)&CLSID_IEAKSnapinExt, sizeof(CLSID), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\dataobj.h ===
//
// IID_IIEAKDataObject interface id
//

// {C14C50E2-FA21-11d0-8CF9-C64377000000}
DEFINE_GUID(IID_IIEAKDataObject,0xc14c50e2, 0xfa21, 0x11d0, 0x8c, 0xf9, 0xc6, 0x43, 0x77, 0x0, 0x0, 0x0);




#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

//
// This is a private dataobject interface for our extension.
// When the IEAK snapin extension receives a dataobject and needs to determine
// if it came from the IEAK snapin extension or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IIEAKDataObject
DECLARE_INTERFACE_(IIEAKDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IIEAKDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ MMC_COOKIE cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ MMC_COOKIE *cookie) PURE;
};
typedef IIEAKDataObject *LPIEAKDATAOBJECT;



//
// CDataObject class
//

class CDataObject : public IDataObject,
                    public IIEAKDataObject
{
    friend class CSnapIn;

protected:

    ULONG                  m_cRef;
    CComponentData        *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    MMC_COOKIE             m_cookie;

    //
    // Clipboard formats that are required by the console
    //

    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;



public:
    CDataObject(CComponentData *pComponent);
    ~CDataObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IDataObject methods
    //

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);


    //
    // Unimplemented IDataObject methods
    //

    STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM)
    { return E_NOTIMPL; };

    STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*)
    { return E_NOTIMPL; };


    //
    // Implemented IIEAKDataObject methods
    //

    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (MMC_COOKIE cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (MMC_COOKIE *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\layout.h ===
#include "ieaksie.h"

#define NUM_NAMESPACE_ITEMS       7
#define ADM_NAMESPACE_ITEM        NUM_NAMESPACE_ITEMS - 1

typedef struct _NAMESPACEITEM
{
    DWORD           dwParent;
    INT             iNameID;
    INT             iDescID;
    LPTSTR          pszName;
    LPTSTR          pszDesc;
    INT             cChildren;
    INT             cResultItems;
    LPRESULTITEM    pResultItems;
    const GUID      *pNodeID;
} NAMESPACEITEM,    *LPNAMESPACEITEM;

typedef struct _IEAKMMCCOOKIE
{
    LPVOID                  lpItem;
    LPVOID                  lpParentItem;
    struct _IEAKMMCCOOKIE   *pNext;
} IEAKMMCCOOKIE,    *LPIEAKMMCCOOKIE;

extern NAMESPACEITEM g_NameSpace[];

BOOL CreateBufandLoadString(HINSTANCE hInst, INT iResId, LPTSTR * ppGlobalStr,
                            LPTSTR * ppMMCStrPtr, DWORD cchMax);
void CleanUpGlobalArrays();

void DeleteCookieList(LPIEAKMMCCOOKIE lpCookieList);
void AddItemToCookieList(LPIEAKMMCCOOKIE *ppCookieList, LPIEAKMMCCOOKIE lpCookieItem);

// Property Sheet Handler functions
INT_PTR CALLBACK TitleDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK BToolbarsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

// favs.cpp
INT_PTR CALLBACK FavoritesDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

// cs.cpp
INT_PTR CALLBACK ConnectSetDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AutoconfigDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ProxyDlgProc     (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

// urls.cpp
INT_PTR CALLBACK UrlsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

// programs.cpp
INT_PTR CALLBACK ProgramsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AdmDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LogoDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK UserAgentDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

// seczones.cpp
INT_PTR CALLBACK SecurityZonesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// secauth.cpp
INT_PTR CALLBACK SecurityAuthDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\logo.cpp ===
#include "precomp.h"

#include <comdef.h>
#include "rsop.h"

///////////////////////////////////////////////////////////
void InitLogoDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();

            BOOL bCustomLogoHandled = FALSE;
            BOOL bBrandAnimHandled = FALSE;
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                // customizeLogoBitmaps field
                if (!bCustomLogoHandled)
                {
                    _variant_t vtValue;
                    hr = paPSObj[nObj]->pObj->Get(L"customizeAnimatedBitmaps", 0, &vtValue, NULL, NULL);
                    BOOL fBrandAnim = FALSE;
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        fBrandAnim = vtValue.boolVal ? TRUE : FALSE;
                        bBrandAnimHandled = TRUE;
                    }

                    if (fBrandAnim)
                    {
                        CheckDlgButton(hDlg, IDC_ANIMBITMAP, BST_CHECKED);

                        // smallAnimatedBitmapPath field
                        hr = paPSObj[nObj]->pObj->Get(L"smallAnimatedBitmapPath", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            _bstr_t bstrVal = vtValue;
                            SetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, (LPCTSTR)bstrVal);
                        }

                        // largeAnimatedBitmapPath field
                        hr = paPSObj[nObj]->pObj->Get(L"largeAnimatedBitmapPath", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            _bstr_t bstrVal = vtValue;
                            SetDlgItemText(hDlg, IDE_BIGANIMBITMAP, (LPCTSTR)bstrVal);
                        }
                    }

                    hr = paPSObj[nObj]->pObj->Get(L"customizeLogoBitmaps", 0, &vtValue, NULL, NULL);
                    BOOL fBrandBmps = FALSE;
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        fBrandBmps = vtValue.boolVal ? TRUE : FALSE;
                        bCustomLogoHandled = TRUE;
                    }

                    if (fBrandBmps)
                    {
                        CheckDlgButton(hDlg, IDC_BITMAPCHECK, BST_CHECKED);

                        // smallCustomLogoBitmapPath field
                        hr = paPSObj[nObj]->pObj->Get(L"smallCustomLogoBitmapPath", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            _bstr_t bstrVal = vtValue;
                            SetDlgItemText(hDlg, IDC_BITMAP2, (LPCTSTR)bstrVal);
                        }

                        // largeCustomLogoBitmapPath field
                        hr = paPSObj[nObj]->pObj->Get(L"largeCustomLogoBitmapPath", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            _bstr_t bstrVal = vtValue;
                            SetDlgItemText(hDlg, IDC_BITMAP, (LPCTSTR)bstrVal);
                        }
                    }
                }

                // no need to process other GPOs since enabled properties have been found
                if (bCustomLogoHandled && bBrandAnimHandled)
                    break;
            }
        }
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
HRESULT InitSmallLogoPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    return InitGenericPrecedencePage(pDRD, hwndList, L"smallCustomLogoBitmapPath");
}

/////////////////////////////////////////////////////////////////////
HRESULT InitLargeLogoPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    return InitGenericPrecedencePage(pDRD, hwndList, L"largeCustomLogoBitmapPath");
}

/////////////////////////////////////////////////////////////////////
HRESULT InitSmallBmpPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    return InitGenericPrecedencePage(pDRD, hwndList, L"smallAnimatedBitmapPath");
}

/////////////////////////////////////////////////////////////////////
HRESULT InitLargeBmpPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    return InitGenericPrecedencePage(pDRD, hwndList, L"largeAnimatedBitmapPath");
}

///////////////////////////////////////////////////////////
void DisplayBitmap(HWND hControl, LPCTSTR pcszFileName, int nBitmapId)
{
    HANDLE hBmp = (HANDLE) GetWindowLongPtr(hControl, GWLP_USERDATA);
    
    if(ISNONNULL(pcszFileName) && PathFileExists(pcszFileName))
        ShowBitmap(hControl, pcszFileName, 0, &hBmp);
    else
        ShowBitmap(hControl, TEXT(""), nBitmapId, &hBmp);

    SetWindowLongPtr(hControl, GWLP_USERDATA, (LONG_PTR)hBmp);
}

///////////////////////////////////////////////////////////
void ReleaseBitmap(HWND hControl)
{
    HANDLE hBmp = (HANDLE) GetWindowLongPtr(hControl, GWLP_USERDATA);

    if (hBmp)
        DeleteObject(hBmp);
}

///////////////////////////////////////////////////////////
INT_PTR CALLBACK LogoDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    TCHAR szLargeBmp[MAX_PATH];
    TCHAR szSmallBmp[MAX_PATH];
    TCHAR szLargeAnimBmp[MAX_PATH];
    TCHAR szSmallAnimBmp[MAX_PATH];
    TCHAR szWorkDir[MAX_PATH];
    BOOL  fBrandBmps,fBrandAnim;;
    int   nStatus;

    switch(msg)
    {
    case WM_SETFONT:
        //a change to mmc requires us to do this logic for all our property pages that use common controls
        INITCOMMONCONTROLSEX iccx;
        iccx.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccx.dwICC = ICC_ANIMATE_CLASS  | ICC_BAR_CLASSES  | ICC_LISTVIEW_CLASSES  |ICC_TREEVIEW_CLASSES;
        InitCommonControlsEx(&iccx);
        break;

    case WM_INITDIALOG:
        SetPropSheetCookie(hDlg, lParam);

        EnableDBCSChars(hDlg, IDC_BITMAP);
        EnableDBCSChars(hDlg, IDC_BITMAP2);

        // find out if this dlg is in RSoP mode
        psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        if (psCookie->pCS->IsRSoP())
        {
            EnableDlgItem2(hDlg, IDC_BITMAPCHECK, FALSE);
            EnableDlgItem2(hDlg, IDC_BITMAP2, FALSE);
            EnableDlgItem2(hDlg, IDC_BROWSEICON2, FALSE);
            EnableDlgItem2(hDlg, IDC_BITMAP, FALSE);
            EnableDlgItem2(hDlg, IDC_BROWSEICON, FALSE);

            EnableDlgItem2(hDlg, IDC_ANIMBITMAP, FALSE);
            EnableDlgItem2(hDlg, IDC_BROWSEBIG, FALSE);
            EnableDlgItem2(hDlg, IDE_BIGANIMBITMAP, FALSE);
            EnableDlgItem2(hDlg, IDC_BROWSESMALL, FALSE);
            EnableDlgItem2(hDlg, IDE_SMALLANIMBITMAP, FALSE);

            CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
            
            if (pDRD != NULL)
                InitLogoDlgInRSoPMode(hDlg, pDRD);
        }
        else
        {
            EnableDBCSChars(hDlg, IDE_SMALLANIMBITMAP);
            EnableDBCSChars(hDlg, IDE_BIGANIMBITMAP);

            Edit_LimitText(GetDlgItem(hDlg, IDE_SMALLANIMBITMAP), countof(szSmallAnimBmp) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_BIGANIMBITMAP), countof(szLargeAnimBmp) - 1);

            Edit_LimitText(GetDlgItem(hDlg, IDC_BITMAP), countof(szLargeBmp) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDC_BITMAP2), countof(szSmallBmp) - 1);
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
                case IDC_BROWSEBIG:
                    GetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szLargeAnimBmp, countof(szLargeAnimBmp));
                    if(BrowseForFile(hDlg, szLargeAnimBmp, countof(szLargeAnimBmp), GFN_BMP))
                        SetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szLargeAnimBmp);
                    break;

                case IDC_BROWSESMALL:
                    GetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmallAnimBmp, countof(szSmallAnimBmp));
                    if(BrowseForFile(hDlg, szSmallAnimBmp, countof(szSmallAnimBmp), GFN_BMP))
                        SetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmallAnimBmp);
                    break;

                case IDC_ANIMBITMAP:
                    fBrandAnim = (IsDlgButtonChecked(hDlg, IDC_ANIMBITMAP) == BST_CHECKED);
                    EnableDlgItem2(hDlg, IDE_BIGANIMBITMAP, fBrandAnim);
                    EnableDlgItem2(hDlg, IDC_BROWSEBIG, fBrandAnim);
                    EnableDlgItem2(hDlg, IDC_BIGANIMBITMAP_TXT, fBrandAnim);
                    EnableDlgItem2(hDlg, IDE_SMALLANIMBITMAP, fBrandAnim);
                    EnableDlgItem2(hDlg, IDC_BROWSESMALL, fBrandAnim);
                    EnableDlgItem2(hDlg, IDC_SMALLANIMBITMAP_TXT, fBrandAnim);
                    break;

                case IDC_BROWSEICON:
                   if(HIWORD(wParam) == BN_CLICKED)
                   {
                      GetDlgItemText(hDlg, IDC_BITMAP, szLargeBmp, countof(szLargeBmp));
                      if(BrowseForFile(hDlg, szLargeBmp, countof(szLargeBmp), GFN_BMP))
                          SetDlgItemText(hDlg, IDC_BITMAP, szLargeBmp);
                      break;
                   }
                   return FALSE;
                    
                case IDC_BROWSEICON2:
                    if(HIWORD(wParam) == BN_CLICKED)
                    {
                        GetDlgItemText(hDlg, IDC_BITMAP2, szSmallBmp, countof(szSmallBmp));
                        if(BrowseForFile(hDlg, szSmallBmp, countof(szSmallBmp), GFN_BMP))
                            SetDlgItemText(hDlg, IDC_BITMAP2, szSmallBmp);
                        break;
                    }
                    return FALSE;

                case IDC_BITMAPCHECK:
                    if(HIWORD(wParam) == BN_CLICKED)
                    {
                        fBrandBmps = (IsDlgButtonChecked(hDlg, IDC_BITMAPCHECK) == BST_CHECKED);
                        EnableDlgItem2(hDlg, IDC_BITMAP, fBrandBmps);
                        EnableDlgItem2(hDlg, IDC_BROWSEICON, fBrandBmps);
                        EnableDlgItem2(hDlg, IDC_LARGEBITMAP_TXT, fBrandBmps);
                        EnableDlgItem2(hDlg, IDC_BROWSEICON2, fBrandBmps);
                        EnableDlgItem2(hDlg, IDC_BITMAP2, fBrandBmps);
                        EnableDlgItem2(hDlg, IDC_SMALLBITMAP_TXT, fBrandBmps);
                        break;
                    }
                    return FALSE;
                
                default:
                    return FALSE;
            }
            break;

            case WM_HELP:   // F1
                ShowHelpTopic(hDlg);
                break;

            case WM_NOTIFY:
                switch (((LPNMHDR)lParam)->code)
                {
                    TCHAR szMsgTitle[1024];
                    TCHAR szMsgText[1024];

                    case PSN_HELP:
                        ShowHelpTopic(hDlg);
                        break;

                    case PSN_SETACTIVE:
                        // don't do any of this stuff in RSoP mode
                        if (!psCookie->pCS->IsRSoP())
                        {
                             // load information from ins file
                            SetDlgItemTextFromIns(hDlg, IDE_BIGANIMBITMAP, IDC_ANIMBITMAP, IS_ANIMATION,
                               TEXT("Big_Path"), GetInsFile(hDlg), NULL, INSIO_TRISTATE);

                            SetDlgItemTextFromIns(hDlg, IDE_SMALLANIMBITMAP, IDC_ANIMBITMAP, IS_ANIMATION,
                                TEXT("Small_Path"), GetInsFile(hDlg), NULL, INSIO_TRISTATE);

                            InsGetString(IS_SMALLLOGO, TEXT("Path"), 
                                szSmallBmp, ARRAYSIZE(szSmallBmp), GetInsFile(hDlg));
                            InsGetString(IS_LARGELOGO, TEXT("Path"), 
                                szLargeBmp, ARRAYSIZE(szLargeBmp), GetInsFile(hDlg), NULL, &fBrandBmps);

                            SetDlgItemTextTriState(hDlg, IDC_BITMAP2, IDC_BITMAPCHECK, szSmallBmp, fBrandBmps);
                            SetDlgItemTextTriState(hDlg, IDC_BITMAP, IDC_BITMAPCHECK, szLargeBmp, fBrandBmps);


                            fBrandAnim = (IsDlgButtonChecked(hDlg, IDC_ANIMBITMAP) == BST_CHECKED);
                            EnableDlgItem2(hDlg, IDC_BROWSEBIG, fBrandAnim);
                            EnableDlgItem2(hDlg, IDC_BIGANIMBITMAP_TXT, fBrandAnim);
                            EnableDlgItem2(hDlg, IDC_BROWSESMALL, fBrandAnim);
                            EnableDlgItem2(hDlg, IDC_SMALLANIMBITMAP_TXT, fBrandAnim);

                            EnableDlgItem2(hDlg, IDC_BROWSEICON, fBrandBmps);
                            EnableDlgItem2(hDlg, IDC_LARGEBITMAP_TXT, fBrandBmps);
                            EnableDlgItem2(hDlg, IDC_BROWSEICON2, fBrandBmps);
                            EnableDlgItem2(hDlg, IDC_SMALLBITMAP_TXT, fBrandBmps);
                        }
                    break;

                    case PSN_APPLY:
                        if (psCookie->pCS->IsRSoP())
                            return FALSE;
                        else
                        {
                            //code from old animation dlg

                            CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\ANIMBMP"), szWorkDir);

                            fBrandAnim = (IsDlgButtonChecked(hDlg, IDC_ANIMBITMAP) == BST_CHECKED);
                    
                            GetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmallAnimBmp, countof(szSmallAnimBmp));
                            GetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szLargeAnimBmp, countof(szLargeAnimBmp));

                            if (fBrandAnim && (!IsAnimBitmapFileValid(hDlg, IDE_SMALLANIMBITMAP, szSmallAnimBmp, NULL, IDS_TOOBIG22, IDS_TOOSMALL22, 22, 22) ||
                                !IsAnimBitmapFileValid(hDlg, IDE_BIGANIMBITMAP, szLargeAnimBmp, NULL, IDS_TOOBIG38, IDS_TOOSMALL38, 38, 38)))
                            {
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                break;
                            }
                    
                            //code from original custicon dlg

                            CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\LOGO"), szWorkDir);

                            fBrandBmps = (IsDlgButtonChecked(hDlg, IDC_BITMAPCHECK) == BST_CHECKED);

                            GetDlgItemText(hDlg, IDC_BITMAP2, szSmallBmp, countof(szSmallBmp));
                            GetDlgItemText(hDlg, IDC_BITMAP, szLargeBmp, countof(szLargeBmp));

                            if (fBrandBmps && (!IsBitmapFileValid(hDlg, IDC_BITMAP2, szSmallBmp, NULL, 22, 22, IDS_TOOBIG22, IDS_TOOSMALL22) ||
                                !IsBitmapFileValid(hDlg, IDC_BITMAP, szLargeBmp, NULL, 38, 38, IDS_TOOBIG38, IDS_TOOSMALL38)))
                            {
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                break;
                            }
                
                            nStatus = TS_CHECK_OK;
                            IsTriStateValid(hDlg, IDC_BITMAP2, IDC_BITMAPCHECK, &nStatus,
                                            res2Str(IDS_QUERY_CLEARSETTING, szMsgText, countof(szMsgText)),
                                            res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)));
                            IsTriStateValid(hDlg, IDC_BITMAP, IDC_BITMAPCHECK, &nStatus, szMsgText, szMsgTitle);
                            IsTriStateValid(hDlg, IDE_SMALLANIMBITMAP, IDC_ANIMBITMAP, &nStatus,
                                res2Str(IDS_QUERY_CLEARSETTING, szMsgText, countof(szMsgText)),
                                res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)));
                            IsTriStateValid(hDlg, IDE_BIGANIMBITMAP, IDC_ANIMBITMAP, &nStatus,
                                szMsgText, szMsgTitle);
                
                            if (nStatus == TS_CHECK_ERROR ||                        
                                !AcquireWriteCriticalSection(hDlg))
                            {
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                break;
                            }

                            CopyLogoBmp(hDlg, szSmallBmp, IS_SMALLLOGO, szWorkDir, GetInsFile(hDlg));
                            CopyLogoBmp(hDlg, szLargeBmp, IS_LARGELOGO, szWorkDir, GetInsFile(hDlg));
                            CopyAnimBmp(hDlg, szSmallAnimBmp, szWorkDir, IK_SMALLBITMAP, TEXT("Small_Path"), GetInsFile(hDlg));
                            CopyAnimBmp(hDlg, szLargeAnimBmp, szWorkDir, IK_LARGEBITMAP, TEXT("Big_Path"), GetInsFile(hDlg));

                            InsWriteBool(IS_ANIMATION, IK_DOANIMATION, fBrandAnim, GetInsFile(hDlg));

                            if (PathIsDirectoryEmpty(szWorkDir))
                                PathRemovePath(szWorkDir);

                            if (PathIsDirectoryEmpty(szWorkDir))
                                PathRemovePath(szWorkDir);
                
                            SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
                        }
                        break;

                    default:
                        return FALSE;
                }
                break;

        default:
            return FALSE;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\favs.cpp ===
#include "precomp.h"

#include "rsop.h"

#include "favsproc.h"
#include <tchar.h>

static INT_PTR CALLBACK addEditFavoriteRSoPProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/////////////////////////////////////////////////////////////////////
struct _FAV4RSOP
{
    WORD wType;

    TCHAR szName[MAX_PATH];
    TCHAR szDisplayName[MAX_PATH];
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szIconFile[MAX_PATH];
    BOOL fOffline;
};
typedef _FAV4RSOP FAV4RSOP, *LPFAV4RSOP;


//////////////////////////////////////////////////////////////////////
BOOL ItemHasText(HWND htv, HTREEITEM hti, LPCTSTR szText)
{
    BOOL bRet = FALSE;
    __try
    {
        if (NULL !=  hti)
        {
            TCHAR szBuffer[MAX_PATH];
            TVITEM tvi;
            ZeroMemory((void*)&tvi, sizeof(tvi));

            tvi.hItem = hti;
            tvi.mask = TVIF_TEXT;

            tvi.pszText = szBuffer;
            tvi.cchTextMax = countof(szBuffer);

            if (TreeView_GetItem(htv, &tvi))
                bRet = (!StrCmpI(tvi.pszText, szText)) ? TRUE : FALSE;
        }
    }
    __except(TRUE)
    {
        ASSERT(0);
    }
    return bRet;
}

//////////////////////////////////////////////////////////////////////
LPARAM GetTVItemLParam(HWND htv, HTREEITEM hti)
{
    LPARAM lpResult = 0;
    __try
    {
        if (NULL !=  hti)
        {
            TVITEM tvi;
            ZeroMemory((void*)&tvi, sizeof(tvi));

            tvi.hItem = hti;
            tvi.mask = TVIF_PARAM;
            if (TreeView_GetItem(htv, &tvi))
                lpResult = tvi.lParam;
        }
    }
    __except(TRUE)
    {
        ASSERT(0);
    }
    return lpResult;
}

/////////////////////////////////////////////////////////////////////
void DestroyTVItemData(HWND htv, HTREEITEM hti)
{
    __try
    {
        HTREEITEM htiCur = hti;
        if (NULL == hti)
            htiCur = TreeView_GetRoot(htv);

        HTREEITEM htiFirstChild = TreeView_GetChild(htv, htiCur);
        if (NULL !=  htiFirstChild)
            DestroyTVItemData(htv, htiFirstChild);

        while (NULL != htiCur)
        {
            htiCur = TreeView_GetNextSibling(htv, htiCur);
            if (NULL != htiCur)
                DestroyTVItemData(htv, htiCur);
        }

        LPARAM lp = GetTVItemLParam(htv, hti);
        if (NULL != hti && NULL != (void*)lp)
            CoTaskMemFree((void*)lp);
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
HTREEITEM FindFolderItem(HWND htv, LPCTSTR szText, HTREEITEM htiParent = NULL)
{
    HTREEITEM htiResult = NULL;
    __try
    {
        HTREEITEM htiFirstChild = NULL;
        if (NULL == htiParent)
        {
            HTREEITEM htiTempParent = TreeView_GetRoot(htv);
            htiFirstChild = TreeView_GetNextSibling(htv, TreeView_GetChild(htv, htiTempParent));
        }
        else
            htiFirstChild = TreeView_GetChild(htv, htiParent);

        // pass the "Favorites" marker at the top - 1st child of root
        HTREEITEM htiCur = htiFirstChild;
        while (NULL != htiCur)
        {
            // look at the current folder
            if (ItemHasText(htv, htiCur, szText))
                break;

            // then the folder's children
            htiCur = FindFolderItem(htv, szText, htiCur);
            if (ItemHasText(htv, htiCur, szText))
                break;

            // then the folder's siblings
            htiCur = TreeView_GetNextSibling(htv, htiCur);
        }
        htiResult = htiCur;
    }
    __except(TRUE)
    {
    }
    return htiResult;
}

/////////////////////////////////////////////////////////////////////
HTREEITEM InsertTreeItem(HWND htv, LPFAV4RSOP pFav, LPCTSTR szText, WORD wType,
                         HTREEITEM htiParent = NULL, HTREEITEM htiPrevious = NULL,
                         UINT nChildren = 0)
{
    HTREEITEM htiResult = NULL;
    __try
    {
        if (NULL != pFav)
        {
            LPFAV4RSOP pNewFav = (LPFAV4RSOP)CoTaskMemAlloc(sizeof(FAV4RSOP));
            if (NULL != pNewFav)
            {
                pNewFav->wType = wType;
                StrCpy(pNewFav->szDisplayName, szText);
                StrCpy(pNewFav->szName, pFav->szName);
                StrCpy(pNewFav->szUrl, pFav->szUrl);
                StrCpy(pNewFav->szIconFile, pFav->szIconFile);
                pNewFav->fOffline = pFav->fOffline;

                TV_ITEM tvi;
                ZeroMemory(&tvi, sizeof(tvi));
                tvi.mask = TVIF_TEXT | TVIF_PARAM;
                if (pFav->wType != FTYPE_URL)
                {
                    tvi.mask |= TVIF_CHILDREN;
                    tvi.cChildren = nChildren;
                }

                if (pFav->wType != FTYPE_URL && pFav->wType != FTYPE_FOLDER)
                {
                    tvi.mask |= TVIF_STATE;
                    tvi.stateMask = TVIS_BOLD;
                    tvi.state = TVIS_BOLD;
                }

                tvi.lParam = (LPARAM)pNewFav;

                tvi.pszText = (LPTSTR)pNewFav->szDisplayName;
                tvi.cchTextMax = StrLen(pNewFav->szDisplayName) + 1;

                TVINSERTSTRUCT tvins;
                ZeroMemory(&tvins, sizeof(tvins));
                tvins.hParent = htiParent;
                tvins.hInsertAfter = htiPrevious;
                CopyMemory(&tvins.item, &tvi, sizeof(tvi));
                htiResult = TreeView_InsertItem(htv, &tvins);
            }
        }
    }
    __except(TRUE)
    {
    }
    return htiResult;
}

/////////////////////////////////////////////////////////////////////
HTREEITEM InsertFavoriteItem(HWND htv, LPFAV4RSOP pFav, LPCTSTR szRemainingPath,
                             HTREEITEM htiPrevious, HTREEITEM htiParent = NULL,
                             BOOL bLink = FALSE)
{
    HTREEITEM htiResult = NULL;
    __try
    {
        // Find the first folder in the path
        LPTSTR szSlash = StrChr(szRemainingPath, _T('\\'));
        if (NULL != szSlash)
        {
            TCHAR szCurFolder[MAX_PATH];
            ZeroMemory(szCurFolder, countof(szCurFolder));
            StrCpyN(szCurFolder, szRemainingPath, (int)(szSlash - szRemainingPath) + 1);

            // See if the folder exists in the tree
            // If so, store the HTREEITEM in a param.
            HTREEITEM htiCurFolder = FindFolderItem(htv, szCurFolder, htiParent);
            if (NULL == htiCurFolder)
            {
                // If not, create the folder with the lParam set to NULL.
                htiCurFolder = InsertTreeItem(htv, pFav, szCurFolder, FTYPE_FOLDER,
                                            htiParent, htiPrevious);
            }

            // Pass the remainder of the string to InsertFavoriteItem
            htiResult = InsertFavoriteItem(htv, pFav, ++szSlash, htiPrevious,
                                            htiCurFolder, bLink);
        }
        else
        {
            // If no more folders, create a new item under current folder
            htiResult = InsertTreeItem(htv, pFav, szRemainingPath, FTYPE_URL,
                                        htiParent, htiPrevious);
            TreeView_Expand(htv, htiParent, TVE_EXPAND);
        }
    }
    __except(TRUE)
    {
    }
    return htiResult;
}

/////////////////////////////////////////////////////////////////////
DWORD AddItemsToTree(HWND hwndTree, CDlgRSoPData *pDRD, BSTR bstrTempClass,
                     BOOL bLink)
{
    DWORD dwRet = 0;
    __try
    {
        _bstr_t bstrClass = bstrTempClass;
        CPSObjData **paFavObj = NULL;
        long nFavObjects = 0;
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass, L"rsopPrecedence",
                                                &paFavObj, &nFavObjects);
        if (SUCCEEDED(hr))
        {
            FAV4RSOP tempFav;
            ZeroMemory(&tempFav, sizeof(FAV4RSOP));

            // Add "Favorites" or "Links" entry to tree
            LoadString(g_hUIInstance, bLink ? IDS_LINKS : IDS_FAVFOLDER,
                        tempFav.szName, countof(tempFav.szName));
            HTREEITEM htiParent = InsertTreeItem(hwndTree, &tempFav, tempFav.szName, FTYPE_UNUSED,
                                                    NULL, TVI_LAST, nFavObjects);

            // For each favorite returned from any GPO
            long nObj;
            for (nObj = 0; nObj < nFavObjects; nObj++)
            {
                _bstr_t bstrGPOName = L" (";
                bstrGPOName += pDRD->GetGPONameFromPSAssociation(paFavObj[nObj]->pObj,
                                                                L"rsopPrecedence") +
                                L")";

                tempFav.wType = FTYPE_URL;

                // name field
                _variant_t vtValue;
                hr = paFavObj[nObj]->pObj->Get(L"name", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                {
                    _bstr_t bstrValue = vtValue;
                    _bstr_t bstrEntry = bstrValue + bstrGPOName;

                    StrCpy(tempFav.szName, (LPCTSTR)bstrValue);

                    // url field
                    hr = paFavObj[nObj]->pObj->Get(L"url", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        bstrValue = vtValue;
                        StrCpy(tempFav.szUrl, (LPCTSTR)bstrValue);
                    }

                    // iconPath field
                    hr = paFavObj[nObj]->pObj->Get(L"iconPath", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        bstrValue = vtValue;
                        StrCpy(tempFav.szIconFile, (LPCTSTR)bstrValue);
                    }

                    // makeAvailableOffline field
                    hr = paFavObj[nObj]->pObj->Get(L"makeAvailableOffline", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        tempFav.fOffline = (bool)vtValue ? TRUE : FALSE;

                    InsertFavoriteItem(hwndTree, &tempFav, (LPCTSTR)bstrEntry, NULL, htiParent, bLink);
                }
            }

            dwRet = nObj;
        }
    }
    __except(TRUE)
    {
    }
    return dwRet;
}

/////////////////////////////////////////////////////////////////////
DWORD InitFavsDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    DWORD dwRet = 0;
    __try
    {
        // First go through all PS objects and look for favorites data
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();

            BOOL bPlaceAtTopHandled = FALSE;
            BOOL bDeleteHandled = FALSE;
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                // placeFavoritesAtTopOfList field
                _variant_t vtValue;
                if (!bPlaceAtTopHandled)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"placeFavoritesAtTopOfList", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        if ((bool)vtValue)
                            CheckDlgButton(hDlg, IDC_FAVONTOP, BST_CHECKED);
                        bPlaceAtTopHandled = TRUE;
                    }
                }

                // deleteExistingChannels field
                if (!bDeleteHandled)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"deleteExistingChannels", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        if ((bool)vtValue)
                            CheckDlgButton(hDlg, IDC_DELETECHANNELS, BST_CHECKED);
                        bDeleteHandled = TRUE;
                    }
                }


                // deleteExistingFavorites field
                if (!bDeleteHandled)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"deleteExistingFavorites", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        if ((bool)vtValue)
                            CheckDlgButton(hDlg, IDC_DELFAVORITES, BST_CHECKED);
                        bDeleteHandled = TRUE;

                        // deleteAdminCreatedFavoritesOnly field
                        hr = paPSObj[nObj]->pObj->Get(L"deleteAdminCreatedFavoritesOnly", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            if ((bool)vtValue)
                                CheckDlgButton(hDlg, IDC_DELIEAKFAVORITES, BST_CHECKED);
                        }
                    }
                }

                // no need to process other GPOs since enabled properties have been found
                if (bPlaceAtTopHandled && bDeleteHandled)
                    break;
            }
        }

        EnableDlgItem2(hDlg, IDC_FAVONTOP, FALSE);
        EnableDlgItem2(hDlg, IDC_DELFAVORITES, FALSE);
        EnableDlgItem2(hDlg, IDC_DELIEAKFAVORITES, FALSE);
        EnableDlgItem2(hDlg, IDC_DELETECHANNELS, FALSE);

        // Now go through all Favorite & Link objects and populate the tree ctrl
        HWND hwndTree = GetDlgItem(hDlg, IDC_TREE1);
        TreeView_DeleteAllItems(hwndTree);

        dwRet = AddItemsToTree(hwndTree, pDRD, L"RSOP_IEFavoriteItem", FALSE);
        dwRet += AddItemsToTree(hwndTree, pDRD, L"RSOP_IELinkItem", TRUE);

        TreeView_SelectItem(hwndTree, TreeView_GetRoot(hwndTree));


        EnableDlgItem2(hDlg, IDC_FAVUP, FALSE);
        EnableDlgItem2(hDlg, IDC_FAVDOWN, FALSE);
        EnableDlgItem2(hDlg, IDC_ADDURL, FALSE);
        EnableDlgItem2(hDlg, IDC_ADDFOLDER, FALSE);
        EnableDlgItem2(hDlg, IDC_MODIFY, FALSE);
        EnableDlgItem2(hDlg, IDC_REMOVE, FALSE);
        EnableDlgItem2(hDlg, IDC_TESTFAVURL, FALSE);
        EnableDlgItem2(hDlg, IDC_IMPORT, FALSE);
    }
    __except(TRUE)
    {
    }
    return dwRet;
}

/////////////////////////////////////////////////////////////////////
HRESULT InitFavsPlacementPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

                // placeFavoritesAtTopOfList field
                BOOL bAtTop = FALSE;
                _variant_t vtValue;
                hr = paPSObj[nObj]->pObj->Get(L"placeFavoritesAtTopOfList", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    bAtTop = (bool)vtValue ? TRUE : FALSE;

                _bstr_t bstrSetting;
                if (bAtTop)
                {
                    TCHAR szTemp[MAX_PATH];
                    LoadString(g_hInstance, IDS_PLACEATTOP_SETTING, szTemp, countof(szTemp));
                    bstrSetting = szTemp;
                }
                else
                    bstrSetting = GetDisabledString();

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT InitFavsDeletionPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

                // deleteExistingFavorites field
                BOOL bDeleteExisting = FALSE;
                BOOL bAdminOnly = FALSE;
                _variant_t vtValue;
                hr = paPSObj[nObj]->pObj->Get(L"deleteExistingFavorites", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))

                // deleteAdminCreatedFavoritesOnly field
                hr = paPSObj[nObj]->pObj->Get(L"deleteExistingFavorites", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                {
                    bDeleteExisting = (bool)vtValue ? TRUE : FALSE;

                    // deleteAdminCreatedFavoritesOnly field
                    hr = paPSObj[nObj]->pObj->Get(L"deleteAdminCreatedFavoritesOnly", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        bAdminOnly = (bool)vtValue;
                }

                _bstr_t bstrSetting;
                if (bDeleteExisting > 0)
                {
                    TCHAR szTemp[MAX_PATH];

                    if (bAdminOnly)
                        LoadString(g_hInstance, IDS_DELADMINCREATED_SETTING, szTemp, countof(szTemp));
                    else
                        LoadString(g_hInstance, IDS_DELEXISTING_SETTING, szTemp, countof(szTemp));

                    bstrSetting = szTemp;
                }
                else
                    bstrSetting = GetDisabledString();

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT InitFavsPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();

            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

                // customFavorites field
                long nFavs = 0, nLinks = 0;
                _variant_t vtValue;
                hr = paPSObj[nObj]->pObj->Get(L"customFavorites", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    nFavs = vtValue;

                // customLinks field
                hr = paPSObj[nObj]->pObj->Get(L"customLinks", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    nLinks = vtValue;

                _bstr_t bstrSetting;
                if (nFavs > 0 || nLinks > 0)
                {
                    TCHAR szTemp[MAX_PATH];

                    LoadString(g_hInstance, IDS_FAVS_AND_LINKS_SETTING, szTemp, countof(szTemp));

                    TCHAR szSetting[MAX_PATH];
                    wnsprintf(szSetting, countof(szSetting), szTemp, nFavs, nLinks);
                    bstrSetting = szSetting;
                }
                else
                    bstrSetting = GetDisabledString();

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK FavoritesDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    TCHAR   szWorkDir[MAX_PATH],
            szValue[16],
            szUrl[INTERNET_MAX_URL_LENGTH];
    HWND    htv = GetDlgItem(hDlg, IDC_TREE1);
    LPCTSTR pszValue;
    BOOL    fQL,
            fFavoritesOnTop, fFavoritesDelete, fIEAKFavoritesDelete;
    DWORD   dwFavoritesDeleteFlags;

    switch (msg) {
    case WM_SETFONT:
        //a change to mmc requires us to do this logic for all our property pages that use common controls
        INITCOMMONCONTROLSEX iccx;
        iccx.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccx.dwICC = ICC_ANIMATE_CLASS  | ICC_BAR_CLASSES  | ICC_LISTVIEW_CLASSES  |ICC_TREEVIEW_CLASSES;
        InitCommonControlsEx(&iccx);
        break;

    case WM_INITDIALOG:
        SetPropSheetCookie(hDlg, lParam);

        EnableDBCSChars(hDlg, IDC_TREE1);
        
        ReadBoolAndCheckButton(IS_DESKTOPOBJS, IK_DELETECHANNELS, FALSE, GetInsFile(hDlg), 
            hDlg, IDC_DELETECHANNELS);

        // find out if this dlg is in RSoP mode
        psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        if (psCookie->pCS->IsRSoP())
        {
            TCHAR szView[64];
            LoadString(g_hInstance, IDS_VIEW, szView, countof(szView));
            SetDlgItemText(hDlg, IDC_MODIFY, szView);

            CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
            InitFavsDlgInRSoPMode(hDlg, pDRD);
        }
        else
        {
            MigrateFavorites(GetInsFile(hDlg));
        }

#ifdef _UNICODE
        TreeView_SetUnicodeFormat(htv, TRUE);
#else
        TreeView_SetUnicodeFormat(htv, FALSE);
#endif
        break;

    case WM_DESTROY:
        if (psCookie->pCS->IsRSoP())
        {
            DestroyDlgRSoPData(hDlg);
            DestroyTVItemData(htv, NULL);
        }
        break;

    case WM_COMMAND:
        if (BN_CLICKED != GET_WM_COMMAND_CMD(wParam, lParam))
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_FAVONTOP:
            if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_FAVONTOP)) {
                HTREEITEM hti;
                TV_ITEM   tvi;

                EnableDlgItem(hDlg, IDC_FAVONTOP);

                hti = TreeView_GetSelection(htv);
                if (NULL != hti) {
                    ZeroMemory(&tvi, sizeof(tvi));
                    tvi.mask  = TVIF_STATE;
                    tvi.hItem = hti;
                    TreeView_GetItem(htv, &tvi);

                    if (!HasFlag(tvi.state, TVIS_BOLD)) {
                        EnableDlgItem2(hDlg, IDC_FAVUP,   (NULL != TreeView_GetPrevSibling(htv, hti)));
                        EnableDlgItem2(hDlg, IDC_FAVDOWN, (NULL != TreeView_GetNextSibling(htv, hti)));
                    }
                }
            }
            else {
                DisableDlgItem(hDlg, IDC_FAVUP);
                DisableDlgItem(hDlg, IDC_FAVDOWN);
            }
            break;

        case IDC_DELFAVORITES:
            fFavoritesDelete = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DELFAVORITES));
            EnableWindow(GetDlgItem(hDlg, IDC_DELIEAKFAVORITES), fFavoritesDelete);
            break;

        case IDC_FAVUP:
            MoveUpFavorite(htv, TreeView_GetSelection(htv));
            break;

        case IDC_FAVDOWN:
            MoveDownFavorite(htv, TreeView_GetSelection(htv));
            break;

        case IDC_ADDURL:
            fQL = !IsFavoriteItem(htv, TreeView_GetSelection(htv));
            if (GetFavoritesNumber(htv, fQL) >= GetFavoritesMaxNumber(fQL)) {
                UINT nID;

                nID = (!fQL ? IDS_ERROR_MAXFAVS : IDS_ERROR_MAXQLS);
                ErrorMessageBox(hDlg, nID);
                break;
            }

            CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\favs"), szWorkDir);
            NewUrl(htv, szWorkDir, PLATFORM_WIN32, IEM_GP);
            break;

        case IDC_ADDFOLDER:
            ASSERT(IsFavoriteItem(htv, TreeView_GetSelection(htv)));
            if (GetFavoritesNumber(htv) >= GetFavoritesMaxNumber()) {
                ErrorMessageBox(hDlg, IDS_ERROR_MAXFAVS);
                break;
            }

            NewFolder(htv);
            break;

        case IDC_MODIFY:
            if (psCookie->pCS->IsRSoP())
            {
                LPFAV4RSOP pFav = (LPFAV4RSOP)GetTVItemLParam(htv, TreeView_GetSelection(htv));
                if (NULL != pFav)
                {
                    DialogBoxParam(g_hUIInstance, MAKEINTRESOURCE(IDD_FAVPOPUP), GetParent(htv),
                                    addEditFavoriteRSoPProc, (LPARAM)pFav);
                }
            }
            else
            {
                CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\favs"), szWorkDir);
                ModifyFavorite(htv, TreeView_GetSelection(htv), szWorkDir, szWorkDir, PLATFORM_WIN32, IEM_GP);
            }
            break;

        case IDC_REMOVE:
            CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\favs"), szWorkDir);
            DeleteFavorite(htv, TreeView_GetSelection(htv), szWorkDir);
            break;

        case IDC_TESTFAVURL:
            if (GetFavoriteUrl(htv, TreeView_GetSelection(htv), szUrl, countof(szUrl)))
                TestURL(szUrl);
            break;

        case IDC_IMPORT: {
            CNewCursor cursor(IDC_WAIT);

            CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\favs"), szWorkDir);
            ImportFavoritesCmd(htv, szWorkDir);
            break;
            }

        default:
            return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_SETACTIVE:
            // don't do any of this stuff in RSoP mode
            if (!psCookie->pCS->IsRSoP())
            {
                CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\favs"), szWorkDir);

                ASSERT(0 == GetFavoritesNumber(htv, FALSE) && 0 == GetFavoritesNumber(htv, TRUE));
                ImportFavorites (htv, NULL, GetInsFile(hDlg), szWorkDir, NULL, FALSE);
                ImportQuickLinks(htv, NULL, GetInsFile(hDlg), szWorkDir, NULL, FALSE);

                TreeView_SelectItem(htv, TreeView_GetRoot(htv));

                fFavoritesOnTop = InsGetBool(IS_BRANDING, IK_FAVORITES_ONTOP, FALSE, GetInsFile(hDlg));
                CheckDlgButton(hDlg, IDC_FAVONTOP, fFavoritesOnTop ? BST_CHECKED : BST_UNCHECKED);

                if (!fFavoritesOnTop) {
                    DisableDlgItem(hDlg, IDC_FAVUP);
                    DisableDlgItem(hDlg, IDC_FAVDOWN);
                }

                dwFavoritesDeleteFlags = (DWORD)InsGetInt(IS_BRANDING, IK_FAVORITES_DELETE, (int)FD_DEFAULT, GetInsFile(hDlg));

                fFavoritesDelete = HasFlag(dwFavoritesDeleteFlags, ~FD_REMOVE_IEAK_CREATED);
                CheckDlgButton(hDlg, IDC_DELFAVORITES, fFavoritesDelete ? BST_CHECKED : BST_UNCHECKED);

                fIEAKFavoritesDelete = HasFlag(dwFavoritesDeleteFlags, FD_REMOVE_IEAK_CREATED);
                CheckDlgButton(hDlg, IDC_DELIEAKFAVORITES, fIEAKFavoritesDelete ? BST_CHECKED : BST_UNCHECKED);

                // only if delete Favorites is TRUE should the delete IEAK Favorites checkbox be enabled
                EnableWindow(GetDlgItem(hDlg, IDC_DELIEAKFAVORITES), fFavoritesDelete);
            }
            break;

        case TVN_GETINFOTIP: 
            ASSERT(IDC_TREE1 == wParam);
            if (!psCookie->pCS->IsRSoP())
                GetFavoritesInfoTip((LPNMTVGETINFOTIP)lParam);
            break;

        case NM_DBLCLK:
            ASSERT(IDC_TREE1 == wParam);
            if (IsWindowEnabled(GetDlgItem(hDlg, IDC_MODIFY)))
                SendMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDC_MODIFY, GetDlgItem(hDlg, IDC_MODIFY), BN_CLICKED));
            break;

        case TVN_KEYDOWN:
            ASSERT(wParam == IDC_TREE1);
            if (((LPNMTVKEYDOWN)lParam)->wVKey == VK_DELETE && IsWindowEnabled(GetDlgItem(hDlg, IDC_REMOVE)))
                SendMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDC_REMOVE, GetDlgItem(hDlg, IDC_REMOVE), BN_CLICKED));
            break;

        case TVN_SELCHANGED: 
            ASSERT(IDC_TREE1 == wParam);
            if (psCookie->pCS->IsRSoP())
            {
                LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)lParam;
                LPFAV4RSOP pFav = (LPFAV4RSOP)pnmtv->itemNew.lParam;

                if (NULL != pFav)
                    EnableDlgItem2(hDlg, IDC_MODIFY, (FTYPE_UNUSED == pFav->wType) ? FALSE : TRUE);
            }
            else
                ProcessFavSelChange(hDlg, htv, (LPNMTREEVIEW)lParam);
            break;

        case PSN_HELP:
            ShowHelpTopic(hDlg);
            break;

        case PSN_APPLY:
            if (psCookie->pCS->IsRSoP())
                return FALSE;
            else
            {
                fFavoritesOnTop = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_FAVONTOP));

                dwFavoritesDeleteFlags = 0;
                szValue[0]             = TEXT('\0');
                pszValue               = NULL;
                fFavoritesDelete       = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DELFAVORITES));
                fIEAKFavoritesDelete   = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DELIEAKFAVORITES));

                if (fFavoritesDelete) {
                    // NOTE. (andrewgu) flags explanation:
                    // 1. FD_FAVORITES        means "empty favorites";
                    // 2. FD_CHANNELS         means "don't delete channels folder";
                    // 3. FD_SOFTWAREUPDATES  means "don't delete sofware updates folder";
                    // 4. FD_QUICKLINKS       means "don't delete quick links folder";
                    // 5. FD_EMPTY_QUICKLINKS means "but make it empty";
                    // 6. FD_REMOVE_HIDDEN    means "don't hesitate to party on HIDDEN folders and favorites";
                    // 7. FD_REMOVE_SYSTEM    means "don't hesitate to party on SYSTEM folders and favorites";
                    dwFavoritesDeleteFlags |= FD_FAVORITES      |
                        FD_CHANNELS        | FD_SOFTWAREUPDATES | FD_QUICKLINKS | FD_EMPTY_QUICKLINKS |
                        FD_REMOVE_HIDDEN   | FD_REMOVE_SYSTEM;
                }

                if (fIEAKFavoritesDelete)
                    // FD_REMOVE_IEAK_CREATED means "delete those items created by the IEAK";
                    dwFavoritesDeleteFlags |= FD_REMOVE_IEAK_CREATED;

                if (dwFavoritesDeleteFlags) {
                    wnsprintf(szValue, countof(szValue), TEXT("0x%X"), dwFavoritesDeleteFlags);
                    pszValue = szValue;
                }

                if (!AcquireWriteCriticalSection(hDlg)) {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    break;
                }

                InsWriteString(IS_BRANDING, IK_FAVORITES_DELETE, pszValue, GetInsFile(hDlg));
                InsWriteBool(IS_BRANDING, IK_FAVORITES_ONTOP, fFavoritesOnTop, GetInsFile(hDlg));

                CheckButtonAndWriteBool(hDlg, IDC_DELETECHANNELS, IS_DESKTOPOBJS, IK_DELETECHANNELS, GetInsFile(hDlg));

                CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\favs"), szWorkDir);
                ExportFavorites (htv, GetInsFile(hDlg), szWorkDir, TRUE);
                ExportQuickLinks(htv, GetInsFile(hDlg), szWorkDir, TRUE);

                MigrateToOldFavorites(GetInsFile(hDlg));

                DeleteFavorite(htv, TreeView_GetRoot(htv), NULL);
                DeleteFavorite(htv, TreeView_GetRoot(htv), NULL);

                if (PathIsDirectoryEmpty(szWorkDir))
                    PathRemovePath(szWorkDir);

                SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
            }
            break;

        case PSN_QUERYCANCEL:
            if (!psCookie->pCS->IsRSoP())
            {
                DeleteFavorite(htv, TreeView_GetRoot(htv), NULL);
                DeleteFavorite(htv, TreeView_GetRoot(htv), NULL);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        ShowHelpTopic(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK addEditFavoriteRSoPProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = FALSE;
    switch (message) {
    case WM_INITDIALOG:
    {
        LPFAV4RSOP pFav = (LPFAV4RSOP)lParam;

        //----- Initialize contols -----
        EnableDBCSChars(hDlg, IDE_FAVNAME);
        EnableDBCSChars(hDlg, IDE_FAVURL);
        EnableDBCSChars(hDlg, IDE_FAVICON);

        Edit_LimitText(GetDlgItem(hDlg, IDE_FAVNAME), _MAX_FNAME);
        Edit_LimitText(GetDlgItem(hDlg, IDE_FAVURL),  INTERNET_MAX_URL_LENGTH-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_FAVICON), _MAX_FNAME);

        EnableWindow(GetDlgItem(hDlg, IDE_FAVNAME), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDE_FAVURL), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDE_FAVICON), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_FAVICONBROWSE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_AVAILOFFLINE), FALSE);

        //----- Populate controls -----
        if (FTYPE_FOLDER == pFav->wType)
            SetDlgItemText(hDlg, IDE_FAVNAME, pFav->szDisplayName);
        else
        {
            LPTSTR szLastSlash = StrRChr(pFav->szName, NULL, _T('\\'));
            SetDlgItemText(hDlg, IDE_FAVNAME, (NULL != szLastSlash) ? szLastSlash + 1 : pFav->szName);

            SetDlgItemText(hDlg, IDE_FAVURL, pFav->szUrl);
            SetDlgItemText(hDlg, IDE_FAVICON, pFav->szIconFile);
            if (pFav->fOffline)
                CheckDlgButton(hDlg, IDC_AVAILOFFLINE, BST_CHECKED);
        }

        fResult = TRUE;
        break;
    }

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            EndDialog(hDlg, IDOK);
            fResult = TRUE;
            break;

        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            fResult = TRUE;
            break;
        }
        break;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <lm.h>
#include <ole2.h>
#include <olectl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commctrl.h>
#include <prsht.h>
#include <initguid.h>
#include <mmc.h>
#include <gpedit.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <wininet.h>

class CSnapIn;

#include <iedkbrnd.h>
#include <ieakutil.h>
#include <exports.h>
#include <ieakui.h>
#include "layout.h"
#include "compdata.h"
#include "snapin.h"
#include "cookie.h"
#include "about.h"
#include "dataobj.h"
#include "util.h"
#include "resource.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\programs.cpp ===
#include "precomp.h"
#include <inetcpl.h>

#include "rsop.h"
#include <tchar.h>

static INT_PTR CALLBACK importProgramsRSoPProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


/////////////////////////////////////////////////////////////////////
void InitProgramsDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
	__try
	{
		BOOL bImport = FALSE;
		_bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
		HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass);
		if (SUCCEEDED(hr))
		{
			CPSObjData **paPSObj = pDRD->GetPSObjArray();
			long nPSObjects = pDRD->GetPSObjCount();

			for (long nObj = 0; nObj < nPSObjects; nObj++)
			{
				// importProgramSettings field
				_variant_t vtValue;
				hr = paPSObj[nObj]->pObj->Get(L"importProgramSettings", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
				{
					bImport = (bool)vtValue ? TRUE : FALSE;
					CheckRadioButton(hDlg, IDC_PROGNOIMPORT, IDC_PROGIMPORT,
									(bool)vtValue ? IDC_PROGIMPORT : IDC_PROGNOIMPORT);

					DWORD dwCurGPOPrec = GetGPOPrecedence(paPSObj[nObj]->pObj);
					pDRD->SetImportedProgSettPrec(dwCurGPOPrec);
					break;
				}
			}
		}

		EnableDlgItem2(hDlg, IDC_PROGNOIMPORT, FALSE);
		EnableDlgItem2(hDlg, IDC_PROGIMPORT, FALSE);
		EnableDlgItem2(hDlg, IDC_MODIFYPROG, bImport);
	}
	__except(TRUE)
	{
	}
}

/////////////////////////////////////////////////////////////////////
HRESULT InitProgramsPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
	HRESULT hr = NOERROR;
	__try
	{
		_bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
		hr = pDRD->GetArrayOfPSObjects(bstrClass);
		if (SUCCEEDED(hr))
		{
			CPSObjData **paPSObj = pDRD->GetPSObjArray();
			long nPSObjects = pDRD->GetPSObjCount();
			for (long nObj = 0; nObj < nPSObjects; nObj++)
			{
				_bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

				// importProgramSettings field
				BOOL bImport = FALSE;
				_variant_t vtValue;
				hr = paPSObj[nObj]->pObj->Get(L"importProgramSettings", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					bImport = (bool)vtValue ? TRUE : FALSE;

				_bstr_t bstrSetting;
				if (bImport)
				{
					TCHAR szTemp[MAX_PATH];
					LoadString(g_hInstance, IDS_IMPORT_PROG_SETTING, szTemp, countof(szTemp));
					bstrSetting = szTemp;
				}
				else
					bstrSetting = GetDisabledString();

				InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
			}
		}
	}
	__except(TRUE)
	{
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK ProgramsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	// Retrieve Property Sheet Page info for each call into dlg proc.
	LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    TCHAR szWorkDir[MAX_PATH];
    BOOL  fImport;

    switch( msg )
    {
    case WM_INITDIALOG:
        SetPropSheetCookie(hDlg, lParam);

		// find out if this dlg is in RSoP mode
		psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
		if (psCookie->pCS->IsRSoP())
		{
			CheckRadioButton(hDlg, IDC_PROGNOIMPORT, IDC_PROGIMPORT, IDC_PROGNOIMPORT);

			TCHAR szViewSettings[128];
			LoadString(g_hInstance, IDS_VIEW_SETTINGS, szViewSettings, countof(szViewSettings));
			SetDlgItemText(hDlg, IDC_MODIFYPROG, szViewSettings);

			CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
			InitProgramsDlgInRSoPMode(hDlg, pDRD);
		}
		else
		{
			fImport = !InsIsKeyEmpty(IS_EXTREGINF, IK_PROGRAMS, GetInsFile(hDlg));
			EnableDlgItem2(hDlg, IDC_MODIFYPROG, fImport);
			CheckRadioButton(hDlg, IDC_PROGNOIMPORT, IDC_PROGIMPORT, fImport ? IDC_PROGIMPORT : IDC_PROGNOIMPORT);
		}
        break;

	case WM_DESTROY:
		if (psCookie->pCS->IsRSoP())
			DestroyDlgRSoPData(hDlg);
		break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_PROGNOIMPORT:
            EnableDlgItem2(hDlg, IDC_MODIFYPROG, FALSE);
            break;
            
        case IDC_PROGIMPORT:
            EnableDlgItem(hDlg, IDC_MODIFYPROG);
            break;
            
        case IDC_MODIFYPROG:
			if (psCookie->pCS->IsRSoP())
			{
				CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
				if (NULL != pDRD)
				{
					CreateINetCplLookALikePage(hDlg, IDD_IMPORTEDPROGRAMS,
												importProgramsRSoPProc, (LPARAM)pDRD);
				}
			}
			else
				ShowInetcpl(hDlg, INET_PAGE_PROGRAMS);
            break;
        default:
            return FALSE;
        }
        break;

    case WM_HELP:   // F1
        ShowHelpTopic(hDlg);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_HELP:
            ShowHelpTopic(hDlg);
            break;

        case PSN_APPLY:
			if (psCookie->pCS->IsRSoP())
				return FALSE;
			else
			{
				CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\PROGRAMS"), szWorkDir);

				if (!AcquireWriteCriticalSection(hDlg))
				{
					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
					break;
				}

				ImportPrograms(GetInsFile(hDlg), szWorkDir, 
					(IsDlgButtonChecked(hDlg, IDC_PROGIMPORT) == BST_CHECKED));

				SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
				if (PathIsDirectoryEmpty(szWorkDir))
					PathRemovePath(szWorkDir);
			}
            break;
        default:
            return FALSE;
        }
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

//*******************************************************************
// CODE FROM INETCPL
//*******************************************************************

/////////////////////////////////////////////////////////////////////
void InitImportedProgramsDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
	__try
	{
		if (NULL != pDRD->ConnectToNamespace())
		{
			// get our stored precedence value
			DWORD dwCurGPOPrec = pDRD->GetImportedProgSettPrec();

			// create the object path of the program settings for this GPO
			WCHAR wszObjPath[128];
			wnsprintf(wszObjPath, countof(wszObjPath),
						L"RSOP_IEProgramSettings.rsopID=\"IEAK\",rsopPrecedence=%ld", dwCurGPOPrec);
			_bstr_t bstrObjPath = wszObjPath;

			// get the RSOP_IEProgramSettings object and its properties
			ComPtr<IWbemServices> pWbemServices = pDRD->GetWbemServices();
			ComPtr<IWbemClassObject> pPSObj = NULL;
			HRESULT hr = pWbemServices->GetObject(bstrObjPath, 0L, NULL, (IWbemClassObject**)&pPSObj, NULL);
			if (SUCCEEDED(hr))
			{
				// htmlEditorProgram field
				_variant_t vtValue;
				_bstr_t bstrValue;
				hr = pPSObj->Get(L"htmlEditorProgram", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
				{
					bstrValue = vtValue;
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_HTMLEDITOR_COMBO, CB_ADDSTRING, 0,
										(LPARAM)((LPCTSTR)bstrValue));
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_HTMLEDITOR_COMBO, CB_SETCURSEL, 0, 0L);
				}

				// emailProgram field
				hr = pPSObj->Get(L"emailProgram", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
				{
					bstrValue = vtValue;
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_MAIL_COMBO, CB_ADDSTRING, 0,
										(LPARAM)((LPCTSTR)bstrValue));
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_MAIL_COMBO, CB_SETCURSEL, 0, 0L);
				}

				// newsgroupsProgram field
				hr = pPSObj->Get(L"newsgroupsProgram", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
				{
					bstrValue = vtValue;
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_NEWS_COMBO, CB_ADDSTRING, 0,
										(LPARAM)((LPCTSTR)bstrValue));
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_NEWS_COMBO, CB_SETCURSEL, 0, 0L);
				}

				// internetCallProgram field
				hr = pPSObj->Get(L"internetCallProgram", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
				{
					bstrValue = vtValue;
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_CALL_COMBO, CB_ADDSTRING, 0,
										(LPARAM)((LPCTSTR)bstrValue));
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_CALL_COMBO, CB_SETCURSEL, 0, 0L);
				}

				// calendarProgram field
				hr = pPSObj->Get(L"calendarProgram", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
				{
					bstrValue = vtValue;
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_CALENDAR_COMBO, CB_ADDSTRING, 0,
										(LPARAM)((LPCTSTR)bstrValue));
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_CALENDAR_COMBO, CB_SETCURSEL, 0, 0L);
				}

				// contactListProgram field
				hr = pPSObj->Get(L"contactListProgram", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
				{
					bstrValue = vtValue;
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_CONTACT_COMBO, CB_ADDSTRING, 0,
										(LPARAM)((LPCTSTR)bstrValue));
					SendDlgItemMessage(hDlg, IDC_PROGRAMS_CONTACT_COMBO, CB_SETCURSEL, 0, 0L);
				}

				// checkIfIEIsDefaultBrowser field
				hr = pPSObj->Get(L"checkIfIEIsDefaultBrowser", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
				{
					if ((bool)vtValue)
						CheckDlgButton(hDlg, IDC_CHECK_ASSOCIATIONS_CHECKBOX, BST_CHECKED);
				}

				// IDC_PROGRAMS_IE_IS_FTPCLIENT
			}
		}
	}
	__except(TRUE)
	{
	}
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK importProgramsRSoPProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResult = FALSE;
    switch (uMsg) {
    case WM_INITDIALOG:
	{
		CDlgRSoPData *pDRD = (CDlgRSoPData*)((LPPROPSHEETPAGE)lParam)->lParam;
		InitImportedProgramsDlgInRSoPMode(hDlg, pDRD);


		EnableDlgItem2(hDlg, IDC_PROGRAMS_HTMLEDITOR_COMBO, FALSE);
		EnableDlgItem2(hDlg, IDC_PROGRAMS_MAIL_COMBO, FALSE);
		EnableDlgItem2(hDlg, IDC_PROGRAMS_NEWS_COMBO, FALSE);
		EnableDlgItem2(hDlg, IDC_PROGRAMS_CALL_COMBO, FALSE);
		EnableDlgItem2(hDlg, IDC_PROGRAMS_CALENDAR_COMBO, FALSE);
		EnableDlgItem2(hDlg, IDC_PROGRAMS_CONTACT_COMBO, FALSE);

		EnableDlgItem2(hDlg, IDC_RESETWEBSETTINGS, FALSE);
		EnableDlgItem2(hDlg, IDC_CHECK_ASSOCIATIONS_CHECKBOX, FALSE);
		EnableDlgItem2(hDlg, IDC_PROGRAMS_IE_IS_FTPCLIENT, FALSE);

        fResult = TRUE;
        break;
	}

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            EndDialog(hDlg, IDOK);
            fResult = TRUE;
            break;

        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            fResult = TRUE;
            break;
        }
        break;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\privacy.cpp ===
#include "precomp.h"

#include "rsopsec.h"
#include <urlmon.h>
#include <wininet.h>
#ifdef WINNT
#include <winineti.h>
#endif // WINNT

#define REGSTR_PRIVACYPS_PATH   TEXT("Software\\Policies\\Microsoft\\Internet Explorer")
#define REGSTR_PRIVACYPS_VALU   TEXT("PrivacyAddRemoveSites")

#define ENABLEAPPLY(hDlg) SendMessage( GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L )

typedef struct {
    DWORD dwType;   // what is the type of lParam? is it an unknown passed in with a
                    // property page addition (0), passed in with a
                    // DialogBoxParam call (1), or a new IEPROPPAGEINFO2 ptr for RSoP(2)?
    LPARAM lParam;
} INETCPL_PPAGE_LPARAM, *LPINETCPL_PPAGE_LPARAM;

// structure to pass info to the control panel
typedef struct {
    UINT cbSize;                    // size of the structure
    DWORD dwFlags;                  // enabled page flags (remove pages)
    LPSTR pszCurrentURL;            // the current URL (NULL=none)
    DWORD dwRestrictMask;           // disable sections of the control panel
    DWORD dwRestrictFlags;          // masking for the above
} IEPROPPAGEINFO, *LPIEPROPPAGEINFO;

// structure to pass info to the control panel
// The RSOP field(s) should eventually be moved to the original
// IEPROPPAGEINFO struct and this structure can be removed
typedef struct {
    LPIEPROPPAGEINFO piepi;
    BSTR bstrRSOPNamespace;
} IEPROPPAGEINFO2, *LPIEPROPPAGEINFO2;


///////////////////////////////////////////////////////////////////////////////////////
//
// Advanced privacy settings dialog
//
// We store the advanced settings in the privacy slider struct because it
// can be easily retrieved from the main privacy dlg.  Either we need to
// pass RSoP data from the main dlg to the advanced dlg, or we need to query
// WMI twice.  Since WMI queries are slow, we'll do the former.
//
///////////////////////////////////////////////////////////////////////////////////////
typedef struct _privslider {

    DWORD_PTR   dwLevel;
    BOOL        fAdvanced;
    BOOL        fCustom;
    HFONT       hfontBolded;
    BOOL        fEditDisabled;

    DWORD       dwTemplateFirst;
    WCHAR       szSessionFirst[MAX_PATH];
    DWORD       dwTemplateThird;
    WCHAR       szSessionThird[MAX_PATH];

} PRIVSLIDER, *PPRIVSLIDER;


DWORD MapPrefToIndex(WCHAR wcPref)
{
    switch(wcPref)
    {
    case 'r':   return 1;       // reject
    case 'p':   return 2;       // prompt
    default:    return 0;       // default is accept
    }
}

WCHAR MapRadioToPref(HWND hDlg, DWORD dwResource)
{
    if(IsDlgButtonChecked(hDlg, dwResource + 1))        // deny
    {
        return 'r';
    }

    if(IsDlgButtonChecked(hDlg, dwResource + 2))        // prompt
    {
        return 'p';
    }

    // deafult is accept
    return 'a';
}


void OnAdvancedInit(HWND hDlg, HWND hwndPrivPage)
{
    BOOL    fSession = FALSE;
    DWORD   dwFirst = IDC_FIRST_ACCEPT;
    DWORD   dwThird = IDC_THIRD_ACCEPT;

    PPRIVSLIDER pData = NULL;

    // if we're not in RSoP mode, this returns NULL
    pData = (PPRIVSLIDER)GetWindowLongPtr(hwndPrivPage, DWLP_USER);

    if(NULL != pData && pData->fAdvanced)
    {
        WCHAR   szBuffer[MAX_PATH];  
        // MAX_PATH is sufficent for advanced mode setting strings, MaxPrivacySettings is overkill.
        LPWSTR pszBuffer = szBuffer;
        WCHAR   *pszAlways;
        DWORD   dwError = (DWORD)-1L; // anything but ERROR_SUCCESS

        //
        // turn on advanced check box
        //
        CheckDlgButton(hDlg, IDC_USE_ADVANCED, TRUE);

        //
        // Figure out first party setting and session
        //
        pszBuffer = pData->szSessionFirst;
        if (0 != pszBuffer[0])
            dwError = ERROR_SUCCESS;

        if(ERROR_SUCCESS == dwError)
        {
            pszAlways = StrStrW(pszBuffer, L"always=");
            if(pszAlways)
            {
                dwFirst = IDC_FIRST_ACCEPT + MapPrefToIndex(*(pszAlways + 7));
            }

            if(StrStrW(pszBuffer, L"session"))
            {
                fSession = TRUE;
            }
        }

        //
        // Figure out third party setting
        //
        pszBuffer = pData->szSessionThird;
        if (0 != pszBuffer[0])
            dwError = ERROR_SUCCESS;

        if(ERROR_SUCCESS == dwError)
        {
            WCHAR *pszAlways;

            pszAlways = StrStrW(pszBuffer, L"always=");
            if(pszAlways)
            {
                dwThird = IDC_THIRD_ACCEPT + MapPrefToIndex(*(pszAlways + 7));
            }
        }
    }

    CheckRadioButton(hDlg, IDC_FIRST_ACCEPT, IDC_FIRST_PROMPT, dwFirst);
    CheckRadioButton(hDlg, IDC_THIRD_ACCEPT, IDC_THIRD_PROMPT, dwThird);
    CheckDlgButton( hDlg, IDC_SESSION_OVERRIDE, fSession);
}

void OnAdvancedEnable(HWND hDlg)
{
    EnableWindow(GetDlgItem(hDlg, IDC_USE_ADVANCED), FALSE);

    EnableWindow(GetDlgItem(hDlg, IDC_FIRST_ACCEPT), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_FIRST_DENY), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_FIRST_PROMPT), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_THIRD_ACCEPT), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_THIRD_DENY), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_THIRD_PROMPT), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_SESSION_OVERRIDE), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_TX_FIRST), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_TX_THIRD), FALSE);

    EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_EDIT), FALSE);
}

INT_PTR CALLBACK PrivAdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            OnAdvancedInit(hDlg, (HWND)lParam);
            OnAdvancedEnable(hDlg);
            return TRUE;

        case WM_HELP:           // F1
//            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
//                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
//            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
//                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
         
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    // fall through

                case IDCANCEL:
                    EndDialog(hDlg, IDOK == LOWORD(wParam));
                    return 0;

                case IDC_FIRST_ACCEPT:
                case IDC_FIRST_PROMPT:
                case IDC_FIRST_DENY:
                    CheckRadioButton(hDlg, IDC_FIRST_ACCEPT, IDC_FIRST_PROMPT, LOWORD(wParam));
                    return 0;

                case IDC_THIRD_ACCEPT:
                case IDC_THIRD_PROMPT:
                case IDC_THIRD_DENY:
                    CheckRadioButton(hDlg, IDC_THIRD_ACCEPT, IDC_THIRD_PROMPT, LOWORD(wParam));
                    return 0;

                case IDC_USE_ADVANCED:
                    OnAdvancedEnable(hDlg);
                    return 0;

                case IDC_PRIVACY_EDIT:
//                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_PRIVACY_PERSITE),
//                             hDlg, PrivPerSiteDlgProc);
                    return 0;
            }
            break;
    }
    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////////////
//
// Privacy pane
//
///////////////////////////////////////////////////////////////////////////////////////

#define PRIVACY_LEVELS          6
#define SLIDER_LEVEL_CUSTOM     6

TCHAR szPrivacyLevel[PRIVACY_LEVELS + 1][30];
TCHAR szPrivacyDescription[PRIVACY_LEVELS + 1][300];

void EnablePrivacyControls(HWND hDlg, BOOL fCustom)
{
    WCHAR szBuffer[256];

    if( fCustom)
        LoadString( g_hInstance, IDS_PRIVACY_SLIDERCOMMANDDEF, szBuffer, ARRAYSIZE( szBuffer));
    else
        LoadString( g_hInstance, IDS_PRIVACY_SLIDERCOMMANDSLIDE, szBuffer, ARRAYSIZE( szBuffer));

    SendMessage(GetDlgItem(hDlg, IDC_PRIVACY_SLIDERCOMMAND), WM_SETTEXT, 
                0, (LPARAM)szBuffer);
     
    // slider disabled when custom
    EnableWindow(GetDlgItem(hDlg, IDC_LEVEL_SLIDER),       !fCustom);
    ShowWindow(GetDlgItem(hDlg, IDC_LEVEL_SLIDER),         !fCustom);

    // disable controls if in read-only mode
    EnableWindow(GetDlgItem(hDlg, IDC_LEVEL_SLIDER), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_DEFAULT), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_IMPORT), FALSE);

    EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_IMPORT), FALSE);

    EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_ADVANCED), fCustom);
    if (fCustom)
    {
        //  Give advanced button focus since slider is disabled
        SendMessage( hDlg, WM_NEXTDLGCTL, 
                     (WPARAM)GetDlgItem( hDlg, IDC_PRIVACY_ADVANCED), 
                     MAKELPARAM( TRUE, 0)); 
    }
}

/////////////////////////////////////////////////////////////////////
HRESULT OnPrivacyInitRSoP(CDlgRSoPData *pDRD, PPRIVSLIDER pData)
{
    HRESULT hr = E_FAIL;
    __try
    {
        pData->fAdvanced = FALSE;

        BSTR bstrClass = SysAllocString(L"RSOP_IEPrivacySettings");
        BSTR bstrPrecedenceProp = SysAllocString(L"rsopPrecedence");
        if (NULL != bstrClass && NULL != bstrPrecedenceProp)
        {
            WCHAR wszObjPath[128];
            DWORD dwCurGPOPrec = pDRD->GetImportedSecZonesPrec();

            // create the object path of this privacy instance for this GPO
            wnsprintf(wszObjPath, countof(wszObjPath),
                        L"RSOP_IEPrivacySettings.rsopID=\"IEAK\",rsopPrecedence=%ld", dwCurGPOPrec);
            _bstr_t bstrObjPath = wszObjPath;

            ComPtr<IWbemClassObject> pPrivObj = NULL;
            ComPtr<IWbemServices> pWbemServices = pDRD->GetWbemServices();
            hr = pWbemServices->GetObject(bstrObjPath, 0L, NULL, (IWbemClassObject**)&pPrivObj, NULL);
            if (SUCCEEDED(hr))
            {
                BOOL fPrivacyHandled = FALSE; // unused

                // useAdvancedSettings field
                pData->fAdvanced = GetWMIPropBool(pPrivObj,
                                                L"useAdvancedSettings",
                                                pData->fAdvanced,
                                                fPrivacyHandled);

                // firstPartyPrivacyType field
                pData->dwTemplateFirst = GetWMIPropUL(pPrivObj,
                                                    L"firstPartyPrivacyType",
                                                    pData->dwTemplateFirst,
                                                    fPrivacyHandled);

                // firstPartyPrivacyTypeText field
                GetWMIPropPWSTR(pPrivObj, L"firstPartyPrivacyTypeText",
                                pData->szSessionFirst, ARRAYSIZE(pData->szSessionFirst),
                                NULL, fPrivacyHandled);

                // thirdPartyPrivacyType field
                pData->dwTemplateThird = GetWMIPropUL(pPrivObj,
                                                    L"thirdPartyPrivacyType",
                                                    pData->dwTemplateThird,
                                                    fPrivacyHandled);

                // thirdPartyPrivacyTypeText field
                GetWMIPropPWSTR(pPrivObj, L"thirdPartyPrivacyTypeText",
                                pData->szSessionThird, ARRAYSIZE(pData->szSessionThird),
                                NULL, fPrivacyHandled);
            }

            SysFreeString(bstrClass);
            SysFreeString(bstrPrecedenceProp);
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
PPRIVSLIDER OnPrivacyInit(HWND hDlg, CDlgRSoPData *pDRD)
{
    DWORD   i;
    PPRIVSLIDER pData;
    DWORD dwRet, dwType, dwSize, dwValue;

    // allocate storage for the font and current level
    pData = new PRIVSLIDER;
    if(NULL == pData)
    {
        // doh
        return NULL;
    }
    pData->dwLevel = (DWORD)-1L;
    pData->hfontBolded = NULL;
    pData->fAdvanced = FALSE;
    pData->fCustom = FALSE;
    pData->fEditDisabled = FALSE;

    // data stored in slider struct to pass RSoP data to advanced dlg
    pData->dwTemplateFirst = PRIVACY_TEMPLATE_CUSTOM;
    pData->szSessionFirst[0] = 0;
    pData->dwTemplateThird = PRIVACY_TEMPLATE_CUSTOM;
    pData->szSessionThird[0] = 0;

    //
    // Init RSoP variables
    //
    OnPrivacyInitRSoP(pDRD, pData);

    // 
    // Set the font of the name to the bold font
    //

    // find current font
    HFONT hfontOrig = (HFONT) SendDlgItemMessage(hDlg, IDC_LEVEL, WM_GETFONT, (WPARAM) 0, (LPARAM) 0);
    if(hfontOrig == NULL)
        hfontOrig = (HFONT) GetStockObject(SYSTEM_FONT);

    // build bold font
    if(hfontOrig)
    {
        LOGFONT lfData;
        if(GetObject(hfontOrig, sizeof(lfData), &lfData) != 0)
        {
            // The distance from 400 (normal) to 700 (bold)
            lfData.lfWeight += 300;
            if(lfData.lfWeight > 1000)
                lfData.lfWeight = 1000;
            pData->hfontBolded = CreateFontIndirect(&lfData);
            if(pData->hfontBolded)
            {
                // the zone level and zone name text boxes should have the same font, so this is okat
                SendDlgItemMessage(hDlg, IDC_LEVEL, WM_SETFONT, (WPARAM) pData->hfontBolded, (LPARAM) MAKELPARAM(FALSE, 0));
            }
        }
    }

    // initialize slider
    SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_SETRANGE, (WPARAM) (BOOL) FALSE, (LPARAM) MAKELONG(0, PRIVACY_LEVELS - 1));
    SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_SETTICFREQ, (WPARAM) 1, (LPARAM) 0);

    // initialize strings for levels and descriptions
    for(i=0; i<PRIVACY_LEVELS + 1; i++)
    {
        LoadString(g_hInstance, IDS_PRIVACY_LEVEL_NO_COOKIE + i, szPrivacyLevel[i], ARRAYSIZE(szPrivacyLevel[i]));
        LoadString(g_hInstance, IDS_PRIVACY_DESC_NO_COOKIE + i,  szPrivacyDescription[i], ARRAYSIZE(szPrivacyDescription[i]));
    }

    //
    // Get current internet privacy level
    //
    if(pData->dwTemplateFirst == pData->dwTemplateThird &&
        pData->dwTemplateFirst != PRIVACY_TEMPLATE_CUSTOM)
    {
        // matched template values, set slider to template level
        pData->dwLevel = pData->dwTemplateFirst;

        if(pData->dwTemplateFirst == PRIVACY_TEMPLATE_ADVANCED)
        {
            pData->fAdvanced = TRUE;
            pData->dwLevel = SLIDER_LEVEL_CUSTOM;
        }
    }
    else
    {
        // make custom end of list
        pData->dwLevel = SLIDER_LEVEL_CUSTOM;
        pData->fCustom = TRUE;
    }

    // move slider to right spot
    SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)pData->dwLevel);

    // Enable stuff based on mode
    EnablePrivacyControls(hDlg, ((pData->fAdvanced) || (pData->fCustom)));

    // save off struct
    SetWindowLongPtr(hDlg, DWLP_USER, (DWORD_PTR)pData);

    dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PRIVACYPS_PATH, REGSTR_PRIVACYPS_VALU, &dwType, &dwValue, &dwSize);

    if (ERROR_SUCCESS == dwRet && 1 == dwValue && REG_DWORD == dwType)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_EDIT), FALSE);
        pData->fEditDisabled = TRUE;
    }

    return pData;
}

void OnPrivacySlider(HWND hDlg, PPRIVSLIDER pData, CDlgRSoPData *pDRD = NULL)
{
    DWORD dwPos;

    if(pData->fCustom || pData->fAdvanced)
    {
        dwPos = SLIDER_LEVEL_CUSTOM;
    }
    else
    {
        dwPos = (DWORD)SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_GETPOS, 0, 0);

        if(dwPos != pData->dwLevel)
        {
            ENABLEAPPLY(hDlg);
        }

        if (NULL == pDRD)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_DEFAULT), 
                         (dwPos != PRIVACY_TEMPLATE_MEDIUM) ? TRUE : FALSE);
        }
    }

    if (NULL != pDRD ||
        PRIVACY_TEMPLATE_NO_COOKIES == dwPos || PRIVACY_TEMPLATE_LOW == dwPos || pData->fEditDisabled)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_EDIT), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_EDIT), TRUE);
    }

    // on Mouse Move, change the level description only
    SetDlgItemText(hDlg, IDC_LEVEL_DESCRIPTION, szPrivacyDescription[dwPos]);
    SetDlgItemText(hDlg, IDC_LEVEL, szPrivacyLevel[dwPos]);
}

INT_PTR CALLBACK PrivacyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PPRIVSLIDER pData = (PPRIVSLIDER)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            // IEAK team needs additional info passed in for RSoP, so they're making
            // use of lParam, which doesn't seem to be used as per the comments above

            // Retrieve Property Sheet Page info
            CDlgRSoPData *pDRD = (CDlgRSoPData*)((LPPROPSHEETPAGE)lParam)->lParam;

            // The dlg needs to store the RSoP and other info for later use, particularly
            // for the advanced dlg
            // On second thought, all the info is stored in the pData variable - never mind.
//            HWND hwndPSheet = GetParent(hDlg);
//            SetWindowLongPtr(hwndPSheet, GWLP_USERDATA, (LONG_PTR)pDRD);

            // initialize slider
            pData = OnPrivacyInit(hDlg, pDRD);
            if(pData)
                OnPrivacySlider(hDlg, pData, pDRD);
            return TRUE;
        }

        case WM_VSCROLL:
            // Slider Messages
            OnPrivacySlider(hDlg, pData);
            return TRUE;

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            ASSERT(lpnm);

            switch (lpnm->code)
            {
                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    return TRUE;

                case PSN_APPLY:
                    break;
            }
            break;
        }
        case WM_DESTROY:
        {
            if(pData)
            {
                if(pData->hfontBolded)
                    DeleteObject(pData->hfontBolded);

                delete pData;
            }
            break;
        }
        case WM_HELP:           // F1
//            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
//                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
//            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
//                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
         
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_PRIVACY_DEFAULT:
                    return 0;

                case IDC_PRIVACY_ADVANCED:
                {
                    // show advanced, pass in hDlg as lparam so we can get to this prop page's data
                    if( DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_PRIVACY_ADVANCED),
                                        hDlg, PrivAdvancedDlgProc, (LPARAM)hDlg))
                    {
                    }
                    return 0;
                }

                case IDC_PRIVACY_IMPORT:
                    return 0;       
                case IDC_PRIVACY_EDIT:
//                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_PRIVACY_PERSITE),
//                              hDlg, PrivPerSiteDlgProc);
                    return 0;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ieaksie.rc
//
#define IDB_IEAKSNAPINEXT_16            301
#define IDB_IEAKSNAPINEXT_32            302
#define IDB_IEAKSIEHELPABT_16           303
#define IDB_IEAKSIEHELPABT_32           304
#define IDI_HELPABOUT                   351
#define IDM_CONTEXTSAVE                 413
#define IDM_CONTEXTONCE                 414
#define IDM_CONTEXTRESET                415
#define IDB_BUTTONS                     470
#define IDB_KEYS                        471
#define IDB_LOCK                        472
#define IDC_PROGRAMS_MAIL_COMBO         501
#define IDC_PROGRAMS_NEWS_COMBO         502
#define IDC_CHECK_ASSOCIATIONS_CHECKBOX 503
#define IDC_PROGRAMS_CALENDAR_COMBO     504
#define IDC_PROGRAMS_MAILANDNEWS_GROUPBOX 505
#define IDC_PROGRAMS_CONTACT_COMBO      506
#define IDC_PROGRAMS_IE_IS_FTPCLIENT    507
#define IDC_PROGRAMS_CALL_COMBO         508
#define IDC_PROGRAMS_HTMLEDITOR_COMBO   509
#define IDC_RESETWEBSETTINGS            510
#define IDC_RESETWEBSETTINGS_TEXT       511
#define IDC_CONNECTION_WIZARD           520
#define IDC_GRP_DIALUPSETTINGS          521
#define IDC_CONN_LIST                   522
#define IDC_DIALUP_ADD                  523
#define IDC_DIALUP_REMOVE               524
#define IDC_MODEM_SETTINGS              525
#define IDC_DIALUP_NEVER                526
#define IDC_DIALUP_ON_NONET             527
#define IDC_DIALUP                      528
#define IDC_DIAL_DEF_TXT                529
#define IDC_DIAL_DEF_ISP                530
#define IDC_SET_DEFAULT                 531
#define IDC_ENABLE_SECURITY             532
#define IDC_GRP_LANSETTINGS             533
#define IDC_CON_SHARING                 534
#define IDC_LAN_SETTINGS                535
#define IDC_AUTODISCOVER                536
#define IDC_CONFIGSCRIPT                537
#define IDC_CONFIGADDR_TX               538
#define IDC_CONFIG_ADDR                 539
#define IDC_GRP_PROXY                   540
#define IDC_MANUAL                      541
#define IDC_ADDRESS_TEXT                542
#define IDC_PROXY_ADDR                  543
#define IDC_PORT_TEXT                   544
#define IDC_PROXY_PORT                  545
#define IDC_PROXY_ADVANCED              546
#define IDC_PROXY_OMIT_LOCAL_ADDRESSES  547
#define IDC_LIST_ZONE                   550
#define IDC_ZONE_ICON                   551
#define IDC_ZONELABEL                   552
#define IDC_STATIC_EMPTY                553
#define IDC_ZONE_DESCRIPTION            554
#define IDC_BUTTON_ADD_SITES            555
#define IDC_LEVEL_GROUPBOX              556
#define IDC_SLIDER                      557
#define IDC_STATIC_SLIDERMOVETEXT       558
#define IDC_LEVEL_NAME                  559
#define IDC_LEVEL_DESCRIPTION           560
#define IDC_BUTTON_SETTINGS             561
#define IDC_ZONE_RESET                  562
#define IDC_EDIT_ADD_SITE               565
#define IDC_BUTTON_ADD                  566
#define IDC_LIST_WEBSITES               567
#define IDC_BUTTON_REMOVE               568
#define IDC_CHECK_REQUIRE_SERVER_VERIFICATION 569
#define IDC_CHECK_USEINTRANET           570
#define IDC_CHECK_PROXY                 571
#define IDC_CHECK_UNC                   572
#define IDC_INTRANET_ADVANCED           573
#define IDC_TREE_SECURITY_SETTINGS      574
#define IDC_DEFAULT_SETTINGS_GROUPBOX   575
#define IDC_COMBO_RESETLEVEL            576
#define IDC_BUTTON_APPLY                577
#define IDC_JAVACUSTOM                  578
#define IDC_PT_TREE                     580
#define IDC_RATING_LABEL                581
#define IDC_PT_TB_SELECT                582
#define IDC_PT_T_RSN_SDESC              583
#define IDC_STATIC2                     584
#define IDC_PT_T_RSN_LDESC              585
#define IDC_PT_T_BITMAP_CATEGORY        586
#define IDC_PT_T_BITMAP_LABEL           587
#define IDC_STATIC3                     588
#define IDC_DETAILSBUTTON               589
#define IDC_STATIC_ALLOW                590
#define IDC_PICSRULESAPPROVEDEDIT       591
#define IDC_PICSRULESAPPROVEDALWAYS     592
#define IDC_PICSRULESAPPROVEDNEVER      593
#define IDC_STATIC_LIST                 594
#define IDC_PICSRULESAPPROVEDLIST       595
#define IDC_PICSRULESAPPROVEDREMOVE     596
#define IDC_UNRATED                     597
#define IDC_PLEASE_MOMMY                598
#define IDC_STATIC1                     599
#define IDC_CHANGE_PASSWORD             600
#define IDC_STATIC4                     601
#define IDC_STATIC5                     602
#define IDC_STATIC6                     603
#define IDC_FINDRATINGS                 604
#define IDC_PROVIDER                    605
#define IDC_TEXT2                       607
#define IDC_3RD_COMBO                   609
#define IDC_STATIC_PICSRULES            610
#define IDC_STATIC_PICSRULES2           611
#define IDC_PICSRULES_LIST              612
#define IDC_PICSRULESOPEN               613
#define IDC_PICSRULESEDIT               614
#define IDC_PICSRULES_UP                615
#define IDC_PICSRULES_DOWN              616
#define IDI_MESSAGING                   901
#define IDI_CONGEN                      902
#define IDI_PHONE                       903
#define IDI_LAN                         904
#define IDI_ZONE                        905
#define IDI_SECURITY                    906
#define IDI_MASTER_KEY                  907
#define IDI_RATING_SYSTEMS              908
#define IDI_ACCEPTALWAYS                909
#define IDI_ACCEPTNEVER                 910
#define IDI_PICSRULES_UP                911
#define IDI_PICSRULES_DOWN              912
#define IDD_RSOPP                       1080
#define IDD_IMPORTEDPROGRAMS            1090
#define IDD_IMPORTEDCONNSETTINGS        1091
#define IDD_IMPORTEDSECZONES            1092
#define IDD_SECURITY_ADD_SITES          1093
#define IDD_SECURITY_INTRANET           1094
#define IDD_SECURITY_CUSTOM_SETTINGS    1095
#define IDD_RATINGS                     1096
#define IDD_APPROVEDSITES               1097
#define IDD_GENERAL                     1098
#define IDD_ADVANCED                    1099
#define IDD_PRIVACY                     1100
#define IDD_PRIVACY_ADVANCED            1101
#define IDD_IEESCDLG                    1102
#define IDS_CONTEXT_EXPORT              10011
#define IDS_CONTEXT_EXPORT_DESC         10012
#define IDS_CONTEXT_ONCE                10013
#define IDS_CONTEXT_ONCE_DESC           10014
#define IDS_CONTEXT_RESET               10015
#define IDS_CONTEXT_RESET_DESC          10016
#define IDS_TOOLBARBUTTON_PREC          10017
#define IDS_HDR_NAME                    10101
#define IDS_HDR_DESC                    10102
#define IDS_NAME_INDIRECT               10110
#define IDS_SIE_NAME                    10111
#define IDS_SIE_DESC                    10112
#define IDS_SNAPIN_DESC                 10113
#define IDS_PROVIDER_NAME               10114
#define IDS_SNAPIN_VERSION              10115
#define IDS_ABOUT_NAME                  10116
#define IDS_BROWSERGRP_NAME             10121
#define IDS_BROWSERGRP_DESC             10122
#define IDS_CONNGRP_NAME                10123
#define IDS_CONNGRP_DESC                10124
#define IDS_URLSGRP_NAME                10125
#define IDS_URLSGRP_DESC                10126
#define IDS_SECURITYGRP_NAME            10127
#define IDS_SECURITYGRP_DESC            10128
#define IDS_ADMGRP_NAME                 10129
#define IDS_ADMGRP_DESC                 10130
#define IDS_PROGGRP_NAME                10131
#define IDS_PROGGRP_DESC                10132
#define IDS_ERROR_CONTEXTMENU           10200
#define IDS_ERROR_SAVE                  10201
#define IDS_ERROR_ONETIME               10202
#define IDS_ERROR_NEEDRESET             10203
#define IDS_RESET_WARN                  10300
#define IDS_GPONAME                     10310
#define IDS_GPOSETTING                  10311
#define IDS_ENABLED                     10312
#define IDS_DISABLED                    10313
#define IDS_UNKNOWN                     10314
#define IDS_TRUE                        10315
#define IDS_FALSE                       10316
#define IDS_ARRAY                       10317
#define IDS_EMPTY                       10318
#define IDS_CONVERSIONERROR             10319
#define IDS_VIEW                        10320
#define IDS_VIEW_SETTINGS               10321
#define IDS_INTERNET_LOC                10322
#define IDS_PRECEDENCE                  10400
#define IDS_TITLE_PREC                  10401
#define IDS_TOOLBARBMP_PREC             10402
#define IDS_SMALLBMP_PREC               10403
#define IDS_LARGEBMP_PREC               10404
#define IDS_SMALLLOGO_PREC              10405
#define IDS_LARGELOGO_PREC              10406
#define IDS_BTOOLBAR_SETTING            10407
#define IDS_BTOOLBAR_DEL_SETTING        10408
#define IDS_CS_IMPORT_SETTING           10410
#define IDS_CS_DELETE_SETTING           10411
#define IDS_CS_IMP_DEL_SETTING          10412
#define IDS_AUTODETECT_CFG_PREC         10413
#define IDS_AUTOCFG_ENABLE_PREC         10414
#define IDS_FAV_ONTOP_PREC              10416
#define IDS_DEL_FAVS_PREC               10417
#define IDS_FAVS_PREC                   10418
#define IDS_PLACEATTOP_SETTING          10419
#define IDS_DELEXISTING_SETTING         10420
#define IDS_DELADMINCREATED_SETTING     10421
#define IDS_FAVS_AND_LINKS_SETTING      10422
#define IDS_HOMEPAGE_PREC               10423
#define IDS_SEARCHPAGE_PREC             10424
#define IDS_SUPPORTPAGE_PREC            10425
#define IDS_DEL_CHANNELS_PREC           10426
#define IDS_ENABLE_CH_BAR_PREC          10427
#define IDS_CHANNELS_PREC               10428
#define IDS_DELETE_CHAN_SETTING         10429
#define IDS_ENABLE_CHBAR_SETTING        10430
#define IDS_CHAN_AND_CAT_SETTING        10431
#define IDS_SECZONES_PREC               10435
#define IDS_CONTENTRAT_PREC             10436
#define IDS_IMPORTZONES_SETTING         10437
#define IDS_IMPORTRATINGS_SETTING       10438
#define IDS_AUTHSECURITY_PREC           10439
#define IDS_PUB_LOCK_PREC               10440
#define IDS_IMPORT_AUTHSEC_SETTING      10441
#define IDS_ENABLE_PUB_LOCK_SETTING     10442
#define IDS_IMPORT_PROG_SETTING         10445
#define IDS_TEMPLATE_DESC_HI            10450
#define IDS_TEMPLATE_DESC_MED           10451
#define IDS_TEMPLATE_DESC_MEDLOW        10452
#define IDS_TEMPLATE_DESC_LOW           10453
#define IDS_TEMPLATE_DESC_CUSTOM        10454
#define IDS_TEMPLATE_NAME_HI            10455
#define IDS_TEMPLATE_NAME_MED           10456
#define IDS_TEMPLATE_NAME_MEDLOW        10457
#define IDS_TEMPLATE_NAME_LOW           10458
#define IDS_TEMPLATE_NAME_CUSTOM        10459
#define IDS_TEMPLATE_NAME_UNDEFINED     10460
#define IDS_WRITE_WARNING               10461
#define IDS_WARNING                     10462
#define IDS_GENERIC                     10463
#define IDC_PRIVACY_SLIDERCOMMAND       10470
#define IDC_LEVEL_SLIDER                10471
#define IDC_LEVEL                       10472
#define IDI_PRIV                        10473
#define IDC_PRIVACY_IMPORT              10474
#define IDC_PRIVACY_ADVANCED            10475
#define IDC_PRIVACY_DEFAULT             10476
#define IDC_PRIVACY_EDIT                10477
#define IDC_USE_ADVANCED                10478
#define IDC_TX_FIRST                    10479
#define IDC_FIRST_ACCEPT                10480
#define IDC_FIRST_DENY                  10481
#define IDC_FIRST_PROMPT                10482
#define IDC_TX_THIRD                    10483
#define IDC_THIRD_ACCEPT                10484
#define IDC_THIRD_DENY                  10485
#define IDC_THIRD_PROMPT                10486
#define IDC_SESSION_OVERRIDE            10487
#define IDI_PRIV_IMPORT                 10488
#define IDS_PRIVACY_SLIDERCOMMANDSLIDE  10489
#define IDS_PRIVACY_SLIDERCOMMANDDEF    10490
#define IDS_PRIVACY_LEVEL_NO_COOKIE     10491
#define IDS_PRIVACY_LEVEL0              10492
#define IDS_PRIVACY_LEVEL1              10493
#define IDS_PRIVACY_LEVEL2              10494
#define IDS_PRIVACY_LEVEL3              10495
#define IDS_PRIVACY_LEVEL4              10496
#define IDS_PRIVACY_LEVEL5              10497
#define IDS_PRIVACY_DESC_NO_COOKIE      10498
#define IDS_PRIVACY_DESC0               10499
#define IDS_PRIVACY_DESC1               10500
#define IDS_PRIVACY_DESC2               10501
#define IDS_PRIVACY_DESC3               10502
#define IDS_PRIVACY_DESC4               10503
#define IDS_PRIVACY_DESC5               10504
#define IDS_IESC_HARDENDESC1            10505
#define IDS_IESC_HARDENDESC2            10506
#define IDS_IESC_HARDENDESC3            10507
#define IDS_IESC_HARDENDESC4            10508
#define IDS_IESC_SOFTENESC1             10509
#define IDS_IESC_SOFTENESC2             10510
#define IDS_IESC_SOFTENESC3             10511
#define IDS_IESC_SOFTENESC4             10512
#define IDS_IESCINFO                    10513
#define IDS_IEESCTITLE                  10514

#define IDC_GPOLIST                     10900
#define IDC_UNUSED                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\rsop.cpp ===
#include "precomp.h"

#include "rsop.h"

#include <comdef.h>
#include <tchar.h>

#include "resource.h"


/////////////////////////////////////////////////////////////////////
// precedence page function prototypes for each dialog

// title.cpp
extern HRESULT InitTitlePrecPage(CDlgRSoPData *pDRD, HWND hwndList);

// logo.cpp
extern HRESULT InitSmallLogoPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitLargeLogoPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitSmallBmpPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitLargeBmpPrecPage(CDlgRSoPData *pDRD, HWND hwndList);

// btoolbar.cpp
extern HRESULT InitBToolbarPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitToolbarBmpPrecPage(CDlgRSoPData *pDRD, HWND hwndList);

// cs.cpp
extern HRESULT InitCSPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitAutoDetectCfgPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitAutoCfgEnablePrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitProxyPrecPage(CDlgRSoPData *pDRD, HWND hwndList);

// useragnt.cpp
extern HRESULT InitUserAgentPrecPage(CDlgRSoPData *pDRD, HWND hwndList);

// favs.cpp
extern HRESULT InitFavsPlacementPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitFavsDeletionPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitFavsPrecPage(CDlgRSoPData *pDRD, HWND hwndList);

// urls.cpp
extern HRESULT InitHomePageUrlPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitSearchBarUrlPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitSupportPageUrlPrecPage(CDlgRSoPData *pDRD, HWND hwndList);

// seczones.cpp
extern HRESULT InitSecZonesPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitContentRatPrecPage(CDlgRSoPData *pDRD, HWND hwndList);

// secauth.cpp
extern HRESULT InitSecAuthPrecPage(CDlgRSoPData *pDRD, HWND hwndList);
extern HRESULT InitAuthLockdownPrecPage(CDlgRSoPData *pDRD, HWND hwndList);

// programs.cpp
extern HRESULT InitProgramsPrecPage(CDlgRSoPData *pDRD, HWND hwndList);

/////////////////////////////////////////////////////////////////////

typedef HRESULT (* PRECEDENCE_HANDLER_PROC)(CDlgRSoPData *pDRD, HWND hwndList);
typedef struct _PRECEDENCE_HANDLER
{
    INT iDlgID;
    INT iPageIndex;
    PRECEDENCE_HANDLER_PROC pfnHandler;
} PRECEDENCE_HANDLER, *LPPRECEDENCE_HANDLER;

#define PH_BTITLE                0
#define PH_CUSTICON              1
#define PH_BTOOLBARS             5
#define PH_CONNECTSET            7
#define PH_QUERYAUTOCONFIG        8
#define PH_PROXY                10
#define PH_UASTRDLG                11
#define PH_FAVORITES            12
#define PH_STARTSEARCH            15
#define PH_SECURITY1            18
#define PH_SECURITYAUTH            20
#define PH_PROGRAMS                22


static PRECEDENCE_HANDLER s_PrecHandlers[] =
{
    {IDD_BTITLE, 0, InitTitlePrecPage},                        // PH_BTITLE = 0
    {IDD_CUSTICON, 0, InitSmallLogoPrecPage},                // PH_CUSTICON = 1
    {IDD_CUSTICON, 1, InitLargeLogoPrecPage},
    {IDD_CUSTICON, 2, InitSmallBmpPrecPage},                
    {IDD_CUSTICON, 3, InitLargeBmpPrecPage},
    {IDD_BTOOLBARS, 0, InitBToolbarPrecPage},                // PH_BTOOLBARS = 5
    {IDD_BTOOLBARS, 1, InitToolbarBmpPrecPage},                
    {IDD_CONNECTSET, 0, InitCSPrecPage},                    // PH_CONNECTSET = 7
    {IDD_QUERYAUTOCONFIG, 0, InitAutoDetectCfgPrecPage},    // PH_QUERYAUTOCONFIG = 8
    {IDD_QUERYAUTOCONFIG, 1, InitAutoCfgEnablePrecPage},
    {IDD_PROXY, 0, InitProxyPrecPage},                        // PH_PROXY = 10
    {IDD_UASTRDLG, 0, InitUserAgentPrecPage},                // PH_UASTRDLG = 11
    {IDD_FAVORITES, 0, InitFavsPlacementPrecPage},            // PH_FAVORITES = 12
    {IDD_FAVORITES, 1, InitFavsDeletionPrecPage},
    {IDD_FAVORITES, 2, InitFavsPrecPage},
    {IDD_STARTSEARCH, 0, InitHomePageUrlPrecPage},            // PH_UASTRDLG = 15
    {IDD_STARTSEARCH, 1, InitSearchBarUrlPrecPage},
    {IDD_STARTSEARCH, 2, InitSupportPageUrlPrecPage},
    {IDD_SECURITY1, 0, InitSecZonesPrecPage},                // PH_SECURITY1 = 18
    {IDD_SECURITY1, 1, InitContentRatPrecPage},
    {IDD_SECURITYAUTH, 0, InitSecAuthPrecPage},                // PH_SECURITYAUTH = 20
    {IDD_SECURITYAUTH, 1, InitAuthLockdownPrecPage},
    {IDD_PROGRAMS, 0, InitProgramsPrecPage}                    // PH_PROGRAMS = 22
};

/////////////////////////////////////////////////////////////////////
// global var to store disabled string
TCHAR g_szDisabled[64] = _T("");
TCHAR g_szEnabled[64] = _T("");
LPCTSTR GetDisabledString() {return g_szDisabled;}
LPCTSTR GetEnabledString() {return g_szEnabled;}


/////////////////////////////////////////////////////////////////////
BOOL IsVariantNull(const VARIANT &v) {return (VT_NULL == v.vt) ? TRUE : FALSE;}

/////////////////////////////////////////////////////////////////////
_bstr_t WbemValueToString(VARIANT &v)
{
    _bstr_t bstrVal;
    __try
    {
        switch(v.vt)
        {
        case CIM_STRING:
            bstrVal = v.bstrVal;
            break;

        case CIM_SINT8:
        case CIM_SINT16:
        case CIM_UINT8:
        case CIM_UINT16:
        case CIM_SINT32:
        case CIM_UINT32:
        {
            WCHAR wszBuf[32];

            switch (v.vt)
            {
            case CIM_SINT8:
            case CIM_SINT16:
                wnsprintf(wszBuf, countof(wszBuf), L"%hd", (CIM_SINT8 == v.vt) ? v.cVal : v.iVal); break;

            case CIM_UINT8:
            case CIM_UINT16:
                wnsprintf(wszBuf, countof(wszBuf), L"%hu", (CIM_UINT8 == v.vt) ? v.bVal : v.uiVal); break;

            case CIM_SINT32:
                wnsprintf(wszBuf, countof(wszBuf), L"%d", v.lVal); break;

            case CIM_UINT32:
                wnsprintf(wszBuf, countof(wszBuf), L"%u", v.ulVal); break;

            }

            bstrVal = wszBuf;
            break;
        }

        case CIM_BOOLEAN:
        {
            TCHAR szBuf[32];
            if (!v.boolVal)
                LoadString(g_hInstance, IDS_FALSE, szBuf, countof(szBuf));
            else
                LoadString(g_hInstance, IDS_TRUE, szBuf, countof(szBuf));

            bstrVal = szBuf;
            break;
        }

        case CIM_UINT8 | CIM_FLAG_ARRAY:
        {
            SAFEARRAY *pVec = v.parray;
            long iLBound, iUBound;

            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);

            TCHAR szBuf[32];
            if ((iUBound - iLBound + 1) == 0)
                LoadString(g_hInstance, IDS_EMPTY, szBuf, countof(szBuf));
            else
                LoadString(g_hInstance, IDS_ARRAY, szBuf, countof(szBuf));

            bstrVal = szBuf;
            break;
        }

        default:
        {
            TCHAR szBuf[128];
            LoadString(g_hInstance, IDS_CONVERSIONERROR, szBuf, countof(szBuf));
            bstrVal = szBuf;
            break;
        }

        }
    }
    __except(TRUE)
    {
    }
    return bstrVal;
}

/////////////////////////////////////////////////////////////////////
CDlgRSoPData *GetDlgRSoPData(HWND hDlg, CSnapIn *pCS)
{
    CDlgRSoPData *pDRD = NULL;
    __try
    {
        HWND hwndPSheet = GetParent(hDlg);
        pDRD = (CDlgRSoPData*)GetWindowLongPtr(hwndPSheet, GWLP_USERDATA);
        if (NULL == pDRD)
        {
            pDRD = new CDlgRSoPData(pCS);
            SetWindowLongPtr(hwndPSheet, GWLP_USERDATA, (LONG_PTR)pDRD);
        }
    }
    __except(TRUE)
    {
    }
    return pDRD;
}

/////////////////////////////////////////////////////////////////////
void DestroyDlgRSoPData(HWND hDlg)
{
    __try
    {
        // delete RSoP data if stored in parent
        HWND hwndPSheet = GetParent(hDlg);
        CDlgRSoPData *pDRD = (CDlgRSoPData*)GetWindowLongPtr(hwndPSheet, GWLP_USERDATA);
        if (NULL != pDRD)
            delete pDRD;
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
_bstr_t GetGPOSetting(ComPtr<IWbemClassObject> pPSObj, BSTR bstrSettingName)
{
    _bstr_t bstrSetting;
    __try
    {
        ASSERT(NULL != pPSObj);

        _variant_t vtSetting;
        HRESULT hr = pPSObj->Get(bstrSettingName, 0, &vtSetting, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            if (IsVariantNull(vtSetting))
                bstrSetting = GetDisabledString();
            else
                bstrSetting = WbemValueToString(vtSetting);
        }
    }
    __except(TRUE)
    {
    }
    return bstrSetting;
}

/////////////////////////////////////////////////////////////////////
// For a class derived from RSOP_PolicySetting, just use the standard
// 'precedence' property.  However, all other IEAK rsop classes should
// have a property which represents its associated PS object's precedence.
// This is typically 'rsopPrecedence', but we'll let the user pass it
// in (bstrProp) because it is custom.
/////////////////////////////////////////////////////////////////////
DWORD GetGPOPrecedence(ComPtr<IWbemClassObject> pPSObj, BSTR bstrProp /*= NULL*/)
{
    DWORD dwPrecedence = 0;
    __try
    {
        ASSERT(NULL != pPSObj);

        _variant_t vtPrec;
        HRESULT hr = NOERROR;
        if (NULL == bstrProp)
            hr = pPSObj->Get(L"precedence", 0, &vtPrec, NULL, NULL);
        else
            hr = pPSObj->Get(bstrProp, 0, &vtPrec, NULL, NULL);

        if (SUCCEEDED(hr))
            dwPrecedence = vtPrec.ulVal;
    }
    __except(TRUE)
    {
    }
    return dwPrecedence;
}

/////////////////////////////////////////////////////////////////////
HRESULT InitGenericPrecedencePage(CDlgRSoPData *pDRD, HWND hwndList, BSTR bstrPropName)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);
                _bstr_t bstrSetting = GetGPOSetting(paPSObj[nObj]->pObj, bstrPropName);
                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
void InsertPrecedenceListItem(HWND hwndList, long nItem, LPTSTR szName, LPTSTR szSetting)
{
    __try
    {
        LVITEM lvi;
        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask = LVIF_TEXT;
        lvi.iItem = nItem;
        lvi.pszText = szName;

        int iListIndex = ListView_InsertItem(hwndList, &lvi);
        if (iListIndex >= 0)
            ListView_SetItemText(hwndList, nItem, 1, szSetting);
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
int CreateINetCplLookALikePage(HWND hwndParent, UINT nID, DLGPROC dlgProc,
                                LPARAM lParam)
{
    int iRet = 0;
    __try
    {
        PROPSHEETPAGE page;

        page.dwSize = sizeof(PROPSHEETPAGE);
        page.dwFlags = 0;
        page.hInstance = g_hInstance;
        page.pszTemplate = MAKEINTRESOURCE(nID);
        page.pfnDlgProc = dlgProc;
        page.pfnCallback = NULL;
        page.lParam = lParam;

        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&page);

        PROPSHEETHEADER psHeader;
        memset(&psHeader,0,sizeof(psHeader));

        psHeader.dwSize = sizeof(psHeader);
        psHeader.dwFlags = PSH_PROPTITLE;
        psHeader.hwndParent = hwndParent;
        psHeader.hInstance = g_hInstance;
        psHeader.nPages = 1;
        psHeader.nStartPage = 0;
        psHeader.phpage = &hPage;
        psHeader.pszCaption = MAKEINTRESOURCE(IDS_INTERNET_LOC);

        iRet = (int)PropertySheet(&psHeader);
    }
    __except(TRUE)
    {
    }
    return iRet;
}

/////////////////////////////////////////////////////////////////////
BOOL GetWMIPropBool(IWbemClassObject *pObj, BSTR bstrProp, BOOL fDefault,
                    BOOL &fHandled)
{
    DWORD fRet = fDefault;
    __try
    {
        BSTR bstrAllocedProp = SysAllocString(bstrProp);
        if (NULL != bstrAllocedProp)
        {
            VARIANT vtValue;
            HRESULT hr = pObj->Get(bstrAllocedProp, 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
            {
                fHandled = TRUE;
                if (0 != vtValue.boolVal)
                    fRet = TRUE;
                else
                    fRet = FALSE;
            }

            SysFreeString(bstrAllocedProp);
        }
    }
    __except(TRUE)
    {
    }
    return fRet;
}

/////////////////////////////////////////////////////////////////////
DWORD GetWMIPropUL(IWbemClassObject *pObj, BSTR bstrProp, DWORD dwDefault,
                   BOOL &fHandled)
{
    DWORD dwRet = dwDefault;
    __try
    {
        BSTR bstrAllocedProp = SysAllocString(bstrProp);
        if (NULL != bstrAllocedProp)
        {
            VARIANT vtValue;
            HRESULT hr = pObj->Get(bstrAllocedProp, 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
            {
                fHandled = TRUE;
                dwRet = vtValue.ulVal;
            }

            SysFreeString(bstrAllocedProp);
        }
    }
    __except(TRUE)
    {
    }
    return dwRet;
}

/////////////////////////////////////////////////////////////////////
void GetWMIPropPWSTR(IWbemClassObject *pObj, BSTR bstrProp, LPWSTR wszBuffer,
                      DWORD dwBufferLen, LPWSTR wszDefault, BOOL &fHandled)
{
    __try
    {
        if (dwBufferLen > 0)
        {
            ZeroMemory(wszBuffer, dwBufferLen);
            if (NULL != wszDefault)
                wcsncpy(wszBuffer, wszDefault, dwBufferLen - 1);

            BSTR bstrAllocedProp = SysAllocString(bstrProp);
            if (NULL != bstrAllocedProp)
            {
                VARIANT vtValue;
                HRESULT hr = pObj->Get(bstrAllocedProp, 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                {
                    fHandled = TRUE;
                    wcsncpy(wszBuffer, (LPWSTR)vtValue.bstrVal, dwBufferLen - 1);
                }

                VariantClear(&vtValue);
                SysFreeString(bstrAllocedProp);
            }
        }
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
void GetWMIPropPTSTR(IWbemClassObject *pObj, BSTR bstrProp, LPTSTR szBuffer,
                      DWORD dwBufferLen, LPTSTR szDefault, BOOL &fHandled)
{
    __try
    {
        if (dwBufferLen > 0)
        {
            ZeroMemory(szBuffer, dwBufferLen);
            if (NULL != szDefault)
                _tcsncpy(szBuffer, szDefault, dwBufferLen - 1);

            BSTR bstrAllocedProp = SysAllocString(bstrProp);
            if (NULL != bstrAllocedProp)
            {
                VARIANT vtValue;
                HRESULT hr = pObj->Get(bstrAllocedProp, 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                {
                    fHandled = TRUE;
#ifdef UNICODE
                    wcsncpy(szBuffer, (LPWSTR)vtValue.bstrVal, dwBufferLen - 1);
#else
                    SHUnicodeToAnsi(vtValue.bstrVal, szBuffer, dwBufferLen);
#endif
                }

                VariantClear(&vtValue);
                SysFreeString(bstrAllocedProp);
            }
        }
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
CDlgRSoPData::CDlgRSoPData(CSnapIn *pCS):
    m_pCS(pCS),
    m_pWbemServices(NULL),
    m_paPSObj(NULL),
    m_nPSObjects(0),
    m_pCRatObj(NULL),
    m_dwImportedProgSettPrec(0),
    m_dwImportedConnSettPrec(0),
    m_dwImportedSecZonesPrec(0),
    m_dwImportedSecRatingsPrec(0),
    m_dwImportedAuthenticodePrec(0),
    m_dwImportedSecZones(0),
    m_paCSObj(0),
    m_nCSObjects(0)
{
    __try
    {
        ASSERT(NULL != pCS);

		// WMI Certificate Info storage for each tab
		m_pwci[0] = m_pwci[1] = m_pwci[2] = m_pwci[3] = m_pwci[4] = NULL;
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
CDlgRSoPData::~CDlgRSoPData()
{
    __try
    {
		// clear the cache of RSOP_IEAKPolicySetting objects
        for (long nObj = 0; nObj < m_nPSObjects; nObj++)
        {
            delete m_paPSObj[nObj];
            m_paPSObj[nObj] = NULL;
        }

        if (NULL != m_paPSObj)
            CoTaskMemFree(m_paPSObj);

		// clear the cache of RSOP_IEConnectionSettings objects
        for (long nObj = 0; nObj < m_nCSObjects; nObj++)
        {
            delete m_paCSObj[nObj];
            m_paCSObj[nObj] = NULL;
        }

        if (NULL != m_paCSObj)
            CoTaskMemFree(m_paCSObj);

		// free certificate info
		UninitCertInfo();
    }
    __except(TRUE)
    {
    }
}

//////////////////////////////////////////////////////////////////////
void CDlgRSoPData::UninitCertInfo()
{
	__try
	{
		for (long iTab = 0; iTab < 5; iTab++)
		{
			WMI_CERT_INFO *pwciToBeDeleted = NULL;
			WMI_CERT_INFO *pwci = m_pwci[iTab];
			while (pwci)
			{
				if (NULL != pwci->wszSubject)
				{
					LocalFree(pwci->wszSubject);
					pwci->wszSubject = NULL;
				}
				if (NULL != pwci->wszIssuer)
				{
					LocalFree(pwci->wszIssuer);
					pwci->wszIssuer = NULL;
				}
				if (NULL != pwci->wszFriendlyName)
				{
					LocalFree(pwci->wszFriendlyName);
					pwci->wszFriendlyName = NULL;
				}
				if (NULL != pwci->wszPurposes)
				{
					LocalFree(pwci->wszPurposes);
					pwci->wszPurposes = NULL;
				}

				pwciToBeDeleted = pwci;
				pwci = pwci->pNext;

				if (NULL != pwciToBeDeleted)
				{
					LocalFree(pwciToBeDeleted);
					pwciToBeDeleted = NULL;
				}
			}

			m_pwci[iTab] = NULL;
		}
	}
	__except(TRUE)
	{
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
// If pWbemServices is non-null, the existing value is used for queries
/////////////////////////////////////////////////////////////////////////////////////////
ComPtr<IWbemServices> CDlgRSoPData::ConnectToNamespace()
{
    __try
    {
        // If we haven't already cached the WbemServices ptr, get it
        // and cache it.
        if (NULL == m_pWbemServices)
        {
            // Connect to the namespace using the locator's
            // ConnectServer method
            ComPtr<IWbemLocator> pIWbemLocator = NULL;
            if (CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                                 IID_IWbemLocator, (LPVOID *) &pIWbemLocator) == S_OK)
            {
                BSTR bstrNamespace = GetNamespace();
                HRESULT hr = pIWbemLocator->ConnectServer(bstrNamespace, NULL, NULL,
                                                            0L, 0L, NULL, NULL,
                                                            &m_pWbemServices);

                if (FAILED(hr))
                {
                    ASSERT(0);
                }

                pIWbemLocator = NULL;
            }
            else
            {
                ASSERT(0);
            }
        }
    }
    __except(TRUE)
    {
    }
    return m_pWbemServices;
}

/////////////////////////////////////////////////////////////////////
_bstr_t CDlgRSoPData::GetGPONameFromPS(ComPtr<IWbemClassObject> pPSObj)
{
    _bstr_t bstrGPOName;
    __try
    {
        ASSERT(NULL != pPSObj);

        if (NULL != ConnectToNamespace())
        {
            _variant_t vtGPOID;
            HRESULT hr = pPSObj->Get(L"GPOID", 0, &vtGPOID, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                _bstr_t bstrObjPath = L"RSOP_GPO.id=\"";
                bstrObjPath += vtGPOID.bstrVal;
                bstrObjPath += L"\"";
                ComPtr<IWbemClassObject> pGPO = NULL;
                hr = m_pWbemServices->GetObject(bstrObjPath, 0L, NULL, (IWbemClassObject**)&pGPO, NULL);
                if (SUCCEEDED(hr))
                {
                    _variant_t vtName;
                    hr = pGPO->Get(L"name", 0, &vtName, NULL, NULL);
                    if (SUCCEEDED(hr) && VT_BSTR == vtName.vt)
                        bstrGPOName = vtName.bstrVal;
                }
            }
        }
    }
    __except(TRUE)
    {
    }
    return bstrGPOName;
}

/////////////////////////////////////////////////////////////////////
_bstr_t CDlgRSoPData::GetGPONameFromPSAssociation(ComPtr<IWbemClassObject> pObj,
                                                  BSTR bstrPrecedenceProp)
{
    _bstr_t bstrGPOName;
    __try
    {
        ASSERT(NULL != pObj);

        if (NULL != ConnectToNamespace())
        {
            // first get the item's precedence value
            _variant_t vtPrecedence;
            HRESULT hr = pObj->Get(bstrPrecedenceProp, 0, &vtPrecedence, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                DWORD dwPrec = vtPrecedence.ulVal;

                WCHAR wszObjPath[128];
                wnsprintf(wszObjPath, countof(wszObjPath), L"RSOP_IEAKPolicySetting.id=\"IEAK\",precedence=%ld", dwPrec);
                _bstr_t bstrObjPath = wszObjPath;

                ComPtr<IWbemClassObject> pPSObj = NULL;
                hr = m_pWbemServices->GetObject(bstrObjPath, 0L, NULL, (IWbemClassObject**)&pPSObj, NULL);
                if (SUCCEEDED(hr))
                    bstrGPOName = GetGPONameFromPS(pPSObj);
            }
        }
    }
    __except(TRUE)
    {
    }
    return bstrGPOName;
}

///////////////////////////////////////////////////////////////////////////////
int CDlgRSoPData::ComparePSObjectsByPrecedence(const void *arg1, const void *arg2)
{
    int iRet = 0;
    __try
    {
        if ( (*(CPSObjData **)arg1)->dwPrecedence > (*(CPSObjData **)arg2)->dwPrecedence )
            iRet = 1;
        else if ( (*(CPSObjData **)arg1)->dwPrecedence < (*(CPSObjData **)arg2)->dwPrecedence )
            iRet = -1;
    }
    __except(TRUE)
    {
        ASSERT(0);
    }
    return iRet;
}

/////////////////////////////////////////////////////////////////////
// To ensure a top-level (currently only RSOP_IEAKPolicySetting) object
// is cached in the DRD, just pass in the first param and leave the rest NULL.
// If ppaPSObj is non NULL, it will be set to a new array of objects.  The
// caller must call CoTaskMemFree on the returned ptr when it is done with
// it.  The 'bstrPrecedenceProp' parameter allows the caller to specify
// a property name other than 'precedence' to get the precedence of the class
// instance (usually rsopPrecedence for non-top-level classes).
/////////////////////////////////////////////////////////////////////
HRESULT CDlgRSoPData::GetArrayOfPSObjects(BSTR bstrClass,
                                          BSTR bstrPrecedenceProp /*= NULL*/,
                                          CPSObjData ***ppaPSObj /*= NULL*/,
                                          long *pnObjCount /*= NULL*/)
{
    HRESULT hr = NOERROR;
    __try
    {
        if (NULL == m_paPSObj || NULL != ppaPSObj)
        {
            hr = E_FAIL;
            CPSObjData **paTempPSObj = NULL;
            long nTempObjects = 0;

            ComPtr<IWbemServices> pWbemServices = ConnectToNamespace();
            if (NULL != pWbemServices)
            {
                ComPtr<IEnumWbemClassObject> pObjEnum = NULL;
                hr = pWbemServices->CreateInstanceEnum(bstrClass,
                                                        WBEM_FLAG_FORWARD_ONLY,
                                                        NULL, &pObjEnum);
                if (SUCCEEDED(hr))
                {
                    #define GROW_PSOBJ_ARRAY_BY        5

                    long nPSArraySize = GROW_PSOBJ_ARRAY_BY;
                    paTempPSObj = (CPSObjData**)CoTaskMemAlloc(sizeof(CPSObjData*) * GROW_PSOBJ_ARRAY_BY);
                    ZeroMemory(paTempPSObj, sizeof(CPSObjData*) * GROW_PSOBJ_ARRAY_BY);

                    // Final Next wil return WBEM_S_FALSE
                    while (WBEM_S_NO_ERROR == hr)
                    {
                        // There should only be one object returned from this query.
                        ULONG uReturned = (ULONG)-1L;
                        ComPtr<IWbemClassObject> pPSObj = NULL;
                        hr = pObjEnum->Next(10000L, 1, &pPSObj, &uReturned);
                        if (SUCCEEDED(hr) && 1 == uReturned)
                        {
                            paTempPSObj[nTempObjects] = new CPSObjData();
                            paTempPSObj[nTempObjects]->pObj = pPSObj;
                            if (NULL == bstrPrecedenceProp)
                                paTempPSObj[nTempObjects]->dwPrecedence = GetGPOPrecedence(pPSObj);
                            else
                                paTempPSObj[nTempObjects]->dwPrecedence =
                                        GetGPOPrecedence(pPSObj, bstrPrecedenceProp);

                            nTempObjects++;


                            // Grow the array of obj paths if we've outgrown the current array
                            if (nTempObjects == nPSArraySize)
                            {
                                paTempPSObj = (CPSObjData**)CoTaskMemRealloc(paTempPSObj, sizeof(CPSObjData*) *
                                                                            nPSArraySize + GROW_PSOBJ_ARRAY_BY);
                                ZeroMemory(paTempPSObj + (nPSArraySize * sizeof(CPSObjData*)),
                                            sizeof(CPSObjData*) * GROW_PSOBJ_ARRAY_BY);

                                if (NULL != paTempPSObj)
                                    nPSArraySize += GROW_PSOBJ_ARRAY_BY;
                            }
                        }
                    }

                    // now sort the list by precedence
                    if (SUCCEEDED(hr))
                        qsort(paTempPSObj, nTempObjects, sizeof(CPSObjData*), ComparePSObjectsByPrecedence);
                }
            }

            if (NULL == ppaPSObj)
            {
                if (!StrCmpIW(bstrClass, L"RSOP_IEConnectionSettings"))
                {
                    m_paCSObj = paTempPSObj;
                    m_nCSObjects = nTempObjects;
                }
                else
                {
                    m_paPSObj = paTempPSObj;
                    m_nPSObjects = nTempObjects;
                }
            }
            else
            {
                *ppaPSObj = paTempPSObj;
                *pnObjCount = nTempObjects;
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT CDlgRSoPData::LoadContentRatingsObject()
{
    HRESULT hr = NOERROR;
    __try
    {
        if (NULL == m_pCRatObj)
        {
            // get our stored precedence value
            DWORD dwCurGPOPrec = m_dwImportedSecRatingsPrec;

            WCHAR wszObjPath[128];
            // create the object path of this security zone for this GPO
            wnsprintf(wszObjPath, countof(wszObjPath),
                        L"RSOP_IESecurityContentRatings.rsopID=\"IEAK\",rsopPrecedence=%ld",
                        dwCurGPOPrec);
            _bstr_t bstrObjPath = wszObjPath;

            // get the RSOP_IEProgramSettings object and its properties
            ComPtr<IWbemServices> pWbemServices = GetWbemServices();
            hr = pWbemServices->GetObject(bstrObjPath, 0L, NULL, (IWbemClassObject**)&m_pCRatObj, NULL);
            if (FAILED(hr))
                m_pCRatObj = NULL;
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
// The dlg proc for all IEAK RSOP precedence property pages
/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK RSoPDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    wParam = wParam;
    lParam = lParam;

    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPRSOPPAGECOOKIE rpCookie = (LPRSOPPAGECOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    switch( msg )
    {
    case WM_INITDIALOG:
    {
        LPRSOPPAGECOOKIE lpRSOPPageCookie = (LPRSOPPAGECOOKIE)(((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lpRSOPPageCookie);

        // Store Property Sheet Page info for later class into dlgProc.
        rpCookie = (LPRSOPPAGECOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        ASSERT(rpCookie->psCookie->pCS->IsRSoP());

        // Initialize the GPO list control
        HWND hwndList = GetDlgItem(hDlg, IDC_GPOLIST);

        LVCOLUMN lvc;
        lvc.mask = LVCF_TEXT | LVCF_WIDTH;
        lvc.fmt = LVCFMT_LEFT;
        lvc.cx = 200;
        TCHAR szHeader[128];
        LoadString(g_hInstance, IDS_GPONAME, szHeader, countof(szHeader));
        lvc.pszText = szHeader;

        ListView_InsertColumn(hwndList, 0, &lvc);

        lvc.cx = 300;
        LoadString(g_hInstance, IDS_GPOSETTING, szHeader, countof(szHeader));
        lvc.pszText = szHeader;
        ListView_InsertColumn(hwndList, 1, &lvc);

        // Initialize the custom data in the list
        if (StrLen(g_szDisabled) <= 0)
            LoadString(g_hInstance, IDS_DISABLED, g_szDisabled, countof(g_szDisabled));
        if (StrLen(g_szEnabled) <= 0)
            LoadString(g_hInstance, IDS_ENABLED, g_szEnabled, countof(g_szEnabled));

        CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, rpCookie->psCookie->pCS);
        long nPrecPage = rpCookie->nPageID;
        switch(rpCookie->psCookie->lpResultItem->iDlgID)
        {
            // Browser User Interface
            case IDD_BTITLE:
                s_PrecHandlers[PH_BTITLE + nPrecPage].pfnHandler(pDRD, hwndList); break;
            case IDD_CUSTICON:
                s_PrecHandlers[PH_CUSTICON + nPrecPage].pfnHandler(pDRD, hwndList); break;
            case IDD_BTOOLBARS:
                s_PrecHandlers[PH_BTOOLBARS + nPrecPage].pfnHandler(pDRD, hwndList); break;

            // Connection
            case IDD_CONNECTSET:
                s_PrecHandlers[PH_CONNECTSET + nPrecPage].pfnHandler(pDRD, hwndList); break;
            case IDD_QUERYAUTOCONFIG:
                s_PrecHandlers[PH_QUERYAUTOCONFIG + nPrecPage].pfnHandler(pDRD, hwndList); break;
            case IDD_PROXY:
                s_PrecHandlers[PH_PROXY + nPrecPage].pfnHandler(pDRD, hwndList); break;
                break;
            case IDD_UASTRDLG:
                s_PrecHandlers[PH_UASTRDLG + nPrecPage].pfnHandler(pDRD, hwndList); break;

            // URLs
            case IDD_FAVORITES:
                s_PrecHandlers[PH_FAVORITES + nPrecPage].pfnHandler(pDRD, hwndList); break;
            case IDD_STARTSEARCH:
                s_PrecHandlers[PH_STARTSEARCH + nPrecPage].pfnHandler(pDRD, hwndList); break;
            
            // Security
            case IDD_SECURITY1:
                s_PrecHandlers[PH_SECURITY1 + nPrecPage].pfnHandler(pDRD, hwndList); break;
            case IDD_SECURITYAUTH:
                s_PrecHandlers[PH_SECURITYAUTH + nPrecPage].pfnHandler(pDRD, hwndList); break;

            // Programs
            case IDD_PROGRAMS:
                s_PrecHandlers[PH_PROGRAMS + nPrecPage].pfnHandler(pDRD, hwndList); break;

            // Advanced
            default:
                break;
        }

        break;
    }

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
            case PSN_HELP:
                if (rpCookie && rpCookie->psCookie && rpCookie->psCookie->lpResultItem)
                {
                    WCHAR wszHelpTopic[MAX_PATH];

                    StrCpyW(wszHelpTopic, HELP_FILENAME TEXT("::/"));
                    StrCatW(wszHelpTopic, rpCookie->psCookie->lpResultItem->pcszHelpTopic);
    
                    MMCPropertyHelp((LPOLESTR)wszHelpTopic);
                }
            
                break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\rsop.h ===
#ifndef __IEAKSIE_RSOP_H__
#define __IEAKSIE_RSOP_H__


#include <comdef.h>
#include <time.h>
#include "wbemcli.h"
#include "SComPtr.h"

/////////////////////////////////////////////////////////////////////
typedef struct _RSOPPAGECOOKIE
{
    LPPROPSHEETCOOKIE psCookie;
	long nPageID;
} RSOPPAGECOOKIE, *LPRSOPPAGECOOKIE;

UINT CALLBACK RSOPPageProc(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

/////////////////////////////////////////////////////////////////////
typedef struct _WMI_CERT_INFO_STRUCT
{
	LPWSTR wszSubject;
	LPWSTR wszIssuer;
	BOOL bExpirationValid;
	FILETIME ftExpiration;
	LPWSTR wszFriendlyName;
	LPWSTR wszPurposes;
	struct _WMI_CERT_INFO_STRUCT *pNext;
} WMI_CERT_INFO;

/////////////////////////////////////////////////////////////////////
class CPSObjData
{
public:
	CPSObjData(): pObj(NULL), dwPrecedence(0) {}

	ComPtr<IWbemClassObject> pObj;
	DWORD dwPrecedence;
};

/////////////////////////////////////////////////////////////////////
// CDlgRSoPData
/////////////////////////////////////////////////////////////////////
class CDlgRSoPData
{
public:
    CDlgRSoPData(CSnapIn *pCS);
    ~CDlgRSoPData();

// operations
public:
	ComPtr<IWbemServices> ConnectToNamespace();

	_bstr_t GetGPONameFromPS(ComPtr<IWbemClassObject> pPSObj);
	_bstr_t GetGPONameFromPSAssociation(ComPtr<IWbemClassObject> pPSObj,
										BSTR bstrPrecedenceProp);

	HRESULT GetArrayOfPSObjects(BSTR bstrClass, BSTR bstrPrecedenceProp = NULL,
								CPSObjData ***ppaPSObj = NULL, long *pnObjCount = NULL);
	HRESULT LoadContentRatingsObject();

// attributes
public:
	BSTR GetNamespace() {return m_pCS->GetRSoPNamespace();}

	ComPtr<IWbemServices> GetWbemServices() {return m_pWbemServices;}

	CPSObjData **GetPSObjArray() {return m_paPSObj;}
	long GetPSObjCount() {return m_nPSObjects;}

	CPSObjData **GetCSObjArray() {return m_paCSObj;}
	long GetCSObjCount() {return m_nCSObjects;}

	ComPtr<IWbemClassObject> GetContentRatingsObject() {return m_pCRatObj;}

    void SetImportedProgSettPrec(DWORD dwPrec) {m_dwImportedProgSettPrec = dwPrec;}
    DWORD GetImportedProgSettPrec() {return m_dwImportedProgSettPrec;}

    void SetImportedConnSettPrec(DWORD dwPrec) {m_dwImportedConnSettPrec = dwPrec;}
    DWORD GetImportedConnSettPrec() {return m_dwImportedConnSettPrec;}

    void SetImportedSecZonesPrec(DWORD dwPrec) {m_dwImportedSecZonesPrec = dwPrec;}
    DWORD GetImportedSecZonesPrec() {return m_dwImportedSecZonesPrec;}

    void SetImportedSecRatingsPrec(DWORD dwPrec) {m_dwImportedSecRatingsPrec = dwPrec;}
    DWORD GetImportedSecRatingsPrec() {return m_dwImportedSecRatingsPrec;}

    void SetImportedAuthenticodePrec(DWORD dwPrec) {m_dwImportedAuthenticodePrec = dwPrec;}
    DWORD GetImportedAuthenticodePrec() {return m_dwImportedAuthenticodePrec;}

    void SetImportedSecZoneCount(DWORD dwCount) {m_dwImportedSecZones = dwCount;}
    DWORD GetImportedSecZoneCount() {return m_dwImportedSecZones;}

    void SetPlanningMode(BOOL fMode) { m_fPlanning = fMode;}
    BOOL IsPlanningMode() { return m_fPlanning;}

    // for authenticode certificates
    WMI_CERT_INFO *m_pwci[5];
    int m_iCurColumn;
    DWORD m_rgdwSortParam[5];

// implementation
public:
private:
    static int __cdecl ComparePSObjectsByPrecedence(const void *arg1, const void *arg2);

    void UninitCertInfo();


    CSnapIn *m_pCS;
    ComPtr<IWbemServices> m_pWbemServices;

    CPSObjData **m_paPSObj;
    long m_nPSObjects;

    CPSObjData **m_paCSObj;
    long m_nCSObjects;
    BOOL m_fPlanning;

    ComPtr<IWbemClassObject> m_pCRatObj; // store this for the multiple pages that use it

    DWORD m_dwImportedProgSettPrec;
    DWORD m_dwImportedConnSettPrec;
    DWORD m_dwImportedSecZonesPrec;
    DWORD m_dwImportedSecRatingsPrec;
    DWORD m_dwImportedAuthenticodePrec;

    DWORD m_dwImportedSecZones;
};

/////////////////////////////////////////////////////////////////////
// cached string functions
LPCTSTR GetDisabledString();
LPCTSTR GetEnabledString();

/////////////////////////////////////////////////////////////////////
// variant utilities
BOOL IsVariantNull(const VARIANT &v);
BOOL GetWMIPropBool(IWbemClassObject *pObj, BSTR bstrProp, BOOL fDefault, BOOL &fHandled);
DWORD GetWMIPropUL(IWbemClassObject *pObj, BSTR bstrProp, DWORD dwDefault, BOOL &fHandled);
void GetWMIPropPWSTR(IWbemClassObject *pObj, BSTR bstrProp, LPWSTR wszBuffer,
                      DWORD dwBufferLen, LPWSTR wszDefault, BOOL &fHandled);
void GetWMIPropPTSTR(IWbemClassObject *pObj, BSTR bstrProp, LPTSTR szBuffer,
                      DWORD dwBufferLen, LPTSTR szDefault, BOOL &fHandled);


/////////////////////////////////////////////////////////////////////
// IEAK RSoP-related functions
CDlgRSoPData *GetDlgRSoPData(HWND hDlg, CSnapIn *pCS);
void DestroyDlgRSoPData(HWND hDlg);

/////////////////////////////////////////////////////////////////////
// IEAK Policy Setting property retrieval functions
_bstr_t GetGPOSetting(ComPtr<IWbemClassObject> pPSObj, BSTR bstrSettingName);
DWORD GetGPOPrecedence(ComPtr<IWbemClassObject> pPSObj, BSTR bstrProp = NULL);

HRESULT InitGenericPrecedencePage(CDlgRSoPData *pDRD, HWND hwndList, BSTR bstrPropName);

/////////////////////////////////////////////////////////////////////
// Precedence page list control functions
void InsertPrecedenceListItem(HWND hwndList, long nItem, LPTSTR szName, LPTSTR szSetting);

// INetCpl-related functions
int CreateINetCplLookALikePage(HWND hwndParent, UINT nID, DLGPROC dlgProc,
								LPARAM lParam);

#endif //__IEAKSIE_RSOP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\rsopsec.h ===
#ifndef __RSOP_SECURITY_H__
#define __RSOP_SECURITY_H__

#include "rsop.h"
#include <tchar.h>

class CRegTreeOptions;

#define REGSTR_PATH_SECURITY_LOCKOUT  TEXT("Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define REGSTR_VAL_HKLM_ONLY          TEXT("Security_HKLM_only")

typedef struct tagSECURITYZONESETTINGS
{
    BOOL    dwFlags;            // from the ZONEATTRIBUTES struct
    DWORD   dwZoneIndex;        // as defined by ZoneManager
    DWORD   dwSecLevel;         // current level (High, Medium, Low, Custom)
    DWORD   dwPrevSecLevel;
    DWORD   dwMinSecLevel;      // current min level (High, Medium, Low, Custom)
    DWORD   dwRecSecLevel;      // current recommended level (High, Medium, Low, Custom)
    TCHAR   szDescription[MAX_ZONE_DESCRIPTION];
    TCHAR   szDisplayName[MAX_ZONE_PATH];
    HICON   hicon;
	WCHAR	wszObjPath[MAX_PATH];	// added for RSoP functionality
	long	nMappings;				// added for RSoP functionality
} SECURITYZONESETTINGS, *LPSECURITYZONESETTINGS;

// structure for main security page
typedef struct tagSECURITYPAGE
{
    HWND                    hDlg;                   // handle to window
    LPURLZONEMANAGER        pInternetZoneManager;   // pointer to InternetZoneManager
    IInternetSecurityManager *pInternetSecurityManager; // pointer to InternetSecurityManager
    HIMAGELIST              himl;                   // imagelist for Zones combobox
    HWND                    hwndZones;              // zones combo box hwnd
    LPSECURITYZONESETTINGS  pszs;                   // current settings for displayed zone
    INT                     iZoneSel;               // selected zone (as defined by ComboBox)
    DWORD                   dwZoneCount;            // number of zones
    BOOL                    fChanged;
    BOOL                    fPendingChange;         // to prevent the controls sending multiple sets (for cancel, mostly)
    HINSTANCE               hinstUrlmon;
    BOOL                    fNoEdit;                // hklm lockout of level edit
    BOOL                    fNoAddSites;            // hklm lockout of addsites
    BOOL                    fNoZoneMapEdit;         // hklm lockout of zone map edits
    HFONT                   hfontBolded;            // special bolded font created for the zone title
    BOOL                    fForceUI;               // Force every zone to show ui?
    BOOL                    fDisableAddSites;       // Automatically disable add sites button?
	CDlgRSoPData			*pDRD;					// added for RSoP functionality
} SECURITYPAGE, *LPSECURITYPAGE;

// structure for Intranet Add Sites
typedef struct tagADDSITESINTRANETINFO {
    HWND hDlg;                                      // handle to window
    BOOL fUseIntranet;                              // Use local defined intranet addresses (in reg)
    BOOL fUseProxyExclusion;                        // Use proxy exclusion list
    BOOL fUseUNC;                                   // Include UNC in intranet
    LPSECURITYPAGE pSec;            
} ADDSITESINTRANETINFO, *LPADDSITESINTRANETINFO;

// structure for Add Sites
typedef struct tagADDSITESINFO {
    HWND hDlg;                                      // handle to window
    BOOL fRequireServerVerification;                // Require Server Verification on sites in zone
    HWND hwndWebSites;                              // handle to list
    HWND hwndAdd;                                   // handle to edit
    TCHAR szWebSite[MAX_ZONE_PATH];                 // text in edit control
    BOOL fRSVOld;
    LPSECURITYPAGE pSec;            
} ADDSITESINFO, *LPADDSITESINFO;

// structure for Custom Settings 
typedef struct tagCUSTOMSETTINGSINFO {
    HWND  hDlg;                                     // handle to window
    HWND hwndTree;

    LPSECURITYPAGE pSec;
    HWND hwndCombo;
    INT iLevelSel;
	CRegTreeOptions *pTO;
    BOOL fUseHKLM;          // get/set settings from HKLM
    DWORD dwJavaPolicy;     // Java policy selected
    BOOL fChanged;
} CUSTOMSETTINGSINFO, *LPCUSTOMSETTINGSINFO;



#define NUM_TEMPLATE_LEVELS      4
extern TCHAR g_szLevel[3][64];
extern TCHAR LEVEL_DESCRIPTION0[];
extern TCHAR LEVEL_DESCRIPTION1[];
extern TCHAR LEVEL_DESCRIPTION2[];
extern TCHAR LEVEL_DESCRIPTION3[];
extern LPTSTR LEVEL_DESCRIPTION[];
extern TCHAR CUSTOM_DESCRIPTION[];

extern TCHAR LEVEL_NAME0[];
extern TCHAR LEVEL_NAME1[];
extern TCHAR LEVEL_NAME2[];
extern TCHAR LEVEL_NAME3[];
extern LPTSTR LEVEL_NAME[];
extern TCHAR CUSTOM_NAME[];

typedef DWORD REG_CMD;
typedef DWORD WALK_TREE_CMD;

struct ACTION_SETTING
{
	TCHAR szName[MAX_PATH];
	DWORD dwValue;
};

/////////////////////////////////////////////////////////////////////
class CRegTreeOptions
{
public:
    CRegTreeOptions();
    ~CRegTreeOptions();

    STDMETHODIMP InitTree( HWND hwndTree, HKEY hkeyRoot, LPCSTR pszRegKey, LPSECURITYPAGE pSec);
    STDMETHODIMP WalkTree( WALK_TREE_CMD cmd );
//    STDMETHODIMP ToggleItem( HTREEITEM hti );

protected:

    BOOL    RegEnumTree(HKEY hkeyRoot, LPCSTR pszRoot, HTREEITEM htviparent, HTREEITEM htvins);
    int     DefaultIconImage(HKEY hkey, int iImage);
    DWORD   GetCheckStatus(HKEY hkey, BOOL *pbChecked, BOOL bUseDefault);
    DWORD   RegGetSetSetting(HKEY hKey, DWORD *pType, LPBYTE pData, DWORD *pcbData, REG_CMD cmd);
    BOOL    WalkTreeRecursive(HTREEITEM htvi,WALK_TREE_CMD cmd);
//    DWORD   SaveCheckStatus(HKEY hkey, BOOL bChecked);
    BOOL    RegIsRestricted(HKEY hsubkey);
//    UINT        cRef;
    HWND        m_hwndTree;
//    LPTSTR      pszParam;
    HIMAGELIST  m_hIml;

	ACTION_SETTING m_as[50]; // as of Oct.2000, only 25, but give it room to grow
	long m_nASCount;
};

/////////////////////////////////////////////////////////////////////

// Pics Tree Dialog Stuff (content ratings) ------------------------------
struct PRSD{
    HINSTANCE			hInst;
//    PicsRatingSystemInfo *pPRSI;
	CDlgRSoPData		*pDRD;
    HWND				hwndBitmapCategory;
    HWND				hwndBitmapLabel;
    BOOL				fNewProviders;
};

#endif //__RSOP_SECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\secauth.cpp ===
#include "precomp.h"

#include "rsop.h"
#include <tchar.h>

/////////////////////////////////////////////////////////////////////
void InitSecAuthDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    __try
    {
        BOOL bImport = FALSE;
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();

            BOOL bImportHandled = FALSE;
            BOOL bEnableHandled = FALSE;
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                // importAuthenticodeSecurityInfo field
                _variant_t vtValue;
                if (!bImportHandled)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"importAuthenticodeSecurityInfo", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
//TODO: uncomment                        bImport = (bool)vtValue ? TRUE : FALSE;
                        CheckRadioButton(hDlg, IDC_NOAUTH, IDC_IMPORTAUTH,
                                        (bool)vtValue ? IDC_IMPORTAUTH : IDC_NOAUTH);

                        DWORD dwCurGPOPrec = GetGPOPrecedence(paPSObj[nObj]->pObj);
                        pDRD->SetImportedAuthenticodePrec(dwCurGPOPrec);
                        bImportHandled = TRUE;
                    }
                }

                // enableTrustedPublisherLockdown field
                vtValue;
                if (!bEnableHandled)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"enableTrustedPublisherLockdown", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        if ((bool)vtValue)
                            CheckDlgButton(hDlg, IDC_TPL, BST_CHECKED);
                        bEnableHandled = TRUE;
                    }
                }

                // no need to process other GPOs since enabled properties have been found
                if (bImportHandled && bEnableHandled)
                    break;
            }
        }

        EnableDlgItem2(hDlg, IDC_NOAUTH, FALSE);
        EnableDlgItem2(hDlg, IDC_IMPORTAUTH, FALSE);
        EnableDlgItem2(hDlg, IDC_MODIFYAUTH, bImport);

        EnableDlgItem2(hDlg, IDC_TPL, FALSE);
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
HRESULT InitSecAuthPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

                // importAuthenticodeSecurityInfo field
                BOOL bImport = FALSE;
                _variant_t vtValue;
                hr = paPSObj[nObj]->pObj->Get(L"importAuthenticodeSecurityInfo", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    bImport = (bool)vtValue ? TRUE : FALSE;

                _bstr_t bstrSetting;
                if (bImport)
                {
                    TCHAR szTemp[MAX_PATH];
                    LoadString(g_hInstance, IDS_IMPORT_AUTHSEC_SETTING, szTemp, countof(szTemp));
                    bstrSetting = szTemp;
                }
                else
                    bstrSetting = GetDisabledString();

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT InitAuthLockdownPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

                // enableTrustedPublisherLockdown field
                BOOL bImport = FALSE;
                _variant_t vtValue;
                hr = paPSObj[nObj]->pObj->Get(L"enableTrustedPublisherLockdown", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    bImport = (bool)vtValue ? TRUE : FALSE;

                _bstr_t bstrSetting;
                if (bImport)
                {
                    TCHAR szTemp[MAX_PATH];
                    LoadString(g_hInstance, IDS_ENABLE_PUB_LOCK_SETTING, szTemp, countof(szTemp));
                    bstrSetting = szTemp;
                }
                else
                    bstrSetting = GetDisabledString();

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK SecurityAuthDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    TCHAR szWorkDir[MAX_PATH],
          szInf[MAX_PATH];
    BOOL  fImport;

    switch (uMsg)
    {
    case WM_SETFONT:
        //a change to mmc requires us to do this logic for all our property pages that use common controls
        INITCOMMONCONTROLSEX iccx;
        iccx.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccx.dwICC = ICC_ANIMATE_CLASS  | ICC_BAR_CLASSES  | ICC_LISTVIEW_CLASSES  |ICC_TREEVIEW_CLASSES;
        InitCommonControlsEx(&iccx);
        break;

    case WM_INITDIALOG:
        SetPropSheetCookie(hDlg, lParam);

        // find out if this dlg is in RSoP mode
        psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        if (psCookie->pCS->IsRSoP())
        {
            CheckRadioButton(hDlg, IDC_NOAUTH, IDC_IMPORTAUTH, IDC_NOAUTH);

            CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
            if (pDRD)
                InitSecAuthDlgInRSoPMode(hDlg, pDRD);
        }
        break;

    case WM_DESTROY:
        if (psCookie->pCS->IsRSoP())
            DestroyDlgRSoPData(hDlg);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            // don't do any of this stuff in RSoP mode
            if (!psCookie->pCS->IsRSoP())
            {
                // authenticode
                fImport = InsGetBool(IS_SITECERTS, TEXT("ImportAuthCode"), FALSE, GetInsFile(hDlg));
                CheckRadioButton(hDlg, IDC_NOAUTH, IDC_IMPORTAUTH, fImport ? IDC_IMPORTAUTH : IDC_NOAUTH);
                EnableDlgItem2(hDlg, IDC_MODIFYAUTH, fImport);
                ReadBoolAndCheckButton(IS_SITECERTS, IK_TRUSTPUBLOCK, FALSE, GetInsFile(hDlg), hDlg, IDC_TPL);
            }
            break;

        case PSN_APPLY:
            if (psCookie->pCS->IsRSoP())
                return FALSE;
            else
            {
                if (!AcquireWriteCriticalSection(hDlg))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    break;
                }

                // process authenticode
                CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\AUTHCODE"), szWorkDir);
                PathCombine(szInf, szWorkDir, TEXT("authcode.inf"));

                ImportAuthCode(GetInsFile(hDlg), NULL, szInf, IsDlgButtonChecked(hDlg, IDC_IMPORTAUTH) == BST_CHECKED);

                if (PathIsDirectoryEmpty(szWorkDir))
                    PathRemovePath(szWorkDir);

                InsWriteBoolEx(IS_SITECERTS, IK_TRUSTPUBLOCK, (IsDlgButtonChecked(hDlg, IDC_TPL) == BST_CHECKED), GetInsFile(hDlg));

                SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
            }
            break;

        case PSN_HELP:
            ShowHelpTopic(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_NOAUTH:
            DisableDlgItem(hDlg, IDC_MODIFYAUTH);
            break;

        case IDC_IMPORTAUTH:
            EnableDlgItem(hDlg, IDC_MODIFYAUTH);
            break;

        case IDC_MODIFYAUTH:
            ModifyAuthCode(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        ShowHelpTopic(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\rsoprat.cpp ===
#include "precomp.h"

#include "rsopsec.h"

#include <regapix.h>		// MAXIMUM_SUB_KEY_LENGTH, MAXIMUM_VALUE_NAME_LENGTH, MAXIMUM_DATA_LENGTH

int g_nKeys, g_nLock; //         indexes of the images 
HIMAGELIST g_hImageList;
int g_iAllowAlways, g_iAllowNever;
enum TreeNodeEnum{tneGeneral, tneAccessList, tneRatingSystemRoot, tneRatingSystemInfo, tneRatingSystemNode, tneNone};

struct TreeNode{
    TreeNodeEnum  tne;
    void         *pData;

    TreeNode(){}
    TreeNode(TreeNodeEnum tneInit, void* pDataInit){tne=tneInit;pData=pDataInit;}
};


#define NUM_BITMAPS  2
#define CX_BITMAP	16
#define CY_BITMAP	16

///////////////////////////////////////////////////////////////////////////////
// InitTreeViewImageLists - creates an image list, adds three bitmaps to 
// it, and associates the image list with a tree-view control. 
// Returns TRUE if successful or FALSE otherwise. 
// hwndTV - handle of the tree-view control 
///////////////////////////////////////////////////////////////////////////////
BOOL InitTreeViewImageLists(HWND hwndTV) 
{
	BOOL bRet = FALSE;

	// Create the image list. 
	HIMAGELIST himl = ImageList_Create(CX_BITMAP, CY_BITMAP, FALSE, NUM_BITMAPS, 0);
	if (himl != NULL)
	{
		// Add the open file, closed file, and document bitmaps. 
		HBITMAP hbmp = (HBITMAP) LoadImage(g_hInstance, MAKEINTRESOURCE(IDB_KEYS),
											IMAGE_BITMAP, 0, 0,
											LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
		g_nKeys = ImageList_Add(himl, hbmp, (HBITMAP) NULL); 
		DeleteObject(hbmp); 

		hbmp = (HBITMAP)LoadImage(g_hInstance, MAKEINTRESOURCE(IDB_LOCK),
								 IMAGE_BITMAP, 0, 0,
								 LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
		g_nLock = ImageList_Add(himl, hbmp, (HBITMAP) NULL); 
		DeleteObject(hbmp); 

		// Fail if not all of the images were added. 
		if (ImageList_GetImageCount(himl) >= NUM_BITMAPS) 
		{
			// Associate the image list with the tree-view control. 
			HIMAGELIST oldHiml = TreeView_SetImageList(hwndTV, himl, TVSIL_NORMAL); 
			if(oldHiml != NULL)
				ImageList_Destroy(oldHiml);

			bRet = TRUE;
		}
	}
	return bRet;
} 

///////////////////////////////////////////////////////////////////////////////
void ShowHideWindow(HWND hCtrl, BOOL fEnable)
{
    EnableWindow(hCtrl, fEnable);
    ShowWindow(hCtrl, fEnable ? SW_SHOW : SW_HIDE);
}

///////////////////////////////////////////////////////////////////////////////
void DeleteBitmapWindow(HWND *phwnd)
{
    if (*phwnd)
	{
        DeleteObject( (HGDIOBJ) SendMessage(*phwnd, STM_GETIMAGE, IMAGE_BITMAP, 0));
        DestroyWindow(*phwnd);
        *phwnd = 0;
    }
}

///////////////////////////////////////////////////////////////////////////////
void ControlsShow(HWND hDlg, PRSD *pPRSD, TreeNodeEnum tne)
{
    BOOL fEnable;

    /*Bitmap placeholders never need to be seen*/
    ShowHideWindow(GetDlgItem(hDlg, IDC_PT_T_BITMAP_CATEGORY), FALSE);
    ShowHideWindow(GetDlgItem(hDlg, IDC_PT_T_BITMAP_LABEL),    FALSE);

    /*Kill old graphic windows*/
    DeleteBitmapWindow(&pPRSD->hwndBitmapCategory);
    DeleteBitmapWindow(&pPRSD->hwndBitmapLabel);

    /*RatingSystemNode Controls*/
    fEnable = (tne == tneRatingSystemNode);

    ShowHideWindow(GetDlgItem(hDlg, IDC_PT_T_RSN_SDESC), fEnable);
    ShowHideWindow(GetDlgItem(hDlg, IDC_PT_TB_SELECT),   fEnable);
    ShowHideWindow(GetDlgItem(hDlg, IDC_RATING_LABEL),   fEnable);

    /*RatingSystemInfo Controls*/
    fEnable = (tne==tneRatingSystemInfo || tne==tneRatingSystemNode);

    ShowHideWindow(GetDlgItem(hDlg, IDC_PT_T_RSN_LDESC), fEnable);
//    ShowHideWindow(GetDlgItem(hDlg, IDC_DETAILSBUTTON), fEnable);

	EnableDlgItem2(hDlg, IDC_DETAILSBUTTON, FALSE);
}

///////////////////////////////////////////////////////////////////////////////
HTREEITEM AddOneItem(HWND hwndTree, HTREEITEM hParent, LPTSTR szText,
					 HTREEITEM hInsAfter, LPARAM lpData, int iImage)
{
    HTREEITEM hItem;
    TV_ITEM tvI;
    TV_INSERTSTRUCT tvIns;

    // The .pszText is filled in.
    tvI.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvI.iSelectedImage = iImage;
    tvI.iImage = iImage;
    tvI.pszText = szText;
    tvI.cchTextMax = StrLen(szText);
    tvI.lParam = lpData;

    tvIns.item = tvI;
    tvIns.hInsertAfter = hInsAfter;
    tvIns.hParent = hParent;

    // Insert the item into the tree.
    hItem = (HTREEITEM)SendMessage(hwndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)&tvIns);

    return (hItem);
}

///////////////////////////////////////////////////////////////////////////////
TreeNode* TreeView_GetSelectionLParam(HWND hwndTree)
{
    TV_ITEM tv;

    tv.mask  = TVIF_HANDLE | TVIF_PARAM;
    tv.hItem = TreeView_GetSelection(hwndTree);
    if (SendMessage(hwndTree, TVM_GETITEM, 0, (LPARAM) &tv))
		return (TreeNode*) tv.lParam;
    else
		return 0;
}

///////////////////////////////////////////////////////////////////////////////
void PicsDlgInit(HWND hDlg, PRSD *pPRSD)
{
	__try
	{
		HWND hwndTree = GetDlgItem(hDlg, IDC_PT_TREE);
		InitTreeViewImageLists(hwndTree);

		// get the zone settings for this zone
		if (NULL != pPRSD->pDRD->ConnectToNamespace())
		{
			HRESULT hr = pPRSD->pDRD->LoadContentRatingsObject();
			ComPtr<IWbemClassObject> pRatObj = pPRSD->pDRD->GetContentRatingsObject();
			if (SUCCEEDED(hr) && NULL != pRatObj)
			{
				// ratingSystemFileNames field
				_variant_t vtValue;
				hr = pRatObj->Get(L"ratingSystemFileNames", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
				{
					SAFEARRAY *psa = vtValue.parray;

					LONG lLBound, lUBound, cElements = 0L;
					hr = SafeArrayGetLBound(psa, 1, &lLBound);
					if (SUCCEEDED(hr))
					{
						hr = SafeArrayGetUBound(psa, 1, &lUBound);
						if (SUCCEEDED(hr))
							cElements = lUBound - lLBound + 1;
					}

					TreeNode *pTN = NULL;

					BSTR HUGEP *pbstr = NULL;
					hr = SafeArrayAccessData(psa, (void HUGEP**)&pbstr);
					if (SUCCEEDED(hr))
					{
						for (long nSys = 0; nSys < cElements; nSys++)
						{
							LPCTSTR szSystem = (LPCTSTR)pbstr[nSys];

							pTN = new TreeNode(tneRatingSystemInfo, NULL);
							ASSERT(pTN);    
							AddOneItem(hwndTree, NULL, (LPTSTR)szSystem, TVI_SORT, (LPARAM)pTN, g_nLock);
						}
					}

					SafeArrayUnaccessData(psa);

					if (cElements > 0)
					{
						HTREEITEM hTreeItem = TreeView_GetNextItem(hwndTree,
																	TreeView_GetRoot(hwndTree),
																	TVGN_CHILD);
						if(NULL != hTreeItem)
						{
							TreeView_SelectItem(hwndTree, hTreeItem);       
							pTN = TreeView_GetSelectionLParam(GetDlgItem(hDlg, IDC_PT_TREE));
							ControlsShow(hDlg, pPRSD, pTN->tne);
						}
					}
				}
			}
		}
	}
	__except(TRUE)
	{
	}
}

///////////////////////////////////////////////////////////////////////////////
void KillTree(HWND hwnd, HTREEITEM hTree)
{
    while (hTree != NULL)
	{
        /* If this node has any items under it, delete them as well. */
        HTREEITEM hChild = TreeView_GetChild(hwnd, hTree);
        if (hChild != NULL)
            KillTree(hwnd, hChild);

        HTREEITEM hNext = TreeView_GetNextSibling(hwnd, hTree);

        TreeView_SelectItem(hwnd, hTree);
        delete TreeView_GetSelectionLParam(hwnd);
        TreeView_DeleteItem(hwnd, hTree);
        hTree = hNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
void PicsDlgUninit(HWND hDlg, PRSD *pPRSD)
{
    HWND hwnd = GetDlgItem(hDlg, IDC_PT_TREE);
    KillTree(hwnd, TreeView_GetRoot(hwnd));

    ControlsShow(hDlg, pPRSD, tneNone);
}

///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK PicsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
	PRSD *pPRSD = NULL;

	switch (uMsg) {
		case WM_INITDIALOG:
			SetWindowLongPtr(hDlg, DWLP_USER, lParam);
			pPRSD = (PRSD *) ((PROPSHEETPAGE*)lParam)->lParam;
			PicsDlgInit(hDlg, pPRSD);
			return TRUE;

		// Set the initial state
		case WM_SYSCOLORCHANGE:
		{
			InitTreeViewImageLists(GetDlgItem(hDlg, IDC_PT_TREE));

			//force the trackbar to redraw its background with the new color
			pPRSD = (PRSD*) ((PROPSHEETPAGE*)GetWindowLongPtr(hDlg, DWLP_USER))->lParam;

			TV_ITEM  tvm;
			ZeroMemory(&tvm,sizeof(tvm));

			tvm.hItem = TreeView_GetSelection(GetDlgItem(hDlg,IDC_PT_TREE));
			tvm.mask = TVIF_PARAM;

			TreeView_GetItem(GetDlgItem(hDlg,IDC_PT_TREE), &tvm);

			TreeNode *pTN = (TreeNode*)tvm.lParam;

			ControlsShow(hDlg, pPRSD, pTN->tne);
			break;
		}

		case WM_HSCROLL:
		case WM_VSCROLL:
			pPRSD = (PRSD *) ((PROPSHEETPAGE*)GetWindowLongPtr(hDlg, DWLP_USER))->lParam;
			switch (LOWORD(wParam)){
				case TB_THUMBTRACK:
				case TB_BOTTOM:
				case TB_ENDTRACK:
				case TB_LINEDOWN:
				case TB_LINEUP:
				case TB_PAGEDOWN:
				case TB_PAGEUP:
				case TB_THUMBPOSITION:
				case TB_TOP:
//					NewTrackbarPosition(hDlg, pPRSD);
					break;
			}
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
			case IDC_DETAILSBUTTON:
				break;
			}
			return TRUE;

		case WM_NOTIFY: {
			NMHDR *lpnm = (NMHDR *) lParam;
			switch (lpnm->code) {
				/*save us*/
				case PSN_SETACTIVE:
					break;
					
				case PSN_APPLY:
				case PSN_RESET:
					// Do this if hit OK or Cancel, not Apply
					pPRSD = (PRSD *) ((PROPSHEETPAGE*)GetWindowLongPtr(hDlg, DWLP_USER))->lParam;
					SendMessage(hDlg,WM_SETREDRAW, FALSE,0L);
					PicsDlgUninit(hDlg, pPRSD);
					SendMessage(hDlg,WM_SETREDRAW, TRUE,0L);
					return TRUE;
				   
				case TVN_ITEMEXPANDING:{
					NM_TREEVIEW *pNMT = (NM_TREEVIEW *) lParam;

					if (pNMT->action == TVE_COLLAPSE)
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
						return TRUE; //Suppress expanding tree.
					}
					break;
				}	 
					
				case TVN_SELCHANGED:
				{
					NM_TREEVIEW *pNMT = (NM_TREEVIEW *) lParam;
					TreeNode *pTN = ((TreeNode*) pNMT->itemNew.lParam);
					pPRSD = (PRSD*) ((PROPSHEETPAGE*)GetWindowLongPtr (hDlg, DWLP_USER))->lParam;

					ControlsShow(hDlg, pPRSD, pTN->tne);
					return TRUE;
				}
			}
		}
		break;

/*		case WM_HELP:
			  SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
					HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
			  break;

		case WM_CONTEXTMENU:
			  SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
					(DWORD_PTR)(LPVOID)aIds);
			  break;
*/	}
	return FALSE;
}

#define PICSRULES_ALWAYS            1
#define PICSRULES_NEVER             0

///////////////////////////////////////////////////////////////////////////////
void LoadSitesIntoList(HWND hwndList, ComPtr<IWbemClassObject> pRatObj,
					   BSTR bstrProp, BOOL fAcceptReject)
{
	__try
	{
		_variant_t vtValue;
		HRESULT hr = pRatObj->Get(bstrProp, 0, &vtValue, NULL, NULL);
		if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
		{
			SAFEARRAY *psa = vtValue.parray;

			LONG lLBound, lUBound, cElements = 0L;
			hr = SafeArrayGetLBound(psa, 1, &lLBound);
			if (SUCCEEDED(hr))
			{
				hr = SafeArrayGetUBound(psa, 1, &lUBound);
				if (SUCCEEDED(hr))
					cElements = lUBound - lLBound + 1;
			}

			BSTR HUGEP *pbstr = NULL;
			hr = SafeArrayAccessData(psa, (void HUGEP**)&pbstr);
			if (SUCCEEDED(hr))
			{
				//fill in the listview with known items
				for (long nSite = 0; nSite < cElements; nSite++)
				{
					LPCTSTR szSite = (LPCTSTR)pbstr[nSite];

					LV_ITEM lvItem;
					ZeroMemory(&lvItem, sizeof(lvItem));

					lvItem.mask = LVIF_TEXT|LVIF_IMAGE;
					lvItem.pszText = (LPTSTR)szSite;

					if (PICSRULES_NEVER == fAcceptReject)
						lvItem.iImage = g_iAllowNever;
					else
						lvItem.iImage = g_iAllowAlways;

					INT64 iIndex = SendMessage(hwndList, LVM_INSERTITEM, (WPARAM)0,
											(LPARAM)&lvItem);
					if (-1 == iIndex)
						break;
				}
			}

			SafeArrayUnaccessData(psa);
		}
	}
	__except(TRUE)
	{
	}
}

///////////////////////////////////////////////////////////////////////////////
void ApprovedSitesDlgInit(HWND hDlg, PRSD *pPRSD)
{
	__try
	{
		HWND hwndList = GetDlgItem(hDlg,IDC_PICSRULESAPPROVEDLIST);

		// get the zone settings for this zone
		if (NULL != pPRSD->pDRD->ConnectToNamespace())
		{
			HRESULT hr = pPRSD->pDRD->LoadContentRatingsObject();
			ComPtr<IWbemClassObject> pRatObj = pPRSD->pDRD->GetContentRatingsObject();
			if (SUCCEEDED(hr) && NULL != pRatObj)
			{
				// neverViewableSites field
				LoadSitesIntoList(hwndList, pRatObj, L"neverViewableSites",
									PICSRULES_NEVER);

				// alwaysViewableSites field
				LoadSitesIntoList(hwndList, pRatObj, L"alwaysViewableSites",
									PICSRULES_ALWAYS);
			}
		}

		// Set the column width to satisfy longest element
		ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);

		// set focus to first item in list
		ListView_SetItemState(hwndList, 0, LVIS_FOCUSED, LVIS_FOCUSED);

		EnableDlgItem2(hDlg, IDC_PICSRULESAPPROVEDEDIT, FALSE);
		EnableDlgItem2(hDlg, IDC_PICSRULESAPPROVEDALWAYS, FALSE);
		EnableDlgItem2(hDlg, IDC_PICSRULESAPPROVEDNEVER, FALSE);
		EnableDlgItem2(hDlg, IDC_PICSRULESAPPROVEDREMOVE, FALSE);
	}
	__except(TRUE)
	{
	}
}

///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK ApprovedSitesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	PRSD *pPRSD;
	
	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			SetWindowLongPtr (hDlg, DWLP_USER, lParam);
			pPRSD = (PRSD *) ((PROPSHEETPAGE*)lParam)->lParam;

			RECT Rect;
			GetWindowRect(GetDlgItem(hDlg,IDC_PICSRULESAPPROVEDLIST),&Rect);

			TEXTMETRIC tm;
			tm.tmAveCharWidth = 0;

			HDC hDC = GetDC(hDlg);
			if (hDC)
			{
				GetTextMetrics(hDC,&tm);
				ReleaseDC(hDlg,hDC);
			}

			LV_COLUMN lvColumn;
			lvColumn.mask = LVCF_FMT|LVCF_WIDTH;
			lvColumn.fmt = LVCFMT_LEFT;
			lvColumn.cx = Rect.right - Rect.left -GetSystemMetrics(SM_CXVSCROLL) -
							GetSystemMetrics(SM_CXSMICON) - tm.tmAveCharWidth;

			SendDlgItemMessage(hDlg, IDC_PICSRULESAPPROVEDLIST,
							   LVM_INSERTCOLUMN, (WPARAM)0, (LPARAM)&lvColumn);

			UINT flags = 0;
/*			if(IS_WINDOW_RTL_MIRRORED(hDlg))
				flags |= ILC_MIRROR;
*/
			g_hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
											GetSystemMetrics(SM_CYSMICON),
											flags, 2, 0);

			HICON hIcon = (HICON) LoadImage(g_hInstance,
											MAKEINTRESOURCE(IDI_ACCEPTALWAYS),
											IMAGE_ICON, 16, 16,
											LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);

			g_iAllowAlways=ImageList_AddIcon(g_hImageList,hIcon); 
			DeleteObject(hIcon); 
 
			hIcon = (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_ACCEPTNEVER),
										IMAGE_ICON, 16, 16,
										LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
			g_iAllowNever = ImageList_AddIcon(g_hImageList, hIcon); 
			DeleteObject(hIcon); 

			ListView_SetImageList(GetDlgItem(hDlg,IDC_PICSRULESAPPROVEDLIST),g_hImageList,LVSIL_SMALL); 

			//disable the remove button until someone selects something
			EnableWindow(GetDlgItem(hDlg,IDC_PICSRULESAPPROVEDREMOVE),FALSE);
			
			//disable the always and never buttons until someone types something
			EnableWindow(GetDlgItem(hDlg,IDC_PICSRULESAPPROVEDNEVER),FALSE);
			EnableWindow(GetDlgItem(hDlg,IDC_PICSRULESAPPROVEDALWAYS),FALSE);

			ApprovedSitesDlgInit(hDlg, pPRSD);
			break;
		}

		case WM_SYSCOLORCHANGE:
		{
			pPRSD=(PRSD *) ((PROPSHEETPAGE*)GetWindowLongPtr(hDlg,DWLP_USER))->lParam;

			HWND hwndList = GetDlgItem(hDlg,IDC_PICSRULESAPPROVEDLIST);
			ListView_SetBkColor(hwndList, GetSysColor(COLOR_WINDOW));

			UINT flags = 0;
/*			if(IS_WINDOW_RTL_MIRRORED(hDlg))
				flags |= ILC_MIRROR;
*/
			g_hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
											GetSystemMetrics(SM_CYSMICON),
											flags, 2, 0);

			HICON hIcon = (HICON) LoadImage(g_hInstance,
											MAKEINTRESOURCE(IDI_ACCEPTALWAYS),
											IMAGE_ICON, 16, 16,
											LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);

			g_iAllowAlways = ImageList_AddIcon(g_hImageList,hIcon); 
			DeleteObject(hIcon); 
 
			hIcon=(HICON) LoadImage(g_hInstance,
									MAKEINTRESOURCE(IDI_ACCEPTNEVER),
									IMAGE_ICON,
									16,
									16,
									LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
			g_iAllowNever = ImageList_AddIcon(g_hImageList,hIcon); 
			DeleteObject(hIcon); 

			HIMAGELIST hOldImageList = ListView_SetImageList(hwndList, g_hImageList, LVSIL_SMALL); 
			if(hOldImageList != NULL)
				ImageList_Destroy(hOldImageList);
			
			break;
		}
		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDC_PICSRULESAPPROVEDEDIT:
					break;
				case IDC_PICSRULESAPPROVEDNEVER:
					break;
				case IDC_PICSRULESAPPROVEDALWAYS:
					break;
				case IDC_PICSRULESAPPROVEDREMOVE:
					break;
			}

			return TRUE;

		case WM_NOTIFY: {
			NMHDR *lpnm = (NMHDR *) lParam;
			switch (lpnm->code) {
				case LVN_ITEMCHANGED:
					break;
				/*save us*/
				case PSN_APPLY:
					return TRUE;
				case PSN_RESET:
					return TRUE;
			}
		}
		break;

/*		case WM_HELP:
			SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
					HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
			break;

		case WM_CONTEXTMENU:
			SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
					(DWORD_PTR)(LPVOID)aIds);
			break;
*/	}

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
void GeneralDlgInit(HWND hDlg, PRSD *pPRSD)
{
	__try
	{
		// get the zone settings for this zone
		if (NULL != pPRSD->pDRD->ConnectToNamespace())
		{
			HRESULT hr = pPRSD->pDRD->LoadContentRatingsObject();
			ComPtr<IWbemClassObject> pRatObj = pPRSD->pDRD->GetContentRatingsObject();
			if (SUCCEEDED(hr) && NULL != pRatObj)
			{
				// viewUnknownRatedSites field
				_variant_t vtValue;
				hr = pRatObj->Get(L"viewUnknownRatedSites", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					CheckDlgButton(hDlg, IDC_UNRATED, (bool)vtValue ? BST_CHECKED : BST_UNCHECKED);

				// passwordOverrideEnabled field
				hr = pRatObj->Get(L"passwordOverrideEnabled", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
					CheckDlgButton(hDlg, IDC_PLEASE_MOMMY, (bool)vtValue ? BST_CHECKED : BST_UNCHECKED);
			}
		}

		EnableDlgItem2(hDlg, IDC_UNRATED, FALSE);
		EnableDlgItem2(hDlg, IDC_PLEASE_MOMMY, FALSE);
		EnableDlgItem2(hDlg, IDC_CHANGE_PASSWORD, FALSE);
		EnableDlgItem2(hDlg, IDC_FINDRATINGS, FALSE);
		EnableDlgItem2(hDlg, IDC_PROVIDER, FALSE);
	}
	__except(TRUE)
	{
	}
}

///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK GeneralDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	PRSD *pPRSD;
	
	switch (uMsg) {
		case WM_INITDIALOG:
			SetWindowLongPtr (hDlg, DWLP_USER, lParam);
			pPRSD = (PRSD *) ((PROPSHEETPAGE*)lParam)->lParam;

			GeneralDlgInit(hDlg, pPRSD);

			break;

		case WM_USER:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				/*edit controls/check boxes.  User updated these, highlight apply button*/
				case IDC_PROVIDER:
					break;
				case IDC_FINDRATINGS:
					break;
				case IDC_PLEASE_MOMMY:
				case IDC_UNRATED:
					break;

			   case IDC_CHANGE_PASSWORD:
					break;
			}

			return TRUE;

		case WM_NOTIFY: {
			NMHDR *lpnm = (NMHDR *) lParam;
			switch (lpnm->code) {
				/*save us*/
				case PSN_APPLY:
				case PSN_RESET:
					return TRUE;
			}
		}
		break;

/*		case WM_HELP:
			SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
					HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
			break;

		case WM_CONTEXTMENU:
			SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
					(DWORD_PTR)(LPVOID)aIds);
			break;
*/	}

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
void AdvancedDlgInit(HWND hDlg, PRSD *pPRSD)
{
	__try
	{
		// get the zone settings for this zone
		if (NULL != pPRSD->pDRD->ConnectToNamespace())
		{
			HRESULT hr = pPRSD->pDRD->LoadContentRatingsObject();
			ComPtr<IWbemClassObject> pRatObj = pPRSD->pDRD->GetContentRatingsObject();
			if (SUCCEEDED(hr) && NULL != pRatObj)
			{
				// selectedRatingsBureau field
				_variant_t vtValue;
				hr = pRatObj->Get(L"selectedRatingsBureau", 0, &vtValue, NULL, NULL);
				if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
				{
					_bstr_t bstrValue = vtValue;

					HWND hwndCombo = GetDlgItem(hDlg, IDC_3RD_COMBO);
					INT_PTR nIndex = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)bstrValue);
					SendMessage(hwndCombo, CB_SETCURSEL, nIndex, nIndex);
				}
			}
		}

		EnableDlgItem2(hDlg, IDC_3RD_COMBO, FALSE);
		EnableDlgItem2(hDlg, IDC_PICSRULESOPEN, FALSE);
		EnableDlgItem2(hDlg, IDC_PICSRULESEDIT, FALSE);
		EnableDlgItem2(hDlg, IDC_PICSRULES_UP, FALSE);
		EnableDlgItem2(hDlg, IDC_PICSRULES_DOWN, FALSE);
	}
	__except(TRUE)
	{
	}
}

///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	PRSD *pPRSD;
	
	switch (uMsg) {
		case WM_INITDIALOG:
		{
			SetWindowLongPtr (hDlg, DWLP_USER, lParam);
			pPRSD = (PRSD *) ((PROPSHEETPAGE*)lParam)->lParam;

			AdvancedDlgInit(hDlg, pPRSD);

			HICON hIcon = (HICON) LoadImage(g_hInstance,
											MAKEINTRESOURCE(IDI_PICSRULES_UP),
											IMAGE_ICON, 16, 16,
											LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
			
			SendDlgItemMessage(hDlg,IDC_PICSRULES_UP,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);

			hIcon = (HICON) LoadImage(g_hInstance,
										MAKEINTRESOURCE(IDI_PICSRULES_DOWN),
										IMAGE_ICON, 16, 16,
										LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
			
			SendDlgItemMessage(hDlg,IDC_PICSRULES_DOWN,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);

			break;
		}

		case WM_SYSCOLORCHANGE:
		{
			HICON hIcon = (HICON) LoadImage(g_hInstance,
										MAKEINTRESOURCE(IDI_PICSRULES_UP),
										IMAGE_ICON, 16, 16,
										LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
			
			HICON hOldIcon = (HICON) SendDlgItemMessage(hDlg,IDC_PICSRULES_UP,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);
			if (NULL != hOldIcon)
				DeleteObject(hOldIcon);
			
			hIcon = (HICON) LoadImage(g_hInstance,
										MAKEINTRESOURCE(IDI_PICSRULES_DOWN),
										IMAGE_ICON, 16, 16,
										LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
			
			hOldIcon = (HICON) SendDlgItemMessage(hDlg,IDC_PICSRULES_DOWN,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);

			if (NULL != hOldIcon)
				DeleteObject(hOldIcon);
			break;
		}
		case WM_USER:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				/*edit controls/check boxes.  User updated these, highlight apply button*/
				case IDC_3RD_COMBO:
					switch(HIWORD(wParam)) {
					case CBN_EDITCHANGE:
					case CBN_SELENDOK:
						break;
					}
					break;

				case IDC_PICSRULES_LIST:
				{
					switch(HIWORD(wParam))
					{
						case LBN_SELCHANGE:
							break;
					}

					break;
				}
				case IDC_PICSRULES_UP:
					break;
				case IDC_PICSRULES_DOWN:
					break;
				case IDC_PICSRULESEDIT:
					break;
				case IDC_PICSRULESOPEN:
					break;
			}

			return TRUE;

		case WM_NOTIFY: {
			NMHDR *lpnm = (NMHDR *) lParam;
			switch (lpnm->code) {
				/*save us*/
				case PSN_SETACTIVE:
					break;
				case PSN_APPLY:
				case PSN_RESET:
					return TRUE;
			}
		}
		break;

/*		case WM_HELP:
			SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
					HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
			break;

		case WM_CONTEXTMENU:
			SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
					(DWORD_PTR)(LPVOID)aIds);
			break;
*/	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\seczones.cpp ===
#include "precomp.h"

#include "rsopsec.h"

static INT_PTR CALLBACK importSecZonesRSoPProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK PrivacyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK SecurityCustomSettingsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK SecurityAddSitesIntranetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK SecurityAddSitesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

INT_PTR CALLBACK PicsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK ApprovedSitesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK GeneralDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#define WIDETEXT(x) L ## x


/////////////////////////////////////////////////////////////////////
void InitSecZonesDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    __try
    {
        BOOL bImportZones = FALSE;
        BOOL bImportRatings = FALSE;
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();

            BOOL bZonesHandled = FALSE;
            BOOL bRatingsHandled = FALSE;
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                // importSecurityZoneSettings field
                _variant_t vtValue;
                if (!bZonesHandled)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"importSecurityZoneSettings", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        bImportZones = (bool)vtValue ? TRUE : FALSE;
                        CheckRadioButton(hDlg, IDC_NOZONES, IDC_IMPORTZONES,
                                        (bool)vtValue ? IDC_IMPORTZONES : IDC_NOZONES);

                        bZonesHandled = TRUE;

                        DWORD dwCurGPOPrec = GetGPOPrecedence(paPSObj[nObj]->pObj);
                        pDRD->SetImportedSecZonesPrec(dwCurGPOPrec);

                        // importedZoneCount field
                        _variant_t vtValue;
                        hr = paPSObj[nObj]->pObj->Get(L"importedZoneCount", 0, &vtValue, NULL, NULL);
                        if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                        {
                            pDRD->SetImportedSecZoneCount((long)vtValue);
                        }

                        if(!pDRD->IsPlanningMode() && IsVariantNull(vtValue))
                        {
                            bZonesHandled = FALSE;
                        }
                    }
                }

                // importContentRatingsSettings field
                vtValue;
                if (!bRatingsHandled)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"importContentRatingsSettings", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        bImportRatings = (bool)vtValue ? TRUE : FALSE;
                        CheckRadioButton(hDlg, IDC_NORAT, IDC_IMPORTRAT,
                                        (bool)vtValue ? IDC_IMPORTRAT : IDC_NORAT);

                        DWORD dwCurGPOPrec = GetGPOPrecedence(paPSObj[nObj]->pObj);
                        pDRD->SetImportedSecRatingsPrec(dwCurGPOPrec);
                        bRatingsHandled = TRUE;
                    }
                }

                // no need to process other GPOs since enabled properties have been found
                if (bZonesHandled && bRatingsHandled)
                    break;
            }
        }

        EnableDlgItem2(hDlg, IDC_NOZONES, FALSE);
        EnableDlgItem2(hDlg, IDC_IMPORTZONES, FALSE);
        EnableDlgItem2(hDlg, IDC_MODIFYZONES, bImportZones);

        EnableDlgItem2(hDlg, IDC_NORAT, FALSE);
        EnableDlgItem2(hDlg, IDC_IMPORTRAT, FALSE);
        EnableDlgItem2(hDlg, IDC_MODIFYRAT, bImportRatings);
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
HRESULT InitSecZonesPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

                // importSecurityZoneSettings field
                BOOL bImport = FALSE;
                _variant_t vtValue;
                hr = paPSObj[nObj]->pObj->Get(L"importSecurityZoneSettings", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    bImport = (bool)vtValue ? TRUE : FALSE;

                _bstr_t bstrSetting;
                if (bImport)
                {
                    TCHAR szTemp[MAX_PATH];
                    LoadString(g_hInstance, IDS_IMPORTZONES_SETTING, szTemp, countof(szTemp));
                    bstrSetting = szTemp;
                }
                else
                    bstrSetting = GetDisabledString();

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT InitContentRatPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    HRESULT hr = NOERROR;
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                _bstr_t bstrGPOName = pDRD->GetGPONameFromPS(paPSObj[nObj]->pObj);

                // importContentRatingsSettings field
                BOOL bImport = FALSE;
                _variant_t vtValue;
                hr = paPSObj[nObj]->pObj->Get(L"importContentRatingsSettings", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    bImport = (bool)vtValue ? TRUE : FALSE;

                _bstr_t bstrSetting;
                if (bImport)
                {
                    TCHAR szTemp[MAX_PATH];
                    LoadString(g_hInstance, IDS_IMPORTRATINGS_SETTING, szTemp, countof(szTemp));
                    bstrSetting = szTemp;
                }
                else
                    bstrSetting = GetDisabledString();

                InsertPrecedenceListItem(hwndList, nObj, bstrGPOName, bstrSetting);
            }
        }
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
HPROPSHEETPAGE AddContentRatingPropPage(UINT nID, DLGPROC dlgProc, PRSD *pPRSD)
{
    HPROPSHEETPAGE hPage = NULL;
    __try
    {
        PROPSHEETPAGE page;

        page.dwSize = sizeof(PROPSHEETPAGE);
        page.dwFlags = 0;
        page.hInstance = g_hInstance;
        page.pszTemplate = MAKEINTRESOURCE(nID);
        page.pfnDlgProc = dlgProc;
        page.pfnCallback = NULL;
        page.lParam = (LPARAM)pPRSD;

        hPage = CreatePropertySheetPage(&page);
    }
    __except(TRUE)
    {
    }
    return hPage;
}

/////////////////////////////////////////////////////////////////////
int CreateContentRatingsUI(HWND hDlg, CDlgRSoPData *pDRD)
{
    int iRet = 0;
    __try
    {
        PRSD *pPRSD = new PRSD;
        if (NULL != pPRSD)
        {
            pPRSD->hInst = g_hInstance;
            pPRSD->pDRD = pDRD;
            pPRSD->hwndBitmapCategory = NULL;
            pPRSD->hwndBitmapLabel = NULL;
            pPRSD->fNewProviders = FALSE;

            HPROPSHEETPAGE apsPage[4];
            apsPage[0] = AddContentRatingPropPage(IDD_RATINGS, PicsDlgProc, pPRSD);
            apsPage[1] = AddContentRatingPropPage(IDD_APPROVEDSITES, ApprovedSitesDlgProc, pPRSD);
            apsPage[2] = AddContentRatingPropPage(IDD_GENERAL, GeneralDlgProc, pPRSD);
            apsPage[3] = AddContentRatingPropPage(IDD_ADVANCED, AdvancedDlgProc, pPRSD);

            PROPSHEETHEADER psHeader;
            memset(&psHeader,0,sizeof(psHeader));

            psHeader.dwSize = sizeof(psHeader);
            psHeader.dwFlags = PSH_PROPTITLE;
            psHeader.hwndParent = hDlg;
            psHeader.hInstance = g_hInstance;
            psHeader.nPages = 4;
            psHeader.nStartPage = 0;
            psHeader.phpage = apsPage;
            psHeader.pszCaption = MAKEINTRESOURCE(IDS_GENERIC);

            iRet = (int)PropertySheet(&psHeader);

            delete pPRSD;
        }
    }
    __except(TRUE)
    {
    }
    return iRet;
}

/////////////////////////////////////////////////////////////////////
int CreateINetCplSecurityLookALikePages(HWND hwndParent, LPARAM lParam)
{
    int iRet = 0;
    __try
    {
        PROPSHEETPAGE pageSec, pagePriv;

        // create the security property page
        pageSec.dwSize = sizeof(PROPSHEETPAGE);
        pageSec.dwFlags = 0;
        pageSec.hInstance = g_hInstance;
        pageSec.pszTemplate = MAKEINTRESOURCE(IDD_IMPORTEDSECZONES);
        pageSec.pfnDlgProc = importSecZonesRSoPProc;
        pageSec.pfnCallback = NULL;
        pageSec.lParam = lParam;

        HPROPSHEETPAGE ahpage[2];
        ahpage[0] = CreatePropertySheetPage(&pageSec);

        // setup privacy property page
        pagePriv.dwSize = sizeof(PROPSHEETPAGE);
        pagePriv.dwFlags = 0;
        pagePriv.hInstance = g_hInstance;
        pagePriv.pszTemplate = MAKEINTRESOURCE(IDD_PRIVACY);
        pagePriv.pfnDlgProc = PrivacyDlgProc;

        pagePriv.pfnCallback = NULL;
        pagePriv.lParam = lParam;

        ahpage[1] = CreatePropertySheetPage(&pagePriv);

        // add pages to the sheet
        PROPSHEETHEADER psHeader;
        memset(&psHeader,0,sizeof(psHeader));

        psHeader.dwSize = sizeof(psHeader);
        psHeader.dwFlags = PSH_PROPTITLE;
        psHeader.hwndParent = hwndParent;
        psHeader.hInstance = g_hInstance;
        psHeader.nPages = 2;
        psHeader.nStartPage = 0;
        psHeader.phpage = ahpage;
        psHeader.pszCaption = MAKEINTRESOURCE(IDS_INTERNET_LOC);

        iRet = (int)PropertySheet(&psHeader);
    }
    __except(TRUE)
    {
    }
    return iRet;
}

INT_PTR CALLBACK EnhancedSecurityWarningDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            TCHAR szBuffer[MAX_PATH * 3];
            UINT uID1, uID2, uID3, uID4;

            if(IEHardened())
            {
                uID1 = IDS_IESC_HARDENDESC1;
                uID2 = IDS_IESC_HARDENDESC2;
                uID3 = IDS_IESC_HARDENDESC3;
                uID4 = IDS_IESC_HARDENDESC4;
            }
            else
            {
                uID1 = IDS_IESC_SOFTENESC1;
                uID2 = IDS_IESC_SOFTENESC2;
                uID3 = IDS_IESC_SOFTENESC3;
                uID4 = IDS_IESC_SOFTENESC4;
            }

            LoadString(g_hInstance, uID1, szBuffer, ARRAYSIZE(szBuffer));
            SetDlgItemText(hDlg, IDC_STATIC1, szBuffer);
            LoadString(g_hInstance, uID2, szBuffer, ARRAYSIZE(szBuffer));
            SetDlgItemText(hDlg, IDC_STATIC2, szBuffer);
            LoadString(g_hInstance, uID3, szBuffer, ARRAYSIZE(szBuffer));
            SetDlgItemText(hDlg, IDC_STATIC3, szBuffer);
            LoadString(g_hInstance, uID4, szBuffer, ARRAYSIZE(szBuffer));
            SetDlgItemText(hDlg, IDC_STATIC4, szBuffer);
            break;
        }

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;
        case IDOK:
            EndDialog(hDlg, IDOK);
            break;
        }

        break;
    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR ShowIEHardenWarning(HWND hParent)
{
    return DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_IEESCDLG),
                        hParent, EnhancedSecurityWarningDlgProc, NULL);
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK SecurityZonesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    TCHAR szWorkDir[MAX_PATH],
          szInf[MAX_PATH];
    BOOL  fImport;

    switch (uMsg)
    {
    case WM_SETFONT:
        //a change to mmc requires us to do this logic for all our property pages that use common controls
        INITCOMMONCONTROLSEX iccx;
        iccx.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccx.dwICC = ICC_ANIMATE_CLASS  | ICC_BAR_CLASSES  | ICC_LISTVIEW_CLASSES  |ICC_TREEVIEW_CLASSES;
        InitCommonControlsEx(&iccx);
        break;

    case WM_INITDIALOG:
        SetPropSheetCookie(hDlg, lParam);

        // find out if this dlg is in RSoP mode
        psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        if (psCookie->pCS->IsRSoP())
        {
            CheckRadioButton(hDlg, IDC_NOZONES, IDC_IMPORTZONES, IDC_NOZONES);
            CheckRadioButton(hDlg, IDC_NORAT, IDC_IMPORTRAT, IDC_NORAT);

            TCHAR szViewSettings[128];
            LoadString(g_hInstance, IDS_VIEW_SETTINGS, szViewSettings, countof(szViewSettings));
            SetDlgItemText(hDlg, IDC_MODIFYZONES, szViewSettings);
            SetDlgItemText(hDlg, IDC_MODIFYRAT, szViewSettings);

            CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
            if (pDRD)
            {
               pDRD->SetPlanningMode(psCookie->pCS->GetCompData()->IsPlanningMode());
               InitSecZonesDlgInRSoPMode(hDlg, pDRD);
            }
        }
        break;

    case WM_DESTROY:
        if (psCookie->pCS->IsRSoP())
            DestroyDlgRSoPData(hDlg);
        break;

    case WM_TIMER:
        {
            KillTimer(hDlg, 1);
            if(IDCANCEL == ShowIEHardenWarning(hDlg))
            {
                CheckRadioButton(hDlg, IDC_NOZONES, IDC_IMPORTZONES, IDC_NOZONES);
                SetFocus(GetDlgItem(hDlg, IDC_NOZONES));
            }

            break;
        }

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            // don't do any of this stuff in RSoP mode
            if (!psCookie->pCS->IsRSoP())
            {
                // zones
                fImport = InsGetBool(SECURITY_IMPORTS, TEXT("ImportSecZones"), FALSE, GetInsFile(hDlg));
                if(fImport)
                {
                    SetTimer(hDlg, 1, 300, NULL);
                }
                CheckRadioButton(hDlg, IDC_NOZONES, IDC_IMPORTZONES, fImport ? IDC_IMPORTZONES : IDC_NOZONES);
                EnableDlgItem2(hDlg, IDC_MODIFYZONES, fImport);

                // ratings
                fImport = InsGetBool(SECURITY_IMPORTS, TEXT("ImportRatings"), FALSE, GetInsFile(hDlg));
                CheckRadioButton(hDlg, IDC_NORAT, IDC_IMPORTRAT, fImport ? IDC_IMPORTRAT : IDC_NORAT);
                EnableDlgItem2(hDlg, IDC_MODIFYRAT, fImport);
            }
            break;

        case PSN_APPLY:
            if (psCookie->pCS->IsRSoP())
                return FALSE;
            else
            {
                if (!AcquireWriteCriticalSection(hDlg))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    break;
                }

                // process zones
                CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\ZONES"), szWorkDir);
                PathCombine(szInf, szWorkDir, TEXT("seczones.inf"));

                ImportZones(GetInsFile(hDlg), NULL, szInf, IsDlgButtonChecked(hDlg, IDC_IMPORTZONES) == BST_CHECKED);

                if (PathIsDirectoryEmpty(szWorkDir))
                    PathRemovePath(szWorkDir);

                // process ratings
                CreateWorkDir(GetInsFile(hDlg), IEAK_GPE_BRANDING_SUBDIR TEXT("\\RATINGS"), szWorkDir);
                PathCombine(szInf, szWorkDir, TEXT("ratings.inf"));

                ImportRatings(GetInsFile(hDlg), NULL, szInf, IsDlgButtonChecked(hDlg, IDC_IMPORTRAT) == BST_CHECKED);

                if (PathIsDirectoryEmpty(szWorkDir))
                    PathRemovePath(szWorkDir);

                SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
            }
            break;

        case PSN_HELP:
            ShowHelpTopic(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_NOZONES:
            DisableDlgItem(hDlg, IDC_MODIFYZONES);
            break;

        case IDC_IMPORTZONES:
            {
                INT_PTR uRet = ShowIEHardenWarning(hDlg);
                if(uRet == IDCANCEL)
                {
                    CheckRadioButton(hDlg, IDC_NOZONES, IDC_IMPORTZONES, IDC_NOZONES);
                    SetFocus(GetDlgItem(hDlg, IDC_NOZONES));
                    break;
                }

                EnableDlgItem(hDlg, IDC_MODIFYZONES);
            }
            break;

        case IDC_MODIFYZONES:
            if (psCookie->pCS->IsRSoP())
            {
                CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
                if (NULL != pDRD)
                    CreateINetCplSecurityLookALikePages(hDlg, (LPARAM)pDRD);
            }
            else
                ModifyZones(hDlg);
            break;

        case IDC_NORAT:
            DisableDlgItem(hDlg, IDC_MODIFYRAT);
            break;

        case IDC_IMPORTRAT:
            EnableDlgItem(hDlg, IDC_MODIFYRAT);
            break;

        case IDC_MODIFYRAT:
            if (psCookie->pCS->IsRSoP())
            {
                CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
                if (NULL != pDRD)
                    CreateContentRatingsUI(hDlg, pDRD);
            }
            else
                ModifyRatings(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        ShowHelpTopic(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//*******************************************************************
// CODE FROM INETCPL
//*******************************************************************

TCHAR g_szLevel[3][64];
TCHAR LEVEL_DESCRIPTION0[300];
TCHAR LEVEL_DESCRIPTION1[300];
TCHAR LEVEL_DESCRIPTION2[300];
TCHAR LEVEL_DESCRIPTION3[300];
LPTSTR LEVEL_DESCRIPTION[NUM_TEMPLATE_LEVELS] = {
    LEVEL_DESCRIPTION0,
    LEVEL_DESCRIPTION1,
    LEVEL_DESCRIPTION2,
    LEVEL_DESCRIPTION3
};
TCHAR CUSTOM_DESCRIPTION[300];

TCHAR LEVEL_NAME0[30];
TCHAR LEVEL_NAME1[30];
TCHAR LEVEL_NAME2[30];
TCHAR LEVEL_NAME3[30];
LPTSTR LEVEL_NAME[NUM_TEMPLATE_LEVELS] = {
    LEVEL_NAME0,
    LEVEL_NAME1,
    LEVEL_NAME2,
    LEVEL_NAME3
};
TCHAR CUSTOM_NAME[30];

/////////////////////////////////////////////////////////////////////
// Initialize the global variables (to be destroyed at WM_DESTROY)
// pSec, Urlmon, pSec->pInternetZoneManager, pSec->hIml
// and set up the proper relationships among them
/////////////////////////////////////////////////////////////////////
BOOL SecurityInitGlobals(LPSECURITYPAGE *ppSec, HWND hDlg, CDlgRSoPData *pDRD,
                         DWORD dwZoneCount)
{
    BOOL bRet = TRUE;
    __try
    {
        DWORD cxIcon;
        DWORD cyIcon;

        LPSECURITYPAGE pSec = (LPSECURITYPAGE)LocalAlloc(LPTR, sizeof(SECURITYPAGE));
        *ppSec = pSec;
        if (!pSec)
            bRet = FALSE;   // no memory?

        if (bRet)
        {
            pSec->dwZoneCount = dwZoneCount;
            pSec->pDRD = pDRD; // for rsop functionality

            pSec->hinstUrlmon = NULL; // don't need any of its functions

            // get our zones hwnd
            pSec->hwndZones = GetDlgItem(hDlg, IDC_LIST_ZONE);
            if(! pSec->hwndZones)
            {
                ASSERT(FALSE);
                bRet = FALSE;  // no list box?
            }
        }

        if (bRet)
        {
            // tell dialog where to get info
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pSec);

            // save the handle to the page
            pSec->hDlg = hDlg;
            pSec->fPendingChange = FALSE;

            // create an imagelist for the ListBox            
            cxIcon = GetSystemMetrics(SM_CXICON);
            cyIcon = GetSystemMetrics(SM_CYICON);
        #ifndef UNIX
            UINT flags = ILC_COLOR32|ILC_MASK;

            // TODO: commented out for RSOP; should it be uncommented?
//            if(IS_WINDOW_RTL_MIRRORED(hDlg))
//                flags |= ILC_MIRROR;
            pSec->himl = ImageList_Create(cxIcon, cyIcon, flags, pSec->dwZoneCount, 0);
        #else
            pSec->himl = ImageList_Create(cxIcon, cyIcon, ILC_COLOR|ILC_MASK, pSec->dwZoneCount, 0);
        #endif
            if(! pSec->himl)
                bRet = FALSE;  // Image list not created
        }

        if (bRet)
            SendMessage(pSec->hwndZones, LVM_SETIMAGELIST, (WPARAM)LVSIL_NORMAL, (LPARAM)pSec->himl);
    }
    __except(TRUE)
    {
    }
    return bRet;
}

/////////////////////////////////////////////////////////////////////
int ZoneIndexToGuiIndex(DWORD dwZoneIndex)
// Product testing asked for the zones in a specific order in the list box;
// This function returns the desired gui position for a given zone
// Unrecognized zones are added to the front
{
    int iGuiIndex = -1;
    switch(dwZoneIndex)
    {
        // Intranet: 2nd spot
        case 1:
            iGuiIndex = 1;
            break;

        // Internet: 1st spot
        case 3:
            iGuiIndex = 0;
            break;

        // Trusted Sites: 3rd Spot
        case 2:
            iGuiIndex = 2;
            break;

        // Restricted Sites: 4th Spot
        case 4:
            iGuiIndex = 3;
            break;

        // unknown zone
        default:
            iGuiIndex = -1;   
            break;
    }


    return iGuiIndex;
}

/////////////////////////////////////////////////////////////////////
// Fill a zone with information from WMI and add it to the
// ordered list going to the listbox
// Return values:
//  S_OK indicates success
//  S_FALSE indicates a good state, but the zone was not added (example: flag ZAFLAGS_NO_UI)
//  E_OUTOFMEMORY
//  E_FAIL - other failure
/////////////////////////////////////////////////////////////////////
HRESULT SecurityInitZone(DWORD dwIndex, DWORD dwZoneCount, BSTR bstrObjPath,
                         ComPtr<IWbemClassObject> pSZObj, LPSECURITYPAGE pSec,
                         LV_ITEM *plviZones, BOOL *pfSpotTaken)
{
    HRESULT hr = S_OK;
    __try
    {
        // create a structure for zone settings
        LPSECURITYZONESETTINGS pszs = (LPSECURITYZONESETTINGS)LocalAlloc(LPTR, sizeof(*pszs));
        if (pszs)
        {
            // store settings for later use
            StrCpyW(pszs->wszObjPath, bstrObjPath);

            // flags field
            _variant_t vtValue;
            hr = pSZObj->Get(L"flags", 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                 pszs->dwFlags = (long)vtValue;

            // zoneIndex field
            hr = pSZObj->Get(L"zoneIndex", 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                 pszs->dwZoneIndex = (long)vtValue;

            // currentTemplateLevel field
            hr = pSZObj->Get(L"currentTemplateLevel", 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                 pszs->dwSecLevel = (long)vtValue;

            // minimumTemplateLevel field
            hr = pSZObj->Get(L"minimumTemplateLevel", 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                 pszs->dwMinSecLevel = (long)vtValue;

            // recommendedTemplateLevel field
            hr = pSZObj->Get(L"recommendedTemplateLevel", 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                 pszs->dwRecSecLevel = (long)vtValue;

            // displayName field
            _bstr_t bstrValue;
            hr = pSZObj->Get(L"displayName", 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
            {
                bstrValue = vtValue;
                StrCpyN(pszs->szDisplayName, (LPCTSTR)bstrValue, ARRAYSIZE(pszs->szDisplayName));
            }

            // description field
            hr = pSZObj->Get(L"description", 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
            {
                bstrValue = vtValue;
                StrCpyN(pszs->szDescription, (LPCTSTR)bstrValue, ARRAYSIZE(pszs->szDescription));
            }

            // iconPath field
            HICON hiconSmall = NULL;
            HICON hiconLarge = NULL;
            hr = pSZObj->Get(L"iconPath", 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
            {
                bstrValue = vtValue;

                TCHAR szIconPath[MAX_PATH];

                // load the icon                
                LPWSTR psz = (LPWSTR)bstrValue;
                if (*psz)
                {
                    // search for the '#'
                    while ((psz[0] != WIDETEXT('#')) && (psz[0] != WIDETEXT('\0')))
                        psz++;
    
                    // if we found it, then we have the foo.dll#00001200 format
                    WORD iIcon = 0;
                    if (psz[0] == WIDETEXT('#'))
                    {
                        psz[0] = WIDETEXT('\0');
                        StrCpyN(szIconPath, (LPCTSTR)bstrValue, ARRAYSIZE(szIconPath));
                        iIcon = (WORD)StrToIntW(psz+1);
                        CHAR szPath[MAX_PATH];
                        SHUnicodeToAnsi(szIconPath, szPath, ARRAYSIZE(szPath));
                        ExtractIconExA(szPath,(UINT)(-1*iIcon), &hiconLarge, &hiconSmall, 1);
                    }
                    else
                    {
                        hiconLarge = (HICON)ExtractAssociatedIcon(g_hInstance, szIconPath, (LPWORD)&iIcon);
                    }
                }

                // no icons?!  well, just use the generic icon
                if (!hiconSmall && !hiconLarge)
                {
                    hiconLarge = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ZONE));
                    if(!hiconLarge)
                    {
                        LocalFree((HLOCAL)pszs);
                        hr = S_FALSE;  // no icon found for this zone, not even the generic one
                    }
                }

                if (S_OK == hr)
                {
                    // we want to save the Large icon if possible for use in the subdialogs
                    pszs->hicon = hiconLarge ? hiconLarge : hiconSmall;
                }
            }

            // zoneMappings field
            hr = pSZObj->Get(L"zoneMappings", 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
            {
                SAFEARRAY *psa = vtValue.parray;

                LONG lLBound, lUBound;
                hr = SafeArrayGetLBound(psa, 1, &lLBound);
                if (SUCCEEDED(hr))
                {
                    hr = SafeArrayGetUBound(psa, 1, &lUBound);
                    if (SUCCEEDED(hr))
                        pszs->nMappings = lUBound - lLBound + 1;
                }
            }

            hr = S_OK;

            // Find the proper index for the zone in the listbox (there is a user-preferred order)
            int iSpot = ZoneIndexToGuiIndex(dwIndex);
            if(iSpot == -1)
            {
                // if not a recognized zone, add it to the end of the list
                iSpot = dwZoneCount - 1;
            }
            // Make sure there are no collisisons
            while(iSpot >= 0 && pfSpotTaken[iSpot] == TRUE)
            {
                iSpot--;
            }
            // Don't go past beginning of array
            if(iSpot < 0)
            {
                // It can be proven that it is impossible to get here, unless there is
                // something wrong with the function ZoneIndexToGuiIndex
                ASSERT(FALSE);
                LocalFree((HLOCAL)pszs);
                if(hiconSmall)
                    DestroyIcon(hiconSmall);
                if(hiconLarge)
                    DestroyIcon(hiconLarge);
                hr = E_FAIL;
            }

            LV_ITEM *plvItem = NULL;
            if (S_OK == hr)
            {
                plvItem = &(plviZones[iSpot]);
                pfSpotTaken[iSpot] = TRUE;


                // init the List Box item and save it for later addition
                plvItem->mask            = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                plvItem->iItem            = iSpot;
                plvItem->iSubItem        = 0;
                // large icons prefered for the icon view (if switch back to report view, prefer small icons)
                plvItem->iImage         = ImageList_AddIcon(pSec->himl, hiconLarge ? hiconLarge : hiconSmall);

                plvItem->pszText        = new TCHAR[MAX_PATH];
                if(!plvItem->pszText)
                {
                    LocalFree((HLOCAL)pszs);
                    if(hiconSmall)
                        DestroyIcon(hiconSmall);   
                    if(hiconLarge)
                        DestroyIcon(hiconLarge);
                    hr = E_OUTOFMEMORY;
                }
            }

            if (S_OK == hr)
            {
                StrCpy(plvItem->pszText, pszs->szDisplayName);
                plvItem->lParam         = (LPARAM)pszs;       // save the zone settings here

                // if we created a small icon, destroy it, since the system does not save the handle
                // when it is added to the imagelist (see ImageList_AddIcon in VC help)
                // Keep it around if we had to use it in place of the large icon
                if (hiconSmall && hiconLarge)
                    DestroyIcon(hiconSmall);   
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }
    __except(TRUE)
    {
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
// To make the slider control accessbile we have to subclass it and over-ride 
// the accessiblity object 
/////////////////////////////////////////////////////////////////////
void SecurityInitSlider(LPSECURITYPAGE pSec)
{
    // Initialize the slider control (set number of levels, and frequency one tick per level)
    SendDlgItemMessage(pSec->hDlg, IDC_SLIDER, TBM_SETRANGE, (WPARAM) (BOOL) FALSE, (LPARAM) MAKELONG(0, NUM_TEMPLATE_LEVELS - 1));
    SendDlgItemMessage(pSec->hDlg, IDC_SLIDER, TBM_SETTICFREQ, (WPARAM) 1, (LPARAM) 0);
}
                    
/////////////////////////////////////////////////////////////////////
void SecurityInitControls(LPSECURITYPAGE pSec)
{
    // select the 0 position zone
    LV_ITEM lvItem;
    lvItem.mask = LVIF_STATE;
    lvItem.stateMask = LVIS_SELECTED;
    lvItem.state = LVIS_SELECTED;
    SendMessage(pSec->hwndZones, LVM_SETITEMSTATE, 0, (LPARAM)&lvItem);

    // get the zone settings for the selected item
    lvItem.mask  = LVIF_PARAM;
    lvItem.iItem = pSec->iZoneSel;
    lvItem.iSubItem = 0;
    SendMessage(pSec->hwndZones, LVM_GETITEM, (WPARAM)0, (LPARAM)&lvItem);
    pSec->pszs = (LPSECURITYZONESETTINGS)lvItem.lParam;

    // Initialize the local strings to carry the Level Descriptions
    LoadString(g_hInstance, IDS_TEMPLATE_DESC_HI, LEVEL_DESCRIPTION0, ARRAYSIZE(LEVEL_DESCRIPTION0));
    LoadString(g_hInstance, IDS_TEMPLATE_DESC_MED, LEVEL_DESCRIPTION1, ARRAYSIZE(LEVEL_DESCRIPTION1));
    LoadString(g_hInstance, IDS_TEMPLATE_DESC_MEDLOW, LEVEL_DESCRIPTION2, ARRAYSIZE(LEVEL_DESCRIPTION2));
    LoadString(g_hInstance, IDS_TEMPLATE_DESC_LOW, LEVEL_DESCRIPTION3, ARRAYSIZE(LEVEL_DESCRIPTION3));
    LoadString(g_hInstance, IDS_TEMPLATE_DESC_CUSTOM, CUSTOM_DESCRIPTION, ARRAYSIZE(CUSTOM_DESCRIPTION));

    LoadString(g_hInstance, IDS_TEMPLATE_NAME_HI, LEVEL_NAME0, ARRAYSIZE(LEVEL_NAME0));
    LoadString(g_hInstance, IDS_TEMPLATE_NAME_MED, LEVEL_NAME1, ARRAYSIZE(LEVEL_NAME1));
    LoadString(g_hInstance, IDS_TEMPLATE_NAME_MEDLOW, LEVEL_NAME2, ARRAYSIZE(LEVEL_NAME2));
    LoadString(g_hInstance, IDS_TEMPLATE_NAME_LOW, LEVEL_NAME3, ARRAYSIZE(LEVEL_NAME3));
    LoadString(g_hInstance, IDS_TEMPLATE_NAME_CUSTOM, CUSTOM_NAME, ARRAYSIZE(CUSTOM_NAME));

    // Initialize text boxes and icons for the current zone
    SetDlgItemText(pSec->hDlg, IDC_ZONE_DESCRIPTION, pSec->pszs->szDescription);
    SetDlgItemText(pSec->hDlg, IDC_ZONELABEL, pSec->pszs->szDisplayName);
    SendDlgItemMessage(pSec->hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pSec->pszs->hicon);

    // Initialize the slider control
    SecurityInitSlider(pSec);

    // Initialize the list view (add column 0 for icon and text, and autosize it)
    LV_COLUMN lvCasey;
    lvCasey.mask = 0;
    SendDlgItemMessage(pSec->hDlg, IDC_LIST_ZONE, LVM_INSERTCOLUMN, (WPARAM) 0, (LPARAM) &lvCasey);
    SendDlgItemMessage(pSec->hDlg, IDC_LIST_ZONE, LVM_SETCOLUMNWIDTH, (WPARAM) 0, (LPARAM) MAKELPARAM(LVSCW_AUTOSIZE, 0));

    // Set the font of the name to the bold font
    pSec->hfontBolded = NULL;
    HFONT hfontOrig = (HFONT) SendDlgItemMessage(pSec->hDlg, IDC_STATIC_EMPTY, WM_GETFONT, (WPARAM) 0, (LPARAM) 0);
    if(hfontOrig == NULL)
        hfontOrig = (HFONT) GetStockObject(SYSTEM_FONT);

    // set the zone name and level font to bolded
    if(hfontOrig)
    {
        LOGFONT lfData;
        if(GetObject(hfontOrig, sizeof(lfData), &lfData) != 0)
        {
            // The distance from 400 (normal) to 700 (bold)
            lfData.lfWeight += 300;
            if(lfData.lfWeight > 1000)
                lfData.lfWeight = 1000;
            pSec->hfontBolded = CreateFontIndirect(&lfData);
            if(pSec->hfontBolded)
            {
                // the zone level and zone name text boxes should have the same font, so this is okat
                SendDlgItemMessage(pSec->hDlg, IDC_ZONELABEL, WM_SETFONT, (WPARAM) pSec->hfontBolded, (LPARAM) MAKELPARAM(FALSE, 0));
                SendDlgItemMessage(pSec->hDlg, IDC_LEVEL_NAME, WM_SETFONT, (WPARAM) pSec->hfontBolded, (LPARAM) MAKELPARAM(FALSE, 0));

            }
        }
    }
}

/////////////////////////////////////////////////////////////////////
// Converting the Security Level DWORD identitifiers to slider levels, and vice versa
/////////////////////////////////////////////////////////////////////
int SecLevelToSliderPos(DWORD dwLevel)
{
    switch(dwLevel)
    {
        case URLTEMPLATE_LOW:
            return 3;
        case URLTEMPLATE_MEDLOW:
            return 2;
        case URLTEMPLATE_MEDIUM:
            return 1;
        case URLTEMPLATE_HIGH:
            return 0;        
        case URLTEMPLATE_CUSTOM:
            return -1;            
        default:
            return -2;
    }
}

/////////////////////////////////////////////////////////////////////
// Duties:
// Make the controls (slider, en/disabled buttons) match the data for the current zone
// Make the views (Level description text) match the data for the current zone
// Set focus (to slider, if enabled, else custom settings button, if enabled, else 
//     listbox) if fSetFocus is TRUE
// Note: the zone descriptions are not set here; those are handled by the code responsible
//       for changing zones
/////////////////////////////////////////////////////////////////////
BOOL SecurityEnableControls(LPSECURITYPAGE pSec, BOOL fSetFocus)
{
    int iLevel = -1;

    if (pSec && pSec->pszs)
    {
        HWND hwndSlider = GetDlgItem(pSec->hDlg, IDC_SLIDER);
        
        iLevel = SecLevelToSliderPos(pSec->pszs->dwSecLevel);
        ASSERT(iLevel > -2);

        // Set the level of the slider to the setting for the current zone
        // Show or hide the slider for preset levels/custom
        // Set the level description text
        if(iLevel >= 0)
        {
            SendMessage(hwndSlider, TBM_SETPOS, (WPARAM) (BOOL) TRUE, (LPARAM) (LONG) iLevel);
            // Make sure the slider is visible
            ShowWindow(hwndSlider, SW_SHOW);
            ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_SLIDERMOVETEXT), SW_SHOW);
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_DESCRIPTION, LEVEL_DESCRIPTION[iLevel]);
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_NAME, LEVEL_NAME[iLevel]);
        }
        else
        {
            // Hide the slider for custom
            ShowWindow(hwndSlider, SW_HIDE);
            ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_SLIDERMOVETEXT), SW_HIDE);
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_DESCRIPTION, CUSTOM_DESCRIPTION);
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_NAME, CUSTOM_NAME);
        }

        // If the zone is empty, show the "zone is empty" string
        // Default is to not show the sting (if something goes wrong)
        // Empty zone not possible for internet, intranet, or local zones
        if((pSec->pszs->dwZoneIndex != URLZONE_INTRANET && 
            pSec->pszs->dwZoneIndex != URLZONE_INTERNET) &&
            pSec->pszs->dwZoneIndex != URLZONE_LOCAL_MACHINE)
        {
            // If there aren't any zone mappings, zone is empty (not valid for internet and intranet)
            if (pSec->pszs->nMappings > 0)
                ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_EMPTY), SW_HIDE);
            else
                ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_EMPTY), SW_SHOW);
        }
        else
            ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_EMPTY), SW_HIDE);

        // If we were told to set focus then move focus to the slider.
        if (fSetFocus)
        {
            if(!pSec->fNoEdit)
            {
               if(iLevel >= 0)
                    SetFocus(hwndSlider);
               else if(pSec->pszs->dwFlags & ZAFLAGS_CUSTOM_EDIT)
                    SetFocus(GetDlgItem(pSec->hDlg, IDC_BUTTON_SETTINGS));
               else
                 SetFocus(GetDlgItem(pSec->hDlg, IDC_LIST_ZONE));
            }
            else // No focus is allowed, set focus to the list box
                SetFocus(GetDlgItem(pSec->hDlg, IDC_LIST_ZONE));
        }

        EnableWindow(GetDlgItem(pSec->hDlg, IDC_BUTTON_SETTINGS), 
                     (pSec->pszs->dwFlags & ZAFLAGS_CUSTOM_EDIT) && !pSec->fNoEdit);
        EnableWindow(GetDlgItem(pSec->hDlg, IDC_BUTTON_ADD_SITES), 
                     (pSec->pszs->dwFlags & ZAFLAGS_ADD_SITES) && !pSec->fDisableAddSites);

        EnableDlgItem2(pSec->hDlg, IDC_SLIDER, FALSE);
        EnableDlgItem2(pSec->hDlg, IDC_ZONE_RESET, FALSE);

        return TRUE;
    }

    return FALSE;
}

BOOL IsESCEnabled(CDlgRSoPData *pDRD, DWORD dwPrecedence)
{
    WCHAR wszObjPath[128];

    wnsprintf(wszObjPath, countof(wszObjPath),
                L"RSOP_IEESC.rsopID=\"IEAK\",rsopPrecedence=%ld", dwPrecedence);

    _bstr_t bstrObjPath = wszObjPath;

    ComPtr<IWbemServices> pWbemServices = pDRD->GetWbemServices();
    ComPtr<IWbemClassObject> pSZObj = NULL;
    _variant_t vtValue;
    HRESULT hr = pWbemServices->GetObject(bstrObjPath, 0L, NULL, (IWbemClassObject**)&pSZObj, NULL);
    if(SUCCEEDED(hr))
    {                    
        hr = pSZObj->Get(L"EscEnabled", 0, &vtValue, NULL, NULL);
        if (SUCCEEDED(hr) && !IsVariantNull(vtValue) && (bool)vtValue)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////
BOOL InitImportedSecZonesDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    BOOL bRet = TRUE;
    __try
    {
        // Initialize globals variables (to be destroyed at WM_DESTROY)
        LPSECURITYPAGE pSec = NULL;
        UINT iIndex = 0;
        DWORD dwZoneCount = pDRD->GetImportedSecZoneCount();
        if(SecurityInitGlobals(&pSec, hDlg, pDRD, dwZoneCount) == FALSE)
        {
            EndDialog(hDlg, 0);
            bRet = FALSE;  // Initialization failed
        }

        if (bRet)
        {
            BOOL fUseHKLM = TRUE;

            // get the zone settings for this zone
            if (NULL != pDRD->ConnectToNamespace())
            {
                // get our stored precedence value
                DWORD dwCurGPOPrec = pDRD->GetImportedSecZonesPrec();

                
                if(!pDRD->IsPlanningMode())
                {
                    if(IsESCEnabled(pDRD, dwCurGPOPrec))
                    {
                        TCHAR szBuffer[MAX_PATH * 2], szTitle[MAX_PATH];
                        LoadString(g_hInstance, IDS_IESCINFO, szBuffer, ARRAYSIZE(szBuffer));
                        LoadString(g_hInstance, IDS_IEESCTITLE, szTitle, ARRAYSIZE(szTitle));
                        MessageBox(hDlg, szBuffer, szTitle, MB_OK);
                    }
                }

                //
                // Add the Listbox items for the zones
                //

                // The zones have to be added in a particular order
                // Array used to order zones for adding
                LV_ITEM *plviZones = new LV_ITEM[dwZoneCount];
                BOOL *pfSpotTaken = new BOOL[dwZoneCount];
                for(iIndex =0; pfSpotTaken && iIndex < dwZoneCount; iIndex++)
                    pfSpotTaken[iIndex] = FALSE;

               // propogate zone dropdown                
 	            WCHAR wszObjPath[128];
                for (DWORD dwIndex=0; dwIndex < dwZoneCount; dwIndex++)
                {
                    // create the object path of this security zone for this GPO
                    wnsprintf(wszObjPath, countof(wszObjPath),
                                L"RSOP_IESecurityZoneSettings.rsopID=\"IEAK\",rsopPrecedence=%ld,useHKLM=%s,zoneIndex=%lu",
                                dwCurGPOPrec, fUseHKLM ? TEXT("TRUE") : TEXT("FALSE"), dwIndex);
                    _bstr_t bstrObjPath = wszObjPath;

                    // get the RSOP_IEProgramSettings object and its properties
                    ComPtr<IWbemServices> pWbemServices = pDRD->GetWbemServices();
                    ComPtr<IWbemClassObject> pSZObj = NULL;
                    HRESULT hr = pWbemServices->GetObject(bstrObjPath, 0L, NULL, (IWbemClassObject**)&pSZObj, NULL);
                    if (SUCCEEDED(hr))
                    {

                        if(FAILED(SecurityInitZone(dwIndex, dwZoneCount, bstrObjPath,
                                                    pSZObj, pSec, plviZones, pfSpotTaken)))
                        {
                            // Delete all memory allocated for any previous zones (which have not yet been added to
                            // the listbox)
                            for(iIndex = 0; iIndex < dwZoneCount; iIndex++)
                            {
                                if(pfSpotTaken && pfSpotTaken[iIndex] && plviZones && (LPSECURITYZONESETTINGS) (plviZones[iIndex].lParam) != NULL)
                                {
                                    LocalFree((LPSECURITYZONESETTINGS) (plviZones[iIndex].lParam));
                                    plviZones[iIndex].lParam = NULL;
                                    if(plviZones[iIndex].pszText)
                                        delete [] plviZones[iIndex].pszText;
                                }
                            }
                            delete [] plviZones;
                            delete [] pfSpotTaken;
                            EndDialog(hDlg, 0);
                            return FALSE;
                        }
                    }
                    else // no more zones read from WMI
                        break;
                }

                // Add all of the arrayed list items to the listbox
                for(iIndex = 0; iIndex < dwZoneCount; iIndex++)
                {
                    if(pfSpotTaken[iIndex])
                    {
                        SendMessage(pSec->hwndZones, LVM_INSERTITEM, (WPARAM)0, (LPARAM)&(plviZones[iIndex]));
                        delete [] plviZones[iIndex].pszText;
                    }
                }
                delete [] plviZones;
                delete [] pfSpotTaken;
            }

            SecurityInitControls(pSec);
            SecurityEnableControls(pSec, FALSE);
        }
    }
    __except(TRUE)
    {
    }
    return bRet;
}

/////////////////////////////////////////////////////////////////////
// SecurityOnCommand()
//
// Handles Security Dialog's window messages
//
/////////////////////////////////////////////////////////////////////
void SecurityOnCommand(LPSECURITYPAGE pSec, UINT id, UINT nCmd)
{
    UNREFERENCED_PARAMETER(nCmd);
    switch (id)
    {
        case IDC_BUTTON_ADD_SITES:
        {
            if (pSec->pszs->dwZoneIndex == URLZONE_INTRANET)
                DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SECURITY_INTRANET), pSec->hDlg,
                               SecurityAddSitesIntranetDlgProc, (LPARAM)pSec);
            else
                DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SECURITY_ADD_SITES), pSec->hDlg,
                               SecurityAddSitesDlgProc, (LPARAM)pSec);
                               
            // Resynch controls (in case the "zone is empty" message needs to be updated)
            SecurityEnableControls(pSec, FALSE);
        }   
        break;

        case IDC_BUTTON_SETTINGS:
        {
            // Note: messages to change the level from preset to custom as a result of this call
            //       are sent by the CustomSettings dialog
            DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SECURITY_CUSTOM_SETTINGS), pSec->hDlg,
                           SecurityCustomSettingsDlgProc, (LPARAM)pSec);
            break;
        }
        case IDC_ZONE_RESET:
            break;
            
        case IDOK:
            EndDialog(pSec->hDlg, IDOK);
            break;
            
        case IDCANCEL:
            EndDialog(pSec->hDlg, IDCANCEL);
            break;
            
        case IDC_SLIDER:
            break;
            
        case IDC_LIST_ZONE:
        {
            // Sundown: coercion to int-- selection is range-restricted
            int iNewSelection = (int) SendMessage(pSec->hwndZones, LVM_GETNEXTITEM, (WPARAM)-1, 
                                                  MAKELPARAM(LVNI_SELECTED, 0));

            if ((iNewSelection != pSec->iZoneSel) && (iNewSelection != -1))
            {
                LV_ITEM lvItem;

                lvItem.iItem = iNewSelection;
                lvItem.iSubItem = 0;
                lvItem.mask  = LVIF_PARAM;                                            
                SendMessage(pSec->hwndZones, LVM_GETITEM, (WPARAM)0, (LPARAM)&lvItem);
                pSec->pszs = (LPSECURITYZONESETTINGS)lvItem.lParam;
                pSec->iZoneSel = iNewSelection;

                SetDlgItemText(pSec->hDlg, IDC_ZONE_DESCRIPTION, pSec->pszs->szDescription);
                SetDlgItemText(pSec->hDlg, IDC_ZONELABEL, pSec->pszs->szDisplayName);
                SendDlgItemMessage(pSec->hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pSec->pszs->hicon);
                SecurityEnableControls(pSec, FALSE);
            }    
            break;
        }
    }   

} // SecurityOnCommand()


/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK importSecZonesRSoPProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        CDlgRSoPData *pDRD = (CDlgRSoPData*)((LPPROPSHEETPAGE)lParam)->lParam;
        BOOL fResult = InitImportedSecZonesDlgInRSoPMode(hDlg, pDRD);

        return fResult;
    }

    LPSECURITYPAGE pSec = (LPSECURITYPAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    if (!pSec)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_COMMAND:
            SecurityOnCommand(pSec, LOWORD(wParam), HIWORD(wParam));
            return TRUE;

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            ASSERT(lpnm);

            // List Box Messages
            if(lpnm->idFrom == IDC_LIST_ZONE)
            {
                NM_LISTVIEW * lplvnm = (NM_LISTVIEW *) lParam;
                if(lplvnm->hdr.code == LVN_ITEMCHANGED)
                {
                    // If an item's state has changed, and it is now selected
                    if(((lplvnm->uChanged & LVIF_STATE) != 0) && ((lplvnm->uNewState & LVIS_SELECTED) != 0))
                    {
                        SecurityOnCommand(pSec, IDC_LIST_ZONE, LVN_ITEMCHANGED);
                    }                   
                }
            }
            else
            {
                switch (lpnm->code)
                {
                    case PSN_QUERYCANCEL:
                    case PSN_KILLACTIVE:
                    case PSN_RESET:
                        //TODO: What do we do with this?
//                        SetWindowLongPtr(pSec->hDlg, DWLP_MSGRESULT, FALSE);
                        return TRUE;

                    case PSN_APPLY:
                        break;
                }
            }
        }
        break;

        case WM_HELP:           // F1
//            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
//                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_VSCROLL:
            // Slider Messages
            SecurityOnCommand(pSec, IDC_SLIDER, LOWORD(wParam));
            return TRUE;

        case WM_CONTEXTMENU:        // right mouse click
//            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
//                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            if(! pSec)
                break;

            if(pSec->hwndZones)
            {
                for (int iIndex = (int)SendMessage(pSec->hwndZones, LVM_GETITEMCOUNT, 0, 0) - 1;
                     iIndex >= 0; iIndex--)
                {
                    LV_ITEM lvItem;

                    // get security zone settings object for this item and release it
                    lvItem.mask = LVIF_PARAM;
                    lvItem.iItem = iIndex;
                    lvItem.iSubItem = 0;
                    if (SendMessage(pSec->hwndZones, LVM_GETITEM, (WPARAM)0, (LPARAM)&lvItem) == TRUE)
                    {
                        LPSECURITYZONESETTINGS pszs = (LPSECURITYZONESETTINGS)lvItem.lParam;
                        if (pszs)
                        {
                            if (pszs->hicon)
                                DestroyIcon(pszs->hicon);
                            LocalFree((HLOCAL)pszs);
                            pszs = NULL;
                        }
                    }                 
                }   
            }

            if(pSec->himl)
                ImageList_Destroy(pSec->himl);

            if(pSec->hfontBolded)
                DeleteObject(pSec->hfontBolded);

            LocalFree(pSec);
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            break;
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////
void InitZoneMappingsInUI(HWND hwndList, CDlgRSoPData *pDRD,
                          LPSECURITYZONESETTINGS pszs)
{
    __try
    {
        // get the RSOP_IEProgramSettings object and its properties
        ComPtr<IWbemServices> pWbemServices = pDRD->GetWbemServices();
        _bstr_t bstrObjPath = pszs->wszObjPath;
        ComPtr<IWbemClassObject> pSZObj = NULL;
        HRESULT hr = pWbemServices->GetObject(bstrObjPath, 0L, NULL, (IWbemClassObject**)&pSZObj, NULL);
        if (SUCCEEDED(hr))
        {
            // zoneMappings field
            _variant_t vtValue;
            hr = pSZObj->Get(L"zoneMappings", 0, &vtValue, NULL, NULL);
            if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
            {
                SAFEARRAY *psa = vtValue.parray;

                BSTR HUGEP *pbstr = NULL;
                hr = SafeArrayAccessData(psa, (void HUGEP**)&pbstr);
                if (SUCCEEDED(hr))
                {
                    for (long nMapping = 0; nMapping < pszs->nMappings; nMapping++)
                    {
                        LPCTSTR szMapping = (LPCTSTR)pbstr[nMapping];
                        SendMessage(hwndList, LB_INSERTSTRING, (WPARAM)-1, (LPARAM)szMapping);
                    }
                }

                SafeArrayUnaccessData(psa);
            }
        }
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK SecurityAddSitesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPADDSITESINFO pasi;

    if (uMsg == WM_INITDIALOG)
    {
        pasi = (LPADDSITESINFO)LocalAlloc(LPTR, sizeof(*pasi));
        if (!pasi)
        {
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
        }

        // tell dialog where to get info
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pasi);

        // save the handle to the page
        pasi->hDlg         = hDlg;
        pasi->pSec         = (LPSECURITYPAGE)lParam;
        pasi->hwndWebSites = GetDlgItem(hDlg, IDC_LIST_WEBSITES);
        pasi->hwndAdd      = GetDlgItem(hDlg, IDC_EDIT_ADD_SITE);

        pasi->fRequireServerVerification = pasi->pSec->pszs->dwFlags & ZAFLAGS_REQUIRE_VERIFICATION;
        CheckDlgButton(hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION, pasi->fRequireServerVerification);
        
        SendMessage(hDlg, WM_SETTEXT, (WPARAM)0, (LPARAM)pasi->pSec->pszs->szDisplayName);
        SendDlgItemMessage(hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pasi->pSec->pszs->hicon);

        InitZoneMappingsInUI(pasi->hwndWebSites, pasi->pSec->pDRD, pasi->pSec->pszs);

        EnableDlgItem2(hDlg, IDC_EDIT_ADD_SITE, FALSE);
        EnableDlgItem2(hDlg, IDC_BUTTON_ADD, FALSE);
        EnableDlgItem2(hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION, FALSE);
        EnableDlgItem2(hDlg, IDC_BUTTON_REMOVE, FALSE);
    }
    
    else
        pasi = (LPADDSITESINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pasi)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    EndDialog(hDlg, IDOK);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;
                
                case IDC_LIST_WEBSITES:
                    switch (HIWORD(wParam))
                    {
                        case LBN_SELCHANGE:
                        case LBN_SELCANCEL:
                            break;
                    }
                    break;
                            
                case IDC_EDIT_ADD_SITE:
                    switch(HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            break;
                    }   
                    break;

                case IDC_BUTTON_ADD:
                    break;

                case IDC_BUTTON_REMOVE:
                    break;
                default:
                    return FALSE;

            }
            return TRUE;
            break;

        case WM_HELP:           // F1
//            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
//                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
//            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
//                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            if (pasi)
            {
                LocalFree(pasi);
                SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            }
            break;
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK SecurityAddSitesIntranetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPADDSITESINTRANETINFO pasii;

    if (uMsg == WM_INITDIALOG)
    {
        pasii = (LPADDSITESINTRANETINFO)LocalAlloc(LPTR, sizeof(*pasii));
        if (!pasii)
        {
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
        }

        // tell dialog where to get info
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pasii);

        // save the handle to the page
        pasii->hDlg = hDlg;
        pasii->pSec = (LPSECURITYPAGE)lParam;

        SendMessage(hDlg, WM_SETTEXT, (WPARAM)0, (LPARAM)pasii->pSec->pszs->szDisplayName);
        CheckDlgButton(hDlg, IDC_CHECK_USEINTRANET, pasii->pSec->pszs->dwFlags & ZAFLAGS_INCLUDE_INTRANET_SITES);
        CheckDlgButton(hDlg, IDC_CHECK_PROXY, pasii->pSec->pszs->dwFlags & ZAFLAGS_INCLUDE_PROXY_OVERRIDE);
        CheckDlgButton(hDlg, IDC_CHECK_UNC, pasii->pSec->pszs->dwFlags & ZAFLAGS_UNC_AS_INTRANET);
        SendDlgItemMessage(hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pasii->pSec->pszs->hicon);

        EnableDlgItem2(hDlg, IDC_CHECK_USEINTRANET, FALSE);
        EnableDlgItem2(hDlg, IDC_CHECK_PROXY, FALSE);
        EnableDlgItem2(hDlg, IDC_CHECK_UNC, FALSE);
        return TRUE;
    }

    else
         pasii = (LPADDSITESINTRANETINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pasii)
        return FALSE;
    
    switch (uMsg) {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    EndDialog(hDlg, IDOK);
                    break;
                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_INTRANET_ADVANCED:
                    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SECURITY_ADD_SITES), hDlg,
                                   SecurityAddSitesDlgProc, (LPARAM)pasii->pSec);
                    break;

                default:
                    return FALSE;
            }
            return TRUE;                

        case WM_HELP:           // F1
//            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
//                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
//            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
//                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            if (pasii)
            {
                LocalFree(pasii);
                SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            }
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\snapin.cpp ===
#include "precomp.h"

#include "resource.h"

#include "rsop.h"

// context.cpp

extern INT_PTR CALLBACK RSoPDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
extern void ExportSettings();

unsigned int CSnapIn::m_cfNodeType = RegisterClipboardFormat(CCF_NODETYPE);

GUID g_guidSnapinExt = CLSID_IEAKSnapinExt;
GUID g_guidRSoPSnapinExt = CLSID_IEAKRSoPSnapinExt;
GUID g_guidClientExt = CLSID_IEAKClientExt;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CSnapIn::CSnapIn(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pImageResult = NULL;
    m_pConsoleVerb = NULL;
    m_pDisplayHelp = NULL;
    m_nColumnSize1 = 180;
    m_nColumnSize2 = 270;
    m_lViewMode = LVS_REPORT;
    m_lpCookieList = NULL;
    *(m_pcd->m_szInsFile) = TEXT('\0');

    LoadString(g_hInstance, IDS_HDR_NAME, m_szColumn1, ARRAYSIZE(m_szColumn1));
    LoadString(g_hInstance, IDS_HDR_DESC, m_szColumn2, ARRAYSIZE(m_szColumn2));
}

CSnapIn::~CSnapIn()
{
    DeleteCookieList(m_lpCookieList);
    InterlockedDecrement(&g_cRefThisDll);
}

HRESULT CSnapIn::AddMenuItems(LPDATAOBJECT piDataObject,
                              LPCONTEXTMENUCALLBACK piCallback,
                              long __RPC_FAR *pInsertionAllowed)
{
    UNREFERENCED_PARAMETER(piDataObject);
    UNREFERENCED_PARAMETER(piCallback);
    UNREFERENCED_PARAMETER(pInsertionAllowed);

    return S_FALSE;
}

HRESULT CSnapIn::SignalPolicyChanged(BOOL bMachine, BOOL bAdd, GUID *pGuidExtension,
                                     GUID *pGuidSnapin)
{
    return m_pcd->m_pGPTInformation->PolicyChanged(bMachine, bAdd, pGuidExtension, pGuidSnapin);
}

LPCTSTR CSnapIn::GetInsFile()
{
    return m_pcd->GetInsFile();
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CSnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CSnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CSnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IComponent)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
        reinterpret_cast<void**>(&m_pHeader));
    
    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);
    
    m_pConsole->QueryInterface(IID_IResultData,
        reinterpret_cast<void**>(&m_pResult));
    
    m_pConsole->QueryResultImageList(&m_pImageResult);
    
    m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    
    m_pConsole->QueryInterface(IID_IDisplayHelp,
        reinterpret_cast<void**>(&m_pDisplayHelp));

    return S_OK;
}

STDMETHODIMP CSnapIn::Destroy(MMC_COOKIE cookie)
{
    UNREFERENCED_PARAMETER(cookie);

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }
    if (m_pImageResult != NULL)
    {
        m_pImageResult->Release();
        m_pImageResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    UNREFERENCED_PARAMETER(param);

    switch(event)
    {
    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;

        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_IEAKSNAPINEXT_16));
        hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_IEAKSNAPINEXT_32));

        // Set the images
        m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(hbmp16x16),
                                          reinterpret_cast<LONG_PTR *>(hbmp32x32),
                                          0, RGB(255, 0, 255));

        DeleteObject(hbmp16x16);
        DeleteObject(hbmp32x32);
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPIEAKDATAOBJECT pIEAKDataObject;
            MMC_COOKIE cookie;
            DWORD dwIndex;
            INT i;

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IIEAKDataObject, (LPVOID *)&pIEAKDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pIEAKDataObject->GetCookie(&cookie);

            pIEAKDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;
            
            dwIndex = PtrToUlong(((LPIEAKMMCCOOKIE)cookie)->lpItem);

            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_szColumn1, LVCFMT_LEFT, m_nColumnSize1);
            m_pHeader->InsertColumn(1, m_szColumn2, LVCFMT_LEFT, m_nColumnSize2);
            m_pResult->SetViewMode(m_lViewMode);

            //
            //  Set the ins file so we can check for dupe GPO pages
            //

            m_pcd->SetInsFile();

            // check to see if we need to enumerate ADM files if this is the adm
            // node

            if (dwIndex == ADM_NAMESPACE_ITEM)
            {
                EnterCriticalSection(&g_LayoutCriticalSection);

                if (g_NameSpace[dwIndex].pResultItems == NULL)
                {
                    GetAdmFileList(&(g_NameSpace[dwIndex].pResultItems), 
                        &(g_NameSpace[dwIndex].cResultItems), ROLE_CORP);
                    for (i = 0; i < g_NameSpace[dwIndex].cResultItems; i++)
                    {
                        g_NameSpace[dwIndex].pResultItems[i].dwNameSpaceItem = ADM_NAMESPACE_ITEM;
                        g_NameSpace[dwIndex].pResultItems[i].iDlgID = IDD_ADM;
                        g_NameSpace[dwIndex].pResultItems[i].iImage = 6;
                        g_NameSpace[dwIndex].pResultItems[i].iNamePrefID = -1;
                        g_NameSpace[dwIndex].pResultItems[i].pszNamePref = NULL;
                        g_NameSpace[dwIndex].pResultItems[i].pfnDlgProc = AdmDlgProc;
                        g_NameSpace[dwIndex].pResultItems[i].pcszHelpTopic = HELP_FILENAME TEXT("::/ieakmmc.htm");
                    }
                }

                LeaveCriticalSection(&g_LayoutCriticalSection);
            }
            

            //
            // Add result pane items for this node
            //

            for (i = 0; i < g_NameSpace[dwIndex].cResultItems; i++)
            {
                LPIEAKMMCCOOKIE lpCookie = (LPIEAKMMCCOOKIE)CoTaskMemAlloc(sizeof(IEAKMMCCOOKIE));

                lpCookie->lpItem =  &g_NameSpace[dwIndex].pResultItems[i];
                lpCookie->lpParentItem = this;
                lpCookie->pNext = NULL;
                AddItemToCookieList(&m_lpCookieList, lpCookie);

                resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                resultItem.str = MMC_CALLBACK;
                resultItem.nImage = g_NameSpace[dwIndex].pResultItems[i].iImage;
                resultItem.lParam = (LPARAM)lpCookie;
                m_pResult->InsertItem(&resultItem);
            }
        }
        else
        {
            m_pHeader->GetColumnWidth(0, &m_nColumnSize1);
            m_pHeader->GetColumnWidth(0, &m_nColumnSize2);
            m_pResult->GetViewMode(&m_lViewMode);
        }
        break;


    case MMCN_SELECT:

        if (m_pConsoleVerb != NULL)
        {
            LPIEAKDATAOBJECT pIEAKDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE cookie;
            DWORD dwIndex;

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IIEAKDataObject, (LPVOID *)&pIEAKDataObject);

            if (FAILED(hr))
                break;

            pIEAKDataObject->GetType(&type);
            pIEAKDataObject->GetCookie(&cookie);

            pIEAKDataObject->Release();
            
            dwIndex = PtrToUlong(((LPIEAKMMCCOOKIE)cookie)->lpItem);

            //
            // If this is a result pane item, enable the Properties menu item
            //

            if (type == CCT_RESULT)
            {
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);


                //
                // If this is a result pane item, then change the default
                // verb to Properties.
                //

                if (type == CCT_RESULT)
                    m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            }

        }
        break;

    case MMCN_CONTEXTHELP:
        if (m_pDisplayHelp != NULL)
        {
            LPOLESTR pszHelpTopic;
            LPIEAKDATAOBJECT pIEAKDataObject;
            MMC_COOKIE cookie;

            hr = lpDataObject->QueryInterface(IID_IIEAKDataObject, (LPVOID *)&pIEAKDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pIEAKDataObject->GetCookie(&cookie);

            pIEAKDataObject->Release();

            if (FAILED(hr))
                return S_OK;

            if ((pszHelpTopic = (LPOLESTR) CoTaskMemAlloc(64 * sizeof(WCHAR))) != NULL)
            {
                LPIEAKMMCCOOKIE lpCookie = (LPIEAKMMCCOOKIE)cookie;

                // determine whether cookie is for scope pane item for result pane item
                
                if (PtrToUlong(lpCookie->lpItem) >= NUM_NAMESPACE_ITEMS)
                {
                    LPRESULTITEM lpResultItem = (LPRESULTITEM)lpCookie->lpItem;
                    
                    StrCpy(pszHelpTopic, HELP_FILENAME TEXT("::/"));
                    StrCat(pszHelpTopic, lpResultItem->pcszHelpTopic);
                }
                else
                    StrCpy(pszHelpTopic, HELP_FILENAME TEXT("::/ieakmmc.htm"));

                m_pDisplayHelp->ShowTopic (pszHelpTopic);
            }

        }
        break;

    case MMCN_COLUMNS_CHANGED:
        hr = S_OK;             // return S_OK so MMC will handle when the user add/removes columns
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CSnapIn::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}

STDMETHODIMP CSnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult != NULL)
    {
        if (pResult->bScopeItem == TRUE)
        {
            DWORD dwIndex = PtrToUlong(((LPIEAKMMCCOOKIE)pResult->lParam)->lpItem);

            if (pResult->mask & RDI_STR)
            {
                switch (pResult->nCol) 
                {
                case 0: 
                    CreateBufandLoadString(g_hInstance, g_NameSpace[dwIndex].iNameID,
                        &g_NameSpace[dwIndex].pszName, &pResult->str, MAX_DISPLAYNAME_SIZE);
                    break;
                case 1:  
                    CreateBufandLoadString(g_hInstance, g_NameSpace[dwIndex].iDescID,
                        &g_NameSpace[dwIndex].pszDesc, &pResult->str, MAX_PATH);
                    break;
                default:
                    pResult->str = L"";
                    break;
                }
            }

            if (pResult->mask & RDI_IMAGE)
            {
                pResult->nImage = dwIndex;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                LPRESULTITEM lpResultItem = (LPRESULTITEM)((LPIEAKMMCCOOKIE)pResult->lParam)->lpItem;

                switch (pResult->nCol)
                {
                    case 0:
                        if (InsIsKeyEmpty(IS_BRANDING, IK_GPE_ONETIME_GUID, m_pcd->GetInsFile()) ||
                            (lpResultItem->iNamePrefID == -1))
                        {
                            CreateBufandLoadString(g_hUIInstance, lpResultItem->iNameID, 
                                &lpResultItem->pszName, &pResult->str, MAX_DISPLAYNAME_SIZE);
                        }
                        else
                        {
                            CreateBufandLoadString(g_hUIInstance, lpResultItem->iNamePrefID, 
                                &lpResultItem->pszNamePref, &pResult->str, MAX_DISPLAYNAME_SIZE);
                        }

                        break;

                    case 1:
                        CreateBufandLoadString(g_hUIInstance, lpResultItem->iDescID, 
                            &lpResultItem->pszDesc, &pResult->str, MAX_PATH);
                        break;
                }

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }
        }
    }

    return S_OK;
}


STDMETHODIMP CSnapIn::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType,
                                        long *pViewOptions)
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(ppViewType);
    UNREFERENCED_PARAMETER(pViewOptions);

    return S_FALSE;
}

STDMETHODIMP CSnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPIEAKDATAOBJECT pIEAKDataObjectA, pIEAKDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private IEAKDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IIEAKDataObject,
                                            (LPVOID *)&pIEAKDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IIEAKDataObject,
                                            (LPVOID *)&pIEAKDataObjectB)))
    {
        pIEAKDataObjectA->Release();
        return S_FALSE;
    }

    pIEAKDataObjectA->GetCookie(&cookie1);
    pIEAKDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
        hr = S_OK;
    else
    {
        LPIEAKMMCCOOKIE lpCookie1 = (LPIEAKMMCCOOKIE)cookie1;
        LPIEAKMMCCOOKIE lpCookie2 = (LPIEAKMMCCOOKIE)cookie2;

        if (lpCookie1->lpItem == lpCookie2->lpItem) 
        {
            CSnapIn * pCS1 = (CSnapIn *)lpCookie1->lpParentItem;
            CSnapIn * pCS2 = (CSnapIn *)lpCookie2->lpParentItem;

            // check if these are referencing the same GPO
            if ((pCS1 == pCS2) || 
                (StrCmpI(pCS1->GetInsFile(), pCS2->GetInsFile()) == 0))
                hr = S_OK;
        }
    }


    pIEAKDataObjectA->Release();
    pIEAKDataObjectB->Release();

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Private helper functions
///////////////////////////////////////////////////////////////////////////////
HRESULT CSnapIn::AddPrecedencePropPage(LPPROPERTYSHEETCALLBACK lpProvider,
                                       LPPROPSHEETCOOKIE lpPropSheetCookie,
                                       LPCTSTR pszTitle, long nPageID)
{
    HRESULT hr = E_FAIL;
    __try
    {
        LPRSOPPAGECOOKIE lpRSOPPageCookie = (LPRSOPPAGECOOKIE)CoTaskMemAlloc(sizeof(RSOPPAGECOOKIE));
        lpRSOPPageCookie->psCookie = lpPropSheetCookie;
        lpRSOPPageCookie->nPageID = nPageID;

        PROPSHEETPAGE pspRSoP;

        pspRSoP.dwSize = sizeof(PROPSHEETPAGE);
        pspRSoP.dwFlags = PSP_HASHELP | PSP_USETITLE; // no callback
        pspRSoP.hInstance = g_hInstance;
        pspRSoP.pszTemplate = MAKEINTRESOURCE(IDD_RSOPP);
        pspRSoP.pfnDlgProc = RSoPDlgProc;

        // For regular pages, when callback fires on closing, it deletes a buffer.
        // We don't to do this twice!  However, since we're passing a different lParam,
        // this won't be a problem.
        pspRSoP.pfnCallback = PropSheetPageProc;
        pspRSoP.lParam = (LPARAM)lpRSOPPageCookie;
        pspRSoP.pszTitle = pszTitle;

        HPROPSHEETPAGE hPrecedencePage = CreatePropertySheetPage(&pspRSoP);
    
        if (hPrecedencePage != NULL)
            hr = lpProvider->AddPage(hPrecedencePage);
        else
            hr = E_FAIL;
    }
    __except(TRUE)
    {
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IExtendPropertySheet)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSnapIn::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr = S_OK;
    HPROPSHEETPAGE hPage;
    PROPSHEETPAGE psp;
    LPIEAKDATAOBJECT pIEAKDataObject;
    LPRESULTITEM pItem;
    LPPROPSHEETCOOKIE lpPropSheetCookie;
    MMC_COOKIE cookie;

    UNREFERENCED_PARAMETER(handle);

    //
    // Make sure this is one of our objects
    //

    if (FAILED(lpDataObject->QueryInterface(IID_IIEAKDataObject,
                                            (LPVOID *)&pIEAKDataObject)))
    {
        return hr;
    }


    //
    // Get the cookie
    //

    pIEAKDataObject->GetCookie(&cookie);
    pIEAKDataObject->Release();


    pItem = (LPRESULTITEM)((LPIEAKMMCCOOKIE)cookie)->lpItem;

    // check to make sure prop sheet is implemented

    if ((pItem->iDlgID == 0) || (pItem->pfnDlgProc == NULL))
        return S_OK;

    // set the ins file

    m_pcd->SetInsFile();

    // Block if we are in preference mode and this setting is not accessible to the user.
    // In RSoP mode, just avoid this.  The right thing to do would be to pop up this
    // error msg if the following criteria are met and all of the GPOs are in preference mode.
    if (!IsRSoP())
    {
        if ((pItem->iNamePrefID == -1) && (pItem->dwNameSpaceItem != ADM_NAMESPACE_ITEM) &&
            !InsIsKeyEmpty(IS_BRANDING, IK_GPE_ONETIME_GUID, m_pcd->GetInsFile()))
        {
            SIEErrorMessageBox(NULL, IDS_ERROR_ONETIME);
            return S_FALSE;
        }
    }
    // construct the cookie

    lpPropSheetCookie = (LPPROPSHEETCOOKIE)CoTaskMemAlloc(sizeof(PROPSHEETCOOKIE));
    lpPropSheetCookie->lpResultItem = pItem;
    lpPropSheetCookie->pCS = this;

    //
    // Initialize the common fields in the property sheet structure
    //

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_HASHELP | PSP_USECALLBACK;
    psp.hInstance = g_hUIInstance;
    psp.pszTemplate = MAKEINTRESOURCE(pItem->iDlgID);
    psp.pfnDlgProc = pItem->pfnDlgProc;
    psp.pfnCallback = PropSheetPageProc;
    psp.lParam = (LPARAM)lpPropSheetCookie;

    hPage = CreatePropertySheetPage(&psp);
    
    if (hPage != NULL)
        hr = lpProvider->AddPage(hPage);
    else
        hr = E_FAIL;

    if (SUCCEEDED(hr) && IsRSoP())
    {
        switch(pItem->iDlgID)
        {
        // Browser User Interface
        case IDD_BTITLE:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_TITLE_PREC), 0);
            break;
        case IDD_CUSTICON:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_SMALLLOGO_PREC), 0);
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_LARGELOGO_PREC), 1);
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_SMALLBMP_PREC), 2);
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_LARGEBMP_PREC), 3);
            break;
        case IDD_BTOOLBARS:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_TOOLBARBUTTON_PREC), 0);
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_TOOLBARBMP_PREC), 1);
            break;

        // Connection
        case IDD_CONNECTSET:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_PRECEDENCE), 0);
            break;
        case IDD_QUERYAUTOCONFIG:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_AUTODETECT_CFG_PREC), 0);
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_AUTOCFG_ENABLE_PREC), 1);
            break;
        case IDD_PROXY:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_PRECEDENCE), 0);
            break;
        case IDD_UASTRDLG:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_PRECEDENCE), 0);
            break;

        // URLs
        case IDD_FAVORITES:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_FAV_ONTOP_PREC), 0);
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_DEL_FAVS_PREC), 1);
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_FAVS_PREC), 2);
            break;
        case IDD_STARTSEARCH:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_HOMEPAGE_PREC), 0);
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_SEARCHPAGE_PREC), 1);
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_SUPPORTPAGE_PREC), 2);
            break;

        // Security
        case IDD_SECURITY1:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_SECZONES_PREC), 0);
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_CONTENTRAT_PREC), 1);
            break;
        case IDD_SECURITYAUTH:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_AUTHSECURITY_PREC), 0);
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_PUB_LOCK_PREC), 1);
            break;

        // Programs
        case IDD_PROGRAMS:
            AddPrecedencePropPage(lpProvider, lpPropSheetCookie, MAKEINTRESOURCE(IDS_PRECEDENCE), 0);
            break;

        // Advanced
        default:
            break;
        }
    }

    return (hr);
}

STDMETHODIMP CSnapIn::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    LPIEAKDATAOBJECT pIEAKDataObject;
    DATA_OBJECT_TYPES type;

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IIEAKDataObject,
                                               (LPVOID *)&pIEAKDataObject)))
    {
        pIEAKDataObject->GetType(&type);
        pIEAKDataObject->Release();

        if (type == CCT_RESULT)
            return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP CSnapIn::Command(long /*lCommandID*/, LPDATAOBJECT lpDataObject)
{
    LPIEAKDATAOBJECT pIEAKDataObject;
    
    if (FAILED(lpDataObject->QueryInterface(IID_IIEAKDataObject,
        (LPVOID *)&pIEAKDataObject)))
    {
        return S_FALSE;
    }
    
    pIEAKDataObject->Release();

    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\urls.cpp ===
#include "precomp.h"

#include "rsop.h"

/////////////////////////////////////////////////////////////////////
void InitUrlsDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();

            BOOL bHomeHandled = FALSE;
            BOOL bSearchHandled = FALSE;
            BOOL bSupportHandled = FALSE;
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                // homePageURL field
                _variant_t vtValue;
                if (!bHomeHandled)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"homePageURL", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        _bstr_t bstrValue = vtValue;
                        BOOL bChecked = (bstrValue.length() > 0);
                        SetDlgItemTextTriState(hDlg, IDE_STARTPAGE, IDC_STARTPAGE, (LPTSTR)bstrValue, bChecked);
                        bHomeHandled = TRUE;
                    }
                }

                // searchBarURL field
                vtValue;
                if (!bSearchHandled)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"searchBarURL", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        _bstr_t bstrValue = vtValue;
                        BOOL bChecked = (bstrValue.length() > 0);
                        SetDlgItemTextTriState(hDlg, IDE_SEARCHPAGE, IDC_SEARCHPAGE, (LPTSTR)bstrValue, bChecked);
                        bSearchHandled = TRUE;
                    }
                }

                // onlineHelpPageURL field
                vtValue;
                if (!bSupportHandled)
                {
                    hr = paPSObj[nObj]->pObj->Get(L"onlineHelpPageURL", 0, &vtValue, NULL, NULL);
                    if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                    {
                        _bstr_t bstrValue = vtValue;
                        BOOL bChecked = (bstrValue.length() > 0);
                        SetDlgItemTextTriState(hDlg, IDE_CUSTOMSUPPORT, IDC_CUSTOMSUPPORT, (LPTSTR)bstrValue, bChecked);
                        bSupportHandled = TRUE;
                    }
                }

                // no need to process other GPOs since enabled properties have been found
                if (bHomeHandled && bSearchHandled && bSupportHandled)
                    break;
            }
        }

        EnableDlgItem2(hDlg, IDC_STARTPAGE, FALSE);
        EnableDlgItem2(hDlg, IDE_STARTPAGE, FALSE);
        EnableDlgItem2(hDlg, IDC_SEARCHPAGE, FALSE);
        EnableDlgItem2(hDlg, IDE_SEARCHPAGE, FALSE);
        EnableDlgItem2(hDlg, IDC_CUSTOMSUPPORT, FALSE);
        EnableDlgItem2(hDlg, IDE_CUSTOMSUPPORT, FALSE);
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
HRESULT InitHomePageUrlPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    return InitGenericPrecedencePage(pDRD, hwndList, L"homePageURL");
}

/////////////////////////////////////////////////////////////////////
HRESULT InitSearchBarUrlPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    return InitGenericPrecedencePage(pDRD, hwndList, L"searchBarURL");
}

/////////////////////////////////////////////////////////////////////
HRESULT InitSupportPageUrlPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    return InitGenericPrecedencePage(pDRD, hwndList, L"onlineHelpPageURL");
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK UrlsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    BOOL fStartPage, fSearchPage, fSupportPage;
    int  nStatus;

    switch( msg )
    {
    case WM_INITDIALOG:
        SetPropSheetCookie(hDlg, lParam);

        EnableDBCSChars(hDlg, IDE_STARTPAGE);
        EnableDBCSChars(hDlg, IDE_SEARCHPAGE);
        EnableDBCSChars(hDlg, IDE_CUSTOMSUPPORT);

        // find out if this dlg is in RSoP mode
        psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        if (psCookie->pCS->IsRSoP())
        {

            CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
            if (pDRD)
                InitUrlsDlgInRSoPMode(hDlg, pDRD);
        }
        else
        {
            Edit_LimitText(GetDlgItem(hDlg, IDE_STARTPAGE), INTERNET_MAX_URL_LENGTH - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_SEARCHPAGE), INTERNET_MAX_URL_LENGTH - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_CUSTOMSUPPORT), INTERNET_MAX_URL_LENGTH - 1);

            // disable customization of search and online support page in preference mode
            if (!InsIsKeyEmpty(IS_BRANDING, IK_GPE_ONETIME_GUID, GetInsFile(hDlg)))
            {
                int rgids[] = { IDC_SEARCHPAGE, IDC_SEARCHPAGE_TXT, IDE_SEARCHPAGE,
                                IDC_CUSTOMSUPPORT, IDC_CUSTOMSUPPORT_TXT, IDE_CUSTOMSUPPORT};

                DisableDlgItems(hDlg, rgids, countof(rgids));
            }
        }

        break;

    case WM_DESTROY:
        if (psCookie->pCS->IsRSoP())
            DestroyDlgRSoPData(hDlg);
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_STARTPAGE:
                fStartPage = (IsDlgButtonChecked(hDlg, IDC_STARTPAGE) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_STARTPAGE, fStartPage);
                EnableDlgItem2(hDlg, IDC_STARTPAGE_TXT, fStartPage);
                break;
                
            case IDC_SEARCHPAGE:
                fSearchPage = (IsDlgButtonChecked(hDlg, IDC_SEARCHPAGE) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_SEARCHPAGE, fSearchPage);
                EnableDlgItem2(hDlg, IDC_SEARCHPAGE_TXT, fSearchPage);
                break;
                
            case IDC_CUSTOMSUPPORT:
                fSupportPage = (IsDlgButtonChecked(hDlg, IDC_CUSTOMSUPPORT) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_CUSTOMSUPPORT, fSupportPage);
                EnableDlgItem2(hDlg, IDC_CUSTOMSUPPORT_TXT, fSupportPage);
                break;

            default:
                return FALSE;
        }
        break;

    case WM_HELP:   // F1
        ShowHelpTopic(hDlg);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        TCHAR szMsgTitle[1024];
        TCHAR szMsgText[1024];

        case PSN_HELP:
            ShowHelpTopic(hDlg);
            break;

        case PSN_SETACTIVE:
            // don't do any of this stuff in RSoP mode
            if (!psCookie->pCS->IsRSoP())
            {
                // BUGBUG: <oliverl> revisit this in IE6 when we have server-side file

                InitializeStartSearch(hDlg, GetInsFile(hDlg), NULL);
            }
            break;

        case PSN_APPLY:
            if (psCookie->pCS->IsRSoP())
                return FALSE;
            else
            {
                // BUGBUG: <oliverl> revisit this in IE6 when we have server-side file

                fStartPage = (IsDlgButtonChecked(hDlg, IDC_STARTPAGE) == BST_CHECKED);
                fSearchPage = (IsDlgButtonChecked(hDlg, IDC_SEARCHPAGE) == BST_CHECKED);
                fSupportPage = (IsDlgButtonChecked(hDlg, IDC_CUSTOMSUPPORT) == BST_CHECKED);

                if ((fStartPage && !CheckField(hDlg, IDE_STARTPAGE, FC_URL))        ||
                    (fSearchPage && !CheckField(hDlg, IDE_SEARCHPAGE, FC_URL))      ||
                    (fSupportPage && !CheckField(hDlg, IDE_CUSTOMSUPPORT, FC_URL)))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    break;
                }
            
                nStatus = TS_CHECK_OK;
                IsTriStateValid(hDlg, IDE_STARTPAGE, IDC_STARTPAGE, &nStatus,
                                res2Str(IDS_QUERY_CLEARSETTING, szMsgText, countof(szMsgText)),
                                res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)));
                IsTriStateValid(hDlg, IDE_SEARCHPAGE, IDC_SEARCHPAGE, &nStatus, szMsgText, szMsgTitle);
                IsTriStateValid(hDlg, IDE_CUSTOMSUPPORT, IDC_CUSTOMSUPPORT, &nStatus, szMsgText, szMsgTitle);
            
                if (nStatus == TS_CHECK_ERROR ||
                    !AcquireWriteCriticalSection(hDlg))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    break;
                }
            
                SaveStartSearch(hDlg, GetInsFile(hDlg), NULL);
                SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
            }
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\snapin.h ===
//
// Global variables
//

extern LONG g_cRefThisDll;
extern HINSTANCE g_hInstance;
extern HINSTANCE g_hUIInstance;
extern GUID g_guidSnapinExt;
extern GUID g_guidClientExt;
extern CRITICAL_SECTION g_LayoutCriticalSection;
extern CRITICAL_SECTION g_ContextMenuCriticalSection;

// Constants/macros

#define IEAK_SUBDIR             TEXT("MICROSOFT\\IEAK")
#define INS_NAME                TEXT("install.ins")
#define HELP_FILENAME           L"ieakmmc.chm"

//  Snapin extension guid

// {FC715823-C5FB-11D1-9EEF-00A0C90347FF}
DEFINE_GUID(CLSID_IEAKSnapinExt,0xFC715823,0xC5FB,0x11D1,0x9E,0xEF,0x00,0xA0,0xC9,0x03,0x47,0xFF);
// {D524927D-6C08-46bf-86AF-391534D779D3}
DEFINE_GUID(CLSID_IEAKRSoPSnapinExt,0xd524927d,0x6c08,0x46bf,0x86,0xaf,0x39,0x15,0x34,0xd7,0x79,0xd3);

// Client extension guid

// {A2E30F80-D7DE-11d2-BBDE-00C04F86AE3B}
DEFINE_GUID(CLSID_IEAKClientExt, 0xA2E30F80, 0xD7DE, 0x11d2, 0xBB, 0xDE, 0x00, 0xC0, 0x4F, 0x86, 0xAE, 0x3B);

//
// Functions to create class factories
//

HRESULT CreateComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv);

class CSnapIn;

#include "cookie.h"

//
// SnapIn class
//

class CSnapIn:
    public IComponent,
    public IExtendPropertySheet,
    public IExtendContextMenu
{

protected:
    ULONG                   m_cRef;
    LPCONSOLE               m_pConsole;        // Console's IFrame interface
    CComponentData         *m_pcd;
    LPRESULTDATA            m_pResult;         // Result pane's interface
    LPHEADERCTRL            m_pHeader;         // Result pane's header control interface
    LPIMAGELIST             m_pImageResult;    // Result pane's image list interface
    LPDISPLAYHELP           m_pDisplayHelp;    // IDisplayHelp interface
    LPCONSOLEVERB           m_pConsoleVerb;    // pointer the console verb
    TCHAR                   m_szColumn1[32];   // Text for column 1
    TCHAR                   m_szColumn2[32];   // Text for column 2
    INT                     m_nColumnSize1;    // Size of column 1
    INT                     m_nColumnSize2;    // Size of column 2
    LONG                    m_lViewMode;       // View mode
    TCHAR                   m_szInsFile[MAX_PATH]; // current path to ins file in current GPO
    LPIEAKMMCCOOKIE         m_lpCookieList;    // list of cookies we allocated
    BOOL                    m_fOneTimeApply;   // flag on whether to apply GPO once or always

    static unsigned int     m_cfNodeType;

public:
    CSnapIn(CComponentData *pComponent);
    ~CSnapIn();

	//
	// RSoP implementation methods
	//
	BOOL IsRSoP() {return m_pcd->IsRSoP();}
	BSTR GetRSoPNamespace() {return m_pcd->GetRSoPNamespace();}


    STDMETHODIMP            SignalPolicyChanged(BOOL bMachine, BOOL bAdd, GUID *pGuidExtension,
                                             GUID *pGuidSnapin);
    STDMETHODIMP_(LPCTSTR)  GetInsFile();
    STDMETHODIMP_(CComponentData *)  GetCompData() {return m_pcd;}

    //
    // IUnknown methods
    //

    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP            Initialize(LPCONSOLE lpConsole);
    STDMETHODIMP            Destroy(MMC_COOKIE cookie);
    STDMETHODIMP            Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP            QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject);
    STDMETHODIMP            GetDisplayInfo(LPRESULTDATAITEM pResult);
    STDMETHODIMP            GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType, long *pViewOptions);
    STDMETHODIMP            CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);


    //
    // Implemented IExtendPropertySheet methods
    //

    STDMETHODIMP            CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP            QueryPagesFor(LPDATAOBJECT lpDataObject);

    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP            AddMenuItems(LPDATAOBJECT lpDataObject, 
                                LPCONTEXTMENUCALLBACK piCallback, long  *pInsertionAllowed);
    STDMETHODIMP            Command(long lCommandID, LPDATAOBJECT lpDataObject);

private:
	HRESULT AddPrecedencePropPage(LPPROPERTYSHEETCALLBACK lpProvider,
									LPPROPSHEETCOOKIE lpPropSheetCookie,
									LPCTSTR pszTitle, long nPageID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\useragnt.cpp ===
#include "precomp.h"

#include "rsop.h"

/////////////////////////////////////////////////////////////////////
void InitUserAgentDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();

            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                // userAgentText field
                _variant_t vtValue;
                hr = paPSObj[nObj]->pObj->Get(L"userAgentText", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                {
                    _bstr_t bstrValue = vtValue;
                    BOOL bChecked = (bstrValue.length() > 0);
                    SetDlgItemTextTriState(hDlg, IDC_UASTRING, IDC_UASTRINGCHECK, (LPTSTR)bstrValue, bChecked);
                    break;
                }
            }
        }

        EnableDlgItem2(hDlg, IDC_UASTRING, FALSE);
        EnableDlgItem2(hDlg, IDC_UASTRINGCHECK, FALSE);
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
HRESULT InitUserAgentPrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    return InitGenericPrecedencePage(pDRD, hwndList, L"userAgentText");
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK UserAgentDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    BOOL fUserAgent;
    int  nStatus;

    switch(msg)
    {
    case WM_INITDIALOG:
        SetPropSheetCookie(hDlg, lParam);

        EnableDBCSChars(hDlg, IDC_UASTRING);
        
        // find out if this dlg is in RSoP mode
        psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        if (psCookie->pCS->IsRSoP())
        {
            CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
            if (pDRD)
                InitUserAgentDlgInRSoPMode(hDlg, pDRD);
        }
        else
            Edit_LimitText(GetDlgItem(hDlg, IDC_UASTRING), MAX_PATH - 1);
        break;

    case WM_DESTROY:
        DestroyDlgRSoPData(hDlg); break;

        case WM_HELP:   // F1
            ShowHelpTopic(hDlg);
            break;

        case WM_COMMAND:
            if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
                return FALSE;
            
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_UASTRINGCHECK:
                    fUserAgent = (IsDlgButtonChecked(hDlg, IDC_UASTRINGCHECK) == BST_CHECKED);
                    EnableDlgItem2(hDlg, IDC_UASTRING, fUserAgent);
                    EnableDlgItem2(hDlg, IDC_UASTRING_TXT, fUserAgent);
                    break;
                
                default:
                    return FALSE;
            }
            break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
            TCHAR szMsgTitle[1024];
            TCHAR szMsgText[1024];

            case PSN_HELP:
                ShowHelpTopic(hDlg);
                break;
            case PSN_SETACTIVE:
                 // don't do any of this stuff in RSoP mode
                if (!psCookie->pCS->IsRSoP())
                {
                    // load information from ins file
                    SetDlgItemTextFromIns(hDlg, IDC_UASTRING, IDC_UASTRINGCHECK, IS_BRANDING, 
                        USER_AGENT, GetInsFile(hDlg), NULL, INSIO_TRISTATE);
                    EnableDlgItem2(hDlg, IDC_UASTRING_TXT, (IsDlgButtonChecked(hDlg, IDC_UASTRINGCHECK) == BST_CHECKED));
                }
                break;

            case PSN_APPLY:
                if (psCookie->pCS->IsRSoP())
                    return FALSE;
                else
                {
                    nStatus = TS_CHECK_OK;
                    IsTriStateValid(hDlg, IDC_UASTRING, IDC_UASTRINGCHECK, &nStatus,
                                    res2Str(IDS_QUERY_CLEARSETTING, szMsgText, countof(szMsgText)),
                                    res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)));
                
                    if (nStatus == TS_CHECK_ERROR ||
                        !AcquireWriteCriticalSection(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        break;
                    }
                
                    WriteDlgItemTextToIns(hDlg, IDC_UASTRING, IDC_UASTRINGCHECK, IS_BRANDING,
                        USER_AGENT, GetInsFile(hDlg), NULL, INSIO_TRISTATE);
                
                    SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
                }
                break;

            default:
                return FALSE;
        }
        break;
    
    default:
        return FALSE;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\title.cpp ===
#include "precomp.h"

#include "rsop.h"

/////////////////////////////////////////////////////////////////////
void InitTitleDlgInRSoPMode(HWND hDlg, CDlgRSoPData *pDRD)
{
    __try
    {
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        HRESULT hr = pDRD->GetArrayOfPSObjects(bstrClass);
        if (SUCCEEDED(hr))
        {
            CPSObjData **paPSObj = pDRD->GetPSObjArray();
            long nPSObjects = pDRD->GetPSObjCount();

            BOOL bTitleHandled = FALSE;
            for (long nObj = 0; nObj < nPSObjects; nObj++)
            {
                // titleBarText field
                _variant_t vtValue;
                hr = paPSObj[nObj]->pObj->Get(L"titleBarCustomText", 0, &vtValue, NULL, NULL);
                if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
                {
                    _bstr_t bstrValue = vtValue;
                    BOOL bChecked = (bstrValue.length() > 0);
                    SetDlgItemTextTriState(hDlg, IDE_TITLE, IDC_TITLE, (LPTSTR)bstrValue, bChecked);
                    bTitleHandled = TRUE;
                }

                // no need to process other GPOs since enabled properties have been found
                if (bTitleHandled)
                    break;
            }
        }

        EnableDlgItem2(hDlg, IDC_TITLE, FALSE);
        EnableDlgItem2(hDlg, IDE_TITLE, FALSE);
    }
    __except(TRUE)
    {
    }
}

/////////////////////////////////////////////////////////////////////
HRESULT InitTitlePrecPage(CDlgRSoPData *pDRD, HWND hwndList)
{
    return InitGenericPrecedencePage(pDRD, hwndList, L"titleBarCustomText");
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK TitleDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Retrieve Property Sheet Page info for each call into dlg proc.
    LPPROPSHEETCOOKIE psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);

    TCHAR szTitle[MAX_PATH];
    TCHAR szFullTitle[1024];
    TCHAR szTemp[MAX_PATH];
    DWORD dwTitlePrefixLen = 0;
    BOOL  fTitle;
    int   nStatus;

    switch( msg )
    {
    case WM_INITDIALOG:
        SetPropSheetCookie(hDlg, lParam);

        EnableDBCSChars(hDlg, IDE_TITLE);
        psCookie = (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
        if (psCookie->pCS->IsRSoP())
        {
            EnableDlgItem2(hDlg, IDC_TITLE, FALSE);
            EnableDlgItem2(hDlg, IDE_TITLE, FALSE);

            CDlgRSoPData *pDRD = GetDlgRSoPData(hDlg, psCookie->pCS);
            if (pDRD)
                InitTitleDlgInRSoPMode(hDlg, pDRD);
        }
        else
        {
            LoadString(g_hUIInstance, IDS_TITLE_PREFIX, szTitle, countof(szTitle));
            dwTitlePrefixLen = StrLen(szTitle);
            // browser will only display 74 chars before cutting off title
            Edit_LimitText(GetDlgItem(hDlg, IDE_TITLE), 74 - dwTitlePrefixLen);
        }
        break;

    case WM_DESTROY:
        if (psCookie->pCS->IsRSoP())
            DestroyDlgRSoPData(hDlg);
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_TITLE:
                fTitle = (IsDlgButtonChecked(hDlg, IDC_TITLE) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_TITLE, fTitle);
                EnableDlgItem2(hDlg, IDC_TITLE_TXT, fTitle);
                break;

            default:
                return FALSE;
        }
        break;

    case WM_HELP:   // F1
        ShowHelpTopic(hDlg);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        TCHAR szMsgTitle[1024];
        TCHAR szMsgText[1024];

        case PSN_HELP:
            ShowHelpTopic(hDlg);
            break;

        case PSN_SETACTIVE:
            // don't do any of this stuff in RSoP mode
        if (!psCookie->pCS->IsRSoP())
        {
            SetDlgItemTextFromIns(hDlg, IDE_TITLE, IDC_TITLE, IS_BRANDING, TEXT("Window_Title_CN"), 
                    GetInsFile(hDlg), NULL, INSIO_TRISTATE);
            EnableDlgItem2(hDlg, IDC_TITLE_TXT, (IsDlgButtonChecked(hDlg, IDC_TITLE) == BST_CHECKED));
        }
            break;

        case PSN_APPLY:
        if (psCookie->pCS->IsRSoP())
        return FALSE;
        else
        {
        nStatus = TS_CHECK_OK;
        IsTriStateValid(hDlg, IDE_TITLE, IDC_TITLE, &nStatus,
                    res2Str(IDS_QUERY_CLEARSETTING, szMsgText, countof(szMsgText)),
                    res2Str(IDS_TITLE, szMsgTitle, countof(szMsgTitle)));
        
        if (nStatus == TS_CHECK_ERROR || !AcquireWriteCriticalSection(hDlg))
        {
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            break;
        }
            
        fTitle = GetDlgItemTextTriState(hDlg, IDE_TITLE, IDC_TITLE, szTitle,countof(szTitle));
             
        // BUGBUG: <oliverl> revisit this in IE6 when we have server-side file

        InsWriteString(IS_BRANDING, TEXT("Window_Title_CN"), szTitle, GetInsFile(hDlg), 
                fTitle, NULL, INSIO_SERVERONLY | INSIO_TRISTATE);

        *szFullTitle = TEXT('\0');
        if (ISNONNULL(szTitle))
        {
            LoadString(g_hUIInstance, IDS_TITLE_PREFIX, szTemp, countof(szTemp));
            wnsprintf(szFullTitle, countof(szFullTitle), szTemp, szTitle);
        }
                InsWriteString(IS_BRANDING, IK_WINDOWTITLE, szFullTitle, GetInsFile(hDlg), 
                    fTitle, NULL, INSIO_TRISTATE);
            
                SignalPolicyChanged(hDlg, FALSE, TRUE, &g_guidClientExt, &g_guidSnapinExt);
        }
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\util.h ===
//
// Function proto-types for util.cpp
//

int SIEErrorMessageBox(HWND hDlg, UINT idErrStr, UINT uiFlags = 0);
void CreateWorkDir(LPCTSTR pcszInsFile, LPCTSTR pcszFeatureDir, LPTSTR pszWorkDir, 
                   LPCTSTR pcszCabDir = NULL, BOOL fCreate = TRUE);


UINT CALLBACK PropSheetPageProc(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
void SetPropSheetCookie(HWND hDlg, LPARAM lParam);
LPCTSTR GetInsFile(LPVOID lpVoid);
void ShowHelpTopic(LPVOID lpVoid);
BOOL AcquireWriteCriticalSection(HWND hDlg, CComponentData * pCDCurrent = NULL , 
                                 BOOL fCreateCookie = TRUE);
void ReleaseWriteCriticalSection(CComponentData * pCD, BOOL fDeleteCookie, BOOL fApplyPolicy, 
                                 BOOL bMachine = FALSE, BOOL bAdd = FALSE, 
                                 GUID *pGuidExtension = NULL, GUID *pGuidSnapin = NULL);
void SignalPolicyChanged(HWND hDlg, BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, 
                         GUID *pGuidSnapin, BOOL fAdvanced = FALSE);
LPCTSTR GetCurrentAdmFile(LPVOID lpVoid);

LPTSTR res2Str(int nIDString, LPTSTR pszBuffer, UINT cbBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\util.cpp ===
#include "precomp.h"
#include <ntverp.h>      //these are for
#include <common.ver>    //ver_productversion_str

// private forward declarations

#define LOCK_FILENAME   TEXT("LOCK")
#define MAX_LOCK_SPINS  10        // number of timeouts before we give up
#define LOCK_TIMEOUT    2000      // in milliseconds

static inline LPPROPSHEETCOOKIE getPropSheetCookie(HWND hDlg);

int SIEErrorMessageBox(HWND hDlg, UINT idErrStr, UINT uiFlags /* = 0 */)
{
    static TCHAR s_szTitle[128];
    TCHAR szMessage[MAX_PATH];

    if (ISNULL(s_szTitle))
        LoadString(g_hInstance, IDS_SIE_NAME, s_szTitle, countof(s_szTitle));

    if (LoadString(g_hInstance, idErrStr, szMessage, countof(szMessage)) == 0)
        LoadString(g_hUIInstance, idErrStr, szMessage, countof(szMessage));

    return MessageBox(hDlg, szMessage, s_szTitle, uiFlags ? uiFlags : MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
}   

void CreateWorkDir(LPCTSTR pcszInsFile, LPCTSTR pcszFeatureDir, LPTSTR pszWorkDir, 
                   LPCTSTR pcszCabDir /* = NULL */, BOOL fCreate /* = TRUE */)
{
    StrCpy(pszWorkDir, pcszInsFile);
    PathRemoveFileSpec(pszWorkDir);

    if (pcszCabDir != NULL)
        PathAppend(pszWorkDir, pcszCabDir);

    PathAppend(pszWorkDir, pcszFeatureDir);

    if (fCreate)
    {
        if (!PathFileExists(pszWorkDir))
            PathCreatePath(pszWorkDir);
    }
}

UINT CALLBACK PropSheetPageProc(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    UNREFERENCED_PARAMETER(hwnd);

    if ((uMsg == PSPCB_RELEASE) && (ppsp->lParam != NULL))
    {
        CoTaskMemFree((LPVOID)ppsp->lParam);
        ppsp->lParam = NULL;
    }

    return TRUE;
}

void SetPropSheetCookie(HWND hDlg, LPARAM lParam)
{
    LPPROPSHEETCOOKIE lpPropSheetCookie = (LPPROPSHEETCOOKIE)(((LPPROPSHEETPAGE)lParam)->lParam);
    TCHAR szTitle[MAX_PATH];
    INT   iNamePrefID = lpPropSheetCookie->lpResultItem->iNamePrefID;
    BOOL  fPrefTitle = (!InsIsKeyEmpty(IS_BRANDING, IK_GPE_ONETIME_GUID, lpPropSheetCookie->pCS->GetInsFile())) &&
                        (iNamePrefID != -1);

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lpPropSheetCookie);

    // overload the page title to get rid of the "properties" suffix
    if (LoadString(g_hUIInstance, fPrefTitle ? 
        iNamePrefID : lpPropSheetCookie->lpResultItem->iNameID,
        szTitle, countof(szTitle)) != 0)
        SetWindowText(GetParent(hDlg), szTitle);
}

LPCTSTR GetInsFile(LPVOID lpVoid)
{
    LPPROPSHEETCOOKIE lpPropSheetCookie = getPropSheetCookie((HWND)lpVoid);
    
    return lpPropSheetCookie->pCS->GetInsFile();
}

void ShowHelpTopic(LPVOID lpVoid)
{
    LPPROPSHEETCOOKIE lpPropSheetCookie = getPropSheetCookie((HWND)lpVoid);
    if (lpPropSheetCookie && lpPropSheetCookie->lpResultItem)
    {
        WCHAR wszHelpTopic[MAX_PATH];

        StrCpyW(wszHelpTopic, HELP_FILENAME TEXT("::/"));
        StrCatW(wszHelpTopic, lpPropSheetCookie->lpResultItem->pcszHelpTopic);
    
        MMCPropertyHelp((LPOLESTR)wszHelpTopic);
    }
}

BOOL AcquireWriteCriticalSection(HWND hDlg, CComponentData * pCDCurrent /* = NULL */, 
                                 BOOL fCreateCookie /* = TRUE */)
{
    CComponentData * pCD;
    TCHAR szLockFile[MAX_PATH];
    LPTSTR pszLockName;
    HANDLE hLock;
    DWORD dwRet;
    BOOL fRet = TRUE;

    if (hDlg != NULL)
    {
        LPPROPSHEETCOOKIE lpPropSheetCookie = getPropSheetCookie(hDlg);

        pCD = lpPropSheetCookie->pCS->GetCompData();
    }
    else
        if (pCDCurrent)
            pCD = pCDCurrent;
        else
        {
            fRet = false;
            goto exit;
        }

    StrCpy(szLockFile, pCD->GetInsFile());
    PathRemoveFileSpec(szLockFile);
    PathAppend(szLockFile, TEXT("LOCK"));
    PathCreatePath(szLockFile);
    pszLockName = PathAddBackslash(szLockFile);
    StrCpy(pszLockName, LOCK_FILENAME);

    // (pritobla): Delete the lock file before acquiring it.
    // If someone else has acquired it, the delete would fail, which is correct behavior.
    // If the file was left behind (probably because the machine crashed the last time the file was created),
    // then the delete would succeed and subsequently, the CreateFile would succeed.
    DeleteFile(szLockFile);

    hLock = CreateFile(szLockFile, GENERIC_WRITE, 0, NULL, CREATE_NEW, 
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL);

    if (hLock == INVALID_HANDLE_VALUE)
    {
        HANDLE hNotify;
        DWORD dwSpins = 0;

        *pszLockName = TEXT('\0');    
        hNotify = FindFirstChangeNotification(szLockFile, FALSE, FILE_NOTIFY_CHANGE_FILE_NAME);

        if (hNotify == INVALID_HANDLE_VALUE)
        {
            fRet = FALSE;
            goto exit;
        }

        StrCpy(pszLockName, LOCK_FILENAME);

        do 
        {
            while (((dwRet = MsgWaitForMultipleObjects(1, &hNotify, FALSE, LOCK_TIMEOUT, QS_ALLINPUT)) != WAIT_OBJECT_0) &&
                    (dwRet != WAIT_TIMEOUT))
            {
                MSG msg;
                
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
            
            dwSpins++;

            hLock = CreateFile(szLockFile, GENERIC_WRITE, 0, NULL, CREATE_NEW, 
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL);

            if ((hLock != INVALID_HANDLE_VALUE) || (dwSpins == MAX_LOCK_SPINS))
                break;
        }
        while (FindNextChangeNotification(hNotify));

        if (!FindCloseChangeNotification(hNotify) || (hLock == INVALID_HANDLE_VALUE))
        {
            if (hLock != INVALID_HANDLE_VALUE)
                CloseHandle(hLock);

            fRet = FALSE;
            goto exit;
        }
    }

    pCD->SetLockHandle(hLock);
    
    if (fCreateCookie)
    {
        // now that we have the lock, create our cookie file in our root GPO dir
        
        *(pszLockName-1) = TEXT('\0');
        PathRemoveFileSpec(szLockFile);
        PathAppend(szLockFile, IEAK_GPE_COOKIE_FILE);
        
        hLock = CreateFile(szLockFile, GENERIC_WRITE, 0, NULL, CREATE_NEW, 
            FILE_ATTRIBUTE_NORMAL, NULL);
        
        
        if (hLock != INVALID_HANDLE_VALUE)
            CloseHandle(hLock);
        else
        {
            ASSERT(FALSE);
        }
    }

exit:

    if (!fRet)
    {
        TCHAR szTitle[MAX_PATH], szMsg[MAX_PATH];
        
        LoadString(g_hInstance, IDS_SIE_NAME, szTitle, countof(szTitle));
        LoadString(g_hInstance, IDS_ERROR_SAVE, szMsg, countof(szMsg));
        
        MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
    }

    return fRet;
}

void ReleaseWriteCriticalSection(CComponentData * pCD, BOOL fDeleteCookie, BOOL fApplyPolicy, 
                                 BOOL bMachine /* = FALSE */, BOOL bAdd /* = FALSE */, 
                                 GUID *pGuidExtension /* = NULL */, GUID *pGuidSnapin /* = NULL */)
{
    HANDLE hLock;
    if (fDeleteCookie)
    {
        TCHAR szCookieFile[MAX_PATH];
        
        StrCpy(szCookieFile, pCD->GetInsFile());
        PathRemoveFileSpec(szCookieFile);
        PathAppend(szCookieFile, IEAK_GPE_COOKIE_FILE);
        DeleteFile(szCookieFile);
        if (fApplyPolicy)
            pCD->SignalPolicyChanged(bMachine, bAdd, pGuidExtension, pGuidSnapin);
    }

    if ((hLock = pCD->GetLockHandle()) != INVALID_HANDLE_VALUE)
    {
        pCD->SetLockHandle(INVALID_HANDLE_VALUE);
        CloseHandle(hLock);
    }
    else
    {
        ASSERT(FALSE);
    }
}

void SignalPolicyChanged(HWND hDlg, BOOL bMachine, BOOL bAdd, GUID *pGuidExtension,
                         GUID *pGuidSnapin, BOOL fAdvanced /* = FALSE */)
{
    LPPROPSHEETCOOKIE lpPropSheetCookie = getPropSheetCookie(hDlg);
    TCHAR szCookieFile[MAX_PATH];
    TCHAR szGuid[128];
    GUID guid;

    USES_CONVERSION;

    StrCpy(szCookieFile, lpPropSheetCookie->pCS->GetInsFile());

    WritePrivateProfileString(BRANDING, GPVERKEY, A2CT(VER_PRODUCTVERSION_STR), szCookieFile);
    //clear other keys so we're sure this is GP
    WritePrivateProfileString(BRANDING, PMVERKEY, NULL, szCookieFile);
    WritePrivateProfileString(BRANDING, IK_WIZVERSION, NULL, szCookieFile);

    //  write out a new guid for one time branding to the ins file if there was already one
    //  there to signify apply only once is checked

    if (!InsIsKeyEmpty(IS_BRANDING, IK_GPE_ONETIME_GUID, szCookieFile))
    {
        if (CoCreateGuid(&guid) == NOERROR)
            CoStringFromGUID(guid, szGuid, countof(szGuid));
        else
            szGuid[64] = TEXT('\0');
        
        InsWriteString(IS_BRANDING, IK_GPE_ONETIME_GUID, szGuid, szCookieFile);
    }
    
    // write out a separate guid to track adms since they are always preferences
    
    if (fAdvanced)
    {
        if (CoCreateGuid(&guid) == NOERROR)
            CoStringFromGUID(guid, szGuid, countof(szGuid));
        else
            szGuid[64] = TEXT('\0');
        
        InsWriteString(IS_BRANDING, IK_GPE_ADM_GUID, szGuid, szCookieFile);
    }
    
    InsFlushChanges(szCookieFile);
    ReleaseWriteCriticalSection(lpPropSheetCookie->pCS->GetCompData(), TRUE, TRUE, bMachine, bAdd, 
        pGuidExtension, pGuidSnapin);
}

LPCTSTR GetCurrentAdmFile(LPVOID lpVoid)
{
    LPPROPSHEETCOOKIE lpPropSheetCookie = getPropSheetCookie((HWND)lpVoid);
    
    return lpPropSheetCookie->lpResultItem->pszDesc;
}

LPTSTR res2Str(int nIDString, LPTSTR pszBuffer, UINT cbBuffer)
{
    if (pszBuffer == NULL || cbBuffer == 0)
        return NULL;

    *pszBuffer = TEXT('\0');
    
    if (LoadString(g_hInstance, nIDString, pszBuffer, cbBuffer) == 0)
        LoadString(g_hUIInstance, nIDString, pszBuffer, cbBuffer);
    
    return pszBuffer;
}

// private helper APIs for this file

static inline LPPROPSHEETCOOKIE getPropSheetCookie(HWND hDlg)
{
    return (LPPROPSHEETCOOKIE)GetWindowLongPtr(hDlg, DWLP_USER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieaksie\treeopt.cpp ===
#include "precomp.h"

#include "rsopsec.h"

#include <regapix.h>		// MAXIMUM_SUB_KEY_LENGTH, MAXIMUM_VALUE_NAME_LENGTH, MAXIMUM_DATA_LENGTH


// TREE_TYPE
#define TREE_UNKNOWN	0
#define TREE_NEITHER	1
#define TREE_CHECKBOX	2
#define TREE_GROUP		3
#define TREE_RADIO		4

const struct
{
	DWORD		type; // TREE_TYPE
	LPCTSTR 	name;
} c_aTreeTypes[] =
{
	{TREE_CHECKBOX, TEXT("checkbox")},
	{TREE_RADIO, TEXT("radio")},
	{TREE_GROUP, TEXT("group")}
};

const TCHAR c_szType[]				= TEXT("Type");
const TCHAR c_szText[]				= TEXT("Text");
const TCHAR c_szPlugUIText[]		= TEXT("PlugUIText");
const TCHAR c_szDefaultBitmap[] 	= TEXT("Bitmap");
const TCHAR c_szHKeyRoot[]		  = TEXT("HKeyRoot");
const TCHAR c_szValueName[]		  = TEXT("ValueName");
const TCHAR c_szCheckedValue[]		= TEXT("CheckedValue");
//const TCHAR c_szUncheckedValue[]	  = TEXT("UncheckedValue");
const TCHAR c_szDefaultValue[]	  = TEXT("DefaultValue");
//const TCHAR c_szSPIAction[]		  = TEXT("SPIAction");
//const TCHAR c_szSPIParamON[]		  = TEXT("SPIParamON");
//const TCHAR c_szSPIParamOFF[] 	  = TEXT("SPIParamOFF");
const TCHAR c_szCheckedValueNT[]	= TEXT("CheckedValueNT");
const TCHAR c_szCheckedValueW95[]	= TEXT("CheckedValueW95");
const TCHAR c_szMask[]			  = TEXT("Mask");
const TCHAR c_szOffset[]			  = TEXT("Offset");
//const TCHAR c_szHelpID[]			  = TEXT("HelpID");
const TCHAR c_szWarning[] 		  = TEXT("WarningIfNotDefault");

// REG_CMD
#define REG_GETDEFAULT			1
#define REG_GET 				2
#define REG_SET					3

// WALK_TREE_CMD
#define WALK_TREE_DELETE		1
#define WALK_TREE_RESTORE		2
#define WALK_TREE_REFRESH		3

#define IDCHECKED		0
#define IDUNCHECKED 	1
#define IDRADIOON		2
#define IDRADIOOFF		3
#define IDUNKNOWN		4

#define BITMAP_WIDTH	16
#define BITMAP_HEIGHT	16
#define NUM_BITMAPS 	5
#define MAX_KEY_NAME	64

#define MAX_URL_STRING		INTERNET_MAX_URL_LENGTH

BOOL g_fNashInNewProcess = FALSE;			// Are we running in a separate process
BOOL g_fRunningOnNT = FALSE;
BOOL g_bRunOnNT5 = FALSE;
BOOL g_fRunOnWhistler = FALSE;
BOOL g_bRunOnMemphis = FALSE;
BOOL g_fRunOnFE = FALSE;
DWORD g_dwStopWatchMode = 0;				// Shell perf automation
HKEY g_hkeyExplorer = NULL; 				// for SHGetExplorerHKey() in util.cpp
HANDLE g_hCabStateChange = NULL;
BOOL g_fIE = FALSE;


///////////////////////////////////////////////////////////////////////////////
static int __cdecl CompareActionSettingStrings(const void *arg1, const void *arg2)
{
	int iRet = 0;
	__try
	{
		iRet = StrCmp(((ACTION_SETTING *)arg1)->szName, ((ACTION_SETTING *)arg2)->szName );
	}
	__except(TRUE)
	{
		ASSERT(0);
	}
	return iRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// CRegTreeOptions Object
//
//////////////////////////////////////////////////////////////////////////////

CRegTreeOptions::CRegTreeOptions() :
	m_nASCount(0)
{
//	  cRef = 1;
}		

CRegTreeOptions::~CRegTreeOptions()
{
//	  ASSERT(cRef == 0);				 // should always have zero

//	  Str_SetPtr(&_pszParam, NULL);
}	 


/////////////////////////////////////////////////////////////////////
BOOL IsScreenReaderEnabled()
{
	BOOL bRet = FALSE;
	SystemParametersInfoA(SPI_GETSCREENREADER, 0, &bRet, 0);
	return bRet;
}

/////////////////////////////////////////////////////////////////////
BOOL CRegTreeOptions::WalkTreeRecursive(HTREEITEM htvi, WALK_TREE_CMD cmd)
{
    HTREEITEM hctvi;    // child
    TV_ITEM   tvi;
    HKEY hkey;
    BOOL bChecked;

    // step through the children
    hctvi = TreeView_GetChild( m_hwndTree, htvi );
    while ( hctvi )
    {
        WalkTreeRecursive(hctvi, cmd);
        hctvi = TreeView_GetNextSibling( m_hwndTree, hctvi );
    }

    // get ourselves
    tvi.mask  = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvi.hItem = htvi;
    TreeView_GetItem( m_hwndTree, &tvi );

    switch (cmd)
    {
    case WALK_TREE_DELETE:
        // if we are destroying the tree...
        // do we have something to clean up?
        if ( tvi.lParam )
        {
            // close the reg hey
            RegCloseKey((HKEY)tvi.lParam);
        }        
        break;
    
    case WALK_TREE_RESTORE:
    case WALK_TREE_REFRESH:
        hkey = (HKEY)tvi.lParam;
        bChecked = FALSE;
        
        if ((tvi.iImage == IDCHECKED)   ||
            (tvi.iImage == IDUNCHECKED) ||
            (tvi.iImage == IDRADIOON)   ||
            (tvi.iImage == IDRADIOOFF))
        {
            GetCheckStatus(hkey, &bChecked, cmd == WALK_TREE_RESTORE ? TRUE : FALSE);
            tvi.iImage = (tvi.iImage == IDCHECKED) || (tvi.iImage == IDUNCHECKED) ?
                         (bChecked ? IDCHECKED : IDUNCHECKED) :
                         (bChecked ? IDRADIOON : IDRADIOOFF);
            tvi.iSelectedImage = tvi.iImage;
            TreeView_SetItem(m_hwndTree, &tvi);
        }        
        break;
    }

    return TRUE;    // success?
}

/////////////////////////////////////////////////////////////////////
BOOL IsValidKey(HKEY hkeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValue)
{
	TCHAR szPath[MAX_PATH];
	DWORD dwType, cbSize = sizeof(szPath);

	if (ERROR_SUCCESS == SHGetValue(hkeyRoot, pszSubKey, pszValue, &dwType, szPath, &cbSize))
	{
		// Zero in the DWORD case or NULL in the string case
		// indicates that this item is not available.
		if (dwType == REG_DWORD)
			return *((DWORD *)szPath) != 0;
		else
			return szPath[0] != 0;
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////
HRESULT CRegTreeOptions::WalkTree(WALK_TREE_CMD cmd)
{
    HTREEITEM htvi = TreeView_GetRoot( m_hwndTree );
    
    // and walk the list of other roots
    while (htvi)
    {
        // recurse through its children
        WalkTreeRecursive(htvi, cmd);

        // get the next root
        htvi = TreeView_GetNextSibling( m_hwndTree, htvi );
    }
    
    return S_OK;    // success?
}

#define REGSTR_POLICIES_EXPLORER TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")

/////////////////////////////////////////////////////////////////////
BOOL CRegTreeOptions::RegIsRestricted(HKEY hsubkey)
{
	HKEY hkey;
	BOOL fRet = FALSE;
	// Does a "Policy" Sub key exist?
	if (RegOpenKeyEx(hsubkey, TEXT("Policy"), 0, KEY_READ, &hkey) == ERROR_SUCCESS)
	{
		// Yes; Enumerate this key. The Values are Policy keys or 
		// Full reg paths.
		DWORD cb;
		TCHAR szKeyName[ MAX_KEY_NAME ];
		FILETIME ftLastWriteTime;

		for (int i=0; 
			cb = ARRAYSIZE( szKeyName ),
			ERROR_SUCCESS == RegEnumKeyEx( hkey, i, szKeyName, &cb, NULL, NULL, NULL, &ftLastWriteTime )
			&& !fRet; i++)
		{
			TCHAR szPath[MAXIMUM_SUB_KEY_LENGTH];
			DWORD dwType, cbSize = sizeof(szPath);

			if (ERROR_SUCCESS == SHGetValue(hkey, szKeyName, TEXT("RegKey"), &dwType, szPath, &cbSize))
			{
				if (IsValidKey(HKEY_LOCAL_MACHINE, szPath, szKeyName))
				{
					fRet = TRUE;
					break;
				}
			}

			// It's not a full Key, try off of policies
			if (IsValidKey(HKEY_LOCAL_MACHINE, REGSTR_POLICIES_EXPLORER, szKeyName) ||
				IsValidKey(HKEY_CURRENT_USER, REGSTR_POLICIES_EXPLORER, szKeyName))
			{
				fRet = TRUE;
				break;
			}
		}
		RegCloseKey(hkey);
	}

	return fRet;
}

/////////////////////////////////////////////////////////////////////
DWORD RegTreeType( LPCTSTR pszType )
{
	for (int i = 0; i < ARRAYSIZE(c_aTreeTypes); i++)
	{
		if (!lstrcmpi(pszType, c_aTreeTypes[i].name))
			return c_aTreeTypes[i].type;
	}
	
	return TREE_UNKNOWN;
}

/////////////////////////////////////////////////////////////////////
int CRegTreeOptions::DefaultIconImage(HKEY hkey, int iImage)
{
	TCHAR	szIcon [ MAX_PATH + 10 ];	// 10 = ",XXXX" plus some more
	DWORD	cb = sizeof(szIcon);

	if (ERROR_SUCCESS ==
		SHQueryValueEx(hkey, c_szDefaultBitmap, NULL, NULL, szIcon, &cb))
	{
		int 		image;
		LPTSTR		psz = StrRChr( szIcon, szIcon + lstrlen(szIcon), TEXT(',') );
		HICON hicon = NULL;

		ASSERT( psz );	 // shouldn't be zero
		if ( !psz )
			return iImage;

		*psz++ = 0; // terminate and move over
		image = StrToInt( psz ); // get ID

		if (!*szIcon)
		{
			hicon = (HICON)LoadIcon(g_hInstance, (LPCTSTR)(INT_PTR)image);
		}
		else
		{
			// get the bitmap from the library
			ExtractIconEx(szIcon, (UINT)(-1*image), NULL, &hicon, 1 );
			if (!hicon)
				ExtractIconEx(szIcon, (UINT)(-1*image), &hicon, NULL, 1 );
				
		}
		
		if (hicon)
		{
			iImage = ImageList_AddIcon( m_hIml, (HICON)hicon);

			// NOTE: The docs say you don't need to do a delete object on icons loaded by LoadIcon, but
			// you do for CreateIcon.  It doesn't say what to do for ExtractIcon, so we'll just call it anyway.
			DestroyIcon( hicon );
		}
	}

	return iImage;
}

/////////////////////////////////////////////////////////////////////
DWORD CRegTreeOptions::RegGetSetSetting(HKEY hKey, DWORD *pType, LPBYTE pData, DWORD *pcbData, REG_CMD cmd)
{
	DWORD dwRet = ERROR_SUCCESS;
	__try
	{
		if (cmd == REG_GETDEFAULT)
			dwRet = SHQueryValueEx(hKey, c_szDefaultValue, NULL, pType, pData, pcbData);
		else
		{
			// support for masks 
			DWORD dwMask = 0xFFFFFFFF;        // Default value
			DWORD cb = sizeof(dwMask);
			BOOL fMask = (SHQueryValueEx(hKey, c_szMask, NULL, NULL, &dwMask, &cb) == ERROR_SUCCESS);
    
			// support for structures
			DWORD dwOffset = 0;               // Default value
			cb = sizeof(dwOffset);
//TODO: uncomment			BOOL fOffset = (SHQueryValueEx(hKey, c_szOffset, NULL, NULL, &dwOffset, &cb) == ERROR_SUCCESS);
    
			HKEY hkRoot = HKEY_CURRENT_USER; // Preinitialize to keep Win64 happy
			cb = sizeof(DWORD); // DWORD, not sizeof(HKEY) or Win64 will get mad
			DWORD dwError = SHQueryValueEx(hKey, c_szHKeyRoot, NULL, NULL, &hkRoot, &cb);
			hkRoot = (HKEY) LongToHandle(HandleToLong(hkRoot));
			if (dwError != ERROR_SUCCESS)
			{
				// use default
				hkRoot = HKEY_CURRENT_USER;
			}
    
			dwError = SHQueryValueEx(hKey, c_szDefaultValue, NULL, pType, pData, pcbData);
    
			TCHAR szName[MAX_PATH];
			cb = sizeof(szName);
			dwError = SHQueryValueEx(hKey, c_szValueName, NULL, NULL, szName, &cb);
			if (dwError == ERROR_SUCCESS)
			{
				// find the matching ACTION_SETTING for this value name
				ACTION_SETTING asKey;
				StrCpy(asKey.szName, szName);
				ACTION_SETTING *pas = (ACTION_SETTING*)bsearch(&asKey, &m_as, m_nASCount, sizeof(m_as[0]),
																CompareActionSettingStrings);

				switch (cmd)
				{
				case REG_GET:
					// grab the value that we have
/*						if (fOffset)
					{
						// TODO: handle this someday
						if (dwOffset < cbData / sizeof(DWORD))
							*((DWORD *)pData) = *(pdwData + dwOffset);
						else
							*((DWORD *)pData) = 0;  // Invalid offset, return something vague
						*pcbData = sizeof(DWORD);
					}
					else
*/
            
					if (NULL != pas)
					{
						*((DWORD *)pData) = pas->dwValue;
						*pcbData = sizeof(pas->dwValue);

						if (fMask)
							*((DWORD *)pData) &= dwMask;
					}
					break;
				}
			}
    
			if ((cmd == REG_GET) && (dwError != ERROR_SUCCESS))
			{
				// get the default setting
				dwError = SHQueryValueEx(hKey, c_szDefaultValue, NULL, pType, pData, pcbData);
			}
    
			return dwError;
		}
	}
	__except(TRUE)
	{
	}
	return dwRet;
}

/////////////////////////////////////////////////////////////////////
DWORD CRegTreeOptions::GetCheckStatus(HKEY hkey, BOOL *pbChecked, BOOL bUseDefault)
{
	DWORD dwError, cbData, dwType;
	BYTE rgData[32];
	DWORD cbDataCHK, dwTypeCHK;
	BYTE rgDataCHK[32];

	// first, get the setting from the specified location.	  
	cbData = sizeof(rgData);
	
	dwError = RegGetSetSetting(hkey, &dwType, rgData, &cbData, bUseDefault ? REG_GETDEFAULT : REG_GET);
	if (dwError == ERROR_SUCCESS)
	{
		// second, get the value for the "checked" state and compare.
		cbDataCHK = sizeof(rgDataCHK);
		dwError = SHQueryValueEx(hkey, c_szCheckedValue, NULL, &dwTypeCHK, rgDataCHK, &cbDataCHK);
		if (dwError != ERROR_SUCCESS)
		{
			// ok, we couldn't find the "checked" value, is it because
			// it's platform dependent?
			cbDataCHK = sizeof(rgDataCHK);
			dwError = SHQueryValueEx(hkey, 
				g_fRunningOnNT ? c_szCheckedValueNT : c_szCheckedValueW95,
				NULL, &dwTypeCHK, rgDataCHK, &cbDataCHK);
		}
		
		if (dwError == ERROR_SUCCESS)
		{
			// make sure two value types match.
			if ((dwType != dwTypeCHK) &&
					(((dwType == REG_BINARY) && (dwTypeCHK == REG_DWORD) && (cbData != 4))
					|| ((dwType == REG_DWORD) && (dwTypeCHK == REG_BINARY) && (cbDataCHK != 4))))
				return ERROR_BAD_FORMAT;
				
			switch (dwType) {
			case REG_DWORD:
				*pbChecked = (*((DWORD*)rgData) == *((DWORD*)rgDataCHK));
				break;
				
			case REG_SZ:
				if (cbData == cbDataCHK)
					*pbChecked = !lstrcmp((LPTSTR)rgData, (LPTSTR)rgDataCHK);
				else
					*pbChecked = FALSE;
					
				break;
				
			case REG_BINARY:
				if (cbData == cbDataCHK)
					*pbChecked = !memcmp(rgData, rgDataCHK, cbData);
				else
					*pbChecked = FALSE;
					
				break;
				
			default:
				return ERROR_BAD_FORMAT;
			}
		}
	}
	
	return dwError;
}

BOOL AppendStatus(LPTSTR pszText,UINT cbText, BOOL fOn)
{
	LPTSTR pszTemp;
	UINT cbStrLen , cbStatusLen;
	
	//if there's no string specified then return
	if (!pszText)
		return FALSE;
	
	//Calculate the string lengths
	cbStrLen = lstrlen(pszText);
	cbStatusLen = fOn ? lstrlen(TEXT("-ON")) : lstrlen(TEXT("-OFF"));
   

	//Remove the old status appended
	pszTemp = StrRStrI(pszText,pszText + cbStrLen, TEXT("-ON"));

	if(pszTemp)
	{
		*pszTemp = (TCHAR)0;
		cbStrLen = lstrlen(pszText);
	}

	pszTemp = StrRStrI(pszText,pszText + cbStrLen, TEXT("-OFF"));

	if(pszTemp)
	{
		*pszTemp = (TCHAR)0;
		cbStrLen = lstrlen(pszText);
	}

	//check if we append status text, we'll explode or not
	if (cbStrLen + cbStatusLen > cbText)	
	{
		//We'll explode 
		return FALSE;
	}

	if (fOn)
	{
		StrCat(pszText, TEXT("-ON"));
	}
	else
	{
		StrCat(pszText, TEXT("-OFF"));
	}
	return TRUE;
}

HTREEITEM Tree_AddItem(HTREEITEM hParent, LPTSTR pszText, HTREEITEM hInsAfter, 
					   int iImage, HWND hwndTree, HKEY hkey, BOOL *pbExisted)
{
	HTREEITEM hItem;
	TV_ITEM tvI;
	TV_INSERTSTRUCT tvIns;
	TCHAR szText[MAX_URL_STRING];

	ASSERT(pszText != NULL);
	StrCpyN(szText, pszText, ARRAYSIZE(szText));

	// NOTE:
	//	This code segment is disabled because we only enum explorer
	//	tree in HKCU, so there won't be any duplicates.
	//	Re-able this code if we start to also enum HKLM that could potentially
	//	result in duplicates.
	
	// We only want to add an item if it is not already there.
	// We do this to handle reading out of HKCU and HKLM.
	//
	TCHAR szKeyName[ MAX_KEY_NAME ];
	
	tvI.mask		= TVIF_HANDLE | TVIF_TEXT;
	tvI.pszText 	= szKeyName;
	tvI.cchTextMax	= ARRAYSIZE(szKeyName);
	
	for (hItem = TreeView_GetChild(hwndTree, hParent) ;
		hItem != NULL ;
		hItem = TreeView_GetNextSibling(hwndTree, hItem)
		)
	{
		tvI.hItem = hItem;
		if (TreeView_GetItem(hwndTree, &tvI))
		{
			if (!StrCmp(tvI.pszText, szText))
			{
				// We found a match!
				//
				*pbExisted = TRUE;
				return hItem;
			}
		}
	}

	// Create the item
	tvI.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
	tvI.iImage		   = iImage;
	tvI.iSelectedImage = iImage;
	tvI.pszText 	   = szText;
	tvI.cchTextMax	   = lstrlen(szText);

	// lParam is the HKEY for this item:
	tvI.lParam = (LPARAM)hkey;

	// Create insert item
	tvIns.item		   = tvI;
	tvIns.hInsertAfter = hInsAfter;
	tvIns.hParent	   = hParent;

	// Insert the item into the tree.
	hItem = (HTREEITEM) SendMessage(hwndTree, TVM_INSERTITEM, 0, 
									(LPARAM)(LPTV_INSERTSTRUCT)&tvIns);

	*pbExisted = FALSE;
	return (hItem);
}

/////////////////////////////////////////////////////////////////////
BOOL CRegTreeOptions::RegEnumTree(HKEY hkeyRoot, LPCSTR pszRoot, HTREEITEM htviparent, HTREEITEM htvins)
{
	HKEY			hkey, hsubkey;
	TCHAR			szKeyName[ MAX_KEY_NAME ];
	FILETIME		ftLastWriteTime;
		
	if (RegOpenKeyExA(hkeyRoot, pszRoot, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
	{
		int i;
		DWORD cb;
		BOOL bScreenReaderEnabled = IsScreenReaderEnabled();

		// we must search all the sub-keys
		for (i=0;					 // always start with 0
			cb=ARRAYSIZE( szKeyName ),	 // string size
			   ERROR_SUCCESS ==
			   RegEnumKeyEx( hkey, i, szKeyName, &cb, NULL, NULL, NULL, &ftLastWriteTime );
			i++)					// get next entry
		{
			// get more info on the entry
			if ( ERROR_SUCCESS == 
				 RegOpenKeyEx( hkey, szKeyName, 0, KEY_READ, &hsubkey ) )
			{
				TCHAR szTemp[MAX_PATH];
				HKEY hkeySave = NULL;

				if (!RegIsRestricted(hsubkey))
				{
					// Get the type of items under this root
					cb = ARRAYSIZE( szTemp );
					if ( ERROR_SUCCESS ==
						 SHQueryValueEx( hsubkey, c_szType, NULL, NULL, szTemp, &cb ))
					{
						HTREEITEM htviroot;
						int 	iImage = -1;
						BOOL	bChecked = FALSE;
						DWORD	dwError = ERROR_SUCCESS;

						// get the type of node
						DWORD dwTreeType = RegTreeType( szTemp );
						
						// get some more info about the this item
						switch (dwTreeType)
						{
							case TREE_GROUP:
								iImage = DefaultIconImage(hsubkey, IDUNKNOWN);
								hkeySave = hsubkey;
								break;
						
							case TREE_CHECKBOX:
								dwError = GetCheckStatus(hsubkey, &bChecked, FALSE);
								if (dwError == ERROR_SUCCESS)
								{
									iImage = bChecked ? IDCHECKED : IDUNCHECKED;
									hkeySave = hsubkey;
								}
								break;

							case TREE_RADIO:
								dwError = GetCheckStatus(hsubkey, &bChecked, FALSE);
								if (dwError == ERROR_SUCCESS)
								{
									iImage = bChecked ? IDRADIOON : IDRADIOOFF;
									hkeySave = hsubkey;
								}
								break;

							default:
								dwError = ERROR_INVALID_PARAMETER;
						}

						if (dwError == ERROR_SUCCESS)
						{
							BOOL bItemExisted = FALSE;
							int cch;
							LPTSTR pszText;
							HRESULT hr = S_OK;

							cch = ARRAYSIZE(szTemp);

							// try to get the plugUI enabled text
							// otherwise we want the old data from a
							// different value

							hr = SHLoadRegUIString(hsubkey, c_szPlugUIText, szTemp, cch);
							if (SUCCEEDED(hr) && szTemp[0] != TEXT('@'))
							{
								pszText = szTemp;
							}
							else 
							{
								// try to get the old non-plugUI enabled text
								hr = SHLoadRegUIString(hsubkey, c_szText, szTemp, cch);
								if (SUCCEEDED(hr))
								{
									pszText = szTemp;
								}
								else
								{
									// if all else fails, the key name itself
									// is a little more useful than garbage

									pszText = szKeyName;
									cch = ARRAYSIZE(szKeyName);
								}
							}

							//See if we need to add status text
							if (bScreenReaderEnabled && (dwTreeType != TREE_GROUP))
							{
								AppendStatus(pszText, cch, bChecked);
							}

							// add root node
							htviroot = Tree_AddItem(htviparent, pszText, htvins, iImage, m_hwndTree, hkeySave, &bItemExisted);

							if (bItemExisted)
								hkeySave = NULL;

							if (dwTreeType == TREE_GROUP)
							{
								CHAR szKeyNameTemp[MAX_KEY_NAME];

								SHTCharToAnsi(szKeyName, szKeyNameTemp, ARRAYSIZE(szKeyNameTemp));
								RegEnumTree(hkey, szKeyNameTemp, htviroot, TVI_FIRST);
							
								TreeView_Expand(m_hwndTree, htviroot, TVE_EXPAND);
							}
						} // if (dwError == ERROR_SUCCESS
					}
				}	// if (!RegIsRestricted(hsubkey))

				if (hkeySave != hsubkey)
					RegCloseKey(hsubkey);
			}
		}

		// Sort all keys under htviparent
		SendMessage(m_hwndTree, TVM_SORTCHILDREN, 0, (LPARAM)htviparent);

		RegCloseKey( hkey );
		return TRUE;
	}

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT CRegTreeOptions::InitTree(HWND hwndTree, HKEY hkeyRoot, LPCSTR pszRegKey,
								  LPSECURITYPAGE pSec)
{
	HRESULT hr = S_OK;
	__try
	{
		g_fRunningOnNT = IsOS(OS_NT);

		if (g_fRunningOnNT)
		{
			g_bRunOnNT5 = IsOS(OS_NT5);
			g_fRunOnWhistler = IsOS(OS_WHISTLERORGREATER);
		}
		else
			g_bRunOnMemphis = IsOS(OS_WIN98);

		g_fRunOnFE = GetSystemMetrics(SM_DBCSENABLED);

		m_hwndTree = hwndTree;
		m_hIml = ImageList_Create( BITMAP_WIDTH, BITMAP_HEIGHT,
									ILC_COLOR | ILC_MASK, NUM_BITMAPS, 4 );

		// Initialize the tree view window.
		LONG_PTR flags = GetWindowLongPtr(hwndTree, GWL_STYLE);
		SetWindowLongPtr(hwndTree, GWL_STYLE, flags & ~TVS_CHECKBOXES);

		HBITMAP hBmp = CreateMappedBitmap(g_hInstance, IDB_BUTTONS, 0, NULL, 0);
		ImageList_AddMasked( m_hIml, hBmp, CLR_DEFAULT);
		DeleteObject( hBmp );

		// Associate the image list with the tree.
		HIMAGELIST himl = TreeView_SetImageList( hwndTree, m_hIml, TVSIL_NORMAL );
		if (himl)
			ImageList_Destroy(himl);

		// Let accessibility know about our state images
		// TODO: what do we do with this?
	//	  SetProp(hwndTree, TEXT("MSAAStateImageMapCount"), LongToPtr(ARRAYSIZE(c_rgimeTree)));
	//	  SetProp(hwndTree, TEXT("MSAAStateImageMapAddr"), (HANDLE)c_rgimeTree);

		//
		// RSoP portion
		//

		// get the RSOP_IEProgramSettings object and its properties
		ComPtr<IWbemServices> pWbemServices = pSec->pDRD->GetWbemServices();
		_bstr_t bstrObjPath = pSec->pszs->wszObjPath;
		ComPtr<IWbemClassObject> pSZObj = NULL;
		HRESULT hr = pWbemServices->GetObject(bstrObjPath, 0L, NULL, (IWbemClassObject**)&pSZObj, NULL);
		if (SUCCEEDED(hr))
		{
			// actionValues field
			_variant_t vtValue;
			hr = pSZObj->Get(L"actionValues", 0, &vtValue, NULL, NULL);
			if (SUCCEEDED(hr) && !IsVariantNull(vtValue))
			{
				SAFEARRAY *psa = vtValue.parray;


				LONG lLBound, lUBound;
				hr = SafeArrayGetLBound(psa, 1, &lLBound);
				hr = SafeArrayGetUBound(psa, 1, &lUBound);
				if (SUCCEEDED(hr))
				{
					LONG cElements = lUBound - lLBound + 1;
					BSTR HUGEP *pbstr = NULL;
					hr = SafeArrayAccessData(psa, (void HUGEP**)&pbstr);
					if (SUCCEEDED(hr))
					{
						long nASCount = 0;
						for (long nVal = 0; nVal < cElements; nVal++)
						{
							LPCTSTR szAction = (LPCTSTR)pbstr[nVal];
							LPTSTR szColon = StrChr(szAction, _T(':'));
							if (NULL != szColon)
							{
								StrCpyN(m_as[nASCount].szName, szAction, (int)((szColon - szAction) + 1));
								szColon++;
								m_as[nASCount].dwValue = StrToInt(szColon);
								nASCount++;
							}
						}
						m_nASCount = nASCount;

						// now sort the list by precedence
						if (m_nASCount > 0)
							qsort(&m_as, m_nASCount, sizeof(m_as[0]), CompareActionSettingStrings);
					}

					SafeArrayUnaccessData(psa);
				}
			}
		}

		RegEnumTree(hkeyRoot, pszRegKey, NULL, TVI_ROOT);
	}
	__except(TRUE)
	{
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////
void ShowCustom(LPCUSTOMSETTINGSINFO pcsi, HTREEITEM hti)
{
    TV_ITEM        tvi;
    tvi.hItem = hti;
    tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_IMAGE;

    TreeView_GetItem( pcsi->hwndTree, &tvi );

        // If it's not selected don't bother.
    if (tvi.iImage != IDRADIOON)
        return;

    TCHAR szValName[64];
    DWORD cb = sizeof(szValName);
    DWORD dwChecked;

    if (RegQueryValueEx((HKEY)tvi.lParam,
                        TEXT("ValueName"),
                        NULL,
                        NULL,
                        (LPBYTE)szValName,
                        &cb) == ERROR_SUCCESS)
    {
        if (!(StrCmp(szValName, TEXT("1C00"))))
        {
            cb = sizeof(dwChecked);
            if (RegQueryValueEx((HKEY)tvi.lParam,
                                TEXT("CheckedValue"),
                                NULL,
                                NULL,
                                (LPBYTE)&dwChecked,
                                &cb) == ERROR_SUCCESS)
            {
#ifndef UNIX
                HWND hCtl = GetDlgItem(pcsi->hDlg, IDC_JAVACUSTOM);
                ShowWindow(hCtl,
                           (dwChecked == URLPOLICY_JAVA_CUSTOM) && (tvi.iImage == IDRADIOON) ? SW_SHOWNA : SW_HIDE);
                EnableWindow(hCtl, dwChecked==URLPOLICY_JAVA_CUSTOM ? TRUE : FALSE);
                pcsi->dwJavaPolicy = dwChecked;
#endif
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////
void _FindCustomRecursive(LPCUSTOMSETTINGSINFO pcsi, HTREEITEM htvi)
{
	HTREEITEM hctvi;	// child
	
	// step through the children
	hctvi = TreeView_GetChild( pcsi->hwndTree, htvi );
	while ( hctvi )
	{
		_FindCustomRecursive(pcsi,hctvi);
		hctvi = TreeView_GetNextSibling( pcsi->hwndTree, hctvi );
	}

	//TODO: Display custom java settings button later
//	ShowCustom(pcsi, htvi);
}

/////////////////////////////////////////////////////////////////////
void _FindCustom(LPCUSTOMSETTINGSINFO pcsi)
{
	HTREEITEM hti = TreeView_GetRoot( pcsi->hwndTree );
	
	// and walk the list of other roots
	while (hti)
	{
		// recurse through its children
		_FindCustomRecursive(pcsi, hti);

		// get the next root
		hti = TreeView_GetNextSibling(pcsi->hwndTree, hti );
	}
}

/////////////////////////////////////////////////////////////////////
BOOL SecurityCustomSettingsInitDialog(HWND hDlg, LPARAM lParam)
{
	LPCUSTOMSETTINGSINFO pcsi = (LPCUSTOMSETTINGSINFO)LocalAlloc(LPTR, sizeof(*pcsi));
	HRESULT hr = S_OK;
	
	if (!pcsi)
	{
		EndDialog(hDlg, IDCANCEL);
		return FALSE;
	}

	// tell dialog where to get info
	SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pcsi);

	// save the handle to the page
	pcsi->hDlg = hDlg;
	pcsi->pSec = (LPSECURITYPAGE)lParam;


	// save dialog handle
	pcsi->hwndTree = GetDlgItem(pcsi->hDlg, IDC_TREE_SECURITY_SETTINGS);

	pcsi->pTO = new CRegTreeOptions;

	DWORD cb = sizeof(pcsi->fUseHKLM);
	SHGetValue(HKEY_LOCAL_MACHINE,
			   REGSTR_PATH_SECURITY_LOCKOUT,
			   REGSTR_VAL_HKLM_ONLY,
			   NULL,
			   &(pcsi->fUseHKLM),
			   &cb);

	// if this fails, we'll just use the default of fUseHKLM == 0
	if (SUCCEEDED(hr))
	{
		pcsi->pTO->InitTree(pcsi->hwndTree, HKEY_LOCAL_MACHINE, pcsi->fUseHKLM ?
							"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SOIEAK" :
							"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SO",
							pcsi->pSec);
	}
	
	// find the first root and make sure that it is visible
	TreeView_EnsureVisible( pcsi->hwndTree, TreeView_GetRoot( pcsi->hwndTree ) );

	pcsi->hwndCombo = GetDlgItem(hDlg, IDC_COMBO_RESETLEVEL);
	
	SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[3]);
	SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[2]);
	SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[1]);
	SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[0]);
	
	switch (pcsi->pSec->pszs->dwRecSecLevel)
	{
		case URLTEMPLATE_LOW:
			pcsi->iLevelSel = 3;
			break;
		case URLTEMPLATE_MEDLOW:
			pcsi->iLevelSel = 2;
			break;
		case URLTEMPLATE_MEDIUM:
			pcsi->iLevelSel = 1;
			break;
		case URLTEMPLATE_HIGH:
			pcsi->iLevelSel = 0;
			break;
		default:
			pcsi->iLevelSel = 0;
			break;
	}

	_FindCustom(pcsi);

	SendMessage(pcsi->hwndCombo, CB_SETCURSEL, (WPARAM)pcsi->iLevelSel, (LPARAM)0);

	EnableDlgItem2(hDlg, IDC_COMBO_RESETLEVEL, FALSE);
	EnableDlgItem2(hDlg, IDC_BUTTON_APPLY, FALSE);

	pcsi->fChanged = FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////
int RegWriteWarning(HWND hParent)
{
    // load "Warning!"
    TCHAR szWarning[64];
    LoadString(g_hInstance, IDS_WARNING, szWarning, ARRAYSIZE(szWarning));

    // Load "You are about to write..."
    TCHAR szWriteWarning[128];
    LoadString(g_hInstance, IDS_WRITE_WARNING, szWriteWarning, ARRAYSIZE(szWriteWarning));

    return MessageBox(hParent, szWriteWarning, szWarning, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2);
}

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK SecurityCustomSettingsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
	LPCUSTOMSETTINGSINFO pcsi;

	if (uMsg == WM_INITDIALOG)
	{
		BOOL fRet = SecurityCustomSettingsInitDialog(hDlg, lParam);

//		EnableDlgItem2(hDlg, IDC_TREE_SECURITY_SETTINGS, FALSE);

		return fRet;
	}
	else
		pcsi = (LPCUSTOMSETTINGSINFO)GetWindowLongPtr(hDlg, DWLP_USER);
	
	if (!pcsi)
		return FALSE;
				
	switch (uMsg) {

		case WM_NOTIFY:
		{
			LPNMHDR psn = (LPNMHDR)lParam;
			switch( psn->code )
			{
				case TVN_KEYDOWN:
					break;
			
				case NM_CLICK:
				case NM_DBLCLK:
					break;
			}
		}
		break;
		
		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case IDOK:
					EndDialog(hDlg, IDOK);
					break;

				case IDCANCEL:
					EndDialog(hDlg, IDCANCEL);
					break;

				case IDC_COMBO_RESETLEVEL:
					switch (HIWORD(wParam))
					{
						case CBN_SELCHANGE:
						{
							// Sundown: coercion to integer since cursor selection is 32b
							int iNewSelection = (int) SendMessage(pcsi->hwndCombo, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

							if (iNewSelection != pcsi->iLevelSel)
							{
								pcsi->iLevelSel = iNewSelection;
								EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_APPLY),TRUE);
							}
							break;
						}
					}
					break;

				case IDC_JAVACUSTOM:
//TODO: uncomment					ShowJavaZonePermissionsDialog(hDlg, pcsi);
					break;
					
				case IDC_BUTTON_APPLY:
					break;
					
				default:
					return FALSE;
			}
			return TRUE;				
			break;

		case WM_HELP:			// F1
		{
			//TODO: implement
/*			LPHELPINFO lphelpinfo;
			lphelpinfo = (LPHELPINFO)lParam;

			TV_HITTESTINFO ht;
			HTREEITEM hItem;

			// If this help is invoked through the F1 key.
			if (GetAsyncKeyState(VK_F1) < 0)
			{
				// Yes we need to give help for the currently selected item.
				hItem = TreeView_GetSelection(pcsi->hwndTree);
			}
			else
			{
				// Else we need to give help for the item at current cursor position
				ht.pt =((LPHELPINFO)lParam)->MousePos;
				ScreenToClient(pcsi->hwndTree, &ht.pt); // Translate it to our window
				hItem = TreeView_HitTest(pcsi->hwndTree, &ht);
			}


			if (FAILED(pcsi->pTO->ShowHelp(hItem , HELP_WM_HELP)))
			{
				ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
							HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
			}
*/			break; 

		}
		case WM_CONTEXTMENU:		// right mouse click
		{
			//TODO: implement
/*			TV_HITTESTINFO ht;

			GetCursorPos( &ht.pt ); 						// get where we were hit
			ScreenToClient( pcsi->hwndTree, &ht.pt );		// translate it to our window

			// retrieve the item hit
			if (FAILED(pcsi->pTO->ShowHelp(TreeView_HitTest( pcsi->hwndTree, &ht),HELP_CONTEXTMENU)))
			{			
				ResWinHelp( (HWND) wParam, IDS_HELPFILE,
							HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
			}
*/			break; 
		}
		case WM_DESTROY:
			if (pcsi)
			{
				if (pcsi->pTO)
				{
					pcsi->pTO->WalkTree( WALK_TREE_DELETE );
					delete pcsi->pTO;
					pcsi->pTO = NULL;
				}
				LocalFree(pcsi);
				SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
			}
			break;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakui\common.h ===
#define IDC_STATIC      -1

#define IDC_TITLE       10001
#define IDE_TITLE       10002
#define IDE_TOOLBARBMP  10003
#define IDC_BROWSETBB   10004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakui\ieakui.h ===
#include "common.h"
#include "resource.h"
#include "wizard.h"
#include "insdll.h"
#include "insexe.h"
#include "ieaksier.h"
#include "legacy.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakui\ieaksier.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ieaksie.rc
//
#define IDS_ADM                         50001
#define IDS_BTITLE_DESC                 50501
#define IDS_ANIMATION_DESC              50502
#define IDS_CUSTICON_DESC               50503
#define IDS_BTOOLBAR_DESC               50504
#define IDS_CONNECTSET_DESC             50505
#define IDS_QUERYAUTOCONFIG_DESC        50506
#define IDS_PROXY_DESC                  50507
#define IDS_UASTRDLG_DESC               50508
#define IDS_FAVORITES_DESC              50509
#define IDS_STARTSEARCH_DESC            50510
#define IDS_CHANNELS_DESC               50511
#define IDS_PROGRAMS_DESC               50512
#define IDS_SECURITY_DESC               50513
#define IDS_AUTHCODE_DESC               50514
#define IDS_ADM_DESC                    50515

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakui\insdll.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by insdll.rc
//
#define IDS_TITLE2                      40001
#define IDS_BTITLE                      40101
#define IDS_ANIMATION2                  40102
#define IDS_CUSTICON2                   40103
#define IDS_STARTSEARCH2                40104
#define IDS_ONLINESUPPORT               40105
#define IDS_FAVORITES2                  40106
#define IDS_CHANNELS2                   40107
#define IDS_SOFTWAREUPDATES             40108
#define IDS_DESKTOP2                    40109
#define IDS_DWALLPAPER                  40110
#define IDS_UASTRDLG2                   40111
#define IDS_PROXY2                      40112
#define IDS_MAIL2                       40113
#define IDS_LDAP2                       40114
#define IDS_SIG2                        40115
#define IDS_CABSIGN                     40116
#define IDS_BTOOLBAR                    40117
#define IDS_IMAP2                       40118
#define IDS_PRECONFIG2                  40119
#define IDS_OEVIEW2                     40120
#define IDS_OE2                         40121
#define IDS_PROGRAMS                    40122
#define IDS_STARTSEARCH_PREF            40123
#define IDS_FAVORITES_PREF              40124
#define IDS_CHANNELS_PREF               40125
#define IDS_PROXY_PREF                  40126
#define IDS_BTOOLBAR_PREF               40127
#define IDS_PROGRAMS_PREF               40128
#define IDS_CHANNELS_FOLDER             40201
#define IDS_SOFTWAREUPDATES_FOLDER      40202
#define IDS_QUICK_LAUNCH                40203
#define IDS_WALLPAPER_ERROR             40401
#define IDS_ADMPARSEDLLPROCERROR        40402
#define IDS_NOPOLICYFILE                40403
#define IDS_POLICYBRANCHTEXT            40404
#define IDS_MEMORY_ERROR                40405
#define IDS_FILE_ERROR                  40406
#define IDS_POLICYBRANCHTITLE           40407
#define IDS_CONNECTSET_WARN             40408

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        3001
#define _APS_NEXT_COMMAND_VALUE         40601
#define _APS_NEXT_CONTROL_VALUE         20001
#define _APS_NEXT_SYMED_VALUE           3001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakui\insexe.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by insexe.rc
//
#define IDD_SAVEAS                      3000
#define IDD_DISPLAYSAVE                 3001
#define IDC_INSBROWSE                   50010
#define IDC_CABVERSION                  50011
#define IDC_SAVEASOK                    50012
#define IDC_SAVEASCANCEL                50013
#define IDE_CABSURL                     50014
#define IDE_INSFILE                     50015
#define IDE_CAB1NAME                    50016
#define IDE_CAB2NAME                    50017
//#define IDE_CAB3NAME                    50018
#define IDC_ANIMATE                     50019
#define IDC_CAB1TEXT                    50020
#define IDC_CAB2TEXT                    50021
//#define IDC_CAB3TEXT                    50022
#define IDC_CABSURLTEXT                 50023
#define IDC_ADVANCEDSIGN                50024
#define IDS_CANTCREATEFILE              50100
#define IDS_MUSTSPECIFYNAME             50101
#define IDS_MUSTSPECIFYURL              50102
#define IDS_MUSTSPECIFYINS              50103
#define IDS_ERROR_MULTPROFMGR           50104
#define IDS_PROFMGR_DEMOMODE            50106
#define IDS_REQUIRE_CORPMODE            50107
#define IDS_FILE_ALREADY_EXISTS         50108
#define IDS_FILE_READONLY               50109

// note this ID must stay matched with the one in resource.h
// have to duplicate because profmgr.exe does not include resource.h

#define IDA_GEARS                       404

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        4001
#define _APS_NEXT_COMMAND_VALUE         50601
#define _APS_NEXT_CONTROL_VALUE         20001
#define _APS_NEXT_SYMED_VALUE           4001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ieakui.rc
//
#define IDB_CHANN                       401
#define IDB_LARGEFLAG                   402
#define IDB_SMALLFLAG                   403
#define IDA_GEARS                       404
#define IDD_BTITLE                      1001
#define IDD_CUSTICON                    1003
#define IDD_STARTSEARCH                 1004
#define IDD_FAVORITES                   1006
#define IDD_CATEGORYPOPUP               1010
#define IDD_UASTRDLG                    1014
#define IDD_QUERYAUTOCONFIG             1015
#define IDD_SECURITYCERT                1016
#define IDD_PROXY                       1017
#define IDD_CONNECTSET                  1018
#define IDD_SECURITY1                   1019
#define IDD_CABSIGN                     1020
#define IDD_BTOOLBARS                   1022
#define IDD_BTOOLBARPOPUP               1023
#define IDD_FAVPOPUP                    1024
#define IDD_SECURITYAUTH                1025
#define IDD_PROGRAMS                    1027
#define IDD_MAIL                        1033
#define IDD_LDAP                        1034
#define IDD_OE                          1035
#define IDD_SIG                         1036
#define IDD_IMAP                        1037
#define IDD_PRECONFIG                   1038
#define IDD_OEVIEW                      1039
#define IDE_SMALLANIMBITMAP             10011
#define IDC_BROWSESMALL                 10012
#define IDE_BIGANIMBITMAP               10013
#define IDC_BROWSEBIG                   10014
#define IDC_BITMAP2                     10021
#define IDC_BROWSEICON2                 10022
#define IDC_BITMAP                      10023
#define IDC_BROWSEICON                  10024
#define IDC_BITMAPCHECK                 10027
#define IDC_SMALLBITMAP_TXT             10028
#define IDC_LARGEBITMAP_TXT             10029
#define IDE_STARTPAGE                   10031
#define IDC_STARTPAGE                   10032
#define IDE_SEARCHPAGE                  10033
#define IDC_SEARCHPAGE                  10034
#define IDC_CUSTOMSUPPORT               10035
#define IDE_CUSTOMSUPPORT               10036
#define IDC_STARTPAGE_TXT               10037
#define IDC_SEARCHPAGE_TXT              10038
#define IDC_CUSTOMSUPPORT_TXT           10039
#define IDC_TREE1                       10040
#define IDE_FAVURL                      10041
#define IDC_FAVICON                     10042
#define IDE_FAVICON                     10043
#define IDC_FAVICONBROWSE               10044
#define IDC_FAVICON2                    10044
#define IDC_AVAILOFFLINE                10045
#define IDC_MODIFY                      10051
#define IDC_DELFAVORITES                10052
#define IDC_FAVONTOP                    10053
#define IDE_FAVNAME                     10054
#define IDC_FAVURL                      10055
#define IDC_ADDFOLDER                   10056
#define IDC_ADDURL                      10057
#define IDC_TESTFAVURL                  10058
#define IDC_REMOVE                      10059
#define IDC_IMPORT                      10060
#define IDC_FAVUP                       10061
#define IDC_FAVDOWN                     10062
#define IDC_DELIEAKFAVORITES            10063
#define IDE_CSSPC                       10071
#define IDE_CSPVK                       10072
#define IDE_CSDESC                      10073
#define IDE_CSURL                       10074
#define IDC_BROWSECSSPC                 10075
#define IDC_BROWSECSPVK                 10076
#define IDC_CSCOMP                      10077
#define IDC_CSCOMP_TXT                  10078
#define IDC_CSADD                       10079
#define IDE_CSTIME                      10080
#define IDC_DELETECHANNELS              10099
#define IDC_CHANNELBITMAP2              10105
#define IDC_BROWSECHBMP2                10106
#define IDC_CHANNELICON2                10107
#define IDC_BROWSECHICO2                10108
#define IDC_ANIMBITMAP                  10110
#define IDE_CATEGORYTITLE               10111
#define IDC_SMALLANIMBITMAP_TXT         10112
#define IDC_CATEGORYHTML                10113
#define IDC_BIGANIMBITMAP_TXT           10114
#define IDC_BROWSECATHTML               10115
#define IDC_TITLE_TXT                   10118
#define IDC_MODIFYADT                   10121
#define IDC_NOADT                       10122
#define IDC_IMPORTADT                   10123
#define IDC_TEXT1                       10124
#define IDC_TEXT3                       10126
#define IDC_DWPATH                      10127
#define IDC_BROWSEDW                    10128
#define IDC_DTNOIMPORT                  10131
#define IDC_DTIMPORT                    10132
#define IDC_MCPATH                      10141
#define IDC_BROWSEMC                    10142
#define IDC_CPPATH                      10143
#define IDC_BROWSECP                    10144
#define IDC_UASTRING                    10151
#define IDC_UASTRINGCHECK               10152
#define IDC_UASTRING_TXT                10153
#define IDC_AUTODETECT                  10161
#define IDC_YESAUTOCON                  10162
#define IDE_AUTOCONFIGURL               10163
#define IDE_AUTOPROXYURL                10164
#define IDC_AUTOCONFIGTEXT1             10165
#define IDC_AUTOCONFIGTEXT2             10166
#define IDE_AUTOCONFIGTIME              10167
#define IDC_AUTOCONFIGTEXT3             10168
#define IDC_AUTOCONFIGURL_TXT           10169
#define IDC_AUTOPROXYURL_TXT            10170
#define IDC_WIN32SECTEXT                10171
#define IDC_SCGB                        10173
#define IDC_NOSC                        10174
#define IDC_IMPORTSC                    10175
#define IDC_MODIFYSC                    10176
#define IDC_AUTHGB                      10178
#define IDC_NOAUTH                      10179
#define IDC_IMPORTAUTH                  10180
#define IDC_MODIFYAUTH                  10181
#define IDC_TPL                         10182
#define IDC_TPL_TEXT                    10183
#define IDC_YESPROXY                    10191
#define IDC_HTTPPROXY1                  10192
#define IDE_HTTPPROXY                   10193
#define IDE_HTTPPORT                    10194
#define IDC_SECPROXY1                   10195
#define IDE_SECPROXY                    10196
#define IDE_SECPORT                     10197
#define IDC_FTPPROXY1                   10198
#define IDE_FTPPROXY                    10199
#define IDE_FTPPORT                     10200
#define IDC_GOPHERPROXY1                10201
#define IDE_GOPHERPROXY                 10202
#define IDE_GOPHERPORT                  10203
#define IDC_SOCKSPROXY1                 10204
#define IDE_SOCKSPROXY                  10205
#define IDE_SOCKSPORT                   10206
#define IDC_SAMEFORALL                  10207
#define IDC_DISPROXYADR1                10208
#define IDE_DISPROXYADR                 10209
#define IDC_DISPROXYLOCAL               10210
#define IDC_SZGB                        10221
#define IDC_NOZONES                     10222
#define IDC_IMPORTZONES                 10223
#define IDC_MODIFYZONES                 10224
#define IDC_RATINGSTEXT                 10225
#define IDC_CRGB                        10226
#define IDC_NORAT                       10227
#define IDC_IMPORTRAT                   10228
#define IDC_MODIFYRAT                   10229
#define IDC_BTOOLBARLIST                10300
#define IDC_ADDBTOOLBAR                 10301
#define IDC_REMOVEBTOOLBAR              10302
#define IDC_EDITBTOOLBAR                10303
#define IDE_BTCAPTION                   10304
#define IDE_BTACTION                    10306
#define IDC_BROWSEBTACTION              10307
#define IDE_BTICON                      10308
#define IDC_BROWSEBTICO                 10309
#define IDE_BTHOTICON                   10310
#define IDC_BROWSEBTHOTICO              10311
#define IDC_DELETEBTOOLBARS             10312
#define IDC_BUTTONSTATE                 10313
#define IDC_POPIMAP                     10441
#define IDE_MAILSERVER                  10442
#define IDE_SMTPSERVER                  10443
#define IDE_NEWSERVER                   10444
#define IDC_USESPAMAIL                  10447
#define IDC_USESPASMTP                  10448
#define IDC_USESPANNTP                  10449
#define IDC_ACCTRO                      10450
#define IDC_ACCTNOCONFIG                10452
#define IDC_ACCOUNT_STATIC              10453
#define IDC_FRIENDLYNAME                10461
#define IDE_FRIENDLYNAME                10462
#define IDC_DIRSERVICE                  10463
#define IDE_DIRSERVICE                  10464
#define IDC_LDAPHOMEPAGE                10465
#define IDE_LDAPHOMEPAGE                10466
#define IDC_SEARCHBASE                  10467
#define IDE_SEARCHBASE                  10468
#define IDE_LDAPBITMAP                  10469
#define IDC_BROWSELDAP                  10470
#define IDC_CHECKNAMES                  10471
#define IDC_SPA                         10472
#define IDC_TIMEOUTSLD                  10473
#define IDC_TIMEOUT                     10474
#define IDC_SPIN1                       10475
#define IDE_MATCHES                     10476
#define IDC_OEPANEURL                   10481
#define IDC_OEPANELOCAL                 10482
#define IDE_OEPANEURL                   10483
#define IDE_OELOCALPATH                 10484
#define IDC_BROWSEOEHTML                10485
#define IDE_OEIMAGEPATH                 10486
#define IDC_BROWSEOEIMAGE               10487
#define IDE_OEWMPATH                    10488
#define IDC_BROWSEOEWM                  10489
#define IDE_OEWMSENDER                  10490
#define IDE_OEWMREPLYTO                 10491
#define IDC_OELOCALPATH_TXT             10492
#define IDC_OEIMAGEPATH_TXT             10493
#define IDC_MAILSIGTEXT                 10502
#define IDE_MAILSIGTEXT                 10503
#define IDC_NEWSSIGTEXT                 10504
#define IDE_NEWSSIGTEXT                 10505
#define IDC_HTMLMAIL                    10508
#define IDC_HTMLNEWS                    10509
#define IDC_HTML_STATIC                 10510
#define IDE_ROOTPATH                    10521
#define IDC_STORESPECIAL                10522
#define IDE_SENTPATH                    10523
#define IDE_DRAFTSPATH                  10524
#define IDC_CHECKNEW                    10527
#define IDC_SENTPATH_TXT                10528
#define IDC_DRAFTSPATH_TXT              10529
#define IDE_NGROUPS                     10540
#define IDE_SERVICENAME                 10541
#define IDE_SERVICEURL                  10542
#define IDC_DEFMAIL                     10545
#define IDC_DEFNEWS                     10546
#define IDC_DELETELINKS                 10547
#define IDC_FOLDERBAR                   10560
#define IDC_FOLDERLIST                  10561
#define IDC_OUTLOOKBAR                  10562
#define IDC_STATUSBAR                   10563
#define IDC_CONTACTS                    10565
#define IDC_TOOLBAR                     10566
#define IDC_TBARTEXT                    10571
#define IDC_PREVIEW                     10572
#define IDC_SPLITHORZ                   10573
#define IDC_SPLITVERT                   10574
#define IDC_PREVIEWHDR                  10575
#define IDC_TIPOFDAY                    10576
#define IDC_CSNOIMPORT                  10601
#define IDC_CSIMPORT                    10602
#define IDC_DELCONNECT                  10603
#define IDC_MODIFYCONNECT               10604
#define IDC_DELCONNECT_TXT              10605
#define IDC_PROGNOIMPORT                10611
#define IDC_PROGIMPORT                  10612
#define IDC_MODIFYPROG                  10613
#define IDC_VISIBLE                     10808
#define IDC_BGIE6                       10833
#define IDC_BG_CUSTOM                   10835
#define IDC_OPTIONTEXT3                 15703
#define IDC_MOVEUP2                     15704
#define IDC_MOVEDOWN2                   15705
#define IDS_AUTOCONFIG_NULL             30000
#define IDS_IEAK                        30001
#define IDS_FOLDERMCCP                  30002
#define IDS_QUERYAUTOCONFIG             30003
#define IDS_SECURITYCERT                30004
#define IDS_SECURITY                    30005
#define IDS_SECURITYAUTH                30007
#define IDS_SECURITY_PREF               30008
#define IDS_SECURITYAUTH_PREF           30009
#define IDS_QUERYAUTOCONFIG_PREF        30010
#define IDS_CONNECTSET                  30014
#define IDS_CONNECTSET_PREF             30015
#define IDS_NEWFOLDER                   30101
#define IDS_FAVFOLDER                   30102
#define IDS_NEWQL                       30103
#define IDS_BROWSEIMPORT                30201
#define IDS_LINKS                       30202
#define IDS_EDIT                        30203
#define IDS_ENDEDIT                     30204
#define IDS_NEW                         30205
#define IDS_BROWSE                      30206
#define IDS_IMAP                        30208
#define IDS_POP3                        30209
#define IDS_XSECONDS                    30211
#define IDS_1MINUTE                     30212
#define IDS_XMINUTES                    30213
#define IDS_TOOBIG22                    30401
#define IDS_TOOSMALL22                  30402
#define IDS_TOOBIG38                    30403
#define IDS_TOOSMALL38                  30404
#define IDS_TOOMANYCOLORS               30405
#define IDS_BOTHBMP_ERROR               30406
#define IDS_BADFAVURL                   30411
#define IDS_BADFAVNAME                  30412
#define IDS_INVALIDBITMAP               30414
#define IDS_IE                          30425
#define IDS_IELNK                       30426
#define IDS_CABSIGN_ERROR               30430
#define IDS_TITLE_PREFIX                30431
#define IDS_ERROR_MAXFAVS               30432
#define IDS_ERROR_MAXQLS                30433
#define IDS_FAVS_TOOLTIPFORMAT          30434
#define IDS_FAVS_ABSENT                 30435
#define IDS_FAVS_OFFLINE                30436
#define IDS_FAVS_NOOFFLINE              30437
#define IDS_OETITLE_PREFIX              30438
#define IDS_LANGDIFFERS                 30451
#define IDS_DUPCHAN                     30452
#define IDS_QUERY_CLEARSETTING          30453
#define IDS_UNSUPPORTED_PLATFORM        30454
#define IDS_TB320                       30500
#define IDS_TB256                       30501

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        1054
#define _APS_NEXT_COMMAND_VALUE         30601
#define _APS_NEXT_CONTROL_VALUE         10812
#define _APS_NEXT_SYMED_VALUE           1051
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakui\legacy.h ===
// do not change this ID, comctl depends on it!!!
#define IDC_NEXT               12324
#define IDC_BANNERBMPCTRL      1001
#define IDC_BANNERTXTCTRL      1002

#define IDC_DEFHELP            25095
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakui\wizard.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wizard.rc
//
#define IDA_DOWNLOAD                    201
#define IDB_WIZARD                      501
#define IDB_LEGEND                      502
#define IDB_SELECT                      503
#define IDB_UNSELECT                    504
#define IDB_CHECK                       505
#define IDB_X                           506
#define IDB_LEGEND2                     507
#define IDI_BROWN                       796
#define IDI_BROWN2                      797
#define IDI_BLUE                        798
#define IDI_GREEN                       800
#define IDI_YELLOW                      801
#define IDI_RED                         802
#define IDI_ICON1                       803
#define IDI_ICON2                       804
#define IDI_ICON3                       805
#define IDI_ICON4                       806
#define IDI_ICON5                       807
#define IDI_BLUE2                       899
#define IDC_LINK                        905
#define IDD_WELCOME                     2001
#define IDD_OCWWELCOME                  2002
#define IDD_STAGE1                      2011
#define IDD_KEYINS                      2012
#define IDD_LANGUAGE                    2014
#define IDD_MEDIA                       2015
#define IDD_TARGET                      2016
#define IDD_ADVANCEDPOPUP               2017
#define IDD_IEAKLITE                    2018
#define IDD_WAITIEAKLITE                2019
#define IDD_STAGE2                      2021
#define IDD_OPTDOWNLOAD                 2023
#define IDD_CUSTCOMP4                   2024
#define IDD_CUSTOMCUSTOM                2025
#define IDD_CORPCUSTOM                  2026
#define IDD_COPYCOMP                    2027
#define IDD_STAGE3                      2031
#define IDD_ISKBACKBITMAP               2032
#define IDD_SETUPWIZARD                 2033
#define IDD_SILENTINSTALL               2034
#define IDD_ICM                         2036
#define IDD_COMPSEL4                    2037
#define IDD_COMPURLS                    2038
#define IDD_ADDON                       2039
#define IDD_INSTALLDIR                  2040
#define IDD_STAGE4                      2051
#define IDD_OCWSTAGE2                   2052
#define IDD_WELCOMEMSGS                 2053
#define IDD_QUERYSIGNUP                 2055
#define IDD_SERVERISPS                  2057
#define IDD_SIGNUPINS                   2058
#define IDD_ADDROOT                     2061
#define IDD_STAGE5                      2071
#define IDD_ADM                         2072
#define IDD_OCWFINISH                   2073
#define IDD_FINISH                      2074
#define IDD_ADMDESC                     2075
#define IDD_DOWNLOAD                    2081
#define IDD_ERRORLOG                    2082
#define IDD_STATUS                      2083
#define IDD_WAITSITES                   2084
#define IDD_DOWNLOADERR                 2085
#define IDD_DOWNLOADSEC                 2086
#define IDD_DUPESYNCH                   2088
#define IDD_UPDATE                      2089
#define IDD_CD                          2090
#define IDD_ICW                         2091
#define IDD_SIGNUPFILES                 2092
#define IDD_SIGNUPPOPUP                 2093
#define IDD_OPTUPDATE                   2094
#define IDD_FINDUPDATE                  2095
#define IDC_YESSYNCH                    15000
#define IDC_NOSYNCH                     15001
#define IDC_NOTOALL                     15002
#define IDC_OFFLINE                     15206
#define IDC_LANGUAGE                    15221
#define IDC_BROWSE                      15231
#define IDC_PLATFORMTEXT                15232
#define IDE_TARGETDIR                   15233
#define IDC_CHECKCD                     15234
#define IDC_BROWSE2                     15235
#define IDC_CHECKDL                     15236
#define IDC_CHECKSDB                    15238
#define IDC_LOADINSTEXT2                15240
#define IDE_SOURCEDIR                   15241
#define IDC_CHECKLAN                    15242
#define IDE_LOADINS                     15243
#define IDC_BROWSEINS                   15244
#define IDC_ADVANCED                    15245
#define IDC_IEAKLITE                    15246
#define IDC_IEAKLITEDESC                15247
#define IDC_TARGETTEXT                  15248
#define IDC_TARGETTEXT2                 15249
#define IDC_STAGE2TEXT1                 15301
#define IDC_STAGE2TEXT2                 15302
#define IDC_STAGE2TEXT3                 15303
#define IDC_DOWNLOADLIST                15311
#define IDC_COMPLIST                    15321
#define IDC_DOWNLOAD                    15322
#define IDC_DOWNLOADALL                 15323
#define IDC_DISKSPACENEEDED             15324
#define IDC_DISKSPACE                   15325
#define IDC_DISKSPACETEXT               15326
#define IDC_DISKSPACETEXT2              15327
#define IDC_UPDATE                      15328
#define IDC_TITLE1                      15431
#define IDC_COMPTITLE                   15432
#define IDC_ADDNEWCOMP                  15433
#define IDC_REMOVECOMP                  15434
#define IDC_LOC1                        15435
#define IDE_COMPFILENAME                15436
#define IDC_BROWSEFILE                  15437
#define IDC_LOC4                        15438
#define IDE_COMPCOMMAND                 15439
#define IDC_VERIFY                      15440
#define IDC_LOC3                        15441
#define IDE_COMPGUID                    15442
#define IDC_PARAM1                      15444
#define IDE_COMPPARAM                   15445
#define IDC_SIZE2                       15446
#define IDE_COMPVERSION                 15447
#define IDC_INSTALLSUCCESS              15448
#define IDE_COMPDESC                    15449
#define IDC_PARAM2                      15450
#define IDE_UNINSTALLKEY                15451
#define IDC_COMPDESC                    15452
#define IDC_POSTINSTALL                 15453
#define IDC_PREINSTALL                  15454
#define IDC_REBOOTINSTALL               15455
#define IDC_STAGE3TEXT1                 15601
#define IDC_STAGE3TEXT2                 15603
#define IDC_STAGE3TEXT3                 15605
#define IDC_STAGE3TEXT4                 15606
#define IDC_STAGE3TEXT6                 15608
#define IDE_ISKTITLEBAR                 15621
#define IDE_ISKBACKBITMAP               15622
#define IDC_ISKBROWSE                   15623
#define IDC_ISKNORMAL1                  15624
#define IDC_ISKNORMAL                   15625
#define IDC_ISKHIGHLIGHT1               15626
#define IDC_ISKHIGHLIGHT                15627
#define IDC_RADIO2                      15628
#define IDC_COOLBUTTON                  15629
#define IDC_ISKCUST3D                   15630
#define IDE_ISKBUTTON                   15631
#define IDC_ISKBROWSE2                  15632
#define IDE_WIZBITMAPPATH               15633
#define IDC_BROWSEWIZPATH               15634
#define IDC_CCTITLE                     15636
#define IDE_WIZBITMAPPATH2              15637
#define IDC_BROWSEWIZPATH2              15638
#define IDC_SILENTNOT                   15650
#define IDC_SILENTALL                   15651
#define IDC_SILENTSOME                  15652
#define IDC_URD                         15653
#define IDC_URD_GROUP                   15654
#define IDC_URD_TEXT1                   15655
#define IDC_URD_TEXT2                   15656
#define IDC_URD_TEXT3                   15657
#define IDC_ICMPROCHECK                 15681
#define IDE_ICMPRO                      15682
#define IDC_BROWSEICMPRO                15683
#define IDC_STARTCMAK                   15684
#define IDC_CMAKICON                    15685
#define IDC_OPTLISTOCW                  15690
#define IDC_OPTIONTEXT1                 15691
#define IDC_OPTLIST                     15692
#define IDC_NEWOPT                      15693
#define IDC_DELOPT                      15694
#define IDC_OPTIONTEXT2                 15695
#define IDC_OPTDESC                     15696
#define IDC_LISTAVAIL                   15697
#define IDC_LISTINSTALL                 15698
#define IDC_ADDCOMP                     15699
#define IDC_ADDALLCOMP                  15700
#define IDC_REMCOMP                     15701
#define IDC_REMALLCOMP                  15702
#define IDC_OPTIONTEXT3                 15703
#define IDC_RESETCOMPS                  15704
#define IDC_HIDECHECKALL                15705
#define IDC_HIDEUNCHECKALL              15706
#define IDC_HIDECOMP                    15707
#define IDC_IECOMPAT                    15708
#define IDC_NOBACKUPDATA                15709
#define IDE_DOWNSITENAME                15711
#define IDC_ADDBASEURL                  15712
#define IDC_REMOVEBASEURL               15713
#define IDE_DOWNSITEURL                 15714
#define IDE_DOWNSITEREGION              15715
#define IDC_BASEURLLIST                 15716
#define IDC_NO_ADDON                    15738
#define IDC_DEF_ADDON                   15739
#define IDC_CUST_ADDON                  15740
#define IDC_MENUTEXT                    15741
#define IDE_MENUTEXT                    15742
#define IDC_ADDONURL                    15743
#define IDE_ADDONURL                    15744
#define IDC_MSDL                        15745
#define IDC_INSTALLDIRTEXT1             15751
#define IDE_INSTALLDIR                  15753
#define IDC_BROWSEDIR                   15754
#define IDC_PROGFILES32                 15756
#define IDC_FULLPATH32                  15757
#define IDC_ALLOWINSTALLDIR             15760
#define IDC_INSTALLDIRTEXT3             15761
#define IDC_CUSTCUST                    15762
#define IDC_CUSTCUSTTEXT                15763
#define IDC_WEBDLOPT                    15764
#define IDC_STAGE4TEXT1                 15901
#define IDC_STAGE4TEXT2                 15902
#define IDC_STAGE4TEXT3                 15903
#define IDC_WELCOMEDEF                  15911
#define IDC_WELCOMENO                   15912
#define IDC_WELCOMECUST                 15913
#define IDE_WELCOMEURL                  15914
#define IDC_ISS2                        15930
#define IDC_ISS                         15931
#define IDC_SERVLESS                    15932
#define IDC_NOSIGNUP                    15933
#define IDC_SIGNUPURLTXT                15935
#define IDE_SIGNUPURL                   15936
#define IDC_CONNECTION1                 16111
#define IDE_CONNECTION                  16113
#define IDC_AREACODE1                   16114
#define IDE_AREACODE                    16115
#define IDC_SUPPORTNUM                  16117
#define IDE_PHONENUMBER                 16118
#define IDC_COUNTRYCODE1                16119
#define IDE_COUNTRYCODE                 16120
#define IDE_USERNAME                    16122
#define IDE_COUNTRYID                   16123
#define IDC_CHECKSTATICDNS              16124
#define IDC_PRIMARY                     16125
#define IDE_DNSA                        16126
#define IDE_DNSB                        16127
#define IDE_DNSC                        16128
#define IDE_DNSD                        16129
#define IDC_ALT                         16130
#define IDE_ALTDNSA                     16131
#define IDE_ALTDNSB                     16132
#define IDE_ALTDNSC                     16133
#define IDE_ALTDNSD                     16134
#define IDC_CHECKIPHDRCOMP              16135
#define IDC_CHECKDEFGW                  16136
#define IDC_CHECKPWENCRYPT              16137
#define IDC_CHECKSWCOMP                 16138
#define IDE_PASSWORD                    16139
#define IDC_ENTER                       16140
#define IDE_SUPPORTNUM                  16141
#define IDE_ISPROOTCERT                 16160
#define IDC_BROWSEROOTCERT              16161
#define IDC_ADMTREE                     16301
#define IDC_ADMINSTR                    16302
#define IDC_ADMIMPORT                   16303
#define IDC_ADMDELETE                   16304
#define IDC_ADMWIN32                    16311
#define IDC_ADMWIN2K                    16312
#define IDC_PROGRESS                    16501
#define IDC_DOWNCOMPNAMD                16502
#define IDC_DOWNSTATUS                  16503
#define IDC_ANIM                        16504
#define IDC_LOGTEXT                     16511
#define IDC_STEP1                       16521
#define IDC_STEP3                       16522
#define IDC_FINISHTXT1                  16525
#define IDC_FINISHTXT3                  16527
#define IDC_BADCOMP                     16531
#define IDC_ERRDLABORT                  16532
#define IDC_ERRDLRETRY                  16533
#define IDC_ERRDLIGNORE                 16534
#define IDC_BADCOMPSEC                  16541
#define IDC_SECERRYES                   16542
#define IDC_SECERRNO                    16543
#define IDE_STARTHTM                    16901
#define IDC_BROWSESTARTHTM              16902
#define IDC_ENABLESTARTHTM              16903
#define IDE_MOREINFO                    16904
#define IDC_BROWSEMOREINFO              16905
#define IDC_LITECHECKALL                16906
#define IDC_LITEUNCHECKALL              16907
#define IDC_COPYCOMP                    16908
#define IDC_ICWTITLE                    16911
#define IDE_ICWTITLE                    16912
#define IDE_ICWHEADERBMP                16913
#define IDC_BROWSEICWHEADERBMP          16914
#define IDE_ICWWATERBMP                 16915
#define IDC_BROWSEICWWATERBMP           16916
#define IDC_COPYCHECKALL                16930
#define IDC_COPYUNCHECKALL              16931
#define IDC_SFBMP1                      16932
#define IDC_SFBMP2                      16933
#define IDC_SFBMP3                      16934
#define IDC_SFBMP4                      16935
#define IDC_USERTXT                     17000
#define IDC_PASSWORDTXT                 17001
#define IDC_DESKTOPUPDATE               17002
#define IDC_SFLOC                       17003
#define IDE_SFCOPY                      17005
#define IDC_SFBROWSE                    17006
#define IDC_COPYSF                      17007
#define IDC_SFSTATUS                    17008
#define IDC_SFSTATUS1                   17009
#define IDC_SFSTATUS2                   17010
#define IDC_SFSTATUS3                   17011
#define IDC_SFSTATUS4                   17012
#define IDC_CHECK3                      17013
#define IDC_CHECK4                      17014
#define IDC_SFADVANCED                  17015
#define IDE_BRANDINGCABNAME             17016
#define IDC_BRANDURL                    17017
#define IDE_BRANDINGCABURL              17018
#define IDC_BRANDNAME                   17019
#define IDC_DONTAPPLYINS                17020
#define IDC_DONTMODIFY                  17021
#define IDC_APPLYINS                    17022
#define IDC_DIALASIS                    17500
#define IDC_CONNECTION                  17501
#define IDC_ADDCONNECTION               17502
#define IDC_RMCONNECTION                17503
#define IDC_NEGOTIATETCP                17504
#define IDC_DISABLELCP                  17505
#define IDC_REQLOGON                    17506
#define IDC_ICMPRO_TXT                  17507
#define IDC_CCTITLE_TXT                 17508
#define IDC_DOWNSITENAME_TXT            17509
#define IDC_DOWNSITEURL_TXT             17510
#define IDC_DOWNSITEREGION_TXT          17511
#define IDC_ICWTITLE_TXT                17512
#define IDC_STARTHTM_TXT                17514
#define IDC_XFLAGFALSE                  18000
#define IDC_XFLAGTRUE                   18001
#define IDC_NOXFLAG                     18002
#define IDS_BADKEY                      35002
#define IDS_BADDIR                      35003
#define IDS_BADDIR2                     35004
#define IDS_CANCELOK                    35005
#define IDS_ERR_PATH                    35006
#define IDS_ENDEMO                      35007
#define IDS_TITLE                       35008
#define IDS_ERROREXIT                   35009
#define IDS_BADSIGN                     35010
#define IDS_NEEDPATH                    35011
#define IDS_ERROR_CIFRWFILE             35012
#define IDS_ERROR_INVALIDMODE           35013
#define IDS_DARKCYAN                    35014
#define IDS_DARKYELLOW                  35015
#define IDS_DARKMAGENTA                 35016
#define IDS_DARKBLUE                    35017
#define IDS_DARKGREEN                   35018
#define IDS_DARKRED                     35019
#define IDS_DARKGRAY                    35020
#define IDS_YELLOW                      35021
#define IDS_MAGENTA                     35022
#define IDS_CYAN                        35023
#define IDS_BLUE                        35024
#define IDS_GREEN                       35025
#define IDS_RED                         35026
#define IDS_LIGHTGRAY                   35027
#define IDS_BLACK                       35028
#define IDS_WHITE                       35029
#define IDS_ERROR_IEUPDATECIF           35030
#define IDS_ERROR_UPDATEFOLDER          35031
#define IDS_INTRANET                    35032
#define IDS_REDIST                      35033
#define IDS_BRANDED                     35034
#define IDS_WIZARDTYPETEXT              35035
#define IDS_CORPTYPE                    35036
#define IDS_ICPTYPE                     35037
#define IDS_ISPTYPE                     35038
#define IDS_INSTALLDIR                  35039
#define IDS_SFDIR                       35040
#define IDS_COMPDLDIR                   35041
#define IDS_TARGETDIR                   35042
#define IDS_DISKERROR                   35043
#define IDS_DESTDISKMSG                 35044
#define IDS_TEMPDISKMSG                 35045
#define IDS_MAIL                        35052
#define IDS_DESTDISKMSG2                35062
#define IDS_TEMPDISKMSG2                35063
#define IDS_ROOTILLEGAL                 35068
#define IDS_ENTERISS                    35075
#define IDS_ENTERSLESS                  35076
#define IDS_BADSIGNHTM                  35078
#define IDS_NOCUSTCOMPNAME              35079
#define IDS_INVALID_VERSION             35080
#define IDS_LANGUAGE                    35082
#define IDS_OPTIONS                     35084
#define IDS_BADIPADDR                   35092
#define IDS_NEWCUST                     35094
#define IDS_DOWNLOADURL                 35095
#define IDS_DOWNSITENAME                35097
#define IDS_DOWNSITEURL                 35098
#define IDS_DOWNSITEREGION              35099
#define IDS_DOWNLOADSITE                35100
#define IDS_NORTHAMERICA                35101
#define IDS_DOWNLOADERR                 35106
#define IDS_PLEASESIGNMSG               35108
#define IDS_SIGNEDMSG                   35110
#define IDS_CERTEXPIREDMSG              35112
#define IDS_CERTERRORMSG                35114
#define IDS_BADPROVIDERMSG              35116
#define IDS_NEWINSTALLOPT               35118
#define IDS_CUSTDESK                    35119
#define IDS_CUSTNAME                    35121
#define IDS_CUSTICMPRO                  35134
#define IDS_NEWSNAME                    35145
#define IDS_QUERYPROXY                  35147
#define IDS_BADDEST                     35159
#define IDS_ADMINVALIDEXTN              35171
#define IDS_ADMOVRWWARN                 35172
#define IDS_ADMDELWARN                  35173
#define IDS_ADMPARSEDLLERROR            35175
#define IDS_BLANKSITE                   35177
#define IDS_INVALID_URL                 35178
#define IDS_ERROR_COMMA                 35184
#define IDS_BLANKOPTION                 35185
#define IDS_NO_DUPLICATEKEYS            35187
#define IDS_TOOBIG49x49                 35188
#define IDS_TOOSMALL49x49               35189
#define IDS_TOOBIG164x458               35190
#define IDS_TOOSMALL164x458             35191
#define IDS_BADFILE                     35200
#define IDS_TOOBIG164x312               35201
#define IDS_TOOSMALL164x312             35202
#define IDS_TOOBIG496x56                35203
#define IDS_TOOSMALL496x56              35204
#define IDS_DOWNLOADLIST_ERROR          35205
#define IDS_COMPINITDOWNLOAD            35207
#define IDS_COMPINITPROCESSING          35208
#define IDS_QUICKLAUNCH                 35213
#define IDS_CHANNELSDIR                 35216
#define IDS_ADDISPCHAN_ERRMSG           35221
#define IDS_ADDISPCHAN_ERR              35222
#define IDS_SRCNEEDPATH                 35227
#define IDS_SRCROOTILLEGAL              35228
#define IDS_OCWLANGERROR                35229
#define IDS_DEFAULT_TARGETDIR           35230
#define IDS_CUSTOMCOMPTITLE             35231
#define IDS_CUSTOMCOMPTITLE_ERROR       35232
#define IDS_DEPEND_WARNING              35234
#define IDS_CHANDESC                    35235
#define IDS_BANNERFONT                  35236
#define IDS_BANNERFONTSIZE              35237
#define IDS_BACKUPDLGFONT               35238
#define IDS_BACKUPDLGFONTSIZE           35239
#define IDS_NOIE                        35241
#define IDS_INVALIDCHARINPATH           35242
#define IDS_VIRUSPROGRAMRUNNING         35243
#define IDS_COMPNAME                    35245
#define IDS_VERSION                     35246
#define IDS_LOCALAUTOCONFIGTXT          35247
#define IDS_NOCMAK                      35248
#define IDS_UPDATEERROR                 35252
#define IDS_NEEDAVS                     35253
#define IDS_NEEDAVS2                    35254
#define IDS_SF_ICWHTM_FOUND             35255
#define IDS_SF_ICWHTM_NOTFOUND          35256
#define IDS_SF_SIGNUPHTM_FOUND          35257
#define IDS_SF_SIGNUPHTM_NOTFOUND       35258
#define IDS_SF_ISPFILES                 35259
#define IDS_SF_INSFILES                 35260
#define IDS_ICWHTM_MISSING              35261
#define IDS_SIGNUPHTM_MISSING           35262
#define IDS_SIGNUPISP_MISSING           35263
#define IDS_INSTALLINS_FOUND            35264
#define IDS_NON_ISP_EXTN                35265
#define IDS_NON_INS_EXTN                35266
#define IDS_PATH_DOESNT_EXIST           35267
#define IDS_IL_ACTIVESETUP              35500
#define IDS_IL_ACTIVESETUPDESC          35501
#define IDS_IL_CORPINSTALL              35504
#define IDS_IL_CORPINSTALLDESC          35505
#define IDS_IL_CABSIGN                  35508
#define IDS_IL_CABSIGNDESC              35509
#define IDS_IL_ICM                      35512
#define IDS_IL_ICMDESC                  35513
#define IDS_IL_BROWSER                  35516
#define IDS_IL_BROWSERDESC              35517
#define IDS_IL_URL                      35520
#define IDS_IL_URLDESC                  35521
#define IDS_IL_FAV                      35528
#define IDS_IL_FAVDESC                  35529
#define IDS_IL_UASTR                    35536
#define IDS_IL_UASTRDESC                35537
#define IDS_IL_CONNECT                  35540
#define IDS_IL_CONNECTDESC              35541
#define IDS_IL_SIGNUP                   35548
#define IDS_IL_SIGNUPDESC               35549
#define IDS_IL_CERT                     35552
#define IDS_IL_CERTDESC                 35553
#define IDS_IL_ZONES                    35556
#define IDS_IL_ZONESDESC                35557
#define IDS_CONNECTFILE_ISP             35558
#define IDS_CONNECTFILE_INS             35559
#define IDS_IL_MAILNEWS                 35560
#define IDS_IL_MAILNEWSDESC             35561
#define IDS_IL_ADM                      35564
#define IDS_IL_ADMDESC                  35565
#define IDS_NOMEDIA                     35566
#define IDS_SAMEDIR                     35567
#define IDS_AVSUPDATEINITFAIL           35568
#define IDS_AVSINITFAIL                 35569
#define IDS_SIGNUPBROWSEDESC            35570
#define IDS_TOOBIG540x347               35571
#define IDS_TOOSMALL540x347             35572
#define IDS_ERROR_MULTWIZ               35573
#define IDS_STATUS                      35574
#define IDS_STATUSFORCE                 35575
#define IDS_STATUSNOSHOW                35576
#define IDS_STATUSSHOW                  35577
#define IDS_NEEDSIGNUPISP               35578
#define IDS_CONNECTNAME                 35579
#define IDS_INSTALLINS_SPECIFIED        35580
#define IDS_ISPINFILEHEADER             35581
#define IDS_ERROR_CMAKVER               35582
#define IDS_STAGE1                      35583
#define IDS_STAGE2                      35584
#define IDS_STAGE3                      35585
#define IDS_STAGE4                      35586
#define IDS_STAGE5                      35587
#define IDS_OCWOPTDESC                  35588
#define IDS_ISPINS1_TITLE               35589
#define IDS_ISPINS1_TEXT                35590
#define IDS_ISPINS2_TITLE               35591
#define IDS_ISPINS2_TEXT                35592
#define IDS_AVSNOUPDATES                35593
#define IDS_OLD_CABS                    35594
#define IDS_RELATIVE_ONLY               35598
#define IDS_OPTCAB_ERROR                35599
#define IDS_IL_PROGRAMS                 35600
#define IDS_IL_PROGRAMSDESC             35601
#define IDS_NOUPDATETITLE               35602
#define IDS_ERROR_UPDATESPACE           35604
#define IDS_SIGNUPNAME                  35605
#define IDS_ERROR_CSADDCERT             35606
#define IDS_SUCCESS_CSADDCERT           35607

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        2101
#define _APS_NEXT_COMMAND_VALUE         35701
#define _APS_NEXT_CONTROL_VALUE         17003
#define _APS_NEXT_SYMED_VALUE           2131
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\crtfree.h ===
// Code to help free modules from the bondage and tyranny of CRT libraries
// Include this header in a single component and #define CPP_FUNCTIONS

#ifdef __cplusplus

#ifdef CPP_FUNCTIONS

void* __cdecl operator new(size_t nSize)
{
    LPVOID p;

    p = (LPVOID)CoTaskMemAlloc((ULONG)nSize);
    if (p != NULL)
        ZeroMemory(p, nSize);

    return p;
}

void  __cdecl operator delete(void *pv)
{
    CoTaskMemFree(pv);
}

#endif

#ifdef DEFINE_PURECALL
extern "C" int __cdecl _purecall(void)
{
    return 0;
}
#endif

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif


#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#ifndef _M_PPC
#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#endif

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\debug.h ===
// REVIEW: This file has been "leveraged" off of \nt\private\shell\lib\debug.c and \nt\private\shell\inc\debug.h.
// By no means it's complete but it gives an idea of the right direction. Ideally, we would share with shell
// debugging closer.

#ifndef _DEBUG_H_
#define _DEBUG_H_

#if (DBG == 1)
    #ifndef _DEBUG
        #define _DEBUG
    #endif
#endif

#ifdef _DEBUG
    #ifndef DEBUG_BREAK
        #ifdef _X86_
            #define DEBUG_BREAK \
            do { __try { __asm { int 3 } } __except(EXCEPTION_EXECUTE_HANDLER) {} } while (0)
        #else
            #define DEBUG_BREAK \
            DebugBreak()
        #endif
    #endif

    #ifndef ASSERT
        BOOL AssertFailedA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL fBreakInside);
        BOOL AssertFailedW(LPCWSTR pszFile, int line, LPCWSTR pszEval, BOOL fBreakInside);

        #ifdef _UNICODE
            #define AssertFailed AssertFailedW
        #else
            #define AssertFailed AssertFailedA
        #endif

        #define DEBUGTEXT(sz, msg) \
            static const TCHAR (sz)[] = (msg);

        #define ASSERT(f)                                                \
        {                                                                \
            DEBUGTEXT(szFile, TEXT(__FILE__));                           \
            if (!(f) && AssertFailed(szFile, __LINE__, TEXT(#f), FALSE)) \
                DEBUG_BREAK;                                             \
        }

        #ifdef _UNICODE
            #define ASSERTA(f)
            #define ASSERTU(f) ASSERT(f)
        #else
            #define ASSERTA(f) ASSERT(f)
            #define ASSERTU(f)
        #endif

        #if defined(_ATL_NO_DEBUG_CRT) && !defined(_ASSERTE)
            #define _ASSERTE(f) ASSERT(f)
            // BUGBUG: (andrewgu) theoretically, this should be enough. _ASSERTE is really a CRT
            // thing, and we should not have to redefine it.
            // #define ATLASSERT(f) ASSERT(f)
        #endif

    #endif // ASSERT

    #ifndef DEBUG_CODE
        #define DEBUG_CODE(x) x;
    #endif

#else  // _DEBUG

    #ifndef DEBUG_BREAK
        #define DEBUG_BREAK
    #endif

    #ifndef ASSERT
        #define ASSERT(f)
        #define ASSERTA(f)
        #define ASSERTU(f)
    #endif

    #ifndef DEBUG_CODE
        #define DEBUG_CODE(x)
    #endif

    #if defined(_ATL_NO_DEBUG_CRT) && !defined(_ASSERTE)
        #define _ASSERTE
        // BUGBUG: (andrewgu) theoretically, this should be enough. _ASSERTE is really a CRT
        // thing, and we should not have to redefine it.
        // #define ATLASSERT
    #endif

#endif // _DEBUG

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\debug.cpp ===
// REVIEW: This file has been "leveraged" off of \nt\private\shell\lib\debug.c and \nt\private\shell\inc\debug.h.
// By no means it's complete but it gives an idea of the right direction. Ideally, we would share with shell
// debugging closer.

#include "precomp.h"
#include "debug.h"

#ifdef _DEBUG

#undef  ASSERT
#ifndef __WATCOMC__
#define ASSERT(f) DEBUG_BREAK
#else
#define ASSERT(f) void(f)
#endif

const CHAR  FAR c_szAssertFailed[]  =  "Assert %s, line %d: (%s)\r\n";
const WCHAR FAR c_wszAssertFailed[] = L"Assert %s, line %d: (%s)\r\n";

BOOL AssertFailedA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL fBreakInside)
{
    CHAR   ach[256];
    LPCSTR psz;
    BOOL   fRet = FALSE;

    for (psz = pszFile + StrLenA(pszFile); psz != pszFile; psz = CharPrevA(pszFile, psz))
        if ((CharPrevA(pszFile, psz) != (psz-2)) && *(psz - 1) == '\\')
            break;
    wnsprintfA(ach, countof(ach), c_szAssertFailed, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (fBreakInside)
        ASSERT(0);
    else
        fRet = TRUE;

    return fRet;
}

BOOL AssertFailedW(LPCWSTR pszFile, int line, LPCWSTR pszEval, BOOL fBreakInside)
{
    WCHAR   ach[256];
    LPCWSTR psz;
    BOOL    fRet = FALSE;

    for (psz = pszFile + StrLenW(pszFile); psz && (psz != pszFile); psz = CharPrevW(pszFile, psz))
        if ((CharPrevW(pszFile, psz) != (psz-2)) && *(psz - 1) == TEXT('\\'))
            break;

    if (psz == NULL) {
        char szFile[MAX_PATH];
        char szEval[256];

        W2Abuf(pszFile, szFile, countof(szFile));
        W2Abuf(pszEval, szEval, countof(szEval));
        return AssertFailedA(szFile, line, szEval, fBreakInside);
    }

    wnsprintfW(ach, countof(ach), c_wszAssertFailed, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (fBreakInside)
        ASSERT(0);
    else
        fRet = TRUE;

    return fRet;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\dload.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L O A D . C P P
//
//  Contents:   Delay Load Failure Hook
//
//  Notes:      This DLL implements a form of exception handler (a failure
//              hook, really) that is called by the delay-load section of
//              the loader.  This DLL implements delay-load handlers for
//              standard APIs by returning an error code specific to the
//              API that failed to load.  This allows clients of those APIs
//              to safely delay load the DLLs that implement those APIs
//              without having to worry about the success or failure of the
//              delay load operation.  Failures in the delay load operation
//              cause the appropriate stub (implemented in this DLL) to be
//              invoked which simply returns an error code specific to the
//              API being called.  (Other interface semantics such as
//              setting output parameters are also performed.)
//
//  To Use:     1. Add the following line to one of your source modules.
//
//                 PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;
//
//              2. Define a global variable like the following:
//
//                 HANDLE g_hBaseDllHandle;
//
//                 And set it equal to your Dlls instance handle from
//                 DLL_PROCESS_ATTACH of DllMain.
//
//  Author:     shaunco   19 May 1998
//
//  Revised by: pritobla  23 Novemver 1998 (removed C-Runtime calls/RtlAssert
//              and modified the "To Use" section)
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop


#if DBG
VOID
WINAPI
AssertDelayLoadFailureMapsAreSorted (
    VOID
    )
{
    const DLOAD_DLL_ENTRY*      pDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;

    CHAR szMsg[1024];
    UINT iDll, iProcName, iOrdinal;
    INT  nRet;

    for (iDll = 0; iDll < g_DllMap.NumberOfEntries; iDll++)
    {
        if (iDll >= 1)
        {
            nRet = StrCmpIA (
                        g_DllMap.pDllEntry[iDll].pszDll,
                        g_DllMap.pDllEntry[iDll-1].pszDll);

            if (nRet <= 0)
            {
                wnsprintfA(szMsg, countof(szMsg),
                    "dload: rows %u and %u are out of order in dload!g_DllMap",
                    iDll-1, iDll);

                AssertFailedA(__FILE__, __LINE__, szMsg, TRUE);
            }
        }

        pDll = g_DllMap.pDllEntry + iDll;
        pProcNameMap = pDll->pProcNameMap;
        pOrdinalMap  = pDll->pOrdinalMap;

        if (pProcNameMap)
        {
            ASSERT (pProcNameMap->NumberOfEntries);

            for (iProcName = 0;
                 iProcName < pProcNameMap->NumberOfEntries;
                 iProcName++)
            {
                if (iProcName >= 1)
                {
                    nRet = StrCmpA (
                                pProcNameMap->pProcNameEntry[iProcName].pszProcName,
                                pProcNameMap->pProcNameEntry[iProcName-1].pszProcName);

                    if (nRet <= 0)
                    {
                        wnsprintfA(szMsg, countof(szMsg),
                            "dload: rows %u and %u of pProcNameMap are out "
                            "of order in dload!g_DllMap for pszDll=%s",
                            iProcName-1, iProcName, pDll->pszDll);

                        AssertFailedA (__FILE__, __LINE__, szMsg, TRUE);
                    }
                }
            }
        }

        if (pOrdinalMap)
        {
            ASSERT (pOrdinalMap->NumberOfEntries);

            for (iOrdinal = 0;
                 iOrdinal < pOrdinalMap->NumberOfEntries;
                 iOrdinal++)
            {
                if (iOrdinal >= 1)
                {
                    if (pOrdinalMap->pOrdinalEntry[iOrdinal].dwOrdinal <=
                        pOrdinalMap->pOrdinalEntry[iOrdinal-1].dwOrdinal)
                    {
                        wnsprintfA(szMsg, countof(szMsg),
                            "dload: rows %u and %u of pOrdinalMap are out "
                            "of order in dload!g_DllMap for pszDll=%s",
                            iOrdinal-1, iOrdinal, pDll->pszDll);

                        AssertFailedA(__FILE__, __LINE__, szMsg, TRUE);
                    }
                }
            }
        }
    }
}
#endif // DBG


const DLOAD_DLL_ENTRY*
FindDll (
    LPCSTR pszDll
    )
{
    const DLOAD_DLL_ENTRY* pDll = NULL;

    INT nResult;

    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and nResult < 0.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    ASSERT(pszDll);
    ASSERT(StrLenA(pszDll) <= MAX_PATH);

    iLow = 0;
    iHigh = g_DllMap.NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        nResult = StrCmpIA (pszDll, g_DllMap.pDllEntry[iMiddle].pszDll);

        if (nResult < 0)
        {
            iHigh = iMiddle - 1;
        }
        else if (nResult > 0)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            ASSERT (0 == nResult);
            pDll = &g_DllMap.pDllEntry[iMiddle];
            break;
        }
    }

    return pDll;
}

FARPROC
LookupHandlerByName (
    LPCSTR                      pszProcName,
    const DLOAD_PROCNAME_MAP*   pMap
    )
{
    FARPROC pfnHandler = NULL;

    INT nResult;

    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and nResult < 0.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    ASSERT (pszProcName);

    iLow = 0;
    iHigh = pMap->NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        nResult = StrCmpA (
                    pszProcName,
                    pMap->pProcNameEntry[iMiddle].pszProcName);

        if (nResult < 0)
        {
            iHigh = iMiddle - 1;
        }
        else if (nResult > 0)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            ASSERT (0 == nResult);
            pfnHandler = pMap->pProcNameEntry[iMiddle].pfnProc;
            break;
        }
    }

    return pfnHandler;
}

FARPROC
LookupHandlerByOrdinal (
    DWORD                       dwOrdinal,
    const DLOAD_ORDINAL_MAP*    pMap
    )
{
    FARPROC pfnHandler = NULL;

    DWORD dwOrdinalProbe;

    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and dwOrdinal < dwOrdinalProbe.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    iLow = 0;
    iHigh = pMap->NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        dwOrdinalProbe = pMap->pOrdinalEntry[iMiddle].dwOrdinal;

        if (dwOrdinal < dwOrdinalProbe)
        {
            iHigh = iMiddle - 1;
        }
        else if (dwOrdinal > dwOrdinalProbe)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            ASSERT (dwOrdinal == dwOrdinalProbe);
            pfnHandler = pMap->pOrdinalEntry[iMiddle].pfnProc;
            break;
        }
    }

    return pfnHandler;
}

FARPROC
LookupHandler (
    PDelayLoadInfo  pDelayInfo
    )
{
    FARPROC                 pfnHandler = NULL;
    const DLOAD_DLL_ENTRY*  pDll;

    ASSERT (pDelayInfo);

#if DBG
    AssertDelayLoadFailureMapsAreSorted();
#endif

    // Find the DLL record if we have one.
    //
    pDll = FindDll (pDelayInfo->szDll);
    if (pDll)
    {
        // Now find the handler whether it be by name or ordinal.
        //
        if (pDelayInfo->dlp.fImportByName &&
            pDll->pProcNameMap)
        {
            pfnHandler = LookupHandlerByName (
                            pDelayInfo->dlp.szProcName,
                            pDll->pProcNameMap);
        }
        else if (pDll->pOrdinalMap)
        {
            pfnHandler = LookupHandlerByOrdinal (
                            pDelayInfo->dlp.dwOrdinal,
                            pDll->pOrdinalMap);
        }
    }

    return pfnHandler;
}


#if DBG

#define DBG_ERROR   0
#define DBG_INFO    1

//+---------------------------------------------------------------------------
// Trace a message to the debug console.  Prefix with who we are so
// people know who to contact.
//
INT
__cdecl
DbgTrace (
    INT     nLevel,
    PCSTR   Format,
    ...
    )
{
    INT cch = 0;

    if (nLevel >= DBG_INFO)
    {
        CHAR    szBuf [1024];
        va_list argptr;

        va_start(argptr, Format);
        cch = wvnsprintfA(szBuf, countof(szBuf), Format, argptr);
        va_end(argptr);

        OutputDebugStringA("dload: ");
        OutputDebugStringA(szBuf);
    }

    return cch;
}

#endif // DBG


//+---------------------------------------------------------------------------
//
//
FARPROC
WINAPI
DelayLoadFailureHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    )
{
    FARPROC ReturnValue = NULL;

    // According to the docs, this parameter is always supplied.
    //
    ASSERT (pDelayInfo);

    // Trace some potentially useful information about why we were called.
    //
#if DBG
    if (pDelayInfo->dlp.fImportByName)
    {
        DbgTrace (DBG_INFO,
            "%s: Dll=%s, ProcName=%s\r\n",
            (dliFailLoadLib == unReason) ? "FailLoadLib" : "FailGetProc",
            pDelayInfo->szDll,
            pDelayInfo->dlp.szProcName);
    }
    else
    {
        DbgTrace (DBG_INFO,
            "%s: Dll=%s, Ordinal=%u\r\n",
            (dliFailLoadLib == unReason) ? "FailLoadLib" : "FailGetProc",
            pDelayInfo->szDll,
            pDelayInfo->dlp.dwOrdinal);
    }
#endif

    // For a failed LoadLibrary, we will return the HINSTANCE of this DLL.
    // This will cause the loader to try a GetProcAddress on our DLL for the
    // function.  This will subsequently fail and then we will be called
    // for dliFailGetProc below.
    //
    if (dliFailLoadLib == unReason)
    {
        ReturnValue = (FARPROC)g_hBaseDllHandle;
    }

    // The loader is asking us to return a pointer to a procedure.
    // Lookup the handler for this DLL/procedure and, if found, return it.
    // If we don't find it, we'll assert with a message about the missing
    // handler.
    //
    else if (dliFailGetProc == unReason)
    {
        FARPROC pfnHandler;

        // Try to find an error handler for the DLL/procedure.
        //
        pfnHandler = LookupHandler (pDelayInfo);

        if (pfnHandler)
        {
#if DBG
            DbgTrace (DBG_INFO,
                "Returning handler function at address 0x%08x\r\n",
                (LONG_PTR)pfnHandler);
#endif

            // Do this on behalf of the handler now that it is about to
            // be called.
            //
            SetLastError (ERROR_MOD_NOT_FOUND);
        }

#if DBG
        else
        {
            CHAR szMsg[MAX_PATH];

            if (pDelayInfo->dlp.fImportByName)
            {
                wnsprintfA(szMsg, countof(szMsg),
                    "No delayload handler found for Dll=%s, ProcName=%s\r\n",
                    pDelayInfo->szDll,
                    pDelayInfo->dlp.szProcName);
            }
            else
            {
                wnsprintfA(szMsg, countof(szMsg),
                    "No delayload handler found for Dll=%s, Ordinal=%u\r\n",
                    pDelayInfo->szDll,
                    pDelayInfo->dlp.dwOrdinal);
            }

            AssertFailedA(__FILE__, __LINE__, szMsg, TRUE);
        }
#endif

        ReturnValue = pfnHandler;
    }

#if DBG
    else
    {
        ASSERT (NULL == ReturnValue);

        DbgTrace (DBG_INFO,
            "Unknown unReason (%u) passed to DelayLoadFailureHook. Ignoring.\r\n",
            unReason);
    }
#endif

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\dload.h ===
#pragma once


typedef struct _DLOAD_PROCNAME_ENTRY
{
    LPCSTR  pszProcName;
    FARPROC pfnProc;
} DLOAD_PROCNAME_ENTRY;

#define DLPENTRY(_fcn)  { #_fcn, (FARPROC)_fcn },

#define DEFINE_PROCNAME_ENTRIES(_dllbasename) \
    const DLOAD_PROCNAME_ENTRY c_PmapEntries_##_dllbasename [] =


typedef struct _DLOAD_PROCNAME_MAP
{
    UINT                        NumberOfEntries;
    const DLOAD_PROCNAME_ENTRY* pProcNameEntry;
} DLOAD_PROCNAME_MAP;

#define DECLARE_PROCNAME_MAP(_dllbasename) \
    extern const DLOAD_PROCNAME_MAP c_Pmap_##_dllbasename;

#define DEFINE_PROCNAME_MAP(_dllbasename) \
    const DLOAD_PROCNAME_MAP c_Pmap_##_dllbasename = \
    { \
        countof(c_PmapEntries_##_dllbasename), \
        c_PmapEntries_##_dllbasename \
    };




typedef struct _DLOAD_ORDINAL_ENTRY
{
    DWORD   dwOrdinal;
    FARPROC pfnProc;
} DLOAD_ORDINAL_ENTRY;

#define DLOENTRY(_ord, _fcn)  { _ord, (FARPROC)_fcn },

#define DEFINE_ORDINAL_ENTRIES(_dllbasename) \
    const DLOAD_ORDINAL_ENTRY c_OmapEntries_##_dllbasename [] =


typedef struct _DLOAD_ORDINAL_MAP
{
    UINT                        NumberOfEntries;
    const DLOAD_ORDINAL_ENTRY*  pOrdinalEntry;
} DLOAD_ORDINAL_MAP;

#define DECLARE_ORDINAL_MAP(_dllbasename) \
    extern const DLOAD_ORDINAL_MAP c_Omap_##_dllbasename;

#define DEFINE_ORDINAL_MAP(_dllbasename) \
    const DLOAD_ORDINAL_MAP c_Omap_##_dllbasename = \
    { \
        countof(c_OmapEntries_##_dllbasename), \
        c_OmapEntries_##_dllbasename \
    };



typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },


typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\dlgctrl.cpp ===
#include "precomp.h"

// Private forward decalarations

static BOOL CALLBACK enumComboBoxChildrenWndProc(HWND hwndChild, LPARAM lParam);
static BOOL isCtrlWithFocus(HWND hCtrl);

void InitSysFont(HWND hDlg, int iCtrlID)
{
    static HFONT s_hfontSys = NULL;

    LOGFONT lf;
    HDC     hDC;
    HWND    hwndCtrl = GetDlgItem(hDlg, iCtrlID);
    HFONT   hFont;
    int     cyLogPixels;

    hDC = GetDC(NULL);
    if (hDC == NULL)
        return;

    cyLogPixels = GetDeviceCaps(hDC, LOGPIXELSY);
    ReleaseDC(NULL, hDC);

    if (s_hfontSys == NULL) {
        LOGFONT lfTemp;
        HFONT   hfontDef = (HFONT)GetStockObject(DEFAULT_GUI_FONT);

        GetObject(hfontDef, sizeof(lfTemp), &lfTemp);
        hFont = GetWindowFont(hwndCtrl);
        if (hFont != NULL)
            if (GetObject(hFont, sizeof(LOGFONT), (PVOID)&lf)) {
                StrCpy(lf.lfFaceName, lfTemp.lfFaceName);
                lf.lfQuality        = lfTemp.lfQuality;
                lf.lfPitchAndFamily = lfTemp.lfPitchAndFamily;
                lf.lfCharSet        = lfTemp.lfCharSet;

                s_hfontSys = CreateFontIndirect(&lf);
            }
    }

    if (iCtrlID == 0xFFFF)
        return;

    if (s_hfontSys != NULL)
        SetWindowFont(hwndCtrl, s_hfontSys, FALSE);
}

UINT GetRadioButton(HWND hDlg, UINT idFirst, UINT idLast)
{
    for (UINT id = idFirst; id <= idLast; id++)
        if (IsDlgButtonChecked(hDlg, id))
            return id;

    return 0;
}

BOOL EnableDlgItems(HWND hDlg, const PINT pidCtrls, UINT cidCtrls, BOOL fEnable /*= TRUE*/)
{
    HWND hCtrl;
    UINT i;
    BOOL fTotalSuccess;

    if (hDlg == NULL || pidCtrls == NULL || cidCtrls == 0)
        return FALSE;

    fTotalSuccess = TRUE;
    for (i = 0; i < cidCtrls; i++) {
        hCtrl = GetDlgItem(hDlg, *(pidCtrls + i));
        if (hCtrl == NULL) {
            fTotalSuccess = FALSE;
            continue;
        }

        if (fEnable != IsWindowEnabled(hCtrl))
            EnableWindow(hCtrl, fEnable);
    }

    return fTotalSuccess;
}

BOOL SetDlgItemFocus(HWND hDlg, int iCtrlID, BOOL fUsePropertySheet /*= FALSE*/)
{                                //  Back,   Next,   Finish
    static UINT s_rgidReserved[] = { 0x3023, 0x3024, 0x3025, IDHELP, IDCANCEL };

    HWND  hCtrl;
    DWORD dwStyle;
    UINT  i;

    if (fUsePropertySheet) {
        for (i = 0; i < countof(s_rgidReserved); i++)
            if ((UINT)iCtrlID == s_rgidReserved[i])
                break;

        if (i < countof(s_rgidReserved))
            hDlg = GetParent(hDlg);
    }

    hCtrl = GetDlgItem(hDlg, iCtrlID);
    if (hCtrl == NULL)
        return FALSE;

    ASSERT(IsWindowEnabled(hCtrl) && IsWindowVisible(hCtrl));
    SetFocus(hCtrl);

    dwStyle = GetWindowLong(hCtrl, GWL_STYLE);
    if (HasFlag(dwStyle, BS_PUSHBUTTON))
        Button_SetStyle(hCtrl, BS_DEFPUSHBUTTON, TRUE);

    return TRUE;
}

BOOL EnsureDialogFocus(HWND hDlg, int idFocus, int idBackup, BOOL fUsePropertySheet /*= FALSE*/)
{
    HWND  hCtrl;
    DWORD dwStyle;

    hCtrl = GetDlgItem(hDlg, idFocus);
    if (hCtrl == NULL)
        return FALSE;

    if (!isCtrlWithFocus(hCtrl))
        return TRUE;

    dwStyle = GetWindowLong(hCtrl, GWL_STYLE);

    if (HasFlag(dwStyle, BS_DEFPUSHBUTTON) && !HasFlag(dwStyle, BS_USERBUTTON))
        Button_SetStyle(hCtrl, BS_PUSHBUTTON, TRUE);

    return SetDlgItemFocus(hDlg, idBackup, fUsePropertySheet);
}

BOOL EnsureDialogFocus(HWND hDlg, const PINT pidFocus, UINT cidFocus, int idBackup, BOOL fUsePropertySheet /*= FALSE*/)
{
    HWND  hCtrl;
    DWORD dwStyle;
    UINT  i;

    if (pidFocus == NULL || cidFocus == 0)
        return FALSE;

    hCtrl = NULL;

    for (i = 0; i < cidFocus; i++) {
        hCtrl = GetDlgItem(hDlg, *(pidFocus + i));
        if (hCtrl == NULL)
            return FALSE;

        if (isCtrlWithFocus(hCtrl))
            break;
    }
    if (i >= cidFocus)
        return TRUE;

    ASSERT(hCtrl != NULL);
    dwStyle = GetWindowLong(hCtrl, GWL_STYLE);
    if (HasFlag(dwStyle, BS_DEFPUSHBUTTON) && !HasFlag(dwStyle, BS_USERBUTTON))
        Button_SetStyle(hCtrl, BS_PUSHBUTTON, TRUE);

    return SetDlgItemFocus(hDlg, idBackup, fUsePropertySheet);
}

void SetDlgItemTextTriState(HWND hDlg, INT nIDDlgText, INT nIDDlgCheck, LPCTSTR lpString, BOOL fChecked)
{
    CheckDlgButton(hDlg, nIDDlgCheck, fChecked ? BST_CHECKED : BST_UNCHECKED);
    EnableDlgItem2(hDlg, nIDDlgText, fChecked);
    SetDlgItemText(hDlg, nIDDlgText, lpString);
}

BOOL GetDlgItemTextTriState(HWND hDlg, INT nIDDlgText, INT nIDDlgCheck, LPTSTR lpString, int nMaxCount)
{
    GetDlgItemText(hDlg, nIDDlgText, lpString, nMaxCount);

    return (IsDlgButtonChecked(hDlg, nIDDlgCheck) == BST_CHECKED);
}

void IsTriStateValid(HWND hDlg, INT nIDDlgText, INT nIDDlgCheck, LPINT pnStatus,
                     LPCTSTR pcszErrMsg, LPCTSTR pcszTitle)
{
    TCHAR   szBuf[INTERNET_MAX_URL_LENGTH];

    if (*pnStatus == TS_CHECK_ERROR || *pnStatus == TS_CHECK_SKIP)
        return;    

    *pnStatus = TS_CHECK_OK;
    
    if (IsDlgButtonChecked(hDlg, nIDDlgCheck) == BST_CHECKED)
    {
        GetDlgItemText(hDlg, nIDDlgText, szBuf, countof(szBuf));
    
        if (ISNULL(szBuf))
        {
            if (MessageBox(hDlg, pcszErrMsg, pcszTitle, MB_ICONQUESTION|MB_YESNO) == IDNO)
            {
                SetFocus(GetDlgItem(hDlg, nIDDlgText));
                *pnStatus = TS_CHECK_ERROR;
            }
            else            
                *pnStatus = TS_CHECK_SKIP;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// Implementation helpers routines (private)

static BOOL CALLBACK enumComboBoxChildrenWndProc(HWND hwndChild, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    // check to see if this child window of the combo box has focus
    
    if (hwndChild == GetFocus())
        return FALSE;     // stop enumeration

    return TRUE;
}

static BOOL isCtrlWithFocus(HWND hCtrl)
{
    DWORD dwStyle;

    if (hCtrl == GetFocus())
        return TRUE;

    dwStyle = GetWindowLong(hCtrl, GWL_STYLE);

    // Check to see if this is a combo box with a hidden edit control
    if ((HasFlag(dwStyle, CBS_DROPDOWN) || HasFlag(dwStyle, CBS_SIMPLE)) &&
        !(HasFlag(dwStyle, CBS_DROPDOWN) && HasFlag(dwStyle, CBS_SIMPLE)))
    {
        if (!EnumChildWindows(hCtrl, (WNDENUMPROC)enumComboBoxChildrenWndProc, 0))
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\ieakutil.h ===
#ifndef _IEAKUTIL_H_
#define _IEAKUTIL_H_

#include <delayimp.h>
#include "dload.h"
#include "debug.h"

/////////////////////////////////////////////////////////////////////////////
// Required definitions in the final project

extern       TCHAR         g_szModule[];
extern       HANDLE        g_hBaseDllHandle;
extern const DLOAD_DLL_MAP g_DllMap;


/////////////////////////////////////////////////////////////////////////////
// Macros

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#endif

#ifndef countof
#define countof ARRAYSIZE
#endif

#define IE3_VERSION 1086


/////////////////////////////////////////////////////////////////////////////
// Classes

#include "newcur.h"
#include "logitem.h"
#include "regins.h"


/////////////////////////////////////////////////////////////////////////////
// Unicode wrappers

#include "unicwrap.h"


/////////////////////////////////////////////////////////////////////////////
// Functions

//----- Dialog Controls Routines -----
#define EnableDBCSChars(hDlg, iCtrlID)  (InitSysFont((hDlg), (iCtrlID)))
#define DisableDBCSChars(hDlg, iCtrlID) (ImmAssociateContext(GetDlgItem((hDlg), (iCtrlID)), NULL))

void    InitSysFont(HWND hDlg, int iCtrlID);
UINT    GetRadioButton(HWND hDlg, UINT idFirst, UINT idLast);

#define EnableDlgItem(hDlg, idCtrl)           (EnableWindow(GetDlgItem((hDlg), (idCtrl)), TRUE))
#define ShowDlgItem(hDlg, idCtrl)             (ShowWindow(GetDlgItem((hDlg), (idCtrl)), SW_SHOW))
#define EnableDlgItem2(hDlg, idCtrl, fEnable) (EnableWindow(GetDlgItem((hDlg), (idCtrl)), (fEnable)))
#define ShowDlgItem2(hDlg, idCtrl, fShow)     (ShowWindow(GetDlgItem((hDlg), (idCtrl)), (fShow) ? SW_SHOW : SW_HIDE))
#define DisableDlgItem(hDlg, idCtrl)          (EnableWindow(GetDlgItem((hDlg), (idCtrl)), FALSE))
#define HideDlgItem(hDlg, idCtrl)             (ShowWindow(GetDlgItem((hDlg), (idCtrl)), SW_HIDE))
BOOL    EnableDlgItems(HWND hDlg, const PINT pidCtrls, UINT cidCtrls, BOOL fEnable = TRUE);
#define DisableDlgItems(hDlg, pidCtrls, cidCtrls) (EnableDlgItems((hDlg), (pidCtrls), (cidCtrls), FALSE))
#define IsDlgItemEnabled(hDlg, idCtrl)        (IsWindowEnabled(GetDlgItem((hDlg), (idCtrl))))
#define GetDlgItemTextLength(hDlg, idCtrl)    (GetWindowTextLength(GetDlgItem((hDlg), (idCtrl))))

BOOL    SetDlgItemFocus(HWND hDlg, int iCtrlID, BOOL fUsePropertySheet = FALSE);
BOOL    EnsureDialogFocus(HWND hDlg, int idFocus, int idBackup, BOOL fUsePropertySheet = FALSE);
BOOL    EnsureDialogFocus(HWND hDlg, const PINT pidFocus, UINT cidFocus, int idBackup, BOOL fUsePropertySheet = FALSE);

void    SetDlgItemTextTriState(HWND hDlg, int nIDDlgText, int nIDDlgCheck, PCTSTR pszString, BOOL fChecked);
BOOL    GetDlgItemTextTriState(HWND hDlg, int nIDDlgText, int nIDDlgCheck, PTSTR  pszString, int nMaxCount);

#define TS_CHECK_OK         1
#define TS_CHECK_ERROR      2
#define TS_CHECK_SKIP       3

void    IsTriStateValid(HWND hDlg, int nIDDlgText, int nIDDlgCheck, PINT pnStatus, PCTSTR pszErrMsg, PCTSTR pszTitle);

//----- String Routines -----
int     StrPrepend(PTSTR pszSource, UINT cchSource, PCTSTR pszAdd, UINT cchAdd = 0);
#define StrRemoveWhitespace(pszSrc) (StrTrim((pszSrc), TEXT(" \t\r\n")))
void    StrRemoveAllWhiteSpace(PTSTR pszBuf);

#define StrLenA(pszSrcA)          (lstrlenA(pszSrcA))
#define StrLenW(pszSrcW)          (lstrlenW(pszSrcW))
#define StrLenUAW(pszSrcUAW)      (ualstrlenW(pszSrcUAW))

#define StrCbFromCchA(cchSrc)     (cchSrc)
#define StrCbFromCchW(cchSrc)     ((cchSrc) * sizeof(WCHAR))

#define StrCchFromCbA(cbSrc)      (cbSrc)
#define StrCchFromCbW(cbSrc)      (GetUnitsFromCb(cbSrc, sizeof(WCHAR)))

#define StrCbFromSzA(pszSrcA)     ((pszSrcA) != NULL ? StrCbFromCchA(StrLenA(pszSrcA) + 1) : 0)
#define StrCbFromSzW(pszSrcW)     ((pszSrcW) != NULL ? StrCbFromCchW(StrLenW(pszSrcW) + 1) : 0)

#define StrCbFromSzUAW(pszSrcUAW) ((pszSrcUAW) != NULL ? StrCbFromCchW(StrLenUAW(pszSrcUAW) + 1) : 0)

#ifdef _UNICODE
    #define StrLen        StrLenW
    #define StrCbFromCch  StrCbFromCchW
    #define StrCbFromSz   StrCbFromSzW
    #define StrCchFromCb  StrCchFromCbW
    #define StrCbFromSzUA StrCbFromSzUAW
#else
    #define StrLen        StrLenA
    #define StrCbFromCch  StrCbFromCchA
    #define StrCbFromSz   StrCbFromSzA
    #define StrCchFromCb  StrCchFromCbA
    #define StrCbFromSzUA StrCbFromSzA
#endif

#define REMOVE_QUOTES           0x01
#define IGNORE_QUOTES           0x02
PTSTR StrGetNextField(PTSTR *ppszData, PCTSTR pcszDelims, DWORD dwFlags);
PTSTR WINAPIV FormatString(PCTSTR pcszFormatString, ...);

#define ISNULL(sz)    ((*(sz)) == TEXT('\0'))
#define ISNONNULL(sz) ((*(sz)) != TEXT('\0'))

//----- String Conversion Routines -----
PWSTR StrAnsiToUnicode(PWSTR pszTarget, PCSTR  pszSource, UINT cchTarget = 0);
PSTR  StrUnicodeToAnsi(PSTR  pszTarget, PCWSTR pszSource, UINT cchTarget = 0);
PTSTR StrSameToSame   (PTSTR pszTarget, PCTSTR pszSource, UINT cchTarget = 0);

#ifndef ATLA2WHELPER
#define ATLA2WHELPER StrAnsiToUnicode
#define ATLW2AHELPER StrUnicodeToAnsi

#include <atlconv.h>
#endif

#if (_ATL_VER != 0x0202)
#pragma message("WARNING: (andrewgu) _ATL_VER changed! please update this file.")
#endif

#ifdef USES_CONVERSION
#undef USES_CONVERSION
#endif

#define USES_CONVERSION int _convert; _convert = 0

#define A2Wbuf(pszSource, pszTarget, cchTarget) StrAnsiToUnicode((pszTarget), (pszSource), (cchTarget))
#define A2Wbux(pszSource, pszTarget)            StrAnsiToUnicode((pszTarget), (pszSource))

#define W2Abuf(pszSource, pszTarget, cchTarget) StrUnicodeToAnsi((pszTarget), (pszSource), (cchTarget))
#define W2Abux(pszSource, pszTarget)            StrUnicodeToAnsi((pszTarget), (pszSource))

#ifdef _UNICODE
#define T2Abuf W2Abuf
#define T2Abux W2Abux

#define A2Tbuf A2Wbuf
#define A2Tbux A2Wbux

#define T2Wbuf(pszSource, pszTarget, cchTarget) StrSameToSame((pszTarget), (pszSource), (cchTarget))
#define T2Wbux(pszSource, pszTarget)            StrSameToSame((pszTarget), (pszSource))

#define W2Tbuf(pszSource, pszTarget, cchTarget) StrSameToSame((pszTarget), (pszSource), (cchTarget))
#define W2Tbux(pszSource, pszTarget)            StrSameToSame((pszTarget), (pszSource))

#else /* #ifndef _UNICODE */
#define T2Abuf(pszSource, pszTarget, cchTarget) StrSameToSame((pszTarget), (pszSource), (cchTarget))
#define T2Abux(pszSource, pszTarget)            StrSameToSame((pszTarget), (pszSource))

#define A2Tbuf(pszSource, pszTarget, cchTarget) StrSameToSame((pszTarget), (pszSource), (cchTarget))
#define A2Tbux(pszSource, pszTarget)            StrSameToSame((pszTarget), (pszSource))

#define T2Wbuf A2Wbuf
#define T2Wbux A2Wbux

#define W2Tbuf W2Abuf
#define W2Tbux W2Abux
#endif /* #ifdef _UNICODE */


//----- Path Routines -----
BOOL    PathCreatePath(PCTSTR pszPathToCreate);

#define PIVP_DEFAULT        0x00000000
#define PIVP_FILENAME_ONLY  0x00000001
#define PIVP_RELATIVE_VALID 0x00000002
#define PIVP_DBCS_INVALID   0x00000004
#define PIVP_0x5C_INVALID   0x00000008
#define PIVP_MUST_EXIST     0x00000010
#define PIVP_FILE_ONLY      (PIVP_MUST_EXIST   | 0x00000020)
#define PIVP_FOLDER_ONLY    (PIVP_MUST_EXIST   | 0x00000040)
#define PIVP_EXCHAR_INVALID (PIVP_DBCS_INVALID | 0x00000080)
BOOL    PathIsValidPath(PCTSTR pszPath, DWORD dwFlags = PIVP_DEFAULT);
BOOL    PathIsValidFile(PCTSTR pszFile, DWORD dwFlags = PIVP_DEFAULT);

#define PIVP_VALID        0x00000000            // the path is valid
#define PIVP_INVALID      0x80000000            // general flag for failure
#define PIVP_ARG          0x80000001            // invalid argument to the function
#define PIVP_CHAR         0x80000002            // invalid char
#define PIVP_WILD         0x80000004            // wildcard
#define PIVP_RELATIVE     0x80000008            // "\\foo" if PIVP_RELATIVE_VALID is not set
#define PIVP_FIRST_CHAR   0x80000010            // "<not '\\' | ' ' | not <LFN char>>\\foo"
#define PIVP_PRESLASH     0x80000020            // char in front of '\\' is invalid
#define PIVP_SPACE        0x80000040            // "bar \\foo"
#define PIVP_FWDSLASH     0x80000080            // '/' encountered
#define PIVP_COLON        0x80000100            // ':' in other than "c:" position
#define PIVP_DRIVE        0x80000200            // invalid drive letter
#define PIVP_SEPARATOR    0x80000400            // invalid separator, should never happen
#define PIVP_DBCS         0x80000800            // DBCS encountered when PIVP_DBCS_INVALID is set
#define PIVP_0x5C         0x80001000            // 0x5C encountered when PIVP_0x5C_INVALID is set
#define PIVP_DOESNT_EXIST 0x80002000            // the path or file doesn't exist
#define PIVP_NOT_FILE     0x80004000            // not a file when PIVP_FILE_ONLY is set
#define PIVP_NOT_FOLDER   0x80008000            // not a folder when PIVP_FOLDER_ONLY is set
#define PIVP_EXCHAR       0x80010000            // extended char encountered when PIVP_EXCHAR_INVALID is set
DWORD   PathIsValidPathEx(PCTSTR pszPath, DWORD dwFlags = PIVP_DEFAULT, PCTSTR *ppszError = NULL);

#define PEP_DEFAULT             0x00000000

#define PEP_SCPE_DEFAULT        0x00000000
#define PEP_SCPE_NOFILES        0x00000001
#define PEP_SCPE_NOFOLDERS      0x00000002
#define PEP_SCPE_ALL            0x00000003

#define PEP_CTRL_DEFAULT        0x00000000
#define PEP_CTRL_ENUMPROCFIRST  0x00000010
#define PEP_CTRL_NOSECONDCALL   0x00000020
#define PEP_CTRL_USECONTROL     0x00000040
#define PEP_CTRL_RESET          0x00000080
#define PEP_CTRL_KEEPAPPLY      0x00000100
#define PEP_CTRL_ALL            0x000001F0

#define PEP_RCRS_DEFAULT        0x00000000
#define PEP_RCRS_FALSE          0x00010000
#define PEP_RCRS_CONTINUE       0x00020000
#define PEP_RCRS_CONTINUE_FALSE 0x00040000
#define PEP_RCRS_FAILED         0x00080000
#define PEP_RCRS_ALL            0x000F0000

#define PEP_S_CONTINUE          ((HRESULT)0x00000002L)
#define PEP_S_CONTINUE_FALSE    ((HRESULT)0x00000003L)

#define PEP_ENUM_INPOS_FIRST           0
#define PEP_ENUM_INPOS_FLAGS           0
#define PEP_ENUM_INPOS_RECOURSEFLAGS   1
#define PEP_ENUM_INPOS_LAST            2

#define PEP_ENUM_OUTPOS_FIRST          0
#define PEP_ENUM_OUTPOS_SECONDCALL     0
#define PEP_ENUM_OUTPOS_BELOW          1
#define PEP_ENUM_OUTPOS_THISLEVEL      2
#define PEP_ENUM_OUTPOS_ABOVE_SIBLINGS 3
#define PEP_ENUM_OUTPOS_ABOVE          4
#define PEP_ENUM_OUTPOS_LAST           5

#define PEP_RCRS_OUTPOS_FIRST          0
#define PEP_RCRS_OUTPOS_SECONDCALL     0
#define PEP_RCRS_OUTPOS_BELOW          1
#define PEP_RCRS_OUTPOS_THISLEVEL      2
#define PEP_RCRS_OUTPOS_LAST           3

typedef HRESULT (*PFNPATHENUMPATHPROC)(PCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam,
    PDWORD *prgdwControl /*= NULL*/);
HRESULT PathEnumeratePath(PCTSTR pszPath, DWORD dwFlags, PFNPATHENUMPATHPROC pfnEnumProc, LPARAM lParam,
    PDWORD *ppdwReserved = NULL);

BOOL    PathRemovePath(PCTSTR pcszPath, DWORD dwFlags = 0);
BOOL    PathIsLocalPath(PCTSTR pszPath);
BOOL    PathFileExistsInDir(PCTSTR pcszFile, PCTSTR pcszDir);
BOOL    PathHasBackslash(PCTSTR pcszPath);
#define PathIsExtension(pszFile, pszExt) (StrCmpI(PathFindExtension(pszFile), pszExt) == 0)
#define PathIsFullPath(pszFile)          (StrCmpI(PathFindFileName(pszFile), pszFile) != 0)
#define PathIsFileURL(pszUrl)            (StrCmpNI(pszUrl, FILEPREFIX, countof(FILEPREFIX)-1) == 0)
#define PathIsFileOrFileURL(pszUrl)      (PathFileExists(pszUrl) || PathIsFileURL(pszUrl))

#define FILES_ONLY     0x00000001
#define FILES_AND_DIRS 0x00000002
BOOL PathIsEmptyPath(PCTSTR pcszPath, DWORD dwFlags = FILES_AND_DIRS, PCTSTR pcszExcludeFile = NULL);
void PathReplaceWithLDIDs(PTSTR pszPath);

//----- Registry Routines -----
#define SHCreateKey(hk, pszSubKey, sam, phkResult) \
    (RegCreateKeyEx((hk), (pszSubKey), 0, NULL, REG_OPTION_NON_VOLATILE, (sam), NULL, (phkResult), NULL))
#define SHCreateKeyHKCR(pszSubKey, sam, phkResult) \
    (SHCreateKey(HKEY_CLASSES_ROOT, pszSubKey, sam, phkResult))
#define SHCreateKeyHKCC(pszSubKey, sam, phkResult) \
    (SHCreateKey(HKEY_CURRENT_CONFIG, pszSubKey, sam, phkResult))
#define SHCreateKeyHKLM(pszSubKey, sam, phkResult) \
    (SHCreateKey(HKEY_LOCAL_MACHINE, pszSubKey, sam, phkResult))
#define SHCreateKeyHKCU(pszSubKey, sam, phkResult) \
    (SHCreateKey(HKEY_CURRENT_USER, pszSubKey, sam, phkResult))
#define SHCreateKeyHKU(pszSubKey, sam, phkResult)  \
    (SHCreateKey(HKEY_USERS, pszSubKey, sam, phkResult))

#define SHOpenKey(hk, pszSubKey, sam, phkResult) \
    (RegOpenKeyEx((hk), (pszSubKey), 0, (sam), (phkResult)))
#define SHOpenKeyHKCR(pszSubKey, sam, phkResult) \
    (SHOpenKey(HKEY_CLASSES_ROOT, pszSubKey, sam, phkResult))
#define SHOpenKeyHKCC(pszSubKey, sam, phkResult) \
    (SHOpenKey(HKEY_CURRENT_CONFIG, pszSubKey, sam, phkResult))
#define SHOpenKeyHKLM(pszSubKey, sam, phkResult) \
    (SHOpenKey(HKEY_LOCAL_MACHINE, pszSubKey, sam, phkResult))
#define SHOpenKeyHKCU(pszSubKey, sam, phkResult) \
    (SHOpenKey(HKEY_CURRENT_USER, pszSubKey, sam, phkResult))
#define SHOpenKeyHKU(pszSubKey, sam, phkResult)  \
    (SHOpenKey(HKEY_USERS, pszSubKey, sam, phkResult))

HRESULT SHCleanUpValue(HKEY hk, PCTSTR pszKey, PCTSTR pszValue = NULL);

void    SHCopyKey     (HKEY hkFrom, HKEY hkTo);
HRESULT SHCopyValue   (HKEY hkFrom, HKEY hkTo, PCTSTR pszValue);
HRESULT SHCopyValue   (HKEY hkFrom, PCTSTR pszSubkeyFrom, HKEY hkTo, PCTSTR pszSubkeyTo, PCTSTR pszValue);

HRESULT SHIsKeyEmpty  (HKEY hk);
HRESULT SHIsKeyEmpty  (HKEY hk, PCTSTR pszSubKey);

HRESULT SHKeyExists   (HKEY hk, PCTSTR pszSubKey);
HRESULT SHValueExists (HKEY hk, PCTSTR pszValue);
HRESULT SHValueExists (HKEY hk, PCTSTR pszSubKey, PCTSTR pszValue);

DWORD RegSaveRestoreDWORD(HKEY hk, PCTSTR pszValue, DWORD dwValue);

#define SHCloseKey(hk) \
    if ((hk) != NULL) { RegCloseKey((hk)); (hk) = NULL; } else


//----- Advanced File Manipulation Routines -----
#define CopyFileToDir(pszFile, pszDir) (CopyFileToDirEx((pszFile), (pszDir), NULL, NULL))
BOOL    CopyFileToDirEx(PCTSTR pszSourceFileOrPath, PCTSTR pszTargetPath, PCTSTR pszSection = NULL, PCTSTR pszIns = NULL);
BOOL    AppendFile(PCTSTR pcszSrcFile, PCTSTR pcszDstFile);

#define CopyHtmlImgs(pszHtmlFile, pszDestPath, pszSectionName, pszInsFile) \
    (CopyHtmlImgsEx((pszHtmlFile), (pszDestPath), (pszSectionName), (pszInsFile), TRUE))
#define DeleteHtmlImgs(pszHtmlFile, pszDestPath, pszSectionName, pszInsFile) \
    (CopyHtmlImgsEx((pszHtmlFile), (pszDestPath), (pszSectionName), (pszInsFile), FALSE))
void    CopyHtmlImgsEx(PCTSTR pszHtmlFile, PCTSTR pszDestPath, PCTSTR pszSectionName, PCTSTR pszInsFile, BOOL fCopy);

HANDLE  CreateNewFile(PCTSTR pcszFileToCreate);
DWORD   FileSize(PCTSTR pcszFile);
BOOL    DeleteFileInDir(PCTSTR pszFileName, PCTSTR pszPath);
#define CloseFile(h) CloseHandle(h)
#define GetFilePointer(hFile) SetFilePointer((hFile), 0, NULL, FILE_CURRENT)
void    SetAttribAllEx(PCTSTR pcszDir, PCTSTR pcszFile, DWORD dwAtr, BOOL fRecurse);
DWORD   GetNumberOfFiles(PCTSTR pcszFileName, PCTSTR pcszDir);

BOOL    GetFreeDiskSpace (PCTSTR pcszDir, PDWORD pdwFreeSpace, PDWORD pdwFlags);
DWORD   FindSpaceRequired(PCTSTR pcszSrcDir, PCTSTR pcszFile, PCTSTR pcszDstDir);

BOOL    WriteStringToFileA (HANDLE hFile, LPCVOID pbBuf, DWORD cchSize);
BOOL    WriteStringToFileW (HANDLE hFile, LPCVOID pbBuf, DWORD cchSize);
BOOL    ReadStringFromFileA(HANDLE hFile, LPVOID  pbBuf, DWORD cchSize);
BOOL    ReadStringFromFileW(HANDLE hFile, LPVOID  pbBuf, DWORD cchSize);
#ifdef _UNICODE
#define WriteStringToFile  WriteStringToFileW
#define ReadStringFromFile ReadStringFromFileW
#else
#define WriteStringToFile  WriteStringToFileA
#define ReadStringFromFile ReadStringFromFileA
#endif

BOOL HasFileAttribute(DWORD dwFileAttrib, PCTSTR pcszFile, PCTSTR pcszDir = NULL);

inline BOOL IsFileReadOnly(PCTSTR pcszFile, PCTSTR pcszDir = NULL)
{
    return HasFileAttribute(FILE_ATTRIBUTE_READONLY, pcszFile, pcszDir);
}

BOOL IsFileCreatable(PCTSTR pcszFile);

//----- Settings File Routines -----
#define InsGetBool(pszSection, pszKey, fDefault, pszIns) \
    (GetPrivateProfileInt((pszSection), (pszKey), (fDefault), (pszIns)) ? TRUE : FALSE)
#define InsGetInt(pszSection, pszKey, iDefault, pszIns) \
    (GetPrivateProfileInt((pszSection), (pszKey), (iDefault), (pszIns)))
DWORD   InsGetString(PCTSTR pszSection, PCTSTR pszKey, PTSTR pszValue, DWORD cchValue, PCTSTR pszIns,
    PCTSTR pszServerFile = NULL, PBOOL pfChecked = NULL);
DWORD   InsGetSubstString(PCTSTR pszSection, PCTSTR pszKey, PTSTR pszValue, DWORD cchValue, PCTSTR pszIns);
BOOL    InsGetYesNo(PCTSTR pszSection, PCTSTR pszKey, BOOL fDefault, PCTSTR pszIns);

#define InsWriteBool(pszSection, pszKey, fValue, pszIns) \
    (WritePrivateProfileString((pszSection), (pszKey), (fValue) ? TEXT("1") : NULL, (pszIns)))
#define InsWriteBoolEx(pszSection, pszKey, fDefault, pszIns) \
    (WritePrivateProfileString((pszSection), (pszKey), (fDefault) ? TEXT("1") : TEXT("0"), (pszIns)))
void    InsWriteInt(PCTSTR pszSection, PCTSTR pszKey, int iValue, PCTSTR pszIns);
void    InsWriteString(PCTSTR pszSection, PCTSTR pszKey, PCTSTR pszValue, PCTSTR pszIns,
    BOOL fChecked = TRUE, PCTSTR pszServerFile = NULL, DWORD dwFlags = 0);
int     InsWriteQuotedString(PCTSTR pszSection, PCTSTR pszKey, PCTSTR pszValue, PCTSTR pszIns);
#define InsWriteYesNo(pszSection, pszKey, fValue, pszIns) \
    (WritePrivateProfileString((pszSection), (pszKey), (fValue) ? TEXT("Yes") : TEXT("No"), (pszIns)))

#define InsDeleteSection(pszSection, pszIns)     \
    (WritePrivateProfileString((pszSection), NULL, NULL, (pszIns)))
#define InsDeleteKey(pszSection, pszKey, pszIns) \
    (WritePrivateProfileString((pszSection), (pszKey), NULL, (pszIns)))

#define InsReadSections(pszSections, cchSections, pszIns) \
    (GetPrivateProfileString(NULL, NULL, (pszSections), (cchSections), (pszIns)))
#define InsReadKeys(pszSection, pszKeys, cchKeys, pszIns) \
    (GetPrivateProfileString((pszSection), NULL, (pszKeys), (cchKeys), (pszIns)))
#define InsFlushChanges(pszIns)                           \
    (WritePrivateProfileString(NULL, NULL, NULL, (pszIns)))

BOOL    InsIsSectionEmpty(PCTSTR pszSection, PCTSTR pszFile);
BOOL    InsIsKeyEmpty(PCTSTR pszSection, PCTSTR pszKey, PCTSTR pszFile);
BOOL    InsKeyExists (PCTSTR pszSection, PCTSTR pszKey, PCTSTR pszFile);

#define ReadBoolAndCheckButton(pszSection, pszKey, fDefault, pszIns, hDlg, idCtrl) \
    (CheckDlgButton((hDlg), (idCtrl), InsGetBool((pszSection), (pszKey), (fDefault), (pszIns)) ? BST_CHECKED : BST_UNCHECKED))

#define CheckButtonAndWriteBool(hDlg, idCtrl, pszSection, pszKey, pszIns) \
    (InsWriteBool((pszSection), (pszKey), BST_CHECKED == IsDlgButtonChecked((hDlg), (idCtrl)), (pszIns)))

#define INSIO_TRISTATE   0x00000001
#define INSIO_PATH       0x00000002
#define INSIO_SERVERONLY 0x00000004

void SetDlgItemTextFromIns(HWND hDlg, int idText, int idCheck,
    PCTSTR pszSection, PCTSTR pszKey, PCTSTR pszIns,
    PCTSTR pszServerFile, DWORD dwFlags);
void WriteDlgItemTextToIns(HWND hDlg, int idText, int idCheck,
    PCTSTR pszSection, PCTSTR pszKey, PCTSTR pszIns,
    PCTSTR pcszServerFile, DWORD dwFlags);


//----- Delay Load Failure Routine -----
FARPROC WINAPI DelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);


//----- Miscellaneous -----
typedef struct tagMAPDW2PSZ {
    DWORD  dw;
    PCTSTR psz;
} MAPDW2PSZ, *PMAPDW2PSZ;
typedef const MAPDW2PSZ *PCMAPDW2PSZ;

#define DW2PSZ_PAIR(dw) { ((DWORD)dw), TEXT(#dw) }

ULONG   CoTaskMemSize(PVOID pv);
UINT    CoStringFromGUID(REFGUID rguid, PTSTR pszBuf, UINT cchBuf);

PCTSTR  GetHrSz(HRESULT hr);
void    ConvertVersionStrToDwords(PTSTR pszVer, PDWORD pdwVer, PDWORD pdwBuild);
void    ConvertDwordsToVersionStr(PTSTR pszVer, DWORD dwVer, DWORD dwBuild);
DWORD   GetIEVersion();

#define HasFlag(dwFlags, dwMask) (((DWORD)(dwFlags) & (DWORD)(dwMask)) != 0L)
BOOL    SetFlag(PDWORD pdwFlags, DWORD dwMask, BOOL fSet = TRUE);

BOOL IsNTAdmin(VOID);

HRESULT GetLcid(LCID *pLcid, PCTSTR pcszLang, PCTSTR pcszLocaleIni);
UINT    GetUnitsFromCb(UINT cbSrc, UINT cbUnit);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\file.cpp ===
#include "precomp.h"

// Private forward decalarations
static LPCTSTR findMatchingBracket(LPCTSTR pszHtml);
static HRESULT findImgSrc(LPCTSTR *ppszHtml, LPTSTR pszSrcBuffer, LPUINT pcch);
static HRESULT buildImagesList(LPCTSTR pszHtml, LPTSTR *ppszList);


BOOL CopyFileToDirEx(LPCTSTR pszSourceFileOrPath, LPCTSTR pszTargetPath, LPCTSTR pszSection /*= NULL*/, LPCTSTR pszIns /*= NULL*/)
{
    LPTSTR pszAuxFile;
    BOOL   fResult;

    if (!PathFileExists(pszSourceFileOrPath))
        return FALSE;

    fResult = TRUE;
    if (!PathIsDirectory(pszSourceFileOrPath)) { // file
        TCHAR szTargetFile[MAX_PATH];

        fResult = PathCreatePath(pszTargetPath);
        if (!fResult)
            return FALSE;

        pszAuxFile = PathFindFileName(pszSourceFileOrPath);
        PathCombine(szTargetFile, pszTargetPath, pszAuxFile);
        SetFileAttributes(szTargetFile, FILE_ATTRIBUTE_NORMAL);

        fResult = CopyFile(pszSourceFileOrPath, szTargetFile, FALSE);
        if (!fResult)
            return FALSE;

        //----- Update the ins file -----
        if (pszSection != NULL && pszIns != NULL) {
            TCHAR szBuf[16];
            UINT  nNumFiles;

            nNumFiles = (UINT)GetPrivateProfileInt(pszSection, IK_NUMFILES, 0, pszIns);
            wnsprintf(szBuf, countof(szBuf), TEXT("%u"), ++nNumFiles);
            WritePrivateProfileString(pszSection, IK_NUMFILES, szBuf, pszIns);

            ASSERT(nNumFiles > 0);
            wnsprintf(szBuf, countof(szBuf), FILE_TEXT, nNumFiles - 1);
            WritePrivateProfileString(pszSection, szBuf, pszAuxFile, pszIns);
        }
    }
    else {                                       // directory
        // BUGBUG: Won't copy files in sub-dirs under pszSourceFileOrPath
        WIN32_FIND_DATA fd;
        TCHAR  szSourceFile[MAX_PATH];
        HANDLE hFindFile;

        StrCpy(szSourceFile, pszSourceFileOrPath);
        PathAddBackslash(szSourceFile);

        // remember the pos where the filename would get copied
        pszAuxFile = szSourceFile + StrLen(szSourceFile);
        StrCpy(pszAuxFile, TEXT("*.*"));

        // copy all the files in pszSourceFileOrPath to pszTargetPath
        hFindFile = FindFirstFile(szSourceFile, &fd);
        if (hFindFile != INVALID_HANDLE_VALUE) {
            fResult = TRUE;
            do {
                // skip ".", ".." and all sub-dirs
                if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    continue;

                StrCpy(pszAuxFile, fd.cFileName);

                // keep going even if copying of a file fails, but return FALSE in case of error
                fResult = fResult && CopyFileToDirEx(szSourceFile, pszTargetPath, pszSection, pszIns);
            } while (FindNextFile(hFindFile, &fd));

            FindClose(hFindFile);
        }
    }

    return fResult;
}

BOOL AppendFile(LPCTSTR pcszSrcFile, LPCTSTR pcszDstFile)
// Append the content of pcszSrcFile to pcszDstFile.
{
    BOOL fRet = FALSE;
    HANDLE hDstFile = INVALID_HANDLE_VALUE,
           hSrcFile = INVALID_HANDLE_VALUE;
    LPBYTE pbBuffer = NULL;
    DWORD cbRead, cbWritten;

    if (pcszDstFile == NULL  ||  pcszSrcFile == NULL  ||  ISNULL(pcszDstFile)  ||  ISNULL(pcszSrcFile))
        return FALSE;

    if ((hDstFile = CreateFile(pcszDstFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        // DstFile doesn't exist; create one and call CopyFile()
        if ((hDstFile = CreateNewFile(pcszDstFile)) != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hDstFile);
            hDstFile = INVALID_HANDLE_VALUE;

            fRet = CopyFile(pcszSrcFile, pcszDstFile, FALSE);
        }

        goto CleanUp;
    }

    if (SetFilePointer(hDstFile, 0, NULL, FILE_END) == (DWORD) -1)
        goto CleanUp;

    if ((hSrcFile = CreateFile(pcszSrcFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
        goto CleanUp;

    // allocate a 4K buffer
    if ((pbBuffer = (LPBYTE)CoTaskMemAlloc(4 * 1024)) == NULL)
        goto CleanUp;
    ZeroMemory(pbBuffer, 4 * 1024);

    while ((fRet = ReadFile(hSrcFile, (LPVOID) pbBuffer, 4 * 1024, &cbRead, NULL)) == TRUE)
    {
        if (cbRead == 0)
            break;

        fRet = WriteFile(hDstFile, (LPCVOID) pbBuffer, cbRead, &cbWritten, NULL);
        if (!fRet)
            break;

        ASSERT(cbRead == cbWritten);
    }

    if (!fRet)
        goto CleanUp;

    fRet = TRUE;

    // good thing to do, esp. on Win95 if you combine AppendFile with Get/WritePrivateProfile functions.
    FlushFileBuffers(hDstFile);

CleanUp:
    if (pbBuffer != NULL)
        CoTaskMemFree(pbBuffer);

    if (hSrcFile != INVALID_HANDLE_VALUE)
        CloseHandle(hSrcFile);

    if (hDstFile != INVALID_HANDLE_VALUE)
        CloseHandle(hDstFile);

    return fRet;
}

// BUGBUG: (andrewgu) there is a number of ways we can improve this:
// 1. (first and foremost) we should be using trident for parsing html. this way will be able to
// pick up not only img tags but dynimg as well and everything else that can reference more files;
// 2. fCopy doesn't quite cut it. we should add support for generic flags. couple of them off the
// top of my head are CopyItself, and MoveNotCopy.
void CopyHtmlImgsEx(LPCTSTR pszHtmlFile, LPCTSTR pszDestPath, LPCTSTR pszSectionName, LPCTSTR pszInsFile, BOOL fCopy /*= TRUE*/)
{
    TCHAR  szSrcFile[MAX_PATH];
    LPTSTR pszFileName, pszList;
    LPSTR  pszHtmlSourceA;
    LPTSTR pszHtmlSource;
    HANDLE hHtml;
    DWORD  dwHtmlFileSize,
           dwSizeRead;

    // read in the entire source of pszHtmlFile into a buffer
    if ((hHtml = CreateFile(pszHtmlFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
        if (!fCopy) { /* if (!fCopy) -- meaning delete */
            // Note. In this case the semantics of parameters are slightly different. So we try to go to the pszDestPath
            //       were image files that we are going to delete would live and see if HTML file itself lives there.
            PathCombine(szSrcFile, pszDestPath, PathFindFileName(pszHtmlFile));
            pszHtmlFile = szSrcFile;

            if ((hHtml = CreateFile(pszHtmlFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
                return;
        }
        else
            return;

    dwHtmlFileSize = GetFileSize(hHtml, NULL);
    if ((pszHtmlSourceA = (LPSTR)CoTaskMemAlloc(dwHtmlFileSize + 16)) == NULL) {
        CloseHandle(hHtml);
        return;
    }
    ZeroMemory(pszHtmlSourceA, dwHtmlFileSize + 16);

    if ((pszHtmlSource = (LPTSTR)CoTaskMemAlloc(StrCbFromCch(dwHtmlFileSize + 16))) == NULL) {
        CloseHandle(hHtml);
        CoTaskMemFree(pszHtmlSourceA);
        return;
    }
    ZeroMemory(pszHtmlSource, StrCbFromCch(dwHtmlFileSize + 16));

    ReadFile(hHtml, (LPVOID)pszHtmlSourceA, dwHtmlFileSize, &dwSizeRead, NULL);
    CloseHandle(hHtml);
    A2Tbuf(pszHtmlSourceA, pszHtmlSource, dwSizeRead);

    // copy the source path of pszHtmlFile to szSrcFile
    PathRemoveFileSpec(StrCpy(szSrcFile, pszHtmlFile)); // copy to itself in the worst case
    PathAddBackslash(szSrcFile);
    pszFileName = szSrcFile + StrLen(szSrcFile);        // remember the pos where the filename would get copied

    if (SUCCEEDED(buildImagesList(pszHtmlSource, &pszList))) {
        LPCTSTR pszImageFile;
        UINT    nLen;

        pszImageFile = pszList;
        if (pszImageFile != NULL) {
            while ((nLen = StrLen(pszImageFile)) > 0) {
                StrCpy(pszFileName, pszImageFile);

                if (fCopy) 
                    CopyFileToDirEx(szSrcFile, pszDestPath, pszSectionName, pszInsFile);
                else /* if (!fCopy) -- meaning delete */
                    DeleteFileInDir(szSrcFile, pszDestPath);

                pszImageFile += nLen + 1;
            }
            CoTaskMemFree(pszList);
        }

        // clean pszInsFile if deleting images
        if (!fCopy && pszSectionName != NULL && pszInsFile != NULL) {
            TCHAR szBuf[16];
            UINT  nNumFiles;

            nNumFiles = GetPrivateProfileInt(pszSectionName, IK_NUMFILES, 0, pszInsFile);
            WritePrivateProfileString(pszSectionName, IK_NUMFILES, NULL, pszInsFile);

            for (UINT i = 0; i < nNumFiles; i++) {
                wnsprintf(szBuf, countof(szBuf), FILE_TEXT, i);
                WritePrivateProfileString(pszSectionName, szBuf, NULL, pszInsFile);
            }

            // delete the section itself if became empty
            GetPrivateProfileSection(pszSectionName, szBuf, countof(szBuf), pszInsFile);
            if (szBuf[0] == TEXT('\0') && szBuf[1] == TEXT('\0'))
                WritePrivateProfileString(pszSectionName, NULL, NULL, pszInsFile);
        }
    }

    CoTaskMemFree(pszHtmlSource);
    CoTaskMemFree(pszHtmlSourceA);
}

HANDLE CreateNewFile(LPCTSTR pcszFileToCreate)
{
    TCHAR szPath[MAX_PATH];

    PathRemoveFileSpec(StrCpy(szPath, pcszFileToCreate));
    PathCreatePath(szPath);

    return CreateFile(pcszFileToCreate, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
}

DWORD FileSize(LPCTSTR pcszFile)
{
    DWORD dwFileSize = 0;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile;

    if (pcszFile == NULL  ||  *pcszFile == '\0')
        return dwFileSize;

    if ((hFile = FindFirstFile(pcszFile, &FindFileData)) != INVALID_HANDLE_VALUE)
    {
        // assumption here is that the size of the file doesn't exceed 4 gigs
        dwFileSize = FindFileData.nFileSizeLow;
        FindClose(hFile);
    }

    return dwFileSize;
}

BOOL DeleteFileInDir(LPCTSTR pcszFile, LPCTSTR pcszDir)
// pcszFile can contain wildcards
{
    TCHAR szFile[MAX_PATH];
    LPTSTR pszPtr;
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;
    BOOL fSuccess = TRUE;

    if (pcszFile == NULL || *pcszFile == TEXT('\0')  ||
        pcszDir  == NULL || *pcszDir  == TEXT('\0'))
        return FALSE;

    StrCpy(szFile, pcszDir);
    PathAddBackslash(szFile);
    pszPtr = szFile + StrLen(szFile);

    pcszFile = PathFindFileName(pcszFile);
    if (pcszFile == NULL)
        return FALSE;

    StrCpy(pszPtr, pcszFile);
    if ((hFindFile = FindFirstFile(szFile, &fileData)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                StrCpy(pszPtr, fileData.cFileName);
                // DeleteFile would fail if readonly and/or hidden and/or system
                // attributes are set; so set the attributes to NORMAL before deleting
                SetFileAttributes(szFile, FILE_ATTRIBUTE_NORMAL);
                fSuccess &= DeleteFile(szFile);
            }
        } while (FindNextFile(hFindFile, &fileData));

        FindClose(hFindFile);
    }
    
    return fSuccess;
}

void SetAttribAllEx(LPCTSTR pcszDir, LPCTSTR pcszFile, DWORD dwAtr, BOOL fRecurse)
{
    TCHAR szPath[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hFind;
    LPTSTR pszFile;

    if ((pcszDir == NULL) || (pcszFile == NULL) || (ISNULL(pcszDir)) || (ISNULL(pcszFile)))
        return;

    StrCpy(szPath, pcszDir);
    pszFile = PathAddBackslash(szPath);
    if ((StrLen(szPath) + StrLen(pcszFile)) < MAX_PATH)
        StrCpy(pszFile, pcszFile);

    if ((hFind = FindFirstFile( szPath, &fd)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if ((StrCmp(fd.cFileName, TEXT("."))) &&
                 (StrCmp(fd.cFileName, TEXT(".."))))
            {
                StrCpy(pszFile, fd.cFileName);
                if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    if (fRecurse)
                        SetAttribAllEx(szPath, pcszFile, dwAtr, TRUE);
                }
                else
                {
                    SetFileAttributes(szPath, dwAtr);
                }
            }
        }
        while (FindNextFile(hFind, &fd));

        FindClose(hFind);
    }

}

DWORD GetNumberOfFiles(LPCTSTR pcszFileName, LPCTSTR pcszDir)
// Return the number of pcszFileName files found in pcszDir.
// pcszFileName can contain wildcard characters
{
    DWORD nFiles = 0;
    TCHAR szPath[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hFind;

    if (pcszFileName == NULL  ||  pcszDir == NULL  ||  ISNULL(pcszFileName)  ||  ISNULL(pcszDir))
        return 0;

    PathCombine(szPath, pcszDir, pcszFileName);

    if ((hFind = FindFirstFile(szPath, &fd)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                continue;
            nFiles++;
        } while (FindNextFile(hFind, &fd));

        FindClose(hFind);
    }

    return nFiles;
}


BOOL GetFreeDiskSpace(LPCTSTR pcszDir, LPDWORD pdwFreeSpace, LPDWORD pdwFlags)
// Return the free disk space (in KBytes) in *pdwFreeSpace
{
    BOOL bRet = FALSE;
    DWORD nSectorsPerCluster, nBytesPerSector, nFreeClusters, nTotalClusters;
    TCHAR szDrive[8];

    if (pcszDir == NULL  ||  *pcszDir == '\0'  ||  *(pcszDir + 1) != ':')
        return FALSE;

    if (pdwFreeSpace == NULL)
        return FALSE;

    StrNCpy(szDrive, pcszDir, 3);
    PathAddBackslash(szDrive);
    if (GetDiskFreeSpace(szDrive, &nSectorsPerCluster, &nBytesPerSector, &nFreeClusters, &nTotalClusters))
    {
        // convert size to KBytes; assumption here is that the free space doesn't exceed 4096 gigs
        if ((*pdwFreeSpace = MulDiv(nFreeClusters, nSectorsPerCluster * nBytesPerSector, 1024)) != (DWORD) -1)
        {
            bRet = TRUE;

            if (pdwFlags != NULL)
            {
                *pdwFlags = 0;
                GetVolumeInformation(szDrive, NULL, 0, NULL, NULL, pdwFlags, NULL, 0);
            }
        }
    }

    return bRet;
}

DWORD FindSpaceRequired(LPCTSTR pcszSrcDir, LPCTSTR pcszFile, LPCTSTR pcszDstDir)
// Return the difference in size (in KBytes) of pcszFile (can contain wildcards)
// under pcszSrcDir and pcszDstDir (if specified)
{
    DWORD dwSizeReq = 0;
    TCHAR szSrcFile[MAX_PATH], szDstFile[MAX_PATH];
    LPTSTR pszSrcPtr = NULL, 
           pszDstPtr = NULL;
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;

    StrCpy(szSrcFile, pcszSrcDir);
    PathAddBackslash(szSrcFile);
    pszSrcPtr = szSrcFile + StrLen(szSrcFile);

    if (pcszDstDir != NULL)
    {
        StrCpy(szDstFile, pcszDstDir);
        PathAddBackslash(szDstFile);
        pszDstPtr = szDstFile + StrLen(szDstFile);
    }

    StrCpy(pszSrcPtr, pcszFile);
    if ((hFindFile = FindFirstFile(szSrcFile, &fileData)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                DWORD dwSrcSize, dwDstSize;

                // assumption here is that the size of the file doesn't exceed 4 gigs
                dwSrcSize = fileData.nFileSizeLow;
                dwDstSize = 0;

                if (pcszDstDir != NULL)
                {
                    StrCpy(pszDstPtr, fileData.cFileName);
                    dwDstSize = FileSize(szDstFile);
                }

                if (dwSrcSize >= dwDstSize)
                {
                    // divide the difference by 1024 (we are interested in KBytes)
                    dwSizeReq += ((dwSrcSize - dwDstSize) >> 10);
                    if (dwSrcSize > dwDstSize)
                        dwSizeReq++;            // increment by 1 to promote any fraction to a whole number
                }
            }
        } while (FindNextFile(hFindFile, &fileData));

        FindClose(hFindFile);
    }

    return dwSizeReq;
}


BOOL WriteStringToFileA(HANDLE hFile, LPCVOID pbBuf, DWORD cchSize)
{
    DWORD cbWritten;
    
    return WriteFile(hFile, pbBuf, cchSize, &cbWritten, NULL);
}

BOOL WriteStringToFileW(HANDLE hFile, LPCVOID pbBuf, DWORD cchSize)
{
    BOOL fRet = FALSE;
    LPVOID pbaBuf;
    DWORD cbSize, dwErr;

    // NOTE: we must use WideCharToMultiByte here because we don't know the exact format of
    //       the string

    pbaBuf = CoTaskMemAlloc(cchSize);
    if (pbaBuf == NULL)
        return FALSE;

    ZeroMemory(pbaBuf, cchSize);
    cbSize = WideCharToMultiByte(CP_ACP, 0, (LPWSTR)pbBuf, cchSize, (LPSTR)pbaBuf, cchSize, NULL, NULL);
    dwErr = GetLastError();

    // NOTE: check to see if we fail, in which case we might be dealing with DBCS chars and
    //       need to reallocate
    
    if (cbSize)
        fRet = WriteStringToFileA(hFile, pbaBuf, cbSize);
    else
    {
        if (dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            LPVOID pbaBuf2;

            cbSize = WideCharToMultiByte(CP_ACP, 0, (LPWSTR)pbBuf, cchSize, (LPSTR)pbaBuf, 0, NULL, NULL);
            pbaBuf2 = CoTaskMemRealloc(pbaBuf, cbSize);

            // need this second ptr because CoTaskMemRealloc doesn't free the old block if 
            // not enough mem for the new one

            if (pbaBuf2 != NULL)
            {
                pbaBuf = pbaBuf2;
                
                if (WideCharToMultiByte(CP_ACP, 0, (LPWSTR)pbBuf, cchSize, (LPSTR)pbaBuf, cbSize, NULL, NULL))
                    fRet = WriteStringToFileA(hFile, pbaBuf, cbSize); 
            }
        }
    }

    CoTaskMemFree(pbaBuf);

    return fRet;
}

BOOL ReadStringFromFileA(HANDLE hFile, LPVOID pbBuf, DWORD cchSize)
{
    DWORD cbRead;

    return ReadFile(hFile, pbBuf, cchSize, &cbRead, NULL);
}

BOOL ReadStringFromFileW(HANDLE hFile, LPVOID pbBuf, DWORD cchSize)
{
    BOOL fRet = FALSE;
    DWORD cbRead;
    LPSTR pszBuf;

    pszBuf = (LPSTR)CoTaskMemAlloc(cchSize);
    if (pszBuf == NULL)
        return FALSE;

    ZeroMemory(pszBuf, cchSize);
    fRet = ReadFile(hFile, (LPVOID)pszBuf, cchSize, &cbRead, NULL);
    ASSERT(cbRead <= cchSize);
    MultiByteToWideChar(CP_ACP, 0, pszBuf, cbRead, (LPWSTR)pbBuf, cbRead);

    CoTaskMemFree(pszBuf);  //bug 14002, forgot to free local buffer

    return fRet;
}

BOOL HasFileAttribute(DWORD dwFileAttrib, LPCTSTR pcszFile, LPCTSTR pcszDir /*= NULL*/)
// dwFileAttrib can accept only one flag.
{
    TCHAR szFile[MAX_PATH];
    DWORD dwAttrib;

    if (pcszFile == NULL || *pcszFile == TEXT('\0'))
        return FALSE;

    if (pcszDir != NULL && *pcszDir != TEXT('\0'))
    {
        PathCombine(szFile, pcszDir, pcszFile);
        pcszFile = szFile;
    }

    dwAttrib = GetFileAttributes(pcszFile);

    if ((dwAttrib != (DWORD) -1) && HasFlag(dwAttrib, dwFileAttrib))
        return TRUE;
    else
        return FALSE;
}

BOOL IsFileCreatable(LPCTSTR pcszFile)
// Return TRUE if pcszFile does not exist and can be created; otherwise, return FALSE
{
    BOOL fRet = FALSE;
    HANDLE hFile;

    if ((hFile = CreateFile(pcszFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
    {
        if ((hFile = CreateFile(pcszFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
        {
            fRet = TRUE;
            CloseHandle(hFile);
            DeleteFile(pcszFile);
        }
    }
    else
    {
        fRet = TRUE;
        CloseHandle(hFile);
    }

    return fRet;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation helpers routines (private)

#define DELIMS TEXT(" \t\r\n")
static const TCHAR s_szDelim[] = DELIMS;

#define FindNextWhitespace(psz)    \
    ((psz) + StrCSpn((psz), s_szDelim))

#define FindNextNonWhitespace(psz) \
    ((psz) + StrSpn((psz), s_szDelim))

static LPCTSTR findMatchingBracket(LPCTSTR pszHtml)
{
    LPCTSTR psz,
            pszBraket;
    UINT    nBalance;

    if (pszHtml == NULL || *pszHtml != TEXT('<'))
        return NULL;

    psz       = pszHtml + 1;
    pszBraket = NULL;
    nBalance  = 1;

    while (psz != NULL && nBalance > 0) {
        pszBraket = StrPBrk(psz, TEXT("<>"));
        if (pszBraket == NULL)
            return NULL;

        if (*pszBraket == TEXT('<'))
            nBalance++;
        else /* if (pszBraket == TEXT('>') */
            nBalance--;

        psz = pszBraket + 1;
    }

    return pszBraket;
}

static HRESULT findImgSrc(LPCTSTR *ppszHtml, LPTSTR pszSrcBuffer, LPUINT pcch)
{
    static const TCHAR c_szImg[] = TEXT("IMG");
    static const TCHAR c_szSrc[] = TEXT("SRC");

    LPCTSTR psz,
            pszLeft, pszRigth,
            pszEndImg, pszPrevSrc;

    if (ppszHtml == NULL)
        return E_POINTER;
    if (*ppszHtml == NULL)
        return E_INVALIDARG;

    if (pszSrcBuffer == NULL || pcch == NULL)
        return E_INVALIDARG;
    *pszSrcBuffer = TEXT('\0');

    // find "<[whitespace]img"
    psz       = *ppszHtml;
    *ppszHtml = NULL;
    do {
        if ((psz = pszLeft = StrChr(psz, TEXT('<'))) != NULL) {
            psz++;                              // psz is next after '<'
            psz = FindNextNonWhitespace(psz);
        }
    } while (psz != NULL && StrCmpNI(psz, c_szImg, countof(c_szImg)-1) != 0);
    if (psz == NULL)
        return E_FAIL;
    psz += countof(c_szImg)-1;                  // psz is next after "img"

    // found the right token => find the end of this token
    pszRigth = findMatchingBracket(pszLeft);
    if (pszRigth == NULL)
        return E_FAIL;
    pszEndImg = pszRigth + 1;

    // BUGBUG: Need to look for DYNSRC's to package as well

    pszPrevSrc = NULL;

    // find [whitespace]src[whitespace|=]
    while ((psz = StrStrI(psz, c_szSrc)), (psz != NULL && psz < pszRigth && psz != pszPrevSrc))
        if (StrChr(s_szDelim, *(psz - 1)) != NULL &&
            StrChr(DELIMS TEXT("="), *(psz + countof(c_szSrc)-1)) != NULL)
            break;
        else
            // IE/OE 65818
            // Make sure an IMG tag with no 'src' attribute, but a 'foosrc' attribute doesn't
            // cause an infinite loop
            pszPrevSrc = psz;

    if (psz == NULL)
        // No more SRC's in the rest of file
        return E_FAIL;        
    else if ((psz >= pszRigth) || (psz == pszPrevSrc))
    {
        // No SRC attrib for this tag, could be more in the file
        *ppszHtml = pszEndImg;
        return S_FALSE;
    }

    psz += countof(c_szSrc)-1;                  // psz is next after "src"

    // find '='
    psz = FindNextNonWhitespace(psz);
    if (psz == NULL || *psz != TEXT('='))
        return E_FAIL;
    psz++;

    psz = FindNextNonWhitespace(psz);
    if (psz == NULL)
        return E_FAIL;

    // psz is a winner
    if (*psz == TEXT('"')) {
        pszLeft  = psz + 1;
        pszRigth = StrChr(pszLeft, TEXT('"'));
    }
    else {
        pszLeft  = psz;
        pszRigth = FindNextWhitespace(pszLeft);
    }
    if (pszLeft == NULL || pszRigth == NULL)
        return E_FAIL;

    // ASSERT(pszRight >= pszLeft);
    if ((UINT)(pszRigth - pszLeft) > *pcch - 1) {
        *pcch = UINT(pszRigth - pszLeft);
        return E_OUTOFMEMORY;
    }

    *ppszHtml = pszEndImg;
    StrCpyN(pszSrcBuffer, pszLeft, INT(pszRigth - pszLeft) + 1);
    *pcch = UINT(pszRigth - pszLeft);

    return S_OK;
}

static HRESULT buildImagesList(LPCTSTR pszHtml, LPTSTR *ppszList)
{
    TCHAR   szImg[MAX_PATH];
    LPCTSTR pszCurHtml = pszHtml;
    LPTSTR  pszBlock, pszNewBlock,
            pszCurPos;
    UINT    nTotalLen,
            nLen;
    HRESULT hr;

    if (ppszList == NULL)
        return E_POINTER;
    *ppszList = NULL;

    pszBlock = (LPTSTR)CoTaskMemAlloc(StrCbFromCch(4 * MAX_PATH));
    if (pszBlock == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(pszBlock, StrCbFromCch(4 * MAX_PATH));

    pszCurPos = pszBlock;
    nTotalLen = 0;
    nLen      = countof(szImg);
    while (SUCCEEDED(hr = findImgSrc(&pszCurHtml, szImg, &nLen))) {
        // S_FALSE indicates an img with no simple SRC
        if (PathIsURL(szImg) || PathIsFullPath(szImg) || S_FALSE == hr)
            continue;

        if (StrCbFromCch(nLen+1 + nTotalLen+1) > CoTaskMemSize(pszBlock)) {
            pszNewBlock = (LPTSTR)CoTaskMemRealloc(pszBlock, StrCbFromCch(nTotalLen+1 + nLen+1 + 2*MAX_PATH));
            if (pszNewBlock == NULL) {
                CoTaskMemFree(pszBlock);
                return E_OUTOFMEMORY;
            }
            ZeroMemory(pszNewBlock + nTotalLen, StrCbFromCch(1 + nLen+1 + 2*MAX_PATH));

            pszBlock  = pszNewBlock;
            pszCurPos = pszBlock + nTotalLen;
        }

        StrCpy(pszCurPos, szImg);
        nTotalLen += nLen + 1;
        pszCurPos += nLen + 1;

        nLen = countof(szImg);
    }

    if (nTotalLen > 0) {
        if (StrCbFromCch(nTotalLen+1) < CoTaskMemSize(pszBlock)) {
            pszNewBlock = (LPTSTR)CoTaskMemRealloc(pszBlock, StrCbFromCch(nTotalLen+1));
            if (pszNewBlock != NULL && pszNewBlock != pszBlock)
                pszBlock = pszNewBlock;
        }

        *ppszList = pszBlock;
    }
    else
        CoTaskMemFree(pszBlock);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\ieakutil.inc ===
TARGETNAME = ieakutil

!include ..\..\common.inc
SOURCES_USED = $(SOURCES_USED) ..\..\common.inc


#----- Strandard goo -----
TARGETTYPE      = LIBRARY
CHICAGO_PRODUCT = 1


#----- C/C++ compilation settings -----
PRECOMPILED_INCLUDE = ..\precomp.h
INCLUDES            = \
    ..;               \
    $(INCLUDES)


#----- C/C++ source files (like you didn't know) -----
SOURCES = \
    ..\dlgctrl.cpp  \
    ..\str.cpp      \
    ..\path.cpp     \
    ..\reg.cpp      \
    ..\file.cpp     \
    ..\logitem.cpp  \
    ..\regins.cpp   \
    ..\ras.cpp      \
    ..\unicwrap.cpp \
    ..\misc.cpp     \
    ..\insio.cpp    \
    ..\dload.cpp    \
    ..\debug.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\insio.cpp ===
#include "precomp.h"

// this string is appended to key names to preserve their values when grayed out in 
// a tri-state dlg control so that the branding dll doesn't process the value

#define LEGACY_SUFFIX       TEXT("_Gray")

#define WritePrivateProfileStringEx(pszSection, pszKey, pszValue, pszIns) \
    (WritePrivateProfileString((pszSection), (pszKey), \
        ((pszValue) != NULL) ? (*(pszValue) != TEXT('\0') ? (pszValue) : NULL) : NULL, (pszIns)))


BOOL InsIsSectionEmpty(LPCTSTR pszSection, LPCTSTR pszFile)
{
    TCHAR szBuf[4];

    ASSERT(pszSection != NULL);
    return (0 == GetPrivateProfileSection(pszSection, szBuf, countof(szBuf), pszFile));
}

BOOL InsIsKeyEmpty(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszFile)
{
    TCHAR szBuf[2];

    ASSERT(pszSection != NULL && pszKey != NULL);
    return (0 == GetPrivateProfileString(pszSection, pszKey, TEXT(""), szBuf, countof(szBuf), pszFile));
}

BOOL InsKeyExists(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszFile)
{
    TCHAR szBuf[2];
    BOOL  fResult;

    ASSERT(pszSection != NULL && pszKey != NULL);
    fResult = TRUE;

    GetPrivateProfileString(pszSection, pszKey, TEXT("x"), szBuf, countof(szBuf), pszFile);
    if (szBuf[0] == TEXT('x')) {
        GetPrivateProfileString(pszSection, pszKey, TEXT("y"), szBuf, countof(szBuf), pszFile);
        fResult = (szBuf[0] != TEXT('y'));
        ASSERT(!fResult || szBuf[0] == TEXT('x'));
    }

    return fResult;
}


DWORD InsGetSubstString(LPCTSTR pszSection, LPCTSTR pszKey, LPTSTR pszValue, DWORD cchValue, LPCTSTR pszFile)
{
    LPTSTR pszLastPercent;
    DWORD  cch;

    cch = GetPrivateProfileString(pszSection, pszKey, TEXT(""), pszValue, cchValue, pszFile);
    if (*pszValue != TEXT('%'))
        return cch;

    pszLastPercent = StrChr(pszValue+1, TEXT('%'));
    if (pszLastPercent != NULL)
        *pszLastPercent = TEXT('\0');

    return GetPrivateProfileString(IS_STRINGS, pszValue+1, TEXT(""), pszValue, cchValue, pszFile);
}

BOOL InsGetYesNo(LPCTSTR pcszSec, LPCTSTR pcszKey, BOOL fDefault, LPCTSTR pcszInf)
{
    TCHAR szBuf[4];

    if (GetPrivateProfileString(pcszSec, pcszKey, TEXT(""), szBuf, countof(szBuf), pcszInf) == 0)
        return fDefault;

    return ((StrCmpI(szBuf, TEXT("Yes")) == 0) || (StrCmpI(szBuf, TEXT("1")) == 0));
}

void SetDlgItemTextFromIns(HWND hDlg, INT nIDDlgText, INT nIDDlgCheck, LPCTSTR lpAppName,
                           LPCTSTR lpKeyName, LPCTSTR pcszInsFile, LPCTSTR pcszServerFile, 
                           DWORD dwFlags)
{
    TCHAR szBuf[INTERNET_MAX_URL_LENGTH];
    BOOL fChecked;

    InsGetString(lpAppName, lpKeyName, szBuf, countof(szBuf), 
        pcszInsFile, pcszServerFile, &fChecked);
    
    if (HasFlag(dwFlags, INSIO_TRISTATE))
        SetDlgItemTextTriState(hDlg, nIDDlgText, nIDDlgCheck, szBuf, fChecked);
    else
        SetDlgItemText(hDlg, nIDDlgText, szBuf);
}

DWORD   InsGetString(LPCTSTR pszSection, LPCTSTR pszKey, LPTSTR pszValue, DWORD cchValue, LPCTSTR pszIns,
    LPCTSTR pszServerFile /* = NULL */, LPBOOL lpfChecked /* = NULL */)
{
    BOOL fChecked;
    DWORD dwRet = 0;

    if (lpfChecked != NULL)
        *lpfChecked = FALSE;

    if (NULL == pszValue)
        return 0;

    *pszValue = TEXT('\0');

    fChecked = InsKeyExists(pszSection, pszKey, pszIns);
    if (fChecked)
        dwRet = GetPrivateProfileString(pszSection, pszKey, TEXT(""), pszValue, cchValue, pszIns);

    else {
        if (NULL != pszServerFile)
            dwRet = SHGetIniString(pszSection, pszKey, pszValue, cchValue, pszServerFile);

        // legacy format for representing grayed out value in a file
        if (TEXT('\0') == *pszValue) {
            TCHAR szLegacyKey[MAX_PATH];

            StrCpy(szLegacyKey, pszKey);
            StrCat(szLegacyKey, LEGACY_SUFFIX);

            dwRet = GetPrivateProfileString(pszSection, szLegacyKey, TEXT(""), pszValue, cchValue, pszIns);
        }
    }

    if (lpfChecked != NULL)
        *lpfChecked = fChecked;

    return dwRet;
}


void WriteDlgItemTextToIns(HWND hDlg, INT nIDDlgText, INT nIDDlgCheck, LPCTSTR lpAppName,
                           LPCTSTR lpKeyName, LPCTSTR pcszInsFile, LPCTSTR pcszServerFile, 
                           DWORD dwFlags)
{
    TCHAR szBuf[INTERNET_MAX_URL_LENGTH];
    BOOL fChecked = TRUE;

    if (HasFlag(dwFlags, INSIO_TRISTATE))
        fChecked = GetDlgItemTextTriState(hDlg, nIDDlgText, nIDDlgCheck, szBuf, countof(szBuf));
    else
        GetDlgItemText(hDlg, nIDDlgText, szBuf, countof(szBuf));

    InsWriteString(lpAppName, lpKeyName, szBuf, pcszInsFile, fChecked, pcszServerFile, dwFlags);
}

void InsWriteString(LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpString, 
                    LPCTSTR pcszInsFile, BOOL fChecked /* = TRUE */, LPCTSTR pcszServerFile /* = NULL */,
                    DWORD dwFlags /* = 0 */)
{
    TCHAR szLegacyKey[MAX_PATH];
    BOOL fServerFile = (pcszServerFile != NULL);
    BOOL fFileFormat = (fServerFile && HasFlag(dwFlags, INSIO_PATH));

    StrCpy(szLegacyKey, lpKeyName);
    StrCat(szLegacyKey, LEGACY_SUFFIX);

    if (fServerFile && HasFlag(dwFlags, INSIO_SERVERONLY))
    {
        WritePrivateProfileString(lpAppName, lpKeyName, NULL, pcszInsFile);
        WritePrivateProfileString(lpAppName, szLegacyKey, NULL, pcszInsFile);
    }
    else
    {
        if (fChecked)
        {
            // cannot use Ex version for tristate because we must write an empty key

            if (HasFlag(dwFlags, INSIO_TRISTATE))
                WritePrivateProfileString(lpAppName, lpKeyName, 
                    fFileFormat ?  PathFindFileName(lpString) : lpString, pcszInsFile);
            else
                WritePrivateProfileStringEx(lpAppName, lpKeyName, 
                    fFileFormat ?  PathFindFileName(lpString) : lpString, pcszInsFile);
            WritePrivateProfileString(lpAppName, szLegacyKey, NULL, pcszInsFile);
        }
        else
        {
            WritePrivateProfileString(lpAppName, lpKeyName, NULL, pcszInsFile);
            
            // only write legacy key if we don't have the server-side file
            
            WritePrivateProfileStringEx(lpAppName, szLegacyKey, 
                (pcszServerFile == NULL) ? lpString : NULL, pcszInsFile);
        }
    }

    if (fServerFile)
        SHSetIniString(lpAppName, lpKeyName, lpString, pcszServerFile);
}


void InsWriteInt(LPCTSTR pszSection, LPCTSTR pszKey, int iValue, LPCTSTR pszIns)
{
    TCHAR szValue[33];

    wnsprintf(szValue, countof(szValue), TEXT("%u"), iValue);
    WritePrivateProfileString(pszSection, pszKey, szValue, pszIns);
}

int InsWriteQuotedString(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszVal, LPCTSTR pszFile)
{
    TCHAR szQuotedVal[MAX_STRING + 2],
          szSafeBuf[MAX_STRING];

    if (!pszVal)
    {
        WritePrivateProfileString(pszSection, pszKey, NULL, pszFile);
        return 0;
    }

    if (StrLen(pszVal) >= MAX_PATH) {
        StrCpyN(szSafeBuf, pszVal, countof(szSafeBuf));
        pszVal = szSafeBuf;
    }

    if (*pszVal != TEXT('\"'))
        wnsprintf(szQuotedVal, countof(szQuotedVal), TEXT("\"%s\""), pszVal);
    else
        StrCpy(szQuotedVal, pszVal);

    return WritePrivateProfileString(pszSection, pszKey, szQuotedVal, pszFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\logitem.cpp ===
#include "precomp.h"
#include "logitem.h"

// utility APIs declarations
// these two are identical to _strdate and _strtime respectively
LPCTSTR StrGetDate(LPTSTR pszDate);
LPCTSTR StrGetTime(LPTSTR pszTime);

// string constants
const TCHAR c_szCRLF[]       = TEXT("\r\n");
const TCHAR c_szSpace[]      = TEXT(" ");
const TCHAR c_szCommaSpace[] = TEXT(", ");
const TCHAR c_szColonColon[] = TEXT("::");
const TCHAR c_szColonSpace[] = TEXT(": ");
const TCHAR c_szLine[]       = TEXT("line %i");

/////////////////////////////////////////////////////////////////////////////
// CLogItem

TCHAR CLogItem::m_szModule[MAX_PATH];
BYTE  CLogItem::m_bStep = 4;

CLogItem::CLogItem(DWORD dwFlags /*= LIF_DEFAULT*/, LPBOOL pfLogLevels /*= NULL*/, UINT cLogLevels /*= 0*/)
{
    if (m_szModule[0] == TEXT('\0')) {
        GetModuleFileName(GetModuleHandle(g_szModule), m_szModule, countof(m_szModule));
        CharLower(m_szModule);
    }

    m_nAbsOffset = 0;
    m_iRelOffset = 0;
    m_nLine      = 0;

    m_rgfLogLevels = NULL;
    m_cLogLevels   = cLogLevels;
    if (pfLogLevels != NULL) {
        ASSERT(cLogLevels > 0);

        m_rgfLogLevels = new BOOL[m_cLogLevels];
        memcpy(m_rgfLogLevels, pfLogLevels, m_cLogLevels * sizeof(BOOL));
    }
    else
        ASSERT(cLogLevels == 0);

    m_nLevel = 0;

    SetFlags(dwFlags);
}

CLogItem::~CLogItem()
{
    delete[] m_rgfLogLevels;
}


/////////////////////////////////////////////////////////////////////////////
// CLogItem operations

LPCTSTR WINAPIV CLogItem::Log(int iLine, LPCTSTR pszFormat ...)
{
    TCHAR   szFormat[3 * MAX_PATH],
            szBuffer[MAX_PATH];
    LPCTSTR pszAux;
    UINT    nLen, nAuxLen,
            cchCRLF;
    BOOL    fPreviousToken;

    szFormat[0] = TEXT('\0');
    nLen = 0;

    if (hasFlag(LIF_NONE))
        return NULL;

    if (m_rgfLogLevels != NULL && m_nLevel < m_cLogLevels) {
        ASSERT((int)m_nLevel >= 0);

        if (!m_rgfLogLevels[m_nLevel])
            return NULL;
    }

    // prepend any CRLF at the beginning
    cchCRLF = StrSpn(pszFormat, c_szCRLF);
    if (cchCRLF > 0) {
        // special case
        if (cchCRLF >= (UINT)StrLen(pszFormat)) {
            StrCpy(m_szMessage, pszFormat);

            if (hasFlag(LIF_DUPLICATEINODS))
                OutputDebugString(m_szMessage);

            return m_szMessage;
        }

        StrCpyN(&szFormat[nLen], pszFormat, cchCRLF + 1);
        nLen += cchCRLF;

        pszFormat += cchCRLF;
    }

    fPreviousToken = FALSE;
    if (hasFlag(LIF_DATE)) {
        StrGetDate(szBuffer);
        StrCpy(&szFormat[nLen], szBuffer);
        nLen += StrLen(szBuffer);

        fPreviousToken = TRUE;
    }

    if (hasFlag(LIF_TIME)) {
        if (fPreviousToken) {
            StrCpy(&szFormat[nLen], c_szSpace);
            nLen += countof(c_szSpace)-1;
        }

        StrGetTime(szBuffer);
        StrCpy(&szFormat[nLen], szBuffer);
        nLen += StrLen(szBuffer);

        fPreviousToken = TRUE;
    }

    if (fPreviousToken) {
        StrCpy(&szFormat[nLen], c_szSpace);
        nLen += countof(c_szSpace)-1;
    }
    if ((m_nAbsOffset-1 + m_iRelOffset) > 0) {
        ASSERT((m_nAbsOffset-1 + m_iRelOffset) * m_bStep < countof(szBuffer));
        for (UINT i = 0; i < (m_nAbsOffset-1 + m_iRelOffset) * m_bStep; i++)
            szBuffer[i] = TEXT(' ');

        StrCpy(&szFormat[nLen], szBuffer);
        nLen += i-1;
    }

    fPreviousToken = FALSE;
    if (hasFlag(LIF_MODULE_ALL)) {
        pszAux = szBuffer;
        if (!hasFlag(LIF_MODULEPATH))
            makeRawFileName(m_szModule, szBuffer, countof(szBuffer));
        else
            pszAux = m_szModule;                // should be lowercase already

        StrCpy(&szFormat[nLen], pszAux);
        nLen += StrLen(pszAux);

        fPreviousToken = TRUE;
    }

    if (hasFlag(LIF_FILE_ALL)) {
        if (fPreviousToken) {
            StrCpy(&szFormat[nLen], c_szCommaSpace);
            nLen += countof(c_szCommaSpace)-1;
        }

        if (!hasFlag(LIF_FILEPATH))
            makeRawFileName(m_szFile, szBuffer, countof(szBuffer));
        else {
            StrCpy(szBuffer, m_szFile);
            CharLower(szBuffer);
        }

        StrCpy(&szFormat[nLen], szBuffer);
        nLen += StrLen(szBuffer);

        fPreviousToken = TRUE;
    }

    if (hasFlag(LIF_CLASS) && hasFlag(LIF_CLASS2)) {
        if (fPreviousToken) {
            StrCpy(&szFormat[nLen], c_szCommaSpace);
            nLen += countof(c_szCommaSpace)-1;
        }

        StrCpy(&szFormat[nLen], m_szClass);
        nLen += StrLen(m_szClass);

        fPreviousToken = TRUE;
    }

    if (hasFlag(LIF_FUNCTION)) {
        if (fPreviousToken) {
            pszAux = (hasFlag(LIF_CLASS) && hasFlag(LIF_CLASS2)) ?
                c_szColonColon : c_szCommaSpace;

            StrCpy(&szFormat[nLen], pszAux);
            nLen += StrLen(pszAux);
        }

        StrCpy(&szFormat[nLen], m_szFunction);
        nLen += StrLen(m_szFunction);

        fPreviousToken = TRUE;
    }

    if (hasFlag(LIF_LINE) && iLine > 0) {
        if (fPreviousToken) {
            StrCpy(&szFormat[nLen], c_szCommaSpace);
            nLen += countof(c_szCommaSpace)-1;
        }

        nAuxLen = wnsprintf(szBuffer, countof(szBuffer), c_szLine, iLine);
        StrCpy(&szFormat[nLen], szBuffer);
        nLen += nAuxLen;

        fPreviousToken = TRUE;
    }

    if (pszFormat == NULL)
        StrCpy(m_szMessage, szFormat);
        // nLen stays the same
    else {
        if (fPreviousToken) {
            StrCpy(&szFormat[nLen], c_szColonSpace);
            nLen += countof(c_szColonSpace)-1;
        }

        StrCpy(&szFormat[nLen], pszFormat);

        va_list  arglist;
        va_start(arglist, pszFormat);
        nAuxLen = wvnsprintf(m_szMessage, countof(m_szMessage), szFormat, arglist);
        va_end(arglist);

        nLen = nAuxLen;
    }

    if (hasFlag(LIF_APPENDCRLF))
        StrCpy(&m_szMessage[nLen], c_szCRLF);

    if (hasFlag(LIF_DUPLICATEINODS))
        OutputDebugString(m_szMessage);

    return m_szMessage;
}

CLogItem::operator LPCTSTR() const
{
    return m_szMessage;
}


/////////////////////////////////////////////////////////////////////////////
// CLogItem implementation helper routines

LPCTSTR CLogItem::makeRawFileName(LPCTSTR pszPath, LPTSTR pszFile, UINT cchFile)
{
    TCHAR   szBuffer[MAX_PATH];
    LPCTSTR pszRawName;

    if (pszFile == NULL || cchFile == 0)
        return NULL;
    *pszFile = TEXT('\0');

    if (pszPath == NULL || StrLen(pszPath) == 0)
        return NULL;

    pszRawName = PathFindFileName(pszPath);
    ASSERT(StrLen(pszRawName) > 0);
    StrCpy(szBuffer, pszRawName);
    CharLower(szBuffer);

    if (cchFile <= (UINT)StrLen(szBuffer))
        return NULL;

    StrCpy(pszFile, szBuffer);
    return pszFile;
}

BOOL CLogItem::setFlag(DWORD dwMask, BOOL fSet /*= TRUE*/)
{
    BOOL fIsFlag = ((m_dwFlags & dwMask) != 0L);

    if (fIsFlag == fSet)
        return FALSE;

    if (!fIsFlag && fSet)
        m_dwFlags |= dwMask;

    else {
        ASSERT(fIsFlag && !fSet);
        m_dwFlags &= ~dwMask;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Utility functions

// Note. pszDate must point to the buffer of at least 11 characters.
LPCTSTR StrGetDate(LPTSTR pszDate)
{
    SYSTEMTIME dt;
    UINT       nMonth, nDay, nYear;

    GetLocalTime(&dt);
    nMonth = dt.wMonth;
    nDay   = dt.wDay;
    nYear  = dt.wYear;

    *(pszDate + 2) = *(pszDate + 5) = TEXT('/');
    *(pszDate + 10) = TEXT('\0');

    *(pszDate + 0) = (TCHAR)(nMonth / 10 + TEXT('0'));
    *(pszDate + 1) = (TCHAR)(nMonth % 10 + TEXT('0'));

    *(pszDate + 3) = (TCHAR)(nDay / 10 + TEXT('0'));
    *(pszDate + 4) = (TCHAR)(nDay % 10 + TEXT('0'));

    *(pszDate + 6) = (TCHAR)(((nYear / 1000) % 10) + TEXT('0'));
    *(pszDate + 7) = (TCHAR)(((nYear / 100)  % 10) + TEXT('0'));
    *(pszDate + 8) = (TCHAR)(((nYear / 10)   % 10) + TEXT('0'));
    *(pszDate + 9) = (TCHAR)(((nYear / 1)    % 10) + TEXT('0'));

    return pszDate;
}

// Note. pszTime must point to the buffer of at least 9 characters.
LPCTSTR StrGetTime(LPTSTR pszTime)
{
    SYSTEMTIME dt;
    int nHours, nMinutes, nSeconds;

    GetLocalTime(&dt);
    nHours   = dt.wHour;
    nMinutes = dt.wMinute;
    nSeconds = dt.wSecond;

    *(pszTime + 2) = *(pszTime + 5) = TEXT(':');
    *(pszTime + 8) = TEXT('\0');

    *(pszTime + 0) = (TCHAR)(nHours / 10 + TEXT('0'));
    *(pszTime + 1) = (TCHAR)(nHours % 10 + TEXT('0'));

    *(pszTime + 3) = (TCHAR)(nMinutes / 10 + TEXT('0'));
    *(pszTime + 4) = (TCHAR)(nMinutes % 10 + TEXT('0'));

    *(pszTime + 6) = (TCHAR)(nSeconds / 10 + TEXT('0'));
    *(pszTime + 7) = (TCHAR)(nSeconds % 10 + TEXT('0'));

    return pszTime;
}

//----- Testing the stuff -----
/*
struct Test
{
    Test();
    void foo();
    void bar();
};

static Test t;

Test::Test()
{   MACRO_LI_Prolog(Test, Test)
    MACRO_LI_SetFlags(MACRO_LI_GetFlags() | LIF_DUPLICATEINODS);

    LI0("Calling foo and then bar");
    foo();
    LI0("foo returned");
    bar();
    LI0("bar returned");
}

void Test::foo()
{   MACRO_LI_Prolog(Test, foo);

    LI0("Calling bar");
    bar();
    LI0("bar returned");
}

void Test::bar()
{   MACRO_LI_Prolog(Test, bar);

    LI0("No arguments");
    LI1("One argument: %d", 2*2);
    LI2("Two arguments: %i, %s", 15, TEXT("nyah"));
    LI3("Three arguments: %d, %s, %x", 5, TEXT("the bar it is"), 0x80FF);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\newcur.h ===
#include <windows.h>

/////////////////////////////////////////////////////////////////////////////
// CNewCursor

class CNewCursor
{
// Constructors
public:
    CNewCursor(LPCTSTR pszID = NULL)
        { m_hCursor = NULL; Push(pszID); }
    CNewCursor(UINT nID)
        { m_hCursor = NULL; Push(nID); }
    ~CNewCursor()
        { Pop(); }

// Operations
public:
    void Push(LPCTSTR pszID)
    {
        Pop();

        if (pszID != NULL)
            m_hCursor = SetCursor(LoadCursor(NULL, pszID));
    }

    void Push(UINT nID)
        { Push(MAKEINTRESOURCE(nID)); }

    void Pop()
    {
        if (m_hCursor != NULL)
            SetCursor(m_hCursor);

        m_hCursor = NULL;
    }

// Attributes
protected:
    // implementation data helpers
    HCURSOR m_hCursor;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\logitem.h ===
#ifndef _LOGITEM_H_
#define _LOGITEM_H_

// determine the number of elements in array (not bytes)
#ifndef countof
#define countof(array) (sizeof(array)/sizeof(array[0]))
#endif


#define LIF_NONE            0x80000000
#define LIF_DATE            0x00000001
#define LIF_TIME            0x00000002
#define LIF_DATETIME        0x00000003
#define LIF_MODULE          0x00000004
#define LIF_MODULEPATH      0x00000008
#define LIF_MODULE_ALL      0x0000000C
#define LIF_FILE            0x00000010
#define LIF_FILEPATH        0x00000020
#define LIF_FILE_ALL        0x00000030
#define LIF_CLASS           0x00000040
#define LIF_FUNCTION        0x00000080
#define LIF_LINE            0x00000100
#define LIF_DUPLICATEINODS  0x00000200
#define LIF_APPENDCRLF      0x00000400
#define LIF_DEFAULT         0x000005D0

// private for context switch from C to C++ and back again
#define LIF_CLASS2 0x01000000


/////////////////////////////////////////////////////////////////////////////
// Initialization

class  CLogItem;                                // forward declaration
extern CLogItem g_li;

#define MACRO_LI_Initialize()                                               \
    CLogItem g_li                                                           \

#define MACRO_LI_Initialize2(dwFlags)                                       \
    CLogItem g_li(dwFlags)                                                  \

#define MACRO_LI_InitializeEx(dwFlags, pfLevels, cLevels)                   \
    CLogItem g_li(dwFlags, pfLevels, cLevels)                               \


/////////////////////////////////////////////////////////////////////////////
// Helpers for individual CLogItem attributes

// file
#define MACRO_LI_SmartFile()                                                \
    CSmartItem<LPCTSTR> siFile(g_li.m_szFile, TEXT(__FILE__))               \

#define MACRO_LI_SmartFileEx(dwItems)                                       \
    CSmartItemEx<LPCTSTR> siFileEx(dwItems, LIF_FILE_ALL,                   \
        g_li.m_szFile, TEXT(__FILE__))                                      \

// class
#define MACRO_LI_SmartClass(Class)                                          \
    CSmartItem<LPCTSTR> siClass(g_li.m_szClass, TEXT(#Class))               \

#define MACRO_LI_SmartClassEx(dwItems, Class)                               \
    CSmartItemEx<LPCTSTR> siClassEx(dwItems, LIF_CLASS,                     \
        g_li.m_szClass, TEXT(#Class))                                       \

// function
#define MACRO_LI_SmartFunction(Function)                                    \
    CSmartItem<LPCTSTR> siFunction(g_li.m_szFunction, TEXT(#Function))      \

#define MACRO_LI_SmartFunctionEx(dwItems, Function)                         \
    CSmartItemEx<LPCTSTR> siFunctionEx(dwItems, LIF_FUNCTION,               \
        g_li.m_szFunction, TEXT(#Function))                                 \

// level, indent and flags
#define MACRO_LI_SmartLevel()                                               \
    CSmartItem<UINT> siLevel(g_li.m_nLevel, g_li.m_nLevel+1)                \

#define MACRO_LI_SmartIndent()                                              \
    CSmartItem<UINT> siIndent(g_li.m_nAbsOffset, g_li.m_nAbsOffset+1)       \

#define MACRO_LI_SmartFlags(dwFlags)                                        \
    CSmartItem<DWORD> siFlags(g_li.m_dwFlags, dwFlags)                      \

// wrappers to manipulate flags, offset and relative offset
#define MACRO_LI_SmartAddFlags(dwFlag)                                      \
    CSmartItem<DWORD> siAddFlags(g_li.m_dwFlags, g_li.m_dwFlags |  (dwFlag))\

#define MACRO_LI_SmartRemoveFlags(dwFlag)                                   \
    CSmartItem<DWORD> siRemFlags(g_li.m_dwFlags, g_li.m_dwFlags & ~(dwFlag))\

#define MACRO_LI_Offset(iOffset)                                            \
    CSmartItem<int> siOffset(g_li.m_iRelOffset, g_li.m_iRelOffset + iOffset)\

#define MACRO_LI_SmartRelativeOffset(iRelOffset)                            \
    CSmartItem<int> siRelOffset(g_li.m_iRelOffset, iRelOffset)              \

// private for context switch from C to C++ and back again
#define MACRO_LI_AddClass2()                                                \
    CSmartItem<DWORD> siAddClass2(g_li.m_dwFlags,                           \
        g_li.m_dwFlags | (LIF_CLASS2))                                      \

#define MACRO_LI_RemClass2()                                                \
    CSmartItem<DWORD> siRemClass2(g_li.m_dwFlags,                           \
        g_li.m_dwFlags & ~(LIF_CLASS2))                                     \


/////////////////////////////////////////////////////////////////////////////
// Prologs

// rarely used standalone, is the foundation for the rest
#define MACRO_LI_PrologSameFunction()                                       \
    MACRO_LI_SmartIndent();                                                 \
    MACRO_LI_SmartLevel();                                                  \

//----- More macros, a little more lean -------------------------------------

// for protected or private functions in the same file as caller
#define MACRO_LI_PrologSameClass(Function)                                  \
    MACRO_LI_SmartFunction(Function);                                       \
    MACRO_LI_PrologSameFunction();                                          \

// for protected or private functions in a different file than caller
#define MACRO_LI_PrologSameClass2(Function)                                 \
    MACRO_LI_SmartFile();                                                   \
    MACRO_LI_SmartFunction(Function);                                       \
    MACRO_LI_PrologSameFunction();                                          \

// for C APIs across files
#define MACRO_LI_PrologC(Function)                                          \
    MACRO_LI_RemClass2();                                                   \
                                                                            \
    MACRO_LI_SmartFile();                                                   \
    MACRO_LI_SmartFunction(Function);                                       \
    MACRO_LI_PrologSameFunction();                                          \

// for C APIs with no prototype in the (respective) *.h file
#define MACRO_LI_PrologSameFileC(Function)                                  \
    MACRO_LI_RemClass2();                                                   \
                                                                            \
    MACRO_LI_SmartFunction(Function);                                       \
    MACRO_LI_PrologSameFunction();                                          \

// for things like friends (two friend classes in one file and methods
// of one class are calling private or protected methods of the other, so
// these private or protected methods can have this prolog)
#define MACRO_LI_PrologSameFile(Class, Function)                            \
    MACRO_LI_AddClass2();                                                   \
                                                                            \
    MACRO_LI_SmartClass(Class);                                             \
    MACRO_LI_PrologSameClass(Function);                                     \

// general version, common case
#define MACRO_LI_Prolog(Class, Function)                                    \
    MACRO_LI_SmartFile();                                                   \
    MACRO_LI_PrologSameFile(Class, Function);                               \

//----- Less macros, a little more overhead ---------------------------------

#define PIF_SAMEFUNC   0x00000000
#define PIF_SAMECLASS  0x00000080
#define PIF_SAMECLASS2 0x000000B0
#define PIF_STD_C      0x00000090
#define PIF_SAMEFILE_C 0x000000B0
#define PIF_SAMEFILE   0x000000C0
#define PIF_STD        0x000000F0

#define MACRO_LI_PrologEx(dwItems, Class, Function)                         \
    MACRO_LI_AddClass2();                                                   \
                                                                            \
    MACRO_LI_SmartFileEx(dwItems);                                          \
    MACRO_LI_SmartClassEx(dwItems, Class);                                  \
    MACRO_LI_SmartFunctionEx(dwItems, Function);                            \
    MACRO_LI_PrologSameFunction();                                          \

#define MACRO_LI_PrologSameClassEx(dwItems, Function)                       \
    MACRO_LI_AddClass2();                                                   \
                                                                            \
    MACRO_LI_SmartFileEx(dwItems);                                          \
    MACRO_LI_SmartFunctionEx(dwItems, Function);                            \
    MACRO_LI_PrologSameFunction();                                          \

#define MACRO_LI_PrologEx_C(dwItems, Function)                              \
    MACRO_LI_RemClass2();                                                   \
                                                                            \
    MACRO_LI_SmartFileEx(dwItems);                                          \
    MACRO_LI_SmartFunctionEx(dwItems, Function);                            \
    MACRO_LI_PrologSameFunction();                                          \


/////////////////////////////////////////////////////////////////////////////
// Logging

#define LI0(pszFormat)                                                      \
    g_li.Log(__LINE__, pszFormat)                                           \

#define LI1(pszFormat, arg1)                                                \
    g_li.Log(__LINE__, pszFormat, arg1)                                     \

#define LI2(pszFormat, arg1, arg2)                                          \
    g_li.Log(__LINE__, pszFormat, arg1, arg2)                               \

#define LI3(pszFormat, arg1, arg2, arg3)                                    \
    g_li.Log(__LINE__, pszFormat, arg1, arg2, arg3)                         \


/////////////////////////////////////////////////////////////////////////////
// Additional helpers

#define MACRO_LI_GetFlags()                                                 \
    g_li.GetFlags()                                                         \

#define MACRO_LI_SetFlags(dwFlags)                                          \
    g_li.SetFlags(dwFlags)                                                  \

#define MACRO_LI_GetRelativeOffset()                                        \
    (const int&)g_li.m_iRelOffset                                           \

#define MACRO_LI_SetRelativeOffset(iRelOffset)                              \
    g_li.m_iRelOffset = iRelOffset                                          \


/////////////////////////////////////////////////////////////////////////////
// CLogItem declaration

class CLogItem
{
// Constructors
public:
    CLogItem(DWORD dwFlags = LIF_DEFAULT, LPBOOL pfLogLevels = NULL, UINT cLogLevels = 0);

// Attributes
public:
    TCHAR m_szMessage[3 * MAX_PATH];

    // offset management
    UINT        m_nAbsOffset;
    int         m_iRelOffset;
    static BYTE m_bStep;

    // module, path, file, class, function, line of code
    LPCTSTR m_szFile;
    LPCTSTR m_szClass;
    LPCTSTR m_szFunction;
    UINT    m_nLine;

    // customization
    DWORD m_dwFlags;
    UINT  m_nLevel;

// Operations
public:
    void  SetFlags(DWORD dwFlags)
        { m_dwFlags = dwFlags; }
    DWORD GetFlags() const
        { return m_dwFlags; }

    virtual LPCTSTR WINAPIV Log(int iLine, LPCTSTR pszFormat ...);

// Overridables
public:
    virtual operator LPCTSTR() const;

// Implementation
public:
    virtual ~CLogItem();

protected:
    // implementation data helpers
    static TCHAR m_szModule[MAX_PATH];

    PBOOL m_rgfLogLevels;
    UINT  m_cLogLevels;

    // implementation helper routines
    LPCTSTR makeRawFileName(LPCTSTR pszPath, LPTSTR pszFile, UINT cchFile);

    BOOL setFlag(DWORD dwMask, BOOL fSet = TRUE);
    BOOL hasFlag(DWORD dwMask) const
        { return hasFlag(m_dwFlags, dwMask); }
    static BOOL hasFlag(DWORD dwFlags, DWORD dwMask)
        { return ((dwFlags & dwMask) != 0L); }
};


// Note. (andrewgu) Right now there seems to be no need to create a special
//       CSmartItem<TCHAR> and CSmartItemEx<TCHAR> classes that would
//       store internally the string passed into it. Also, the parameter
//       isn't necessary TCHAR it's just a placeholder for an idea.
/////////////////////////////////////////////////////////////////////////////
// CSmartItem definition

template <class T> class CSmartItem
{
public:
    CSmartItem(T& tOld, const T& tNew)
    {
        m_pitem = NULL;

        if (tOld == tNew)
            return;

        m_item = tOld; m_pitem = &tOld; tOld = tNew;
    }

    ~CSmartItem()
    {
        if (m_pitem == NULL)
            return;

        *m_pitem = m_item; m_pitem = NULL;
    }

    // Attributes
    T *m_pitem,
       m_item;

protected:
    // disable the copy constructor and assignment operator
    CSmartItem(const CSmartItem&)
        {}
    const CSmartItem& operator=(const CSmartItem&)
        { return *this; }
};

/////////////////////////////////////////////////////////////////////////////
// CSmartItemEx definition

template <class T> class CSmartItemEx
{
public:
    CSmartItemEx(DWORD dwAllItems, DWORD dwThisItem, T& tOld, const T& tNew)
    {
        m_pitem   = NULL;
        m_fNoSwap = ((dwAllItems & dwThisItem) == 0);

        if (m_fNoSwap)
            return;

        if (tOld == tNew)
            return;

        m_item = tOld; m_pitem = &tOld; tOld = tNew;
    }

    ~CSmartItemEx()
    {
        if (m_fNoSwap)
            return;

        if (m_pitem == NULL)
            return;

        *m_pitem = m_item; m_pitem = NULL;
    }

    // Attributes
    T *m_pitem,
       m_item;

protected:
    // disable the copy constructor and assignment operator
    CSmartItemEx(const CSmartItem<T>&)
        {}
    const CSmartItemEx<T>& operator=(const CSmartItemEx<T>&)
        { return *this; }

    // implementation data helpers
    BOOL m_fNoSwap;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\rashelp.h ===
#ifndef _RASHELP_H_
#define _RASHELP_H_

#include <ras.h>
#include <raserror.h>

BOOL RasIsInstalled();

//----- RAS function prototypes -----
// NOTE: (andrewgu) W versions of RAS apis are not implemented on Win9x platforms.

// used by CloseRasConnections() in the branding dll
typedef DWORD (WINAPI* RASENUMCONNECTIONSA)(LPRASCONNA, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* RASHANGUPA)(HRASCONN);
typedef DWORD (WINAPI* RASGETCONNECTSTATUSA)(HRASCONN, LPRASCONNSTATUSA);

// used by ProcessConnectionSettingsDeletion() in the branding dll
typedef DWORD (WINAPI* RASENUMENTRIESA)(LPCSTR,  LPCSTR,  LPRASENTRYNAMEA, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* RASENUMENTRIESW)(LPCWSTR, LPCWSTR, LPRASENTRYNAMEW, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* RASDELETEENTRYA)(LPCSTR,  LPCSTR);
typedef DWORD (WINAPI* RASDELETEENTRYW)(LPCWSTR, LPCWSTR);

// used by ProcessConnectionSettings() and lcy50_ProcessConnectionSettings() in the branding dll
typedef DWORD (WINAPI* RASENUMDEVICESA)(LPRASDEVINFOA, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* RASENUMDEVICESW)(LPRASDEVINFOW, LPDWORD, LPDWORD);

// used by ImportConnectSet() in the engine dll
typedef DWORD (WINAPI* RASGETENTRYPROPERTIESA)(LPCSTR,  LPCSTR,  LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD (WINAPI* RASGETENTRYPROPERTIESW)(LPCWSTR, LPCWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD);

// used by ImportConnectSet() in the engine dll
typedef DWORD (WINAPI* RASGETENTRYDIALPARAMSA)(LPCSTR,  LPRASDIALPARAMSA, LPBOOL);
typedef DWORD (WINAPI* RASGETENTRYDIALPARAMSW)(LPCWSTR, LPRASDIALPARAMSW, LPBOOL);

// used by lcy50_ProcessConnectionSettings() and importRasSettings() in the branding dll
typedef DWORD (WINAPI* RASSETENTRYPROPERTIESA)(LPCSTR,  LPCSTR,  LPRASENTRYA, DWORD, LPBYTE, DWORD);
typedef DWORD (WINAPI* RASSETENTRYPROPERTIESW)(LPCWSTR, LPCWSTR, LPRASENTRYW, DWORD, LPBYTE, DWORD);

// used by importRasCredentialsSettings() in the branding dll
typedef DWORD (WINAPI* RASSETENTRYDIALPARAMSA)(LPCSTR,  LPRASDIALPARAMSA, BOOL);
typedef DWORD (WINAPI* RASSETENTRYDIALPARAMSW)(LPCWSTR, LPRASDIALPARAMSW, BOOL);

//----- Global RAS function pointers -----
extern RASENUMCONNECTIONSA    g_pfnRasEnumConnectionsA;
extern RASHANGUPA             g_pfnRasHangupA;
extern RASGETCONNECTSTATUSA   g_pfnRasGetConnectStatusA;

extern RASENUMENTRIESA        g_pfnRasEnumEntriesA;
extern RASENUMENTRIESW        g_pfnRasEnumEntriesW;
extern RASDELETEENTRYA        g_pfnRasDeleteEntryA;
extern RASDELETEENTRYW        g_pfnRasDeleteEntryW;

extern RASENUMDEVICESA        g_pfnRasEnumDevicesA;
extern RASENUMDEVICESW        g_pfnRasEnumDevicesW;
extern RASGETENTRYPROPERTIESA g_pfnRasGetEntryPropertiesA;
extern RASGETENTRYPROPERTIESW g_pfnRasGetEntryPropertiesW;
extern RASGETENTRYDIALPARAMSA g_pfnRasGetEntryDialParamsA;
extern RASGETENTRYDIALPARAMSW g_pfnRasGetEntryDialParamsW;
extern RASSETENTRYPROPERTIESA g_pfnRasSetEntryPropertiesA;
extern RASSETENTRYPROPERTIESW g_pfnRasSetEntryPropertiesW;
extern RASSETENTRYDIALPARAMSA g_pfnRasSetEntryDialParamsA;
extern RASSETENTRYDIALPARAMSW g_pfnRasSetEntryDialParamsW;

//----- RasPrepareApis -----
#define RPA_UNLOAD                 0x00000000

#define RPA_RASENUMCONNECTIONSA    0x00000001
#define RPA_RASHANGUPA             0x00000002
#define RPA_RASGETCONNECTSTATUSA   0x00000004

#define RPA_RASENUMENTRIESA        0x00000008
#define RPA_RASENUMENTRIESW        0x00000010
#define RPA_RASDELETEENTRYA        0x00000020
#define RPA_RASDELETEENTRYW        0x00000040

#define RPA_RASENUMDEVICESA        0x00000080
#define RPA_RASENUMDEVICESW        0x00000100
#define RPA_RASGETENTRYPROPERTIESA 0x00000200
#define RPA_RASGETENTRYPROPERTIESW 0x00000400
#define RPA_RASGETENTRYDIALPARAMSA 0x00000800
#define RPA_RASGETENTRYDIALPARAMSW 0x00001000
#define RPA_RASSETENTRYPROPERTIESA 0x00002000
#define RPA_RASSETENTRYPROPERTIESW 0x00004000
#define RPA_RASSETENTRYDIALPARAMSA 0x00008000
#define RPA_RASSETENTRYDIALPARAMSW 0x00010000
BOOL    RasPrepareApis(DWORD dwApiFlags, BOOL fLoad = TRUE);

//----- Wrappers and miscellaneous helpers -----
// RWM stands for Ras Wrappers Mode
#define RWM_FORCE_A 0x00000001
#define RWM_FORCE_W 0x00000002
#define RWM_RUNTIME 0x00000004

typedef BOOL (*RASENUMPROCA)(PCSTR  pszNameA, LPARAM lParam);
typedef BOOL (*RASENUMPROCW)(PCWSTR pszNameW, LPARAM lParam);

BOOL  RasEnumEntriesCallback(PCTSTR pszPhonebook, PVOID pfnEnumAorW, LPARAM lParam,
    DWORD dwMode = RWM_RUNTIME);

DWORD RasEnumConnectionsExA(LPRASCONNA *pprcA, PDWORD pcbBuffer, PDWORD pcEntries);

DWORD RasEnumEntriesExA(PCSTR  pszPhonebookA, LPRASENTRYNAMEA *pprenA, PDWORD pcbBuffer, PDWORD pcEntries);
DWORD RasEnumEntriesExW(PCWSTR pszPhonebookW, LPRASENTRYNAMEW *pprenW, PDWORD pcbBuffer, PDWORD pcEntries,
    DWORD dwMode = RWM_RUNTIME);

DWORD RasEnumDevicesExA(LPRASDEVINFOA *pprdiA, PDWORD pcbBuffer, PDWORD pcEntries);
DWORD RasEnumDevicesExW(LPRASDEVINFOW *pprdiW, PDWORD pcbBuffer, PDWORD pcEntries,
    DWORD dwMode = RWM_RUNTIME);

DWORD RasGetEntryPropertiesExA(PCSTR  pszNameA, LPRASENTRYA *ppreA, PDWORD pcbRasEntry);
DWORD RasGetEntryPropertiesExW(PCWSTR pszNameW, LPRASENTRYW *ppreW, PDWORD pcbRasEntry,
    DWORD dwMode = RWM_RUNTIME);

DWORD RasEnumEntriesWrap(PCWSTR pszPhonebookW, LPRASENTRYNAMEW prenW, PDWORD pcbBuffer, PDWORD pcEntries,
    DWORD dwMode = RWM_RUNTIME);
DWORD RasEnumDevicesWrap(LPRASDEVINFOW prdiW, PDWORD pcbBuffer, PDWORD pcEntries,
    DWORD dwMode = RWM_RUNTIME);

DWORD RasGetEntryPropertiesWrap(PCWSTR pszNameW, LPRASENTRYW preW, PDWORD pcbRasEntry,
    DWORD dwMode = RWM_RUNTIME);
DWORD RasGetEntryDialParamsWrap(LPRASDIALPARAMSW prdpW, PBOOL pfPassword,
    DWORD dwMode = RWM_RUNTIME);

DWORD RasSetEntryPropertiesWrap(PCWSTR pszPhonebookW, PCWSTR pszNameW, LPRASENTRYW preW, DWORD cbRasEntry,
    DWORD dwMode = RWM_RUNTIME);
DWORD RasSetEntryDialParamsWrap(PCWSTR pszPhonebookW, LPRASDIALPARAMSW prdpW, BOOL fRemovePassword,
    DWORD dwMode = RWM_RUNTIME);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\ras.cpp ===
#include "precomp.h"
#include <wininet.h>
#include "rashelp.h"


RASENUMCONNECTIONSA    g_pfnRasEnumConnectionsA;
RASHANGUPA             g_pfnRasHangupA;
RASGETCONNECTSTATUSA   g_pfnRasGetConnectStatusA;

RASENUMENTRIESA        g_pfnRasEnumEntriesA;
RASENUMENTRIESW        g_pfnRasEnumEntriesW;
RASDELETEENTRYA        g_pfnRasDeleteEntryA;
RASDELETEENTRYW        g_pfnRasDeleteEntryW;

RASENUMDEVICESA        g_pfnRasEnumDevicesA;
RASENUMDEVICESW        g_pfnRasEnumDevicesW;
RASGETENTRYPROPERTIESA g_pfnRasGetEntryPropertiesA;
RASGETENTRYPROPERTIESW g_pfnRasGetEntryPropertiesW;
RASGETENTRYDIALPARAMSA g_pfnRasGetEntryDialParamsA;
RASGETENTRYDIALPARAMSW g_pfnRasGetEntryDialParamsW;
RASSETENTRYPROPERTIESA g_pfnRasSetEntryPropertiesA;
RASSETENTRYPROPERTIESW g_pfnRasSetEntryPropertiesW;
RASSETENTRYDIALPARAMSA g_pfnRasSetEntryDialParamsA;
RASSETENTRYDIALPARAMSW g_pfnRasSetEntryDialParamsW;


// Private forward decalarations
void rasEntryNameA2W(const LPRASENTRYNAMEA prenSourceA, LPRASENTRYNAMEW prenTargetW);
void rasEntryNameW2A(const LPRASENTRYNAMEW prenSourceW, LPRASENTRYNAMEA prenTargetA);
void rasEntryA2W(const LPRASENTRYA preSourceA, LPRASENTRYW preTargetW);
void rasEntryW2A(const LPRASENTRYW preSourceW, LPRASENTRYA preTargetA);
void rasDevInfoA2W(const LPRASDEVINFOA prdiSourceA, LPRASDEVINFOW prdiTargetW);
void rasDialParamsA2W(const LPRASDIALPARAMSA prdpSourceA, LPRASDIALPARAMSW prdpTargetW);
void rasDialParamsW2A(const LPRASDIALPARAMSW prdpSourceW, LPRASDIALPARAMSA prdpTargetA);


BOOL RasIsInstalled()
{
    static int s_iRasInstalled = -1;            // not initialized

    if (s_iRasInstalled == -1) {
        DWORD dwFlags;

        dwFlags = 0;
        InternetGetConnectedStateEx(&dwFlags, NULL, 0, 0);
        s_iRasInstalled = HasFlag(dwFlags, INTERNET_RAS_INSTALLED) ? 1 : 0;
    }

    ASSERT(s_iRasInstalled == (int)FALSE || s_iRasInstalled == (int)TRUE);
    return (BOOL)s_iRasInstalled;
}

BOOL RasPrepareApis(DWORD dwApiFlags, BOOL fLoad /*= TRUE*/)
{
    static struct {
        DWORD dwApiFlag;
        PCSTR pszApiName;
        PVOID *ppfn;
    } s_rgApisMap[] = {
        { RPA_RASENUMCONNECTIONSA,    "RasEnumConnectionsA",    (PVOID *)&g_pfnRasEnumConnectionsA    },
        { RPA_RASHANGUPA,             "RasHangUpA",             (PVOID *)&g_pfnRasHangupA             },
        { RPA_RASGETCONNECTSTATUSA,   "RasGetConnectStatusA",   (PVOID *)&g_pfnRasGetConnectStatusA   },
        { RPA_RASENUMENTRIESA,        "RasEnumEntriesA",        (PVOID *)&g_pfnRasEnumEntriesA        },
        { RPA_RASENUMENTRIESW,        "RasEnumEntriesW",        (PVOID *)&g_pfnRasEnumEntriesW        },
        { RPA_RASDELETEENTRYA,        "RasDeleteEntryA",        (PVOID *)&g_pfnRasDeleteEntryA        },
        { RPA_RASDELETEENTRYW,        "RasDeleteEntryW",        (PVOID *)&g_pfnRasDeleteEntryW        },
        { RPA_RASENUMDEVICESA,        "RasEnumDevicesA",        (PVOID *)&g_pfnRasEnumDevicesA        },
        { RPA_RASENUMDEVICESW,        "RasEnumDevicesW",        (PVOID *)&g_pfnRasEnumDevicesW        },
        { RPA_RASGETENTRYPROPERTIESA, "RasGetEntryPropertiesA", (PVOID *)&g_pfnRasGetEntryPropertiesA },
        { RPA_RASGETENTRYPROPERTIESW, "RasGetEntryPropertiesW", (PVOID *)&g_pfnRasGetEntryPropertiesW },
        { RPA_RASGETENTRYDIALPARAMSA, "RasGetEntryDialParamsA", (PVOID *)&g_pfnRasGetEntryDialParamsA },
        { RPA_RASGETENTRYDIALPARAMSW, "RasGetEntryDialParamsW", (PVOID *)&g_pfnRasGetEntryDialParamsW },
        { RPA_RASSETENTRYPROPERTIESA, "RasSetEntryPropertiesA", (PVOID *)&g_pfnRasSetEntryPropertiesA },
        { RPA_RASSETENTRYPROPERTIESW, "RasSetEntryPropertiesW", (PVOID *)&g_pfnRasSetEntryPropertiesW },
        { RPA_RASSETENTRYDIALPARAMSA, "RasSetEntryDialParamsA", (PVOID *)&g_pfnRasSetEntryDialParamsA },
        { RPA_RASSETENTRYDIALPARAMSW, "RasSetEntryDialParamsW", (PVOID *)&g_pfnRasSetEntryDialParamsW }
    };
    static HINSTANCE s_hRasDll, s_hRnaDll;
    static UINT      s_nLoadRef;

    UINT i;

    if (fLoad) {
        if (!RasIsInstalled())
            return FALSE;

        if (s_hRasDll == NULL) {
            ASSERT(s_nLoadRef == 0);

            s_hRasDll = LoadLibrary(TEXT("rasapi32.dll"));
            if (s_hRasDll == NULL)
                return FALSE;
        }
        s_nLoadRef++;

        for (i = 0; i < countof(s_rgApisMap); i++) {
            if (!HasFlag(dwApiFlags, s_rgApisMap[i].dwApiFlag))
                continue;

            ASSERT(s_rgApisMap[i].ppfn != NULL);
            if (*s_rgApisMap[i].ppfn != NULL)
                continue;

            *s_rgApisMap[i].ppfn = GetProcAddress(s_hRasDll, s_rgApisMap[i].pszApiName);
            if (*s_rgApisMap[i].ppfn == NULL) {
                if (s_hRnaDll == NULL) {
                    s_hRnaDll = LoadLibrary(TEXT("rnaph.dll"));
                    if (s_hRnaDll == NULL)
                        return FALSE;
                }

                *s_rgApisMap[i].ppfn = GetProcAddress(s_hRnaDll, s_rgApisMap[i].pszApiName);
                if (*s_rgApisMap[i].ppfn == NULL)
                    return FALSE;
            }
        }
    }
    else { /* if (!fLoad) */
        if (s_nLoadRef == 1) {
            for (i = 0; i < countof(s_rgApisMap); i++)
                *s_rgApisMap[i].ppfn = NULL;

            if (s_hRnaDll != NULL) {
                FreeLibrary(s_hRnaDll);
                s_hRnaDll = NULL;
            }

            ASSERT(s_hRasDll != NULL)
            FreeLibrary(s_hRasDll);
            s_hRasDll = NULL;
        }

        if (s_nLoadRef > 0)
            s_nLoadRef--;
    }

    return TRUE;
}


BOOL RasEnumEntriesCallback(PCTSTR pszPhonebook, PVOID pfnEnumAorW, LPARAM lParam,
    DWORD dwMode /*= RWM_RUNTIME*/)
{
    USES_CONVERSION;

    PBYTE pBlob;
    DWORD cEntries,
          dwResult;
    UINT  i;
    BOOL  fCallback,
          fResult;

    if (!RasIsInstalled()) {
        ((RASENUMPROCW)pfnEnumAorW)(NULL, lParam);  // for LAN settings
        return TRUE;
    }

    pBlob    = NULL;
    cEntries = 0;
    fResult  = FALSE;

    if (dwMode != RWM_FORCE_A)
        dwResult = RasEnumEntriesExW(T2CW(pszPhonebook), (LPRASENTRYNAMEW *)&pBlob, NULL, &cEntries, dwMode);
    else
        dwResult = RasEnumEntriesExA(T2CA(pszPhonebook), (LPRASENTRYNAMEA *)&pBlob, NULL, &cEntries);

    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    for (i = 0; i < cEntries; i++) {
        if (dwMode != RWM_FORCE_A)
            fCallback = ((RASENUMPROCW)pfnEnumAorW)(((LPRASENTRYNAMEW)pBlob + i)->szEntryName, lParam);
        else
            fCallback = ((RASENUMPROCA)pfnEnumAorW)(((LPRASENTRYNAMEA)pBlob + i)->szEntryName, lParam);

        if (!fCallback)
            break;
    }

    fResult = TRUE;

Exit:
    if (pBlob != NULL)
        CoTaskMemFree(pBlob);

    ((RASENUMPROCW)pfnEnumAorW)(NULL, lParam);      // for LAN settings
    return fResult;
}


DWORD RasEnumConnectionsExA(LPRASCONNA *pprcA, PDWORD pcbBuffer, PDWORD pcEntries)
{
    LPRASCONNA prcA;
    DWORD cbBuffer, cEntries,
          dwResult;
    BOOL  fRasApisLoaded;

    ASSERT(RasIsInstalled());

    if (pprcA == NULL || pcEntries == NULL)
        return ERROR_INVALID_PARAMETER;

    *pprcA = NULL;
    if (pcbBuffer != NULL)
        *pcbBuffer = 0;
    *pcEntries = 0;

    cbBuffer       = sizeof(RASCONNA);
    cEntries       = 0;
    fRasApisLoaded = FALSE;

    prcA = (LPRASCONNA)CoTaskMemAlloc(sizeof(RASCONNA));
    if (prcA == NULL) {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    ZeroMemory(prcA, sizeof(RASCONNA));
    prcA[0].dwSize = sizeof(RASCONNA);

    if (!RasPrepareApis(RPA_RASENUMCONNECTIONSA) || g_pfnRasEnumConnectionsA == NULL) {
        dwResult = ERROR_INVALID_FUNCTION;
        goto Exit;
    }
    fRasApisLoaded = TRUE;

    dwResult = g_pfnRasEnumConnectionsA(prcA, &cbBuffer, &cEntries);
    if (dwResult == ERROR_BUFFER_TOO_SMALL || dwResult == ERROR_NOT_ENOUGH_MEMORY) {
        prcA = (LPRASCONNA)CoTaskMemRealloc(prcA, cbBuffer);
        if (prcA == NULL) {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        ZeroMemory(prcA, cbBuffer);

        prcA[0].dwSize = sizeof(RASCONNA);
        cEntries = 0;
        dwResult = g_pfnRasEnumConnectionsA(prcA, &cbBuffer, &cEntries);
    }

    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    if (cEntries > 0) {
        *pprcA = prcA;

        if (pcbBuffer != NULL)
            *pcbBuffer = cbBuffer;
    }
    *pcEntries = cEntries;

Exit:
    if ((dwResult != ERROR_SUCCESS || cEntries == 0) && prcA != NULL)
        CoTaskMemFree(prcA);

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    return dwResult;
}

DWORD RasEnumEntriesExA(PCSTR pszPhonebookA, LPRASENTRYNAMEA *pprenA, PDWORD pcbBuffer, PDWORD pcEntries)
{
    LPRASENTRYNAMEA prenA;
    DWORD cbBuffer, cEntries,
          dwResult;
    BOOL  fRasApisLoaded;

    ASSERT(RasIsInstalled());

    if (pprenA == NULL || pcEntries == NULL)
        return ERROR_INVALID_PARAMETER;

    *pprenA = NULL;
    if (pcbBuffer != NULL)
        *pcbBuffer = 0;
    *pcEntries = 0;

    cbBuffer       = sizeof(RASENTRYNAMEA);
    cEntries       = 0;
    fRasApisLoaded = FALSE;

    prenA = (LPRASENTRYNAMEA)CoTaskMemAlloc(sizeof(RASENTRYNAMEA));
    if (prenA == NULL) {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    ZeroMemory(prenA, sizeof(RASENTRYNAMEA));
    prenA[0].dwSize = sizeof(RASENTRYNAMEA);

    if (!RasPrepareApis(RPA_RASENUMENTRIESA) || g_pfnRasEnumEntriesA == NULL) {
        dwResult = ERROR_INVALID_FUNCTION;
        goto Exit;
    }
    fRasApisLoaded = TRUE;

    dwResult = g_pfnRasEnumEntriesA(NULL, pszPhonebookA, prenA, &cbBuffer, &cEntries);
    if (dwResult == ERROR_BUFFER_TOO_SMALL || dwResult == ERROR_NOT_ENOUGH_MEMORY) {
        prenA = (LPRASENTRYNAMEA)CoTaskMemRealloc(prenA, cbBuffer);
        if (prenA == NULL) {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        ZeroMemory(prenA, cbBuffer);

        prenA[0].dwSize = sizeof(RASENTRYNAMEA);
        cEntries = 0;
        dwResult = g_pfnRasEnumEntriesA(NULL, pszPhonebookA, prenA, &cbBuffer, &cEntries);
    }

    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    if (cEntries > 0) {
        *pprenA = prenA;

        if (pcbBuffer != NULL)
            *pcbBuffer = cbBuffer;
    }
    *pcEntries = cEntries;

Exit:
    if ((dwResult != ERROR_SUCCESS || cEntries == 0) && prenA != NULL)
        CoTaskMemFree(prenA);

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    return dwResult;
}

DWORD RasEnumEntriesExW(PCWSTR pszPhonebookW, LPRASENTRYNAMEW *pprenW, PDWORD pcbBuffer, PDWORD pcEntries,
    DWORD dwMode /*= RWM_RUNTIME*/)
{
    LPRASENTRYNAMEW prenW;
    DWORD cbBuffer, cEntries,
          dwResult;

    ASSERT(RasIsInstalled());

    if (pprenW == NULL || pcEntries == NULL)
        return ERROR_INVALID_PARAMETER;

    *pprenW = NULL;
    if (pcbBuffer != NULL)
        *pcbBuffer = 0;
    *pcEntries = 0;

    cbBuffer = sizeof(RASENTRYNAMEW);
    cEntries = 0;

    prenW = (LPRASENTRYNAMEW)CoTaskMemAlloc(sizeof(RASENTRYNAMEW));
    if (prenW == NULL) {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    ZeroMemory(prenW, sizeof(RASENTRYNAMEW));
    prenW[0].dwSize = sizeof(RASENTRYNAMEW);

    dwResult = RasEnumEntriesWrap(pszPhonebookW, prenW, &cbBuffer, &cEntries, dwMode);
    if (dwResult == ERROR_BUFFER_TOO_SMALL || dwResult == ERROR_NOT_ENOUGH_MEMORY) {
        prenW = (LPRASENTRYNAMEW)CoTaskMemRealloc(prenW, cbBuffer);
        if (prenW == NULL) {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        ZeroMemory(prenW, cbBuffer);

        prenW[0].dwSize = sizeof(RASENTRYNAMEW);
        cEntries = 0;
        dwResult = RasEnumEntriesWrap(pszPhonebookW, prenW, &cbBuffer, &cEntries, dwMode);
    }

    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    if (cEntries > 0) {
        *pprenW = prenW;

        if (pcbBuffer != NULL)
            *pcbBuffer = cbBuffer;
    }
    *pcEntries = cEntries;

Exit:
    if ((dwResult != ERROR_SUCCESS || cEntries == 0) && prenW != NULL)
        CoTaskMemFree(prenW);

    return dwResult;
}

DWORD RasEnumDevicesExA(LPRASDEVINFOA *pprdiA, PDWORD pcbBuffer, PDWORD pcEntries)
{
    LPRASDEVINFOA prdiA;
    DWORD cbBuffer, cEntries,
          dwResult;
    BOOL  fRasApisLoaded;

    ASSERT(RasIsInstalled());

    if (pprdiA == NULL || pcEntries == NULL)
        return ERROR_INVALID_PARAMETER;

    *pprdiA = NULL;
    if (pcbBuffer != NULL)
        *pcbBuffer = 0;
    *pcEntries = 0;

    prdiA          = NULL;
    cbBuffer       = 0;
    cEntries       = 0;
    fRasApisLoaded = FALSE;

    if (!RasPrepareApis(RPA_RASENUMDEVICESA) || g_pfnRasEnumDevicesA == NULL) {
        dwResult = ERROR_INVALID_FUNCTION;
        goto Exit;
    }
    fRasApisLoaded = TRUE;

    dwResult = g_pfnRasEnumDevicesA(NULL, &cbBuffer, &cEntries);
    if (dwResult == ERROR_BUFFER_TOO_SMALL || dwResult == ERROR_NOT_ENOUGH_MEMORY) {
        prdiA = (LPRASDEVINFOA)CoTaskMemAlloc(cbBuffer);
        if (prdiA == NULL) {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        ZeroMemory(prdiA, cbBuffer);

        prdiA[0].dwSize = sizeof(RASDEVINFOA);
        cEntries = 0;
        dwResult = g_pfnRasEnumDevicesA(prdiA, &cbBuffer, &cEntries);
    }

    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    if (cEntries > 0) {
        *pprdiA = prdiA;

        if (pcbBuffer != NULL)
            *pcbBuffer = cbBuffer;
    }
    *pcEntries = cEntries;

Exit:
    if ((dwResult != ERROR_SUCCESS || cEntries == 0) && prdiA != NULL)
        CoTaskMemFree(prdiA);

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    return dwResult;
}

DWORD RasEnumDevicesExW(LPRASDEVINFOW *pprdiW, PDWORD pcbBuffer, PDWORD pcEntries, DWORD dwMode /*= RWM_RUNTIME*/)
{
    LPRASDEVINFOW prdiW;
    DWORD cbBuffer, cEntries,
          dwResult;

    ASSERT(RasIsInstalled());

    if (pprdiW == NULL || pcEntries == NULL)
        return ERROR_INVALID_PARAMETER;

    *pprdiW = NULL;
    if (pcbBuffer != NULL)
        *pcbBuffer = 0;
    *pcEntries = 0;

    prdiW    = NULL;
    cbBuffer = 0;
    cEntries = 0;

    dwResult = RasEnumDevicesWrap(NULL, &cbBuffer, &cEntries, dwMode);
    if (dwResult == ERROR_BUFFER_TOO_SMALL || dwResult == ERROR_NOT_ENOUGH_MEMORY) {
        prdiW = (LPRASDEVINFOW)CoTaskMemAlloc(cbBuffer);
        if (prdiW == NULL) {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        ZeroMemory(prdiW, cbBuffer);

        prdiW[0].dwSize = sizeof(RASDEVINFOW);
        cEntries = 0;
        dwResult = RasEnumDevicesWrap(prdiW, &cbBuffer, &cEntries, dwMode);
    }

    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    if (cEntries > 0) {
        *pprdiW = prdiW;

        if (pcbBuffer != NULL)
            *pcbBuffer = cbBuffer;
    }
    *pcEntries = cEntries;

Exit:
    if ((dwResult != ERROR_SUCCESS || cEntries == 0) && prdiW != NULL)
        CoTaskMemFree(prdiW);

    return dwResult;
}

DWORD RasGetEntryPropertiesExA(PCSTR pszNameA, LPRASENTRYA *ppreA, PDWORD pcbRasEntry)
{
    LPRASENTRYA preA;
    DWORD cbRasEntry,
          dwResult;
    BOOL  fRasApisLoaded;

    ASSERT(RasIsInstalled());

    if (pszNameA == NULL || ppreA == NULL || pcbRasEntry == NULL)
        return ERROR_INVALID_PARAMETER;

    *ppreA       = NULL;
    *pcbRasEntry = 0;

    preA           = NULL;
    fRasApisLoaded = FALSE;

    if (!RasPrepareApis(RPA_RASGETENTRYPROPERTIESA) || g_pfnRasGetEntryPropertiesA == NULL) {
        dwResult = ERROR_INVALID_FUNCTION;
        goto Exit;
    }
    fRasApisLoaded = TRUE;

    cbRasEntry = 0;
    dwResult   = g_pfnRasGetEntryPropertiesA(NULL, pszNameA, NULL, &cbRasEntry, NULL, NULL);
    ASSERT(dwResult != ERROR_SUCCESS);

    if (dwResult == ERROR_BUFFER_TOO_SMALL || dwResult == ERROR_NOT_ENOUGH_MEMORY) {
        preA = (LPRASENTRYA)CoTaskMemAlloc(cbRasEntry);
        if (preA == NULL) {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        ZeroMemory(preA, cbRasEntry);

        preA[0].dwSize = sizeof(RASENTRYA);
        dwResult       = g_pfnRasGetEntryPropertiesA(NULL, pszNameA, preA, &cbRasEntry, NULL, NULL);
    }

    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    *ppreA       = preA;
    *pcbRasEntry = cbRasEntry;

Exit:
    if (dwResult != ERROR_SUCCESS && preA != NULL)
        CoTaskMemFree(preA);

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    return dwResult;
}

DWORD RasGetEntryPropertiesExW(PCWSTR pszNameW, LPRASENTRYW *ppreW, PDWORD pcbRasEntry,
    DWORD dwMode /*= RWM_RUNTIME*/)
{
    LPRASENTRYW preW;
    DWORD cbRasEntry,
          dwResult;

    ASSERT(RasIsInstalled());

    if (pszNameW == NULL || ppreW == NULL || pcbRasEntry == NULL)
        return ERROR_INVALID_PARAMETER;

    *ppreW       = NULL;
    *pcbRasEntry = 0;

    preW       = NULL;
    cbRasEntry = 0;
    dwResult   = RasGetEntryPropertiesWrap(pszNameW, NULL, &cbRasEntry, dwMode);
    ASSERT(dwResult != ERROR_SUCCESS);

    if (dwResult == ERROR_BUFFER_TOO_SMALL || dwResult == ERROR_NOT_ENOUGH_MEMORY) {
        preW = (LPRASENTRYW)CoTaskMemAlloc(cbRasEntry);
        if (preW == NULL) {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        ZeroMemory(preW, cbRasEntry);

        preW[0].dwSize = sizeof(RASENTRYW);
        dwResult       = RasGetEntryPropertiesWrap(pszNameW, preW, &cbRasEntry, dwMode);
    }

    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    *ppreW       = preW;
    *pcbRasEntry = cbRasEntry;

Exit:
    if (dwResult != ERROR_SUCCESS && preW != NULL)
        CoTaskMemFree(preW);

    return dwResult;
}


DWORD RasEnumEntriesWrap(PCWSTR pszPhonebookW, LPRASENTRYNAMEW prenW, PDWORD pcbBuffer, PDWORD pcEntries,
    DWORD dwMode /*= RWM_RUNTIME*/)
{
    USES_CONVERSION;

    LPRASENTRYNAMEA prenA;
    DWORD cEntries, cbBuffer,
          dwResult;
    UINT  i;
    BOOL  fRasApisLoaded;

    ASSERT(RasIsInstalled());

    if (prenW == NULL || pcbBuffer == NULL || pcEntries == NULL)
        return ERROR_INVALID_PARAMETER;

    prenA          = NULL;
    cEntries       = 0;
    dwResult       = ERROR_SUCCESS;
    fRasApisLoaded = FALSE;

    if (HasFlag(dwMode, RWM_FORCE_W) || (HasFlag(dwMode, RWM_RUNTIME) && IsOS(OS_NT))) {
        if (!RasPrepareApis(RPA_RASENUMENTRIESW) || g_pfnRasEnumEntriesW == NULL)
            return ERROR_INVALID_FUNCTION;
        fRasApisLoaded = TRUE;

        dwResult = g_pfnRasEnumEntriesW(NULL, pszPhonebookW, prenW, pcbBuffer, pcEntries);
    }
    else {
        ASSERT(dwMode == RWM_FORCE_A || (HasFlag(dwMode, RWM_RUNTIME) && !IsOS(OS_NT)));

        ASSERT(*pcbBuffer % sizeof(RASENTRYNAMEW) == 0);
        cEntries = *pcbBuffer / sizeof(RASENTRYNAMEW);
        cbBuffer = cEntries   * sizeof(RASENTRYNAMEA);

        *pcbBuffer = 0;
        *pcEntries = 0;

        prenA = (LPRASENTRYNAMEA)CoTaskMemAlloc(cbBuffer);
        if (prenA == NULL) {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }

        ZeroMemory(prenA, cbBuffer);
        prenA[0].dwSize = sizeof(RASENTRYNAMEA);

        if (!RasPrepareApis(RPA_RASENUMENTRIESA) || g_pfnRasEnumEntriesA == NULL) {
            dwResult = ERROR_INVALID_FUNCTION;
            goto Exit;
        }
        fRasApisLoaded = TRUE;

        cEntries = 0;
        dwResult = g_pfnRasEnumEntriesA(NULL, W2CA(pszPhonebookW), prenA, &cbBuffer, &cEntries);

        if (dwResult == ERROR_SUCCESS) {
            ASSERT(cbBuffer == cEntries * sizeof(RASENTRYNAMEA));
            for (i = 0; i < cEntries; i++) {
                rasEntryNameA2W(prenA + i, prenW + i);
                ASSERT((prenW + i)->dwSize == sizeof(RASENTRYNAMEW));
            }
        }

        *pcbBuffer = cEntries * sizeof(RASENTRYNAMEW);
        *pcEntries = cEntries;
    }

Exit:
    if (prenA != NULL)
        CoTaskMemFree(prenA);

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    return dwResult;
}

DWORD RasEnumDevicesWrap(LPRASDEVINFOW prdiW, PDWORD pcbBuffer, PDWORD pcEntries,
    DWORD dwMode /*= RWM_RUNTIME*/)
{
    LPRASDEVINFOA prdiA;
    DWORD cbBuffer, cEntries,
          dwResult;
    UINT  i;
    BOOL  fRasApisLoaded;

    ASSERT(RasIsInstalled());

    if (pcbBuffer == NULL || pcEntries == NULL)
        return ERROR_INVALID_PARAMETER;

    prdiA          = NULL;
    dwResult       = ERROR_SUCCESS;
    fRasApisLoaded = FALSE;

    if (HasFlag(dwMode, RWM_FORCE_W) || (HasFlag(dwMode, RWM_RUNTIME) && IsOS(OS_NT))) {
        if (!RasPrepareApis(RPA_RASENUMDEVICESW) || g_pfnRasEnumDevicesW == NULL)
            return ERROR_INVALID_FUNCTION;
        fRasApisLoaded = TRUE;

        dwResult = g_pfnRasEnumDevicesW(prdiW, pcbBuffer, pcEntries);
    }
    else {
        ASSERT(dwMode == RWM_FORCE_A || (HasFlag(dwMode, RWM_RUNTIME) && !IsOS(OS_NT)));

        *pcEntries = 0;

        if (prdiW == NULL) {
            cEntries = 0;
            cbBuffer = 0;

            *pcbBuffer = 0;
        }
        else {
            ASSERT(*pcbBuffer % sizeof(RASDEVINFOW) == 0);
            cEntries = *pcbBuffer / sizeof(RASDEVINFOW);
            cbBuffer = cEntries   * sizeof(RASDEVINFOA);

            *pcbBuffer = 0;

            prdiA = (LPRASDEVINFOA)CoTaskMemAlloc(cbBuffer);
            if (prdiA == NULL) {
                dwResult = ERROR_NOT_ENOUGH_MEMORY;
                goto Exit;
            }

            ZeroMemory(prdiA, cbBuffer);
            prdiA[0].dwSize = sizeof(RASDEVINFOA);
        }

        if (!RasPrepareApis(RPA_RASENUMDEVICESA) || g_pfnRasEnumDevicesA == NULL) {
            dwResult = ERROR_INVALID_FUNCTION;
            goto Exit;
        }
        fRasApisLoaded = TRUE;

        cEntries = 0;
        dwResult = g_pfnRasEnumDevicesA(prdiA, &cbBuffer, &cEntries);

        if (dwResult == ERROR_SUCCESS && prdiA != NULL) {
            ASSERT(prdiW != NULL);

            for (i = 0; i < cEntries; i++) {
                rasDevInfoA2W(prdiA + i, prdiW + i);
                ASSERT((prdiW + i)->dwSize == sizeof(RASDEVINFOW));
            }
        }

        *pcbBuffer = cEntries * sizeof(RASDEVINFOW);
        *pcEntries = cEntries;
    }

Exit:
    if (prdiA != NULL)
        CoTaskMemFree(prdiA);

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    return dwResult;
}

DWORD RasGetEntryPropertiesWrap(PCWSTR pszNameW, LPRASENTRYW preW, PDWORD pcbRasEntry,
    DWORD dwMode /*= RWM_RUNTIME*/)
{
    USES_CONVERSION;

    DWORD dwResult;

    ASSERT(RasIsInstalled());

    if (pszNameW == NULL || pcbRasEntry == NULL)
        return ERROR_INVALID_PARAMETER;

    if (HasFlag(dwMode, RWM_FORCE_W) || (HasFlag(dwMode, RWM_RUNTIME) && IsOS(OS_NT))) {
        if (!RasPrepareApis(RPA_RASGETENTRYPROPERTIESW) || g_pfnRasGetEntryPropertiesW == NULL)
            return ERROR_INVALID_FUNCTION;

        dwResult = g_pfnRasGetEntryPropertiesW(NULL, pszNameW, preW, pcbRasEntry, NULL, NULL);
    }
    else {
        RASENTRYA   reA;
        LPRASENTRYA preA;
        DWORD       cbRasEntry;

        ASSERT(dwMode == RWM_FORCE_A || (HasFlag(dwMode, RWM_RUNTIME) && !IsOS(OS_NT)));

        *pcbRasEntry = 0;

        if (!RasPrepareApis(RPA_RASGETENTRYPROPERTIESA) || g_pfnRasGetEntryPropertiesA == NULL)
            return ERROR_INVALID_FUNCTION;

        preA       = NULL;
        cbRasEntry = 0;

        if (preW != NULL) {
            preA = &reA;
            rasEntryW2A(preW, preA);
            ASSERT(preA->dwSize == sizeof(RASENTRYA));
            cbRasEntry = sizeof(RASENTRYA);
        }

        dwResult = g_pfnRasGetEntryPropertiesA(NULL, W2CA(pszNameW), preA, &cbRasEntry, NULL, NULL);
        if (dwResult == ERROR_SUCCESS && preW != NULL) {
            ASSERT(preA != NULL);
            rasEntryA2W(preA, preW);
            ASSERT(preW->dwSize == sizeof(RASENTRYW));
        }

        *pcbRasEntry = sizeof(RASENTRYW);
    }

    RasPrepareApis(RPA_UNLOAD, FALSE);
    return dwResult;
}

DWORD RasGetEntryDialParamsWrap(LPRASDIALPARAMSW prdpW, PBOOL pfPassword,
    DWORD dwMode /*= RWM_RUNTIME*/)
{
    DWORD dwResult;

    ASSERT(RasIsInstalled());

    if (prdpW == NULL)
        return ERROR_INVALID_PARAMETER;

    if (HasFlag(dwMode, RWM_FORCE_W) || (HasFlag(dwMode, RWM_RUNTIME) && IsOS(OS_NT))) {
        if (!RasPrepareApis(RPA_RASGETENTRYDIALPARAMSW) || g_pfnRasGetEntryDialParamsW == NULL)
            return ERROR_INVALID_FUNCTION;

        dwResult = g_pfnRasGetEntryDialParamsW(NULL, prdpW, pfPassword);
    }
    else {
        RASDIALPARAMSA rdpA;
        BOOL           fPassword;

        ASSERT(dwMode == RWM_FORCE_A || (HasFlag(dwMode, RWM_RUNTIME) && !IsOS(OS_NT)));

        if (!RasPrepareApis(RPA_RASGETENTRYDIALPARAMSA) || g_pfnRasGetEntryDialParamsA == NULL)
            return ERROR_INVALID_FUNCTION;

        rasDialParamsW2A(prdpW, &rdpA);
        ASSERT(rdpA.dwSize == sizeof(RASDIALPARAMSA));

        fPassword = FALSE;
        dwResult  = g_pfnRasGetEntryDialParamsA(NULL, &rdpA, &fPassword);
        if (dwResult == ERROR_SUCCESS) {
            rasDialParamsA2W(&rdpA, prdpW);
            ASSERT(prdpW->dwSize == sizeof(RASDIALPARAMSW));

            if (pfPassword != NULL)
                *pfPassword = fPassword;
        }
    }

    RasPrepareApis(RPA_UNLOAD, FALSE);
    return dwResult;
}


DWORD RasSetEntryPropertiesWrap(PCWSTR pszPhonebookW, PCWSTR pszNameW, LPRASENTRYW preW, DWORD cbRasEntry,
    DWORD dwMode /*= RWM_RUNTIME*/)
{
    USES_CONVERSION;

    DWORD dwResult;

    ASSERT(RasIsInstalled());

    if (pszNameW == NULL || preW == NULL)
        return ERROR_INVALID_PARAMETER;

    if (HasFlag(dwMode, RWM_FORCE_W) || (HasFlag(dwMode, RWM_RUNTIME) && IsOS(OS_NT))) {
        if (!RasPrepareApis(RPA_RASSETENTRYPROPERTIESW) || g_pfnRasSetEntryPropertiesW == NULL)
            return ERROR_INVALID_FUNCTION;

        dwResult = g_pfnRasSetEntryPropertiesW(pszPhonebookW, pszNameW, preW, cbRasEntry, NULL, 0);
    }
    else {
        RASENTRYA reA;

        ASSERT(dwMode == RWM_FORCE_A || (HasFlag(dwMode, RWM_RUNTIME) && !IsOS(OS_NT)));

        if (!RasPrepareApis(RPA_RASSETENTRYPROPERTIESA) || g_pfnRasSetEntryPropertiesA == NULL)
            return ERROR_INVALID_FUNCTION;

        rasEntryW2A(preW, &reA);
        ASSERT(reA.dwSize == sizeof(RASENTRYA));

        dwResult = g_pfnRasSetEntryPropertiesA(W2CA(pszPhonebookW), W2CA(pszNameW), &reA, reA.dwSize, NULL, 0);
    }

    RasPrepareApis(RPA_UNLOAD, FALSE);
    return dwResult;
}

DWORD RasSetEntryDialParamsWrap(PCWSTR pszPhonebookW, LPRASDIALPARAMSW prdpW, BOOL fRemovePassword,
    DWORD dwMode /*= RWM_RUNTIME*/)
{
    USES_CONVERSION;

    DWORD dwResult;

    ASSERT(RasIsInstalled());

    if (prdpW == NULL)
        return ERROR_INVALID_PARAMETER;

    if (HasFlag(dwMode, RWM_FORCE_W) || (HasFlag(dwMode, RWM_RUNTIME) && IsOS(OS_NT))) {
        if (!RasPrepareApis(RPA_RASSETENTRYDIALPARAMSW) || g_pfnRasSetEntryDialParamsW == NULL)
            return ERROR_INVALID_FUNCTION;

        dwResult = g_pfnRasSetEntryDialParamsW(pszPhonebookW, prdpW, fRemovePassword);
    }
    else {
        RASDIALPARAMSA rdpA;

        ASSERT(dwMode == RWM_FORCE_A || (HasFlag(dwMode, RWM_RUNTIME) && !IsOS(OS_NT)));

        if (!RasPrepareApis(RPA_RASSETENTRYDIALPARAMSA) || g_pfnRasSetEntryDialParamsA == NULL)
            return ERROR_INVALID_FUNCTION;

        rasDialParamsW2A(prdpW, &rdpA);
        ASSERT(rdpA.dwSize == sizeof(RASDIALPARAMSA));

        dwResult = g_pfnRasSetEntryDialParamsA(W2CA(pszPhonebookW), &rdpA, fRemovePassword);
    }

    RasPrepareApis(RPA_UNLOAD, FALSE);
    return dwResult;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

void rasEntryNameA2W(const LPRASENTRYNAMEA prenSourceA, LPRASENTRYNAMEW prenTargetW)
{
    ASSERT(prenSourceA != NULL && prenTargetW != NULL);
    ASSERT(RasIsInstalled());
    ZeroMemory(prenTargetW, sizeof(RASENTRYNAMEW));

    prenTargetW->dwSize = sizeof(RASENTRYNAMEW);
    A2Wbux(prenSourceA->szEntryName, prenTargetW->szEntryName);
}

void rasEntryNameW2A(const LPRASENTRYNAMEW prenSourceW, LPRASENTRYNAMEA prenTargetA)
{
    ASSERT(prenSourceW != NULL && prenTargetA != NULL);
    ASSERT(RasIsInstalled());
    ZeroMemory(prenTargetA, sizeof(RASENTRYNAMEA));

    prenTargetA->dwSize = sizeof(RASENTRYNAMEA);
    W2Abux(prenSourceW->szEntryName, prenTargetA->szEntryName);
}

void rasEntryA2W(const LPRASENTRYA preSourceA, LPRASENTRYW preTargetW)
{
    ASSERT(preSourceA != NULL && preTargetW != NULL);
    ASSERT(RasIsInstalled());
    ZeroMemory(preTargetW, sizeof(RASENTRYW));

    // first quirk
    preTargetW->dwSize        = sizeof(RASENTRYW);
    preTargetW->dwfOptions    = preSourceA->dwfOptions;
    preTargetW->dwCountryID   = preSourceA->dwCountryID;
    preTargetW->dwCountryCode = preSourceA->dwCountryCode;

    A2Wbux(preSourceA->szAreaCode,         preTargetW->szAreaCode);
    A2Wbux(preSourceA->szLocalPhoneNumber, preTargetW->szLocalPhoneNumber);

    // second quirk
    preTargetW->dwAlternateOffset = 0;

    CopyMemory(&preTargetW->ipaddr,        &preSourceA->ipaddr,        sizeof(preSourceA->ipaddr));
    CopyMemory(&preTargetW->ipaddrDns,     &preSourceA->ipaddrDns,     sizeof(preSourceA->ipaddrDns));
    CopyMemory(&preTargetW->ipaddrDnsAlt,  &preSourceA->ipaddrDnsAlt,  sizeof(preSourceA->ipaddrDnsAlt));
    CopyMemory(&preTargetW->ipaddrWins,    &preSourceA->ipaddrWins,    sizeof(preSourceA->ipaddrWins));
    CopyMemory(&preTargetW->ipaddrWinsAlt, &preSourceA->ipaddrWinsAlt, sizeof(preSourceA->ipaddrWinsAlt));

    preTargetW->dwFrameSize       = preSourceA->dwFrameSize;
    preTargetW->dwfNetProtocols   = preSourceA->dwfNetProtocols;
    preTargetW->dwFramingProtocol = preSourceA->dwFramingProtocol;

    A2Wbux(preSourceA->szScript,        preTargetW->szScript);
    A2Wbux(preSourceA->szAutodialDll,   preTargetW->szAutodialDll);
    A2Wbux(preSourceA->szAutodialFunc,  preTargetW->szAutodialFunc);
    A2Wbux(preSourceA->szDeviceType,    preTargetW->szDeviceType);
    A2Wbux(preSourceA->szDeviceName,    preTargetW->szDeviceName);
    A2Wbux(preSourceA->szX25PadType,    preTargetW->szX25PadType);
    A2Wbux(preSourceA->szX25Address,    preTargetW->szX25Address);
    A2Wbux(preSourceA->szX25Facilities, preTargetW->szX25Facilities);
    A2Wbux(preSourceA->szX25UserData,   preTargetW->szX25UserData);

    preTargetW->dwChannels  = preSourceA->dwChannels;
    preTargetW->dwReserved1 = preSourceA->dwReserved1;
    preTargetW->dwReserved2 = preSourceA->dwReserved2;

    // third quirk
    #if (WINVER >= 0x401)
        #error RASENTRY has more members than currently copied. These new members need to be added!
    #endif
}

void rasEntryW2A(const LPRASENTRYW preSourceW, LPRASENTRYA preTargetA)
{
    ASSERT(preSourceW != NULL && preTargetA != NULL);
    ASSERT(RasIsInstalled());
    ZeroMemory(preTargetA, sizeof(RASENTRYA));

    // first quirk
    preTargetA->dwSize        = sizeof(RASENTRYA);
    preTargetA->dwfOptions    = preSourceW->dwfOptions;
    preTargetA->dwCountryID   = preSourceW->dwCountryID;
    preTargetA->dwCountryCode = preSourceW->dwCountryCode;

    W2Abux(preSourceW->szAreaCode,         preTargetA->szAreaCode);
    W2Abux(preSourceW->szLocalPhoneNumber, preTargetA->szLocalPhoneNumber);

    // second quirk
    preTargetA->dwAlternateOffset = 0;

    CopyMemory(&preTargetA->ipaddr,        &preSourceW->ipaddr,        sizeof(preSourceW->ipaddr));
    CopyMemory(&preTargetA->ipaddrDns,     &preSourceW->ipaddrDns,     sizeof(preSourceW->ipaddrDns));
    CopyMemory(&preTargetA->ipaddrDnsAlt,  &preSourceW->ipaddrDnsAlt,  sizeof(preSourceW->ipaddrDnsAlt));
    CopyMemory(&preTargetA->ipaddrWins,    &preSourceW->ipaddrWins,    sizeof(preSourceW->ipaddrWins));
    CopyMemory(&preTargetA->ipaddrWinsAlt, &preSourceW->ipaddrWinsAlt, sizeof(preSourceW->ipaddrWinsAlt));

    preTargetA->dwFrameSize       = preSourceW->dwFrameSize;
    preTargetA->dwfNetProtocols   = preSourceW->dwfNetProtocols;
    preTargetA->dwFramingProtocol = preSourceW->dwFramingProtocol;

    W2Abux(preSourceW->szScript,        preTargetA->szScript);
    W2Abux(preSourceW->szAutodialDll,   preTargetA->szAutodialDll);
    W2Abux(preSourceW->szAutodialFunc,  preTargetA->szAutodialFunc);
    W2Abux(preSourceW->szDeviceType,    preTargetA->szDeviceType);
    W2Abux(preSourceW->szDeviceName,    preTargetA->szDeviceName);
    W2Abux(preSourceW->szX25PadType,    preTargetA->szX25PadType);
    W2Abux(preSourceW->szX25Address,    preTargetA->szX25Address);
    W2Abux(preSourceW->szX25Facilities, preTargetA->szX25Facilities);
    W2Abux(preSourceW->szX25UserData,   preTargetA->szX25UserData);

    preTargetA->dwChannels  = preSourceW->dwChannels;
    preTargetA->dwReserved1 = preSourceW->dwReserved1;
    preTargetA->dwReserved2 = preSourceW->dwReserved2;
}

void rasDevInfoA2W(const LPRASDEVINFOA prdiSourceA, LPRASDEVINFOW prdiTargetW)
{
    ASSERT(prdiSourceA != NULL && prdiTargetW != NULL);
    ASSERT(RasIsInstalled());
    ZeroMemory(prdiTargetW, sizeof(RASDEVINFOW));

    // first quirk
    prdiTargetW->dwSize = sizeof(RASDEVINFOW);

    A2Wbux(prdiSourceA->szDeviceType, prdiTargetW->szDeviceType);
    A2Wbux(prdiSourceA->szDeviceName, prdiTargetW->szDeviceName);
}

void rasDialParamsA2W(const LPRASDIALPARAMSA prdpSourceA, LPRASDIALPARAMSW prdpTargetW)
{
    ASSERT(prdpSourceA != NULL && prdpTargetW != NULL);
    ASSERT(RasIsInstalled());
    ZeroMemory(prdpTargetW, sizeof(RASDIALPARAMSW));

    // first quirk
    prdpTargetW->dwSize = sizeof(RASDIALPARAMSW);

    A2Wbux(prdpSourceA->szEntryName,      prdpTargetW->szEntryName);
    A2Wbux(prdpSourceA->szPhoneNumber,    prdpTargetW->szPhoneNumber);
    A2Wbux(prdpSourceA->szCallbackNumber, prdpTargetW->szCallbackNumber);
    A2Wbux(prdpSourceA->szUserName,       prdpTargetW->szUserName);
    A2Wbux(prdpSourceA->szPassword,       prdpTargetW->szPassword);
    A2Wbux(prdpSourceA->szDomain,         prdpTargetW->szDomain);
}

void rasDialParamsW2A(const LPRASDIALPARAMSW prdpSourceW, LPRASDIALPARAMSA prdpTargetA)
{
    ASSERT(prdpSourceW != NULL && prdpTargetA != NULL);
    ASSERT(RasIsInstalled());
    ZeroMemory(prdpTargetA, sizeof(RASDIALPARAMSA));

    // first quirk
    prdpTargetA->dwSize = sizeof(RASDIALPARAMSA);

    W2Abux(prdpSourceW->szEntryName,      prdpTargetA->szEntryName);
    W2Abux(prdpSourceW->szPhoneNumber,    prdpTargetA->szPhoneNumber);
    W2Abux(prdpSourceW->szCallbackNumber, prdpTargetA->szCallbackNumber);
    W2Abux(prdpSourceW->szUserName,       prdpTargetA->szUserName);
    W2Abux(prdpSourceW->szPassword,       prdpTargetA->szPassword);
    W2Abux(prdpSourceW->szDomain,         prdpTargetA->szDomain);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\misc.cpp ===
#include "precomp.h"
#include <wininet.h>
#include <regstr.h>

// Private forward decalarations
static LPCTSTR mapSingleDw2Psz(PCMAPDW2PSZ pMap, UINT cEntries, DWORD dw, BOOL fFailNotFound = FALSE);


ULONG CoTaskMemSize(LPVOID pv)
{
    IMalloc *p;
    HRESULT hr;

    if (pv == NULL)
        return 0;

    hr = CoGetMalloc(1, &p);
    if (FAILED(hr))
        return 0;

    return (ULONG)p->GetSize(pv);
}

UINT CoStringFromGUID(REFGUID rguid, LPTSTR pszBuf, UINT cchBuf)
{
    WCHAR wszGuid[128];
    UINT  nSize;

    nSize = StringFromGUID2(rguid, wszGuid, countof(wszGuid));
    W2Tbuf(wszGuid, pszBuf, cchBuf);

    return nSize;
}


LPCTSTR GetHrSz(HRESULT hr)
{
    static MAPDW2PSZ mapHr[] = {
        // real HRESULTs
        DW2PSZ_PAIR(S_OK),
        DW2PSZ_PAIR(S_FALSE),

        DW2PSZ_PAIR(E_UNEXPECTED),
        DW2PSZ_PAIR(E_NOTIMPL),
        DW2PSZ_PAIR(E_OUTOFMEMORY),
        DW2PSZ_PAIR(E_INVALIDARG),
        DW2PSZ_PAIR(E_NOINTERFACE),
        DW2PSZ_PAIR(E_POINTER),
        DW2PSZ_PAIR(E_HANDLE),
        DW2PSZ_PAIR(E_ABORT),
        DW2PSZ_PAIR(E_FAIL),
        DW2PSZ_PAIR(E_ACCESSDENIED),

        DW2PSZ_PAIR(CO_E_NOTINITIALIZED),
        DW2PSZ_PAIR(CO_E_ALREADYINITIALIZED),
        DW2PSZ_PAIR(CO_E_DLLNOTFOUND),
        DW2PSZ_PAIR(CO_E_APPNOTFOUND),
        DW2PSZ_PAIR(CO_E_ERRORINDLL),
        DW2PSZ_PAIR(CO_E_APPDIDNTREG),
        DW2PSZ_PAIR(RPC_E_CHANGED_MODE),

        DW2PSZ_PAIR(REGDB_E_CLASSNOTREG),
        DW2PSZ_PAIR(REGDB_E_READREGDB),
        DW2PSZ_PAIR(REGDB_E_IIDNOTREG),
        DW2PSZ_PAIR(CLASS_E_NOAGGREGATION),

        DW2PSZ_PAIR(STG_E_FILENOTFOUND),
        DW2PSZ_PAIR(STG_E_PATHNOTFOUND),

        DW2PSZ_PAIR(TRUST_E_NOSIGNATURE),
        DW2PSZ_PAIR(TRUST_E_FAIL),
        DW2PSZ_PAIR(TRUST_E_SUBJECT_NOT_TRUSTED),

        // win32 errors
        DW2PSZ_PAIR(ERROR_FILE_NOT_FOUND),
        DW2PSZ_PAIR(ERROR_PATH_NOT_FOUND),

        // wininet errors
        DW2PSZ_PAIR(ERROR_INTERNET_INTERNAL_ERROR)
    };

    LPCTSTR pszResult;

    pszResult = mapSingleDw2Psz(mapHr, countof(mapHr), hr, TRUE);
    if (pszResult != NULL)
        return pszResult;

    // error from HRESULT_FROM_WIN32
    if (hr < 0 && (hr & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16))
        hr &= 0x0000FFFF;                       // only LOWORD matters

    return mapSingleDw2Psz(mapHr, countof(mapHr), hr);
}

DWORD GetStringField(LPTSTR szStr, UINT uField, LPTSTR szBuf, UINT cchBufSize)
{
   LPTSTR pszBegin = szStr;
   LPTSTR pszEnd;
   TCHAR cSeparator;
   UINT i = 0;
   DWORD dwToCopy;

   if(cchBufSize == 0)
       return 0;

   szBuf[0] = TEXT('\0');

   if(szStr == NULL)
      return 0;

   // figure out whether we're looking for commas or periods

   if (StrChr(szStr, TEXT(',')))
       cSeparator = TEXT(',');
   else
   {
       if (StrChr(szStr, TEXT('.')))
           cSeparator = TEXT('.');
       else
           return 0;
   }

   while(pszBegin && *pszBegin != TEXT('\0') && i < uField)
   {
      pszBegin = StrChr(pszBegin, cSeparator);
      if(pszBegin && (*pszBegin != TEXT('\0')))
         pszBegin++;
      i++;
   }

   // we reached end of string, no field
   if(!pszBegin || *pszBegin == TEXT('\0'))
   {
      return 0;
   }


   pszEnd = StrChr(pszBegin, cSeparator);
   while(pszBegin <= pszEnd && *pszBegin == TEXT(' '))
      pszBegin++;

   while(pszEnd > pszBegin && *(pszEnd - 1) == TEXT(' '))
      pszEnd--;

   if(pszEnd > (pszBegin + 1) && *pszBegin == TEXT('"') && *(pszEnd-1) == TEXT('"'))
   {
      pszBegin++;
      pszEnd--;
   }

   dwToCopy = (DWORD) (pszEnd - pszBegin + 1);

   if(dwToCopy > cchBufSize)
      dwToCopy = cchBufSize;

   StrCpyN(szBuf, pszBegin, dwToCopy);

   return dwToCopy - 1;
}

DWORD GetIntField(LPTSTR szStr, UINT uField, DWORD dwDefault)
{
   TCHAR szNumBuf[16];

   if (GetStringField(szStr, uField, szNumBuf, countof(szNumBuf)) == 0)
      return dwDefault;
   else
      return StrToInt(szNumBuf);
}

void ConvertVersionStrToDwords(LPTSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
   DWORD dwTemp1,dwTemp2;

   dwTemp1 = GetIntField(pszVer, 0, 0);
   dwTemp2 = GetIntField(pszVer, 1, 0);

   *pdwVer = (dwTemp1 << 16) + dwTemp2;

   dwTemp1 = GetIntField(pszVer, 2, 0);
   dwTemp2 = GetIntField(pszVer, 3, 0);

   *pdwBuild = (dwTemp1 << 16) + dwTemp2;
}

void ConvertDwordsToVersionStr(LPTSTR pszVer, DWORD dwVer, DWORD dwBuild)
{
    WORD w1, w2, w3, w4;

    w1 = HIWORD(dwVer);
    w2 = LOWORD(dwVer);
    w3 = HIWORD(dwBuild);
    w4 = LOWORD(dwBuild);

    wnsprintf(pszVer, 32, TEXT("%d,%d,%d,%d"), w1, w2, w3, w4);
}

DWORD GetIEVersion()
{
    TCHAR szValue[MAX_PATH];
    DWORD dwInstalledVer, dwInstalledBuild, dwSize;

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;

    szValue[0] = TEXT('\0');
    dwSize     = sizeof(szValue);
    SHGetValue(HKEY_LOCAL_MACHINE, RK_IE, RV_VERSION, NULL, szValue, &dwSize);
    if (szValue[0] != TEXT('\0')) {
        ConvertVersionStrToDwords(szValue, &dwInstalledVer, &dwInstalledBuild);
        return dwInstalledVer;
    }

    if (dwInstalledVer == (DWORD)-1) {
        szValue[0] = TEXT('\0');
        dwSize     = sizeof(szValue);
        SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\iexplore.exe"), NULL, NULL, szValue, &dwSize);
        if (szValue[0] != TEXT('\0')) {
            GetVersionFromFileWrap(szValue, &dwInstalledVer, &dwInstalledBuild, TRUE);
            return dwInstalledVer;
        }
    }

    return 0;
}

BOOL SetFlag(LPDWORD pdwFlags, DWORD dwMask, BOOL fSet /*= TRUE*/)
{
    if (pdwFlags == NULL)
        return FALSE;

    if (fSet)
        *pdwFlags |= dwMask;

    else
        *pdwFlags &= ~dwMask;

    return TRUE;
}

// taken from IE setup code

BOOL IsNTAdmin()
{
    typedef BOOL (WINAPI *LPCHECKTOKENMEMBERSHIP)(HANDLE, PSID, PBOOL);
    
    static int    s_fIsAdmin = 2;
    HANDLE        hAccessToken = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;
    BOOL bRet  = FALSE;
    
    
    //
    // If we have cached a value, return the cached value. Note I never
    // set the cached value to false as I want to retry each time in
    // case a previous failure was just a temp. problem (ie net access down)
    //
    
    bRet = FALSE;
    
    if( s_fIsAdmin != 2 )
        return (BOOL)s_fIsAdmin;
    
    if (!IsOS(OS_NT)) 
    {
        s_fIsAdmin = TRUE;      // If we are not running under NT return TRUE.
        return (BOOL)s_fIsAdmin;
    }
    
    
    if(!IsOS(OS_NT5) && 
        !OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hAccessToken ) )
        return FALSE;
    
    
    if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
    {
        // if we're running on W2K use the proper check (b388901 in W2K database) which
        // will work for restricted tokens
        
        if (IsOS(OS_NT5))
        {
            HINSTANCE hAdvapi32 = NULL;
            LPCHECKTOKENMEMBERSHIP lpfnCheckTokenMembership = NULL;
    
            hAdvapi32 = LoadLibrary(TEXT("advapi32.dll"));
            if (hAdvapi32 != NULL)
            {
                lpfnCheckTokenMembership = 
                    (LPCHECKTOKENMEMBERSHIP)GetProcAddress(hAdvapi32, "CheckTokenMembership");
                
                if (lpfnCheckTokenMembership != NULL)
                {
                    BOOL fMember = FALSE;
                    
                    if (lpfnCheckTokenMembership(hAccessToken, AdministratorsGroup, 
                        &fMember) && fMember)
                    {
                        s_fIsAdmin = TRUE;
                        bRet = TRUE;
                    }
                }
                
                FreeLibrary(hAdvapi32);
            }
        }
        else
        {
            PTOKEN_GROUPS ptgGroups;
            DWORD         dwReqSize;
            UINT          i;
    
            ptgGroups = NULL;
    
            // See how big of a buffer we need for the token information
            if(!GetTokenInformation( hAccessToken, TokenGroups, NULL, 0, &dwReqSize))
            {
                // GetTokenInfo should the buffer size we need - Alloc a buffer
                if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    ptgGroups = (PTOKEN_GROUPS) CoTaskMemAlloc(dwReqSize);
                
            }

            // ptgGroups could be NULL for a coupla reasons here:
            // 1. The alloc above failed
            // 2. GetTokenInformation actually managed to succeed the first time (possible?)
            // 3. GetTokenInfo failed for a reason other than insufficient buffer
            // Any of these seem justification for bailing.
            
            // So, make sure it isn't null, then get the token info
            if((ptgGroups != NULL) && 
                GetTokenInformation(hAccessToken, TokenGroups, ptgGroups, dwReqSize, &dwReqSize))
            {
                
                // Search thru all the groups this process belongs to looking for the
                // Administrators Group.
                
                for( i=0; i < ptgGroups->GroupCount; i++ )
                {
                    if (EqualSid(ptgGroups->Groups[i].Sid, AdministratorsGroup))
                    {
                        // Yea! This guy looks like an admin
                        s_fIsAdmin = TRUE;
                        bRet = TRUE;
                        break;
                    }
                }
            }

            if (ptgGroups != NULL)
                CoTaskMemFree(ptgGroups);
        }
        FreeSid(AdministratorsGroup);
    }
    // BUGBUG: Close handle here? doc's aren't clear whether this is needed.

    if (hAccessToken != NULL)
        CloseHandle(hAccessToken);
    
    return bRet;
}




HRESULT GetLcid(LCID *pLcid, LPCTSTR pcszLang, LPCTSTR pcszLocaleIni)
{
    TCHAR   szLookupEntries[1024];
    TCHAR   szLang[8];
    LPTSTR  pszIndex;
    HRESULT hRetVal = E_FAIL;

    if (pLcid == NULL || pcszLang == NULL || *pcszLang == TEXT('\0') || pcszLocaleIni == NULL ||
        *pcszLocaleIni == TEXT('\0'))
        return hRetVal;

    if (GetPrivateProfileString(IS_ACTIVESETUP, NULL, TEXT(""), szLookupEntries, countof(szLookupEntries), pcszLocaleIni))
    {
        for (pszIndex = szLookupEntries; *pszIndex; pszIndex += StrLen(pszIndex)+1)
        {
            GetPrivateProfileString(IS_ACTIVESETUP, pszIndex, TEXT(""), szLang, countof(szLang), pcszLocaleIni);
            if (StrCmpI(szLang, pcszLang) == 0)
            {
                TCHAR szHexLCID[16];

                StrCpy(szHexLCID, TEXT("0x"));
                StrCat(szHexLCID, pszIndex);
                if (StrToIntEx(szHexLCID, STIF_SUPPORT_HEX, (int *)pLcid))
                    hRetVal = S_OK;
                break;
            }
        }
    }

    return hRetVal;
}

UINT GetUnitsFromCb(UINT cbSrc, UINT cbUnit)
{
    ASSERT(0 == cbSrc % cbUnit);
    return (cbSrc / cbUnit);
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helpers routines (private)

LPCTSTR mapSingleDw2Psz(PCMAPDW2PSZ pMap, UINT cEntries, DWORD dw, BOOL fFailNotFound /*= FALSE*/)
{
    static TCHAR szUnknown[30];

    ASSERT(pMap != NULL);
    for (UINT i = 0; i < cEntries; i++)
        if ((pMap + i)->dw == dw)
            return (pMap + i)->psz;

    if (fFailNotFound)
        return NULL;

    wnsprintf(szUnknown, countof(szUnknown), TEXT("(unknown) [0x%08lX]"), dw);
    return szUnknown;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

/////////////////////////////////////////////////////////////////////////
//
//  ATL / OLE HACKHACK
//
//  Include <w95wraps.h> before anything else that messes with names.
//  Although everybody gets the wrong name, at least it's *consistently*
//  the wrong name, so everything links.
//
//  NOTE:  This means that while debugging you will see functions like
//  ShellExecuteExWrapW when you expected to see
//  ShellExecuteExW.
//
#include <w95wraps.h>
#include <windows.h>
#include <windowsx.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <wininet.h>

#include <iedkbrnd.h>
#include "ieakutil.h"
#include "debug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\reg.cpp ===
#include "precomp.h"

LONG SHCleanUpValue(HKEY hk, PCTSTR pszKey, PCTSTR pszValue /*= NULL*/)
{
    TCHAR   szKey[MAX_PATH];
    LPTSTR  pszCurrent;
    HKEY    hkAux;
    HRESULT hr;
    LONG    lResult;

    if (hk == NULL)
        return E_INVALIDARG;

    if (StrLen(pszKey) >= countof(szKey))
        return E_OUTOFMEMORY;
    StrCpy(szKey, pszKey);

    if (pszValue != NULL) {
        lResult = SHOpenKey(hk, pszKey, KEY_SET_VALUE, &hkAux);
        if (lResult == ERROR_SUCCESS) {
            lResult = RegDeleteValue(hkAux, pszValue);
            SHCloseKey(hkAux);

            if (lResult != ERROR_SUCCESS && lResult != ERROR_FILE_NOT_FOUND)
                return E_FAIL;
        }
    }

    for (pszCurrent = szKey + StrLen(szKey); TRUE; *pszCurrent = TEXT('\0')) {
        hr = SHIsKeyEmpty(hk, szKey);
        if (FAILED(hr))
            if (hr == STG_E_PATHNOTFOUND)
                continue;
            else
                return E_FAIL;

        if (hr == S_FALSE)
            break;

        RegDeleteKey(hk, szKey);

        pszCurrent = StrRChr(szKey, pszCurrent, TEXT('\\'));
        if (pszCurrent == NULL)
            break;
    }

    return S_OK;
}


void SHCopyKey(HKEY hkFrom, HKEY hkTo)
{
    TCHAR szData[1024],
          szValue[MAX_PATH];
    DWORD dwSize, dwVal, dwSizeData, dwType;
    HKEY  hkSubkeyFrom, hkSubkeyTo;

    dwVal      = 0;
    dwSize     = countof(szValue);
    dwSizeData = sizeof(szData);
    while (ERROR_SUCCESS == RegEnumValue(hkFrom, dwVal++, szValue, &dwSize, NULL, &dwType, (LPBYTE)szData, &dwSizeData)) {
        RegSetValueEx(hkTo, szValue, 0, dwType, (LPBYTE)szData, dwSizeData);
        dwSize     = countof(szValue);
        dwSizeData = sizeof(szData);
    }

    dwVal = 0;
    while (ERROR_SUCCESS == RegEnumKey(hkFrom, dwVal++, szValue, countof(szValue)))
        if (ERROR_SUCCESS == SHOpenKey(hkFrom, szValue, KEY_DEFAULT_ACCESS, &hkSubkeyFrom))
            if (SHCreateKey(hkTo, szValue, KEY_DEFAULT_ACCESS, &hkSubkeyTo) == ERROR_SUCCESS)
                SHCopyKey(hkSubkeyFrom, hkSubkeyTo);
}

HRESULT SHCopyValue(HKEY hkFrom, HKEY hkTo, PCTSTR pszValue)
{
    PBYTE pData;
    DWORD dwType,
          cbData;
    LONG  lResult;

    if (NULL == hkFrom || NULL == hkTo)
        return E_INVALIDARG;

    if (S_OK != SHValueExists(hkFrom, pszValue))
        return STG_E_FILENOTFOUND;

    cbData  = 0;
    lResult = RegQueryValueEx(hkFrom, pszValue, NULL, &dwType, NULL, &cbData);
    if (ERROR_SUCCESS != lResult)
        return E_FAIL;

    pData = (PBYTE)CoTaskMemAlloc(cbData);
    if (NULL == pData)
        return E_OUTOFMEMORY;
    // ZeroMemory(pData, cbData);               // don't really have to do this

    lResult = RegQueryValueEx(hkFrom, pszValue, NULL, NULL, pData, &cbData);
    ASSERT(ERROR_SUCCESS == lResult);

    lResult = RegSetValueEx(hkTo, pszValue, 0, dwType, pData, cbData);
    CoTaskMemFree(pData);

    return (ERROR_SUCCESS == lResult) ? S_OK : HRESULT_FROM_WIN32(lResult);
}

HRESULT SHCopyValue(HKEY hkFrom, PCTSTR pszSubkeyFrom, HKEY hkTo, PCTSTR pszSubkeyTo, PCTSTR pszValue)
{
    HKEY    hkSubkeyFrom, hkSubkeyTo;
    HRESULT hr;
    LONG    lResult;

    hkSubkeyFrom = NULL;
    hkSubkeyTo   = NULL;
    hr           = E_FAIL;

    if (NULL == hkFrom || NULL == pszSubkeyFrom ||
        NULL == hkTo   || NULL == pszSubkeyTo) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    lResult = SHOpenKey(hkFrom, pszSubkeyFrom, KEY_QUERY_VALUE, &hkSubkeyFrom);
    if (ERROR_SUCCESS != lResult) {
        hr = (ERROR_FILE_NOT_FOUND == lResult) ? STG_E_PATHNOTFOUND : E_FAIL;
        goto Exit;
    }

    lResult = SHCreateKey(hkTo, pszSubkeyTo, KEY_SET_VALUE, &hkSubkeyTo);
    if (ERROR_SUCCESS != lResult)
        goto Exit;

    hr = SHCopyValue(hkSubkeyFrom, hkSubkeyTo, pszValue);

Exit:
    SHCloseKey(hkSubkeyFrom);
    SHCloseKey(hkSubkeyTo);

    return hr;
}


HRESULT SHIsKeyEmpty(HKEY hk)
{
    DWORD  dwKeys, dwValues;
    LONG   lResult;

    if (hk == NULL)
        return E_INVALIDARG;

    lResult = RegQueryInfoKey(hk, NULL, NULL, NULL, &dwKeys, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL);
    if (lResult != ERROR_SUCCESS)
        return E_FAIL;

    return (dwKeys == 0 && dwValues == 0) ? S_OK : S_FALSE;
}

HRESULT SHIsKeyEmpty(HKEY hk, PCTSTR pszSubKey)
{
    HKEY    hkAux;
    HRESULT hr;
    LONG    lResult;

    lResult = SHOpenKey(hk, pszSubKey, KEY_QUERY_VALUE, &hkAux);
    if (lResult != ERROR_SUCCESS)
        return (lResult == ERROR_FILE_NOT_FOUND) ? STG_E_PATHNOTFOUND : E_FAIL;

    hr = SHIsKeyEmpty(hkAux);
    SHCloseKey(hkAux);

    return hr;
}


HRESULT SHKeyExists(HKEY hk, PCTSTR pszSubKey)
{
    HKEY    hkAux;
    HRESULT hr;
    DWORD   lResult;

    if (hk == NULL)
        return E_INVALIDARG;

    hkAux   = NULL;
    lResult = SHOpenKey(hk, pszSubKey, KEY_QUERY_VALUE, &hkAux);
    SHCloseKey(hkAux);

    hr = S_OK;
    if (lResult != ERROR_SUCCESS)
        hr = (lResult == ERROR_FILE_NOT_FOUND) ? S_FALSE : E_FAIL;

    return hr;
}

HRESULT SHValueExists(HKEY hk, PCTSTR pszValue)
{
    HRESULT hr;
    DWORD   lResult;

    if (hk == NULL)
        return E_INVALIDARG;

    if (pszValue != NULL && *pszValue != TEXT('\0'))
        lResult = RegQueryValueEx(hk, pszValue, NULL, NULL, NULL, NULL);

    else {
        DWORD dwValueDataLen;
        TCHAR szDummyBuf[1];

        // On Win95, for the default value name, its existence is checked as follows:
        //  - pass in a dummy buffer for the value data but pass in the size of the buffer as 0
        //  - the query would succeed if and only if there is no value data set
        //  - for all other cases, including the case where the value data is just the empty string,
        //      the query would fail and dwValueDataLen would contain the no. of bytes needed to
        //      fit in the value data
        // On NT4.0, if no value data is set, the query returns ERROR_FILE_NOT_FOUND

        dwValueDataLen = 0;
        lResult        = RegQueryValueEx(hk, pszValue, NULL, NULL, (LPBYTE)szDummyBuf, &dwValueDataLen);
        if (lResult == ERROR_SUCCESS)
            lResult = ERROR_FILE_NOT_FOUND;
    }

    hr = S_OK;
    if (lResult != ERROR_SUCCESS)
        hr = (lResult == ERROR_FILE_NOT_FOUND) ? S_FALSE : E_FAIL;

    return hr;
}

HRESULT SHValueExists(HKEY hk, PCTSTR pszSubKey, PCTSTR pszValue)
{
    HKEY    hkAux;
    HRESULT hr;
    LONG    lResult;

    lResult = SHOpenKey(hk, pszSubKey, KEY_QUERY_VALUE, &hkAux);
    if (lResult != ERROR_SUCCESS)
        return (lResult == ERROR_FILE_NOT_FOUND) ? STG_E_PATHNOTFOUND : E_FAIL;

    hr = SHValueExists(hkAux, pszValue);
    SHCloseKey(hkAux);

    return hr;
}


DWORD RegSaveRestoreDWORD(HKEY hk, PCTSTR pcszValue, DWORD dwVal)
{
    DWORD dwRet, dwSize;    

    // Note: we assume that a value of 0 is equivalent to the value not being there at all
    
    dwSize = sizeof(dwRet);

    if (SHQueryValueEx(hk, pcszValue, NULL, NULL, (LPVOID)&dwRet, &dwSize) != ERROR_SUCCESS)
        dwRet = 0;
     
    if (dwVal == 0)
        RegDeleteValue(hk, pcszValue);
    else
        RegSetValueEx(hk, pcszValue, 0, REG_DWORD, (CONST BYTE *)&dwVal, sizeof(dwVal));

    return dwRet;     // return the value we overwrite in the registry
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\path.cpp ===
#include "precomp.h"
#include <regstr.h>

// Private forward decalarations
static DWORD pepHrToPep(HRESULT hr);
static void  pepHrCallToHrResult(HRESULT hrCall, HRESULT &hrResult);

static BOOL replaceSubString(LPTSTR pszSrc, LPCTSTR pcszSub, LPCTSTR pcszReplace);


BOOL PathCreatePath(LPCTSTR pszPathToCreate)
{
    TCHAR  szGrowingPath[MAX_PATH],
           szBuffer[MAX_PATH];
    LPTSTR pszNext;

    if (!PathIsValidPath(pszPathToCreate))
        return FALSE;

    if (PathIsUNCServer(pszPathToCreate))
        return FALSE;

    if (PathIsRoot(pszPathToCreate))
        return TRUE;

    szGrowingPath[0] = TEXT('\0');
    StrCpy(szBuffer, pszPathToCreate);
    pszPathToCreate  = &szBuffer[0];

    pszNext = PathSkipRoot(pszPathToCreate);
    if (pszNext != NULL) {
        // copy the root to szGrowingPath
        StrCpyN(szGrowingPath, pszPathToCreate, INT(pszNext - pszPathToCreate) + 1);
        pszPathToCreate = pszNext;
    }

    // loop through each dir in the path and if it doesn't exist, create it
    for (; (pszNext = PathFindNextComponent(pszPathToCreate)) != NULL; pszPathToCreate = pszNext) {
        if (*pszNext != TEXT('\0')) {
            ASSERT(pszNext > pszPathToCreate);
            *(pszNext - 1) = TEXT('\0');
        }

        PathAppend(szGrowingPath, pszPathToCreate);
        if (!PathFileExists(szGrowingPath))
            if (!CreateDirectory(szGrowingPath, NULL) && !PathFileExists(szGrowingPath))
                return FALSE;

        else
            if (!PathIsDirectory(szGrowingPath))
                return FALSE;
    }

    return TRUE;
}


BOOL PathIsValidPath(LPCTSTR pszPath, DWORD dwFlags /*= PIVP_DEFAULT*/)
{
    return (PathIsValidPathEx(pszPath, dwFlags) == PIVP_VALID);
}

BOOL PathIsValidFile(LPCTSTR pszFile, DWORD dwFlags /*= PIVP_DEFAULT*/)
{
    return (PathIsValidPathEx(pszFile, dwFlags | PIVP_FILENAME_ONLY) == PIVP_VALID);
}

DWORD PathIsValidPathEx(LPCTSTR pszPath, DWORD dwFlags /*= PIVP_DEFAULT*/, LPCTSTR *ppszError /*= NULL*/)
{
    LPCTSTR pszCur, pszPrev;
    UINT    nType;
    int     i;
    DWORD   dwResult;

    dwResult = PIVP_VALID;
    if (ppszError != NULL)
        *ppszError = NULL;

    if (pszPath == NULL)
        return PIVP_ARG;

    for (i = 0, pszCur = pszPath, pszPrev = NULL;
         dwResult == PIVP_VALID && *pszCur != TEXT('\0');
         i++, pszPrev = pszCur, pszCur = CharNext(pszCur)) {

        nType = PathGetCharType(*pszCur);

        if (HasFlag(nType, GCT_INVALID) || HasFlag(nType, GCT_WILD))
            dwResult = HasFlag(nType, GCT_WILD) ? PIVP_WILD : PIVP_CHAR;

        else if (HasFlag(nType, GCT_SEPARATOR)) {
            if (HasFlag(dwFlags, PIVP_FILENAME_ONLY))
                dwResult = PIVP_CHAR;

            else { /* !HasFlag(dwFlag, PIVP_FILENAME_ONLY)) */
                if (*pszCur == TEXT('\\')) {
                    if (i == 0) {
                        ASSERTA(!IsDBCSLeadByte(*pszCur));

                        if (!HasFlag(dwFlags, PIVP_RELATIVE_VALID) &&
                            *(pszCur + 1) != TEXT('\\'))
                            dwResult = PIVP_RELATIVE;
                    }
                    else if (i == 1) {
                        ASSERT(pszPrev != NULL);

                        if (*pszPrev == TEXT('\\'))
                            ;
                        else if (*pszPrev != TEXT(' ') &&
                                 HasFlag(PathGetCharType(*pszPrev), GCT_LFNCHAR))
                            ;
                        else
                            dwResult = PIVP_FIRST_CHAR;
                    }
                    else { /* if (i >= 2) */
                        ASSERT(pszPrev != NULL);

                        if (*pszPrev != TEXT(' ')) {
                            if (!HasFlag(PathGetCharType(*pszPrev), GCT_LFNCHAR))
                                dwResult = PIVP_PRESLASH;

                            if (dwResult != PIVP_VALID && i == 2)
                                dwResult = (*pszPrev != TEXT(':')) ? dwResult : PIVP_VALID;
                        }
                        else
                            dwResult = PIVP_SPACE;
                    }
                }
                else if (*pszCur == TEXT('/'))
                    dwResult = PIVP_FWDSLASH;

                else if (*pszCur == TEXT(':'))
                    if (i != 1)
                        dwResult = PIVP_COLON;

                    else {
                        int iDrive;

                        ASSERT(pszPrev == pszPath);
                        iDrive = PathGetDriveNumber(pszPath);
                        dwResult = (iDrive < 0 || iDrive > 25) ? PIVP_DRIVE : PIVP_VALID;
                    }

                else /* any other separator */
                    dwResult = PIVP_SEPARATOR;      // better be safe than sorry
            } /* !HasFlag(dwFlag, PIVP_FILENAME_ONLY)) */
        } /* HasFlag(nType, GCT_SEPARATOR) */
        else if (HasFlag(nType, GCT_LFNCHAR)) {
            LPCSTR pcszBuffer = NULL; // used only to check DBCS and 0x5c validity
            CHAR   szAbuff[3];

#ifndef _UNICODE
            pcszBuffer = pszCur;
            *szAbuff = TEXT('\0');
#else
            // convert the character to ANSI to check for invalid DBCS and 5c
            {
            WCHAR  szWbuff[2];

            szWbuff[0] = *pszCur;
            szWbuff[1] = TEXT('\0');

            W2Abuf(szWbuff, szAbuff, countof(szAbuff));
            pcszBuffer = szAbuff;
            }
#endif
            if (HasFlag(dwFlags, PIVP_DBCS_INVALID))
                if (IsDBCSLeadByte(*pcszBuffer))
                    dwResult = PIVP_DBCS;

            if (dwResult == PIVP_VALID && HasFlag(dwFlags, PIVP_0x5C_INVALID))
                if (IsDBCSLeadByte(*pcszBuffer) && *(pcszBuffer + 1) == 0x5C)
                    dwResult = PIVP_0x5C;

            if (dwResult == PIVP_VALID && HasFlag(dwFlags, PIVP_EXCHAR_INVALID))
                if (*pszCur & 0x80)
                    dwResult = PIVP_EXCHAR;

            if (dwResult == PIVP_VALID && i == 2) {
                ASSERT(pszPrev != NULL);

                if (*pszPrev == TEXT(':'))
                    dwResult = PIVP_COLON;
            }
        }
        else
            dwResult = PIVP_CHAR;
    }

    if (dwResult == PIVP_VALID && HasFlag(dwFlags, PIVP_MUST_EXIST))
        if (!PathFileExists(pszPath)) {
            dwResult = PIVP_DOESNT_EXIST;
            pszPrev  = pszPath;
        }
        else {
            SetFlag((LPDWORD)&dwFlags, PIVP_MUST_EXIST, FALSE);
            if (PathIsDirectory(pszPath)) {
                if (HasFlag(dwFlags, PIVP_FILE_ONLY)) {
                    dwResult = PIVP_NOT_FILE;
                    pszPrev  = pszPath;
                }
            }
            else /* it's a file */
                if (HasFlag(dwFlags, PIVP_FOLDER_ONLY)) {
                    dwResult = PIVP_NOT_FOLDER;
                    pszPrev  = pszPath;
                }
        }

    if (dwResult != PIVP_VALID && ppszError != NULL)
        *ppszError = pszPrev;

    return dwResult;
}


HRESULT PathEnumeratePath(LPCTSTR pszPath, DWORD dwFlags, PFNPATHENUMPATHPROC pfnEnumProc, LPARAM lParam,
    PDWORD *ppdwReserved /*= NULL*/)
{
    WIN32_FIND_DATA fd;
    TCHAR   szPath[MAX_PATH];
    HANDLE  hFindFile;
    HRESULT hrFirst, hrSecond, hrResult;
    PDWORD  pdwEnum, pdwRcrs,
            pdwRslt, pdwSrc;
    DWORD   rgdwRslt[PEP_RCRS_OUTPOS_LAST],
            rgdwEnum[PEP_ENUM_OUTPOS_LAST],
            rgdwRcrs[PEP_RCRS_OUTPOS_LAST],
            dwBelowFlags, dwBelowFlags2;
    BOOL    fOwnEnum, fOwnRcrs;

    if (pszPath == NULL || pfnEnumProc == NULL)
        return E_INVALIDARG;

    if (ppdwReserved != NULL && *ppdwReserved != NULL)
        ZeroMemory(*ppdwReserved, sizeof(rgdwRslt));

    PathCombine(szPath, pszPath, TEXT("*.*"));
    hFindFile = FindFirstFile(szPath, &fd);
    if (hFindFile == INVALID_HANDLE_VALUE)
        return E_FAIL;

    hrResult     = S_OK;
    dwBelowFlags = dwFlags;
    ZeroMemory(rgdwRslt, sizeof(rgdwRslt));

    do {
        PathCombine(szPath, pszPath, fd.cFileName);

        //----- Filter out non-interesting objects -----
        if (HasFlag(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            if (StrCmp(fd.cFileName, TEXT(".")) == 0 || StrCmp(fd.cFileName, TEXT("..")) == 0)
                continue;

            if (HasFlag(dwFlags, PEP_SCPE_NOFOLDERS))
                continue;
        }
        else
            if (HasFlag(dwFlags, PEP_SCPE_NOFILES))
                continue;

        //----- Initialize loop variables -----
        hrFirst  = S_OK;
        hrSecond = S_OK;
        pdwEnum  = NULL;
        pdwRcrs  = NULL;
        fOwnEnum = FALSE;
        fOwnRcrs = FALSE;

        ZeroMemory(rgdwEnum, sizeof(rgdwEnum));
        ZeroMemory(rgdwRcrs, sizeof(rgdwRcrs));

        //----- The order is: recourse first then go into the callback -----
        if (!HasFlag(dwFlags, PEP_CTRL_ENUMPROCFIRST)) {

            //_____ Recourse processing _____
            if (HasFlag(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
                if (HasFlag(dwFlags, PEP_CTRL_USECONTROL)) {
                    pdwRcrs  = rgdwRcrs;
                    fOwnRcrs = TRUE;
                }

                hrFirst = PathEnumeratePath(szPath, dwBelowFlags, pfnEnumProc, lParam, &pdwRcrs);

                ASSERT(pdwRcrs == NULL ||
                    (!HasFlag(pdwRcrs[PEP_RCRS_OUTPOS_BELOW],     PEP_RCRS_ALL) &&
                     !HasFlag(pdwRcrs[PEP_RCRS_OUTPOS_THISLEVEL], PEP_RCRS_ALL)));
            }

            //_____ Callback processing _____
            if (!HasFlag(dwFlags, PEP_CTRL_NOSECONDCALL) &&
                (pdwRcrs == NULL || !HasFlag(pdwRcrs[PEP_RCRS_OUTPOS_SECONDCALL], PEP_CTRL_NOSECONDCALL))) {

                if (HasFlag(dwFlags, PEP_CTRL_USECONTROL) ||
                    (pdwRcrs != NULL && HasFlag(pdwRcrs[PEP_RCRS_OUTPOS_SECONDCALL], PEP_CTRL_USECONTROL))) {

                    rgdwEnum[PEP_ENUM_INPOS_FLAGS] = dwFlags;
                    if (pdwRcrs != NULL)
                        if (HasFlag(pdwRcrs[PEP_RCRS_OUTPOS_SECONDCALL], PEP_CTRL_RESET))
                            rgdwEnum[PEP_ENUM_INPOS_FLAGS] = 0;

                        else {
                            rgdwEnum[PEP_ENUM_INPOS_FLAGS] = pdwRcrs[PEP_RCRS_OUTPOS_SECONDCALL];
                            SetFlag(&rgdwEnum[PEP_ENUM_INPOS_FLAGS], PEP_CTRL_USECONTROL, FALSE);
                        }

                    // callback also needs to know:
                    rgdwEnum[PEP_ENUM_INPOS_FLAGS]        |= pepHrToPep(hrFirst); // how recourse for this object worked
                    rgdwEnum[PEP_ENUM_INPOS_RECOURSEFLAGS] = dwBelowFlags;        // what flags recourse was called with

                    pdwEnum  = rgdwEnum;
                    fOwnEnum = TRUE;
                }

                hrSecond = pfnEnumProc(szPath, &fd, lParam, &pdwEnum);
            }
        }

        //----- The order is: go into callback then recourse -----
        else { /* if (HasFlag(dwFlags, PEP_CTRL_ENUMPROCFIRST)) */

            //_____ Callback processing _____
            if (HasFlag(dwFlags, PEP_CTRL_USECONTROL)) {
                rgdwEnum[PEP_ENUM_INPOS_FLAGS] = dwFlags;

                pdwEnum  = rgdwEnum;
                fOwnEnum = TRUE;
            }

            hrFirst = pfnEnumProc(szPath, &fd, lParam, &pdwEnum);

            //_____ Recourse processing _____
            if (HasFlag(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) &&
                !HasFlag(dwFlags, PEP_CTRL_NOSECONDCALL)               &&
                (pdwEnum == NULL || !HasFlag(pdwEnum[PEP_ENUM_OUTPOS_SECONDCALL], PEP_CTRL_NOSECONDCALL))) {

                dwBelowFlags2 = dwBelowFlags;
                if (pdwEnum != NULL && pdwEnum[PEP_ENUM_OUTPOS_SECONDCALL] != 0)
                    if (HasFlag(pdwEnum[PEP_ENUM_OUTPOS_SECONDCALL], PEP_CTRL_RESET))
                        dwBelowFlags2 = 0;

                    else {
                        dwBelowFlags2 = pdwEnum[PEP_ENUM_OUTPOS_SECONDCALL];
                        SetFlag(&dwBelowFlags2, PEP_CTRL_USECONTROL, FALSE);
                    }

                if (HasFlag(dwFlags, PEP_CTRL_USECONTROL) ||
                    (pdwEnum != NULL && HasFlag(pdwEnum[PEP_ENUM_OUTPOS_SECONDCALL], PEP_CTRL_USECONTROL))) {
                    pdwRcrs  = rgdwRcrs;
                    fOwnRcrs = TRUE;
                }

                hrSecond = PathEnumeratePath(szPath, dwBelowFlags2, pfnEnumProc, lParam, &pdwRcrs);

                ASSERT(pdwRcrs == NULL ||
                    (pdwRcrs[PEP_RCRS_OUTPOS_SECONDCALL] == 0                   &&
                     !HasFlag(pdwRcrs[PEP_RCRS_OUTPOS_BELOW],     PEP_RCRS_ALL) &&
                     !HasFlag(pdwRcrs[PEP_RCRS_OUTPOS_THISLEVEL], PEP_RCRS_ALL)));
            }
        }

        //----- Setting preliminary out-parameters -----

        // PEP_ENUM_OUTPOS_SECONDCALL
        pdwRslt = &rgdwRslt[PEP_RCRS_OUTPOS_SECONDCALL];
        if (!HasFlag(dwFlags, PEP_CTRL_ENUMPROCFIRST)) {
            pdwSrc = (pdwEnum != NULL) ? &pdwEnum[PEP_ENUM_OUTPOS_SECONDCALL] : NULL;
            if (pdwSrc != NULL && *pdwSrc != 0)
                *pdwRslt = *pdwSrc;
        }

        // PEP_RCRS_OUTPOS_BELOW
        pdwRslt = &rgdwRslt[PEP_RCRS_OUTPOS_BELOW];
        if (!HasFlag(dwFlags, PEP_CTRL_ENUMPROCFIRST)) {
            pdwSrc = (pdwEnum != NULL) ? &pdwEnum[PEP_ENUM_OUTPOS_ABOVE_SIBLINGS] : NULL;
            if (pdwSrc != NULL && *pdwSrc != 0)
                *pdwRslt = *pdwSrc;

            else {
                pdwSrc = (pdwRcrs != NULL) ? &pdwRcrs[PEP_RCRS_OUTPOS_BELOW] : NULL;
                if (pdwSrc != NULL && HasFlag(*pdwSrc, PEP_CTRL_KEEPAPPLY))
                    *pdwRslt = *pdwSrc;
            }
        }
        else {
            pdwSrc = (pdwRcrs != NULL) ? &pdwRcrs[PEP_RCRS_OUTPOS_BELOW] : NULL;
            if (pdwSrc != NULL && HasFlag(*pdwSrc, PEP_CTRL_KEEPAPPLY))
                *pdwRslt = *pdwSrc;

            else {
                pdwSrc = (pdwEnum != NULL) ? &pdwEnum[PEP_ENUM_OUTPOS_ABOVE_SIBLINGS] : NULL;
                if (pdwSrc != NULL && *pdwSrc != 0)
                    *pdwRslt = *pdwSrc;
            }
        }

        // PEP_RCRS_OUTPOS_THISLEVEL
        pdwRslt = &rgdwRslt[PEP_RCRS_OUTPOS_THISLEVEL];
        if (!HasFlag(dwFlags, PEP_CTRL_ENUMPROCFIRST)) {
            pdwSrc = (pdwEnum != NULL) ? &pdwEnum[PEP_ENUM_OUTPOS_ABOVE] : NULL;
            if (pdwSrc != NULL && *pdwSrc != 0)
                *pdwRslt = *pdwSrc;

            else {
                pdwSrc = (pdwRcrs != NULL) ? &pdwRcrs[PEP_RCRS_OUTPOS_THISLEVEL] : NULL;
                if (pdwSrc != NULL && HasFlag(*pdwSrc, PEP_CTRL_KEEPAPPLY))
                    *pdwRslt = *pdwSrc;
            }
        }
        else {
            pdwSrc = (pdwRcrs != NULL) ? &pdwRcrs[PEP_RCRS_OUTPOS_THISLEVEL] : NULL;
            if (pdwSrc != NULL && HasFlag(*pdwSrc, PEP_CTRL_KEEPAPPLY))
                *pdwRslt = *pdwSrc;

            else {
                pdwSrc = (pdwEnum != NULL) ? &pdwEnum[PEP_ENUM_OUTPOS_ABOVE] : NULL;
                if (pdwSrc != NULL && *pdwSrc != 0)
                    *pdwRslt = *pdwSrc;
            }
        }

        //----- Adjust to the new control settings -----

        // dwBelowFlags
        if (!HasFlag(dwFlags, PEP_CTRL_ENUMPROCFIRST)) {
            pdwSrc = (pdwEnum != NULL) ? &pdwEnum[PEP_ENUM_OUTPOS_BELOW] : NULL;
            if (pdwSrc != NULL && *pdwSrc != 0)
                dwBelowFlags = *pdwSrc;

            else {
                pdwSrc = (pdwRcrs != NULL) ? &pdwRcrs[PEP_RCRS_OUTPOS_BELOW] : NULL;
                if (pdwSrc != NULL && *pdwSrc != 0)
                    dwBelowFlags = *pdwSrc;
            }
        }
        else {
            pdwSrc = (pdwRcrs != NULL) ? &pdwRcrs[PEP_RCRS_OUTPOS_BELOW] : NULL;
            if (pdwSrc != NULL && *pdwSrc != 0)
                dwBelowFlags = *pdwSrc;

            else {
                pdwSrc = (pdwEnum != NULL) ? &pdwEnum[PEP_ENUM_OUTPOS_BELOW] : NULL;
                if (pdwSrc != NULL && *pdwSrc != 0)
                    dwBelowFlags = *pdwSrc;
            }
        }

        // dwFlags
        if (!HasFlag(dwFlags, PEP_CTRL_ENUMPROCFIRST)) {
            pdwSrc = (pdwEnum != NULL) ? &pdwEnum[PEP_ENUM_OUTPOS_THISLEVEL] : NULL;
            if (pdwSrc != NULL && *pdwSrc != 0)
                dwFlags = *pdwSrc;

            else {
                pdwSrc = (pdwRcrs != NULL) ? &pdwRcrs[PEP_RCRS_OUTPOS_THISLEVEL] : NULL;
                if (pdwSrc != NULL && *pdwSrc != 0)
                    dwFlags = *pdwSrc;
            }
        }
        else {
            pdwSrc = (pdwRcrs != NULL) ? &pdwRcrs[PEP_RCRS_OUTPOS_THISLEVEL] : NULL;
            if (pdwSrc != NULL && *pdwSrc != 0)
                dwFlags = *pdwSrc;

            else {
                pdwSrc = (pdwEnum != NULL) ? &pdwEnum[PEP_ENUM_OUTPOS_THISLEVEL] : NULL;
                if (pdwSrc != NULL && *pdwSrc != 0)
                    dwFlags = *pdwSrc;
            }
        }

        //----- Release the memory not owned here -----
        if (!fOwnEnum && pdwEnum != NULL)
            CoTaskMemFree(pdwEnum);

        if (!fOwnRcrs && pdwRcrs != NULL)
            CoTaskMemFree(pdwRcrs);

        //----- Process result codes from both calls -----
        pepHrCallToHrResult(hrFirst, hrResult);     // modifies hrResult by reference
        if (hrResult == S_FALSE || FAILED(hrResult))
            break;

        pepHrCallToHrResult(hrSecond, hrResult);    // modifies hrResult by reference
        if (hrResult == S_FALSE || FAILED(hrResult))
            break;

    } while (FindNextFile(hFindFile, &fd));
    FindClose(hFindFile);

    //----- Set an out-parameter(s) -----
    if (ppdwReserved != NULL) {
        if (*ppdwReserved == NULL &&
            (rgdwRslt[PEP_RCRS_OUTPOS_SECONDCALL] != 0 ||
             rgdwRslt[PEP_RCRS_OUTPOS_BELOW]      != 0 ||
             rgdwRslt[PEP_RCRS_OUTPOS_THISLEVEL]  != 0)) {

            *ppdwReserved = (PDWORD)CoTaskMemAlloc(sizeof(rgdwRslt));
            if (*ppdwReserved == NULL)
                return E_OUTOFMEMORY;
        }

        if (*ppdwReserved != NULL)
            CopyMemory(*ppdwReserved, rgdwRslt, sizeof(rgdwRslt));
    }

    return hrResult;
}


BOOL PathRemovePath(LPCTSTR pszPath, DWORD dwFlags /*= 0*/)
{
    USES_CONVERSION;

    return (DelNode(T2CA(pszPath), dwFlags) == S_OK);
}

BOOL PathIsLocalPath(LPCTSTR pszPath)
{
    if (pszPath == NULL || *pszPath == TEXT('\0') || PathIsUNC(pszPath) || PathIsURL(pszPath))
        return FALSE;

    if (pszPath[1] == TEXT(':')) {              // drive letter present, check if it's a network drive
        TCHAR szDrive[4];

        // NOTE: Need not worry about DBCS chars here because
        // (1) 'a' thru 'z', 'A' thru 'Z' and ':' are not DBCS lead byte chars
        // (2) ':' is not a DBCS trailing byte char
        szDrive[0] = pszPath[0];
        szDrive[1] = pszPath[1];
        szDrive[2] = TEXT('\\');
        szDrive[3] = TEXT('\0');

        return GetDriveType(szDrive) != DRIVE_REMOTE;
    }

    // not a fully qualified path, so must be local
    return TRUE;
}

BOOL PathFileExistsInDir(LPCTSTR pcszFile, LPCTSTR pcszDir)
{
    TCHAR szFile[MAX_PATH];

    if (pcszFile == NULL  ||  pcszDir == NULL  ||  ISNULL(pcszFile)  ||  ISNULL(pcszDir))
        return FALSE;

    PathCombine(szFile, pcszDir, pcszFile);
    return PathFileExists(szFile);
}

BOOL PathHasBackslash(LPCTSTR pcszPath)
{
    if (pcszPath == NULL  ||  *pcszPath == TEXT('\0'))
        return FALSE;

    return *CharPrev(pcszPath, pcszPath + StrLen(pcszPath)) == TEXT('\\');
}

BOOL PathIsEmptyPath(LPCTSTR pcszPath, DWORD dwFlags /*= FILES_AND_DIRS*/, LPCTSTR pcszExcludeFile /*= NULL*/)
// pcszExcludeFile - file to be excluded while searching in the path.
// Return TRUE if pcszPath is non-existent or empty; otherwise, return FALSE
{
    BOOL fRet = TRUE;
    TCHAR szSrcFile[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hFindFile;
    

    if (!PathIsDirectory(pcszPath))
        return TRUE;
    
    PathCombine(szSrcFile, pcszPath, TEXT("*.*"));
    
    if (pcszExcludeFile != NULL)
        pcszExcludeFile = PathFindFileName(pcszExcludeFile);

    if ((hFindFile = FindFirstFile(szSrcFile, &fd)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (StrCmpI(fd.cFileName, TEXT("."))  &&  StrCmpI(fd.cFileName, TEXT("..")))
            {
                if(((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && HasFlag(dwFlags, FILES_ONLY)) ||
                   (pcszExcludeFile != NULL && StrCmpI(fd.cFileName, pcszExcludeFile) == 0))
                    continue;

                // pcszPath is not empty
                fRet = FALSE;
                break;
            }
        } while (FindNextFile(hFindFile, &fd));

        FindClose(hFindFile);
    }

    return fRet;
}

void PathReplaceWithLDIDs(LPTSTR pszPath)
{
    TCHAR szSearchDir[MAX_PATH];
    DWORD dwSize;

    // check IE dir first since IE is usually under programs files
    dwSize = sizeof(szSearchDir);
    if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\iexplore.exe"), NULL, NULL, 
        szSearchDir, &dwSize) == ERROR_SUCCESS)
    {
        PathRemoveFileSpec(szSearchDir);

        // note: we assume that IE install dir has been defined as custom LDID 49100 here
        if (replaceSubString(pszPath, szSearchDir, TEXT("%49100%")))
            return;
    }

    dwSize = sizeof(szSearchDir);
    if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, TEXT("ProgramFilesDir"), NULL, 
        szSearchDir, &dwSize) == ERROR_SUCCESS)
    {
        PathRemoveBackslash(szSearchDir);
        // note: we assume that program files has been defined as custom LDID 49000 here
        if (replaceSubString(pszPath, szSearchDir, TEXT("%49000%")))
            return;
    }

    // check system before windows since windows is usually a substring of system
    if (GetSystemDirectory(szSearchDir, countof(szSearchDir)))
    {
        PathRemoveBackslash(szSearchDir);
        if (replaceSubString(pszPath, szSearchDir, TEXT("%11%")))
            return;
    }

    // check windows dir last
    if (GetWindowsDirectory(szSearchDir, countof(szSearchDir)))
    {
        PathRemoveBackslash(szSearchDir);
        if (replaceSubString(pszPath, szSearchDir, TEXT("%10%")))
            return;
    }
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helpers routines (private)

DWORD pepHrToPep(HRESULT hr)
{
    DWORD dwResult;

    if (hr == S_OK)
        dwResult = PEP_RCRS_DEFAULT;

    else if (hr == S_FALSE)
        dwResult = PEP_RCRS_FALSE;

    else if (hr == PEP_S_CONTINUE)
        dwResult = PEP_RCRS_CONTINUE;

    else if (hr == PEP_S_CONTINUE_FALSE)
        dwResult = PEP_RCRS_CONTINUE_FALSE;

    else {
        ASSERT(FAILED(hr));
        dwResult = PEP_RCRS_FAILED;
    }

    return dwResult;
}

void pepHrCallToHrResult(HRESULT hrCall, HRESULT &hrResult)
{
    if (hrCall == S_OK)
        hrResult = hrCall;

    else if (hrCall == S_FALSE) {
        ASSERT(hrResult == S_OK || hrResult == PEP_S_CONTINUE);
        hrResult = ((hrResult != PEP_S_CONTINUE) ? S_FALSE : PEP_S_CONTINUE_FALSE);
    }
    else if (hrCall == PEP_S_CONTINUE)
        hrCall = PEP_S_CONTINUE;

    else {
        ASSERT(FAILED(hrCall));
        hrResult = hrCall;
    }
}


BOOL replaceSubString(LPTSTR pszSrc, LPCTSTR pcszSub, LPCTSTR pcszReplace)
{
    LPTSTR pszStart = NULL;
    
    // replace pcszSub in pszSrc with pcszReplace (assumes pcszReplace is shorter than pcszSub)
    if ((pszStart = StrStrI(pszSrc, pcszSub)) != NULL) {
        int iReplace, iCurrent;

        // replace the substring
        iReplace = StrLen(pcszReplace);
        iCurrent = StrLen(pcszSub);
        StrCpy(pszStart, pcszReplace);
        StrCpy(pszStart+iReplace, pszStart + iCurrent);

        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\regins.cpp ===
#include "precomp.h"
#include "regins.h"

/////////////////////////////////////////////////////////////////////////////
// CRegInsMap operations

HRESULT CRegInsMap::PerformAction(HKEY *phk /*= NULL*/)
{
    (void)phk;
    return E_NOTIMPL;
}


HRESULT CRegInsMap::RegToIns(HKEY *phk /*= NULL*/, BOOL fClear /*= FALSE*/)
{
    TCHAR   szBuffer[MAX_PATH];
    VARIANT var;
    HKEY    hk;
    HRESULT hr;
    DWORD   cBuffer, dwType;
    LONG    lResult;

    if ((phk != NULL && *phk == NULL) && m_pszRegKey == NULL)
        return E_INVALIDARG;

    //----- Special cases processing -----

    //_____ Close cached reg key _____
    if ((phk != NULL && *phk != NULL) && (m_pszRegKey == NULL && m_pszRegValue == NULL)) {
        ASSERT(!fClear);
        ASSERT(m_pszInsSection == NULL && m_pszInsKey == NULL);

        SHCloseKey(*phk);
        *phk = NULL;
        return S_FALSE;
    }

    //_____ Clear ins file entry (not even necessary to open reg key) _____
    ASSERT(m_pszInsSection != NULL && m_pszInsKey != NULL);
    if (fClear) {
        ASSERT(phk == NULL);

        // REVIEW: (andrewgu) if i'm clearing and when last entry is gone see if section is gone
        // as well and if it is not, do getprivateprofilesection to see if section is empty and
        // delete it if it is.
        WritePrivateProfileString(m_pszInsSection, m_pszInsKey, NULL, s_pszIns);
        return S_FALSE;
    }

    //----- Main processing -----
    hk = (phk != NULL) ? *phk : NULL;
    openRegKey(&hk);
    if (hk == NULL)
        return E_FAIL;

    //_____ Special case of caching reg key _____
    if (m_pszInsSection == NULL) {
        ASSERT(m_pszInsKey == NULL);

        if (phk == NULL)
            return E_INVALIDARG;

        *phk = hk;
        return S_FALSE;
    }

    szBuffer[0] = TEXT('\0');
    cBuffer = sizeof(szBuffer);
    lResult = SHQueryValueEx(hk, m_pszRegValue, NULL, &dwType, szBuffer, &cBuffer);

    if (phk != NULL && *phk != hk)
        SHCloseKey(hk);

    if (lResult != ERROR_SUCCESS)
        return E_UNEXPECTED;

    //----- Convert szBuffer into var with proper type -----
    hr = S_OK;
    VariantClear(&var);

    switch (dwType) {
    case REG_BINARY:
        if (cBuffer > sizeof(int)) {
            hr = E_UNEXPECTED;
            break;
        }
        // fall through

//  case REG_DWORD_LITTLE_ENDIAN:
    case REG_DWORD:
        var.vt   = VT_I4;
        var.lVal = *(PINT)szBuffer;
        break;

    case REG_SZ:
    case REG_EXPAND_SZ:
        var.vt      = VT_BSTR;
        var.bstrVal = T2BSTR(szBuffer);
        break;

//  case REG_DWORD_BIG_ENDIAN:
//  case REG_LINK:
//  case REG_MULTI_SZ:
//  case REG_NONE:
//  case REG_RESOURCE_LIST:
    default:
        hr = E_FAIL;
    }
    if (FAILED(hr))
        return hr;

    //----- Convert var into szBuffer appropriate for WritePrivateProfileString -----
    switch (var.vt) {
    case VT_I4:
        wnsprintf(szBuffer, countof(szBuffer), TEXT("%l"), var.lVal);
        break;

    case VT_I2:
        wnsprintf(szBuffer, countof(szBuffer), TEXT("%i"), var.iVal);
        break;

    case VT_UI1:
        wnsprintf(szBuffer, countof(szBuffer), TEXT("%u"), (UINT)var.bVal);
        break;

    case VT_BOOL:
        wnsprintf(szBuffer, countof(szBuffer), TEXT("%u"), (UINT)var.boolVal);
        break;

    case VT_BSTR:
        W2Tbuf(var.bstrVal, szBuffer, countof(szBuffer));
        break;

    // too many cases to enumerate that are invalid
    default:
        hr = E_FAIL;
    }
    if (FAILED(hr))
        return hr;

    WritePrivateProfileString(m_pszInsSection, m_pszInsKey, szBuffer, s_pszIns);
    return S_OK;
}

HRESULT CRegInsMap::InsToReg(HKEY *phk /*= NULL*/, BOOL fClear /*= FALSE*/)
{
    (void)phk; (void)fClear;
    return E_NOTIMPL;
}


HRESULT CRegInsMap::RegToInsArray(CRegInsMap *prg, UINT cEntries, BOOL fClear /*= FALSE*/)
{
    HKEY    hk,
            *rghkStack;
    HRESULT hr;
    UINT    i, cStackDepth;
    BOOL    fContinueOnFailure,
            fTotalSuccess, fBufferOverrun;

    if (prg == NULL)
        return E_INVALIDARG;

    if (cEntries == 0)
        return S_OK;

    hr                 = S_OK;
    fContinueOnFailure = TRUE;
    fTotalSuccess      = TRUE;
    fBufferOverrun     = FALSE;

    if (fClear) {
        for (i = 0; i < cEntries; i++) {
            hr = prg->RegToIns(NULL, fClear);
            if (FAILED(hr)) {
                fTotalSuccess = FALSE;

                if (!fContinueOnFailure)
                    break;
            }
        }
        if (FAILED(hr))
            return hr;

        return fTotalSuccess ? S_OK : S_FALSE;
    }

    rghkStack = new HKEY[cEntries/2 + 1];
    if (rghkStack == NULL)
        return E_OUTOFMEMORY;
    cStackDepth = 0;

    for (i = 0; i < cEntries; i++) {
        if (cStackDepth == 0)
            hk = NULL;

        else {
            hk = rghkStack[cStackDepth-1];
            ASSERT(hk != NULL);
        }

        hr = prg->RegToIns(&hk);
        if (FAILED(hr)) {
            fTotalSuccess = FALSE;

            if (fContinueOnFailure)
                continue;
            else
                break;
        }

        if (hk != NULL) {
            if (hk != rghkStack[cStackDepth-1]) {
                if (cStackDepth >= cEntries/2 + 1) {
                    SHCloseKey(hk);

                    hr             = E_UNEXPECTED;
                    fTotalSuccess  = FALSE;
                    fBufferOverrun = TRUE;
                    break;
                }

                rghkStack[cStackDepth++] = hk;
            }
        }
        else
            if (cStackDepth > 0)
                rghkStack[--cStackDepth] = NULL;
    }

    if (FAILED(hr)) {
        ASSERT(!fTotalSuccess);

        for (i = 0; i < cEntries/2 + 1; i++)
            if (rghkStack[i] != NULL) {
                SHCloseKey(rghkStack[i]);
                rghkStack[i] = NULL;
            }
        cStackDepth = 0;
    }

    ASSERT(cStackDepth == 0);
    delete[] rghkStack;

    if (!fBufferOverrun)
        if (fContinueOnFailure && !fTotalSuccess)
            hr = S_FALSE;

    return hr;
}

HRESULT CRegInsMap::InsToRegArray(CRegInsMap *prg, UINT cEntries, BOOL fClear /*= FALSE*/)
{
    (void)prg; (void)cEntries; (void)fClear;
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CRegInsMap implementation helper routines

void CRegInsMap::openRegKey(HKEY *phk)
{
    LPCTSTR pszRegKey;
    HRESULT hr;
    LONG    lResult;

    ASSERT(phk != NULL);
    if (*phk != NULL && m_pszRegKey == NULL)
        return;

    ASSERT(m_pszRegKey != NULL);

    if (*phk == NULL) {
        hr = getHive(phk, &pszRegKey);
        if (FAILED(hr)) {
            ASSERT(*phk == NULL && pszRegKey == NULL);
            return;
        }

        ASSERT(*phk != NULL && pszRegKey != NULL);
    }
    else {
        ASSERT(getHive(NULL, NULL, GH_LOOKUPONLY) != S_OK);
        pszRegKey = m_pszRegKey;
    }

    lResult = SHOpenKey(*phk, pszRegKey, KEY_QUERY_VALUE, phk);
    if (lResult != ERROR_SUCCESS) {
        ASSERT(*phk == NULL);
    }
}

HRESULT CRegInsMap::getHive(HKEY *phk, LPCTSTR *ppszRegKey, WORD wFlags /*= GH_DEFAULT*/)
{
    LPCTSTR pszSlash;

    if (!(wFlags & GH_LOOKUPONLY)) {
        if (phk == NULL || ppszRegKey == NULL)
            return E_INVALIDARG;

        *phk        = NULL;
        *ppszRegKey = NULL;
    }

    pszSlash = StrChr(m_pszRegKey, TEXT('\\'));
    if (pszSlash == NULL)
        return E_FAIL;
    ASSERT(*(pszSlash+1) != TEXT('\0'));

    struct {
        HKEY    hk;
        LPCTSTR pszHive;
    } map[] = {
        { HKEY_CLASSES_ROOT,  RH_HKCR },
        { HKEY_CURRENT_USER,  RH_HKCU },
        { HKEY_LOCAL_MACHINE, RH_HKLM },
        { HKEY_USERS,         RH_HKU  }
    };

    for (UINT i = 0; i < countof(map); i++)
        if (StrCmpNI(m_pszRegKey, map[i].pszHive, INT(m_pszRegKey-pszSlash) + 1) == 0)
            break;
    if (i >= countof(map)) {
        if (!(wFlags & GH_LOOKUPONLY))
            *ppszRegKey = m_pszRegKey;

        return S_FALSE;
    }

    if (!(wFlags & GH_LOOKUPONLY)) {
        *phk        = map[i].hk;
        *ppszRegKey = pszSlash + 1;
    }

    return S_OK;
}


// HINTS: (andrewgu) on optimization
// 1. to start a regkey optimization section (i.e. to cache a reg key) have InsSection set to
//    NULL, at the same time InsKey is ASSERTed NULL, meaning it better be NULL too;
// 2. to close last cached key, have RegKey and RegValue equal NULL. also InsSection and InsKey
//    are ASSERTed NULL, so they also should be NULL;
// 3. if in optimization section and reg key is not empty current cached hk will be combined with
//    regkey, it'll ASSERT if finds hive in RegKey;
// 4. if hive is not found in RegKey and the object is not in the optimization section it's an error
// 5. nested optimization sections are allowed

/*
LPCTSTR CRegInsMap::s_pszIns = TEXT("c:\foo.ini");

CRegInsMap rgTest1  = { TEXT("HKLM\\RegKey0"), TEXT("RegValue0"), 0L, NULL, NULL };
CRegInsMap rgTest[] = {
    { RH_HKLM TEXT("RegKey0"), NULL, 0L, NULL, NULL },
        { TEXT("RegKey1"), TEXT("RegValue1"), 0L, TEXT("InsSection1"), TEXT("InsKey1") },
        { NULL           , TEXT("RegValue2"), 0L, TEXT("InsSection1"), TEXT("InsKey2") },
    { NULL, NULL, 0L, NULL, NULL },

    { RH_HKCR RK_IEAK, RV_TOOLBARBMP, 0L, IS_BRANDING, IK_TOOLBARBMP },
    { TEXT("RegKey4"), TEXT("RegValue4"), 0L, TEXT("InsSection4"), TEXT("InsKey4") },
    { TEXT("RegKey5"), TEXT("RegValue5"), 0L, TEXT("InsSection5"), TEXT("InsKey5") },
    { TEXT("RegKey6"), TEXT("RegValue6"), 0L, TEXT("InsSection6"), TEXT("InsKey6") },
    { TEXT("RegKey7"), TEXT("RegValue7"), 0L, TEXT("InsSection7"), TEXT("InsKey7") },
    { TEXT("RegKey8"), TEXT("RegValue8"), 0L, TEXT("InsSection8"), TEXT("InsKey8") },
    { TEXT("RegKey9"), TEXT("RegValue9"), 0L, TEXT("InsSection9"), TEXT("InsKey9") }
};

// Example usage
rgTest[0].RegToInsArray(rgTest, countof(rgTest));
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\unicwrap.h ===
#ifndef _UNICWRAP_H_
#define _UNICWRAP_H_

#include <shellapi.h>          // LPSHFILEOPSTRUCT
#include <advpub.h>
#include <inseng.h>

//----- tchar wrappers for functions we need to thunk on our own ----
// for functions which don't have their W versions implemented on 9x be sure to undef
// the TCHAR macro below so that the appropriate wrapper will be used for W version calls

// advpack

HRESULT ExtractFilesWrapW(LPCWSTR pszCabName, LPCWSTR pszExpandDir, DWORD dwFlags,
                          LPCWSTR pszFileList, LPVOID lpReserved, DWORD dwReserved);
HRESULT GetVersionFromFileWrapW(LPWSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);
HRESULT RunSetupCommandWrapW(HWND hWnd, LPCWSTR szCmdName, LPCWSTR szInfSection, LPCWSTR szDir,
                             LPCWSTR lpszTitle, HANDLE *phEXE, DWORD dwFlags, LPVOID pvReserved );

// inseng

HRESULT CheckTrustExWrapW(LPCWSTR wszUrl, LPCWSTR wszFilename, HWND hwndForUI, BOOL bShowBadUI, DWORD dwReserved);

// kernel32

DWORD   GetPrivateProfileStringW_p(LPCWSTR lpAppName, LPCWSTR lpSectionName, LPCWSTR lpDefault,
                                   LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
DWORD   GetPrivateProfileSectionWrapW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
BOOL    WritePrivateProfileSectionWrapW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName);
UINT    GetDriveTypeWrapW(LPCWSTR lpRootPathName);
HANDLE  OpenMutexWrapW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);

// advapi32

BOOL    LookupPrivilegeValueWrapW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);
LONG    RegLoadKeyWrapW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile);
LONG    RegUnLoadKeyWrapW(HKEY hKey, LPCWSTR lpSubKey);
LONG    RegSaveKeyWrapW(HKEY hKey, LPCWSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes); 

// shell32

int SHFileOperationW_p(LPSHFILEOPSTRUCT lpFileOp);

// util

BOOL RunAndWaitA(LPSTR pszCmd, LPCSTR pcszDir, WORD wShow, LPDWORD lpExitCode = NULL);
BOOL RunAndWaitW(LPWSTR pwszCmd, LPCWSTR pcwszDir, WORD wShow, LPDWORD lpExitCode = NULL);

#ifdef UNICODE 
#define ExtractFilesWrap                ExtractFilesWrapW
#define GetVersionFromFileWrap          GetVersionFromFileWrapW
#define RunSetupCommandWrap             RunSetupCommandWrapW
#define CheckTrustExWrap                CheckTrustExWrapW
#define GetPrivateProfileString_p       GetPrivateProfileStringW_p
#define GetPrivateProfileSectionWrap    GetPrivateProfileSectionWrapW
#define WritePrivateProfileSectionWrap  WritePrivateProfileSectionWrapW
#define GetDriveTypeWrap                GetDriveTypeWrapW
#define OpenMutexWrap                   OpenMutexWrapW
#define LookupPrivilegeValueWrap        LookupPrivilegeValueWrapW
#define RegLoadKeyWrap                  RegLoadKeyWrapW
#define RegUnLoadKeyWrap                RegUnLoadKeyWrapW
#define RegSaveKeyWrap                  RegSaveKeyWrapW
#define SHFileOperation_p               SHFileOperationW_p
#define RunAndWait                      RunAndWaitW
#else
#define ExtractFilesWrap                ExtractFiles
#define GetVersionFromFileWrap          GetVersionFromFile
#define RunSetupCommandWrap             RunSetupCommand
#define CheckTrustExWrap                CheckTrustEx
#define GetPrivateProfileString_p       GetPrivateProfileStringA
#define GetPrivateProfileSectionWrap    GetPrivateProfileSectionA
#define WritePrivateProfileSectionWrap  WritePrivateProfileSectionA
#define GetDriveTypeWrap                GetDriveTypeA
#define OpenMutexWrap                   OpenMutexA
#define LookupPrivilegeValueWrap        LookupPrivilegeValueA
#define RegLoadKeyWrap                  RegLoadKeyA
#define RegUnLoadKeyWrap                RegUnLoadKeyA
#define RegSaveKeyWrap                  RegSaveKeyA
#define SHFileOperation_p               SHFileOperationA
#define RunAndWait                      RunAndWaitA
#endif

// undef the macros to resolve these calls we wrap so that we can resolve them to our wrappers
// make sure the win header actually defines the macro you undef, otherwise you'll have to
// call the Wrap explicitly everywhere

#ifndef GetPrivateProfileString
#error  GetPrivateProfileString undefined
#else
#undef  GetPrivateProfileString
#endif
#define GetPrivateProfileString     GetPrivateProfileString_p

#ifndef GetPrivateProfileSection
#error  GetPrivateProfileSection undefined
#else
#undef  GetPrivateProfileSection
#endif
#define GetPrivateProfileSection    GetPrivateProfileSectionWrap

#ifndef WritePrivateProfileSection
#error  WritePrivateProfileSection undefined
#else
#undef  WritePrivateProfileSection
#endif
#define WritePrivateProfileSection  WritePrivateProfileSectionWrap

#ifndef GetDriveType
#error  GetDriveType undefined
#else
#undef  GetDriveType
#endif
#define GetDriveType                GetDriveTypeWrap

#ifndef OpenMutex
#error  OpenMutex undefined
#else
#undef  OpenMutex
#endif
#define OpenMutex                   OpenMutexWrap

#ifndef LookupPrivilegeValue
#error  LookupPrivilegeValue undefined
#else
#undef  LookupPrivilegeValue
#endif
#define LookupPrivilegeValue        LookupPrivilegeValueWrap

#ifndef RegLoadKey
#error  RegLoadKey undefined
#else
#undef  RegLoadKey
#endif
#define RegLoadKey                  RegLoadKeyWrap

#ifndef RegUnLoadKey
#error  RegUnLoadKey undefined
#else
#undef  RegUnLoadKey                
#define RegUnLoadKey                RegUnLoadKeyWrap
#endif

#ifndef RegSaveKey
#error  RegSaveKey undefined
#else
#undef  RegSaveKey                
#define RegSaveKey                  RegSaveKeyWrap
#endif

#ifndef SHFileOperation
#error  SHFileOperation undefined
#else
#undef  SHFileOperation
#endif
#define SHFileOperation             SHFileOperation_p

#endif   // _UNICWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\regins.h ===
#ifndef __REGINS_H_
#define __REGINS_H_

#define RH_HKCR TEXT("HKCR\\")
#define RH_HKCU TEXT("HKCU\\")
#define RH_HKLM TEXT("HKLM\\")
#define RH_HKU  TEXT("HKU\\")

struct CRegInsMap {
// Operations
public:
    HRESULT PerformAction(HKEY *phk = NULL);

    HRESULT RegToIns(HKEY *phk = NULL, BOOL fClear = FALSE);
    HRESULT InsToReg(HKEY *phk = NULL, BOOL fClear = FALSE);

    HRESULT RegToInsArray(CRegInsMap *prg, UINT cEntries, BOOL fClear = FALSE);
    HRESULT InsToRegArray(CRegInsMap *prg, UINT cEntries, BOOL fClear = FALSE);

// Properties
public:
    LPCTSTR m_pszRegKey;
    LPCTSTR m_pszRegValue;

    DWORD m_dwFlags;

    static LPCTSTR s_pszIns;
    LPCTSTR m_pszInsSection;
    LPCTSTR m_pszInsKey;

// Implementation
public:
    // implementation helper routines
    void openRegKey(HKEY *phk);

    #define GH_LOOKUPONLY 0x0001
    #define GH_DEFAULT    0x0000
    HRESULT getHive(HKEY *phk, LPCTSTR *ppszRegKey, WORD wFlags = GH_DEFAULT);

    // REVIEW: (andrewgu)
    // 1. add support for removing values not just moving;
    // 2. add support for reusing the reg key (perf) also if hk is provided and so is reg key,
    // open the key still but base it on hk;
    // 3. (shortcoming) in a run through array there'll be calls to getHive for every item, the
    // hive information will be lost from m_pszRegKey. this means that only one run is possible.
    // in order to perform another run, the array needs to be reinitialized. in order to fix this
    // problem, HKEY member variable is needed in CRegInsMap;
    // 4. (ideas for the next round of work) remove m_var, replace it with m_dwFlags. the benifits
    // are numerious:
    // - saves memory;
    // - m_var doesn't handle everthing; support is required for things like File, YesToBool,
    //   BoolToYes, String, Number, Bool;
    // - the same m_dwFlags can hold the fClear flag;
    // - one usefull thing to add would be Action flags, like RegToIns or InsToReg, it can be ORed
    // with fClear and stored in the samae m_dwFlags;
    // 5. set of macros to mask the complexity of building the static array of map entries;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\unicwrap.cpp ===
#include "precomp.h"

// this class is used by our private wrappers to thunk unicode to ansi and take care of
// all the allocation goo.  There are three constructors: use LPCWSTR if you just need
// to thunk a normal string to ansi, use LPCWSTR, LPDWORD if you need to thunk a list of
// null-terminated strings to ansi, and use DWORD if you need a buffer for an out 
// parameter

class CAnsiStr
{
private:
    CHAR m_szBuf[MAX_PATH];
    BOOL m_fFree;

public:
    LPSTR pszStr;

    CAnsiStr(LPCWSTR);
    CAnsiStr(LPCWSTR, LPDWORD pcchSize);
    CAnsiStr(DWORD cchSize);
    ~CAnsiStr();
};

CAnsiStr::CAnsiStr(LPCWSTR pcwszStr)
{
    if (pcwszStr == NULL)
    {
        m_fFree = FALSE;
        pszStr = NULL;
    }
    else
    {
        DWORD cchSize = StrLenW(pcwszStr);
        DWORD cbSize, dwErr;

        m_fFree = (cchSize > (countof(m_szBuf) - 1));
        if (m_fFree)
        {
            pszStr = (LPSTR)CoTaskMemAlloc(cchSize+1);
            if (pszStr == NULL)
            {
                m_fFree = FALSE;
                return;
            }
            else
                ZeroMemory(pszStr, cchSize+1);
        }
        else
            pszStr = m_szBuf;

        cbSize = WideCharToMultiByte(CP_ACP, 0, pcwszStr, cchSize+1, pszStr, cchSize+1, NULL, NULL);
        dwErr = GetLastError();

        // NOTE: check to see if we fail, in which case we might be dealing with DBCS chars and
        //       need to reallocate or allocate

        if ((cbSize == 0) && (dwErr == ERROR_INSUFFICIENT_BUFFER))
        {
            cbSize = WideCharToMultiByte(CP_ACP, 0, pcwszStr, cchSize+1, pszStr, 0, NULL, NULL);

            if (m_fFree)
            {
                LPSTR pszStr2;

                // need this second ptr because CoTaskMemRealloc doesn't free the old block if 
                // not enough mem for the new one

                pszStr2 = (LPSTR)CoTaskMemRealloc(pszStr, cbSize);

                if (pszStr2 == NULL)
                    CoTaskMemFree(pszStr);

                pszStr = pszStr2;
            }
            else
            {
                m_fFree = (cbSize > countof(m_szBuf));

                if (m_fFree)
                    pszStr = (LPSTR)CoTaskMemAlloc(cbSize);
            }

            if (m_fFree && (pszStr == NULL))
            {
                m_fFree = FALSE;
                return;
            }

            WideCharToMultiByte(CP_ACP, 0, pcwszStr, cchSize+1, pszStr, cbSize, NULL, NULL);
        }
    }
}

CAnsiStr::CAnsiStr(LPCWSTR pcwszStr, LPDWORD pcchSize)
{
    if (pcchSize != NULL)
        *pcchSize = 0;

    if (pcwszStr == NULL)
    {
        m_fFree = FALSE;
        pszStr = NULL;
    }
    else
    {
        DWORD cchSize = 0;
        DWORD cbSize, dwErr;

        for (LPCWSTR pcwsz = pcwszStr; *pcwsz; )
        {
            DWORD cchStrSize = StrLenW(pcwsz)+1;
            cchSize += cchStrSize;
            pcwsz += cchStrSize;
        }

        m_fFree = (cchSize > (ARRAYSIZE(m_szBuf) - 1));
        if (m_fFree)
        {
            pszStr = (LPSTR)CoTaskMemAlloc(cchSize+1);
            if (pszStr == NULL)
            {
                m_fFree = FALSE;
                return;
            }
            else
                ZeroMemory(pszStr, cchSize+1);
        }
        else
            pszStr = m_szBuf;

        cbSize = WideCharToMultiByte(CP_ACP, 0, pcwszStr, cchSize+1, pszStr, cchSize+1, NULL, NULL);
        dwErr = GetLastError();

        // NOTE: check to see if we fail, in which case we might be dealing with DBCS chars and
        //       need to reallocate or allocate

        if ((cbSize == 0) && (dwErr == ERROR_INSUFFICIENT_BUFFER))
        {
            cbSize = WideCharToMultiByte(CP_ACP, 0, pcwszStr, cchSize+1, pszStr, 0, NULL, NULL);

            if (m_fFree)
            {
                LPSTR pszStr2;

                // need this second ptr because CoTaskMemRealloc doesn't free the old block if 
                // not enough mem for the new one

                pszStr2 = (LPSTR)CoTaskMemRealloc(pszStr, cbSize);

                if (pszStr2 == NULL)
                    CoTaskMemFree(pszStr);

                pszStr = pszStr2;
            }
            else
            {
                m_fFree = (cbSize > countof(m_szBuf));

                if (m_fFree)
                    pszStr = (LPSTR)CoTaskMemAlloc(cbSize);
            }

            if (m_fFree && (pszStr == NULL))
            {
                m_fFree = FALSE;
                return;
            }

            WideCharToMultiByte(CP_ACP, 0, pcwszStr, cchSize+1, pszStr, cbSize, NULL, NULL);
        }

        if (pcchSize != NULL)
            *pcchSize = cchSize;
    }
}

CAnsiStr::CAnsiStr(DWORD cchSize)
{
    m_fFree = (cchSize > ARRAYSIZE(m_szBuf));
    if (m_fFree)
    {
        pszStr = (LPSTR)CoTaskMemAlloc(cchSize);
        if (pszStr == NULL)
        {
            m_fFree = FALSE;
            return;
        }
        else
            ZeroMemory(pszStr, cchSize);
    }
    else
    {
        pszStr = m_szBuf;
        ZeroMemory(pszStr, cchSize);
    }
}

CAnsiStr::~CAnsiStr()
{
    if (m_fFree && (pszStr != NULL))
        CoTaskMemFree(pszStr);
}

//------ advpack wrappers --------
// advpack is exclusively ANSI so have to thunk for UNICODE

HRESULT ExtractFilesWrapW(LPCWSTR pszCabName, LPCWSTR pszExpandDir, DWORD dwFlags,
                          LPCWSTR pszFileList, LPVOID lpReserved, DWORD dwReserved)
{
    CAnsiStr astrFileList(pszFileList, NULL);

    USES_CONVERSION;

    if ((pszFileList != NULL) && (astrFileList.pszStr == NULL))
    {
        // class memory allocation failed

        ASSERT(FALSE);
        return E_OUTOFMEMORY;
    }

    return ExtractFiles(W2CA(pszCabName), W2CA(pszExpandDir), dwFlags,
                        (LPCSTR)astrFileList.pszStr, lpReserved, dwReserved);
}

HRESULT GetVersionFromFileWrapW(LPWSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion)
{
    USES_CONVERSION;

    return GetVersionFromFile(W2A(lpszFilename), pdwMSVer, pdwLSVer, bVersion);
}

HRESULT RunSetupCommandWrapW(HWND hWnd, LPCWSTR szCmdName, LPCWSTR szInfSection, LPCWSTR szDir,
                             LPCWSTR lpszTitle, HANDLE *phEXE, DWORD dwFlags, LPVOID pvReserved )
{
    USES_CONVERSION;

    return RunSetupCommand(hWnd, W2CA(szCmdName), W2CA(szInfSection), W2CA(szDir),
                           W2CA(lpszTitle), phEXE, dwFlags, pvReserved);
}

//------ inseng wrappers --------
// inseng is exclusively ANSI so have to thunk for UNICODE

HRESULT CheckTrustExWrapW(LPCWSTR wszUrl, LPCWSTR wszFilename, HWND hwndForUI, BOOL bShowBadUI, DWORD dwReserved)
{
    USES_CONVERSION;

    return CheckTrustEx(W2CA(wszUrl), W2CA(wszFilename), hwndForUI, bShowBadUI, dwReserved);
}

// either shlwapi doesn't implement wrappers or their wrappers have limitations on these APIs

//------ kernel32 wrappers --------

// this is the equivalent of GetPrivateProfileString and should only be called if lpAppName
// and/or lpSectionName is NULL.  shlwapi's wrappers doesn't handle the series of NULL-terminated
// strings

DWORD GetPrivateProfileStringW_p(LPCWSTR lpAppName, LPCWSTR lpSectionName, LPCWSTR lpDefault, 
                                LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
{
    DWORD dwRetLen;

    USES_CONVERSION;

    // this occurence of GetPrivateProfileStringW is actually wrapped by shlwapi itself so
    // you won't actually ever see GetPrivateProfileStringW in the import table for your module

    if (IsOS(OS_NT))
        dwRetLen = GetPrivateProfileStringW(lpAppName, lpSectionName, lpDefault, lpReturnedString, nSize, lpFileName);
    else
    {
        CAnsiStr astrReturnedString(nSize);
        
        if (astrReturnedString.pszStr == NULL)
        {
            // class memory allocation failed
            
            ASSERT(FALSE);
            return 0;
        }

        dwRetLen = GetPrivateProfileStringA(W2CA(lpAppName), W2CA(lpSectionName), W2CA(lpDefault),
                                            astrReturnedString.pszStr, nSize, W2CA(lpFileName));

        MultiByteToWideChar(CP_ACP, 0, astrReturnedString.pszStr, dwRetLen+1, lpReturnedString, nSize);

        // handle possible truncation

        if (((lpAppName == NULL) || (lpSectionName == NULL))
            && (dwRetLen == (nSize - 2)))
            lpReturnedString[nSize - 1] = TEXT('\0');
    }

    return dwRetLen;
}

DWORD GetPrivateProfileSectionWrapW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
{
    DWORD dwRetLen;

    USES_CONVERSION;

    if (IsOS(OS_NT))
        dwRetLen = GetPrivateProfileSectionW(lpAppName, lpReturnedString, nSize, lpFileName);
    else
    {
        CAnsiStr astrReturnedString(nSize);

        if (astrReturnedString.pszStr == NULL)
        {
            // class memory allocation failed
            
            ASSERT(FALSE);
            return 0;
        }

        dwRetLen = GetPrivateProfileSectionA(W2CA(lpAppName), astrReturnedString.pszStr, nSize, W2CA(lpFileName));

        MultiByteToWideChar(CP_ACP, 0, astrReturnedString.pszStr, dwRetLen+1, lpReturnedString, nSize);

        // null terminate the end of the buffer if size is insufficient

        if (dwRetLen == (nSize - 2))
            lpReturnedString[nSize - 1] = TEXT('\0');
    }
    

    return dwRetLen;
}

BOOL WritePrivateProfileSectionWrapW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
{
    USES_CONVERSION;

    if (IsOS(OS_NT))
        return WritePrivateProfileSectionW(lpAppName, lpString, lpFileName);
    else
    {
        CAnsiStr astrString(lpString, NULL);

        return WritePrivateProfileSectionA(W2CA(lpAppName), astrString.pszStr, W2CA(lpFileName));
    }
}

UINT GetDriveTypeWrapW(LPCWSTR lpRootPathName)
{
    USES_CONVERSION;

    if (IsOS(OS_NT))
        return GetDriveTypeW(lpRootPathName);
    else
        return GetDriveTypeA(W2CA(lpRootPathName));
}

HANDLE  OpenMutexWrapW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
{
    USES_CONVERSION;

    if (IsOS(OS_NT))
        return OpenMutexW(dwDesiredAccess, bInheritHandle, lpName);
    else
        return OpenMutexA(dwDesiredAccess, bInheritHandle, W2CA(lpName));
}

//------ advapi32 wrappers --------

BOOL LookupPrivilegeValueWrapW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
{
    USES_CONVERSION;

    if (IsOS(OS_NT))
        return LookupPrivilegeValueW(lpSystemName, lpName, lpLuid);
    else
        return LookupPrivilegeValueA(W2CA(lpSystemName), W2CA(lpName), lpLuid);
}

LONG RegLoadKeyWrapW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
{
    USES_CONVERSION;

    if (IsOS(OS_NT))
        return RegLoadKeyW(hKey, lpSubKey, lpFile);
    else
        return RegLoadKeyA(hKey, W2CA(lpSubKey), W2CA(lpFile));
}

LONG RegUnLoadKeyWrapW(HKEY hKey, LPCWSTR lpSubKey)
{
    USES_CONVERSION;

    if (IsOS(OS_NT))
        return RegUnLoadKeyW(hKey, lpSubKey);
    else
        return RegUnLoadKeyA(hKey, W2CA(lpSubKey));
}

LONG RegSaveKeyWrapW(HKEY hKey, LPCWSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    USES_CONVERSION;

    if (IsOS(OS_NT))
        return RegSaveKeyW(hKey, lpFile, lpSecurityAttributes);
    else
        return RegSaveKeyA(hKey, W2CA(lpFile), lpSecurityAttributes);
}

//------ shell32 wrappers --------

int SHFileOperationW_p(LPSHFILEOPSTRUCTW lpFileOpW)
{
    int iRet;

    USES_CONVERSION;

    if (IsOS(OS_NT))
        iRet =  SHFileOperationW(lpFileOpW);
    else
    {
        SHFILEOPSTRUCTA shInfo;
        CAnsiStr * pastrIn = NULL;
        CAnsiStr * pastrOut = NULL;


        ZeroMemory(&shInfo, sizeof(shInfo));

        shInfo.fAnyOperationsAborted = lpFileOpW->fAnyOperationsAborted;
        shInfo.fFlags = lpFileOpW->fFlags;
        shInfo.hNameMappings = lpFileOpW->hNameMappings;
        shInfo.hwnd = lpFileOpW->hwnd;
        shInfo.lpszProgressTitle = W2A(lpFileOpW->lpszProgressTitle);
        shInfo.wFunc = lpFileOpW->wFunc;

        pastrIn = new CAnsiStr(lpFileOpW->pFrom, NULL);

        if ((pastrIn == NULL) || (pastrIn->pszStr == NULL))
        {
            // allocation failed
            
            ASSERT(FALSE);
            return E_OUTOFMEMORY;
        }

        shInfo.pFrom = pastrIn->pszStr;

             
        if (lpFileOpW->fFlags & FOF_MULTIDESTFILES)
        {
            pastrOut = new CAnsiStr(lpFileOpW->pTo, NULL);
            if ((pastrOut == NULL) || (pastrOut->pszStr == NULL))
            {
                // allocation failed
                
                ASSERT(FALSE);
                return E_OUTOFMEMORY;
            }
            shInfo.pTo = pastrOut->pszStr;
        }
        else
            shInfo.pTo = W2A(lpFileOpW->pTo);

        iRet = SHFileOperationA(&shInfo);

        if (pastrIn != NULL)
            delete pastrIn;

        if (pastrOut != NULL)
            delete pastrOut;
    }

    return iRet;
}

//------ private util wrappers --------

BOOL RunAndWaitA(LPSTR pszCmd, LPCSTR pcszDir, WORD wShow, LPDWORD lpExitCode  /* = NULL */)
{
    PROCESS_INFORMATION pi;
    STARTUPINFOA        stiA;
    MSG                 msg;

    ZeroMemory(&stiA, sizeof(stiA));
    stiA.cb = sizeof(stiA);
    stiA.dwFlags = STARTF_USESHOWWINDOW;
    stiA.wShowWindow = wShow;

    USES_CONVERSION;
    if (!CreateProcessA(NULL, pszCmd, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, pcszDir, &stiA, &pi))
        return FALSE;

    // wait for the process to finish
    while (MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

    if (lpExitCode)
        GetExitCodeProcess(pi.hProcess, lpExitCode);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    return TRUE;
}

BOOL RunAndWaitW(LPWSTR pwszCmd, LPCWSTR pcwszDir, WORD wShow, LPDWORD lpExitCode  /* = NULL */)
{
    PROCESS_INFORMATION pi;
    STARTUPINFOW        stiW;
    MSG                 msg;

    ZeroMemory(&stiW, sizeof(stiW));
    stiW.cb = sizeof(stiW);
    stiW.dwFlags = STARTF_USESHOWWINDOW;
    stiW.wShowWindow = wShow;

    USES_CONVERSION;
    if (!CreateProcessW(NULL, pwszCmd, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, pcwszDir, &stiW, &pi))
        return FALSE;

    // wait for the process to finish
    while (MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

    if (lpExitCode)
        GetExitCodeProcess(pi.hProcess, lpExitCode);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieakutil\str.cpp ===
#include "precomp.h"

int StrPrepend(LPTSTR pszSource, UINT cchSource, LPCTSTR pszAdd, UINT cchAdd /*= 0*/)
{
    int iLen;

    if (pszSource == NULL)
        return -1;

    iLen = StrLen(pszSource);

    if (cchAdd == 0)
        cchAdd = StrLen(pszAdd);
    if (cchAdd == 0)
        return iLen;

    if (iLen + cchAdd >= cchSource)
        return -1;

    MoveMemory(pszSource + cchAdd, pszSource, StrCbFromCch(iLen + 1));
    CopyMemory(pszSource, pszAdd, StrCbFromCch(cchAdd));

    return iLen + cchAdd;
}


void StrRemoveAllWhiteSpace(LPTSTR pszBuf)
{
    LPTSTR pszSearch;
    TCHAR tchar;
    int i = 0;

    for (i = 0, pszSearch = pszBuf; *pszSearch; i++, pszSearch++)
    {
        tchar = *pszSearch;
        while ((tchar == TEXT(' ')) || (tchar == TEXT('\t')) ||
            (tchar == TEXT('\r')) || (tchar == TEXT('\n')))
        {
            pszSearch++;
            tchar = *pszSearch;
        }
        pszBuf[i] = *pszSearch;
        if (!*pszSearch)
            break;
    }
    pszBuf[i] = TEXT('\0');
}

LPTSTR StrGetNextField(LPTSTR *ppszData, LPCTSTR pcszDeLims, DWORD dwFlags)
// If (dwFlags & IGNORE_QUOTES) is TRUE, then look for any char in pcszDeLims in *ppszData.  If found,
// replace it with the '\0' char and set *ppszData to point to the beginning of the next field and return
// pointer to current field.
//
// If (dwFlags & IGNORE_QUOTES) is FALSE, then look for any char in pcszDeLims outside of balanced quoted sub-strings
// in *ppszData.  If found, replace it with the '\0' char and set *ppszData to point to the beginning of
// the next field and return pointer to current field.
//
// If (dwFlags & REMOVE_QUOTES) is TRUE, then remove the surrounding quotes and replace two consecutive quotes by one.
//
// NOTE: If IGNORE_QUOTES and REMOVE_QUOTES are both specified, then IGNORE_QUOTES takes precedence over REMOVE_QUOTES.
//
// If you just want to remove the quotes from a string, call this function as
// GetNextField(&pszData, "\"" or "'" or "", REMOVE_QUOTES).
//
// If you call this function as GetNextField(&pszData, "\"" or "'" or "", 0), you will get back the
// entire pszData as the field.
//
{
    LPTSTR pszRetPtr, pszPtr;
    BOOL fWithinQuotes = FALSE, fRemoveQuote;
    TCHAR chQuote = TEXT('\0');

    if (ppszData == NULL  ||  *ppszData == NULL  ||  **ppszData == TEXT('\0'))
        return NULL;

    for (pszRetPtr = pszPtr = *ppszData;  *pszPtr;  pszPtr = CharNext(pszPtr))
    {
        if (!(dwFlags & IGNORE_QUOTES)  &&  (*pszPtr == TEXT('"')  ||  *pszPtr == TEXT('\'')))
        {
            fRemoveQuote = FALSE;

            if (*pszPtr == *(pszPtr + 1))           // two consecutive quotes become one
            {
                pszPtr++;

                if (dwFlags & REMOVE_QUOTES)
                    fRemoveQuote = TRUE;
                else
                {
                    // if pcszDeLims is '"' or '\'', then *pszPtr == pcszDeLims would
                    // be TRUE and we would break out of the loop against the design specs;
                    // to prevent this just continue
                    continue;
                }
            }
            else if (!fWithinQuotes)
            {
                fWithinQuotes = TRUE;
                chQuote = *pszPtr;                  // save the quote char

                fRemoveQuote = dwFlags & REMOVE_QUOTES;
            }
            else
            {
                if (*pszPtr == chQuote)             // match the correct quote char
                {
                    fWithinQuotes = FALSE;
                    fRemoveQuote = dwFlags & REMOVE_QUOTES;
                }
            }

            if (fRemoveQuote)
            {
                // shift the entire string one char to the left to get rid of the quote char
                MoveMemory(pszPtr, pszPtr + 1, StrCbFromCch(StrLen(pszPtr)));
            }
        }

        // BUGBUG: Is type casting pszPtr to UNALIGNED necessary? -- copied it from ANSIStrChr
        // check if pszPtr is pointing to one of the chars in pcszDeLims
        if (!fWithinQuotes  && StrChr(pcszDeLims, *pszPtr) != NULL)
            break;
    }

    // NOTE: if fWithinQuotes is TRUE here, then we have an unbalanced quoted string; but we don't care!
    //       the entire string after the beginning quote becomes the field

    if (*pszPtr)                                    // pszPtr is pointing to a char in pcszDeLims
    {
        *ppszData = CharNext(pszPtr);               // save the pointer to the beginning of next field in *ppszData
        *pszPtr = TEXT('\0');                             // replace the DeLim char with the '\0' char
    }
    else
        *ppszData = pszPtr;                         // we have reached the end of the string; next call to this function
                                                    // would return NULL

    return pszRetPtr;
}

// constructs a string using the format specified in pcszFormatString
LPTSTR WINAPIV FormatString(LPCTSTR pcszFormatString, ...)
{
    va_list vaArgs;
    LPTSTR pszOutString = NULL;

    va_start(vaArgs, pcszFormatString);
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
          (LPCVOID) pcszFormatString, 0, 0, (LPTSTR) &pszOutString, 0, &vaArgs);
    va_end(vaArgs);

    return pszOutString;
}


/////////////////////////////////////////////////////////////////////////////
// String Conversion Routines

LPWSTR StrAnsiToUnicode(LPWSTR pszTarget, LPCSTR pszSource, UINT cchTarget /*= 0*/)
{
    int cchResult;

    cchResult = SHAnsiToUnicode(pszSource, pszTarget, int((cchTarget != 0) ? cchTarget : StrLenA(pszSource)+1));
    if (0 == cchResult)
        return NULL;

    return pszTarget;
}

LPSTR StrUnicodeToAnsi(LPSTR pszTarget, LPCWSTR pszSource, UINT cchTarget /*= 0*/)
{
    int cchResult;

    // NOTE: pass in twice the size of the source for the target in case we have DBCS
    //       chars.  We're assuming that the target buffer is sufficient here.

    cchResult = SHUnicodeToAnsi(pszSource, pszTarget,
        (cchTarget != 0) ? cchTarget : (StrLenW(pszSource)+1) * 2);

    if (0 == cchResult)
        return NULL;

    return pszTarget;
}

LPTSTR StrSameToSame(LPTSTR pszTarget, LPCTSTR pszSource, UINT cchTarget /*= 0*/)
{
    CopyMemory(pszTarget, pszSource, StrCbFromCch((cchTarget != 0) ? cchTarget : StrLen(pszSource)+1));
    return pszTarget;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieinst\dispids.h ===
#define    DISPID_INSERT      5000
#define    DISPID_WORKINGDIR  5001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieinst\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__48D17194_32CF_11D2_A337_00C04FD7C1FC__INCLUDED_)
#define AFX_DLLDATAX_H__48D17194_32CF_11D2_A337_00C04FD7C1FC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__48D17194_32CF_11D2_A337_00C04FD7C1FC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieinst\atl.inc ===
##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1991-96
#   All Rights Reserved.
#
##########################################################################

#
# Common include file 'sources' files ATL controls in the controls project.
#
#
# Required definitions:
#
#     CONTROLS_DIR
#        Path to controls root.
#
#     FREEBUILD
#        Set by makefile.def file.  One of the following:
#          0      - build debug
#          1      - build retail
#
#
# Definitions used if defined:
#
#     USE_LEGO
#        Define lego macros
#
#     TARGET_WIN95
#        Build component explicitly for the Win95 platform.  If this is
#        not defined, default is NT or both.
#
#     TARGET_BOTH
#        Build component to run on both platforms.
#
#     FULL_DEBUG
#        If set to 1, then debug builds will also have FULL_DEBUG defined.
#        Retail builds unaffected.
#
#     MEASURE_PERF
#        If set to 1, enables performance timing code for both debug and
#        retail builds.  This code squirts the timings for interesting
#        events to the debug terminal.
#

!if !defined(CONTROLS_DIR)
!error  CONTROLS_DIR must be defined in sources file
!endif

#
# Set private paths
#
INCLUDES        = \
		  $(SDK_INC_PATH)\atl21;\
	  $(INCLUDES)

#
# Set common options
#

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN= 1

# Don't link to the runtime libs
USE_NOLIBS      = 1

# Don't link to NTDLL if this runs on both platforms
!ifdef TARGET_BOTH
NO_NTDLL=1
!endif

!if defined(TARGET_WIN95)
#  Don't define WINNT
CHICAGO_PRODUCT = 1
!endif

UMTYPE          = windows

#
# Lego options
#
!if defined(USE_LEGO)
NTBBT           = 1
NTPROFILEINPUT  = 1
!endif

#
# Additional compiler flags
#

C_DEFINES       = $(C_DEFINES) -DWIN32 -D_WIN32

!if !defined(TARGET_WIN95)
C_DEFINES       = $(C_DEFINES) -DNT

!  if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!  endif
!endif

!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DDEBUG
LINKER_NOICF      = 1           # ICF is s-l-o-w

# Check for missing PURE directives in interface decls (debug only)
C_DEFINES       = $(C_DEFINES) -DNO_NOVTABLE

# Define FULL_DEBUG for asserts to break by default
!  if "$(FULL_DEBUG)" == "1"
C_DEFINES       = $(C_DEFINES) -DFULL_DEBUG
!  endif
!endif

!if "$(MEASURE_PERF)" == "1"
C_DEFINES       = $(C_DEFINES) -DMEASURE_PERF
!endif

!if "$(NO_PRIVATE_HEADERS)" == "1"
C_DEFINES       = $(C_DEFINES) -DNO_PRIVATE_HEADERS
!endif

# This define helps us distinguish our development environment
C_DEFINES       = $(C_DEFINES) -DWINNT_ENV

# Make warnings equivalent to errors

!if !defined(MSC_WARNING_LEVEL)
MSC_WARNING_LEVEL= /W3
!endif
MSC_WARNING_LEVEL= $(MSC_WARNING_LEVEL) /WX

!if defined(TARGET_WIN95) || defined(TARGET_BOTH)
USE_MAPSYM      = 1
!endif


!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieinst\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieinst\ieinst.cpp ===
// ieinst.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for ieinst.idl by adding the following 
//		files to the Outputs.
//			ieinst_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f ieinstps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "ieinst.h"
#include "dlldatax.h"

#include "ieinst_i.c"
#include "IEInstallCtrl.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_IEInstallCtrl, CIEInstallCtrl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieinst\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning(disable : 4273)
#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#ifdef _M_IA64

//$WIN64: Don't know why _WndProcThunkProc isn't defined 

extern "C" LRESULT CALLBACK _WndProcThunkProc(HWND, UINT, WPARAM, LPARAM )
{
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieinst\ieinstallctrl.h ===
// IEInstallCtrl.h : Declaration of the CIEInstallCtrl

#ifndef __IEINSTALLCTRL_H_
#define __IEINSTALLCTRL_H_

#include "resource.h"       // main symbols
#include <mshtml.h>
#include <wininet.h>

/////////////////////////////////////////////////////////////////////////////
// CIEInstallCtrl
class ATL_NO_VTABLE CIEInstallCtrl :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIEInstallCtrl,&CLSID_IEInstallCtrl>,
	public CComControl<CIEInstallCtrl>,
	public IDispatchImpl<IIEInstallCtrl, &IID_IIEInstallCtrl, &LIBID_IEINSTLib>,
	public IPersistStreamInitImpl<CIEInstallCtrl>,
	public IOleControlImpl<CIEInstallCtrl>,
	public IOleObjectImpl<CIEInstallCtrl>,
	public IOleInPlaceActiveObjectImpl<CIEInstallCtrl>,
	public IViewObjectExImpl<CIEInstallCtrl>,
	public IOleInPlaceObjectWindowlessImpl<CIEInstallCtrl>,
    public IObjectSafetyImpl<CIEInstallCtrl>
{
public:
	CIEInstallCtrl()
	{
 
	}

DECLARE_REGISTRY_RESOURCEID(IDR_IEINSTALLCTRL)

BEGIN_COM_MAP(CIEInstallCtrl) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IIEInstallCtrl)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CIEInstallCtrl)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CIEInstallCtrl)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
		return S_OK;
	}

// IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
    {
        ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
        if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
            return E_POINTER;
        HRESULT hr = S_OK;
        if (riid == IID_IDispatch)
        {
            *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
            *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        }
        else
        {
            *pdwSupportedOptions = 0;
            *pdwEnabledOptions = 0;
            hr = E_NOINTERFACE;
        }
        return hr;
    }
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);

// IIEInstallCtrl
public:
	HRESULT OnDraw(ATL_DRAWINFO& di);

    STDMETHOD(Insert)(BSTR Header, BSTR Name, BSTR Value, BSTR InsFilename, long *lRet);
    STDMETHOD(WorkingDir)(BSTR bstrPath, BSTR *bstrDir); 

};

#endif //__IEINSTALLCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieinst\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__48D1718C_32CF_11D2_A337_00C04FD7C1FC__INCLUDED_)
#define AFX_STDAFX_H__48D1718C_32CF_11D2_A337_00C04FD7C1FC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__48D1718C_32CF_11D2_A337_00C04FD7C1FC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieinst\ieinstallctrl.cpp ===
// IEInstallCtrl.cpp : Implementation of CIEInstallCtrl
#include "stdafx.h"
#include "ieinst.h"
#include "IEInstallCtrl.h"

/////////////////////////////////////////////////////////////////////////////
// CIEInstallCtrl


HRESULT CIEInstallCtrl::OnDraw(ATL_DRAWINFO& di)
{
	RECT& rc = *(RECT*)di.prcBounds;
	Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
	DrawText(di.hdcDraw, _T("ATL 2.0"), -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
	return S_OK;
}

BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}

LPSTR FAR ANSIStrChr(LPCSTR lpStart, WORD wMatch)
{
    for ( ; *lpStart; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}

LPSTR FAR ANSIStrRChr(LPCSTR lpStart, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    for ( ; *lpStart; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}

PathRemoveFileSpec(
    LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;        // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}

void Strip(LPSTR pszUrl)
{
	char szTemp[MAX_PATH] ;
	int tempPtr=0, pathPtr=0 ;

	while (pszUrl[pathPtr])
	{
		if (pszUrl[pathPtr] == '%')
		{
			int value = 0 ;
			pathPtr++ ;
			while (pszUrl[pathPtr] && ((pszUrl[pathPtr] >= '0') && (pszUrl[pathPtr] <= '9')))
			{
                value = (value * 0x10) + (pszUrl[pathPtr] - '0') ;
                pathPtr++ ;
			}
			szTemp[tempPtr++] = (char)value;
		}
		else
		{
			szTemp[tempPtr++] = pszUrl[pathPtr++] ;
		}
	}
	szTemp[tempPtr] = pszUrl[pathPtr] ;

	lstrcpy(pszUrl, szTemp) ;
}

BOOL CompareDirs(LPCSTR pcszDir1, LPCSTR pcszDir2)
{
    char szDir1[MAX_PATH];
    char szDir2[MAX_PATH];

    if (GetShortPathName(pcszDir1, szDir1, sizeof(szDir1)) && GetShortPathName(pcszDir2, szDir2, sizeof(szDir2))
        && (lstrcmpi(szDir1, szDir2) == 0))
        return TRUE;

    return FALSE;
}

BOOL CheckSignupDir(LPCSTR pcszFile)
{
    char szIEPath[MAX_PATH];
    char szFilePath[MAX_PATH];
    DWORD dwSize;
    HKEY hkAppPaths;

    dwSize = sizeof(szIEPath);
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\iexplore.exe",
        0, KEY_READ, &hkAppPaths) != ERROR_SUCCESS)
        return FALSE;

    if (RegQueryValueEx(hkAppPaths, "Path", 0, NULL, (LPBYTE)&szIEPath, &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hkAppPaths);
        return FALSE;
    }

    RegCloseKey(hkAppPaths);

    if (szIEPath[lstrlen(szIEPath)-1] == ';')
        szIEPath[lstrlen(szIEPath)-1] = '\0';

    if (szIEPath[lstrlen(szIEPath)-1] == '\\')
        szIEPath[lstrlen(szIEPath)-1] = '\0';

    lstrcat(szIEPath, "\\signup");

    lstrcpy(szFilePath, pcszFile);
    PathRemoveFileSpec(szFilePath);

    // check that we are writing to a file in the signup dir
    
    if (!CompareDirs(szIEPath, szFilePath))
        return FALSE;

    return TRUE;
}
STDMETHODIMP CIEInstallCtrl::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    CComBSTR strURL;
    char szURL[INTERNET_MAX_URL_LENGTH];
    char cBack;
    LPSTR pPtr, pSlash;
    ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
    
    USES_CONVERSION;
    
    // check to make sure it's a file://<drive letter> URL that we're being hosted on
    CComPtr<IOleContainer> spContainer; 
    m_spClientSite->GetContainer(&spContainer); 
    CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2> spDoc(spContainer); 
    
    if (spDoc)
        spDoc->get_URL(&strURL);
    else
        return E_NOINTERFACE;
    
    lstrcpy(szURL, OLE2A(strURL));
    Strip(szURL);

    cBack = szURL[7];
    szURL[7] = '\0';
    if (lstrcmpi(szURL, "file://") != 0)
        return E_NOINTERFACE;
    
    szURL[7] = cBack;
    pPtr = &szURL[7];

    while (*pPtr == '/')
        pPtr++;

    pSlash = pPtr;
    while (pSlash = ANSIStrChr(pSlash, '/'))
        *pSlash = '\\';
    if (!CheckSignupDir(pPtr))
        return E_FAIL;

    // If we're being asked to set our safe for scripting option then oblige
    
    if (riid == IID_IDispatch )
    {
        // Store our current safety level to return in GetInterfaceSafetyOptions
        m_dwSafety = dwEnabledOptions & dwOptionSetMask;
        return S_OK;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP CIEInstallCtrl::Insert(BSTR Header, BSTR Name, BSTR Value, BSTR InsFilename, long *lRet) 
{
    char szFile[MAX_PATH];
    char szHeader[128];
    char szValueName[128];
    char szValue[256];
    LPSTR pszPtr;

    USES_CONVERSION;

    lstrcpyn(szFile, OLE2A(InsFilename), MAX_PATH);
    
    // check for .ins extension

    if (!(pszPtr = ANSIStrRChr(szFile, '.')) || lstrcmpi(pszPtr, ".ins"))
        return E_FAIL;

    for (pszPtr = szFile; *pszPtr; pszPtr++)
    {
        if (*pszPtr == '/')
            *pszPtr = '\\';
    }

    if (!CheckSignupDir(szFile))
        return E_FAIL;

    lstrcpyn(szFile, OLE2A(InsFilename), MAX_PATH);

    // only write to existing ins files

    if (GetFileAttributes(szFile) == 0xFFFFFFFF)
        return E_FAIL;

    for (pszPtr = szFile; *pszPtr; pszPtr++)
    {
        if (*pszPtr == '/')
            *pszPtr = '\\';
    }

    lstrcpyn(szHeader, OLE2A(Header), 128);
    lstrcpyn(szValueName, OLE2A(Name), 128);
    lstrcpyn(szValue, OLE2A(Value), 256 - lstrlen(szValueName));
    
	*lRet = WritePrivateProfileString(szHeader, szValueName, szValue, szFile);
    return S_OK;
}

STDMETHODIMP CIEInstallCtrl::WorkingDir(BSTR bstrPath, BSTR *bstrDir) 
{
	char cBack;
    char szPath[MAX_PATH];
    char szURL[MAX_PATH*2];
    LPSTR pPath, pSlash, pUrl;
    
    USES_CONVERSION;

    lstrcpyn(szURL, OLE2A(bstrPath), MAX_PATH);
    Strip(szURL);
    cBack = szURL[7];
    szURL[7] = '\0';

    if (lstrcmpi(szURL, "file://") != 0) 
        szPath[0] = '\0';
    else
    {
        szURL[7] = cBack;
        pUrl = &szURL[7];
        while (*pUrl == '/')
            pUrl++;
        if (ANSIStrChr(pUrl, ':') || (pUrl[0] == '\\'))
            lstrcpyn(szPath, pUrl, MAX_PATH);
        else
        {
            lstrcpy(szPath, "\\\\");
            pPath = &szPath[2];
            lstrcpyn(pPath, pUrl, MAX_PATH - 2);
        }
        pSlash = szPath;
        while (pSlash = ANSIStrChr(pSlash, '/'))
            *pSlash = '\\';
        PathRemoveFileSpec(szPath);
    }
	
    *bstrDir = A2BSTR(szPath);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\extract.h ===
#ifndef _CDL_H_
#define _CDL_H_

// #define  USE_BINDHOST    1


// CDL.h
// Code Downloader header file
//
// Read "class descriptions" first for understanding how the
// code downloader works.

#ifdef __cplusplus
extern "C" {
#endif

/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */


// buffer size for downloads in CBSC::m_cbuffer
#define BUFFERMAX 2048

// File Name List
//
// used as pFilesToExtract to track files in the CAB we need extracted
//
// or a pFileList in PSESSION
//
// We keep track of all files that are in a cabinet
// keeping their names in a list and when the download
// is complete we use this list to delete temp files

struct sFNAME {
    LPSTR               pszFilename;
    struct sFNAME       *pNextName;
    DWORD               status; /* out */
};

typedef struct sFNAME FNAME;
typedef FNAME *PFNAME;

// SFNAME.status: success is 0 or non-zero error code in extraction
#define SFNAME_INIT         1
#define SFNAME_EXTRACTED    0

// FILE extentions we know about
typedef enum {
    FILEXTN_NONE,
    FILEXTN_UNKNOWN,
    FILEXTN_CAB,
    FILEXTN_DLL,
    FILEXTN_OCX,
    FILEXTN_INF,
    FILEXTN_EXE,
} FILEXTN;


//
// Master State Information for File Extraction: used by extract.c
//

typedef struct {
    UINT        cbCabSize;
    ERF         erf;
    PFNAME      pFileList;              // List of Files in CAB
    UINT        cFiles;
    DWORD       flags;                  // flags: see below for list
    char        achLocation[MAX_PATH];  // Dest Dir
    char        achFile[MAX_PATH];      // Current File
    char        achCabPath[MAX_PATH];   // Current Path to cabs
    PFNAME      pFilesToExtract;        // files to extract;null=enumerate only

} SESSION, *PSESSION;

typedef enum {
    SESSION_FLAG_NONE           = 0x0,
    SESSION_FLAG_ENUMERATE      = 0x1,
    SESSION_FLAG_EXTRACT_ALL    = 0x2,
    SESSION_FLAG_EXTRACTED_ALL  = 0x4
} SESSION_FLAGS;



#ifdef __cplusplus
}
#endif
#endif // _CDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieinst\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\ieinst\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ieinst.rc
//
#define IDS_PROJNAME                    100
#define IDR_IEINSTALLCTRL               101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\admparse.h ===
//------------------------------------------------------------------------
//  Admparse.h
//------------------------------------------------------------------------

#define ADM_SAVE            0x00000001
#define ADM_DESTROY         0x00000002

//  exported functions from admparse.dll
STDAPI AdmInitA(LPCSTR pcszAdmFile, LPCSTR pcszInfFile, BSTR bstrNamespace,
				LPDWORD lpdwAdm, LPVOID* pData);
STDAPI AdmInitW(LPCWSTR pcwszAdmFile, LPCWSTR pcwszInfFile, BSTR bstrNamespace,
				LPDWORD lpdwAdm, LPVOID* pData);
STDAPI AdmFinishedA(DWORD hAdm, LPCSTR pcszInfFile, LPVOID pPartData);
STDAPI AdmFinishedW(DWORD hAdm, LPCWSTR pcwszInfFile, LPVOID pPartData);
STDAPI CreateAdmUiA(DWORD hAdm, HWND hParent, int x, int y, int width, int height, 
                    DWORD dwStyle, DWORD dwExStyle, LPCSTR pcszCategory, HKEY hKeyClass,
                    HWND *phWnd, LPVOID pPartData, LPVOID* pCategoryData, BOOL fRSoPMode);
STDAPI CreateAdmUiW(DWORD hAdm, HWND hParent, int x, int y, int width, int height, 
                    DWORD dwStyle, DWORD dwExStyle, LPCWSTR pcwszCategory, HKEY hKeyClass,
                    HWND *phWnd, LPVOID pPartData, LPVOID* pCategoryData, BOOL fRSoPMode);
STDAPI GetAdmCategoriesA(DWORD hAdm, LPSTR pszCategories, int cchLength, int *nBytes);
STDAPI GetAdmCategoriesW(DWORD hAdm, LPWSTR pwszCategories, int cchLength, int *nBytes);
STDAPI CheckDuplicateKeysA(DWORD hAdm, DWORD hCompareAdm, LPCSTR pcszLogFile, BOOL bClearFile);
STDAPI CheckDuplicateKeysW(DWORD hAdm, DWORD hCompareAdm, LPCWSTR pcwszLogFile, BOOL bClearFile);
STDAPI AdmResetA(DWORD hAdm, LPCSTR pcszInfFile, LPVOID pPartData, LPVOID pCategoryData);
STDAPI AdmResetW(DWORD hAdm, LPCWSTR pcwszInfFile, LPVOID pPartData, LPVOID pCategoryData);
STDAPI AdmClose(DWORD hAdm, LPVOID* pPartData, BOOL fClear);
BOOL WINAPI IsAdmDirty();
VOID WINAPI ResetAdmDirtyFlag();
STDAPI AdmSaveData(DWORD hAdm, LPVOID pPartData, LPVOID pCategoryData, DWORD dwFlags);
STDAPI GetFontInfoA(LPSTR pszFontName, LPINT pnFontSize);
STDAPI GetFontInfoW(LPWSTR pwszFontName, LPINT pnFontSize);

#ifdef UNICODE 

#define AdmInit                 AdmInitW
#define AdmFinished             AdmFinishedW
#define CreateAdmUi             CreateAdmUiW
#define GetAdmCategories        GetAdmCategoriesW
#define CheckDuplicateKeys      CheckDuplicateKeysW
#define AdmReset                AdmResetW
#define GetFontInfo             GetFontInfoW

#else

#define AdmInit                 AdmInitA
#define AdmFinished             AdmFinishedA
#define CreateAdmUi             CreateAdmUiA
#define GetAdmCategories        GetAdmCategoriesA
#define CheckDuplicateKeys      CheckDuplicateKeysA
#define AdmReset                AdmResetA
#define GetFontInfo             GetFontInfoA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\all.h ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <malloc.h>

#define GTR_MALLOC(x)     malloc(x)
#define GTR_REALLOC(x, y) realloc(x, y)
#define GTR_FREE(x)       free(x)

#define FEATURE_RATINGS
#define USE_ROT_FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\crypto.h ===
//Prototype of crypto functions
//The limitation of these crypto functions is 128 characters, not include
//NULL terminator.
//You msut use the same keys to Encrypt and Decrypt.
//sizeof(lpszOutput) must be more than double of sizeof(lpszInput)
//Just alloc 256 bytes for it will be safe
//aKey must contain one key string more than 8 characters
int WINAPI EncryptString(LPSTR lpszInput, LPSTR lpszOutput,
                         unsigned char far *aKey, LPCSTR lpszKey2);
int WINAPI DecryptString(LPSTR lpszInput, LPSTR lpszOutput,
                         unsigned char far *aKey, LPCSTR lpszKey2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\ieakdl.h ===
#define IEAKDL_GETINTERFACE_FAILED      0x10
#define IEAKDL_UPDATE_SUCCESSFUL        0x11
#define IEAKDL_MEMALLOC_FAILED          0x12
#define IEAKDL_CANCELLED                0x13
#define IEAKDL_WRONG_VERSION            0x14

// the REGVERSION structure
typedef struct {
    WORD wMajor;
    WORD wMinor1;
    WORD wMinor2;
    WORD wBuild;
} REGVERSION;

// the UPDATEJOB structure
typedef struct {
    LPSTR szFriendlyName;
    LPSTR szSectionName;
} UPDATEJOB;

// the UPDATECOMPONENTS structure
typedef struct {
    UINT nSize;                     // = sizeof( UPDATECOMPONENTS )
    LPSTR szDestPath;               // destination path
    LPSTR szSiteList;               // URL for site list
    LPSTR szTitle;                  // Title for Download Servers box
    LPSTR szCifCab;                 // name of cab file containing .cif
    LPSTR szCifFile;                // name of .cif file
    int nJobs;                      // number of jobs in pJobs
    UPDATEJOB *pJobs;               // pointer to array of jobs
} UPDATECOMPONENTS;


//DWORD UpdateComponents( LPSTR, LPSTR, LPSTR, LPSTR, DWORD );
DWORD UpdateComponents( UPDATECOMPONENTS * );
INT_PTR CALLBACK DownloadSiteDlgProc( HWND, UINT, WPARAM, LPARAM );
DWORD AddItemsToListBox( HWND, LPSTR );
void CenterDialog( HWND );
DWORD CreateJob( LPSTR, LPSTR, LPSTR, LPSTR, LPSTR, LPSTR );
DWORD ExecuteJobs( LPSTR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\ieaksie.h ===
#ifndef _IEAKSIE_H_
#define _IEAKSIE_H_

#include <commctrl.h>

#define IEAK_GPE_BRANDING_SUBDIR        TEXT("BRANDING")
#define IEAK_GPE_DESKTOP_SUBDIR         TEXT("DESKTOP")

#define IEAK_GPE_COOKIE_FILE            TEXT("JONCE")

#define MAX_DISPLAYNAME_SIZE            128

typedef struct _RESULTITEMA
{
    DWORD           dwNameSpaceItem;                // index in g_NameSpace array
    INT             iNameID;                        // res id for page name
    INT             iNamePrefID;                    // res id for page name for preference GPO
    INT             iDescID;                        // res id for page description
    INT             iDlgID;                         // res id for dlg template
    INT             iImage;                         // index into image strip
    LPSTR           pszName;                        // pointer to name string
    LPSTR           pszNamePref;                    // pointer to name string for preference GPO
    LPSTR           pszDesc;                        // poitner to description string
    DLGPROC         pfnDlgProc;                     // pointer to dlgproc
    LPCSTR          pcszHelpTopic;                  // pointer to help htm file in chm file
} RESULTITEMA, *LPRESULTITEMA;

typedef struct _RESULTITEMW
{
    DWORD           dwNameSpaceItem;                // index in g_NameSpace array
    INT             iNameID;                        // res id for page name
    INT             iNamePrefID;                    // res id for page name for preference GPO
    INT             iDescID;                        // res id for page description
    INT             iDlgID;                         // res id for dlg template
    INT             iImage;                         // index into image strip
    LPWSTR          pszName;                        // pointer to name string
    LPWSTR          pszNamePref;                    // pointer to name string for preference GPO
    LPWSTR          pszDesc;                        // poitner to description string
    DLGPROC         pfnDlgProc;                     // pointer to dlgproc
    LPCWSTR         pcszHelpTopic;                  // pointer to help htm file in chm file
} RESULTITEMW, *LPRESULTITEMW;

#ifdef UNICODE 

#define RESULTITEM      RESULTITEMW
#define LPRESULTITEM    LPRESULTITEMW

#else

#define RESULTITEM      RESULTITEMA
#define LPRESULTITEM    LPRESULTITEMA

#endif

#endif    // _IEAKSIE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\iclientp.h ===
#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
//#include "resource.h"

#include <rasc.h>
#include <raserr.h>

// These are used in inecfg.h but not defined in Win 16 Land
#define CHAR    char
typedef long    HRESULT;
typedef BOOL    FAR *LPBOOL;


// Selected codes from WINERROR.H
#define ERROR_SUCCESS                    0L

// The MFC 1.52 build environement does not define _loadds for WINAPI
// but we need it defined.
#ifdef WINAPI
#undef WINAPI
#endif
#define WINAPI      _loadds _far _pascal


#ifndef RC_INVOKED
#include <inetcfg.h>
#endif

//
// Define the sections and key names used in iedial.ini
//
#define IEDIAL_INI              "iedial.ini"
#define IEDIAL_DEF_SECTION      "Default"
#define IEDIAL_DEF_DEFCONFILE   "DefaultConnectionFile"
#define IEDIAL_EXE              "iedial.exe"




// Define the sections and key names used in iexplore.ini

#define EXP_INI "iexplore.ini"
#define EXP_YES "yes"
#define EXP_NO  "no"


//
// !!!!!!! Make sure you leave the extra space after sign-up
//
#define CRYPTO_KEY "sign-up "


//
// Sections
//
#define EXP_SVC    "Services"
#define EXP_MAIL   "NewMailUser"
#define EXP_NEWS   "Services"



//
// Keys
//
#define EXP_SVC_ENABLE_PROXY        "Enable Proxy"
#define EXP_SVC_HTTP_PROXY          "HTTP_Proxy_Server"
#define EXP_SVC_OVERIDE_PROXY       "No_Proxy"

#define EXP_MAIL_EMAILNAME          "Email_Name"
#define EXP_MAIL_EMAILADDR          "Email_Address"
#define EXP_MAIL_POP_LOGON_NAME     "Email_POP_Name"
#define EXP_MAIL_POP_LOGON_PWD      "Email_POP_Pwd"
#define EXP_MAIL_POP_SERVER         "Email_POP_Server"
#define EXP_MAIL_SMTP_SERVER        "Email_SMTP_Server"

#define EXP_NEWS_ENABLED            "NNTP_Enabled"
#define EXP_NEWS_LOGON_NAME         "NNTP_MailName"
#define EXP_NEWS_LOGON_PWD          "NNTP_Use_Auth"
#define EXP_NEWS_SERVER             "NNTP_Server"
#define EXP_NEWS_EMAIL_NAME         "NNTP_MailAddr"




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\iedkbrnd.h ===
#define BRAND_FAVORITES     0x00000001
#define BRAND_STARTSEARCH   0x00000002
#define BRAND_TITLE         0x00000004
#define BRAND_BITMAPS       0x00000008
#define BRAND_MAIL          0x00000010
#define BRAND_NEWS          0x00000020
#define BRAND_RESTRICT      0x00000040
#define BRAND_CONF          0x00000080
#define BRAND_QL1           0x00000100
#define BRAND_QL2           0x00000200
#define BRAND_QL3           0x00000400
#define BRAND_QL4           0x00000800
#define BRAND_QL5           0x00001000
#define BRAND_ANIMATION     0x00002000
#define BRAND_FIRSTHOMEPAGE 0x00004000

#define BRAND_QUICKLINKS    (BRAND_QL1 | BRAND_QL2 | BRAND_QL3 | BRAND_QL4 | BRAND_QL5)
#define BRAND_TOOLBAR       (BRAND_STARTSEARCH | BRAND_TITLE | BRAND_BITMAPS | BRAND_QUICKLINKS | BRAND_ANIMATION | BRAND_FIRSTHOMEPAGE)
#define BRAND_ALL           (BRAND_FAVORITES | BRAND_MAIL | BRAND_NEWS | BRAND_RESTRICT | BRAND_CONF | BRAND_TOOLBAR)
#define BRAND_NO_RESTRICT   (BRAND_FAVORITES | BRAND_MAIL | BRAND_NEWS | BRAND_CONF | BRAND_TOOLBAR)
#define BRAND_NO_MAIL       (BRAND_FAVORITES | BRAND_CONF | BRAND_TOOLBAR)

#define MASK_DEFAULT        (BRAND_FAVORITES | BRAND_STARTSEARCH | BRAND_BITMAPS)

#define REDIST       0
#define BRANDED      1
#define INTRANET     2
#define BRANDEDPROXY 3

#define ROLE_ICP     REDIST
#define ROLE_ISP     BRANDED
#define ROLE_CORP    INTRANET

#define CAB_TYPE_CONFIG   0x00000001
#define CAB_TYPE_DESKTOP  0x00000002
#define CAB_TYPE_CHANNELS 0x00000004

#define SET   TRUE
#define CLEAR FALSE

#define PM_COPY  0x00000001
#define PM_CLEAR 0x00000002
#define PM_CHECK 0x00000004

// NOTE. (andrewgu) FD stands for FavoritesDelete. here is how these flags may be used:
// 1. if FD_FAVORITES is specified then any of FD_CHANNELS, FD_SOFTWAREUPDATES or FD_QUICKLINKS
//    are used to determine which folders to preserve when sweeping favorites;
// 2. if FD_FAVORITES is NOT specified then any of FD_CHANNELS, FD_SOFTWAREUPDATES or
//    FD_QUICKLINKS are used to determine which folders to nuke;
// 3. if FD_EMPTY_FAVORITES is set the entire favorites branch will be removed including the
//    folder itself;
// 4. the rest of FD_EMPTY_XXX flags work as follows. if FD_FAVORITES is specified then
//    if FD_EMPTY_XXX is set for a folder it will be emptied, if FD_FAVORITES is NOT set the
//    folder itself and all its content will be removed;
// 5. FD_REMOVE_HIDDEN, FD_REMOVE_SYSTEM and FD_REMOVE_READONLY are used to specify if items
//    with respective attributes are to be removed. desktop.ini in the respective folders doesn't
//    fall into this category and is processed separately;
// 6. the determination of whether Channels, Software Updates and Quick Links subfolders under
//    Favorites are system or user created is done in GetXxxPath() apis (in the branding dll).
#define FD_DEFAULT               0x0000
#define FD_FAVORITES             0x0001
#define FD_CHANNELS              0x0002
#define FD_SOFTWAREUPDATES       0x0004
#define FD_QUICKLINKS            0x0008
#define FD_FOLDERS               0x000F
#define FD_EMPTY_FAVORITES       0x0010
#define FD_EMPTY_CHANNELS        0x0020
#define FD_EMPTY_SOFTWAREUPDATES 0x0040
#define FD_EMPTY_QUICKLINKS      0x0080
#define FD_EMPTY_FOLDERS         0x00F0
#define FD_FOLDERS_ALL           0x00FF
#define FD_REMOVE_HIDDEN         0x1000
#define FD_REMOVE_SYSTEM         0x2000
#define FD_REMOVE_READONLY       0x4000
#define FD_REMOVE_IEAK_CREATED   0x8000
#define FD_REMOVE_ALL            0xF000

#define CS_VERSION_50              0x00000001
#define CS_VERSION_5X              0x00000002
#define CS_VERSION_5X_MAX          0x00000006
#define CS_STRUCT_HEADER           0xAFBEADDE
#define CS_STRUCT_RAS              0xAFBEAFDE
#define CS_STRUCT_RAS_CREADENTIALS 0xCCBAEDFE
#define CS_STRUCT_WININET          0xADFBCADE


//----- Inf processing -----

// plain section names
#define IS_DEFAULTINSTALL          TEXT("DefaultInstall")
#define IS_DEFAULTINSTALL_HKCU     IS_DEFAULTINSTALL TEXT(".Hkcu")
#define IS_DEFAULTINSTALL_HKLM     IS_DEFAULTINSTALL TEXT(".Hklm")

#define IS_IEAKINSTALL             TEXT("IeakInstall")
#define IS_IEAKINSTALL_HKCU        IS_IEAKINSTALL TEXT(".Hkcu")
#define IS_IEAKINSTALL_HKLM        IS_IEAKINSTALL TEXT(".Hklm")

#define IS_IEAKADDREG              TEXT("AddReg")
#define IS_IEAKADDREG_HKCU         IS_IEAKADDREG TEXT(".Hkcu")
#define IS_IEAKADDREG_HKLM         IS_IEAKADDREG TEXT(".Hklm")

// section names as they appear in the inf
#define INF_DEFAULTINSTALL         TEXT("\r\n[") IS_DEFAULTINSTALL      TEXT("]\r\n")
#define INF_DEFAULTINSTALL_HKCU    TEXT("\r\n[") IS_DEFAULTINSTALL_HKCU TEXT("]\r\n")
#define INF_DEFAULTINSTALL_HKLM    TEXT("\r\n[") IS_DEFAULTINSTALL_HKLM TEXT("]\r\n")

#define INF_IEAKINSTALL            TEXT("\r\n[") IS_IEAKINSTALL      TEXT("]\r\n")
#define INF_IEAKINSTALL_HKCU       TEXT("\r\n[") IS_IEAKINSTALL_HKCU TEXT("]\r\n")
#define INF_IEAKINSTALL_HKLM       TEXT("\r\n[") IS_IEAKINSTALL_HKLM TEXT("]\r\n")

#define INF_IEAKADDREG             TEXT("\r\n[") IS_IEAKADDREG      TEXT("]\r\n")
#define INF_IEAKADDREG_HKCU        TEXT("\r\n[") IS_IEAKADDREG_HKCU TEXT("]\r\n")
#define INF_IEAKADDREG_HKLM        TEXT("\r\n[") IS_IEAKADDREG_HKLM TEXT("]\r\n")

// addreg entries
#define INF_ADDREG_IEAKADDREG      TEXT("AddReg=") IS_IEAKADDREG      TEXT("\r\n")
#define INF_ADDREG_IEAKADDREG_HKCU TEXT("AddReg=") IS_IEAKADDREG_HKCU TEXT("\r\n")
#define INF_ADDREG_IEAKADDREG_HKLM TEXT("AddReg=") IS_IEAKADDREG_HKLM TEXT("\r\n")
#define INF_ADDREG_IEAKADDREG_BOTH TEXT("AddReg=") IS_IEAKADDREG_HKCU TEXT(",") IS_IEAKADDREG_HKLM TEXT("\r\n")

// custom destination entries
#define IS_CUSTOMDESTINATIONSECT   TEXT("CustInstDestSection")
#define INF_CUSTOMDESTINATION      TEXT("CustomDestination=") IS_CUSTOMDESTINATIONSECT TEXT("\r\n")
#define INF_CUSTOMDESTINATIONSECT  TEXT("\r\n[") IS_CUSTOMDESTINATIONSECT TEXT("]\r\n")  \
                                   TEXT("49000,49001,49002,49003=ProgramFilesDir,21\r\n") \
                                   TEXT("49100,49101,49102,49103=IEDir,21\r\n")           \
                                   TEXT("\r\n[ProgramFilesDir]\r\n")                     \
                                   TEXT("HKLM,\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\",\"ProgramFilesDir\",,\"%24%\\Program Files\"\r\n") \
                                   TEXT("\r\n[IEDir]\r\n")                               \
                                   TEXT("HKLM,\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\iexplore.exe\",\"Path\",,\"%49001%\\Internet Explorer\"\r\n")

// miscellaneous
#define INF_REQUIREDENGINE         TEXT("RequiredEngine=SetupAPI,\"Fatal Error - missing setupapi.dll\"\r\n")
 
// prolog helpers
#define INF_PROLOG                  \
    TEXT("[Version]\r\n")           \
    TEXT("Signature=$Chicago$\r\n") \
    TEXT("AdvancedINF=2.5\r\n")

#define INF_DFI_PROLOG              \
    INF_PROLOG                      \
    INF_DEFAULTINSTALL              \
    INF_REQUIREDENGINE              

#define INF_ERI_PROLOG_HKCU         \
    INF_DFI_PROLOG                  \
    INF_CUSTOMDESTINATION           \
    INF_ADDREG_IEAKADDREG_HKCU      \
    INF_IEAKINSTALL_HKCU            \
    INF_REQUIREDENGINE              \
    INF_CUSTOMDESTINATION           \
    INF_ADDREG_IEAKADDREG_HKCU      \
    INF_CUSTOMDESTINATIONSECT

#define INF_ERI_PROLOG_HKLM         \
    INF_DFI_PROLOG                  \
    INF_CUSTOMDESTINATION           \
    INF_ADDREG_IEAKADDREG_HKLM      \
    INF_IEAKINSTALL_HKLM            \
    INF_REQUIREDENGINE              \
    INF_CUSTOMDESTINATION           \
    INF_ADDREG_IEAKADDREG_HKLM      \
    INF_CUSTOMDESTINATIONSECT

#define INF_ERI_PROLOG_BOTH         \
    INF_DFI_PROLOG                  \
    INF_CUSTOMDESTINATION           \
    INF_ADDREG_IEAKADDREG_BOTH      \
    INF_IEAKINSTALL_HKCU            \
    INF_REQUIREDENGINE              \
    INF_CUSTOMDESTINATION           \
    INF_ADDREG_IEAKADDREG_HKCU      \
    INF_IEAKINSTALL_HKLM            \
    INF_REQUIREDENGINE              \
    INF_CUSTOMDESTINATION           \
    INF_ADDREG_IEAKADDREG_HKLM      \
    INF_CUSTOMDESTINATIONSECT


#define INF_PROLOG_CS               \
    INF_ERI_PROLOG_HKCU             \
    INF_IEAKADDREG_HKCU

#define INF_PROLOG_ADM              \
    INF_ERI_PROLOG_BOTH             \
    INF_DEFAULTINSTALL_HKCU         \
    INF_REQUIREDENGINE              \
    INF_ADDREG_IEAKADDREG_HKCU      \
    INF_DEFAULTINSTALL_HKLM         \
    INF_REQUIREDENGINE              \
    INF_ADDREG_IEAKADDREG_HKLM


//----- Legacy #defines we should clean up -----
#define INF_ADD           \
    INF_DFI_PROLOG        \
    INF_ADDREG_IEAKADDREG \
    INF_IEAKADDREG

#define DESK_INF_ADD INF_ADD

#define PROGRAMS_INF_ADD  \
    INF_ERI_PROLOG_BOTH   \
    INF_IEAKADDREG_HKLM

#define RATINGS_INF_ADD   \
    INF_ERI_PROLOG_HKLM   \
    INF_IEAKADDREG_HKLM

#define ZONES_INF_ADD     \
    INF_ERI_PROLOG_BOTH   \
    INF_IEAKADDREG_HKLM

#define ZONES_INF_ADDREG_HKCU INF_IEAKADDREG_HKCU

#define AUTH_INF_ADD     \
    INF_ERI_PROLOG_HKCU  \
    INF_IEAKADDREG_HKCU

#define SC_INF_ADD                                                 \
    INF_DFI_PROLOG                                                 \
    INF_ADDREG_IEAKADDREG_BOTH                                     \
    TEXT("DelReg=DelReg.HKCU\r\n")                                 \
    INF_IEAKINSTALL_HKCU                                           \
    INF_REQUIREDENGINE                                             \
    INF_ADDREG_IEAKADDREG_HKCU                                     \
    TEXT("DelReg=DelReg.HKCU\r\n")                                 \
    INF_IEAKINSTALL_HKLM                                           \
    INF_REQUIREDENGINE                                             \
    INF_ADDREG_IEAKADDREG_HKCU                                     \
    TEXT("\r\n[DelReg.HKCU]\r\n")                                  \
    TEXT("HKCU,Software\\Microsoft\\SystemCertificates\\Root\r\n") \
    TEXT("HKCU,Software\\Microsoft\\SystemCertificates\\CA\r\n")   \
    INF_IEAKADDREG_HKLM
#define SC_INF_ADDREG_HKCU INF_IEAKADDREG_HKCU

#define UPDATE_BRAND_ADD1               \
    INF_DFI_PROLOG                      \
    TEXT("CopyFiles=BrndCopyFiles\r\n")

#define UPDATE_BRAND_ADD2          \
    TEXT("[DestinationDirs]\r\n")  \
    TEXT("BrndCopyFiles=11\r\n")   \
    TEXT("\r\n")                   \
    TEXT("[SourceDisksNames]\r\n") \
    TEXT("55=Branding,\"\",0\r\n") \
    TEXT("\r\n")                   \
    TEXT("[SourceDisksFiles]\r\n") \
    TEXT("iedkcs32.DLL=55\r\n")    \
    TEXT("\r\n")                   \
    TEXT("[BrndCopyFiles]\r\n")    \
    TEXT("iedkcs32.DLL,,,32\r\n")


#define KEY_DESKTOP_COMP DESKTOPKEY TEXT("\\Components")
#define KEY_DESKTOP_GEN DESKTOPKEY TEXT("\\General")
#define KEY_DESKTOP_OLD TEXT("Control Panel\\desktop")
#define DESKTOP_OBJ_SECT TEXT("DesktopObjects")
#define IMPORT_DESKTOP TEXT("ImportObjects")
#define GEN_FLAGS TEXT("GeneralFlags")
#define SOURCE TEXT("Source")
#define SUBSCRIBEDURL TEXT("SubscribedURL")
#define POSITION TEXT("Position")
#define IMPORT_TOOLBARS TEXT("ImportToolbars")
#define RESTRICT_TOOL_DRAG TEXT("RestrictToolDrag")
#define RESTRICT_TOOL_CLOSE TEXT("RestrictToolClose")
#define FLAGS TEXT("Flags")
#define Z_ORDER TEXT("ZOrder")
#define NAME_COUNT TEXT("NameCount")
#define OPTION TEXT("Option")
#define OPTIONS TEXT("Options")
#define APP_LAUNCHED TEXT("AppLaunched")
#define STRINGS TEXT("Strings")
#define INSTALL_DIR TEXT("InstallDir")
#define LOCAL_HTML TEXT("LocalHTML")
#define KEY_TOOLBAR_VAL CURRENTVERSIONKEY TEXT("\\Explorer\\Streams\\Desktop")
#define KEY_TOOLBAR_REST CURRENTVERSIONKEY TEXT("\\Policies\\IEAK")
#define ADMIN_BAND_SETTINGS TEXT("Admin Band Settings")
#define UNUSED TEXT("!Unused")
#define BRANDING TEXT("Branding")
#define WEB_INTEGRATED TEXT("WebIntegrated")
#define WEB_CHOICE TEXT("WebChoice")
#define OPTIONS_WIN TEXT("Options.Win")
#define OPTIONS_NTX86 TEXT("Options.NTx86")
#define OPTIONS_NTALPHA TEXT("Options.NTAlpha")
#define DEFAULT_EXPLORER_PATH TEXT("DefaultExplorerPath")
#define MODE_RELATION TEXT("ModeRelation")
#define INSTALL_PROMPT TEXT("InstallPrompt")
#define DISPLAY_LICENSE TEXT("DisplayLicense")
#define DEFAULT_INSTALL TEXT("DefaultInstall")
#define DEFAULT_INSTALL_NT TEXT("DefaultInstall.NT")
#define DEFAULT_INSTALL_ALPHA TEXT("DefaultInstall.NTAlpha")
#define REQUIRED_ENGINE TEXT("RequiredEngine")
#define SETUPAPI_FATAL TEXT("SetupAPI,\"Fatal Error - Missing SETUPAPI.DLL\"")
#define CABSIGN_INF_ADD TEXT("HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0\",\"%s\",,\"%s\"\0")
#define KEY_INET_SETTINGS CURRENTVERSIONKEY TEXT("\\Internet Settings")
#define KEY_USER_AGENT CURRENTVERSIONKEY TEXT("\\Internet Settings\\User Agent\\Post Platform")
#define USER_AGENT TEXT("User Agent")
#define URL_SECT TEXT("URL")
#define INITHOMEPAGE TEXT("FirstHomePage")
#define MODES_WIN TEXT("Modes.Win")
#define MODES_NTX86 TEXT("Modes.NTx86")
#define LISTNAME TEXT("ListName")
#define LISTDESC TEXT("ListDesc")
#define SECURITY_IMPORTS TEXT("Security Imports")
#define REG_KEY_RATINGS CURRENTVERSIONKEY TEXT("\\Policies\\Ratings")
#define REG_KEY_POLICY_DATA TEXT("PolicyData\\Users")
#define REG_KEY_SITECERT1 TEXT("Software\\Microsoft\\SystemCertificates\\Root")
#define REG_KEY_SITECERT2 TEXT("Software\\Microsoft\\SystemCertificates\\CA")
#define REG_KEY_AUTHENTICODE CURRENTVERSIONKEY TEXT("\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database")
#define REG_KEY_SOFTPUB CURRENTVERSIONKEY TEXT("\\WinTrust\\Trust Providers\\Software Publishing")
#define REG_VAL_STATE TEXT("State")
#define TRUSTED_ONLY TEXT("TrustedOnly")
#define REG_KEY_ZONES CURRENTVERSIONKEY TEXT("\\Internet Settings\\Zones")
#define REG_KEY_ZONEMAP CURRENTVERSIONKEY TEXT("\\Internet Settings\\ZoneMap")
#define REG_KEY_P3P CURRENTVERSIONKEY TEXT("\\Internet Settings\\P3P")
#define POLICYDATA TEXT("PolicyData")
#define WALLPAPER TEXT("Wallpaper")
#define BACKUPWALLPAPER TEXT("BackupWallpaper")
#define EXTREGINF TEXT("ExtRegInf")
#define DESKTOP TEXT("Desktop")
#define TOOLBARS TEXT("Toolbars")
#define IE4_WELCOME_MSG TEXT("IE4 Welcome Msg")
#define REG_KEY_TIPS CURRENTVERSIONKEY TEXT("\\Explorer\\Tips")
#define REG_VAL_SHOWIE4 TEXT("ShowIE4")
#define DEPENDENCIES TEXT("Dependencies")
#define STARTHOMEPAGE TEXT("StartHomePage")
#define TOOLBAR_BMP TEXT("Toolbar Bitmap")

#define INTERNET_MAIL TEXT("Internet_Mail")
#define INTERNET_NEWS TEXT("Internet_News")
#define POP_SERVER TEXT("POP_Server")
#define SMTP_SERVER TEXT("SMTP_Server")

#define NNTP_SERVER TEXT("NNTP_Server")
#define DEFCLIENT TEXT("Default_Client")
#define INFOPANE TEXT("Infopane")
#define INFOPANEBMP TEXT("Infopane_Bitmap")
#define WELCOMEMSG TEXT("Welcome_Message")
#define WELCOMENAME TEXT("Welcome_Name")
#define WELCOMEADDR TEXT("Welcome_Address")
#define EMAILNAME TEXT("Email_Name")
#define EMAILADDR TEXT("Email_Address")
#define USE_SPA TEXT("Logon_Using_SPA")
#define LOGON_REQUIRED TEXT("Logon_Required")
#define HTML_MSGS TEXT("HTML_Msgs")

#define LDAP TEXT("LDAP")
#define FRIENDLYNAME TEXT("FriendlyName")
#define SERVER TEXT("Server")
#define HOMEPAGE TEXT("HomePage")
#define SEARCHBASE TEXT("SearchBase")
#define TEXT_BITMAP TEXT("Bitmap")
#define CHECKNAMES TEXT("CheckNames")
#define AUTHTYPE TEXT("AuthType")

#define MAIL_SIG TEXT("Mail_Signature")
#define USE_MAIL_FOR_NEWS TEXT("Use_Mail_For_News")
#define USE_SIG TEXT("Use_Signature")
#define SIGNATURE TEXT("Signature")
#define SIG_TEXT TEXT("Signature_Text")

#define CUSTITEMS TEXT("CustItems")
#define START_PAGE TEXT("Home_Page")
#define SEARCH_PAGE TEXT("Search_Page")
#define IMPORT_ZONES TEXT("Import_Zones")
#define REG_KEY_IEAK TEXT("Software\\Microsoft\\IEAK")
#define REG_KEY_IEAK_CABVER REG_KEY_IEAK TEXT("\\CabVersions")
#define CAB_VERSIONS TEXT("CabVersions")
#define CMBITMAPNAME TEXT("CMBitmapName")
#define CMBITMAPPATH TEXT("CMBitmapPath")
#define CMPROFILENAME TEXT("CMProfileName")
#define CMPROFILEPATH TEXT("CMProfilePath")
#define CMUSECUSTOM TEXT("CMUseCustom")
#define WEBVIEWFOLDERGUIDSECT TEXT("{BE098140-A513-11D0-A3A4-00C04FD706EC}")
#define ICONAREA_IMAGE TEXT("IconArea_Image")
#define CUSTCMSECT TEXT("CustIcmPro")
#define CUSTCMSECTNAME TEXT("CustIcmProName")
#define CUSTCMMODES TEXT("CustIcmProModes")
#define SILENT_INSTALL TEXT("Silent Install")
#define REG_KEY_ACT_SETUP TEXT("Software\\Microsoft\\Active Setup\\Installed Components")
#define DESTINATION_DIRS TEXT("DestinationDirs")
#define FIRST_HOME_PAGE TEXT("First Home Page")
#define KEY_UNINSTALL_BRAND CURRENTVERSIONKEY TEXT("\\Uninstall\\Branding")
#define QUIETUNINSTALLSTR TEXT("QuietUninstallString")
#define RUNDLL_UNINSTALL TEXT("Rundll32 IedkCS32.dll,BrandCleanInstallStubs")
#define REQUIRESIESTR TEXT("RequiresIESysFile")
#define IEVER TEXT("100.0")
#define KEY_TOOLBAR_LINKS RK_IE TEXT("\\Toolbar\\Links")
#define INSTALLMODE TEXT("InstallMode")
#define SAVE_TASKBARS "SaveTaskbar"
#define REG_KEY_IEAK_POLUSER TEXT("IEAKPolicyData\\Users")
#define REG_KEY_IEAK_POL TEXT("IEAKPolicyData")
#define CHANNEL_ADD TEXT("Channel Add")
#define CDFURL TEXT("CDFURL")
#define CHICON TEXT("ChIconPath")
#define CHBMP TEXT("ChBmpPath")
#define CHBMPW TEXT("ChBmpWidePath")
#define CHPREURLNAME TEXT("ChPreloadURLName")
#define CHPREURLPATH TEXT("ChPreloadURLPath")
#define CHICONNAME TEXT("ChIconName")
#define CHBMPNAME TEXT("ChBmpName")
#define CHBMPWIDENAME TEXT("ChBmpWideName")
#define CHTITLE TEXT("ChTitle")
#define CHSUBINDEX TEXT("ChSubGrp")
#define SUBGROUP TEXT("SubGrp")
#define KEY_CHANNEL_ADD RK_IE_POLICIES TEXT("\\Infodelivery\\Modifications\\Channel%s\\AddChannels\\ChannelIEAK%s")
#define KEY_SUBSCRIPTION_ADD RK_IE_POLICIES TEXT("\\Infodelivery\\Modifications\\Channel%s\\AddSubscriptions\\SubscribeIEAK%s")
#define POLICIES TEXT("Policy")
#define CHANNELGUIDE TEXT("ChannelGuide")
#define REG_KEY_INET_POLICIES RK_MS_POLICIES TEXT("\\Windows\\CurrentVersion\\Internet Settings")
#define REG_VAL_HKLM_ONLY TEXT("Security_HKLM_Only")
#define REG_VAL_OPT_EDIT TEXT("Security_Options_Edit")
#define REG_VAL_ZONE_MAP TEXT("Security_Zones_Map_Edit")
#define MYCPTRPATH TEXT("My Computer Path")
#define CTLPANELPATH TEXT("Control Panel Path")
#define WLPPRPATH TEXT("Desktop Wallpaper Path")
#define DESKCOMPURL TEXT("Desktop Component URL")
#define DESKCOMPLOCALFLAG TEXT("Desktop Component Local Flag")
#define DESKCOMPLOCALPATH TEXT("Desktop Component Local Path")
#define IEAK_HELP TEXT("IEAK Help")
#define DEFAULT TEXT("Default")
#define FRAME TEXT("Frame")
#define ADDREG TEXT("AddReg")
#define DELREG TEXT("DelReg")
#define INIT_HOME_DEL TEXT("StartHomePage.Remove")
#define UPDATE_INIS TEXT("UpdateInis")
#define ADDWELCOME TEXT("AddWelcome")
#define CATEGORY TEXT("Category")
#define CATHTML TEXT("CategoryHtml")
#define CATICON TEXT("CategoryIcon")
#define CATBMP TEXT("CategoryBmp")
#define CATBMPWIDE TEXT("CategoryBmpWide")
#define CATHTMLNAME TEXT("CategoryHtmlName")
#define CATICONNAME TEXT("CategoryIconName")
#define CATBMPNAME TEXT("CategoryBmpName")
#define CATBMPWIDENAME TEXT("CategoryBmpWideName")
#define CATTITLE TEXT("CategoryTitle")
#define CURRENTVERSIONKEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define WALLPPRDIR TEXT("WallPaperDir")
#define WALLPPRVALUE TEXT("Wallpaper")
#define COMPONENTPOS TEXT("ComponentsPositioned")
#define CUSTWALLPPR TEXT("Custom Wallpaper")
#define NUMFILES TEXT("NumFiles")
#define FILE_TEXT TEXT("file%i")
#define SHELLFOLDERS_KEY CURRENTVERSIONKEY TEXT("\\Explorer\\Shell Folders")
#define APPDATA_VALUE TEXT("AppData")
#define FAVORITES_VALUE TEXT("Favorites")
#define SOFTWAREUPDATES_FOLDER TEXT("Software Updates")
#define CHANNELS_FOLDER TEXT("Channels")
#define QUICKLAUNCH TEXT("Quick Launch Files")
#define IK_KEEPIELNK TEXT("Keep IE Link")
#define BROWSERLNKSECT TEXT("setup.ini, progman.groups,,\"IE_WEBVIEW=\"\"%%49050%%\\Microsoft\\Internet Explorer\\%s\"\"\"\r\nsetup.ini, IE_WEBVIEW,, \"\"\"%s\"\",\"\"\"\"\"\"%%49000%%\\IEXPLORE.EXE\"\"\"\"\"\",,,,,%s\"\r\n\0\0")
#define DESKTOPKEY RK_IE TEXT("\\Desktop")
#define MYCPTRKEY TEXT("SOFTWARE\\Classes\\CLSID\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\shellex\\ExtShellFolderViews\\{5984FFE0-28D4-11CF-AE66-08002B2E1262}")
#define CTLPANELKEY TEXT("SOFTWARE\\Classes\\CLSID\\{21EC2020-3AEA-1069-A2DD-08002B30309D}\\shellex\\ExtShellFolderViews\\{5984FFE0-28D4-11CF-AE66-08002B2E1262}")
#define FOLDERVALUE TEXT("PersistMoniker")
#define REG_KEY_SCHED_ITEMS CURRENTVERSIONKEY TEXT("\\NotificationMgr\\SchedItems 0.6")
#define REG_KEY_SCHED_GROUP CURRENTVERSIONKEY TEXT("\\NotificationMgr\\ScheduleGroup 0.6")
#define SHELLCLASSINFO TEXT(".ShellClassInfo")
#define URL TEXT("URL")
#define LOGO TEXT("Logo")
#define ICONFILE TEXT("IconFile")
#define ICON TEXT("Icon")
#define CHANNEL_SECT TEXT("Channel")
#define CHANNELKEY TEXT("ChannelKey")
#define CLEANUPKEY TEXT("CleanKey")
#define WIDELOGO TEXT("WideLogo")
#define CHANNEL_ADD_REG  TEXT("[Version]\r\nSignature=$Chicago$\r\nAdvancedINF=2.5\r\n[DefaultInstall]\r\nRequiredEngine=SetupAPI,\"Fatal Error - Missing SETUPAPI.DLL\"\r\nAddReg=DeskAddReg\r\n[DeskAddReg]\r\n")
#define LOCALE TEXT("Locale")
#define CONTENT_ENGLISH TEXT("7")
#define CONTENT TEXT("Content")

#define IEAKCHANADDREG TEXT("IeakChan.AddReg")
#define IEAKCHANDELREG TEXT("IeakChan.DelReg")

#define IEAKCHANCOPYFILES TEXT("IeakChan.CopyFiles")
#define REG_KEY_UNINSTALL TEXT("HKLM,Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\")
#define UNINSTALL_CMD TEXT(",QuietUninstallString,,\"RunDll32 advpack.dll,LaunchINFSection %17%\\")
#define REQUIRE_VER_CMD TEXT(",RequiresIESysFile,,100.0")
#define DEFAULTINSTALL TEXT("DefaultInstall")
#define COPYFILES TEXT("CopyFiles")
#define DESTINATIONDIRS TEXT("DestinationDirs")
#define CHANNEL_KEY_VAL RK_IE_POLICIES TEXT("\\Infodelivery\\Modifications\\ChannelDefault\\AddChannels")
#define CLEANUP_KEY_VAL RK_IE_POLICIES TEXT("\\Infodelivery\\Modifications\\ChannelDefault\\RemoveAllChannels")
#define COMPLETED_DELREG TEXT("HKCU,\"Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\CompletedModifications\",ChannelDefault,,,")
#define INSTALLUSER TEXT("InstallUser")
#define UNINSTALL TEXT("Uninstall")
#define DELFILES TEXT("DelFiles")
#define UNINSTALL5 TEXT(",Uninstall,5")
#define IMPORT_CHANNELS TEXT("ImportChannels")
#define SUBSCRIPTIONS TEXT("Subscriptions")
#define GUID_VAL TEXT("GUID")
#define STUBSETUP TEXT("StubSetup")
#define COMPNAME TEXT("CompName")
#define VERSION      TEXT("Version")
#define VERSION_TEXT TEXT("Version")
#define DATE      TEXT("Date")
#define DATE_TEXT TEXT("Date")
#define INSVERKEY TEXT("InsVersion")
#define GPVERKEY TEXT("GPVersion")
#define PMVERKEY TEXT("ProfMgrVersion")
#define CABSURLPATH TEXT("CabsURLPath")
#define CUSTOMVERSECT TEXT("Custom Version Section")
#define CUSTBRND TEXT("Custom Branding")
#define CUSTBRNDNAME BRANDING
#define CUSTBRNDSECT CUSTBRND
#define CUSTDESKNAME DESKTOP
#define CUSTDESKSECT TEXT("Custom Desktop")
#define CUSTCHANNAME TEXT("Channels")
#define CUSTCHANSECT TEXT("Custom Channels")
#define CHANNELSIZE TEXT("ChannelSize")
#define OEMSIZE TEXT("OEMSize")
#define REG_KEY_URL_GUIDE TEXT("HKCU,\"SOFTWARE\\Microsoft\\Internet Explorer\\Main\",ChannelsURL,,\"http://channels.microsoft.com/guide/chguide.asp\"")
#define REG_KEY_CHANURL_FIRST TEXT("HKCU,\"SOFTWARE\\Microsoft\\Internet Explorer\\Main\",ChannelsFirstURL,,\"res://ie4tour.dll/channels.htm\"")
#define REG_KEY_REMOVE_PP2_CHANNELS TEXT("HKCU,\"%CleanKey%\\CleanUp\",\"OldIEVersion\",,\"4.71.1008.3\"")
#define REG_KEY_CHAN_SIZE TEXT("HKCU,\"Software\\Microsoft\\Internet Explorer\\Desktop\",ChannelSize,65537,%s")
#define REG_KEY_OEM_SIZE TEXT("HKCU,\"Software\\Microsoft\\Internet Explorer\\Desktop\",OEMSize,65537,%s")
#define WEBCHECK_REGKEY CURRENTVERSIONKEY TEXT("\\Webcheck")
#define ADDONURL TEXT("Add on URL")
#define ADDONURL_KEY RK_IE TEXT("\\Main")
#define ADDONURL_VALUE TEXT("Addon_URL")
#define PRELOAD_KEY CURRENTVERSIONKEY TEXT("\\Internet Settings\\Cache\\Preload")
#define SWUPDATES TEXT("SWUpdates")
#define NUMCHANNELS TEXT("NumChannels")
#define SOFTWAREUPDATES TEXT("SoftwareUpdates")
#define REG_KEY_ICW TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define REG_VAL_COMPLETED TEXT("Completed")
#define BROWSER_ONLY TEXT("BrowserOnlyModes")
#define IEAK_ZERO_NAME TEXT("IEAK_0_Name")
#define ZERO_NAME TEXT("0_Name")
#define IEAK_ZERO_DESC TEXT("IEAK_0_Desc")
#define ZERO_DESC TEXT("0_Desc")
#define WSTR_BASE L"BASE"
#define WSTR_LOGO L"LOGO"
#define WSTR_IMAGE L"IMAGE"
#define WSTR_ICON L"ICON"
#define WSTR_IMAGEW L"IMAGE-WIDE"
#define WSTR_STYLE L"STYLE"
#define WSTR_HREF L"HREF"
#define LANG_LOCALE TEXT("Language Locale")
#define LANG_ID TEXT("Language ID")
#define CHANNEL_MODES TEXT("ChannelModes")
#define DELOLDCHAN TEXT("Delete Old Channels")
#define SHOWCHANBAR TEXT("Channel Bar")

#define DEFAULT_COMP_X 200
#define DEFAULT_COMP_Y 20
#define COMP_INC 0x20


#define DESKTOP_NONE 0
#define DESKTOP_OBJECTS 1
#define DESKTOP_HTML 2

#define INSTALL_OPT_FULL 0
#define INSTALL_OPT_PROG 2


#define INF_BUF_SIZE 16768
#define REG_BUF_SIZE 8192

#ifndef ARRAYSIZE                               // one definition is fine
#define ARRAYSIZE(a)     (sizeof(a)/sizeof((a)[0]))
#endif

#ifndef IsSpace
#define IsSpace(c)       ((c) == TEXT(' ')   ||  (c) == TEXT('\t')  ||  (c) == TEXT('\r') || \
    (c) == TEXT('\n')  ||  (c) == TEXT('\v')  ||  (c) == TEXT('\f'))
#endif

#define KEY_DEFAULT_ACCESS (KEY_READ | KEY_WRITE)


DEFINE_GUID(GUID_BRANDING, 0x60B49E34, 0xC7CC, 0x11D0, 0x89,0x53,0,0xa0,0xc9,3,0x47,0xff);
#define BRANDING_GUID_STR TEXT("{60B49E34-C7CC-11D0-8953-00A0C90347FF}")

#define MAX_STRING 1024
#define MAX_CHAN 50
#define MAX_BTOOLBARS   10
#define MAX_BTOOLBAR_TEXT_LENGTH  10

#define GFN_PICTURE         0x00000001
#define GFN_LOCALHTM        0x00000002
#define GFN_CAB             0x00000004
#define GFN_CDF             0x00000008
#define GFN_HTX             0x00000010
#define GFN_MYCOMP          0x00000020
#define GFN_CONTROLP        0x00000040
#define GFN_CERTIFICATE     0x00000080
#define GFN_BMP             0x00000100
#define GFN_ADM             0x00000200
#define GFN_INS             0x00000400
#define GFN_PVK             0x00000800
#define GFN_SPC             0x00001000
#define GFN_TXT             0x00002000
#define GFN_ICO             0x00004000
#define GFN_EXE             0x00008000
#define GFN_SCRIPT          0x00010000
#define GFN_RULES           0x00020000
#define GFN_ISP             0x00040000
#define GFN_WAV             0x00080000
#define GFN_GIF             0x00100000

#define PLATFORM_WIN32      2
#define PLATFORM_W2K        4

#define MIN_PACKAGE_SIZE 97280
#define FILEPREFIX   TEXT("file://")

#define INSTALL_INS  TEXT("install.ins")
#define BRANDING_CAB TEXT("branding.cab")
#define RATINGS_POL  TEXT("ratings.pol")
#define RATINGS_INF  TEXT("ratings.inf")
#define CONNECT_RAS  TEXT("connect.ras")
#define CONNECT_SET  TEXT("connect.set")
#define CONNECT_INF  TEXT("connect.inf")
#define CS_DAT       TEXT("cs.dat")
#define DESKTOP_INI  TEXT("desktop.ini")
#define FOLDER_INI   TEXT("folder.ini")
#define CA_STR       TEXT("ca.str")
#define ROOT_STR     TEXT("root.str")
#define ROOT_DIS     TEXT("root.dis")
#define PREFIX_FAV   TEXT("fav")
#define PREFIX_ICON  TEXT("$fi")
#define DOT_URL      TEXT(".url")
#define DOT_ICO      TEXT(".ico")
#define DOT_EXE      TEXT(".exe")
#define DOT_DLL      TEXT(".dll")

// RP_xxx  - registry path
// RK_xxx  - registry key
// RSK_xxx - registry subkey
// RV_xxx  - registry value
// RD_xxx  - registry data
// RA_xxx  - registry aux (can be anything for example, common suffix)

//----- Registry paths -----
#define RP_MS           TEXT("Software\\Microsoft")
#define RP_IE           RP_MS TEXT("\\Internet Explorer")

#define RP_WINDOWS      REGSTR_PATH_SETUP
#define RP_NT_WINDOWS   REGSTR_PATH_NT_CURRENTVERSION
#define RP_INETSET      RP_WINDOWS  TEXT("\\Internet Settings")

#define RP_MS_POLICIES  TEXT("Software\\Policies\\Microsoft")
#define RP_IE_POLICIES  RP_MS_POLICIES TEXT("\\Internet Explorer")

#define RP_REMOTEACCESS TEXT("RemoteAccess")
#define RP_PROFILES     RP_REMOTEACCESS TEXT("\\Profile")


#define RK_IE4SETUP     RP_MS TEXT("\\IE Setup\\Setup")
#define RV_PATH         TEXT("Path")

#define RK_WINDOWS      RP_WINDOWS
#define RK_NT_WINDOWS   RP_NT_WINDOWS
#define RV_IEAK_HELPSTR TEXT("IeakHelpString")

#define RK_IE           RP_IE
#define RV_VERSION      TEXT("Version")
#define RV_CUSTOMVER    TEXT("CustomizedVersion")

#define RK_INETSETTINGS        RP_INETSET
#define RV_ENABLEAUTODIAL      TEXT("EnableAutodial")
#define RV_NONETAUTODIAL       TEXT("NoNetAutodial")
#define RV_ENABLESECURITYCHECK TEXT("EnableSecurityCheck")

#define RK_UA_POSTPLATFORM     RK_INETSETTINGS TEXT("\\User Agent\\Post Platform")

//----- Connection settings -----
#define RK_REMOTEACCESS          RP_REMOTEACCESS
#define RV_INTERNETPROFILE       TEXT("InternetProfile")

#define RK_REMOTEACCESS_PROFILES RP_PROFILES
#define RV_COVEREXCLUDE          TEXT("CoverExclude")
#define RV_ENABLEAUTODISCONNECT  TEXT("EnableAutoDisconnect")
#define RV_ENABLEEXITDISCONNECT  TEXT("EnableExitDisconnect")
#define RV_DISCONNECTIDLETIME    TEXT("DisconnectIdleTime")
#define RV_REDIALATTEMPTS        TEXT("RedialAttempts")
#define RV_REDIALINTERVAL        TEXT("RedialWait")

#define RK_BTOOLBAR RK_IE TEXT("\\Extensions")

#define RK_RATINGS              REG_KEY_RATINGS
#define RK_IEAKPOLICYDATA       REG_KEY_IEAK_POL
#define RK_IEAKPOLICYDATA_USERS REG_KEY_IEAK_POLUSER
#define RK_USERS                TEXT("Users")
#define RV_KEY                  TEXT("Key")

#define RK_HELPMENUURL   RK_IE TEXT("\\Help_Menu_URLs")
#define RV_ONLINESUPPORT TEXT("Online_Support")
#define RV_3             TEXT("3")

#define RK_IE_MAIN           ADDONURL_KEY
#define RV_WINDOWTITLE       TEXT("Window Title")
#define RV_COMPANYNAME       TEXT("CompanyName")
#define RV_CUSTOMKEY         TEXT("Custom_Key")
#define RV_WIZVERSION        TEXT("Wizard_Version")
#define RV_ADDONURL          ADDONURL_VALUE
#define RV_HOMEPAGE          TEXT("Start Page")
#define RV_FIRSTHOMEPAGE     FIRST_HOME_PAGE
#define RV_SEARCHBAR         TEXT("Search Bar")
#define RV_USE_CUST_SRCH_URL TEXT("Use Custom Search URL")
#define RV_LARGEBITMAP       TEXT("BigBitmap")
#define RV_SMALLBITMAP       TEXT("SmallBitmap")
#define RV_DEFAULTPAGE       TEXT("Default_Page_URL")

#define RK_TOOLBAR         RK_IE TEXT("\\Toolbar")
#define RV_BRANDBMP        TEXT("BrandBitmap")
#define RV_SMALLBRANDBMP   TEXT("SmBrandBitmap")
#define RV_BACKGROUNDBMP   TEXT("BackBitmap")
#define RV_BACKGROUNDBMP50 TEXT("BackBitmapIE5")
#define RV_BITMAPMODE      TEXT("BitmapMode")
#define RV_TOOLBARTHEME    TEXT("UseTheme")
#define RV_TOOLBARICON     TEXT("ITB0")

#define RK_IEAK      REG_KEY_IEAK
#define RK_IEAK_MAIN RK_IEAK TEXT("\\Main")

#define RK_IEAK_SERVER      TEXT("Software\\Microsoft\\IEAK6")
#define RK_IEAK_SERVER_MAIN RK_IEAK_SERVER TEXT("\\Main")

#define RK_ICW       REG_KEY_ICW
#define RV_COMPLETED REG_VAL_COMPLETED

#define RK_UNINSTALL_BRANDING REGSTR_PATH_UNINSTALL TEXT("\\Branding")
#define RV_QUIET              QUIETUNINSTALLSTR
#define RV_REQUIRE_IE         REQUIRESIESTR
#define RD_RUNDLL             RUNDLL_UNINSTALL
#define RD_IE_VER             IEVER

#define RK_INETCPL        RK_IE_POLICIES TEXT("\\Control Panel")

#define RK_IE_DESKTOP  DESKTOPKEY
#define RV_CHLBAR_SIZE CHANNELSIZE

#define RK_CHANNEL_ADD     KEY_CHANNEL_ADD
#define RV_TITLE           TEXT("Title")
#define RV_URL             TEXT("URL")
#define RV_PRELOADURL      TEXT("PreloadURL")
#define RV_LOGO            TEXT("Logo")
#define RV_WIDELOGO        TEXT("WideLogo")
#define RV_ICON            TEXT("Icon")
#define RV_OFFLINE         TEXT("Offline")
#define RV_SYNCHRONIZE     TEXT("Synchronize")
#define RV_CATEGORY        TEXT("Category")
#define RV_SOFTWARE        TEXT("Software")
#define RV_SHOWCHANNELBAND TEXT("Show_ChannelBand")
#define RV_NOAUTOSIGNUP    TEXT("NoAutomaticSignup")

#define RK_MS_POLICIES           RP_MS_POLICIES
#define RK_IE_POLICIES           RP_IE_POLICIES
#define RK_POLICES_INFODELIVERY  RK_IE_POLICIES TEXT("\\Infodelivery")

#define RP_IE_POLICIESW          L"Software\\Policies\\Microsoft\\Internet Explorer"
#define RK_RESTRICTIONSW         L"Restrictions"
#define RV_NO_EXTERNAL_BRANDINGW L"NoExternalBranding"

#define RK_POLICES_RESTRICTIONS  RK_POLICES_INFODELIVERY TEXT("\\Restrictions")
#define RV_TPL                   TEXT("TrustedPublisherLockdown")

#define RK_POLICES_MODIFICATIONS RK_POLICES_INFODELIVERY TEXT("\\Modifications")
#define RK_CHANNEL_DEL           RK_POLICES_MODIFICATIONS TEXT("\\Channel%s\\RemoveAllChannels")
#define RV_CHANNELGUIDE          CHANNELGUIDE

#define RK_SUBSCRIPTION_ADD KEY_SUBSCRIPTION_ADD
#define RV_SUBSCRIPTIONTYPE TEXT("SubscriptionType")
#define RV_SCHEDULEGROUP    TEXT("ScheduleGroup")

#define RK_SYSCERT        TEXT("Software\\Microsoft\\SystemCertificates")
#define RSK_ROOT          TEXT("ROOT")
#define RSK_ROOT_DISABLED TEXT("ROOT_DISABLED")
#define RSK_CA            TEXT("CA")

#define RK_SYSCERT_ROOT          RK_SYSCERT TEXT("\\") RSK_ROOT
#define RK_SYSCERT_ROOT_DISABLED RK_SYSCERT TEXT("\\") RSK_ROOT_DISABLED
#define RK_SYSCERT_CA            RK_SYSCERT TEXT("\\") RSK_CA

#define RK_OE_ACCOUNTMGR TEXT("Software\\Microsoft\\Internet Account Manager")
#define RV_DLLPATH       TEXT("DllPath")

#define RK_TRUSTKEY   CURRENTVERSIONKEY TEXT("\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0")

#define RK_CLIENT       TEXT("Software\\Clients")
#define RK_HTMLEDIT     RK_IE TEXT("\\Default HTML Editor")

//----- IE4x Active Desktop legacy support -----
#define FOLDER_WALLPAPER TEXT("Wallpaper")

#define RP_CLSID      TEXT("Software\\Classes\\CLSID")
#define RP_IE_DESKTOP RK_IE TEXT("\\Desktop")

#define RK_MYCOMPUTER        RP_CLSID TEXT("\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\shellex\\ExtShellFolderViews\\{5984FFE0-28D4-11CF-AE66-08002B2E1262}")
#define RK_CONTROLPANEL      RP_CLSID TEXT("\\{21EC2020-3AEA-1069-A2DD-08002B30309D}\\shellex\\ExtShellFolderViews\\{5984FFE0-28D4-11CF-AE66-08002B2E1262}")
#define RV_PERSISTMONIKER    TEXT("PersistMoniker")

#define RK_WINDOWS           RP_WINDOWS
#define RV_WALLPAPERDIR      TEXT("WallpaperDir")

#define RK_CP_DESKTOP        TEXT("Control Panel\\desktop")
#define RK_DT_GENERAL        RP_IE_DESKTOP TEXT("\\General")
#define RV_WALLPAPER         TEXT("Wallpaper")
#define RV_BACKUPWALLPAPER   TEXT("BackupWallpaper")
#define RV_WALLPAPERFILETIME TEXT("WallpaperFileTime")
#define RV_TILEWALLPAPER     TEXT("TileWallpaper")
#define RV_WALLPAPERSTYLE    TEXT("WallpaperStyle")
#define RV_COMPONENTPOS      TEXT("ComponentsPositioned")

#define RK_DT_COMPONENTS     RP_IE_DESKTOP TEXT("\\Components")
#define RV_GENERALFLAGS      TEXT("GeneralFlags")
#define RV_SOURCE            TEXT("Source")
#define RV_FLAGS             TEXT("Flags")
#define RD_DIRTY             1
#define RD_CHLBAR_ENABLE     0x2000

#define IS_DESKTOPOBJS   DESKTOP_OBJ_SECT
#define IK_OPTION        OPTION
#define IK_MYCPTRPATH    MYCPTRPATH
#define IK_CPANELPATH    CTLPANELPATH
#define IK_DTOPCOMPURL   DESKCOMPURL
#define IK_SHOWCHLBAR    SHOWCHANBAR
#define IK_DESKCOMPLOCAL DESKCOMPLOCALFLAG

#define IS_WALLPAPER       TEXT("Wallpaper")
#define IS_CUSTOMWALLPAPER TEXT("Custom Wallpaper")
#define IK_COMPONENTPOS    TEXT("ComponentsPositioned")

#define IS_QUICKLAUNCH TEXT("Quick Launch Files")

#define REFRESH_DESKTOP TEXT("RefreshDesktop")
//----- The End -----

#define FOLDER_CUSTOM TEXT("Custom")
#define FOLDER_SIGNUP TEXT("Signup")
#define FOLDER_WEB    TEXT("Web")

#define IS_BRANDING               TEXT("Branding")
#define IK_SERVERKIOSK            TEXT("ServerKiosk")
#define IK_SERVERLESS             TEXT("Serverless")
#define IK_FLAGS                  TEXT("Flags")
#define IK_TYPE                   TEXT("Type")
#define IK_NOCLEAR                TEXT("NoClear")
#define IK_NODIAL                 TEXT("NoDial")
#define IK_CUSTOMKEY              TEXT("Custom_Key")
#define IK_COMPANYNAME            TEXT("CompanyName")
#define IK_WIZVERSION             TEXT("Wizard_Version")
#define IK_GPE_ONETIME_GUID       TEXT("One_Time_Guid")
#define IK_GPE_ADM_GUID           TEXT("Adm_Guid")
#define IK_UASTR                  USER_AGENT
#define IK_WINDOWTITLE            TEXT("Window_Title")
#define IK_TOOLBARBMP             TOOLBAR_BMP
#define IK_HELPSTR                TEXT("HelpString")
#define IK_AC_DONTMIGRATEVERSIONS TEXT("DontMigrateVersions")
#define IK_AC_NOUPDATEONINSCHANGE TEXT("NoUpdateOnInsChange")
#define IK_FAVORITES_ENCODE       TEXT("EncodeFavs")
#define IK_FAVORITES_DELETE       TEXT("FavoritesDelete")
#define IK_FAVORITES_ONTOP        TEXT("FavoritesOnTop")

#define IS_FF                 TEXT("FeatureFlags")
#define IK_FF_EXTREGINF       TEXT("ExtRegInf")
#define IK_FF_GENERAL         TEXT("General")
#define IK_FF_TOOLBARBUTTONS  TEXT("ToolbarButtons")
#define IK_FF_ROOTCERT        TEXT("RootCert")
#define IK_FF_TPL             TEXT("TrustedPublisherLockdown")
#define IK_FF_CD_WELCOME      TEXT("CDWelcome")
#define IK_FF_OUTLOOKEXPRESS  TEXT("OutlookExpress")
#define IK_FF_CHANNELS        TEXT("Channels")
#define IK_FF_SOFTWAREUPDATES TEXT("SoftwareUpdates")
#define IK_FF_CHANNELBAR      TEXT("ChannelBar")
#define IK_FF_SUBSCRIPTIONS   TEXT("Subscriptions")

#define IS_ANIMATION   TEXT("Animation")
#define IK_LARGEBITMAP TEXT("Big_Name")
#define IK_SMALLBITMAP TEXT("Small_Name")
#define IK_DOANIMATION TEXT("DoAnimation")

#define IS_LARGELOGO TEXT("Big_Logo")
#define IS_SMALLLOGO TEXT("Small_Logo")

#define IK_NO_ADDON       TEXT("NoAddonMenu")
#define IK_DEF_ADDON      TEXT("UseDefAddon")
#define IK_CUST_ADDON     TEXT("UseCustAddon")
#define IK_HELP_MENU_TEXT TEXT("Help_Menu_Text")
#define RV_HELP_MENU_TEXT TEXT("Windows Update Menu Text")
#define IK_ADDONURL       ADDONURL
#define IS_CUSTOM         TEXT("Custom")
#define IK_ALT_SITES_URL  TEXT("UseAlternateSitesURL")
#define IK_NO_WELCOME_URL TEXT("NoWelcome")

#define IS_EXTREGINF        EXTREGINF
#define IS_EXTREGINF_HKLM   IS_EXTREGINF TEXT(".Hklm")
#define IS_EXTREGINF_HKCU   IS_EXTREGINF TEXT(".Hkcu")

#define IS_EXTREGINF_ESC        TEXT("ExtRegInf_ESC")
#define IS_EXTREGINF_ESC_HKLM   IS_EXTREGINF_ESC TEXT(".Hklm")
#define IS_EXTREGINF_ESC_HKCU   IS_EXTREGINF_ESC TEXT(".Hkcu")

#define IK_CONNECTSET       TEXT("connset")

#define IS_CABVERSIONS CAB_VERSIONS

#define IS_STRINGS     STRINGS
#define IK_49100       TEXT("49100")

#define IS_URL               URL_SECT
#define IK_HOMEPAGE          START_PAGE
#define IK_FIRSTHOMEPAGE     INITHOMEPAGE
#define IK_SEARCHPAGE        SEARCH_PAGE
#define IK_HELPPAGE          TEXT("Help_Page")
#define IK_DETECTCONFIG      TEXT("AutoDetect")
#define IK_USEAUTOCONF       TEXT("AutoConfig")
#define IK_AUTOCONFURL       TEXT("AutoConfigURL")
#define IK_AUTOCONFURLJS     TEXT("AutoConfigJSURL")
#define IK_AUTOCONFTIME      TEXT("AutoConfigTime")
#define IK_LOCALAUTOCONFIG   TEXT("UseLocalIns")
#define IK_QUICKLINK_NAME    TEXT("Quick_Link_%i_Name")
#define IK_QUICKLINK_URL     TEXT("Quick_Link_%i")
#define IK_QUICKLINK_ICON    TEXT("Quick_Link_%i_Icon")
#define IK_QUICKLINK_OFFLINE TEXT("Quick_Link_%i_Offline")

#define IS_CUSTOMBRANDING CUSTBRNDSECT
#define IK_BRANDING       BRANDING

#define IS_CUSTOMDESKTOP CUSTDESKSECT
#define IK_DESKTOP       DESKTOP

#define IS_CUSTOMCHANNELS CUSTCHANSECT
#define IK_CHANNELS       CUSTCHANNAME

#define IS_FAVORITES     TEXT("Favorites")
#define IK_NAME          TEXT("Name")
#define IK_NOFAVORITES   TEXT("NoFavorites")
#define IK_NOLINKS       TEXT("NoLinks")
#define IK_REPOSITORY    TEXT("Repository")

// used by ProcessFavorites in brandll\brand.cpp
#define IS_FAVORITESEX      TEXT("FavoritesEx")
#define IK_TITLE_FMT        TEXT("Title%u")
#define IK_URL_FMT          TEXT("URL%u")
#define IK_ICON_FMT         TEXT("IconFile%u")
#define IK_HOT_ICON_FMT     TEXT("HotIconFile%u")
#define IK_OFFLINE_FMT      TEXT("Offline%u")

// used by SFavorite::CreateFavorite in brandll\utils.cpp
#define IS_INTERNETSHORTCUT TEXT("InternetShortcut")
#define IK_URL              TEXT("URL")
#define IK_ICONINDEX        TEXT("IconIndex")
#define IK_ICONFILE         ICONFILE

#define IS_CHANNEL_ADD    CHANNEL_ADD
#define IK_CHL_TITLE      CHTITLE
#define IK_CHL_URL        CDFURL
#define IK_CHL_PRELOADURL CHPREURLNAME
#define IK_CHL_LOGO       CHBMPNAME
#define IK_CHL_WIDELOGO   CHBMPWIDENAME
#define IK_CHL_ICON       CHICONNAME
#define IK_CHL_OFFLINE    TEXT("ChOffline")
#define IK_CHL_SBN_INDEX  CHSUBINDEX
#define IK_CAT_TITLE      CATTITLE
#define IK_CAT_URL        CATHTMLNAME
#define IK_CAT_PRELOADURL CHPREURLNAME
#define IK_CAT_LOGO       CATBMPNAME
#define IK_CAT_WIDELOGO   CATBMPWIDENAME
#define IK_CAT_ICON       CATICONNAME
#define IK_CATEGORY       CATEGORY

#define IS_SOFTWAREUPDATES SWUPDATES
#define IK_DELETECHANNELS  DELOLDCHAN
#define IK_PRELOADURL_FMT  TEXT("PreloadURL%u")
#define IK_LOGO_FMT        TEXT("Logo%u")
#define IK_WIDELOGO_FMT    TEXT("WideLogo%u")
#define IK_SBN_INDEX       SUBSCRIPTIONS


//----- IE4x subscriptions legacy support -----
#define RK_SCHEDITEMS    RP_WINDOWS TEXT("\\NotificationMgr\\SchedItems 0.6\\%s")
#define IS_SUBSCRIPTIONS TEXT("Subscriptions")
//------ The End -----

#define IS_ACTIVESETUP_SITES TEXT("ActiveSetupSites")
#define IK_SITENAME          TEXT("SiteName%u")
#define IK_SITEURL           TEXT("SiteURL%u")

#define IS_ACTIVESETUP    TEXT("ActiveSetup")
#define IK_WIZTITLE       TEXT("WizardTitle")
#define IK_WIZBMP         TEXT("WizardBitmap")
#define IK_WIZBMP2        TEXT("WizardBitmapTop")

#define IS_SITECERTS      SECURITY_IMPORTS
#define IK_TRUSTPUBLOCK   TEXT("TrustedPublisherLock")

// Security zones - added for RSoP support
#define IK_ZONE_FMT			TEXT("Zone%u")
#define IK_ZONE_HKLM_FMT	TEXT("Zone%u_HKLM")
#define IK_ZONE_HKCU_FMT	TEXT("Zone%u_HKCU")
#define IK_MAPPING_FMT		TEXT("Mapping%u")
#define IK_ACTIONVALUE_FMT	TEXT("Action%u")
#define IK_ZONES			TEXT("Zones")
#define IK_IEESC			TEXT("IEESCEnabled")

#define IK_DISPLAYNAME		TEXT("DisplayName")
#define IK_DESCRIPTION		TEXT("Description")
#define IK_ICONPATH			TEXT("Icon")
#define IK_CURLEVEL			TEXT("CurrentLevel")
#define IK_RECOMMENDLEVEL	TEXT("RecommendedLevel")
#define IK_MINLEVEL			TEXT("MinLevel")

#define IK_FILENAME_FMT		TEXT("FileName%i")
#define VIEW_UNKNOWN_RATED_SITES TEXT("Allow_Unknowns")
#define PASSWORD_OVERRIDE_ENABLED TEXT("PleaseMom")
#define IK_APPROVED_FMT		TEXT("Approved%i")
#define IK_DISAPPROVED_FMT	TEXT("Disapproved%i")
#define IK_BUREAU			TEXT("Bureau")

// Privacy settings - added for RSoP support
#define IK_PRIVACY					TEXT("Privacy")
#define IK_PRIV_1PARTY_TYPE			TEXT("FirstPartyType")
#define IK_PRIV_1PARTY_TYPE_TEXT	TEXT("FirstPartyTypeText")
#define IK_PRIV_3PARTY_TYPE			TEXT("ThirdPartyType")
#define IK_PRIV_3PARTY_TYPE_TEXT	TEXT("ThirdPartyTypeText")
#define IK_PRIV_ADV_SETTINGS		TEXT("AdvancedSettings")


// === Outlook Express

// OE Sections
#define IS_IDENTITIES     TEXT("Identities")
#define IS_INTERNETMAIL   INTERNET_MAIL
#define IS_INTERNETNEWS   INTERNET_NEWS
#define IS_OUTLKEXP       TEXT("Outlook_Express")
#define IS_OEGLOBAL       TEXT("Outlook_Express_Global")

// OE
#define IK_FOLDERBAR      TEXT("Folder_Bar")
#define IK_FOLDERLIST     TEXT("Folder_List")
#define IK_OUTLOOKBAR     TEXT("Outlook_Bar")
#define IK_STATUSBAR      TEXT("Status_Bar")
#define IK_CONTACTS       TEXT("Contacts")
#define IK_TIPOFTHEDAY    TEXT("Tip_Day")
#define IK_TOOLBAR        TEXT("Toolbar")
#define IK_TOOLBARTEXT    TEXT("Show_Toolbar_Text")
#define IK_PREVIEWPANE    TEXT("Preview_Pane")
#define IK_PREVIEWSIDE    TEXT("Show_Preview_Beside_Msgs")
#define IK_PREVIEWHDR     TEXT("Show_Preview_Header")
#define IK_DELETELINKS    TEXT("DeleteLinks")

// OE - Global
#define IK_READONLY       TEXT("Read_Only")
#define IK_NOMODIFYACCTS  TEXT("Disable_Account_Access")
#define IK_SERVICENAME    TEXT("Service_Name")
#define IK_SERVICEURL     TEXT("Service_URL")

// IK_PREVIEWPANEPOS values
#define PREVIEW_BOTTOM    0
#define PREVIEW_SIDE      1

// OE - Mail
#define IK_USESPECIAL     TEXT("Use_Special_Folders")
#define IK_CHECKFORNEW    TEXT("Poll_Subscribed_Folders")
#define IK_SHOWALL        TEXT("IMAP_ShowAllFolders")
#define IK_DRAFTS         TEXT("IMAP_Drafts")
#define IK_SENTITEMS      TEXT("IMAP_Sent_Items")
#define IK_RFP            TEXT("IMAP_Root_Folder")
#define IK_USEIMAP        TEXT("Use_IMAP")
#define IK_IMAPSERVER     TEXT("IMAP_Server")
#define IK_POPSERVER      TEXT("POP_Server")
#define IK_SMTPSERVER     SMTP_SERVER
#define IK_SMTPUSESPA     TEXT("SMTP_Logon_Using_SPA")
#define IK_SMTPREQLOGON   TEXT("SMTP_Logon_Required")
#define IK_NNTPSERVER     NNTP_SERVER
#define IK_DEFAULTCLIENT  DEFCLIENT
#define IK_USESPA         USE_SPA
#define IK_REQLOGON       LOGON_REQUIRED
#define IK_INFOPANE       INFOPANE
#define IK_INFOPANEBMP    INFOPANEBMP
#define IK_WELCOMEMESSAGE WELCOMEMSG
#define IK_WELCOMENAME    WELCOMENAME
#define IK_WELCOMEADDR    WELCOMEADDR
#define IK_EMAILNAME      EMAILNAME
#define IK_EMAILADDR      EMAILADDR
#define IK_HTMLMSGS       HTML_MSGS
#define IK_NEWSGROUPS     TEXT("Newsgroups")
#define IK_NEWSGROUPLIST  TEXT("Newsgroup_List")
#if defined(CONDITIONAL_JUNKMAIL)
#define IK_JUNKMAIL       TEXT("Junk_Mail_Filtering")
#endif

#define TIMEOUT_SEC_MIN     30
#define TIMEOUT_SEC_DEFAULT 60
#define TIMEOUT_SEC_MAX     5 * 60
#define TIMEOUT_DSEC        30
#define CTIMEOUT            (((TIMEOUT_SEC_MAX - TIMEOUT_SEC_MIN) / TIMEOUT_DSEC) + 1)

#define MATCHES_MAX         9999
#define MATCHES_MIN         1
#define MATCHES_DEFAULT     100

#define AUTH_ANONYMOUS      0
#define AUTH_SPA            2

#define IS_LDAP         LDAP
#define IK_SEARCHBASE   SEARCHBASE
#define IK_FRIENDLYNAME FRIENDLYNAME
#define IK_SERVER       TEXT("Server")
#define IK_LDAPHOMEPAGE TEXT("HomePage")
#define IK_SEARCHBASE   SEARCHBASE
#define IK_BITMAP       TEXT("Bitmap")
#define IK_CHECKNAMES   CHECKNAMES
#define IK_AUTHTYPE     AUTHTYPE
#define IK_TIMEOUT      TEXT("Search_Timeout")
#define IK_MATCHES      TEXT("Maximum_Results")

#define IS_MAILSIG        MAIL_SIG
#define IS_SIG            SIGNATURE
#define IK_USEMAILFORNEWS USE_MAIL_FOR_NEWS
#define IK_USESIG         USE_SIG
#define IK_SIGTEXT        SIG_TEXT

#define IS_CONNECTSET      TEXT("ConnectionSettings")
#define IK_OPTION          OPTION
#define IK_APPLYTONAME     TEXT("ApplyInsToConnection")
#define IK_DELETECONN      TEXT("DeleteConnectionSettings")
#define IK_ENABLEAUTODIAL  TEXT("EnableAutodial")
#define IK_NONETAUTODIAL   TEXT("NoNetAutodial")
#define IK_CONNECTNAME     TEXT("ConnectName%u")
#define IK_CONNECTSIZE     TEXT("ConnectSize%u")

#define IS_ISPSECURITY     TEXT("ISP_Security")
#define IK_ROOTCERT        TEXT("RootCertPath")

#define IS_PROXY           TEXT("Proxy")
#define IK_PROXYENABLE     TEXT("Proxy_Enable")
#define IK_SAMEPROXY       TEXT("Use_Same_Proxy")
#define IK_HTTPPROXY       TEXT("HTTP_Proxy_Server")
#define IK_GOPHERPROXY     TEXT("Gopher_Proxy_Server")
#define IK_FTPPROXY        TEXT("FTP_Proxy_Server")
#define IK_SECPROXY        TEXT("Secure_Proxy_Server")
#define IK_SOCKSPROXY      TEXT("Socks_Proxy_Server")
#define IK_PROXYOVERRIDE   TEXT("Proxy_Override")
#define LOCALPROXY         TEXT("<local>")

#define IS_CABSIGN      TEXT("CabSigning")
#define IK_PVK          TEXT("pvkFile")
#define IK_SPC          TEXT("spcFile")
#define IK_CSURL        TEXT("InfoURL")
#define IK_CSTIME       TEXT("TimeStampUrl")

#define IK_FULL         TEXT("Full")
#define IK_CAB          TEXT("Cab")
#define IK_INI          TEXT("Ini")

#define IS_IEAKLITE     TEXT("IEAKLite")

#define IS_SIGNUP       TEXT("SignupFiles")
#define IK_SIGNUP       TEXT("Signup")

#define IS_ISPFILES     TEXT("ISPFiles")
#define IS_INSFILE      TEXT("INSFile%d")

#define IS_OEWELC       TEXT("OEWelcomeFiles")

#define IS_CDCUST       TEXT("CDCustomFiles")
#define IK_MOREINFO     TEXT("MoreInfo")
#define IK_STARTHTM     TEXT("StartHtm")
#define IK_DISABLESTART TEXT("DisableStart")

#define IS_BTOOLBARS    TEXT("BrowserToolbars")
#define IK_BTCAPTION    TEXT("Caption")
#define IK_BTICON       ICON
#define IK_BTHOTICO     TEXT("HotIcon")
#define IK_BTACTION     TEXT("Action")
#define IK_BTTOOLTIP    TEXT("ToolTipText")
#define IK_BTDELETE     TEXT("DeleteButtons")
#define IK_BTSHOW       TEXT("Show")

#define IS_ICW          TEXT("ICW_IEAK")
#define IK_MODIFY_ISP   TEXT("Modify_ISP_Files")
#define IK_MODIFY_INS   TEXT("Modify_INS_Files")
#define IK_USEICW       TEXT("Use_ICW")
#define IK_ICWHTM       TEXT("HTML_Page")
#define IK_CUSTICWTITLE TEXT("CustomizeICWTitle")
#define IK_ICWDISPNAME  TEXT("ISP_Display_Name")
#define IK_HEADERBMP    TEXT("Header_Bitmap")
#define IK_WATERBMP     TEXT("Watermark_Bitmap")

#define IS_APPLYINS     TEXT("ApplyInsSec")
#define IK_DONTAPPLYINS TEXT("DontApplyIns")
#define IK_DONTMODIFY   TEXT("DontModify")
#define IK_APPLYINS     TEXT("ApplyIns")
#define IK_BRAND_NAME   TEXT("BrandingCabName")
#define IK_BRAND_URL    TEXT("BrandingCabURL")

#define IK_PROGRAMS     TEXT("Programs")

#define IS_BATCH        TEXT("Batch")

//----- Miscellaneous -----
#define IS_HIDECUST     TEXT("HideCustom")
#define IS_NOCOPYCUST   TEXT("NoCopyComps")
#define IS_CUSTOMVER CUSTOMVERSECT
#define IK_NUMFILES  NUMFILES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\inetcfg.h ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: INETCFG.H
//
//  PURPOSE:  Contains API's exported from inetcfg.dll and structures
//            required by those functions. 
//            Note:  Definitions in this header file require RAS.H.
//
//*******************************************************************

#ifndef _INETCFG_H_
#define _INETCFG_H_

#ifndef UNLEN
#include <lmcons.h>
#endif

// Generic HRESULT error code
#define ERROR_INETCFG_UNKNOWN 0x20000000L

#define MAX_EMAIL_NAME          64
#define MAX_EMAIL_ADDRESS       128
#define MAX_LOGON_NAME          UNLEN
#define MAX_LOGON_PASSWORD      PWLEN
#define MAX_SERVER_NAME         64  // max length of DNS name per RFC 1035 +1

// Flags for dwfOptions

// install exchange and internet mail
#define INETCFG_INSTALLMAIL           0x00000001
// Invoke InstallModem wizard if NO MODEM IS INSTALLED
#define INETCFG_INSTALLMODEM          0x00000002
// install RNA (if needed)
#define INETCFG_INSTALLRNA            0x00000004
// install TCP (if needed)
#define INETCFG_INSTALLTCP            0x00000008
// connecting with LAN (vs modem)
#define INETCFG_CONNECTOVERLAN        0x00000010
// Set the phone book entry for autodial
#define INETCFG_SETASAUTODIAL         0x00000020
// Overwrite the phone book entry if it exists
// Note: if this flag is not set, and the entry exists, a unique name will
// be created for the entry.
#define INETCFG_OVERWRITEENTRY        0x00000040
// Do not show the dialog that tells the user that files are about to be installed,
// with OK/Cancel buttons.
#define INETCFG_SUPPRESSINSTALLUI     0x00000080
// Check if TCP/IP file sharing is turned on, and warn user to turn it off.
// Reboot is required if the user turns it off.
#define INETCFG_WARNIFSHARINGBOUND    0x00000100
// Check if TCP/IP file sharing is turned on, and force user to turn it off.
// If user does not want to turn it off, return will be ERROR_CANCELLED
// Reboot is required if the user turns it off.
#define INETCFG_REMOVEIFSHARINGBOUND  0x00000200
// Indicates that this is a temporary phone book entry
// In Win3.1 an icon will not be created
#define INETCFG_TEMPPHONEBOOKENTRY    0x00000400


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

// constants for INETCLIENTINFO.dwFlags

#define INETC_LOGONMAIL     0x00000001
#define INETC_LOGONNEWS     0x00000002

// Struct INETCLIENTINFO
//
// This structure is used when getting and setting the internet
// client parameters
//
// The members are as follows:
//
//  dwSize
//    size of this structure, for future versioning
//    this member should be set before passing the structure to the DLL
//  dwFlags
//    miscellaneous flags
//    see definitions above
//  szEMailName
//    user's internet email name
//  szEMailAddress
//    user's internet email address
//  szPOPLogonName
//    user's internet mail server logon name
//  szPOPLogonPassword
//    user's internet mail server logon password
//  szPOPServer
//    user's internet mail POP3 server
//  szSMTPServer
//    user's internet mail SMTP server
//  szNNTPLogonName
//    user's news server logon name
//  szNNTPLogonPassword
//    user's news server logon password
//  szNNTPServer
//    user's news server

  typedef struct tagINETCLIENTINFO
  {
    DWORD   dwSize;
    DWORD   dwFlags;
    CHAR    szEMailName[MAX_EMAIL_NAME + 1];
    CHAR    szEMailAddress[MAX_EMAIL_ADDRESS + 1];
    CHAR    szPOPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szPOPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szPOPServer[MAX_SERVER_NAME + 1];
    CHAR    szSMTPServer[MAX_SERVER_NAME + 1];
    CHAR    szNNTPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szNNTPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szNNTPServer[MAX_SERVER_NAME + 1];
  } INETCLIENTINFO, *PINETCLIENTINFO, FAR *LPINETCLIENTINFO;
  


#ifdef __cplusplus
}
#endif // __cplusplus

#endif //_INETCFG_H_#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\intrawiz.h ===
#include "commctrl.h"
#include "intrawiz.rcv"

// menu commands

// Options menu
#define IDM_WIZARD      4100
#define IDM_EXIT        4101
#define IDM_LAST		4102

// Help menu
#define IDM_ABOUT       4200

// icons
#define EXE_ICON        300

// ids
#define ID_EDITCHILD	41000

// constants
#define NUM_PAGES   11
#define MAX_BUF		5000
#define MAX_LINE	512
#define MAX_URL	512


#define PPAGE_KEY 0
#define PPAGE_LANGUAGE 1
#define PPAGE_MEDIA 2
#define PPAGE_STARTSEARCH 3
#define PPAGE_FAVORITES 4
#define PPAGE_CUSTOMISK 5
#define PPAGE_ISKBACK 6

#define PPAGE_TITLE 7
#define PPAGE_CUSTICON 8
#define PPAGE_FINISH 10
#define PPAGE_HTML 9

// typedefs
typedef struct tagREVIEWINFO
{
    HINSTANCE hInst;        // current instance
	int iCustIcon;
	int iFavorites;
	int iReliability;
	int iGoals;
	int iAdaptation;
	char pszName[MAX_PATH];
	char pszTitle[MAX_PATH];
	char pszBitmap[MAX_PATH];
	char pszHomePage[MAX_URL];
	char pszSearchPage[MAX_URL];
	char pszDepartment[MAX_PATH];
	char pszBitmapPath[MAX_PATH];
	char pszBitmapName[MAX_PATH];
	char pszBitmap2Path[MAX_PATH];
	char pszBitmap2Name[MAX_PATH];

} REVIEWINFO;

// Function prototypes

// procs
long APIENTRY MainWndProc(HWND, UINT, UINT, LONG);
BOOL APIENTRY About(HWND, UINT, UINT, LONG);

// Pages for Wizard
BOOL APIENTRY CustIcon(HWND, UINT, UINT, LONG);
BOOL APIENTRY Favorites(HWND, UINT, UINT, LONG);
BOOL APIENTRY Reliability(HWND, UINT, UINT, LONG);
BOOL APIENTRY Goals(HWND, UINT, UINT, LONG);
BOOL APIENTRY Adaptation(HWND, UINT, UINT, LONG);

//functions
BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
int CreateWizard(HWND, HINSTANCE);
void FillInPropertyPage(LPPROPSHEETHEADER, int , int, LPSTR, DLGPROC);
void GenerateReview(HWND);
void StatusDialog(UINT);

// definitions for StatusDialog( )
#define SD_STEP1    1
#define SD_STEP2    2
#define SD_STEP3    3
#define SD_STEP4    4
#define SD_STEP5    5
#define SD_DESTROY  6

typedef struct tagISKINFO
{
	char pszISKBackBitmap[MAX_PATH];
	char pszISKTitleBar[MAX_PATH];
    char pszISKBtnBitmap[MAX_PATH];
    DWORD dwNormalColor;
    DWORD dwHighlightColor;
    DWORD dwNIndex;
    DWORD dwHIndex;
    BOOL fCoolButtons;
} ISKINFO;

BOOL APIENTRY ISKBackBitmap(HWND, UINT, UINT, LONG);

typedef void (PASCAL * OPKWIZCALLBACK) (LPARAM, WPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\ohareinc.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//      OHAREINC.H - common defines for O'Hare components
//			
//

//	HISTORY:
//	
//	3/10/95		jeremys		Created.
//


#ifndef _OHAREINC_H_
#define _OHAREINC_H_

// BUGBUG: duplicate in guitar.h should be removed

#define MAX_URL_STRING  1024

#endif // _OHARESTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\msgout.h ===
// =================================================================================
// Message Out Object Definition
// Written by: Steven J. Bailey on 1/21/96
// =================================================================================
#ifndef __MSGOUT_H
#define __MSGOUT_H

// =================================================================================
// Depends on
// =================================================================================
#include "mimeatt.h"
#include "message.h"
#include "mimecmn.h"
#include "ipab.h"

// =================================================================================
// Defines
// =================================================================================
#define MAX_ENCODE_BUFFER           4096
#define MAX_XMAILER_STR             255
#define MAX_MIME_VERSION_STR        255
#define MAX_MSGID_STR               255
#define MAX_BOUNDARY_STR            38
#define STREAM_ECODING_SCAN_LENGTH  4096

// =================================================================================
// Stream Out
// =================================================================================
HRESULT HrEmitMessageID (LPSTREAM lpstmOut);
HRESULT HrEmitMIMEVersion (LPSTREAM lpstmOut);
HRESULT HrEmitDateTime (LPSTREAM lpstmOut, LPFILETIME lpft);
HRESULT HrEmitBody (LPSTREAM lpstmOut, LPSTREAM lpstmBody, LPSTR lpszBoundary, BOOL fMIME);
HRESULT HrEmitMimeHdr (LPSTREAM lpstmOut, LPMIMEHDR lpMimeHdr);
HRESULT HrEmitLineBreak (LPSTREAM lpstmOut);
HRESULT HrEscapeQuotedString (LPTSTR pszIn, LPTSTR *ppszOut);
HRESULT HrStreamMsgOut (CMsg *lpMsg, LPSTREAM lpstmOut, LPMSGINFO lpMsgInfo, ULONG *piBodyStart);

HRESULT HrEmitAddrList (LPSTREAM    lpstmOut, 
                        LPTSTR      lpszKeyword, 
                        LPWABAL     lpWabal, 
                        LONG        lRecipType, 
                        ULONG       cbMaxLine,
                        BOOL        f1522Allowed,
                        LPTSTR      lpszCset);

HRESULT HrEmitKeywordValue (LPSTREAM    lpstmOut, 
                            LPTSTR      lpszKeyword, 
                            LPTSTR      lpszValue, 
                            BOOL        fStructured, 
                            ULONG       cbMaxLine,
                            BOOL        fEncode,
                            LPSTR       lpszCset);

#endif // __MSGOUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\scomptr.h ===
#ifndef __SMART_COM_POINTER_H_
#define __SMART_COM_POINTER_H_

#include <comutil.h>

///////////////////////////////////////////////////////////////////////////////
// ComPtr template class (smart pointer for a simple COM class which supports
// no interfaces but IUnknown.
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable: 4290)

// taken from _com_ptr_t definition in COMIP.h
template<class CLS> class ComPtr
{
public:
	// Default constructor.
	ComPtr() throw()
		: m_pInterface(NULL)	{}

	// This constructor is provided to allow NULL assignment. It will issue
	// an error if any value other than null is assigned to the object.
	ComPtr(int null) throw(_com_error)
		: m_pInterface(NULL)
	{
		if (null != 0) {
			_com_issue_error(E_POINTER);
		}
	}

	// Copy the pointer and AddRef().
	ComPtr(const ComPtr& cp) throw()
		: m_pInterface(cp.m_pInterface)
		{ _AddRef(); }

	// Saves the interface.
	ComPtr(CLS* pInterface) throw()
		: m_pInterface(pInterface)
		{ _AddRef(); }

	// Saves the interface.
	ComPtr& operator=(CLS* pInterface) throw()
	{
		if (m_pInterface != pInterface) {
			CLS* pOldInterface = m_pInterface;

			m_pInterface = pInterface;

			_AddRef();

			if (pOldInterface != NULL) {
				pOldInterface->Release();
			}
		}

		return *this;
	}

	// Copies and AddRef()'s the interface.
	ComPtr& operator=(const ComPtr& cp) throw()
		{ return operator=(cp.m_pInterface); }


	// This operator is provided to permit the assignment of NULL to the class.
	// It will issue an error if any value other than NULL is assigned to it.
	ComPtr& operator=(int null) throw(_com_error)
	{
		if (null != 0) {
			_com_issue_error(E_POINTER);
		}

		return operator=(reinterpret_cast<CLS*>(NULL));
	}

	// If we still have an interface then Release() it. The interface
	// may be NULL if Detach() has previously been called, or if it was
	// never set.
	~ComPtr() throw()
		{ _Release(); }

	// Return the class ptr. This value may be NULL.
	operator CLS*() const throw()
		{ return m_pInterface; }

	// Queries for the unknown and returns it
	// Provides minimal level error checking before use.
	operator CLS&() const throw(_com_error)
	{ 
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		return *m_pInterface; 
	}

	// Returns the address of the interface pointer contained in this
	// class. This is useful when using the COM/OLE interfaces to create
	// this interface.
	CLS** operator&() throw()
	{
		_Release();
		m_pInterface = NULL;
		return &m_pInterface;
	}

	// Allows this class to be used as the interface itself.
	// Also provides simple error checking.
	//
	CLS* operator->() const throw(_com_error)
	{ 
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		return m_pInterface; 
	}

	// This operator is provided so that simple boolean expressions will
	// work.  For example: "if (p) ...".
	// Returns TRUE if the pointer is not NULL.
	operator bool() const throw()
		{ return m_pInterface != NULL; }

	// Compare with other class ptr
	bool operator==(CLS* p) throw(_com_error)
		{ return (m_pInterface == p); }

	// Compares 2 ComPtr's
	bool operator==(ComPtr& p) throw()
		{ return operator==(p.m_pInterface); }

	// For comparison to NULL
	bool operator==(int null) throw(_com_error)
	{
		if (null != 0) {
			_com_issue_error(E_POINTER);
		}

		return m_pInterface == NULL;
	}

	// Compare with other interface
	bool operator!=(CLS* p) throw(_com_error)
		{ return !(operator==(p)); }

	// Compares 2 ComPtr's
	bool operator!=(ComPtr& p) throw(_com_error)
		{ return !(operator==(p)); }

	// For comparison to NULL
	bool operator!=(int null) throw(_com_error)
		{ return !(operator==(null)); }

	// Provides error-checking Release()ing of this interface.
	void Release() throw(_com_error)
	{
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		m_pInterface->Release();
		m_pInterface = NULL;
	}

	// Provides error-checking AddRef()ing of this interface.
	void AddRef() throw(_com_error)
	{ 
		if (m_pInterface == NULL) {
			_com_issue_error(E_POINTER);
		}

		m_pInterface->AddRef(); 
	}


private:
	// The Interface.
	CLS* m_pInterface;

	// Releases only if the interface is not null.
	// The interface is not set to NULL.
	//
	void _Release() throw()
	{
		if (m_pInterface != NULL) {
			m_pInterface->Release();
		}
	}

	// AddRefs only if the interface is not NULL
	//
	void _AddRef() throw()
	{
		if (m_pInterface != NULL) {
			m_pInterface->AddRef();
		}
	}
};


#endif //__SMART_COM_POINTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\setup31.h ===
//**********************************************************************
//
// SETUP31.H
//
//  Copyright (c) 1993-1996 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Windows 3.1 Setup services. (Based on
// Windows 95 SETUPX.DLL)
//
//**********************************************************************

#ifndef SETUP31_INC
#define SETUP31_INC   1 

// Need commctrl.h for some struct defines
#include <comctlie.h>
#include <stdlib.h>             // Stuff including _MAX_PATH

/********************************************************************
Stuff that should be in Windows.h
**********************************************************************/
#ifndef MAX_PATH
#define MAX_PATH    _MAX_PATH
#endif

/********************************************************************
Manifest constants
**********************************************************************/
#define MAX_DEVICE_ID_LEN       256
#define LINE_LEN                256
#define MAX_CLASS_NAME_LEN      32
#define MAX_SECT_NAME_LEN    32

/********************************************************************
Errors
**********************************************************************/
typedef UINT RETERR;             // Return Error code type.

#define OK 0                     // success error code
#define DI_ERROR       (500)    // Device Installer

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUP31 DEVICE_INSTALLER
*
*   @typee    _ERR_DEVICE_INSTALL | Error return codes for Device Installation
*   APIs.
*
*   @emem ERR_DI_INVALID_DEVICE_ID | Incorrectly formed device ID.
*
*   @emem ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST | Invalid compatible device list.
*
*   @emem ERR_DI_LOW_MEM | Insufficient memory to complete.
*
*   @emem ERR_DI_BAD_DEV_INFO | A passed in DEVICE_INFO struct is invalid.
*
*   @emem ERR_DI_DO_DEFAULT | Do the default action for the requested operation.
*
*   @emem ERR_DI_USER_CANCEL | The user cancelled the operation.
*
*   @emem ERR_DI_BAD_INF | An invalid INF file was encountered.
*
*   @emem ERR_DI_NO_INF | No INF found on supplied OEM path.
*
*   @emem ERR_DI_FAIL_QUERY | The queried action should not take place.
*
*   @emem ERR_DI_API_ERROR | One of the Device installation APIs was called
*   incorrectly or with invalid parameters.
*
*   @emem ERR_DI_BAD_PATH | An OEM path was specified incorrectly.
*
*******************************************************************************/
enum _ERR_DEVICE_INSTALL
{
    ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    
    ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  
    ERR_DI_LOW_MEM,                         
    ERR_DI_BAD_DEV_INFO,                    
    ERR_DI_DO_DEFAULT,                      
    ERR_DI_USER_CANCEL,                     
    ERR_DI_BAD_INF,                         
    ERR_DI_NO_INF,                          
    ERR_DI_FAIL_QUERY,                      
    ERR_DI_API_ERROR,                       
    ERR_DI_BAD_PATH,                        
    ERR_DI_NO_SECTION,
    ERR_DI_NO_LINE,
    ERR_DI_NO_STRING,
    ERR_ID_NO_MORE_LINES,
    ERR_DI_INVALID_FIELD
};


/********************************************************************
Structure Definitions
**********************************************************************/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUP31 DEVICE_INSTALLER
*
*   @types    DRIVER_NODE | This strucure represents a driver which can be
*   installed for a specific device.
*
*   @field struct _DRIVER_NODE FAR* | lpNextDN | Pointer to the next driver node
*   in a list.
*
*   @field UINT | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0
*   is the most compatible.
*
*   @field UINT | InfType | Type of INF this driver cam from.  This will
*   be either INFTYPE_TEXT or INFTYPE_EXECUTABLE
*
*   @field unsigned | InfDate | DOS date stamp of the INF file.
*
*   @field LPSTR | lpszDescription | Pointer to a the descriptrion of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszSectionName | Pointer to the name of INF install section for
*   this driver.
*
*   @field ATOM  | atInfFileName | Global ATOM containing the name of the INF file.
*
*   @field ATOM  | atMfgName | Global ATOM containing the name of this driver's
*   manufacture.
*
*   @field ATOM  | atProviderName | Global ATOM containing the name of this driver's
*   provider.
*
*   @field DWORD | Flags | Flags that control functions using this DRIVER_NODE
*       @flag DNF_DUPDESC           | This driver has the same device description
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*       @flag DNF_CONVERTEDLPINFO   | Set if this Driver Node was converted from an Info Node.
*       Setting this flag will cause the cleanup functions to explicitly delete it.
*
*   @field DWORD | dwPrivateData | Reserved
*
*   @field LPSTR | lpszDrvDescription | Pointer to a driver description.
*
*   @field LPSTR | lpszHardwareID | Pointer to a list of Plug-and-Play hardware IDs for
*   this driver.
*
*   @field LPSTR | lpszCompatIDs | Pointer to a list of Plug-and-Play compatible IDs for
*   this driver.
*
*******************************************************************************/
typedef struct _DRIVER_NODE 
{
    struct _DRIVER_NODE FAR*     lpNextDN;
    UINT                        Rank;
    unsigned                    InfDate;
    LPSTR                       lpszDescription;
    LPSTR                       lpszSectionName;
    ATOM                        atInfFileName;
    ATOM                        atMfgName;
    ATOM                        atProviderName;
    DWORD                       Flags;
    LPSTR                       lpszHardwareID;
}   DRIVER_NODE, NEAR* PDRIVER_NODE, FAR* LPDRIVER_NODE, FAR* FAR* LPLPDRIVER_NODE;

#define DNF_DUPDESC             0x00000001   // Multiple providers have same desc

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUP31 DEVICE_INSTALLER
*
*   @types    DEVICE_INFO | Device Information struct
*
*   @field UINT | cbSize | Size of the DEVICE_INFO struct.
*
*   @field struct _DEVICE_INFO FAR | *lpNextDi | Pointer to the next DEVICE_INFO struct
*   in a linked list.
*
*   @field char | szDescription[LINE_LEN] | Buffer containing the description of the
*   device.
*
*   @field char | szClassName[MAX_CLASS_NAME_LEN] | Buffer containing the device's
*   class name. (Can be a GUID str)
*
*   @field DWORD | Flags | Flags for controlling installation and U/I functions. Some
*   flags can be set prior to calling device installer APIs, and other are set
*   automatically during the processing of some APIs.
*
*   @field HWND | hwndParent | Window handle that will own U/I dialogs related to this
*   device.
*
*   @field LPDRIVER_NODE | lpCompatDrvList | Pointer to a linked list of DRIVER_NODES
*   representing the compatible drivers for this device.
*
*   @field LPDRIVER_NODE | lpClassDrvList | Pointer to a linked list of DRIVER_NODES
*   representing all drivers of this device's class.
*
*   @field LPDRIVER_NODE | lpSelectedDriver | Pointer to a single DRIVER_NODE that
*   has been selected as the driver for this device.
*
*   @field ATOM | atDriverPath | Global ATOM containing the path to this device's INF
*   file.  This is set only of the driver came from an OEM INF file.  This will be
*   0 if the INF is a standard Windows INF file.
*
*******************************************************************************/
typedef struct _DEVICE_INFO
{
    UINT                        cbSize;
    struct _DEVICE_INFO FAR     *lpNextDi;
    char                        szDescription[LINE_LEN];
    char                        szClassName[MAX_CLASS_NAME_LEN];
    DWORD                       Flags;
    HWND                        hwndParent;
    LPDRIVER_NODE               lpCompatDrvList;
    LPDRIVER_NODE               lpClassDrvList;
    LPDRIVER_NODE               lpSelectedDriver;
    ATOM                        atDriverPath;
} DEVICE_INFO, FAR * LPDEVICE_INFO, FAR * FAR * LPLPDEVICE_INFO;

// Flags for DEVICE_INFO
#define DI_SHOWOEM                  0x00000001L     // support Other... button
#define DI_SHOWCOMPAT               0x00000002L     // show compatibility list
#define DI_SHOWCLASS                0x00000004L     // show class list
#define DI_SHOWALL                  0x00000007L
#define DI_DIDCOMPAT                0x00000010L     // Searched for compatible devices
#define DI_DIDCLASS                 0x00000020L     // Searched for class devices
#define DI_MULTMFGS                 0x00000400L     // Set if multiple manufacturers in

#define ASSERT_DI_STRUC(lpdi) if (lpdi->cbSize != sizeof(DEVICE_INFO)) return (ERR_DI_BAD_DEV_INFO)


/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUP31 DEVICE_INSTALLER
*
*   @types    SUBSTR_DATA | Data structure used to manage substrings.
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field LPSTR | lpFirstSubstr | Pointer to the first substring in the list.
*
*   @field LPSTR | lpCurSubstr | Pointer to the current substring in the list.
*
*   @field LPSTR | lpLastSubstr | Pointer to the last substring in the list.
*
*   @xref InitSubstrData
*   @xref GetFirstSubstr
*   @xref GetNextSubstr
*
*******************************************************************************/
typedef struct _SUBSTR_DATA 
{
    LPSTR lpFirstSubstr;
    LPSTR lpCurSubstr;
    LPSTR lpLastSubstr;
}   SUBSTR_DATA;
typedef SUBSTR_DATA*        PSUBSTR_DATA;
typedef SUBSTR_DATA NEAR*   NPSUBSTR_DATA;
typedef SUBSTR_DATA FAR*    LPSUBSTR_DATA;


/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUP31 DEVICE_INSTALLER
*
*   @types    INF | Handle to an opened INF file
*
*   @field CHAR | szInfPath | Copy of the INF's path
*
*******************************************************************************/
typedef struct _INF
{
    WORD    cbSize;
    char    szInfPath[MAX_PATH];
    HDPA    hdpaStrings;
    HDPA    hdpaSections;                  // Array of INF section structs
}INF, FAR * LPINF, FAR * FAR * LPLPINF;

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUP31 DEVICE_INSTALLER
*
*   @types    INFSECT | A section in an INF file
*
*   @field WORD | cbSize | size of struct
*
*******************************************************************************/
typedef struct _INFSECT
{
    WORD    cbSize;
    char    szSectionName[MAX_SECT_NAME_LEN];
    WORD    wCurrentLine;
    HDPA    hdpaLines;
}INFSECT, FAR * LPINFSECT, FAR * FAR * LPLPINFSECT;


/********************************************************************
Exported Function Prototypes constants
**********************************************************************/
RETERR WINAPI DiBuildClassDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildCompatDrvList(LPDEVICE_INFO lpdi, LPCSTR lpcszDeviceID);
RETERR WINAPI DiDestroyDriverNodeList(LPDRIVER_NODE lpDNList);
RETERR WINAPI DiDestroyDeviceInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiCreateDeviceInfo
(
    LPLPDEVICE_INFO lplpdi,             
    LPCSTR          lpszDescription,    
    LPCSTR          lpszClassName,      
    HWND            hwndParent          
);

RETERR WINAPI IpOpen
(
    LPCSTR  lpcszFileSpec,
    LPLPINF lplpInf
);

RETERR WINAPI IpClose
(
    LPINF lpInf
);

BOOL WINAPI InitSubstrData(LPSUBSTR_DATA lpSubstrData, LPSTR lpStr);
BOOL WINAPI GetFirstSubstr(LPSUBSTR_DATA lpSubstrData);
BOOL WINAPI GetNextSubstr(LPSUBSTR_DATA lpSubStrData);
BOOL WINAPI InitSubstrDataEx(LPSUBSTR_DATA lpssd, LPSTR lpString, char chDelim);  /* ;Internal */
BOOL WINAPI InitSubstrDataNulls(LPSUBSTR_DATA lpssd, LPSTR lpString);

int WINAPI _i_strnicmp
(
    LPCSTR  lpOne,
    LPCSTR  lpTwo,
    int		n
);

void WINAPI FormStrWithoutPlaceHolders(LPSTR lpszDest, LPSTR lpszSource, LPINF lpInf);
RETERR WINAPI IpFindFirstLine
(
    LPINF       lpInf, 
    LPCSTR      lpcszSection,
    LPCSTR      lpcszEntry, 
    LPLPINFSECT lplpInfSection
);
RETERR WINAPI IpFindNextLine
(
    LPINF       lpInf, 
    LPINFSECT   lpInfSect
);
RETERR WINAPI IpGetStringField
(
    LPINF       lpInf, 
    LPINFSECT   lpInfSect, 
    WORD        wField, 
    LPSTR       lpszBuffer, 
    WORD        cbBuffer, 
    LPWORD      lpwcbCopied
);
RETERR WINAPI IpGetFieldCount
(
    LPINF       lpInf, 
    LPINFSECT   lpInfSect, 
    LPWORD      lpwFields
);

void WINAPI IpSaveRestorePosition
(
    LPINF   lpInf, 
    BOOL    bSave
);

//////////////////////////////////////////////////////////////////////////
// API that adds an icon into a Program Manager group. The group name can
// be gotten either from the INI file or from allowing the user to choose
// from the existing program manager groups.
//
BOOL CALLBACK __export
AddProgmanIcon
(
    LPCSTR  lpszExeFile,        // executable file that goes with the icon
    LPCSTR  lpszCmdLine,        // command line parameters for the exe file
    LPCSTR  lpszDescription,    // description under the icon
    LPCSTR  lpszIconFile,       // file that contains the icon
    int     nIconIndex,         // index of the icon in the icon file
    BOOL    fVerbose            // if TRUE and no name in the INI file, ask
                                // the user, else skip adding the icon
);


#endif                // SETUP31_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>

STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable);
STDAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                             LPCSTR pszRatingInfo, LPBYTE pData,
                             DWORD cbData, void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, void *pRatingDetails);
STDAPI RatingFreeDetails(void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCTSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCTSTR pszRating, void *lpvRatingDetails), HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif

STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();


#define S_RATING_ALLOW		S_OK
#define S_RATING_DENY		S_FALSE
#define S_RATING_FOUND		0x00000002
#define E_RATING_NOT_FOUND	0x80000001

/************************************************************************

IObtainRating interface

This interface is used to obtain the rating (PICS label) for a URL.
It is entirely up to the server to determine how to come up with the
label.  The ObtainRating call may be synchronous.

GetSortOrder returns a ULONG which is used to sort this rating helper
into the list of installed helpers.  The helpers are sorted in ascending
order, so a lower numbered helper will be called before a higher numbered
one.

************************************************************************/

DECLARE_INTERFACE_(IObtainRating, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(ObtainRating) (THIS_ LPCTSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut) PURE;

	STDMETHOD_(ULONG,GetSortOrder) (THIS) PURE;
};

#define RATING_ORDER_REMOTESITE		0x80000000
#define RATING_ORDER_LOCALLIST		0xC0000000


#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\raserr.h ===
/* RasErr.h
**
** Shiva Corporation
**
** Based on raserror.h
**
** Copyright (c) 1992-1995, Microsoft Corporation, all rights reserved
**
** Remote Access external API
** RAS specific error codes
*/

#ifndef _RASERR_H_
#define _RASERR_H_


#define RASBASE 600
#define SUCCESS 0


#define PENDING                              (RASBASE+0)
#define ERROR_INVALID_PORT_HANDLE            (RASBASE+1)
#define ERROR_PORT_ALREADY_OPEN              (RASBASE+2)
#define ERROR_BUFFER_TOO_SMALL               (RASBASE+3)
#define ERROR_WRONG_INFO_SPECIFIED           (RASBASE+4)
#define ERROR_CANNOT_SET_PORT_INFO           (RASBASE+5)
#define ERROR_PORT_NOT_CONNECTED             (RASBASE+6)
#define ERROR_EVENT_INVALID                  (RASBASE+7)
#define ERROR_DEVICE_DOES_NOT_EXIST          (RASBASE+8)
#define ERROR_DEVICETYPE_DOES_NOT_EXIST      (RASBASE+9)
#define ERROR_BUFFER_INVALID                 (RASBASE+10)
#define ERROR_ROUTE_NOT_AVAILABLE            (RASBASE+11)
#define ERROR_ROUTE_NOT_ALLOCATED            (RASBASE+12)
#define ERROR_INVALID_COMPRESSION_SPECIFIED  (RASBASE+13)
#define ERROR_OUT_OF_BUFFERS                 (RASBASE+14)
#define ERROR_PORT_NOT_FOUND                 (RASBASE+15)
#define ERROR_ASYNC_REQUEST_PENDING          (RASBASE+16)
#define ERROR_ALREADY_DISCONNECTING          (RASBASE+17)
#define ERROR_PORT_NOT_OPEN                  (RASBASE+18)
#define ERROR_PORT_DISCONNECTED              (RASBASE+19)
#define ERROR_NO_ENDPOINTS                   (RASBASE+20)
#define ERROR_CANNOT_OPEN_PHONEBOOK          (RASBASE+21)
#define ERROR_CANNOT_LOAD_PHONEBOOK          (RASBASE+22)
#define ERROR_CANNOT_FIND_PHONEBOOK_ENTRY    (RASBASE+23)
#define ERROR_CANNOT_WRITE_PHONEBOOK         (RASBASE+24)
#define ERROR_CORRUPT_PHONEBOOK              (RASBASE+25)
#define ERROR_CANNOT_LOAD_STRING             (RASBASE+26)
#define ERROR_KEY_NOT_FOUND                  (RASBASE+27)
#define ERROR_DISCONNECTION                  (RASBASE+28)
#define ERROR_REMOTE_DISCONNECTION           (RASBASE+29)
#define ERROR_HARDWARE_FAILURE               (RASBASE+30)
#define ERROR_USER_DISCONNECTION             (RASBASE+31)
#define ERROR_INVALID_SIZE                   (RASBASE+32)
#define ERROR_PORT_NOT_AVAILABLE             (RASBASE+33)
#define ERROR_CANNOT_PROJECT_CLIENT          (RASBASE+34)
#define ERROR_UNKNOWN                        (RASBASE+35)
#define ERROR_WRONG_DEVICE_ATTACHED          (RASBASE+36)
#define ERROR_BAD_STRING                     (RASBASE+37)
#define ERROR_REQUEST_TIMEOUT                (RASBASE+38)
#define ERROR_CANNOT_GET_LANA                (RASBASE+39)
#define ERROR_NETBIOS_ERROR                  (RASBASE+40)
#define ERROR_SERVER_OUT_OF_RESOURCES        (RASBASE+41)
#define ERROR_NAME_EXISTS_ON_NET             (RASBASE+42)
#define ERROR_SERVER_GENERAL_NET_FAILURE     (RASBASE+43)
#define WARNING_MSG_ALIAS_NOT_ADDED          (RASBASE+44)
#define ERROR_AUTH_INTERNAL                  (RASBASE+45)
#define ERROR_RESTRICTED_LOGON_HOURS         (RASBASE+46)
#define ERROR_ACCT_DISABLED                  (RASBASE+47)
#define ERROR_PASSWD_EXPIRED                 (RASBASE+48)
#define ERROR_NO_DIALIN_PERMISSION           (RASBASE+49)
#define ERROR_SERVER_NOT_RESPONDING          (RASBASE+50)
#define ERROR_FROM_DEVICE                    (RASBASE+51)
#define ERROR_UNRECOGNIZED_RESPONSE          (RASBASE+52)
#define ERROR_MACRO_NOT_FOUND                (RASBASE+53)
#define ERROR_MACRO_NOT_DEFINED              (RASBASE+54)
#define ERROR_MESSAGE_MACRO_NOT_FOUND        (RASBASE+55)
#define ERROR_DEFAULTOFF_MACRO_NOT_FOUND     (RASBASE+56)
#define ERROR_FILE_COULD_NOT_BE_OPENED       (RASBASE+57)
#define ERROR_DEVICENAME_TOO_LONG            (RASBASE+58)
#define ERROR_DEVICENAME_NOT_FOUND           (RASBASE+59)
#define ERROR_NO_RESPONSES                   (RASBASE+60)
#define ERROR_NO_COMMAND_FOUND               (RASBASE+61)
#define ERROR_WRONG_KEY_SPECIFIED            (RASBASE+62)
#define ERROR_UNKNOWN_DEVICE_TYPE            (RASBASE+63)
#define ERROR_ALLOCATING_MEMORY              (RASBASE+64)
#define ERROR_PORT_NOT_CONFIGURED            (RASBASE+65)
#define ERROR_DEVICE_NOT_READY               (RASBASE+66)
#define ERROR_READING_INI_FILE               (RASBASE+67)
#define ERROR_NO_CONNECTION                  (RASBASE+68)
#define ERROR_BAD_USAGE_IN_INI_FILE          (RASBASE+69)
#define ERROR_READING_SECTIONNAME            (RASBASE+70)
#define ERROR_READING_DEVICETYPE             (RASBASE+71)
#define ERROR_READING_DEVICENAME             (RASBASE+72)
#define ERROR_READING_USAGE                  (RASBASE+73)
#define ERROR_READING_MAXCONNECTBPS          (RASBASE+74)
#define ERROR_READING_MAXCARRIERBPS          (RASBASE+75)
#define ERROR_LINE_BUSY                      (RASBASE+76)
#define ERROR_VOICE_ANSWER                   (RASBASE+77)
#define ERROR_NO_ANSWER                      (RASBASE+78)
#define ERROR_NO_CARRIER                     (RASBASE+79)
#define ERROR_NO_DIALTONE                    (RASBASE+80)
#define ERROR_IN_COMMAND                     (RASBASE+81)
#define ERROR_WRITING_SECTIONNAME            (RASBASE+82)
#define ERROR_WRITING_DEVICETYPE             (RASBASE+83)
#define ERROR_WRITING_DEVICENAME             (RASBASE+84)
#define ERROR_WRITING_MAXCONNECTBPS          (RASBASE+85)
#define ERROR_WRITING_MAXCARRIERBPS          (RASBASE+86)
#define ERROR_WRITING_USAGE                  (RASBASE+87)
#define ERROR_WRITING_DEFAULTOFF             (RASBASE+88)
#define ERROR_READING_DEFAULTOFF             (RASBASE+89)
#define ERROR_EMPTY_INI_FILE                 (RASBASE+90)
#define ERROR_AUTHENTICATION_FAILURE         (RASBASE+91)
#define ERROR_PORT_OR_DEVICE                 (RASBASE+92)
#define ERROR_NOT_BINARY_MACRO               (RASBASE+93)
#define ERROR_DCB_NOT_FOUND                  (RASBASE+94)
#define ERROR_STATE_MACHINES_NOT_STARTED     (RASBASE+95)
#define ERROR_STATE_MACHINES_ALREADY_STARTED (RASBASE+96)
#define ERROR_PARTIAL_RESPONSE_LOOPING       (RASBASE+97)
#define ERROR_UNKNOWN_RESPONSE_KEY           (RASBASE+98)
#define ERROR_RECV_BUF_FULL                  (RASBASE+99)
#define ERROR_CMD_TOO_LONG                   (RASBASE+100)
#define ERROR_UNSUPPORTED_BPS                (RASBASE+101)
#define ERROR_UNEXPECTED_RESPONSE            (RASBASE+102)
#define ERROR_INTERACTIVE_MODE               (RASBASE+103)
#define ERROR_BAD_CALLBACK_NUMBER            (RASBASE+104)
#define ERROR_INVALID_AUTH_STATE             (RASBASE+105)
#define ERROR_WRITING_INITBPS                (RASBASE+106)
#define ERROR_X25_DIAGNOSTIC                 (RASBASE+107)
#define ERROR_ACCT_EXPIRED                   (RASBASE+108)
#define ERROR_CHANGING_PASSWORD              (RASBASE+109)
#define ERROR_OVERRUN                        (RASBASE+110)
#define ERROR_RASMAN_CANNOT_INITIALIZE       (RASBASE+111)
#define ERROR_BIPLEX_PORT_NOT_AVAILABLE      (RASBASE+112)
#define ERROR_NO_ACTIVE_ISDN_LINES           (RASBASE+113)
#define ERROR_NO_ISDN_CHANNELS_AVAILABLE     (RASBASE+114)
#define ERROR_TOO_MANY_LINE_ERRORS           (RASBASE+115)
#define ERROR_IP_CONFIGURATION               (RASBASE+116)
#define ERROR_NO_IP_ADDRESSES                (RASBASE+117)
#define ERROR_PPP_TIMEOUT                    (RASBASE+118)
#define ERROR_PPP_REMOTE_TERMINATED          (RASBASE+119)
#define ERROR_PPP_NO_PROTOCOLS_CONFIGURED    (RASBASE+120)
#define ERROR_PPP_NO_RESPONSE                (RASBASE+121)
#define ERROR_PPP_INVALID_PACKET             (RASBASE+122)
#define ERROR_PHONE_NUMBER_TOO_LONG          (RASBASE+123)
#define ERROR_IPXCP_NO_DIALOUT_CONFIGURED    (RASBASE+124)
#define ERROR_IPXCP_NO_DIALIN_CONFIGURED     (RASBASE+125)
#define ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE   (RASBASE+126)
#define ERROR_ACCESSING_TCPCFGDLL            (RASBASE+127)
#define ERROR_NO_IP_RAS_ADAPTER              (RASBASE+128)
#define ERROR_SLIP_REQUIRES_IP               (RASBASE+129)
#define ERROR_PROJECTION_NOT_COMPLETE        (RASBASE+130)
#define ERROR_PROTOCOL_NOT_CONFIGURED        (RASBASE+131)
#define ERROR_PPP_NOT_CONVERGING             (RASBASE+132)
#define ERROR_PPP_CP_REJECTED                (RASBASE+133)
#define ERROR_PPP_LCP_TERMINATED             (RASBASE+134)
#define ERROR_PPP_REQUIRED_ADDRESS_REJECTED  (RASBASE+135)
#define ERROR_PPP_NCP_TERMINATED             (RASBASE+136)
#define ERROR_PPP_LOOPBACK_DETECTED          (RASBASE+137)
#define ERROR_PPP_NO_ADDRESS_ASSIGNED        (RASBASE+138)
#define ERROR_CANNOT_USE_LOGON_CREDENTIALS   (RASBASE+139)
#define ERROR_TAPI_CONFIGURATION             (RASBASE+140)
#define ERROR_NO_LOCAL_ENCRYPTION            (RASBASE+141)
#define ERROR_NO_REMOTE_ENCRYPTION           (RASBASE+142)
#define ERROR_REMOTE_REQUIRES_ENCRYPTION     (RASBASE+143)
#define ERROR_IPXCP_NET_NUMBER_CONFLICT      (RASBASE+144)
#define ERROR_INVALID_SMM                    (RASBASE+145)
#define ERROR_SMM_UNINITIALIZED              (RASBASE+146)
#define ERROR_NO_MAC_FOR_PORT                (RASBASE+147)
#define ERROR_SMM_TIMEOUT                    (RASBASE+148)
#define ERROR_BAD_PHONE_NUMBER               (RASBASE+149)
#define ERROR_WRONG_MODULE                   (RASBASE+150)

#define ERROR_INVALID_NAME                   (RASBASE+151)
#define ERROR_ALREADY_EXISTS                 (RASBASE+152)

#define RASBASEEND                           (RASBASE+152)


#endif // _RASERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\test.h ===
//
// Copyright  1994-1996  Microsoft Corporation.  All Rights Reserved.
//
//	PROGRAM:	test.h
//
#define TEST 0
#define DOBRAND 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\version.h ===
#define OFFICIAL   1
#define FINAL      1

#define IEDKIT

/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the         *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values            *
 *                                                                          *
 ****************************************************************************/
/*XLATOFF*/
#ifndef WIN32
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <ver.h>
#endif 


/*--------------------------------------------------------------*/
/*                                                              */
/*                    CHANGING VERSION?                         */
/*                                                              */
/*                      PLEASE READ!                            */
/*                                                              */
/* The version has BOTH hex and string representations.  Take   */
/* care that the string version components are PROPERLY         */
/* CONVERTED TO HEX and that the hex values are INSERTED INTO   */
/* THE CORRECT POSITION in the hex versions.                    */
/*                                                              */
/* Suppose the version was being defined as:                    */
/*                                                              */
/*           #define VERSION  "9.99.1234"                       */
/*                                                              */
/* The other string preresentations of the version would be:    */ 
/*                                                              */
/*           #define VER_PRODUCTVERSION_STR  "9.99.1234\0"      */
/*           #define VER_PRODUCTVERSION       9,99,0,1234       */
/*                                                              */
/* The hex versions would NOT be 0x0999????.  The correct       */
/* definitions are:                                             */
/*                                                              */
/*    #define VER_PRODUCTVERSION_BUILD 1234                     */
/*    #define VER_PRODUCTVERSION_DW    (0x09630000 | 1234)      */
/*    #define VER_PRODUCTVERSION_W     (0x0963)                 */
/*                                                              */
/* The last four digits of the build number should be modified  */
/* by the official builder for each build.                      */
/*                                                              */
/*--------------------------------------------------------------*/
#if defined(IEDKIT)

/*--------------------------------------------------------------*/
/* Version numbers for IE Distribution kit                      */
/*--------------------------------------------------------------*/

#define VERSION                     "3.0.0.509"
#define VER_PRODUCTVERSION_STR      "3.0.0.509\0"
#define VER_PRODUCTVERSION          3,0,0,509
#define VER_PRODUCTVERSION_BUILD    509
#define VER_PRODUCTVERSION_DW       (0x01000000 | 509)
#define VER_PRODUCTVERSION_W        (0x0100)
#endif


/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"

#define VER_PRODUCTNAME_STR         "Microsoft\256 Internet Explorer Administration Kit\0"

#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\warning.h ===
#pragma warning(disable: 4127)                  // conditional expression is constant
#pragma warning(disable: 4201)                  // nonstandard extension used : nameless struct/union
#pragma warning(disable: 4211)                  // redefining extern to static is OK
#pragma warning(disable: 4509)                  // SEH and destructors are OK
#pragma warning(disable: 4710)                  // inline function was not expanded
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\vwin32.h ===
/******************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp.  All Rights Reserved, 1989-1995
 *
 *   Title: vwin32.h -
 *
 *   Version:   4.00
 *
 *   Date:  24-May-1993
 *
 ******************************************************************************/

/*INT32*/

#ifndef _VWIN32_H_
#define _VWIN32_H_

// ;BeginInternal
// Note that this ID has been reserved for us in VMM.H

#define VWIN32_DEVICE_ID    0x0002A

#define VWIN32_VER_MAJOR    1
#define VWIN32_VER_MINOR    4

#define THREAD_TYPE_WIN32 VWIN32_DEVICE_ID

// ;EndInternal

#ifndef Not_VxD

/*XLATOFF*/
#define VWIN32_Service  Declare_Service
#define VWIN32_StdCall_Service Declare_SCService
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VWIN32)

VWIN32_Service  (VWIN32_Get_Version, LOCAL)
VWIN32_Service  (VWIN32_DIOCCompletionRoutine, LOCAL)
VWIN32_Service  (_VWIN32_QueueUserApc)
VWIN32_Service  (_VWIN32_Get_Thread_Context)
VWIN32_Service  (_VWIN32_Set_Thread_Context)
VWIN32_Service  (_VWIN32_CopyMem, LOCAL)
VWIN32_Service  (_VWIN32_Npx_Exception)
VWIN32_Service  (_VWIN32_Emulate_Npx)
VWIN32_Service  (_VWIN32_CheckDelayedNpxTrap)
VWIN32_Service  (VWIN32_EnterCrstR0)
VWIN32_Service  (VWIN32_LeaveCrstR0)
VWIN32_Service  (_VWIN32_FaultPopup)
VWIN32_Service  (VWIN32_GetContextHandle)
VWIN32_Service  (VWIN32_GetCurrentProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_SetWin32Event)
VWIN32_Service  (_VWIN32_PulseWin32Event)
VWIN32_Service  (_VWIN32_ResetWin32Event)
VWIN32_Service  (_VWIN32_WaitSingleObject)
VWIN32_Service  (_VWIN32_WaitMultipleObjects)
VWIN32_Service  (_VWIN32_CreateRing0Thread)
VWIN32_Service  (_VWIN32_CloseVxDHandle)
VWIN32_Service  (VWIN32_ActiveTimeBiasSet, LOCAL)
VWIN32_Service  (VWIN32_GetCurrentDirectory, LOCAL)
VWIN32_Service  (VWIN32_BlueScreenPopup)
VWIN32_Service  (VWIN32_TerminateApp)
VWIN32_Service  (_VWIN32_QueueKernelAPC)
VWIN32_Service  (VWIN32_SysErrorBox)
VWIN32_Service  (_VWIN32_IsClientWin32)
VWIN32_Service  (VWIN32_IFSRIPWhenLev2Taken, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Event)
VWIN32_Service  (_VWIN32_InitWin32Mutex)
VWIN32_Service  (_VWIN32_ReleaseWin32Mutex)
VWIN32_Service  (_VWIN32_BlockThreadEx)
VWIN32_Service  (VWIN32_GetProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Semaphore)
VWIN32_Service  (_VWIN32_SignalWin32Sem)
VWIN32_Service  (_VWIN32_QueueUserApcEx)
VWIN32_Service	(_VWIN32_OpenVxDHandle)
VWIN32_Service	(_VWIN32_CloseWin32Handle)
VWIN32_Service	(_VWIN32_AllocExternalHandle)
VWIN32_Service	(_VWIN32_UseExternalHandle)
VWIN32_Service	(_VWIN32_UnuseExternalHandle)
VWIN32_StdCall_Service	(KeInitializeTimer, 1)
VWIN32_StdCall_Service	(KeSetTimer, 4)
VWIN32_StdCall_Service	(KeCancelTimer, 1)
VWIN32_StdCall_Service	(KeReadStateTimer, 1)
VWIN32_Service	(_VWIN32_ReferenceObject)
VWIN32_Service	(_VWIN32_GetExternalHandle)

End_Service_Table(VWIN32)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)      // turn on not enough params warning
/*XLATON*/

#endif // Not_VxD

// ;BeginInternal

// PM API list

#define VWIN32_GET_VER      0
#define VWIN32_THREAD_SWITCH    1   // ECX = wake param, EBX = ring 0 handle
#define VWIN32_DPMI_FAULT   2   // SS:BP = FAULTSTACKFRAME, AL = ignore
#define VWIN32_MMGR_FUNCTIONS   3
#define VWIN32_EVENT_CREATE 4
#define VWIN32_EVENT_DESTROY    5
#define VWIN32_EVENT_WAIT   6
#define VWIN32_EVENT_SET    7
#define VWIN32_RealNetx_Info    8
#define VWIN32_THREAD_BOOST_PRI 9
#define VWIN32_WAIT_CRST    10
#define VWIN32_WAKE_CRST    11
#define VWIN32_SET_FAULT_INFO   12
#define VWIN32_EXIT_TIME    13
#define VWIN32_BOOST_THREAD_GROUP 14
#define VWIN32_BOOST_THREAD_STATIC 15
#define VWIN32_WAKE_IDLE_SYS    16
#define VWIN32_MAKE_IDLE_SYS    17
#define VWIN32_DELIVER_PENDING_KERNEL_APCS 18
#define VWIN32_SYS_ERROR_BOX    19
#define VWIN32_GET_IFSMGR_XLAT_PTR 20
#define VWIN32_BOOST_THREAD_DECAY 21
#define VWIN32_LAST_CMD     21

#define VWIN32_MMGR_RESERVE ((VWIN32_MMGR_FUNCTIONS << 8) + 0)
#define VWIN32_MMGR_COMMIT  ((VWIN32_MMGR_FUNCTIONS << 8) + 1)
#define VWIN32_MMGR_DECOMMIT    ((VWIN32_MMGR_FUNCTIONS << 8) + 2)
#define VWIN32_MMGR_PAGEFREE    ((VWIN32_MMGR_FUNCTIONS << 8) + 3)

//
// Current Win32 thread/process handles.
//
// Updated every context switch.
//

typedef struct _K32CURRENT {
    DWORD   CurThreadHandle;    // win32 thread handle
    DWORD   CurProcessHandle;   // win32 process handle
    DWORD   CurTDBX;        // current TDBX
    DWORD   pCurK16Task;        // flat pointer to kernel 16 CurTDB
    DWORD   CurContextHandle;   // win32 memory context handle
} K32CURRENT;

//
// Flag values for CreateThread
//
#define VWIN32_CT_EMULATE_NPX   0x01    // set EM bit in CR0 for thread
#define VWIN32_CT_WIN32_NPX 0x02    // use Win32 FP exception model
#define VWIN32_CT_WIN32     0x04    // thread is Win32 (not Win16)

//
// Return values from VWIN32_CheckDelayedNpxTrap
//
#define CX_RAISE    0       // instruction raises exception
#define CX_IGNORE   1       // instruction ignores exception
#define CX_CLEAR    2       // instruction clears or masks exception

// flags to use for win32 blocking
#define WIN32_BLOCK_FLAGS (BLOCK_FORCE_SVC_INTS+BLOCK_SVC_INTS+BLOCK_THREAD_IDLE+BLOCK_ENABLE_INTS)

//
// Flags for VWIN32_BlueScreenPopup
//

#define VBSP_CANCEL     0x00000001
#define VBSP_DISPLAY_VXD_NAME   0x00000002

//
// Fault stack frame structure
//

typedef struct fsf_s {
    WORD fsf_GS;
    WORD fsf_FS;
    WORD fsf_ES;
    WORD fsf_DS;
    DWORD fsf_EDI;
    DWORD fsf_ESI;
    DWORD fsf_EBP;
    DWORD fsf_locked_ESP;
    DWORD fsf_EBX;
    DWORD fsf_EDX;
    DWORD fsf_ECX;
    DWORD fsf_EAX;
    WORD fsf_num;       // Fault number
    WORD fsf_prev_IP;   // IP of previous fault handler
    WORD fsf_prev_CS;   // CS of previous fault handler
    WORD fsf_ret_IP;    // DPMI fault handler frame follows
    WORD fsf_ret_CS;
    WORD fsf_err_code;
    WORD fsf_faulting_IP;
    WORD fsf_faulting_CS;
    WORD fsf_flags;
    WORD fsf_SP;
    WORD fsf_SS;
} FAULTSTACKFRAME;

typedef FAULTSTACKFRAME *PFAULTSTACKFRAME;

// ;EndInternal

//
// structure for VWIN32_SysErrorBox
//

typedef struct vseb_s {
    DWORD vseb_resp;
    WORD vseb_b3;
    WORD vseb_b2;
    WORD vseb_b1;
    DWORD vseb_pszCaption;
    DWORD vseb_pszText;
} VSEB;

typedef VSEB *PVSEB;

#define SEB_ANSI    0x4000      // ANSI strings if set on vseb_b1
#define SEB_TERMINATE   0x2000      // forces termination if button pressed

// VWIN32_QueueKernelAPC flags

#define KERNEL_APC_IGNORE_MC        0x00000001
#define KERNEL_APC_STATIC       0x00000002
#define KERNEL_APC_WAKE         0x00000004

// for DeviceIOControl support
// On a DeviceIOControl call vWin32 will pass following parameters to
// the Vxd that is specified by hDevice. hDevice is obtained thru an
// earlier call to hDevice = CreateFile("\\.\vxdname", ...);
// ESI = DIOCParams STRUCT (defined below)
typedef struct DIOCParams   {
    DWORD   Internal1;      // ptr to client regs
    DWORD   VMHandle;       // VM handle
    DWORD   Internal2;      // DDB
    DWORD   dwIoControlCode;
    DWORD   lpvInBuffer;
    DWORD   cbInBuffer;
    DWORD   lpvOutBuffer;
    DWORD   cbOutBuffer;
    DWORD   lpcbBytesReturned;
    DWORD   lpoOverlapped;
    DWORD   hDevice;
    DWORD   tagProcess;
} DIOCPARAMETERS;

typedef DIOCPARAMETERS *PDIOCPARAMETERS;

// dwIoControlCode values for vwin32's DeviceIOControl Interface
// all VWIN32_DIOC_DOS_ calls require lpvInBuffer abd lpvOutBuffer to be
// struct * DIOCRegs
#define VWIN32_DIOC_GETVERSION DIOC_GETVERSION
#define VWIN32_DIOC_DOS_IOCTL       1
#define VWIN32_DIOC_DOS_INT25       2
#define VWIN32_DIOC_DOS_INT26       3
#define VWIN32_DIOC_DOS_INT13       4
#define VWIN32_DIOC_SIMCTRLC        5
#define VWIN32_DIOC_DOS_DRIVEINFO   6
#define VWIN32_DIOC_CLOSEHANDLE DIOC_CLOSEHANDLE

// DIOCRegs
// Structure with i386 registers for making DOS_IOCTLS
// vwin32 DIOC handler interprets lpvInBuffer , lpvOutBuffer to be this struc.
// and does the int 21
// reg_flags is valid only for lpvOutBuffer->reg_Flags
typedef struct DIOCRegs {
    DWORD   reg_EBX;
    DWORD   reg_EDX;
    DWORD   reg_ECX;
    DWORD   reg_EAX;
    DWORD   reg_EDI;
    DWORD   reg_ESI;
    DWORD   reg_Flags;      
} DIOC_REGISTERS;

// if we are not included along with winbase.h
#ifndef FILE_FLAG_OVERLAPPED
  // OVERLAPPED structure for DeviceIOCtl VxDs
  typedef struct _OVERLAPPED {
          DWORD O_Internal;
          DWORD O_InternalHigh;
          DWORD O_Offset;
          DWORD O_OffsetHigh;
          HANDLE O_hEvent;
  } OVERLAPPED;
#endif

//  Parameters for _VWIN32_OpenVxDHandle to validate the Win32 handle type.
#define OPENVXD_TYPE_SEMAPHORE  0
#define OPENVXD_TYPE_EVENT      1
#define OPENVXD_TYPE_MUTEX      2
#define	OPENVXD_TYPE_ANY	3
  
// ;BeginInternal
#define OPENVXD_TYPE_MAXIMUM    3
// ;EndInternal

//
//  Object type table declaration for _VWIN32_AllocExternalHandle
//
/*XLATOFF*/
#define R0OBJCALLBACK           __stdcall
typedef VOID    (R0OBJCALLBACK *R0OBJFREE)(PVOID pR0ObjBody);
typedef PVOID   (R0OBJCALLBACK *R0OBJDUP)(PVOID pR0ObjBody, DWORD hDestProc);
/*XLATON*/
/* ASM
R0OBJFREE   TYPEDEF     DWORD
R0OBJDUP    TYPEDEF     DWORD
*/

typedef struct _R0OBJTYPETABLE {
    DWORD       ott_dwSize;             //  sizeof(R0OBJTYPETABLE)
    R0OBJFREE   ott_pfnFree;            //  called by Win32 CloseHandle
    R0OBJDUP    ott_pfnDup;             //  called by Win32 DuplicateHandle
} R0OBJTYPETABLE, *PR0OBJTYPETABLE;
/* ASM
R0OBJTYPETABLE  typedef _R0OBJTYPETABLE;
*/

#define R0EHF_INHERIT   0x00000001      //  Handle is inheritable
#define R0EHF_GLOBAL    0x00000002      //  Handle is valid in all contexts
// ;BeginInternal
#define R0EHF_ALL       (R0EHF_INHERIT | R0EHF_GLOBAL)
// ;EndInternal

// ;BeginInternal

/* ASM

FSF_CLEANUP_RETURN  EQU fsf_ret_IP - fsf_num
FSF_CLEANUP_CHAIN   EQU fsf_prev_IP - fsf_num

K32CURRENT typedef _K32CURRENT

;***LT  W32Fun - macro to make a function callable from Kernel32
;
;   This macro will create a stub of the format that the Ring0/Ring3
;   Win32 calling interface likes.
;   It plays around with the stack so that the arguments are set
;   up right and clean off right and it also sets the ring 3
;   registers to reflect the outcome of the operation.
;
;   This macro is taken from VMM's memory manager, file: mma.asm
;
;   ENTRY:  fun - function name
;       cargs - number of dword arguments it has
;       prefix - prefix for function
;   EXIT:   none
;
;   Note that when the function is called:
;       EBX is the VM handle
;       ESI points to client registers
;       EDI points to the return address
;   THESE REGISTERS MUST NOT BE TRASHED!
;
W32Fun  MACRO   fun, cbargs, prefix

BeginProc   VW32&fun, esp, W32SVC, public
    ArgVar  pcrs,dword
    ArgVar  hvm,dword
    x = 0
    REPT    cbargs
        x = x + 1
        ArgVar  arg&x,dword
    ENDM

    EnterProc
    pop edi     ;Save and remove return address
    pop esi     ;Save and remove client regs
    pop ebx     ;Save and remove hvm

    call    prefix&fun  ;Call function somewhere in VxD
                ;Note that this function may be a C function

    mov [esi].Client_EAX,eax    ;Put return values into client regs

    push    ebx     ;Put hvm back on stack
    push    esi     ;Put client regs back on stack
    push    edi     ;Restore return address

    LeaveProc
    Return
EndProc VW32&fun

ENDM
*/

// ;EndInternal

#endif  // _VWIN32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\winsav.h ===
#include <windowsx.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\adjustui.cpp ===
#include "pch.h"

#pragma pack(push, 2)
typedef struct tagDLGTEMPLATEEX {
    WORD   dlgVer;
    WORD   signature;
    DWORD  helpID;
    DWORD  exStyle;
    DWORD  style;
    WORD   cDlgItems;
    short  x;
    short  y;
    short  cx;
    short  cy;
} DLGTEMPLATEEX, *PDLGTEMPLATEEX;
typedef const DLGTEMPLATEEX* PCDLGTEMPLATEEX;
#pragma pack(pop)

BOOL loadDialogTemplate (HINSTANCE hinstDlg, UINT nID, PVOID *ppvDT, PDWORD pcbDT);


HRESULT PrepareDlgTemplate(HINSTANCE hInst, UINT nDlgID, DWORD dwStyle, PVOID *ppvDT)
{
    PCDLGTEMPLATEEX pdt2;
    LPCDLGTEMPLATE  pdt;                        // for some weird reason there is no PCDLGTEMPLATE
    PVOID           pvDlg;
    HRESULT         hr;
    DWORD           cbDlg;
    BOOL            fResult;

    //----- Initialization and parameter validation -----
    if (hInst == NULL || nDlgID == 0)
        return E_INVALIDARG;

    if (ppvDT == NULL)
        return E_POINTER;
    *ppvDT = NULL;

    //----- Resource allocation -----
    fResult = loadDialogTemplate(hInst, nDlgID, &pvDlg, &cbDlg);
    if (!fResult)
        return E_FAIL;

    *ppvDT = CoTaskMemAlloc(cbDlg);
    if (*ppvDT == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppvDT, cbDlg);
    CopyMemory(*ppvDT, pvDlg, cbDlg);
    hr = S_OK;

    //----- Parse through Dialog Template -----
    UINT nStyleOffset;

    pdt  = NULL;
    pdt2 = (PCDLGTEMPLATEEX)pvDlg;              // assume extended style

    if (pdt2->signature == 0xFFFF) {
        if (pdt2->dlgVer != 1)
            return E_UNEXPECTED;                // Chicago sanity check

        nStyleOffset = (UINT) ((PBYTE)&pdt2->style - (PBYTE)pdt2);
    }
    else {
        pdt  = (LPCDLGTEMPLATE)pvDlg;
        pdt2 = NULL;

        nStyleOffset = (UINT) ((PBYTE)&pdt->style - (PBYTE)pdt);
    }

    // let party on it now, style is DWORD

    // BUGBUG: (andrewgu) the code below regarding to styles was figured out by experement. if you
    // can't understand it just believe in it and pray that it works. the idea is to preserve
    // extended style bits from the old style if new style doesn't have any. on the other hand, if
    // the new style has extended bits in it, i assume the caller knows what he's doing and i let
    // it through.
    PDWORD pdwOldStyle;
    DWORD  dwNewStyle;

    pdwOldStyle = (PDWORD)((PBYTE)*ppvDT + nStyleOffset);
    dwNewStyle  = dwStyle;
    if (dwNewStyle == 0)
        dwNewStyle = WS_CHILD | DS_CONTROL;

    if ((dwNewStyle & 0x0000FFFF) == 0)
        dwNewStyle |= *pdwOldStyle & 0x0000FFFF;

    *pdwOldStyle = dwNewStyle;

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helpers routines (private)

BOOL loadDialogTemplate(HINSTANCE hinstDlg, UINT nID, PVOID *ppvDT, PDWORD pcbDT)
{
    PVOID  p;
    HANDLE h;

    if (hinstDlg == NULL)
        return FALSE;

    if (ppvDT == NULL)
        return FALSE;
    *ppvDT = NULL;

    if (pcbDT == NULL)
        return FALSE;
    *pcbDT = 0;

    h = FindResource(hinstDlg, MAKEINTRESOURCE(nID), RT_DIALOG);
    if (h == NULL)
        return FALSE;

    *pcbDT = SizeofResource(hinstDlg, (HRSRC)h);
    if (*pcbDT == 0)
        return FALSE;

    h = LoadResource(hinstDlg, (HRSRC)h);
    if (h == NULL)
        return FALSE;

    p = LockResource(h);
    if (p == NULL)
        return FALSE;

    *ppvDT = p;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\autocnfg.cpp ===
//
// AUTOCNFG.CPP
//

#include "pch.h"


INT_PTR CALLBACK QueryAutoConfigDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szAutoConfigURL[MAX_URL],
          szAutoProxyURL[MAX_URL],
          szAutoConfigTime[7];
    BOOL  fDetectConfig,
          fUseAutoConfig,
          fCheckDirtyOnly;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // warn the user that settings on this page will override imported connection settings
        if (InsGetBool(IS_CONNECTSET, IK_OPTION, FALSE, g_szInsFile))
            ErrorMessageBox(hDlg, IDS_CONNECTSET_WARN);

        DisableDBCSChars(hDlg, IDE_AUTOCONFIGTIME);

        EnableDBCSChars(hDlg, IDE_AUTOCONFIGURL);
        EnableDBCSChars(hDlg, IDE_AUTOPROXYURL);

        Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOCONFIGTIME), countof(szAutoConfigTime) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOCONFIGURL),  countof(szAutoConfigURL) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOPROXYURL),   countof(szAutoProxyURL) - 1);

        fDetectConfig = FALSE;
        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_AUTODETECT))) {
            fDetectConfig = InsGetBool(IS_URL, IK_DETECTCONFIG, TRUE, g_szInsFile);
            CheckDlgButton(hDlg, IDC_AUTODETECT, fDetectConfig  ? BST_CHECKED : BST_UNCHECKED);
        }

        fUseAutoConfig = InsGetBool(IS_URL, IK_USEAUTOCONF,  FALSE, g_szInsFile);
        CheckDlgButton(hDlg, IDC_YESAUTOCON, fUseAutoConfig ? BST_CHECKED : BST_UNCHECKED);

        
        GetPrivateProfileString(IS_URL, IK_AUTOCONFTIME, TEXT(""), szAutoConfigTime, countof(szAutoConfigTime), g_szInsFile);
        SetDlgItemText(hDlg, IDE_AUTOCONFIGTIME, szAutoConfigTime);
        EnableDlgItem2(hDlg, IDE_AUTOCONFIGTIME, fUseAutoConfig);
        EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT2, fUseAutoConfig);
        EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT3, fUseAutoConfig);

        GetPrivateProfileString(IS_URL, IK_AUTOCONFURL, TEXT(""), szAutoConfigURL, countof(szAutoConfigURL), g_szInsFile);
        SetDlgItemText(hDlg, IDE_AUTOCONFIGURL, szAutoConfigURL);
        EnableDlgItem2(hDlg, IDE_AUTOCONFIGURL, fUseAutoConfig);
        EnableDlgItem2(hDlg, IDC_AUTOCONFIGURL_TXT, fUseAutoConfig);

        GetPrivateProfileString(IS_URL, IK_AUTOCONFURLJS, TEXT(""), szAutoProxyURL, countof(szAutoProxyURL), g_szInsFile);
        SetDlgItemText(hDlg, IDE_AUTOPROXYURL, szAutoProxyURL);
        EnableDlgItem2(hDlg, IDE_AUTOPROXYURL, fUseAutoConfig);
        EnableDlgItem2(hDlg, IDC_AUTOPROXYURL_TXT, fUseAutoConfig);
        return TRUE;

    case UM_SAVE:
        fCheckDirtyOnly = (BOOL) lParam;

        fDetectConfig  = (IsDlgButtonChecked(hDlg, IDC_AUTODETECT) == BST_CHECKED);
        fUseAutoConfig = (IsDlgButtonChecked(hDlg, IDC_YESAUTOCON) == BST_CHECKED);

        GetDlgItemText(hDlg, IDE_AUTOCONFIGTIME, szAutoConfigTime, countof(szAutoConfigTime));
        GetDlgItemText(hDlg, IDE_AUTOCONFIGURL,  szAutoConfigURL,  countof(szAutoConfigURL));
        GetDlgItemText(hDlg, IDE_AUTOPROXYURL,   szAutoProxyURL,   countof(szAutoProxyURL));

        if (fCheckDirtyOnly) {
            TCHAR szTmp[MAX_URL];
            BOOL  fTemp;

            if (!g_fInsDirty) {
                fTemp = InsGetBool(IS_URL, IK_DETECTCONFIG, FALSE, g_szInsFile);
                g_fInsDirty = (fTemp != fDetectConfig);
            }

            if (!g_fInsDirty) {
                fTemp = InsGetBool(IS_URL, IK_USEAUTOCONF, FALSE, g_szInsFile);
                g_fInsDirty = (fTemp != fUseAutoConfig);
            }

            if (!g_fInsDirty) {
                GetPrivateProfileString(IS_URL, IK_AUTOCONFTIME, TEXT(""), szTmp, countof(szTmp), g_szInsFile);
                g_fInsDirty = (0 != StrCmpI(szTmp, szAutoConfigTime));
            }

            if (!g_fInsDirty) {
                GetPrivateProfileString(IS_URL, IK_AUTOCONFURL, TEXT(""), szTmp, countof(szTmp), g_szInsFile);
                g_fInsDirty = (0 != StrCmpI(szTmp, szAutoConfigURL));
            }

            if (!g_fInsDirty) {
                GetPrivateProfileString(IS_URL, IK_AUTOCONFURLJS, TEXT(""), szTmp, countof(szTmp), g_szInsFile);
                g_fInsDirty = (0 != StrCmpI(szTmp, szAutoProxyURL));
            }
        }
        else {
            // do error checking
            if (fUseAutoConfig) {
                if (IsWindowEnabled(GetDlgItem(hDlg, IDE_AUTOCONFIGTIME)) &&
                    !CheckField(hDlg, IDE_AUTOCONFIGTIME, FC_NUMBER))
                    return FALSE;

                if (*szAutoConfigURL == TEXT('\0') && *szAutoProxyURL == TEXT('\0')) {
                    ErrorMessageBox(hDlg, IDS_AUTOCONFIG_NULL);
                    SetFocus(GetDlgItem(hDlg, IDE_AUTOCONFIGURL));
                    return FALSE;
                }

                if (!CheckField(hDlg, IDE_AUTOCONFIGURL, FC_URL) ||
                    !CheckField(hDlg, IDE_AUTOPROXYURL,  FC_URL))
                    return FALSE;
            }

            // write the values to the INS file
            InsWriteBoolEx(IS_URL, IK_DETECTCONFIG,  fDetectConfig,    g_szInsFile);
            InsWriteBoolEx(IS_URL, IK_USEAUTOCONF,   fUseAutoConfig,   g_szInsFile);
            InsWriteString(IS_URL, IK_AUTOCONFTIME,  szAutoConfigTime, g_szInsFile);
            InsWriteString(IS_URL, IK_AUTOCONFURL,   szAutoConfigURL,  g_szInsFile);
            InsWriteString(IS_URL, IK_AUTOCONFURLJS, szAutoProxyURL,   g_szInsFile);
        }

        *((LPBOOL) wParam) = TRUE;
        return TRUE;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
            case BN_CLICKED:
                switch(LOWORD(wParam))
                {
                    case IDC_YESAUTOCON:
                        fUseAutoConfig = (IsDlgButtonChecked(hDlg, IDC_YESAUTOCON) == BST_CHECKED);

                        EnableDlgItem2(hDlg, IDE_AUTOCONFIGTIME, fUseAutoConfig);
                        EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT2, fUseAutoConfig);
                        EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT3, fUseAutoConfig);
                        EnableDlgItem2(hDlg, IDE_AUTOCONFIGURL, fUseAutoConfig);
                        EnableDlgItem2(hDlg, IDC_AUTOCONFIGURL_TXT, fUseAutoConfig);
                        EnableDlgItem2(hDlg, IDE_AUTOPROXYURL,  fUseAutoConfig);
                        EnableDlgItem2(hDlg, IDC_AUTOPROXYURL_TXT, fUseAutoConfig);
                        return TRUE;
                }
                break;
        }
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\wizard.h ===
#include "commctrl.h"
#include "wizard.rcv"

// menu commands

// icons

// ids

// constants
#define MAX_BUF		5000
#define MAX_LINE	512
#define MAX_URL	2048

typedef enum tagPPAGE
{
 PPAGE_WELCOME = 0,
 PPAGE_KEY,
 PPAGE_LANGUAGE, 
 PPAGE_MEDIA, 
 PPAGE_CUSTOMISK,
 PPAGE_ISKBACK,
 PPAGE_TITLE,
 PPAGE_CUSTICON,
 PPAGE_ANIMATION,
 PPAGE_STARTSEARCH,
 PPAGE_HELP,
 PPAGE_FAVORITES,
 PPAGE_QUERYSIGNUP,
 PPAGE_HTML,
 PPAGE_SERVLESSHTML,
 PPAGE_SERVLESS,
 PPAGE_SCRIPT,
 PPAGE_QUERYAUTOCONFIG,
 PPAGE_QUERYPROX,
 PPAGE_PROXY,
 PPAGE_INSTALLDIR,
 PPAGE_CUSTUSER,
 PPAGE_RESTRICT,
 PPAGE_SECURITY,
 PPAGE_CUSTCMD,
 PPAGE_OPTIONS,
 PPAGE_MAIL,
 PPAGE_LDAP,
 PPAGE_NEWS,
 PPAGE_SIG,
 PPAGE_ULS,
 PPAGE_NETMTG,
 PPAGE_NETMTGADV,
 PPAGE_CUSTOPTIONS,
 PPAGE_FINISH
 } ;

#define NUM_PAGES   PPAGE_FINISH + 1


// typedefs
typedef struct tagREVIEWINFO
{
    HINSTANCE hInst;        // current instance
	int iCustIcon;
	int iFavorites;
	int iReliability;
	int iGoals;
	int iAdaptation;
	char pszName[MAX_PATH];
	char pszTitle[MAX_PATH];
	char pszBitmap[MAX_PATH];
	char pszHomePage[MAX_URL];
	char pszSearchPage[MAX_URL];
	char pszDepartment[MAX_PATH];
	char pszBitmapPath[MAX_PATH];
	char pszBitmapName[MAX_PATH];
	char pszBitmap2Path[MAX_PATH];
	char pszBitmap2Name[MAX_PATH];

} REVIEWINFO;

// Function prototypes

// procs
long APIENTRY MainWndProc(HWND, UINT, UINT, LONG);
BOOL APIENTRY About(HWND, UINT, UINT, LONG);

// Pages for Wizard
BOOL APIENTRY CustIcon(HWND, UINT, UINT, LONG);
BOOL APIENTRY Favorites(HWND, UINT, UINT, LONG);
BOOL APIENTRY QueryProxy(HWND, UINT, UINT, LONG);
BOOL APIENTRY QueryAutoConfig(HWND, UINT, UINT, LONG);
BOOL APIENTRY ProxySettings(HWND, UINT, UINT, LONG);
BOOL APIENTRY Signature(HWND, UINT, UINT, LONG);
BOOL APIENTRY InstallDirectory(HWND, UINT, UINT, LONG);
BOOL APIENTRY CustUserSettings(HWND, UINT, UINT, LONG);
BOOL APIENTRY CustDirSettings(HWND, UINT, UINT, LONG);
BOOL APIENTRY Restrictions(HWND, UINT, UINT, LONG);
BOOL APIENTRY Security(HWND, UINT, UINT, LONG);
BOOL APIENTRY NetMeetingRestrict(HWND, UINT, UINT, LONG);
BOOL APIENTRY NetMeetingAdvanced(HWND, UINT, UINT, LONG);

//functions
BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE, int);
int CreateWizard(HWND, HINSTANCE);
void FillInPropertyPage( int , int, LPSTR, DLGPROC);
void GenerateReview(HWND);
void StatusDialog(UINT);

// definitions for StatusDialog( )
#define SD_STEP1    1
#define SD_STEP2    2
#define SD_STEP3    3
#define SD_STEP4    4
#define SD_STEP5    5
#define SD_DESTROY  6

typedef struct tagISKINFO
{
	char pszISKBackBitmap[MAX_PATH];
	char pszISKTitleBar[MAX_PATH];
    char pszISKBtnBitmap[MAX_PATH];
    DWORD dwNormalColor;
    DWORD dwHighlightColor;
    DWORD dwNIndex;
    DWORD dwHIndex;
    BOOL fCoolButtons;
} ISKINFO;

BOOL APIENTRY ISKBackBitmap(HWND, UINT, UINT, LONG);


#define SIGTYPE_TEXT 1
#define SIGTYPE_FILE 2


#define SIGFLAG_OUTGOING 0x10000
#define SIGFLAG_REPLY 0x20000


//#ifdef NTMAKEENV
//#define DLGFONT "MS Shell Dlg"
//#else
#define DLGFONT "MS Sans Serif"
//#endif

#define IDM_WIZARD WM_USER + 3000
#define IDM_LAST   WM_USER + 3001
#define IDM_EXIT   WM_USER + 3002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\btoolbar.cpp ===
#include "pch.h"

HRESULT BToolbarsFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState)
{
    TCHAR szBToolbarWork[MAX_PATH];

    PathCombine(szBToolbarWork, g_szWorkDir, TEXT("btoolbar.wrk"));
    
    if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && !PathIsEmptyPath(szBToolbarWork, FILES_ONLY))
        SetFlag(pdwCabState, CAB_TYPE_CONFIG);

    if (HasFlag(dwFlags, PM_COPY))
        CopyFileToDir(szBToolbarWork, pcszDestDir);
    
    if (HasFlag(dwFlags, PM_CLEAR))
        PathRemovePath(szBToolbarWork);
    return S_OK;
}

INT_PTR CALLBACK BToolbarProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szBToolbarWork[MAX_PATH];
    TCHAR szToolbarBmp[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    BOOL  fToolbarBmp;
    INT iBackground = 0;

    switch (message)
    {
    case WM_INITDIALOG:
        g_hDlg = hDlg;

        // --------- Toolbar background -----------------------------------------
        EnableDBCSChars(hDlg, IDE_TOOLBARBMP);
        Edit_LimitText(GetDlgItem(hDlg, IDE_TOOLBARBMP), countof(szToolbarBmp) - 1);
        
        // --------- Toolbar buttons --------------------------------------------
        EnableDBCSChars(hDlg, IDC_BTOOLBARLIST);
        
        // --------- Toolbar background -----------------------------------------
        // import INS clean-up -- delete bitmap from the temp location
        InsGetString(IS_BRANDING, TOOLBAR_BMP, szToolbarBmp, countof(szToolbarBmp), 
            g_szInsFile, NULL, &fToolbarBmp);
        if (fToolbarBmp)
            DeleteFileInDir(szToolbarBmp, g_szWorkDir);

        if (fToolbarBmp)
        {
            CheckRadioButton(hDlg, IDC_BGIE6, IDC_BG_CUSTOM, IDC_BG_CUSTOM);
        }
        else
        {
            CheckRadioButton(hDlg, IDC_BGIE6, IDC_BG_CUSTOM, IDC_BGIE6);
        }
        
        SetDlgItemTextTriState(hDlg, IDE_TOOLBARBMP, IDC_BG_CUSTOM, szToolbarBmp, fToolbarBmp);
        EnableDlgItem2(hDlg, IDE_TOOLBARBMP, fToolbarBmp);
        EnableDlgItem2(hDlg, IDC_BROWSETBB, fToolbarBmp);
        
        // --------- Toolbar buttons --------------------------------------------
        // import INS clean-up -- delete keys that are not relevant
        InsDeleteKey(IS_BTOOLBARS, IK_BTDELETE, g_szInsFile);

        PathCombine(szBToolbarWork, g_szWorkDir, TEXT("btoolbar.wrk"));
        PathCreatePath(szBToolbarWork);

        if (0 == BToolbar_Init(GetDlgItem(hDlg, IDC_BTOOLBARLIST), g_szInsFile, g_szWorkDir, szBToolbarWork))
        {
            EnsureDialogFocus(hDlg, IDC_REMOVEBTOOLBAR, IDC_ADDBTOOLBAR);
            EnsureDialogFocus(hDlg, IDC_EDITBTOOLBAR,   IDC_ADDBTOOLBAR);

            EnableWindow(GetDlgItem(hDlg, IDC_EDITBTOOLBAR),   FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_REMOVEBTOOLBAR),   FALSE);
        }
        else
            ListBox_SetCurSel(GetDlgItem(hDlg, IDC_BTOOLBARLIST), (WPARAM) 0);

        CheckDlgButton(hDlg, IDC_DELETEBTOOLBARS, 
            GetPrivateProfileInt(IS_BTOOLBARS, IK_BTDELETE, 0, g_szInsFile) ? BST_CHECKED : BST_UNCHECKED);

        break;

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDC_ADDBTOOLBAR:
                BToolbar_Edit(GetDlgItem(hDlg, IDC_BTOOLBARLIST), TRUE);
                SetFocus(GetDlgItem(hDlg, IDC_ADDBTOOLBAR));
                g_fInsDirty = TRUE;
                break;

            case IDC_REMOVEBTOOLBAR:
                BToolbar_Remove(GetDlgItem(hDlg, IDC_BTOOLBARLIST));
                g_fInsDirty = TRUE;
                break;

            case IDC_EDITBTOOLBAR:
                BToolbar_Edit(GetDlgItem(hDlg, IDC_BTOOLBARLIST), FALSE);
                SetFocus(GetDlgItem(hDlg, IDC_EDITBTOOLBAR));
                g_fInsDirty = TRUE;
                break;


            case IDC_BGIE6:
            case IDC_BG_CUSTOM:
                fToolbarBmp = (GET_WM_COMMAND_ID(wParam, lParam)==IDC_BG_CUSTOM);
                EnableDlgItem2(hDlg, IDE_TOOLBARBMP,     fToolbarBmp);
                EnableDlgItem2(hDlg, IDC_BROWSETBB,      fToolbarBmp);
                break;

            case IDC_BROWSETBB:
                GetDlgItemText(hDlg, IDE_TOOLBARBMP, szToolbarBmp, countof(szToolbarBmp));
                if (BrowseForFile(hDlg, szToolbarBmp, countof(szToolbarBmp), GFN_BMP))
                    SetDlgItemText(hDlg, IDE_TOOLBARBMP, szToolbarBmp);
                SetFocus(GetDlgItem(hDlg, IDC_BROWSETBB));
                break;

            default:
                return FALSE;
            }
            break;
        }
        break;

    case UM_SAVE:
        {
            BOOL fDeleteBToolbars;
            BOOL fCheckDirtyOnly = (BOOL) lParam;

            if (!fCheckDirtyOnly)
            {
                // --------- Toolbar background -----------------------------------------
                //----- Validate the path for a bitmap -----
                iBackground = IsDlgButtonChecked(hDlg, IDC_BGIE6) ? 0 : 2;

                fToolbarBmp = GetDlgItemTextTriState(hDlg, IDE_TOOLBARBMP, IDC_BG_CUSTOM, szToolbarBmp, countof(szToolbarBmp));
                if ((iBackground==2) &&  !IsBitmapFileValid(hDlg, IDE_TOOLBARBMP, szToolbarBmp, NULL, 0, 0, 0, 0))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                // toolbar bitmap

                // delete the old bitmap file
                if (InsGetString(IS_BRANDING, TOOLBAR_BMP, szTemp, countof(szTemp), g_szInsFile))
                    DeleteFileInDir(szTemp, g_szWorkDir);

                // copy the new bitmap file
                if (fToolbarBmp  &&  *szToolbarBmp)
                    CopyFileToDir(szToolbarBmp, g_szWorkDir);

                InsWriteString(IS_BRANDING, TOOLBAR_BMP, szToolbarBmp, g_szInsFile, fToolbarBmp, NULL, INSIO_TRISTATE);

                // --------- Toolbar buttons --------------------------------------------
                PathCombine(szBToolbarWork, g_szWorkDir, TEXT("btoolbar.wrk"));
                BToolbar_Save(GetDlgItem(hDlg, IDC_BTOOLBARLIST), g_szInsFile, szBToolbarWork, IEM_PROFMGR);
            }

            fDeleteBToolbars = (IsDlgButtonChecked(hDlg, IDC_DELETEBTOOLBARS) == BST_CHECKED);
            if (!g_fInsDirty)
            {
                BOOL fTemp;

                fTemp = (GetPrivateProfileInt(IS_BTOOLBARS, IK_BTDELETE, 0, g_szInsFile) != 0);
                if (fTemp != fDeleteBToolbars)
                    g_fInsDirty = TRUE;
            }

            WritePrivateProfileString(IS_BTOOLBARS, IK_BTDELETE, 
                fDeleteBToolbars ? TEXT("1") : NULL, g_szInsFile);

        }
        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\inc\wintreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       wintrust.h
//
//  Contents:   Microsoft Internet Security Trust Provider Model
//
//  History:    31-May-1997 pberkman   created
//
//--------------------------------------------------------------------------


#define WVT_OFFSETOF(t,f)   ((DWORD)(&((t*)0)->f))

#define WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(structtypedef, structpassedsize, member) \
                    (WVT_OFFSETOF(structtypedef, member) < structpassedsize) ? TRUE : FALSE


//
//  CTL Trusted CA Lists
//
#define szOID_TRUSTED_CODESIGNING_CA_LIST   "1.3.6.1.4.1.311.2.2.1"
#define szOID_TRUSTED_CLIENT_AUTH_CA_LIST   "1.3.6.1.4.1.311.2.2.2"
#define szOID_TRUSTED_SERVER_AUTH_CA_LIST   "1.3.6.1.4.1.311.2.2.3"

//
//  not used for encode/decode
//
#define SPC_COMMON_NAME_OBJID               szOID_COMMON_NAME
#define SPC_CERT_EXTENSIONS_OBJID           "1.3.6.1.4.1.311.2.1.14"
#define SPC_RAW_FILE_DATA_OBJID             "1.3.6.1.4.1.311.2.1.18"
#define SPC_STRUCTURED_STORAGE_DATA_OBJID   "1.3.6.1.4.1.311.2.1.19"
#define SPC_JAVA_CLASS_DATA_OBJID           "1.3.6.1.4.1.311.2.1.20"
#define SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.21"
#define SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.22"
#define SPC_CAB_DATA_OBJID                  "1.3.6.1.4.1.311.2.1.25"

//
//  encode/decode defines
//
#define SPC_SP_AGENCY_INFO_STRUCT           ((LPCSTR) 2000)
#define SPC_MINIMAL_CRITERIA_STRUCT         ((LPCSTR) 2001)
#define SPC_FINANCIAL_CRITERIA_STRUCT       ((LPCSTR) 2002)
#define SPC_INDIRECT_DATA_CONTENT_STRUCT    ((LPCSTR) 2003)
#define SPC_STATEMENT_TYPE_STRUCT           ((LPCSTR) 2006)
#define SPC_SP_OPUS_INFO_STRUCT             ((LPCSTR) 2007)

#define SPC_INDIRECT_DATA_OBJID             "1.3.6.1.4.1.311.2.1.4"
#define SPC_STATEMENT_TYPE_OBJID            "1.3.6.1.4.1.311.2.1.11"
#define SPC_SP_OPUS_INFO_OBJID              "1.3.6.1.4.1.311.2.1.12"
#define SPC_SP_AGENCY_INFO_OBJID            "1.3.6.1.4.1.311.2.1.10"
#define SPC_MINIMAL_CRITERIA_OBJID          "1.3.6.1.4.1.311.2.1.26"
#define SPC_FINANCIAL_CRITERIA_OBJID        "1.3.6.1.4.1.311.2.1.27"

#define SPC_TIME_STAMP_REQUEST_OBJID        "1.3.6.1.4.1.311.3.2.1"


//////////////////////////////////////////////////////////////////////////////
//
// Wintrust Policy Flags
//----------------------------------------------------------------------------
//  These are set during install and can be modified by the user
//  through various means.  The SETREG.EXE utility (found in the Authenticode
//  Tools Pack) will select/deselect each of them.
//
#define WTPF_TRUSTTEST              0x00000020  // trust any "TEST" generated certificate
#define WTPF_TESTCANBEVALID         0x00000080 
#define WTPF_IGNOREEXPIRATION       0x00000100  // Use expiration date
#define WTPF_IGNOREREVOKATION       0x00000200  // Do revocation check
#define WTPF_OFFLINEOK_IND          0x00000400  // off-line is ok for individual certs
#define WTPF_OFFLINEOK_COM          0x00000800  // off-line is ok for commercial certs
#define WTPF_OFFLINEOKNBU_IND       0x00001000  // off-line is ok for individual certs, no bad ui
#define WTPF_OFFLINEOKNBU_COM       0x00002000  // off-line is ok for commercial certs, no bad ui
#define WTPF_TIMESTAMP_IND          0x00004000  // Use timestamp for individual certs
#define WTPF_TIMESTAMP_COM          0x00008000  // Use timestamp for commerical certs
#define WTPF_VERIFY_V1_OFF          0x00010000  // turn verify of v1 certs off
#define WTPF_IGNOREREVOCATIONONTS   0x00020000  // ignore TimeStamp revocation checks
#define WTPF_ALLOWONLYPERTRUST      0x00040000  // allow only items in personal trust db.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\dlgprocs.cpp ===
#include "pch.h"

//_________________________________________________________________________
//
//                  D I A L O G  B O X  P R O C E D U R E S
//_________________________________________________________________________
//

void InitializeTitle(HWND hDlg, LPCTSTR szInsFile)
{
    SetDlgItemTextFromIns(hDlg, IDE_TITLE, IDC_TITLE, IS_BRANDING, TEXT("Window_Title_CN"), 
            szInsFile, NULL, INSIO_TRISTATE);
    EnableDlgItem2(hDlg, IDC_TITLE_TXT, (IsDlgButtonChecked(hDlg, IDC_TITLE) == BST_CHECKED));
}

BOOL SaveTitle(HWND hDlg, LPCTSTR szDefInf, LPCTSTR /*szInsFile*/, BOOL fCheckDirtyOnly)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szMsg[512];
    TCHAR szFullTitle[MAX_PATH];
    TCHAR szOEFullTitle[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    BOOL  fTitle, fTemp; 

    szFullTitle[0] = TEXT('\0');
    szOEFullTitle[0] = TEXT('\0');
    fTitle = GetDlgItemTextTriState(hDlg, IDE_TITLE, IDC_TITLE, szTitle,
                ARRAYSIZE(szTitle));
    if(fTitle && ISNONNULL(szTitle))
    {
        if(GetPrivateProfileString(TEXT("Strings"), TEXT("IE_TITLE"), TEXT(""), szMsg, ARRAYSIZE(szMsg), szDefInf))
            wsprintf(szFullTitle, szMsg, szTitle);

        // customize the OE title also
        if(GetPrivateProfileString(TEXT("Strings"), TEXT("OE_TITLE"), TEXT(""), szMsg, ARRAYSIZE(szMsg), szDefInf))
            wsprintf(szOEFullTitle, szMsg, szTitle);
    }

    if (!g_fInsDirty)
    {
        InsGetString(IS_BRANDING, TEXT("Window_Title_CN"), 
            szTemp, ARRAYSIZE(szTemp), g_szInsFile, NULL, &fTemp);
        if (fTitle != fTemp || StrCmp(szTemp, szTitle) != 0)
            g_fInsDirty = TRUE;

        InsGetString(IS_BRANDING, IK_WINDOWTITLE, 
                    szTemp, ARRAYSIZE(szTemp), g_szInsFile);
        if (StrCmp(szTemp, szFullTitle) != 0)
            g_fInsDirty = TRUE;
    }

    if (!fCheckDirtyOnly)
    {
        InsWriteString(IS_BRANDING, TEXT("Window_Title_CN"), szTitle, g_szInsFile, 
                        fTitle, NULL, INSIO_SERVERONLY | INSIO_TRISTATE);
        InsWriteString(IS_BRANDING, IK_WINDOWTITLE, szFullTitle, g_szInsFile, 
                        fTitle, NULL, INSIO_TRISTATE);
    
        // save the customized OE title
        InsWriteString(IS_INTERNETMAIL, IK_WINDOWTITLE, szOEFullTitle, g_szInsFile, 
                        fTitle, NULL, INSIO_TRISTATE);
    }
    return TRUE;
}

INT_PTR CALLBACK TitleProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    TCHAR szTitle[MAX_PATH];
    DWORD dwTitlePrefixLen;

    switch( msg )
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_TITLE);
        LoadString(g_hInst, IDS_TITLE_PREFIX, szTitle, ARRAYSIZE(szTitle));
        dwTitlePrefixLen = StrLen(szTitle);

        // browser will only display 74 chars before cutting off title
        Edit_LimitText(GetDlgItem(hDlg, IDE_TITLE), 74 - dwTitlePrefixLen);

        // load information from ins file
        InitializeTitle(hDlg, g_szInsFile);
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_TITLE:
                EnableDlgItem2(hDlg, IDE_TITLE, (IsDlgButtonChecked(hDlg, IDC_TITLE) == BST_CHECKED));
                EnableDlgItem2(hDlg, IDC_TITLE_TXT, (IsDlgButtonChecked(hDlg, IDC_TITLE) == BST_CHECKED));
                break;

            default:
                return FALSE;
        }
        break;

    case UM_SAVE:
        // write the information back to the ins file
        *((LPBOOL)wParam) = SaveTitle(hDlg, g_szDefInf, g_szInsFile, (BOOL) lParam);
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        return FALSE;

    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK CabSignProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    TCHAR szDesc[MAX_PATH];
    TCHAR szPVKPath[MAX_PATH];
    TCHAR szSPCPath[MAX_PATH];
    TCHAR szInfoUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szTimeUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szTemp[INTERNET_MAX_URL_LENGTH];

    switch( msg )
    {
    case WM_INITDIALOG:
        // not needed for profile manager

        DisableDlgItem(hDlg, IDC_CSADD);

        EnableDBCSChars(hDlg, IDE_CSPVK);
        EnableDBCSChars(hDlg, IDE_CSSPC);
        EnableDBCSChars(hDlg, IDE_CSURL);
        EnableDBCSChars(hDlg, IDE_CSDESC);
        EnableDBCSChars(hDlg, IDE_CSTIME);
        
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSSPC),  countof(szSPCPath) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSPVK),  countof(szPVKPath) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSDESC), countof(szDesc)    - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSURL),  countof(szInfoUrl) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSTIME),  countof(szTimeUrl) - 1);
        
        InsGetString(IS_CABSIGN, IK_PVK, szPVKPath, countof(szPVKPath), g_szInsFile);
        InsGetString(IS_CABSIGN, IK_SPC, szSPCPath, countof(szSPCPath), g_szInsFile);
        InsGetString(IS_CABSIGN, IK_CSURL, szInfoUrl, countof(szInfoUrl), g_szInsFile);
        InsGetString(IS_CABSIGN, IK_NAME, szDesc, countof(szDesc), g_szInsFile);
        InsGetString(IS_CABSIGN, IK_CSTIME, szTimeUrl, countof(szTimeUrl), g_szInsFile);
        
        SetDlgItemText(hDlg, IDE_CSPVK, szPVKPath);
        SetDlgItemText(hDlg, IDE_CSSPC, szSPCPath);
        SetDlgItemText(hDlg, IDE_CSURL, szInfoUrl);
        SetDlgItemText(hDlg, IDE_CSDESC, szDesc);
        SetDlgItemText(hDlg, IDE_CSTIME, szTimeUrl);
        DisableDlgItem(hDlg, IDC_CSCOMP);
        DisableDlgItem(hDlg, IDC_CSCOMP_TXT);
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == BN_CLICKED) 
        {
            switch(LOWORD(wParam))
            {
            case IDC_BROWSECSPVK:
                GetDlgItemText( hDlg, IDE_CSPVK, szPVKPath, ARRAYSIZE(szPVKPath));
                if( BrowseForFile( hDlg, szPVKPath, ARRAYSIZE(szPVKPath), GFN_PVK ))
                    SetDlgItemText( hDlg, IDE_CSPVK, szPVKPath );
                SetFocus(GetDlgItem(hDlg, IDC_BROWSECSPVK));
                break;
            case IDC_BROWSECSSPC:
                GetDlgItemText( hDlg, IDE_CSSPC, szSPCPath, ARRAYSIZE(szSPCPath));
                if( BrowseForFile( hDlg, szSPCPath, ARRAYSIZE(szSPCPath), GFN_SPC ))
                    SetDlgItemText( hDlg, IDE_CSSPC, szSPCPath );
                SetFocus(GetDlgItem(hDlg, IDC_BROWSECSSPC));
                break;
            }
        }
        break;

    case UM_SAVE:
        // write the information back to the ins file
        {
            BOOL fDirty = FALSE;
            BOOL fCheckDirtyOnly = (BOOL) lParam;

            GetDlgItemText(hDlg, IDE_CSPVK, szPVKPath, countof(szPVKPath));
            GetDlgItemText(hDlg, IDE_CSSPC, szSPCPath, countof(szSPCPath));
            GetDlgItemText(hDlg, IDE_CSURL, szInfoUrl, countof(szInfoUrl));
            GetDlgItemText(hDlg, IDE_CSDESC, szDesc, countof(szDesc));
            GetDlgItemText(hDlg, IDE_CSTIME, szTimeUrl, countof(szTimeUrl));

            InsGetString(IS_CABSIGN, IK_PVK, szTemp, ARRAYSIZE(szTemp), g_szInsFile);
            if (StrCmp(szTemp, szPVKPath) != 0)
                fDirty = TRUE;
            InsGetString(IS_CABSIGN, IK_SPC, szTemp, ARRAYSIZE(szTemp), g_szInsFile);
            if (StrCmp(szTemp, szSPCPath) != 0)
                fDirty = TRUE;
            InsGetString(IS_CABSIGN, IK_CSURL, szTemp, ARRAYSIZE(szTemp), g_szInsFile);
            if (StrCmp(szTemp, szInfoUrl) != 0)
                fDirty = TRUE;
            InsGetString(IS_CABSIGN, IK_NAME, szTemp, ARRAYSIZE(szTemp), g_szInsFile);
            if (StrCmp(szTemp, szDesc) != 0)
                fDirty = TRUE;
            InsGetString(IS_CABSIGN, IK_CSTIME, szTemp, ARRAYSIZE(szTemp), g_szInsFile);
            if (StrCmp(szTemp, szTimeUrl) != 0)
                fDirty = TRUE;

            if (!fCheckDirtyOnly)
            {
                if (ISNONNULL(szPVKPath) || ISNONNULL(szSPCPath)
                    || ISNONNULL(szInfoUrl) || ISNONNULL(szDesc) || ISNONNULL(szTimeUrl))
                {
                    if (!CheckField(hDlg, IDE_CSPVK, FC_NONNULL | FC_FILE | FC_EXISTS) ||
                        !CheckField(hDlg, IDE_CSSPC, FC_NONNULL | FC_FILE | FC_EXISTS) ||
                        !CheckField(hDlg, IDE_CSDESC, FC_NONNULL) || 
                        !CheckField(hDlg, IDE_CSURL, FC_URL) || !CheckField(hDlg, IDE_CSTIME, FC_URL))
                    {
                        return TRUE;
                    }
                }

                InsWriteString(IS_CABSIGN, IK_PVK, szPVKPath, g_szInsFile);
                InsWriteString(IS_CABSIGN, IK_SPC, szSPCPath, g_szInsFile);
                InsWriteString(IS_CABSIGN, IK_CSURL, szInfoUrl, g_szInsFile);
                InsWriteString(IS_CABSIGN, IK_NAME, szDesc, g_szInsFile);
                InsWriteString(IS_CABSIGN, IK_CSTIME, szTimeUrl, g_szInsFile);
            }

            if (fDirty)
                g_fInsDirty = TRUE;
        }
        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        return FALSE;

    default:
        return FALSE;
    }
    return TRUE;
}

void SaveUserAgent(HWND hDlg, LPCTSTR szInsFile, BOOL fCheckDirtyOnly)
{
    TCHAR szUserAgent[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    BOOL fUserAgent;

    fUserAgent = GetDlgItemTextTriState(hDlg, IDC_UASTRING, IDC_UASTRINGCHECK, szUserAgent,
                        countof(szUserAgent));
    if (!g_fInsDirty)
    {
        BOOL fTemp;
        
        InsGetString(IS_BRANDING, USER_AGENT, szTemp, ARRAYSIZE(szTemp), szInsFile, NULL, &fTemp);
        if (fUserAgent != fTemp || StrCmp(szTemp, szUserAgent) != 0)
            g_fInsDirty = TRUE;
    }

    if (!fCheckDirtyOnly)
        InsWriteString(IS_BRANDING, USER_AGENT, szUserAgent, szInsFile, 
            fUserAgent, NULL, INSIO_TRISTATE);
}

INT_PTR CALLBACK UserAgentProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch( msg )
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDC_UASTRING);
        Edit_LimitText(GetDlgItem(hDlg, IDC_UASTRING), MAX_PATH - 1);
        // load information from ins file
        SetDlgItemTextFromIns(hDlg, IDC_UASTRING, IDC_UASTRINGCHECK, IS_BRANDING, 
            USER_AGENT, g_szInsFile, NULL, INSIO_TRISTATE);
        EnableDlgItem2(hDlg, IDC_UASTRING_TXT, (IsDlgButtonChecked(hDlg, IDC_UASTRINGCHECK) == BST_CHECKED));
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;
        
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_UASTRINGCHECK:
                EnableDlgItem2(hDlg, IDC_UASTRING, (IsDlgButtonChecked(hDlg, IDC_UASTRINGCHECK) == BST_CHECKED));
                EnableDlgItem2(hDlg, IDC_UASTRING_TXT, (IsDlgButtonChecked(hDlg, IDC_UASTRINGCHECK) == BST_CHECKED));
                break;
            
            default:
                return FALSE;
        }
        break;
    case UM_SAVE:
        // write the information back to the ins file
        SaveUserAgent(hDlg, g_szInsFile, (BOOL) lParam);
        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        return FALSE;

    default:
        return FALSE;
    }
    return TRUE;
}

void InitializeAnimBmps(HWND hDlg, LPCTSTR szInsFile)
{
    TCHAR szBig[MAX_PATH];
    TCHAR szSmall[MAX_PATH];
    BOOL fBrandBmps;

    // load information from ins file
    InsGetString(IS_ANIMATION, TEXT("Big_Path"), 
        szBig, ARRAYSIZE(szBig), szInsFile, NULL, &fBrandBmps);
    SetDlgItemTextTriState(hDlg, IDE_BIGANIMBITMAP, IDC_ANIMBITMAP, szBig, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_BROWSEBIG, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_BIGANIMBITMAP_TXT, fBrandBmps);
    
    InsGetString(IS_ANIMATION, TEXT("Small_Path"), 
        szSmall, ARRAYSIZE(szSmall), szInsFile, NULL, &fBrandBmps);
    SetDlgItemTextTriState(hDlg, IDE_SMALLANIMBITMAP, IDC_ANIMBITMAP, szSmall, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_BROWSESMALL, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_SMALLANIMBITMAP_TXT, fBrandBmps);
}

BOOL SaveAnimBmps(HWND hDlg, LPCTSTR szInsFile, BOOL fCheckDirtyOnly)
{
    TCHAR szBig[MAX_PATH];
    TCHAR szSmall[MAX_PATH];
    TCHAR szBigTemp[MAX_PATH];
    TCHAR szSmallTemp[MAX_PATH];
    BOOL fBmpDirty = FALSE;
    BOOL fBrandBmps, fTemp;

    fBrandBmps = (IsDlgButtonChecked(hDlg, IDC_ANIMBITMAP) == BST_CHECKED);
    
    GetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szBig, countof(szBig));
    InsGetString(IS_ANIMATION, TEXT("Big_Path"), szBigTemp, ARRAYSIZE(szBigTemp), szInsFile, 
        NULL, &fTemp);

    GetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmall, countof(szSmall));
    InsGetString(IS_ANIMATION, TEXT("Small_Path"), szSmallTemp, ARRAYSIZE(szSmallTemp), szInsFile);

    if (fCheckDirtyOnly)
    {
        if(fBrandBmps != fTemp || StrCmpI(szBig, szBigTemp) != 0 || StrCmpI(szSmall, szSmallTemp) != 0)
            fBmpDirty = TRUE;
    }
    else
    {
        if(fBrandBmps != fTemp || StrCmpI(szBig, szBigTemp) != 0)
        {
            if(fBrandBmps && !IsAnimBitmapFileValid(hDlg, IDE_BIGANIMBITMAP, szBig, NULL, IDS_TOOBIG38, IDS_TOOSMALL38, 30, 45))
                return FALSE;
            fBmpDirty = TRUE;
        }

        CopyAnimBmp(hDlg, szBig, g_szWorkDir, IK_LARGEBITMAP, TEXT("Big_Path"), szInsFile);

        if(fBrandBmps != fTemp || StrCmpI(szSmall, szSmallTemp) != 0)
        {
            if(fBrandBmps && !IsAnimBitmapFileValid(hDlg, IDE_SMALLANIMBITMAP, szSmall, NULL, IDS_TOOBIG22, IDS_TOOSMALL22, 0, 30))
                return FALSE;
            fBmpDirty = TRUE;
        }

        CopyAnimBmp(hDlg, szSmall, g_szWorkDir, IK_SMALLBITMAP, TEXT("Small_Path"), szInsFile);

        if ((fBrandBmps && ISNULL(szSmall) && ISNONNULL(szBig)) || (fBrandBmps && ISNONNULL(szSmall) && ISNULL(szBig)))
        {
            ErrorMessageBox(hDlg, IDS_BOTHBMP_ERROR);
            if (ISNULL(szSmall))
                SetFocus(GetDlgItem(hDlg, IDE_SMALLANIMBITMAP));
            else
                SetFocus(GetDlgItem(hDlg, IDE_BIGANIMBITMAP));
            return FALSE;
        }

        InsWriteBool(IS_ANIMATION, IK_DOANIMATION, fBrandBmps, szInsFile);
        WritePrivateProfileString(NULL, NULL, NULL, szInsFile);
    }

    if (fBmpDirty)
        g_fInsDirty = TRUE;

    return TRUE;
}

void DisplayBitmap(HWND hControl, LPCTSTR pcszFileName, int nBitmapId)
{
    HANDLE hBmp = (HANDLE) GetWindowLongPtr(hControl, GWLP_USERDATA);
    
    if(ISNONNULL(pcszFileName) && PathFileExists(pcszFileName))
        ShowBitmap(hControl, pcszFileName, 0, &hBmp);
    else
        ShowBitmap(hControl, TEXT(""), nBitmapId, &hBmp);

    SetWindowLongPtr(hControl, GWLP_USERDATA, (LONG_PTR)hBmp);
}

void ReleaseBitmap(HWND hControl)
{
    HANDLE hBmp = (HANDLE) GetWindowLongPtr(hControl, GWLP_USERDATA);

    if (hBmp)
        DeleteObject(hBmp);
}

INT_PTR CALLBACK LogoProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    TCHAR szBig[MAX_PATH];
    TCHAR szSmall[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    BOOL fBrandBmps, fBrandAnim;

    switch( msg )
    {
    case WM_INITDIALOG:
        //from old animbmp
        EnableDBCSChars(hDlg, IDE_SMALLANIMBITMAP);
        EnableDBCSChars(hDlg, IDE_BIGANIMBITMAP);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SMALLANIMBITMAP), countof(szSmall) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BIGANIMBITMAP), countof(szBig) - 1);
        // load information from ins file
        InitializeAnimBmps(hDlg, g_szInsFile);

        //from old logo
        EnableDBCSChars(hDlg, IDC_BITMAP);
        EnableDBCSChars(hDlg, IDC_BITMAP2);
        Edit_LimitText(GetDlgItem(hDlg, IDC_BITMAP), countof(szBig) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDC_BITMAP2), countof(szSmall) - 1);
        // load information from ins file
        InsGetString(IS_SMALLLOGO, TEXT("Path"), 
            szSmall, ARRAYSIZE(szSmall), g_szInsFile, NULL, &fBrandBmps);
        SetDlgItemTextTriState(hDlg, IDC_BITMAP2, IDC_BITMAPCHECK, szSmall, fBrandBmps);
        EnableDlgItem2(hDlg, IDC_BROWSEICON2, fBrandBmps);
        EnableDlgItem2(hDlg, IDC_SMALLBITMAP_TXT, fBrandBmps);
                
        if (ISNONNULL(szSmall))
        {
            if(!PathFileExists(szSmall))
            {
                PathCombine(szTemp, g_szWorkDir, PathFindFileName(szSmall));
                StrCpy(szSmall, szTemp);
            }
        }
        
        InsGetString(IS_LARGELOGO, TEXT("Path"), 
                    szBig, ARRAYSIZE(szBig), g_szInsFile, NULL, &fBrandBmps);
        SetDlgItemTextTriState(hDlg, IDC_BITMAP, IDC_BITMAPCHECK, szBig, fBrandBmps);
        EnableDlgItem2(hDlg, IDC_BROWSEICON, fBrandBmps);
        EnableDlgItem2(hDlg, IDC_LARGEBITMAP_TXT, fBrandBmps);

        if(ISNONNULL(szBig))
        {
            if(!PathFileExists( szBig ))
            {
                PathCombine(szTemp, g_szWorkDir, PathFindFileName(szBig));
                StrCpy(szBig, szTemp);
            }
        }

        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_BROWSEBIG:
                GetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szBig, countof(szBig));
                if(BrowseForFile(hDlg, szBig, countof(szBig), GFN_BMP))
                    SetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szBig);
                SetFocus(GetDlgItem(hDlg, IDC_BROWSEBIG));
                break;
            
            case IDC_BROWSESMALL:
                GetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmall, countof(szSmall));
                if(BrowseForFile(hDlg, szSmall, countof(szSmall), GFN_BMP))
                    SetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmall);
                SetFocus(GetDlgItem(hDlg, IDC_BROWSESMALL));
                break;
            
            case IDC_ANIMBITMAP:
                fBrandAnim = (IsDlgButtonChecked(hDlg, IDC_ANIMBITMAP) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_BIGANIMBITMAP, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BROWSEBIG, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BIGANIMBITMAP_TXT, fBrandAnim);
                EnableDlgItem2(hDlg, IDE_SMALLANIMBITMAP, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BROWSESMALL, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_SMALLANIMBITMAP_TXT, fBrandAnim);
                break;

            case IDC_BROWSEICON:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    GetDlgItemText(hDlg, IDC_BITMAP, szBig, countof(szBig));
                    if(BrowseForFile(hDlg, szBig, countof(szBig), GFN_BMP))
                        SetDlgItemText(hDlg, IDC_BITMAP, szBig);
                    SetFocus(GetDlgItem(hDlg, IDC_BROWSEICON));
                    break;
                }
                return FALSE;
            
            case IDC_BROWSEICON2:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    GetDlgItemText(hDlg, IDC_BITMAP2, szSmall, countof(szSmall));
                    if(BrowseForFile(hDlg, szSmall, countof(szSmall), GFN_BMP))
                        SetDlgItemText(hDlg, IDC_BITMAP2, szSmall);
                    SetFocus(GetDlgItem(hDlg, IDC_BROWSEICON2));
                    break;
                }
                return FALSE;
            
            case IDC_BITMAPCHECK:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    fBrandBmps = (IsDlgButtonChecked(hDlg, IDC_BITMAPCHECK) == BST_CHECKED);
                    EnableDlgItem2(hDlg, IDC_BITMAP, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_BITMAP2, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_BROWSEICON2, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_BROWSEICON, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_SMALLBITMAP_TXT, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_LARGEBITMAP_TXT, fBrandBmps);
                    break;
                }
                return FALSE;
                
            default:
                return FALSE;
        }
        break;

    case UM_SAVE:
        // write the information back to the ins file
        {
            *((LPBOOL)wParam) = SaveAnimBmps(hDlg, g_szInsFile, (BOOL) lParam);
        
            TCHAR szSmallTemp[MAX_PATH];
            TCHAR szBigTemp[MAX_PATH];
            BOOL fBmpDirty = FALSE;
            BOOL fCheckDirtyOnly = (BOOL) lParam;
            BOOL fTemp;

            fBrandBmps = (IsDlgButtonChecked(hDlg, IDC_BITMAPCHECK) == BST_CHECKED);

            GetDlgItemText(hDlg, IDC_BITMAP2, szSmall, countof(szSmall));
            InsGetString(IS_SMALLLOGO, TEXT("Path"), szSmallTemp, ARRAYSIZE(szSmallTemp), 
                g_szInsFile, NULL, &fTemp);

            GetDlgItemText(hDlg, IDC_BITMAP, szBig, countof(szBig));
            InsGetString(IS_LARGELOGO, TEXT("Path"), szBigTemp, ARRAYSIZE(szBigTemp), g_szInsFile);

            if (fCheckDirtyOnly)
            {
                if(fBrandBmps != fTemp || StrCmpI(szSmall, szSmallTemp) != 0 || StrCmpI(szBig, szBigTemp) != 0)
                    fBmpDirty = TRUE;
            }
            else
            {
                if(fBrandBmps != fTemp || StrCmpI(szSmall, szSmallTemp) != 0)
                {
                    if (fBrandBmps && !IsBitmapFileValid(hDlg, IDC_BITMAP2, szSmall, NULL, 22, 22, IDS_TOOBIG22, IDS_TOOSMALL22))
                        return FALSE;
                    fBmpDirty = TRUE;
                }

                CopyLogoBmp(hDlg, szSmall, IS_SMALLLOGO, g_szWorkDir, g_szInsFile);

                if(fBrandBmps != fTemp || StrCmpI(szBig, szBigTemp) != 0)
                {
                    if (fBrandBmps && !IsBitmapFileValid(hDlg, IDC_BITMAP, szBig, NULL, 38, 38, IDS_TOOBIG38, IDS_TOOSMALL38))
                        return FALSE;
                    fBmpDirty = TRUE;
                }

                CopyLogoBmp(hDlg, szBig, IS_LARGELOGO, g_szWorkDir, g_szInsFile);

                if ((fBrandBmps && ISNULL(szSmall) && ISNONNULL(szBig)) || (fBrandBmps && ISNONNULL(szSmall) && ISNULL(szBig)))
                {
                    ErrorMessageBox(hDlg, IDS_BOTHBMP_ERROR);
                    if (ISNULL(szSmall))
                        SetFocus(GetDlgItem(hDlg, IDC_BITMAP2));
                    else
                        SetFocus(GetDlgItem(hDlg, IDC_BITMAP));
                    return FALSE;
                }

                WritePrivateProfileString(NULL, NULL, NULL, g_szInsFile);
            }
            
            if (fBmpDirty)
                g_fInsDirty = TRUE;
        }
        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:        
        DestroyWindow(hDlg);
        return FALSE;

    default:
        return FALSE;
    }
    return TRUE;
}

void EnableProxyControls( HWND hDlg, BOOL fSame, BOOL fUseProxy )
{
    EnableDlgItem2(hDlg, IDE_FTPPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_FTPPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_FTPPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SECPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SECPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_SECPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_GOPHERPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_GOPHERPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_GOPHERPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SOCKSPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SOCKSPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_SOCKSPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_HTTPPROXY, fUseProxy);
    EnableDlgItem2(hDlg, IDE_HTTPPORT, fUseProxy);
    EnableDlgItem2(hDlg, IDC_HTTPPROXY1, fUseProxy);
    EnableDlgItem2(hDlg, IDC_SAMEFORALL, fUseProxy);
    EnableDlgItem2(hDlg, IDE_DISPROXYADR, fUseProxy);
    EnableDlgItem2(hDlg, IDC_DISPROXYADR1, fUseProxy);
    EnableDlgItem2(hDlg, IDC_DISPROXYLOCAL, fUseProxy);
}

void InitializeProxy(HWND hDlg, LPCTSTR szInsFile)
{
    BOOL fUseProxy;
    BOOL fSameProxy;
    BOOL fLocal;
    LPTSTR pLocal;
    TCHAR szProxy[MAX_PATH];
    TCHAR szProxyOverride[MAX_STRING];

    fUseProxy = InsGetBool(IS_PROXY, IK_PROXYENABLE, FALSE, szInsFile);
    CheckDlgButton( hDlg, IDC_YESPROXY, fUseProxy );

    fSameProxy = InsGetBool(IS_PROXY, IK_SAMEPROXY, TRUE, szInsFile);
    CheckDlgButton( hDlg, IDC_SAMEFORALL, fSameProxy );

    GetPrivateProfileString( TEXT("Proxy"), TEXT("HTTP_Proxy_Server"), TEXT(""), szProxy,
        ARRAYSIZE(szProxy), szInsFile );
    if( fSameProxy )
    {
        SetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
    }
    else
    {
        SetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT, TRUE );
        GetPrivateProfileString( TEXT("Proxy"), TEXT("FTP_Proxy_Server"), TEXT(""), szProxy, ARRAYSIZE(szProxy), szInsFile );
        SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
        GetPrivateProfileString( TEXT("Proxy"), TEXT("Gopher_Proxy_Server"), TEXT(""), szProxy, ARRAYSIZE(szProxy), szInsFile );
        SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
        GetPrivateProfileString( TEXT("Proxy"), TEXT("Secure_Proxy_Server"), TEXT(""), szProxy, ARRAYSIZE(szProxy), szInsFile );
        SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
        GetPrivateProfileString( TEXT("Proxy"), TEXT("Socks_Proxy_Server"), TEXT(""), szProxy, ARRAYSIZE(szProxy), szInsFile );
        if( *szProxy != 0 )
            SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
    }

    GetPrivateProfileString( TEXT("Proxy"), TEXT("Proxy_Override"), TEXT("<local>"), szProxyOverride,
        ARRAYSIZE( szProxyOverride ), szInsFile );

    pLocal = StrStr(szProxyOverride, TEXT("<local>"));
    if(pLocal)
    {
        if (pLocal == (LPTSTR) szProxyOverride)         // at the beginning
        {
            LPTSTR pSemi = pLocal + 7;
            if( *pSemi == TEXT(';') ) pSemi++;
            MoveMemory(pLocal, pSemi, StrCbFromSz(pSemi));
        }
        else if (*(pLocal + 7) == TEXT('\0'))   // at the end
            *(pLocal - 1) = TEXT('\0');
        fLocal = TRUE;
    }
    else
        fLocal = FALSE;
    CheckDlgButton( hDlg, IDC_DISPROXYLOCAL, fLocal );
    SetDlgItemText( hDlg, IDE_DISPROXYADR, szProxyOverride );
    EnableProxyControls( hDlg, fSameProxy, fUseProxy );
}

BOOL SaveProxy(HWND hDlg, LPCTSTR szInsFile, BOOL fCheckDirtyOnly)
{
    BOOL fUseProxy;
    BOOL fSameProxy;
    BOOL fLocal;
    TCHAR szProxy[MAX_PATH];
    BOOL fTemp;
    TCHAR szTemp[MAX_STRING];
    TCHAR szProxyOverride[MAX_STRING];

    if (!fCheckDirtyOnly &&
        (!CheckField(hDlg, IDE_HTTPPORT, FC_NUMBER)   || 
         !CheckField(hDlg, IDE_FTPPORT, FC_NUMBER)    ||
         !CheckField(hDlg, IDE_GOPHERPORT, FC_NUMBER) ||
         !CheckField(hDlg, IDE_SECPORT, FC_NUMBER)    ||
         !CheckField(hDlg, IDE_SOCKSPORT, FC_NUMBER)))
        return FALSE;

    
    fSameProxy = IsDlgButtonChecked( hDlg, IDC_SAMEFORALL );
    fUseProxy = IsDlgButtonChecked( hDlg, IDC_YESPROXY );
    fLocal = IsDlgButtonChecked( hDlg, IDC_DISPROXYLOCAL );
    
    GetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT );
    if (!g_fInsDirty)
    {
        GetPrivateProfileString( TEXT("Proxy"), TEXT("HTTP_Proxy_Server"), TEXT(""), szTemp, ARRAYSIZE(szTemp), szInsFile );
        if (StrCmp(szTemp, szProxy) != 0)
            g_fInsDirty = TRUE;
    }
    if (!fCheckDirtyOnly)
        WritePrivateProfileString( TEXT("Proxy"), TEXT("HTTP_Proxy_Server"), szProxy, szInsFile );

    GetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT );
    if (!g_fInsDirty)
    {
        GetPrivateProfileString( TEXT("Proxy"), TEXT("FTP_Proxy_Server"), TEXT(""), szTemp, ARRAYSIZE(szTemp), szInsFile );
        if (StrCmp(szTemp, szProxy) != 0)
            g_fInsDirty = TRUE;
    }
    if (!fCheckDirtyOnly)
        WritePrivateProfileString( TEXT("Proxy"), TEXT("FTP_Proxy_Server"), szProxy, szInsFile );

    GetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT );
    if (!g_fInsDirty)
    {
        GetPrivateProfileString( TEXT("Proxy"), TEXT("Gopher_Proxy_Server"), TEXT(""), szTemp, ARRAYSIZE(szTemp), szInsFile );
        if (StrCmp(szTemp, szProxy) != 0)
            g_fInsDirty = TRUE;
    }
    if (!fCheckDirtyOnly)
        WritePrivateProfileString( TEXT("Proxy"), TEXT("Gopher_Proxy_Server"), szProxy, szInsFile );

    GetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT );
    if (!g_fInsDirty)
    {
        GetPrivateProfileString( TEXT("Proxy"), TEXT("Secure_Proxy_Server"), TEXT(""), szTemp, ARRAYSIZE(szTemp), szInsFile );
        if (StrCmp(szTemp, szProxy) != 0)
            g_fInsDirty = TRUE;
    }
    if (!fCheckDirtyOnly)
        WritePrivateProfileString( TEXT("Proxy"), TEXT("Secure_Proxy_Server"), szProxy, szInsFile );

    GetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT );
    if (!g_fInsDirty)
    {
        GetPrivateProfileString( TEXT("Proxy"), TEXT("Socks_Proxy_Server"), TEXT(""), szTemp, ARRAYSIZE(szTemp), szInsFile );
        if (StrCmp(szTemp, szProxy) != 0)
            g_fInsDirty = TRUE;
    }
    if (!fCheckDirtyOnly)
        WritePrivateProfileString( TEXT("Proxy"), TEXT("Socks_Proxy_Server"), szProxy, szInsFile );

    if (!g_fInsDirty)
    {
        fTemp = (BOOL) GetPrivateProfileInt( TEXT("Proxy"), TEXT("Use_Same_Proxy"), 0, szInsFile );
        if (fTemp != fSameProxy)
            g_fInsDirty = TRUE;
    }
    if (!fCheckDirtyOnly)
        WritePrivateProfileString( TEXT("Proxy"), TEXT("Use_Same_Proxy"), fSameProxy ? TEXT("1") : TEXT("0"), szInsFile );

    if (!g_fInsDirty)
    {
        fTemp = (BOOL) GetPrivateProfileInt( TEXT("Proxy"), TEXT("Proxy_Enable"), 0, szInsFile );
        if (fTemp != fUseProxy)
            g_fInsDirty = TRUE;
    }
    if (!fCheckDirtyOnly)
        WritePrivateProfileString( TEXT("Proxy"), TEXT("Proxy_Enable"), fUseProxy ? TEXT("1") : TEXT("0"), szInsFile );

    GetDlgItemText( hDlg, IDE_DISPROXYADR, szProxyOverride, countof(szProxyOverride) - 10 ); // 8 for ;<local> + 2 for ""
    GetPrivateProfileString( TEXT("Proxy"), TEXT("Proxy_Override"), TEXT(""), szTemp, ARRAYSIZE(szTemp), szInsFile );
    if( fLocal )
    {
        if( *szProxyOverride != 0 )
        {
            TCHAR szPort[MAX_STRING];

            StrRemoveAllWhiteSpace(szProxyOverride);
            wsprintf( szPort, TEXT("%s;<local>"), szProxyOverride );
            if (!g_fInsDirty)
            {
                if (StrCmp(szTemp, szPort) != 0)
                    g_fInsDirty = TRUE;
            }
            if (!fCheckDirtyOnly)
                InsWriteQuotedString( TEXT("Proxy"), TEXT("Proxy_Override"), szPort, szInsFile );
        }
        else
        {
            if (!g_fInsDirty)
            {
                if (StrCmp(szTemp, TEXT("<local>")) != 0)
                    g_fInsDirty = TRUE;
            }
            if (!fCheckDirtyOnly)
                WritePrivateProfileString( TEXT("Proxy"), TEXT("Proxy_Override"), TEXT("<local>"), szInsFile );
        }
    }
    else
    {
        if (!g_fInsDirty)
        {
            if (StrCmp(szTemp, szProxyOverride) != 0)
                g_fInsDirty = TRUE;
        }
        if (!fCheckDirtyOnly)
            WritePrivateProfileString( TEXT("Proxy"), TEXT("Proxy_Override"), szProxyOverride, szInsFile );
    }
    return TRUE;
}

INT_PTR CALLBACK ProxyProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    BOOL fSameProxy;
    BOOL fUseProxy;
    BOOL fLocal;
    TCHAR szProxy[MAX_PATH];
    TCHAR szPort[MAX_PATH];

    switch( msg )
    {
    case WM_INITDIALOG:
        // warn the user that settings on this page will override imported connection settings
        if (InsGetBool(IS_CONNECTSET, IK_OPTION, FALSE, g_szInsFile))
            ErrorMessageBox(hDlg, IDS_CONNECTSET_WARN);

        EnableDBCSChars(hDlg, IDE_HTTPPROXY);
        EnableDBCSChars(hDlg, IDE_SECPROXY);
        EnableDBCSChars(hDlg, IDE_FTPPROXY);
        EnableDBCSChars(hDlg, IDE_GOPHERPROXY);
        EnableDBCSChars(hDlg, IDE_SOCKSPROXY);
        EnableDBCSChars(hDlg, IDE_DISPROXYADR);

        Edit_LimitText(GetDlgItem(hDlg, IDE_HTTPPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_FTPPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_GOPHERPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SECPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SOCKSPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_DISPROXYADR), MAX_STRING - 11); // 8 for ;<local> + 2 for the double quotes

        // load information from ins file
        InitializeProxy(hDlg, g_szInsFile);
        break;

    case WM_COMMAND:
        fSameProxy = IsDlgButtonChecked( hDlg, IDC_SAMEFORALL );
        fUseProxy = IsDlgButtonChecked( hDlg, IDC_YESPROXY );
        fLocal = IsDlgButtonChecked( hDlg, IDC_DISPROXYLOCAL );

        if( HIWORD(wParam) == BN_CLICKED )
        {
            switch( LOWORD(wParam))
            {
            case IDC_SAMEFORALL:
                GetDlgItemText( hDlg, IDE_HTTPPROXY, szProxy, MAX_PATH );
                GetDlgItemText( hDlg, IDE_HTTPPORT, szPort, MAX_PATH );
                StrCat( szProxy, TEXT(":") );
                StrCat( szProxy, szPort );
                if( fSameProxy )
                {
                    SetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
                }
                // fallthrough

            case IDC_YESPROXY:
                EnableProxyControls( hDlg, fSameProxy, fUseProxy );
                break;
            }
        }
        else if( (HIWORD(wParam) == EN_UPDATE) && fSameProxy && ((LOWORD(wParam) == IDE_HTTPPROXY) || (LOWORD(wParam) == IDE_HTTPPORT)))
        {
            GetDlgItemText( hDlg, IDE_HTTPPROXY, szProxy, MAX_PATH );
            GetDlgItemText( hDlg, IDE_HTTPPORT, szPort, MAX_PATH );
            StrCat( szProxy, TEXT(":") );
            StrCat( szProxy, szPort );
            SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
            SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
            SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
            SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
        }
        break;

    case UM_SAVE:
        *((LPBOOL)wParam) = SaveProxy(hDlg, g_szInsFile, (BOOL) lParam);
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        return FALSE;

    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK ConnectionSettingsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        CheckRadioButton(hDlg, IDC_CSNOIMPORT, IDC_CSIMPORT, IDC_CSNOIMPORT);
        ReadBoolAndCheckButton(IS_CONNECTSET, IK_DELETECONN, 0, g_szInsFile, hDlg, IDC_DELCONNECT);
        DisableDlgItem(hDlg, IDC_MODIFYCONNECT);
        return TRUE;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDC_CSNOIMPORT:
                DisableDlgItem(hDlg, IDC_MODIFYCONNECT);
                break;
                
            case IDC_CSIMPORT:
                EnableDlgItem(hDlg, IDC_MODIFYCONNECT);
                break;
                
            case IDC_MODIFYCONNECT:
                ShowInetcpl(hDlg, INET_PAGE_CONNECTION);
                SetFocus(GetDlgItem(hDlg, IDC_MODIFYCONNECT));
                break;
            }
            break;
        }
        break;
    case UM_SAVE:
        {
            TCHAR szCSWorkDir[MAX_PATH];
            BOOL fCheckDirtyOnly = (BOOL) lParam;
            BOOL fDeleteCS;
            
            if (IsDlgButtonChecked(hDlg, IDC_CSIMPORT) == BST_CHECKED)
            {
                if (!fCheckDirtyOnly)
                {
                    PathCombine(szCSWorkDir, g_szWorkDir, TEXT("connect.wrk"));
                    ImportConnectSet(g_szInsFile, szCSWorkDir, g_szWorkDir, TRUE, IEM_PROFMGR);

                    CheckRadioButton(hDlg, IDC_CSNOIMPORT, IDC_CSIMPORT, IDC_CSNOIMPORT);
                    DisableDlgItem(hDlg, IDC_MODIFYCONNECT);
                }
                g_fInsDirty = TRUE;
            }

            fDeleteCS = (IsDlgButtonChecked(hDlg, IDC_DELCONNECT) == BST_CHECKED);
            if (!g_fInsDirty)
            {
                BOOL fTemp;

                fTemp = InsGetBool(IS_CONNECTSET, IK_DELETECONN, 0, g_szInsFile);
                if (fTemp != fDeleteCS)
                    g_fInsDirty = TRUE;
            }

            if (!fCheckDirtyOnly)
                InsWriteBool(IS_CONNECTSET, IK_DELETECONN, fDeleteCS, g_szInsFile);
        }
        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        return FALSE;

    default:
        return FALSE;
    }

    return TRUE;
}

HRESULT ConnectionSettingsFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState)
{
    TCHAR szFrom[MAX_PATH];

    PathCombine(szFrom, g_szWorkDir, TEXT("connect.wrk"));

    if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && !PathIsEmptyPath(szFrom, FILES_ONLY))
        SetFlag(pdwCabState, CAB_TYPE_CONFIG);

    if (HasFlag(dwFlags, PM_COPY))
        CopyFileToDir(szFrom, pcszDestDir);

    if (HasFlag(dwFlags, PM_CLEAR))
        PathRemovePath(szFrom);

    return S_OK;
}


INT_PTR CALLBACK StartSearchProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch( msg )
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_STARTPAGE);
        EnableDBCSChars(hDlg, IDE_SEARCHPAGE);
        EnableDBCSChars(hDlg, IDE_CUSTOMSUPPORT);
        Edit_LimitText(GetDlgItem(hDlg, IDE_STARTPAGE), INTERNET_MAX_URL_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SEARCHPAGE), INTERNET_MAX_URL_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CUSTOMSUPPORT), INTERNET_MAX_URL_LENGTH - 1);
        // load information from ins file
        InitializeStartSearch(hDlg, g_szInsFile, NULL);
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_STARTPAGE:
                EnableDlgItem2(hDlg, IDE_STARTPAGE, (IsDlgButtonChecked(hDlg, IDC_STARTPAGE) == BST_CHECKED));
                EnableDlgItem2(hDlg, IDC_STARTPAGE_TXT, (IsDlgButtonChecked(hDlg, IDC_STARTPAGE) == BST_CHECKED));
                break;
                
            case IDC_SEARCHPAGE:
                EnableDlgItem2(hDlg, IDE_SEARCHPAGE, (IsDlgButtonChecked(hDlg, IDC_SEARCHPAGE) == BST_CHECKED));
                EnableDlgItem2(hDlg, IDC_SEARCHPAGE_TXT, (IsDlgButtonChecked(hDlg, IDC_SEARCHPAGE) == BST_CHECKED));
                break;
                
            case IDC_CUSTOMSUPPORT:
                EnableDlgItem2(hDlg, IDE_CUSTOMSUPPORT, (IsDlgButtonChecked(hDlg, IDC_CUSTOMSUPPORT) == BST_CHECKED));
                EnableDlgItem2(hDlg, IDC_CUSTOMSUPPORT_TXT, (IsDlgButtonChecked(hDlg, IDC_CUSTOMSUPPORT) == BST_CHECKED));
                break;

            default:
                return FALSE;
        }
        break;

    case UM_SAVE:
        // write the information back to the ins file
        {
        BOOL fStartPage = (IsDlgButtonChecked(hDlg, IDC_STARTPAGE) == BST_CHECKED);
        BOOL fSearchPage = (IsDlgButtonChecked(hDlg, IDC_SEARCHPAGE) == BST_CHECKED);
        BOOL fSupportPage = (IsDlgButtonChecked(hDlg, IDC_CUSTOMSUPPORT) == BST_CHECKED);

        if ((fStartPage && !CheckField(hDlg, IDE_STARTPAGE, FC_URL))        ||
            (fSearchPage && !CheckField(hDlg, IDE_SEARCHPAGE, FC_URL))      ||
            (fSupportPage && !CheckField(hDlg, IDE_CUSTOMSUPPORT, FC_URL)))
            return FALSE;

        *((LPBOOL)wParam) = SaveStartSearch(hDlg, g_szInsFile, NULL, &g_fInsDirty, (BOOL) lParam);
        }
        break;
        
    case WM_CLOSE:
        DestroyWindow(hDlg);
        return FALSE;

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\customoe.cpp ===
#include "pch.h"

#define MAX_SERVER  256

static const TCHAR c_sz1[] = TEXT("1");
static const TCHAR c_sz0[] = TEXT("0");
static const TCHAR c_szYes[] = TEXT("Yes");
static const TCHAR c_szNo[] = TEXT("No");
static const TCHAR c_szEmpty[] = TEXT("");
static const TCHAR c_szNULL[] = TEXT("NULL");

/////////////////////////////////////////////////////////////////////////////
// MailServer

INT_PTR CALLBACK MailServer(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR   szMailServer[MAX_SERVER],
            szSMTPServer[MAX_SERVER],
            szNewsServer[MAX_SERVER],
            szChoice[16];
    LPCTSTR pszKey;
    HWND    hComboBox;
    BOOL    fIMAP, fCheckDirtyOnly,
            fSPAMail, fSPASMTP, fSPANNTP,
            fAcctRO, fNoModify;

    switch(msg)
    {
    case WM_INITDIALOG:
        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_MAILSERVER);
        EnableDBCSChars(hDlg, IDE_SMTPSERVER);
        EnableDBCSChars(hDlg, IDE_NEWSERVER);

        Edit_LimitText(GetDlgItem(hDlg, IDE_MAILSERVER), countof(szMailServer)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SMTPSERVER), countof(szSMTPServer)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_NEWSERVER),  countof(szNewsServer)-1);

        hComboBox = GetDlgItem(hDlg, IDC_POPIMAP);
        ComboBox_ResetContent(hComboBox);

        LoadString(g_hInst, IDS_POP3, szChoice, countof(szChoice));
        ComboBox_AddString(hComboBox, szChoice);

        LoadString(g_hInst, IDS_IMAP, szChoice, countof(szChoice));
        ComboBox_AddString(hComboBox, szChoice);

        //----- Initialization of fields -----
        fIMAP  = InsGetYesNo(IS_INTERNETMAIL, IK_USEIMAP, FALSE, g_szInsFile);
        pszKey = fIMAP ? IK_IMAPSERVER : IK_POPSERVER;

        GetPrivateProfileString(IS_INTERNETMAIL, pszKey,        c_szEmpty, szMailServer, countof(szMailServer), g_szInsFile);
        GetPrivateProfileString(IS_INTERNETMAIL, IK_SMTPSERVER, c_szEmpty, szSMTPServer, countof(szSMTPServer), g_szInsFile);
        GetPrivateProfileString(IS_INTERNETNEWS, IK_NNTPSERVER, c_szEmpty, szNewsServer, countof(szNewsServer), g_szInsFile);

        StrRemoveWhitespace(szMailServer);
        StrRemoveWhitespace(szSMTPServer);
        StrRemoveWhitespace(szNewsServer);

        fSPAMail   = InsGetYesNo(IS_INTERNETMAIL, IK_USESPA,        FALSE, g_szInsFile);
        fSPASMTP   = InsGetYesNo(IS_INTERNETMAIL, IK_SMTPUSESPA,    FALSE, g_szInsFile);
        fSPANNTP   = InsGetYesNo(IS_INTERNETNEWS, IK_USESPA,        FALSE, g_szInsFile);

        fAcctRO    = InsGetYesNo(IS_OEGLOBAL,     IK_READONLY,      FALSE, g_szInsFile);
        fNoModify  = InsGetYesNo(IS_OEGLOBAL,     IK_NOMODIFYACCTS, FALSE, g_szInsFile);
        
        SetDlgItemText(hDlg, IDE_MAILSERVER, szMailServer);
        SetDlgItemText(hDlg, IDE_SMTPSERVER, szSMTPServer);
        SetDlgItemText(hDlg, IDE_NEWSERVER,  szNewsServer);

        CheckDlgButton(hDlg, IDC_USESPAMAIL,    fSPAMail);
        CheckDlgButton(hDlg, IDC_USESPASMTP,    fSPASMTP);
        CheckDlgButton(hDlg, IDC_USESPANNTP,    fSPANNTP);

        CheckDlgButton(hDlg, IDC_ACCTRO,        fAcctRO);
        CheckDlgButton(hDlg, IDC_ACCTNOCONFIG,  fNoModify);

        ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_POPIMAP), fIMAP ? 1 : 0);
        break;

    case UM_SAVE:
        fCheckDirtyOnly = (BOOL) lParam;

        //----- Read data from controls into internal variables -----
        fIMAP = (ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_POPIMAP)) > 0);

        GetDlgItemText(hDlg, IDE_MAILSERVER, szMailServer, countof(szMailServer));
        GetDlgItemText(hDlg, IDE_SMTPSERVER, szSMTPServer, countof(szSMTPServer));
        GetDlgItemText(hDlg, IDE_NEWSERVER,  szNewsServer, countof(szNewsServer));

        StrRemoveWhitespace(szMailServer);
        StrRemoveWhitespace(szSMTPServer);
        StrRemoveWhitespace(szNewsServer);

        fSPAMail   = IsDlgButtonChecked(hDlg, IDC_USESPAMAIL);
        fSPASMTP   = IsDlgButtonChecked(hDlg, IDC_USESPASMTP);
        fSPANNTP   = IsDlgButtonChecked(hDlg, IDC_USESPANNTP);

        fAcctRO     = IsDlgButtonChecked(hDlg, IDC_ACCTRO);
        fNoModify   = IsDlgButtonChecked(hDlg, IDC_ACCTNOCONFIG);

        //----- Handle g_fInsDirty flag -----
        if (!g_fInsDirty)
        {
            TCHAR   szWasMailServer[MAX_SERVER],
                    szWasSMTPServer[MAX_SERVER],
                    szWasNewsServer[MAX_SERVER];
            BOOL    fWasIMAP, fWasSPAMail, fWasSPASMTP, fWasSPANNTP,
                    fWasAcctRO, fWasNoModify;

            fWasIMAP = InsGetYesNo(IS_INTERNETMAIL, IK_USEIMAP, FALSE, g_szInsFile);
            pszKey = fWasIMAP ? IK_IMAPSERVER : IK_POPSERVER;

            GetPrivateProfileString(IS_INTERNETMAIL, pszKey,        c_szEmpty, szWasMailServer, countof(szWasMailServer), g_szInsFile);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_SMTPSERVER, c_szEmpty, szWasSMTPServer, countof(szWasSMTPServer), g_szInsFile);
            GetPrivateProfileString(IS_INTERNETNEWS, IK_NNTPSERVER, c_szEmpty, szWasNewsServer, countof(szWasNewsServer), g_szInsFile);

            StrRemoveWhitespace(szWasMailServer);
            StrRemoveWhitespace(szWasSMTPServer);
            StrRemoveWhitespace(szWasNewsServer);

            fWasSPAMail   = InsGetYesNo(IS_INTERNETMAIL, IK_USESPA,        FALSE, g_szInsFile);
            fWasSPASMTP   = InsGetYesNo(IS_INTERNETMAIL, IK_SMTPUSESPA,    FALSE, g_szInsFile);
            fWasSPANNTP   = InsGetYesNo(IS_INTERNETNEWS, IK_USESPA,        FALSE, g_szInsFile);

            fWasAcctRO    = InsGetYesNo(IS_OEGLOBAL,     IK_READONLY,      FALSE, g_szInsFile);
            fWasNoModify  = InsGetYesNo(IS_OEGLOBAL,     IK_NOMODIFYACCTS, FALSE, g_szInsFile);

            if (fIMAP != fWasIMAP ||
                fSPAMail != fWasSPAMail ||
                fSPASMTP != fWasSPASMTP ||
                fSPANNTP != fWasSPANNTP ||
                fAcctRO != fWasAcctRO ||
                fNoModify != fWasNoModify ||
                StrCmpI(szMailServer, szWasMailServer) != 0 ||
                StrCmpI(szSMTPServer, szWasSMTPServer) != 0 ||
                StrCmpI(szNewsServer, szWasNewsServer) != 0)
                g_fInsDirty = TRUE;
        }

        //----- Serialize data to the *.ins file -----
        if (!fCheckDirtyOnly)
        {
            WritePrivateProfileString(IS_INTERNETMAIL, IK_USEIMAP, fIMAP ? c_szYes : c_szNo, g_szInsFile);
            if (fIMAP)
            {
                WritePrivateProfileString(IS_INTERNETMAIL, IK_IMAPSERVER, szMailServer, g_szInsFile);
                WritePrivateProfileString(IS_INTERNETMAIL, IK_POPSERVER,  NULL,         g_szInsFile);
            }
            else
            {
                WritePrivateProfileString(IS_INTERNETMAIL, IK_IMAPSERVER, NULL,         g_szInsFile);
                WritePrivateProfileString(IS_INTERNETMAIL, IK_POPSERVER,  szMailServer, g_szInsFile);
            }
            WritePrivateProfileString(IS_INTERNETMAIL, IK_SMTPSERVER, szSMTPServer, g_szInsFile);
            WritePrivateProfileString(IS_INTERNETNEWS, IK_NNTPSERVER, szNewsServer, g_szInsFile);

            WritePrivateProfileString(IS_INTERNETMAIL, IK_USESPA,       fSPAMail ? c_szYes : c_szNo, g_szInsFile);

            WritePrivateProfileString(IS_INTERNETMAIL, IK_SMTPUSESPA,   fSPASMTP ? c_szYes : c_szNo, g_szInsFile);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_SMTPREQLOGON, fSPASMTP ? c_sz1   : c_sz0,  g_szInsFile);

            WritePrivateProfileString(IS_INTERNETNEWS, IK_USESPA,       fSPANNTP ? c_szYes : c_szNo, g_szInsFile);
            WritePrivateProfileString(IS_INTERNETNEWS, IK_REQLOGON,     fSPANNTP ? c_sz1   : c_sz0,  g_szInsFile);

            WritePrivateProfileString(IS_OEGLOBAL,     IK_READONLY,     fAcctRO     ? c_sz1   : c_sz0,  g_szInsFile);
            WritePrivateProfileString(IS_OEGLOBAL,     IK_NOMODIFYACCTS,fNoModify   ? c_sz1   : c_sz0,  g_szInsFile);
        }

        *((LPBOOL)wParam) = TRUE;
        break;
    
    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// IMAPSettings

INT_PTR CALLBACK IMAPSettings(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR   szRFP[MAX_PATH], szSentPath[MAX_PATH], szDrafts[MAX_PATH];
    BOOL    fSpecial, fCheckNew, fCheckDirtyOnly;

    switch(msg)
    {
    case WM_INITDIALOG:
        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_ROOTPATH);
        EnableDBCSChars(hDlg, IDE_SENTPATH);
        EnableDBCSChars(hDlg, IDE_DRAFTSPATH);

        Edit_LimitText(GetDlgItem(hDlg, IDE_ROOTPATH), countof(szRFP)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SENTPATH), countof(szSentPath)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_DRAFTSPATH),  countof(szDrafts)-1);

        //----- Initialization of fields -----
        GetPrivateProfileString(IS_INTERNETMAIL, IK_RFP,        c_szEmpty, szRFP,        countof(szRFP),        g_szInsFile);
        GetPrivateProfileString(IS_INTERNETMAIL, IK_SENTITEMS,  c_szEmpty, szSentPath,   countof(szSentPath),   g_szInsFile);
        GetPrivateProfileString(IS_INTERNETMAIL, IK_DRAFTS,     c_szEmpty, szDrafts,     countof(szDrafts),     g_szInsFile);

        StrRemoveWhitespace(szRFP);
        StrRemoveWhitespace(szSentPath);
        StrRemoveWhitespace(szDrafts);

        fCheckNew  = GetPrivateProfileInt(IS_INTERNETMAIL, IK_CHECKFORNEW,   FALSE, g_szInsFile);
        fSpecial   = GetPrivateProfileInt(IS_INTERNETMAIL, IK_USESPECIAL,    FALSE, g_szInsFile);

        SetDlgItemText(hDlg, IDE_ROOTPATH,   szRFP);
        SetDlgItemText(hDlg, IDE_SENTPATH,   szSentPath);
        SetDlgItemText(hDlg, IDE_DRAFTSPATH, szDrafts);

        CheckDlgButton(hDlg, IDC_STORESPECIAL,  fSpecial);
        CheckDlgButton(hDlg, IDC_CHECKNEW,      fCheckNew);

        EnableDlgItem2(hDlg, IDE_SENTPATH, fSpecial);
        EnableDlgItem2(hDlg, IDC_SENTPATH_TXT, fSpecial);
        EnableDlgItem2(hDlg, IDE_DRAFTSPATH, fSpecial);
        EnableDlgItem2(hDlg, IDC_DRAFTSPATH_TXT, fSpecial);
        break;

    case WM_COMMAND:
        if (BN_CLICKED == HIWORD(wParam))
        {
            switch (LOWORD(wParam))
            {
            case IDC_STORESPECIAL:
                fSpecial = IsDlgButtonChecked(hDlg, IDC_STORESPECIAL);
                EnableDlgItem2(hDlg, IDE_SENTPATH, fSpecial);
                EnableDlgItem2(hDlg, IDC_SENTPATH_TXT, fSpecial);
                EnableDlgItem2(hDlg, IDE_DRAFTSPATH, fSpecial);
                EnableDlgItem2(hDlg, IDC_DRAFTSPATH_TXT, fSpecial);
                break;
            }
        }
        break;

    case UM_SAVE:
        fCheckDirtyOnly = (BOOL) lParam;

        //----- Read data from controls into internal variables -----
        GetDlgItemText(hDlg, IDE_ROOTPATH,   szRFP,        countof(szRFP));
        GetDlgItemText(hDlg, IDE_SENTPATH,   szSentPath,   countof(szSentPath));
        GetDlgItemText(hDlg, IDE_DRAFTSPATH, szDrafts,     countof(szDrafts));

        StrRemoveWhitespace(szRFP);
        StrRemoveWhitespace(szSentPath);
        StrRemoveWhitespace(szDrafts);

        fCheckNew  = IsDlgButtonChecked(hDlg, IDC_CHECKNEW);
        fSpecial   = IsDlgButtonChecked(hDlg, IDC_STORESPECIAL);

        //----- Handle g_fInsDirty flag -----
        if (!g_fInsDirty)
        {
            TCHAR   szWasRFP[MAX_PATH], szWasSentPath[MAX_PATH], szWasDrafts[MAX_PATH];
            BOOL    fWasSpecial, fWasCheckNew;

            GetPrivateProfileString(IS_INTERNETMAIL, IK_RFP,        c_szEmpty, szWasRFP,        countof(szWasRFP),        g_szInsFile);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_SENTITEMS,  c_szEmpty, szWasSentPath,   countof(szWasSentPath),   g_szInsFile);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_DRAFTS,     c_szEmpty, szWasDrafts,     countof(szWasDrafts),     g_szInsFile);

            StrRemoveWhitespace(szWasRFP);
            StrRemoveWhitespace(szWasSentPath);
            StrRemoveWhitespace(szWasDrafts);

            fWasCheckNew  = GetPrivateProfileInt(IS_INTERNETMAIL, IK_CHECKFORNEW,   FALSE, g_szInsFile);
            fWasSpecial   = GetPrivateProfileInt(IS_INTERNETMAIL, IK_USESPECIAL,    FALSE, g_szInsFile);

            if (fCheckNew != fWasCheckNew ||
                fSpecial != fWasSpecial ||
                StrCmpI(szRFP, szWasRFP) != 0 ||
                StrCmpI(szSentPath, szWasSentPath) != 0 ||
                StrCmpI(szDrafts, szWasDrafts) != 0)
                g_fInsDirty = TRUE;
        }

        //----- Serialize data to the *.ins file -----
        if (!fCheckDirtyOnly)
        {
            WritePrivateProfileString(IS_INTERNETMAIL, IK_RFP,          szRFP,      g_szInsFile);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_SENTITEMS,    szSentPath, g_szInsFile);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_DRAFTS,       szDrafts,   g_szInsFile);

            WritePrivateProfileString(IS_INTERNETMAIL, IK_CHECKFORNEW,  fCheckNew ? c_sz1 : c_sz0, g_szInsFile);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_USESPECIAL,   fSpecial ? c_sz1 : c_sz0, g_szInsFile);
        }

        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void SetTimeoutString(HWND hwnd, UINT pos)
{
    UINT cch, csec, cmin;
    TCHAR szOut[128], sz[128];
    
    csec = TIMEOUT_SEC_MIN + (pos * TIMEOUT_DSEC);
    ASSERT(csec >= TIMEOUT_SEC_MIN && csec <= TIMEOUT_SEC_MAX);
    
    cmin = csec / 60;
    csec = csec % 60;
    if (cmin > 1)
    {
        LoadString(g_hInst, IDS_XMINUTES, sz, countof(sz));
        wsprintf(szOut, sz, cmin);
        cch = lstrlen(szOut);
    }
    else if (cmin == 1)
    {
        cch = LoadString(g_hInst, IDS_1MINUTE, szOut, countof(szOut));
    }
    else
    {
        cch = 0;
    }
    
    if (csec != 0)
    {
        if (cmin > 0)
        {
            szOut[cch] = TEXT(' ');
            cch++;
        }
        
        LoadString(g_hInst, IDS_XSECONDS, sz, countof(sz));
        wsprintf(&szOut[cch], sz, csec);
    }
    
    SetWindowText(hwnd, szOut);
}

/////////////////////////////////////////////////////////////////////////////
// LDAPServer

INT_PTR CALLBACK LDAPServer(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szLDAPServer[MAX_SERVER],
          szLDAPHome[INTERNET_MAX_URL_LENGTH],
          szLDAPBitmap[MAX_PATH],
          szWorkDir[MAX_PATH],
          szLDAPFriendly[MAX_SERVER],
          szLDAPBase[128];
    UINT  uTimeout, uMatches, uAuthType;
    BOOL  fLDAPCheck, fCheckDirtyOnly, fTrans;

    switch(msg)
    {
    case WM_INITDIALOG:
        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_FRIENDLYNAME);
        EnableDBCSChars(hDlg, IDE_SEARCHBASE);
        EnableDBCSChars(hDlg, IDE_LDAPBITMAP);
        EnableDBCSChars(hDlg, IDE_DIRSERVICE);
        EnableDBCSChars(hDlg, IDE_LDAPHOMEPAGE);

        Edit_LimitText(GetDlgItem(hDlg, IDE_FRIENDLYNAME), countof(szLDAPFriendly) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_DIRSERVICE),   countof(szLDAPServer) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_LDAPHOMEPAGE), countof(szLDAPHome) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SEARCHBASE),   countof(szLDAPBase) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_LDAPBITMAP),   countof(szLDAPBitmap) - 1);
    
        SendDlgItemMessage(hDlg, IDC_TIMEOUTSLD, TBM_SETRANGE, 0, (LPARAM)MAKELONG(0, CTIMEOUT - 1));

        SendDlgItemMessage(hDlg, IDC_SPIN1, UDM_SETRANGE, 0, MAKELONG(MATCHES_MAX, MATCHES_MIN));
        Edit_LimitText(GetDlgItem(hDlg, IDE_MATCHES),   4);

        //----- Initialization of fields -----
        GetPrivateProfileString(IS_LDAP, IK_FRIENDLYNAME, c_szEmpty,        szLDAPFriendly, countof(szLDAPFriendly), g_szInsFile);
        GetPrivateProfileString(IS_LDAP, IK_SERVER,       c_szEmpty,        szLDAPServer,   countof(szLDAPServer),   g_szInsFile);
        GetPrivateProfileString(IS_LDAP, IK_LDAPHOMEPAGE, c_szEmpty,        szLDAPHome,     countof(szLDAPHome),     g_szInsFile);
        GetPrivateProfileString(IS_LDAP, IK_SEARCHBASE,   c_szNULL,         szLDAPBase,     countof(szLDAPBase),     g_szInsFile);
        GetPrivateProfileString(IS_LDAP, IK_BITMAP,       c_szEmpty,        szLDAPBitmap,   countof(szLDAPBitmap),   g_szInsFile);

        StrRemoveWhitespace(szLDAPFriendly);
        StrRemoveWhitespace(szLDAPServer);
        StrRemoveWhitespace(szLDAPHome);
        StrRemoveWhitespace(szLDAPBase);
        StrRemoveWhitespace(szLDAPBitmap);

        fLDAPCheck    = (BOOL)GetPrivateProfileInt(IS_LDAP, IK_CHECKNAMES, FALSE, g_szInsFile);

        uTimeout      = GetPrivateProfileInt(IS_LDAP, IK_TIMEOUT, TIMEOUT_SEC_DEFAULT, g_szInsFile);
        if (uTimeout < TIMEOUT_SEC_MIN)
            uTimeout = TIMEOUT_SEC_MIN;
        else if (uTimeout > TIMEOUT_SEC_MAX)
            uTimeout = TIMEOUT_SEC_MAX;

        uMatches      = GetPrivateProfileInt(IS_LDAP, IK_MATCHES, MATCHES_DEFAULT, g_szInsFile);
        if (uMatches < MATCHES_MIN)
            uMatches = MATCHES_MIN;
        else if (uMatches > MATCHES_MAX)
            uMatches = MATCHES_MAX;

        uAuthType     = GetPrivateProfileInt(IS_LDAP, IK_AUTHTYPE, AUTH_ANONYMOUS, g_szInsFile);
        if (uAuthType != AUTH_ANONYMOUS && uAuthType != AUTH_SPA)
            uAuthType = AUTH_ANONYMOUS;

        SetDlgItemText(hDlg, IDE_FRIENDLYNAME, szLDAPFriendly);
        SetDlgItemText(hDlg, IDE_DIRSERVICE,   szLDAPServer);
        SetDlgItemText(hDlg, IDE_LDAPHOMEPAGE, szLDAPHome);
        SetDlgItemText(hDlg, IDE_SEARCHBASE,   szLDAPBase);
        SetDlgItemText(hDlg, IDE_LDAPBITMAP,   szLDAPBitmap);

        uTimeout = (uTimeout / TIMEOUT_DSEC) - 1;
        SendDlgItemMessage(hDlg, IDC_TIMEOUTSLD, TBM_SETPOS, TRUE, (LPARAM)uTimeout);
        SetTimeoutString(GetDlgItem(hDlg, IDC_TIMEOUT), uTimeout);

        SetDlgItemInt(hDlg, IDE_MATCHES, uMatches, FALSE);

        CheckDlgButton(hDlg, IDC_CHECKNAMES, fLDAPCheck ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_SPA, uAuthType == AUTH_SPA ? BST_CHECKED : BST_UNCHECKED);
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            switch (LOWORD(wParam))
            {
            case IDC_BROWSELDAP:
                GetDlgItemText(hDlg, IDE_LDAPBITMAP, szLDAPBitmap, countof(szLDAPBitmap));

                if (BrowseForFile(hDlg, szLDAPBitmap, countof(szLDAPBitmap), GFN_BMP))
                    SetDlgItemText(hDlg, IDE_LDAPBITMAP, szLDAPBitmap);
                SetFocus(GetDlgItem(hDlg, IDC_BROWSELDAP));
                break;

            default:
                return FALSE;
            }
        }
        break;

    case WM_HSCROLL:
        SetTimeoutString(GetDlgItem(hDlg, IDC_TIMEOUT), (UINT) SendMessage((HWND)lParam, TBM_GETPOS, 0, 0));
        break;

    case UM_SAVE:
        fCheckDirtyOnly = (BOOL) lParam;

        //----- Read data from controls into internal variables -----
        GetDlgItemText(hDlg, IDE_FRIENDLYNAME, szLDAPFriendly, countof(szLDAPFriendly));
        GetDlgItemText(hDlg, IDE_DIRSERVICE,   szLDAPServer,   countof(szLDAPServer));
        GetDlgItemText(hDlg, IDE_LDAPHOMEPAGE, szLDAPHome,     countof(szLDAPHome));
        GetDlgItemText(hDlg, IDE_SEARCHBASE,   szLDAPBase,     countof(szLDAPBase));
        GetDlgItemText(hDlg, IDE_LDAPBITMAP,   szLDAPBitmap,   countof(szLDAPBitmap));

        StrRemoveWhitespace(szLDAPFriendly);
        StrRemoveWhitespace(szLDAPServer);
        StrRemoveWhitespace(szLDAPHome);
        StrRemoveWhitespace(szLDAPBase);
        StrRemoveWhitespace(szLDAPBitmap);

        fLDAPCheck    = IsDlgButtonChecked(hDlg, IDC_CHECKNAMES);
        uAuthType     = IsDlgButtonChecked(hDlg, IDC_SPA) ? AUTH_SPA : AUTH_ANONYMOUS;

        uTimeout = (UINT) SendDlgItemMessage(hDlg, IDC_TIMEOUTSLD, TBM_GETPOS, 0, 0);
        uTimeout = TIMEOUT_SEC_MIN + (uTimeout * TIMEOUT_DSEC);

        uMatches = GetDlgItemInt(hDlg, IDE_MATCHES, &fTrans, FALSE);
        // TODO: we should probably display an error msg here
        if (!fTrans)
            uMatches = MATCHES_DEFAULT;
        else if (uMatches < MATCHES_MIN)
            uMatches = MATCHES_MIN;
        else if (uMatches > MATCHES_MAX)
            uMatches = MATCHES_MAX;

        //----- Validate the input -----
        if (!fCheckDirtyOnly)
        {
            if (!CheckField(hDlg, IDE_LDAPBITMAP, FC_FILE | FC_EXISTS))
                return(TRUE);

            if (!CheckField(hDlg, IDE_LDAPHOMEPAGE, FC_URL))
                return(TRUE);
        }

        //----- Handle g_fInsDirty flag -----
        if (!g_fInsDirty)
        {
            TCHAR szWasLDAPServer[MAX_SERVER],
                  szWasLDAPHome[INTERNET_MAX_URL_LENGTH],
                  szWasLDAPBitmap[MAX_PATH],
                  szWasLDAPFriendly[MAX_SERVER],
                  szWasLDAPBase[128];
            UINT  uWasTimeout, uWasMatches, uWasAuthType;
            BOOL  fWasLDAPCheck;

            GetPrivateProfileString(IS_LDAP, IK_FRIENDLYNAME, c_szEmpty,        szWasLDAPFriendly, countof(szWasLDAPFriendly), g_szInsFile);
            GetPrivateProfileString(IS_LDAP, IK_SERVER,       c_szEmpty,        szWasLDAPServer,   countof(szWasLDAPServer),   g_szInsFile);
            GetPrivateProfileString(IS_LDAP, IK_LDAPHOMEPAGE, c_szEmpty,        szWasLDAPHome,     countof(szWasLDAPHome),     g_szInsFile);
            GetPrivateProfileString(IS_LDAP, IK_SEARCHBASE,   c_szNULL,         szWasLDAPBase,     countof(szWasLDAPBase),     g_szInsFile);
            GetPrivateProfileString(IS_LDAP, IK_BITMAP,       c_szEmpty,        szWasLDAPBitmap,   countof(szWasLDAPBitmap),   g_szInsFile);

            StrRemoveWhitespace(szWasLDAPFriendly);
            StrRemoveWhitespace(szWasLDAPServer);
            StrRemoveWhitespace(szWasLDAPHome);
            StrRemoveWhitespace(szWasLDAPBase);
            StrRemoveWhitespace(szWasLDAPBitmap);

            fWasLDAPCheck    = (BOOL)GetPrivateProfileInt(IS_LDAP, IK_CHECKNAMES, FALSE, g_szInsFile);
            uWasTimeout      = GetPrivateProfileInt(IS_LDAP, IK_TIMEOUT, TIMEOUT_SEC_MIN, g_szInsFile);
            uWasMatches      = GetPrivateProfileInt(IS_LDAP, IK_MATCHES, MATCHES_DEFAULT, g_szInsFile);
            uWasAuthType     = GetPrivateProfileInt(IS_LDAP, IK_AUTHTYPE, AUTH_ANONYMOUS, g_szInsFile);

            if (fLDAPCheck != fWasLDAPCheck ||
                uTimeout != uWasTimeout ||
                uMatches != uWasMatches ||
                uAuthType != uWasAuthType ||
                StrCmpI(szLDAPFriendly, szWasLDAPFriendly) != 0 ||
                StrCmpI(szLDAPServer, szWasLDAPServer) != 0 ||
                StrCmpI(szLDAPHome, szWasLDAPHome) != 0 ||
                StrCmpI(szLDAPBase, szWasLDAPBase) != 0 ||
                StrCmpI(szLDAPBitmap, szWasLDAPBitmap) != 0)
                g_fInsDirty = TRUE;
        }

        //----- Serialize data to the *.ins file -----
        if (!fCheckDirtyOnly)
        {
            // clear of the old entry and associated image.
            ImportLDAPBitmap(g_szInsFile, g_szWorkDir, FALSE);
            
            WritePrivateProfileString(IS_LDAP, IK_FRIENDLYNAME, szLDAPFriendly, g_szInsFile);
            WritePrivateProfileString(IS_LDAP, IK_SERVER,       szLDAPServer,   g_szInsFile);
            WritePrivateProfileString(IS_LDAP, IK_LDAPHOMEPAGE, szLDAPHome,     g_szInsFile);
            InsWriteQuotedString (IS_LDAP, IK_SEARCHBASE,   szLDAPBase,     g_szInsFile);
            WritePrivateProfileString(IS_LDAP, IK_BITMAP,       szLDAPBitmap,   g_szInsFile);

            WritePrivateProfileString(IS_LDAP, IK_CHECKNAMES, fLDAPCheck ? c_sz1 : c_sz0, g_szInsFile);
            
            wsprintf(szWorkDir, TEXT("%i"), uTimeout);
            WritePrivateProfileString(IS_LDAP, IK_TIMEOUT, szWorkDir, g_szInsFile);

            wsprintf(szWorkDir, TEXT("%i"), uMatches);
            WritePrivateProfileString(IS_LDAP, IK_MATCHES, szWorkDir, g_szInsFile);

            wsprintf(szWorkDir, TEXT("%i"), uAuthType);
            WritePrivateProfileString(IS_LDAP, IK_AUTHTYPE, szWorkDir, g_szInsFile);

            PathCombine(szWorkDir, g_szWorkDir, TEXT("ldap.wrk"));
            ImportLDAPBitmap(g_szInsFile, szWorkDir, TRUE);
        }

        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CustomizeOE

INT_PTR CALLBACK CustomizeOE(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szInfopane[INTERNET_MAX_URL_LENGTH],
          szInfopaneBmp[MAX_PATH],
          szHTMLPath[MAX_PATH],
          szWorkDir[MAX_PATH],
          szSender[255],
          szReply[255];
    UINT  nID;
    BOOL  fURL,
          fCheckDirtyOnly;

    switch(msg)
    {
    case WM_INITDIALOG:
        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_OELOCALPATH);
        EnableDBCSChars(hDlg, IDE_OEIMAGEPATH);
        EnableDBCSChars(hDlg, IDE_OEWMPATH);
        EnableDBCSChars(hDlg, IDE_OEWMSENDER);

        EnableDBCSChars(hDlg, IDE_OEPANEURL);
        EnableDBCSChars(hDlg, IDE_OEWMREPLYTO);

        Edit_LimitText(GetDlgItem(hDlg, IDE_OEPANEURL),   countof(szInfopane) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_OELOCALPATH), MAX_PATH);
        Edit_LimitText(GetDlgItem(hDlg, IDE_OEIMAGEPATH), countof(szInfopaneBmp) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_OEWMPATH),    countof(szHTMLPath) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_OEWMSENDER),  countof(szSender) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_OEWMREPLYTO), countof(szReply) - 1);

        //----- Initialization of fields (1st phase) -----
        GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANE,       c_szEmpty, szInfopane,    countof(szInfopane),    g_szInsFile);
        GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANEBMP,    c_szEmpty, szInfopaneBmp, countof(szInfopaneBmp), g_szInsFile);
        GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEMESSAGE, c_szEmpty, szHTMLPath,    countof(szHTMLPath),    g_szInsFile);
        GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMENAME,    c_szEmpty, szSender,      countof(szSender),      g_szInsFile);
        GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEADDR,    c_szEmpty, szReply,       countof(szReply),       g_szInsFile);

        StrRemoveWhitespace(szInfopane);
        StrRemoveWhitespace(szInfopaneBmp);
        StrRemoveWhitespace(szHTMLPath);
        StrRemoveWhitespace(szSender);
        StrRemoveWhitespace(szReply);

        //----- Initialization of fields (2nd phase) -----
        nID = PathIsURL(szInfopane) ? IDC_OEPANEURL : IDC_OEPANELOCAL;

        //----- Set read values in the controls -----
        CheckRadioButton(hDlg, IDC_OEPANEURL, IDC_OEPANELOCAL, nID);
        SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(nID, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, nID));

        if (nID == IDC_OEPANEURL)
        {
            SetDlgItemText(hDlg, IDE_OEPANEURL, szInfopane);
            SetDlgItemText(hDlg, IDE_OELOCALPATH, NULL);
        }
        else
        {
            SetDlgItemText(hDlg, IDE_OEPANEURL, NULL);
            SetDlgItemText(hDlg, IDE_OELOCALPATH, szInfopane);
        }
        SetDlgItemText(hDlg, IDE_OEIMAGEPATH, szInfopaneBmp);
        SetDlgItemText(hDlg, IDE_OEWMPATH,    szHTMLPath);
        SetDlgItemText(hDlg, IDE_OEWMSENDER,  szSender);
        SetDlgItemText(hDlg, IDE_OEWMREPLYTO, szReply);
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            switch (LOWORD(wParam))
            {
            case IDC_OEPANEURL:
            case IDC_OEPANELOCAL:
                fURL = (LOWORD(wParam) == IDC_OEPANEURL);
                
                EnableDlgItem2(hDlg, IDE_OEPANEURL,        fURL);
                EnableDlgItem2(hDlg, IDE_OELOCALPATH,     !fURL);
                EnableDlgItem2(hDlg, IDC_BROWSEOEHTML,    !fURL);
                EnableDlgItem2(hDlg, IDC_OELOCALPATH_TXT, !fURL);
                EnableDlgItem2(hDlg, IDE_OEIMAGEPATH,     !fURL);
                EnableDlgItem2(hDlg, IDC_BROWSEOEIMAGE,   !fURL);
                EnableDlgItem2(hDlg, IDC_OEIMAGEPATH_TXT, !fURL);
                break;

            case IDC_BROWSEOEHTML:
                GetDlgItemText(hDlg, IDE_OELOCALPATH, szInfopane, countof(szInfopane));

                if (BrowseForFile(hDlg, szInfopane, countof(szInfopane), GFN_LOCALHTM))
                    SetDlgItemText(hDlg, IDE_OELOCALPATH, szInfopane);
                SetFocus(GetDlgItem(hDlg, IDC_BROWSEOEHTML));
                break;

            case IDC_BROWSEOEIMAGE:
                GetDlgItemText(hDlg, IDE_OEIMAGEPATH, szInfopaneBmp, countof(szInfopaneBmp));

                if (BrowseForFile(hDlg, szInfopaneBmp, countof(szInfopaneBmp), GFN_PICTURE))
                    SetDlgItemText(hDlg, IDE_OEIMAGEPATH, szInfopaneBmp);
                SetFocus(GetDlgItem(hDlg, IDC_BROWSEOEIMAGE));
                break;

            case IDC_BROWSEOEWM:
                GetDlgItemText(hDlg, IDE_OEWMPATH, szHTMLPath, countof(szHTMLPath));

                if (BrowseForFile(hDlg, szHTMLPath, countof(szHTMLPath), GFN_LOCALHTM))
                    SetDlgItemText(hDlg, IDE_OEWMPATH, szHTMLPath);
                SetFocus(GetDlgItem(hDlg, IDC_BROWSEOEWM));
                break;

            default:
                break;
            }
        }
        break;

    case UM_SAVE:
        fCheckDirtyOnly = (BOOL) lParam;

        //----- Read data from controls into internal variables -----
        nID = IsDlgButtonChecked(hDlg, IDC_OEPANEURL) == BST_CHECKED ? IDE_OEPANEURL : IDE_OELOCALPATH;

        GetDlgItemText(hDlg, nID,             szInfopane,    countof(szInfopane));
        GetDlgItemText(hDlg, IDE_OEWMSENDER,  szSender,      countof(szSender));
        GetDlgItemText(hDlg, IDE_OEWMREPLYTO, szReply,       countof(szReply));
        GetDlgItemText(hDlg, IDE_OEWMPATH,    szHTMLPath,    countof(szHTMLPath));
        GetDlgItemText(hDlg, IDE_OEIMAGEPATH, szInfopaneBmp, countof(szInfopaneBmp));

        StrRemoveWhitespace(szInfopane);
        StrRemoveWhitespace(szSender);
        StrRemoveWhitespace(szReply);

        //----- Validate the input -----
        if (!fCheckDirtyOnly)
        {
            szInfopaneBmp[0] = TEXT('\0');
            if (nID == IDE_OEPANEURL)
            {
                if (!CheckField(hDlg, IDE_OEPANEURL, FC_URL))
                    return(TRUE);
            }
            else
            { /* if (nID == IDE_OELOCALPATH) */
                if (!CheckField(hDlg, IDE_OELOCALPATH, FC_FILE | FC_EXISTS))
                    return(TRUE);

                if (!CheckField(hDlg, IDE_OEIMAGEPATH, FC_FILE | FC_EXISTS))
                    return(TRUE);
            }

            if (!CheckField(hDlg, IDE_OEWMPATH, FC_FILE | FC_EXISTS))
                return(TRUE);

            if (*szHTMLPath != TEXT('\0') && (!CheckField(hDlg, IDE_OEWMSENDER, FC_NONNULL) ||
                                              !CheckField(hDlg, IDE_OEWMREPLYTO, FC_NONNULL)))
                return TRUE;
        }

        //----- Handle g_fInsDirty flag -----
        if (!g_fInsDirty)
        {
            TCHAR szWasInfopane[INTERNET_MAX_URL_LENGTH],
                  szWasInfopaneBmp[MAX_PATH],
                  szWasHTMLPath[MAX_PATH],
                  szWasSender[255],
                  szWasReply[255];

            GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANE,       TEXT(""), szWasInfopane,    countof(szInfopane),    g_szInsFile);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANEBMP,    TEXT(""), szWasInfopaneBmp, countof(szInfopaneBmp), g_szInsFile);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEMESSAGE, TEXT(""), szWasHTMLPath,    countof(szHTMLPath),    g_szInsFile);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMENAME,    TEXT(""), szWasSender,      countof(szSender),      g_szInsFile);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEADDR,    TEXT(""), szWasReply,       countof(szReply),       g_szInsFile);

            StrRemoveWhitespace(szWasInfopane);
            StrRemoveWhitespace(szWasInfopaneBmp);
            StrRemoveWhitespace(szWasHTMLPath);
            StrRemoveWhitespace(szWasSender);
            StrRemoveWhitespace(szWasReply);

            if (StrCmpI(szWasInfopane, szInfopane) != 0 ||
                StrCmpI(szWasInfopaneBmp, szInfopaneBmp) != 0 ||
                StrCmpI(szWasHTMLPath, szHTMLPath) != 0 ||
                StrCmp (szWasSender, szSender) != 0 ||
                StrCmpI(szWasReply, szReply) != 0)
                g_fInsDirty = TRUE;
        }

        //----- Serialize data to the *.ins file -----
        if (!fCheckDirtyOnly)
        {
            // clear of the old entries and associated images.
            ImportOEInfo(g_szInsFile, g_szWorkDir, FALSE);

            WritePrivateProfileString(IS_INTERNETMAIL, IK_INFOPANE,       szInfopane,    g_szInsFile);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_INFOPANEBMP,    szInfopaneBmp, g_szInsFile);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEMESSAGE, szHTMLPath,    g_szInsFile);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_WELCOMENAME,    szSender,      g_szInsFile);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEADDR,    szReply,       g_szInsFile);

            PathCombine(szWorkDir, g_szWorkDir, TEXT("oe.wrk"));
            ImportOEInfo(g_szInsFile, szWorkDir, TRUE);
        }

        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Signature

INT_PTR CALLBACK Signature(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf1[1024],
          szBuf2[1024];
    BOOL  fUseMailForNews,
          fDoSig,
          fHtmlMail,
          fHtmlNews,
          fCheckDirtyOnly,
          fEnable;

    switch (msg)
    {
    case WM_INITDIALOG:
        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_MAILSIGTEXT);
        EnableDBCSChars(hDlg, IDE_NEWSSIGTEXT);

        Edit_LimitText(GetDlgItem(hDlg, IDE_MAILSIGTEXT), countof(szBuf1)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_NEWSSIGTEXT), countof(szBuf1)-1);

        //----- Initialization of fields -----
        fUseMailForNews = (BOOL)GetPrivateProfileInt(IS_MAILSIG, IK_USEMAILFORNEWS, FALSE, g_szInsFile);
        fDoSig          = (BOOL)GetPrivateProfileInt(IS_MAILSIG, IK_USESIG,         FALSE, g_szInsFile);

        fHtmlMail       = (BOOL)GetPrivateProfileInt(IS_INTERNETMAIL, IK_HTMLMSGS,  TRUE,  g_szInsFile);
        fHtmlNews       = (BOOL)GetPrivateProfileInt(IS_INTERNETNEWS, IK_HTMLMSGS,  FALSE, g_szInsFile);

        GetPrivateProfileString(IS_MAILSIG, IK_SIGTEXT, c_szEmpty, szBuf1, countof(szBuf1), g_szInsFile);
        EncodeSignature(szBuf1, szBuf2, FALSE);
        SetDlgItemText(hDlg, IDE_MAILSIGTEXT, szBuf2);

        if (!fUseMailForNews)
        {
            GetPrivateProfileString(IS_SIG, IK_SIGTEXT, c_szEmpty, szBuf1, countof(szBuf1), g_szInsFile);
            EncodeSignature(szBuf1, szBuf2, FALSE);
            SetDlgItemText(hDlg, IDE_NEWSSIGTEXT, szBuf2);
        }

        //----- Set up dialog controls -----
        // Note. Some of it is done above already;
        CheckDlgButton(hDlg, IDC_MAILSIGTEXT, fDoSig ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_NEWSSIGTEXT, (fDoSig && !fUseMailForNews) ? BST_CHECKED : BST_UNCHECKED);
        
        EnableDlgItem2(hDlg, IDE_MAILSIGTEXT, fDoSig);
        EnableDlgItem2(hDlg, IDC_NEWSSIGTEXT, fDoSig);
        EnableDlgItem2(hDlg, IDE_NEWSSIGTEXT, fDoSig && !fUseMailForNews);

        CheckDlgButton(hDlg, IDC_HTMLMAIL, fHtmlMail ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_HTMLNEWS, fHtmlNews ? BST_CHECKED : BST_UNCHECKED);
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDC_MAILSIGTEXT:
            case IDC_NEWSSIGTEXT:
                fEnable = (IsDlgButtonChecked(hDlg, IDC_MAILSIGTEXT) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_MAILSIGTEXT, fEnable);

                EnableDlgItem2(hDlg, IDC_NEWSSIGTEXT, fEnable);

                fEnable &= (IsDlgButtonChecked(hDlg, IDC_NEWSSIGTEXT) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_NEWSSIGTEXT, fEnable);
                break;
            }
            break;

        default:
            return FALSE;
        }
        break;

    case UM_SAVE:
        fCheckDirtyOnly = (BOOL) lParam;

        //----- Read data from controls into internal variables -----
        fUseMailForNews = (IsDlgButtonChecked(hDlg, IDC_NEWSSIGTEXT) != BST_CHECKED);
        fDoSig          = (IsDlgButtonChecked(hDlg, IDC_MAILSIGTEXT) == BST_CHECKED);

        fHtmlMail       = (IsDlgButtonChecked(hDlg, IDC_HTMLMAIL)    == BST_CHECKED);
        fHtmlNews       = (IsDlgButtonChecked(hDlg, IDC_HTMLNEWS)    == BST_CHECKED);

        //----- Handle g_fInsDirty flag -----
        if (!g_fInsDirty)
        {
            BOOL  fChgMailSig,
                  fChgNewsSig,
                  fWasUseMailForNews,
                  fWasHtmlMail,
                  fWasHtmlNews,
                  fWasDoSig;

            GetPrivateProfileString(IS_MAILSIG, IK_SIGTEXT, c_szEmpty, szBuf1, countof(szBuf1), g_szInsFile);
            EncodeSignature(szBuf1, szBuf2, FALSE);
            GetDlgItemText(hDlg, IDE_MAILSIGTEXT, szBuf1, countof(szBuf1));
            fChgMailSig = (StrCmp(szBuf1, szBuf2) != 0);

            GetPrivateProfileString(IS_SIG, IK_SIGTEXT, c_szEmpty, szBuf1, countof(szBuf1), g_szInsFile);
            EncodeSignature(szBuf1, szBuf2, FALSE);
            GetDlgItemText(hDlg, IDE_NEWSSIGTEXT, szBuf1, countof(szBuf1));
            fChgNewsSig = (StrCmp(szBuf1, szBuf2) != 0);

            fWasUseMailForNews = (BOOL)GetPrivateProfileInt(IS_MAILSIG,  IK_USEMAILFORNEWS, FALSE, g_szInsFile);
            fWasDoSig          = (BOOL)GetPrivateProfileInt(IS_MAILSIG,  IK_USESIG,         FALSE, g_szInsFile);

            fWasHtmlMail       = (BOOL)GetPrivateProfileInt(IS_INTERNETMAIL, IK_HTMLMSGS,   TRUE,  g_szInsFile);
            fWasHtmlNews       = (BOOL)GetPrivateProfileInt(IS_INTERNETNEWS, IK_HTMLMSGS,   FALSE, g_szInsFile);

            if (fChgMailSig                           ||
                fChgNewsSig                           ||
                fWasUseMailForNews != fUseMailForNews ||
                fWasDoSig          != fDoSig          ||
                fWasHtmlMail       != fHtmlMail       ||
                fWasHtmlNews       != fHtmlNews)
                g_fInsDirty = TRUE;
        }

        //----- Serialize data to the *.ins file (main part) -----
        if (!fCheckDirtyOnly)
        {
            GetDlgItemText(hDlg, IDE_MAILSIGTEXT, szBuf1, countof(szBuf1));
            EncodeSignature(szBuf1, szBuf2, TRUE);
            WritePrivateProfileString(MAIL_SIG, SIG_TEXT, szBuf2, g_szInsFile);

            GetDlgItemText(hDlg, IDE_NEWSSIGTEXT, szBuf1, countof(szBuf1));
            EncodeSignature(szBuf1, szBuf2, TRUE);
            WritePrivateProfileString(SIGNATURE, SIG_TEXT, szBuf2, g_szInsFile);

            // Note. Some of it is done above already.
            WritePrivateProfileString(IS_MAILSIG, IK_USEMAILFORNEWS, fUseMailForNews ? c_sz1 : c_sz0, g_szInsFile);
            WritePrivateProfileString(IS_MAILSIG, IK_USESIG,         fDoSig          ? c_sz1 : c_sz0, g_szInsFile);
            WritePrivateProfileString(IS_SIG,     IK_USESIG,         fDoSig          ? c_sz1 : c_sz0, g_szInsFile);

            WritePrivateProfileString(IS_INTERNETMAIL, IK_HTMLMSGS,  fHtmlMail       ? c_sz1 : c_sz0, g_szInsFile);
            WritePrivateProfileString(IS_INTERNETNEWS, IK_HTMLMSGS,  fHtmlNews       ? c_sz1 : c_sz0, g_szInsFile);
        }

        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;

    default:
        return FALSE;

    }

    return TRUE;
}

#define CBSECTION 1024

void InitializeNewsgroups(HWND hwnd, LPCTSTR pszSection, LPCTSTR pszValue, LPCTSTR pszFile)
{
    LPTSTR pszGroups, psz, pszDest;
    TCHAR szGroupSection[256];
    DWORD dw;

    dw =  GetPrivateProfileString(pszSection, pszValue, c_szEmpty, szGroupSection, countof(szGroupSection), pszFile);
    if (dw > 0)
    {
        pszGroups = (LPTSTR)LocalAlloc(LMEM_FIXED, StrCbFromCch(CBSECTION));
        if (pszGroups != NULL)
        {
            dw = GetPrivateProfileSection(szGroupSection, pszGroups, CBSECTION, pszFile);
            if (dw > 0)
            {
                psz = pszGroups;
                pszDest = pszGroups;
                while (*psz != 0)
                {
                    while (*psz != 0 && *psz != '=')
                    {
                        *pszDest = *psz;
                        psz++;
                        pszDest++;
                    }

                    if (*psz != 0)
                    {
                        psz++;
                        while (*psz != 0)
                            psz++;
                    }
                    psz++;

                    *pszDest = 0x0d;
                    pszDest++;
                    *pszDest = 0x0a;
                    pszDest++;
                }

                *pszDest = 0;
            }

            SetWindowText(hwnd, pszGroups);

            LocalFree(pszGroups);
        }
    }
}

void SaveNewsgroups(HWND hwnd, LPCTSTR pszSection, LPCTSTR pszValue, LPCTSTR pszFile)
{
    LPTSTR pszGroups, psz, pszDest, pszDestT;
    TCHAR szGroupSection[256];
    DWORD dw, cch;
    BOOL fGroups;

    fGroups = FALSE;

    cch = GetWindowTextLength(hwnd);
    if (cch > 0)
    {
        cch += 4;
        pszGroups = (LPTSTR)LocalAlloc(LMEM_FIXED, StrCbFromCch(cch));
        if (pszGroups != NULL)
        {
            cch = GetWindowText(hwnd, pszGroups, cch);
            psz = pszGroups;
            pszDest = pszGroups;
            pszDestT = pszDest;

            while (*psz != 0)
            {
                if (*psz == '\r' && *(psz + 1) == '\n')
                {
                    psz += 2;
                    if (pszDest > pszDestT)
                    {
                        *pszDest = '=';
                        pszDest++;
                        *pszDest = 0;
                        pszDest++;

                        pszDestT = pszDest;
                        fGroups = TRUE;
                    }
                    continue;
                }
                else if (*psz != '\t' && *psz != ' ' && *psz != '\r' && *psz != '\n')
                {
                    *pszDest = *psz;
                    pszDest++;
                }

                psz++;
            }

            if (pszDest > pszDestT)
            {
                *pszDest = '=';
                pszDest++;
                *pszDest = 0;
                pszDest++;
            }
            *pszDest = 0;

            if (fGroups)
            {
                dw =  GetPrivateProfileString(pszSection, pszValue, c_szEmpty, szGroupSection, countof(szGroupSection), pszFile);
                if (dw == 0)
                    lstrcpy(szGroupSection, IK_NEWSGROUPLIST);

                WritePrivateProfileString(pszSection, pszValue, szGroupSection, pszFile);
                WritePrivateProfileSection(szGroupSection, pszGroups, pszFile);
            }

            LocalFree(pszGroups);
        }
    }

    if (!fGroups)
    {
        dw =  GetPrivateProfileString(pszSection, pszValue, c_szEmpty, szGroupSection, countof(szGroupSection), pszFile);
        if (dw > 0)
            WritePrivateProfileSection(szGroupSection, NULL, pszFile);

        WritePrivateProfileString(pszSection, pszValue, NULL, pszFile);
    }
}

/////////////////////////////////////////////////////////////////////////////
// PreConfigSettings
INT_PTR CALLBACK PreConfigSettings(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fDefMail,
            fDefNews,
#if defined(CONDITIONAL_JUNKMAIL)
            fJunkMail,
#endif
            fDeleteLinks,
            fCheckDirtyOnly;
    TCHAR   szServiceName[MAX_PATH],
            szServiceURL[INTERNET_MAX_URL_LENGTH];

    switch(msg)
    {
    case WM_INITDIALOG:
        //----- Set up dialog controls -----
        // EnableDBCSChars(hDlg, IDE_NGROUPS);
        EnableDBCSChars(hDlg, IDE_SERVICENAME);
        EnableDBCSChars(hDlg, IDE_SERVICEURL);

        Edit_LimitText(GetDlgItem(hDlg, IDE_SERVICENAME),   countof(szServiceName)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SERVICEURL),    countof(szServiceURL)-1);

#if defined(CONDITIONAL_JUNKMAIL)
        //----- Initialization of fields -----
        fJunkMail  = InsGetYesNo(IS_INTERNETMAIL, IK_JUNKMAIL,      FALSE, g_szInsFile);
#endif
        fDefMail   = InsGetYesNo(IS_INTERNETMAIL, IK_DEFAULTCLIENT, FALSE, g_szInsFile);
        fDefNews   = InsGetYesNo(IS_INTERNETNEWS, IK_DEFAULTCLIENT, FALSE, g_szInsFile);
        fDeleteLinks = InsGetBool(IS_OUTLKEXP, IK_DELETELINKS, FALSE, g_szInsFile);

        GetPrivateProfileString(IS_OEGLOBAL,     IK_SERVICENAME, c_szEmpty, szServiceName, countof(szServiceName), g_szInsFile);
        GetPrivateProfileString(IS_OEGLOBAL,     IK_SERVICEURL,  c_szEmpty, szServiceURL,  countof(szServiceURL),  g_szInsFile);

        StrRemoveWhitespace(szServiceName);
        StrRemoveWhitespace(szServiceURL);

        //----- Set up dialog controls -----
        CheckDlgButton(hDlg, IDC_DEFMAIL, fDefMail ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_DEFNEWS, fDefNews ? BST_CHECKED : BST_UNCHECKED);
#if defined(CONDITIONAL_JUNKMAIL)
        CheckDlgButton(hDlg, IDC_JUNKMAIL,fJunkMail? BST_CHECKED : BST_UNCHECKED);
#endif
        CheckDlgButton(hDlg, IDC_DELETELINKS, fDeleteLinks ? BST_CHECKED : BST_UNCHECKED);

        InitializeNewsgroups(GetDlgItem(hDlg, IDE_NGROUPS), IS_INTERNETNEWS, IK_NEWSGROUPS, g_szInsFile);
        SendDlgItemMessage(hDlg, IDE_NGROUPS, EM_SETMODIFY, 0, 0);

        SetDlgItemText(hDlg, IDE_SERVICENAME,   szServiceName);
        SetDlgItemText(hDlg, IDE_SERVICEURL,    szServiceURL);
        break;

    case UM_SAVE:
        fCheckDirtyOnly = (BOOL) lParam;

        //----- Read data from controls into internal variables -----
        fDefMail = (IsDlgButtonChecked(hDlg, IDC_DEFMAIL)     == BST_CHECKED);
        fDefNews = (IsDlgButtonChecked(hDlg, IDC_DEFNEWS)     == BST_CHECKED);
#if defined(CONDITIONAL_JUNKMAIL)
        fJunkMail= (IsDlgButtonChecked(hDlg, IDC_JUNKMAIL)    == BST_CHECKED);
#endif
        fDeleteLinks = (IsDlgButtonChecked(hDlg, IDC_DELETELINKS) == BST_CHECKED);

        GetDlgItemText(hDlg, IDE_SERVICENAME, szServiceName, countof(szServiceName));
        GetDlgItemText(hDlg, IDE_SERVICEURL,  szServiceURL,  countof(szServiceURL));

        StrRemoveWhitespace(szServiceName);
        StrRemoveWhitespace(szServiceURL);

        //----- Validate the input -----
        if (!fCheckDirtyOnly)
        {
            if (ISNONNULL(szServiceName) || ISNONNULL(szServiceURL))
            {
                if (!CheckField(hDlg, IDE_SERVICENAME, FC_NONNULL))
                    return(TRUE);

                if (!CheckField(hDlg, IDE_SERVICEURL, FC_URL | FC_NONNULL))
                    return(TRUE);
            }
        }

        //----- Handle g_fInsDirty flag -----
        if (!g_fInsDirty)
        {
            BOOL    fWasDefMail,
#if defined(CONDITIONAL_JUNKMAIL)
                    fWasJunkMail,
#endif
                    fWasDefNews,
                    fWasDeleteLinks;

            TCHAR   szWasRulesFile[MAX_PATH],
                    szWasServiceName[MAX_PATH],
                    szWasServiceURL[INTERNET_MAX_URL_LENGTH];

            fWasDefMail   = InsGetYesNo(IS_INTERNETMAIL, IK_DEFAULTCLIENT, FALSE, g_szInsFile);
            fWasDefNews   = InsGetYesNo(IS_INTERNETNEWS, IK_DEFAULTCLIENT, FALSE, g_szInsFile);
#if defined(CONDITIONAL_JUNKMAIL)
            fWasJunkMail  = InsGetYesNo(IS_INTERNETMAIL, IK_JUNKMAIL,      FALSE, g_szInsFile);
#endif
            fWasDeleteLinks = InsGetBool(IS_OUTLKEXP, IK_DELETELINKS, FALSE, g_szInsFile);

            GetPrivateProfileString(IS_OEGLOBAL,     IK_SERVICENAME, c_szEmpty, szWasServiceName, countof(szWasServiceName), g_szInsFile);
            GetPrivateProfileString(IS_OEGLOBAL,     IK_SERVICEURL,  c_szEmpty, szWasServiceURL,  countof(szWasServiceURL),  g_szInsFile);

            StrRemoveWhitespace(szWasServiceName);
            StrRemoveWhitespace(szWasServiceURL);
            StrRemoveWhitespace(szWasRulesFile);

            if (fDefMail != fWasDefMail ||
                fDefNews != fWasDefNews ||
#if defined(CONDITIONAL_JUNKMAIL)
                fJunkMail != fWasJunkMail ||
#endif
                fDeleteLinks != fWasDeleteLinks || 
                SendDlgItemMessage(hDlg, IDE_NGROUPS, EM_GETMODIFY, 0, 0) ||
                StrCmpI(szServiceName, szWasServiceName) != 0 ||
                StrCmpI(szServiceURL, szWasServiceURL) != 0)
                g_fInsDirty = TRUE;
        }

        //----- Serialize data to the *.ins file -----
        if (!fCheckDirtyOnly)
        {
            WritePrivateProfileString(IS_INTERNETMAIL, IK_DEFAULTCLIENT, fDefMail ? c_szYes : c_szNo, g_szInsFile);
            WritePrivateProfileString(IS_INTERNETNEWS, IK_DEFAULTCLIENT, fDefNews ? c_szYes : c_szNo, g_szInsFile);
#if defined(CONDITIONAL_JUNKMAIL)
            WritePrivateProfileString(IS_INTERNETMAIL, IK_JUNKMAIL,      fJunkMail? c_sz1   : c_sz0,  g_szInsFile);
#endif
            InsWriteBool(IS_OUTLKEXP, IK_DELETELINKS, fDeleteLinks? c_sz1 : NULL, g_szInsFile);

            SaveNewsgroups(GetDlgItem(hDlg, IDE_NGROUPS), IS_INTERNETNEWS, IK_NEWSGROUPS, g_szInsFile);

            WritePrivateProfileString(IS_OEGLOBAL,     IK_SERVICENAME,  szServiceName, g_szInsFile);
            WritePrivateProfileString(IS_OEGLOBAL,     IK_SERVICEURL,   szServiceURL,  g_szInsFile);
        }

        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// ViewSettings
INT_PTR CALLBACK ViewSettings(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fFolderBar,
            fFolderList,
            fContacts,
            fTip,
            fStatus,
            fToolbar,
            fToolbarText,
            fOutlook,
            fPreview,
            fPreviewHdr,
            fPreviewSide,
            fCheckDirtyOnly;
    LPCTSTR  psz;

    switch(msg)
    {
    case WM_INITDIALOG:

        //----- Initialization of fields -----
        fFolderBar   = GetPrivateProfileInt(IS_OUTLKEXP, IK_FOLDERBAR,      TRUE,  g_szInsFile);
        fFolderList  = GetPrivateProfileInt(IS_OUTLKEXP, IK_FOLDERLIST,     TRUE,  g_szInsFile);
        fOutlook     = GetPrivateProfileInt(IS_OUTLKEXP, IK_OUTLOOKBAR,     FALSE, g_szInsFile);
        fStatus      = GetPrivateProfileInt(IS_OUTLKEXP, IK_STATUSBAR,      TRUE,  g_szInsFile);
        fContacts    = GetPrivateProfileInt(IS_OUTLKEXP, IK_CONTACTS,       TRUE,  g_szInsFile);
        fTip         = GetPrivateProfileInt(IS_OUTLKEXP, IK_TIPOFTHEDAY,    TRUE,  g_szInsFile);

        fToolbar = GetPrivateProfileInt(IS_OUTLKEXP, IK_TOOLBAR, TRUE,  g_szInsFile);
        if (fToolbar)
            fToolbarText = GetPrivateProfileInt(IS_OUTLKEXP, IK_TOOLBARTEXT, TRUE, g_szInsFile);
        else
            fToolbarText = TRUE;

        fPreview = GetPrivateProfileInt(IS_OUTLKEXP, IK_PREVIEWPANE, TRUE, g_szInsFile);
        if (fPreview)
        {
            fPreviewHdr = GetPrivateProfileInt(IS_OUTLKEXP, IK_PREVIEWHDR, TRUE, g_szInsFile);
            fPreviewSide = GetPrivateProfileInt(IS_OUTLKEXP, IK_PREVIEWSIDE, FALSE, g_szInsFile);
        }
        else
        {
            fPreviewHdr = TRUE;
            fPreviewSide = FALSE;
        }

        //----- Set up dialog controls -----
        CheckDlgButton(hDlg, IDC_FOLDERBAR,  fFolderBar  ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_FOLDERLIST, fFolderList ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_OUTLOOKBAR, fOutlook    ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_STATUSBAR,  fStatus     ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_CONTACTS,   fContacts   ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_TIPOFDAY,   fTip        ? BST_CHECKED : BST_UNCHECKED);

        CheckDlgButton(hDlg, IDC_TOOLBAR, fToolbar ? BST_CHECKED : BST_UNCHECKED);
        if (!fToolbar)
            SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_TOOLBAR, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, IDC_TOOLBAR));
        CheckDlgButton(hDlg, IDC_TBARTEXT, fToolbarText ? BST_CHECKED : BST_UNCHECKED);

        CheckDlgButton(hDlg, IDC_PREVIEW, fPreview ? BST_CHECKED : BST_UNCHECKED);
        if (!fPreview)
            SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_PREVIEW, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, IDC_PREVIEW));
        CheckDlgButton(hDlg, fPreviewSide ? IDC_SPLITVERT : IDC_SPLITHORZ, BST_CHECKED);
        CheckDlgButton(hDlg, IDC_PREVIEWHDR, fPreviewHdr ? BST_CHECKED : BST_UNCHECKED);
        break;

    case WM_COMMAND:
        if (BN_CLICKED == HIWORD(wParam))
        {
            switch (LOWORD(wParam))
            {
            case IDC_TOOLBAR:
                fToolbar = IsDlgButtonChecked(hDlg, IDC_TOOLBAR);
                EnableDlgItem2(hDlg, IDC_TBARTEXT, fToolbar);
                break;

            case IDC_PREVIEW:
                fPreview = IsDlgButtonChecked(hDlg, IDC_PREVIEW);
                EnableDlgItem2(hDlg, IDC_SPLITVERT, fPreview);
                EnableDlgItem2(hDlg, IDC_SPLITHORZ, fPreview);
                EnableDlgItem2(hDlg, IDC_PREVIEWHDR, fPreview);
                break;
            }
            break;
        }
        break;

    case UM_SAVE:
        fCheckDirtyOnly = (BOOL) lParam;

        //----- Read data from controls into internal variables -----
        fFolderBar  = (IsDlgButtonChecked(hDlg, IDC_FOLDERBAR)  == BST_CHECKED);
        fFolderList = (IsDlgButtonChecked(hDlg, IDC_FOLDERLIST) == BST_CHECKED);
        fOutlook    = (IsDlgButtonChecked(hDlg, IDC_OUTLOOKBAR) == BST_CHECKED);
        fStatus     = (IsDlgButtonChecked(hDlg, IDC_STATUSBAR)  == BST_CHECKED);
        fContacts   = (IsDlgButtonChecked(hDlg, IDC_CONTACTS)   == BST_CHECKED);
        fTip        = (IsDlgButtonChecked(hDlg, IDC_TIPOFDAY)   == BST_CHECKED);

        fToolbar     = (IsDlgButtonChecked(hDlg, IDC_TOOLBAR)  == BST_CHECKED);
        fToolbarText = (IsDlgButtonChecked(hDlg, IDC_TBARTEXT) == BST_CHECKED);

        fPreview     = (IsDlgButtonChecked(hDlg, IDC_PREVIEW)    == BST_CHECKED);
        fPreviewSide = (IsDlgButtonChecked(hDlg, IDC_SPLITVERT)  == BST_CHECKED);
        fPreviewHdr  = (IsDlgButtonChecked(hDlg, IDC_PREVIEWHDR) == BST_CHECKED);

        //----- Handle g_fInsDirty flag -----
        if (!g_fInsDirty)
        {
            BOOL    fWasFolderBar,
                    fWasFolderList,
                    fWasContacts,
                    fWasTip,
                    fWasStatus,
                    fWasToolbar,
                    fWasToolbarText,
                    fWasOutlook,
                    fWasPreview,
                    fWasPreviewHdr,
                    fWasPreviewSide;

            fWasFolderBar   = GetPrivateProfileInt(IS_OUTLKEXP, IK_FOLDERBAR,      TRUE,  g_szInsFile);
            fWasFolderList  = GetPrivateProfileInt(IS_OUTLKEXP, IK_FOLDERLIST,     TRUE,  g_szInsFile);
            fWasOutlook     = GetPrivateProfileInt(IS_OUTLKEXP, IK_OUTLOOKBAR,     FALSE, g_szInsFile);
            fWasStatus      = GetPrivateProfileInt(IS_OUTLKEXP, IK_STATUSBAR,      TRUE,  g_szInsFile);
            fWasContacts    = GetPrivateProfileInt(IS_OUTLKEXP, IK_CONTACTS,       TRUE,  g_szInsFile);
            fWasTip         = GetPrivateProfileInt(IS_OUTLKEXP, IK_TIPOFTHEDAY,    TRUE,  g_szInsFile);
            fWasToolbar     = GetPrivateProfileInt(IS_OUTLKEXP, IK_TOOLBAR,        TRUE,  g_szInsFile);
            fWasToolbarText = GetPrivateProfileInt(IS_OUTLKEXP, IK_TOOLBARTEXT,    TRUE,  g_szInsFile);
            fWasPreview     = GetPrivateProfileInt(IS_OUTLKEXP, IK_PREVIEWPANE,    TRUE,  g_szInsFile);
            fWasPreviewHdr  = GetPrivateProfileInt(IS_OUTLKEXP, IK_PREVIEWHDR,     TRUE,  g_szInsFile);
            fWasPreviewSide = GetPrivateProfileInt(IS_OUTLKEXP, IK_PREVIEWSIDE,    FALSE, g_szInsFile);

            if (fFolderBar   != fWasFolderBar || 
                fFolderList  != fWasFolderList || 
                fContacts    != fWasContacts ||
                fTip         != fWasTip ||
                fStatus      != fWasStatus ||
                fToolbar     != fWasToolbar ||
                fToolbarText != fWasToolbarText ||
                fOutlook     != fWasOutlook ||
                fPreview     != fWasPreview ||
                fPreviewHdr  != fWasPreviewHdr ||
                fPreviewSide != fWasPreviewSide)
                g_fInsDirty = TRUE;
        }

        //----- Serialize data to the *.ins file -----
        if (!fCheckDirtyOnly)
        {
            WritePrivateProfileString(IS_OUTLKEXP, IK_FOLDERBAR,   fFolderBar  ? c_sz1 : c_sz0,  g_szInsFile);
            WritePrivateProfileString(IS_OUTLKEXP, IK_FOLDERLIST,  fFolderList ? c_sz1 : c_sz0,  g_szInsFile);
            WritePrivateProfileString(IS_OUTLKEXP, IK_OUTLOOKBAR,  fOutlook    ? c_sz1 : c_sz0,  g_szInsFile);
            WritePrivateProfileString(IS_OUTLKEXP, IK_STATUSBAR,   fStatus     ? c_sz1 : c_sz0,  g_szInsFile);
            WritePrivateProfileString(IS_OUTLKEXP, IK_CONTACTS,    fContacts   ? c_sz1 : c_sz0,  g_szInsFile);
            WritePrivateProfileString(IS_OUTLKEXP, IK_TIPOFTHEDAY, fTip        ? c_sz1 : c_sz0,  g_szInsFile);

            WritePrivateProfileString(IS_OUTLKEXP, IK_TOOLBAR, fToolbar ? c_sz1 : c_sz0,  g_szInsFile);
            if (fToolbar)
                psz = fToolbarText ? c_sz1 : c_sz0;
            else
                psz = NULL;
            WritePrivateProfileString(IS_OUTLKEXP, IK_TOOLBARTEXT, psz,  g_szInsFile);

            WritePrivateProfileString(IS_OUTLKEXP, IK_PREVIEWPANE, fPreview ? c_sz1 : c_sz0,  g_szInsFile);
            if (fPreview)
                psz = fPreviewHdr ? c_sz1 : c_sz0;
            else
                psz = NULL;
            WritePrivateProfileString(IS_OUTLKEXP, IK_PREVIEWHDR, psz,  g_szInsFile);
            if (fPreview)
                psz = fPreviewSide ? c_sz1 : c_sz0;
            else
                psz = NULL;
            WritePrivateProfileString(IS_OUTLKEXP, IK_PREVIEWSIDE, psz,  g_szInsFile);
        }

        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// LDAPFinalCopy

HRESULT LDAPFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState)
{
    TCHAR szFrom[MAX_PATH];

    PathCombine(szFrom, g_szWorkDir, TEXT("ldap.wrk"));

    if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && !PathIsEmptyPath(szFrom, FILES_ONLY))
        SetFlag(pdwCabState, CAB_TYPE_CONFIG);

    if (HasFlag(dwFlags, PM_COPY))
        CopyFileToDir(szFrom, pcszDestDir);
    
    if (HasFlag(dwFlags, PM_CLEAR))
        PathRemovePath(szFrom);
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// OEFinalCopy

HRESULT OEFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState)
{
    TCHAR szFrom[MAX_PATH];

    PathCombine(szFrom, g_szWorkDir, TEXT("oe.wrk"));

    if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && !PathIsEmptyPath(szFrom, FILES_ONLY))
        SetFlag(pdwCabState, CAB_TYPE_CONFIG);

    if (HasFlag(dwFlags, PM_COPY))
        CopyFileToDir(szFrom, pcszDestDir);
    
    if (HasFlag(dwFlags, PM_CLEAR))
        PathRemovePath(szFrom);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\favsproc.cpp ===
#include "pch.h"

INT_PTR CALLBACK FavsProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR      szValue[16];
    TCHAR      szUrl[INTERNET_MAX_URL_LENGTH];
    LPCTSTR    pszValue;
    HWND       hTv = GetDlgItem(hDlg, IDC_TREE1);
    BOOL       fQL,
               fFavoritesOnTop, fFavoritesDelete, fIEAKFavoritesDelete, fCheckDirtyOnly;
    DWORD      dwFavoritesDeleteFlags;

    switch (msg) {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDC_TREE1);

        MigrateFavorites(g_szInsFile);
        ASSERT(GetFavoritesNumber(hTv, FALSE) == 0 && GetFavoritesNumber(hTv, TRUE) == 0);
        ImportFavorites (hTv, g_szDefInf, g_szInsFile, NULL, g_szWorkDir, FALSE);
        ImportQuickLinks(hTv, g_szDefInf, g_szInsFile, NULL, g_szWorkDir, FALSE);

        TreeView_SelectItem(hTv, TreeView_GetRoot(hTv));
    
        fFavoritesOnTop = GetPrivateProfileInt(IS_BRANDING, IK_FAVORITES_ONTOP, (int)FALSE, g_szInsFile);
        CheckDlgButton(hDlg, IDC_FAVONTOP, fFavoritesOnTop ? BST_CHECKED : BST_UNCHECKED);

        if (!fFavoritesOnTop) {
            DisableDlgItem(hDlg, IDC_FAVUP);
            DisableDlgItem(hDlg, IDC_FAVDOWN);
        }

        dwFavoritesDeleteFlags = (DWORD) GetPrivateProfileInt(IS_BRANDING, IK_FAVORITES_DELETE, (int)FD_DEFAULT, g_szInsFile);

        fFavoritesDelete = HasFlag(dwFavoritesDeleteFlags, ~FD_REMOVE_IEAK_CREATED);
        CheckDlgButton(hDlg, IDC_DELFAVORITES, fFavoritesDelete ? BST_CHECKED : BST_UNCHECKED);

        fIEAKFavoritesDelete = HasFlag(dwFavoritesDeleteFlags, FD_REMOVE_IEAK_CREATED);
        CheckDlgButton(hDlg, IDC_DELIEAKFAVORITES, fIEAKFavoritesDelete ? BST_CHECKED : BST_UNCHECKED);

        // only if delete Favorites is TRUE should the delete IEAK Favorites checkbox be enabled
        EnableWindow(GetDlgItem(hDlg, IDC_DELIEAKFAVORITES), fFavoritesDelete);
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam)) {
        case BN_CLICKED:
            switch (LOWORD(wParam)) {
            case IDC_FAVONTOP:
                if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_FAVONTOP)) {
                    HTREEITEM hti;
                    TV_ITEM   tvi;

                    EnableDlgItem(hDlg, IDC_FAVONTOP);

                    hti = TreeView_GetSelection(hTv);
                    if (hti != NULL) {
                        ZeroMemory(&tvi, sizeof(tvi));
                        tvi.mask  = TVIF_STATE;
                        tvi.hItem = hti;
                        TreeView_GetItem(hTv, &tvi);

                        if (!HasFlag(tvi.state, TVIS_BOLD)) {
                            EnableDlgItem2(hDlg, IDC_FAVUP,   (NULL != TreeView_GetPrevSibling(hTv, hti)));
                            EnableDlgItem2(hDlg, IDC_FAVDOWN, (NULL != TreeView_GetNextSibling(hTv, hti)));
                        }
                    }
                }
                else {
                    DisableDlgItem(hDlg, IDC_FAVUP);
                    DisableDlgItem(hDlg, IDC_FAVDOWN);
                }
                break;

            case IDC_DELFAVORITES:
                fFavoritesDelete = (IsDlgButtonChecked(hDlg, IDC_DELFAVORITES) == BST_CHECKED);
                EnableWindow(GetDlgItem(hDlg, IDC_DELIEAKFAVORITES), fFavoritesDelete);
                break;

            case IDC_FAVUP:
                if (MoveUpFavorite(hTv, TreeView_GetSelection(hTv)))
                    g_fInsDirty = TRUE;
                SetFocus(GetDlgItem(hDlg, IDC_TREE1));
                break;

            case IDC_FAVDOWN:
                if (MoveDownFavorite(hTv, TreeView_GetSelection(hTv)))
                    g_fInsDirty = TRUE;
                SetFocus(GetDlgItem(hDlg, IDC_TREE1));
                break;

            case IDC_ADDURL:
                fQL = !IsFavoriteItem(hTv, TreeView_GetSelection(hTv));
                if (GetFavoritesNumber(hTv, fQL) >= GetFavoritesMaxNumber(fQL)) {
                    UINT nID;

                    nID = (!fQL ? IDS_ERROR_MAXFAVS : IDS_ERROR_MAXQLS);
                    ErrorMessageBox(hDlg, nID);
                    break;
                }

                if (NewUrl(hTv, g_szWorkDir, g_dwPlatformId, IEM_PROFMGR))
                    g_fInsDirty = TRUE;
                RedrawWindow(hTv, NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE);
                SetFocus(GetDlgItem(hDlg, IDC_ADDURL));
                break;

            case IDC_ADDFOLDER:
                ASSERT(IsFavoriteItem(hTv, TreeView_GetSelection(hTv)));
                if (GetFavoritesNumber(hTv) >= GetFavoritesMaxNumber()) {
                    ErrorMessageBox(hDlg, IDS_ERROR_MAXFAVS);
                    break;
                }

                if (NewFolder(hTv))
                    g_fInsDirty = TRUE;
                RedrawWindow(hTv, NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE);
                SetFocus(GetDlgItem(hDlg, IDC_ADDFOLDER));
                break;

            case IDC_MODIFY:
                if (ModifyFavorite(hTv, TreeView_GetSelection(hTv), g_szWorkDir, g_szWorkDir, g_dwPlatformId, IEM_PROFMGR))
                    g_fInsDirty = TRUE;
                RedrawWindow(hTv, NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE);
                SetFocus(GetDlgItem(hDlg, IDC_MODIFY));
                break;

            case IDC_REMOVE:
                if (DeleteFavorite(hTv, TreeView_GetSelection(hTv), g_szWorkDir))
                    g_fInsDirty = TRUE;
                break;

            case IDC_TESTFAVURL:
                if (GetFavoriteUrl(hTv, TreeView_GetSelection(hTv), szUrl, ARRAYSIZE(szUrl)))
                    TestURL(szUrl);
                SetFocus(GetDlgItem(hDlg, IDC_TESTFAVURL));
                break;

            case IDC_IMPORT: {
                CNewCursor cursor(IDC_WAIT);

                if (ImportFavoritesCmd(hTv, g_szWorkDir) > 0)
                    g_fInsDirty = TRUE;
                SetFocus(GetDlgItem(hDlg, IDC_IMPORT));
                break;
            }
            }
            break;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code) {
        case TVN_GETINFOTIP: 
            ASSERT(wParam == IDC_TREE1);
            GetFavoritesInfoTip((NMTVGETINFOTIP *)lParam);
            break;

        case NM_DBLCLK:
            ASSERT(wParam == IDC_TREE1);
            if (IsWindowEnabled(GetDlgItem(hDlg, IDC_MODIFY)))
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_MODIFY, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, IDC_MODIFY));
            break;

        case TVN_KEYDOWN:
            ASSERT(wParam == IDC_TREE1);
            if (((LPNMTVKEYDOWN)lParam)->wVKey == VK_DELETE && IsWindowEnabled(GetDlgItem(hDlg, IDC_REMOVE)))
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_REMOVE, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, IDC_REMOVE));
            break;

        case TVN_SELCHANGED: 
            ASSERT(wParam == IDC_TREE1);
            ProcessFavSelChange(hDlg, hTv, (LPNMTREEVIEW)lParam);
            break;

        default:
            return FALSE;
        }
        break;

    case UM_SAVE:
        fCheckDirtyOnly = (BOOL) lParam;
        fFavoritesOnTop = (IsDlgButtonChecked(hDlg, IDC_FAVONTOP) == BST_CHECKED);

        dwFavoritesDeleteFlags = 0;
        szValue[0]             = TEXT('\0');
        pszValue               = NULL;
        fFavoritesDelete       = (IsDlgButtonChecked(hDlg, IDC_DELFAVORITES)     == BST_CHECKED);
        fIEAKFavoritesDelete   = (IsDlgButtonChecked(hDlg, IDC_DELIEAKFAVORITES) == BST_CHECKED);

        if (!g_fInsDirty) {
            BOOL fTemp;
            DWORD dwTemp;

            // check to see if there is a old favorites section.
            // if there isn't a section, set the dirty flag to TRUE so that we write 
            // the old section for backward compatibility.
            if (GetFavoritesNumber(hTv) > 1)
            {
                if (!GetPrivateProfileSection(IS_FAVORITES, szValue, countof(szValue), g_szInsFile))
                    g_fInsDirty = TRUE;
            }

            dwTemp = (DWORD) GetPrivateProfileInt(IS_BRANDING, IK_FAVORITES_DELETE, (int)FD_DEFAULT, g_szInsFile);

            fTemp = HasFlag(dwTemp, ~FD_REMOVE_IEAK_CREATED);
            if (fTemp != fFavoritesDelete)
                g_fInsDirty = TRUE;

            fTemp = HasFlag(dwTemp, FD_REMOVE_IEAK_CREATED);
            if (fTemp != fIEAKFavoritesDelete)
                g_fInsDirty = TRUE;

            fTemp = GetPrivateProfileInt(IS_BRANDING, IK_FAVORITES_ONTOP, (int)FALSE, g_szInsFile);
            if (fTemp != fFavoritesOnTop)
                g_fInsDirty = TRUE;
        }

        if (!fCheckDirtyOnly) {
            if (fFavoritesDelete) {
                // NOTE. (andrewgu) flags explanation:
                // 1. FD_FAVORITES        means "empty favorites";
                // 2. FD_CHANNELS         means "don't delete channels folder";
                // 3. FD_SOFTWAREUPDATES  means "don't delete sofware updates folder";
                // 4. FD_QUICKLINKS       means "don't delete quick links folder";
                // 5. FD_EMPTY_QUICKLINKS means "but make it empty";
                // 6. FD_REMOVE_HIDDEN    means "don't hesitate to party on HIDDEN folders and favorites";
                // 7. FD_REMOVE_SYSTEM    means "don't hesitate to party on SYSTEM folders and favorites";
                dwFavoritesDeleteFlags |= FD_FAVORITES      |
                    FD_CHANNELS        | FD_SOFTWAREUPDATES | FD_QUICKLINKS | FD_EMPTY_QUICKLINKS |
                    FD_REMOVE_HIDDEN   | FD_REMOVE_SYSTEM;
            }

            if (fIEAKFavoritesDelete)
                // FD_REMOVE_IEAK_CREATED means "delete those items created by the IEAK";
                dwFavoritesDeleteFlags |= FD_REMOVE_IEAK_CREATED;

            if (dwFavoritesDeleteFlags) {
                wsprintf(szValue, TEXT("0x%X"), dwFavoritesDeleteFlags);
                pszValue = szValue;
            }

            WritePrivateProfileString(IS_BRANDING, IK_FAVORITES_DELETE, pszValue, g_szInsFile);
            WritePrivateProfileString(IS_BRANDING, IK_FAVORITES_ONTOP, fFavoritesOnTop ? TEXT("1") : TEXT("0"), g_szInsFile);

            ExportFavorites (hTv, g_szInsFile, g_szWorkDir, TRUE);
            ExportQuickLinks(hTv, g_szInsFile, g_szWorkDir, TRUE);
            MigrateToOldFavorites(g_szInsFile);
        }
        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DeleteFavorite(hTv, TreeView_GetRoot(hTv), NULL);
        DeleteFavorite(hTv, TreeView_GetRoot(hTv), NULL);
        DestroyWindow(hDlg);
        return FALSE;

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wizard.rc
//

#define IDS_INSDLL_TITLE                1
#define IDS_IEAKUI_LOADERROR            2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        1001
#define _APS_NEXT_COMMAND_VALUE         20001
#define _APS_NEXT_CONTROL_VALUE         10001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\insdll.h ===
//
// INSDLL.H
//

#define UM_SAVE     WM_USER + 100

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

// prototype declarations
INT_PTR CALLBACK SoftwareUpdates            (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK MailServer                 (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK IMAPSettings               (HWND hDlg, UINT msg,  WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK PreConfigSettings          (HWND hDlg, UINT msg,  WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ViewSettings               (HWND hDlg, UINT msg,  WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LDAPServer                 (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK CustomizeOE                (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK Signature                  (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK QueryAutoConfigDlgProc     (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SecurityZonesDlgProc       (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SecurityCertsDlgProc       (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SecurityAuthDlgProc        (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ConnectionSettingsDlgProc  (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ProgramsDlgProc            (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

HRESULT BToolbarsFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT ChannelsFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT SoftwareUpdatesFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT LDAPFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT OEFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT DesktopFinalCopy(LPCTSTR psczDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT ToolbarFinalCopy(LPCTSTR psczDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT MccphttFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT ZonesFinalCopy(LPCTSTR psczDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT CertsFinalCopy(LPCTSTR psczDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT AuthFinalCopy(LPCTSTR psczDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT WallPaperFinalCopy(LPCTSTR psczDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT ConnectionSettingsFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState);
HRESULT ProgramsFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState);

HRESULT PrepareDlgTemplate(HINSTANCE hInst, UINT nDlgID, DWORD dwStyle, PVOID *ppvDT);

// extern declaration of global variables
extern HINSTANCE g_hInst;
extern LPTSTR    g_szInsFile;
extern TCHAR     g_szWorkDir[];
extern TCHAR     g_szDefInf[];
extern TCHAR     g_szFrom[5 * MAX_PATH];
extern HWND      g_hDlg;
extern TCHAR     g_szDefInf[];
extern DWORD     g_dwPlatformId;
extern BOOL      g_fUseShortFileName;
extern BOOL      g_fInsDirty;

#ifdef __cplusplus
}
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\programs.cpp ===
#include "pch.h"

INT_PTR CALLBACK ProgramsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        CheckRadioButton(hDlg, IDC_PROGNOIMPORT, IDC_PROGIMPORT, IDC_PROGNOIMPORT);
        EnableWindow(GetDlgItem(hDlg, IDC_MODIFYPROG), FALSE);
        return TRUE;

    case UM_SAVE:
        {
            TCHAR szProgWorkDir[MAX_PATH];
            BOOL fCheckDirtyOnly = (BOOL) lParam;
            
            if (IsDlgButtonChecked(hDlg, IDC_PROGIMPORT) == BST_CHECKED)
            {
                if (!fCheckDirtyOnly)
                {
                    PathCombine(szProgWorkDir, g_szWorkDir, TEXT("programs.wrk"));
                    ImportPrograms(g_szInsFile, szProgWorkDir, TRUE);

                    CheckRadioButton(hDlg, IDC_PROGNOIMPORT, IDC_PROGIMPORT, IDC_PROGNOIMPORT);
                    EnableWindow(GetDlgItem(hDlg, IDC_MODIFYPROG), FALSE);
                }
                g_fInsDirty = TRUE;
            }
        }
        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        return FALSE;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDC_PROGNOIMPORT:
                EnableWindow(GetDlgItem(hDlg, IDC_MODIFYPROG), FALSE);
                break;
                
            case IDC_PROGIMPORT:
                EnableWindow(GetDlgItem(hDlg, IDC_MODIFYPROG), TRUE);
                break;
                
            case IDC_MODIFYPROG:
                ShowInetcpl(hDlg, INET_PAGE_PROGRAMS);
                SetFocus(GetDlgItem(hDlg, IDC_MODIFYPROG));
                break;
            }
            break;
        }
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

HRESULT ProgramsFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState)
{
    TCHAR szFrom[MAX_PATH];

    PathCombine(szFrom, g_szWorkDir, TEXT("programs.wrk"));

    if ((HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL) || HasFlag(dwFlags, PM_COPY))
    {
        TCHAR szFile[MAX_PATH];

        PathCombine(szFile, szFrom, TEXT("programs.inf"));
        if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && PathFileExists(szFile))
            SetFlag(pdwCabState, CAB_TYPE_CONFIG);
        if (HasFlag(dwFlags, PM_COPY))
            CopyFileToDir(szFile, pcszDestDir);
    }

    if (HasFlag(dwFlags, PM_CLEAR))
        PathRemovePath(szFrom);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\insdll.cpp ===
#include "pch.h"

HINSTANCE g_hInst;
HINSTANCE g_hDllInst;
LPTSTR g_szInsFile;
TCHAR g_szWorkDir[MAX_PATH];
TCHAR g_szDefInf[MAX_PATH];
TCHAR g_szFrom[5 * MAX_PATH];
HWND  g_hDlg;

typedef struct _insdlg
{
    LPTSTR DlgId;
    LPTSTR szName;
    DLGPROC dlgproc;
    DWORD hItem;
    HRESULT (WINAPI *pfnFinalCopy)(LPCTSTR psczDestDir, DWORD dwFlags, LPDWORD pdwCabState);
} INSDLG, *LPINSDLG;

BOOL g_bInitialize = FALSE;
DWORD g_dwPlatformId = PLATFORM_WIN32;

INT_PTR CALLBACK TitleProc          ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK LogoProc           ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK CabSignProc        ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK SupportProc        ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK UserAgentProc      ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK ProxyProc          ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK BToolbarProc       ( HWND, UINT, WPARAM, LPARAM ); 
INT_PTR CALLBACK FavsProc           ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK StartSearchProc    ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK MailProc           ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK LdapProc           ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK SignatureProc      ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK DlgProc            ( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK WallPaperProc      ( HWND, UINT, WPARAM, LPARAM );


#define INSDIALOG_COUNT 27

INSDLG dialog[INSDIALOG_COUNT];
int g_nInsDialogsVisible = 0;
BOOL g_fInsDirty = FALSE;

void InitializeInsDialogProcs();


BOOL WINAPI DllMain( HINSTANCE hModule, DWORD fdwReason, LPVOID /*lpReserved*/ )
{
    int nIndex = 0;
    TCHAR szTitle[MAX_PATH];
    TCHAR szMsg[MAX_PATH];
    
    g_hDllInst = hModule;
    
    if(fdwReason == DLL_PROCESS_ATTACH && !g_bInitialize)
    {
        g_hInst = LoadLibrary(TEXT("ieakui.dll"));
        if (g_hInst == NULL)
        {
            LoadString(g_hInst, IDS_INSDLL_TITLE, szTitle, ARRAYSIZE(szTitle));
            LoadString(g_hInst, IDS_IEAKUI_LOADERROR, szMsg, ARRAYSIZE(szMsg));
            MessageBox(NULL, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
            return FALSE;
        }

        ZeroMemory(g_szDefInf, sizeof(g_szDefInf));
        InitializeInsDialogProcs();
        g_bInitialize = TRUE;
    }
    else if(fdwReason == DLL_PROCESS_DETACH && g_bInitialize)
    {
        for(nIndex = 0; nIndex < g_nInsDialogsVisible; nIndex++)
        {
            if(dialog[nIndex].szName)
            {
                LocalFree((HLOCAL) dialog[nIndex].szName);
                ZeroMemory(&dialog[nIndex], sizeof(dialog[nIndex]));
            }
        }
        g_nInsDialogsVisible = 0;
        g_bInitialize = FALSE;
        if(g_hInst)
            FreeLibrary(g_hInst);
    }
    return TRUE;
}

INT_PTR CALLBACK DlgProc( HWND /*hWnd*/, UINT msg, WPARAM /*wParam*/, LPARAM /*lParam*/ )
{
    switch( msg )
    {
    case WM_INITDIALOG:
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

LPINSDLG GetInsDlgStruct( int *nDialogs )
{
    *nDialogs = g_nInsDialogsVisible;
    return dialog;
}

HWND CreateInsDialog( HWND hWnd, int x, int y, int nIndex, LPTSTR szInsFile, LPTSTR szWorkDir )
{
    HWND hDialog;
    RECT r;
    long lStyle;
    PVOID lpTemplate;

    g_szInsFile = szInsFile;
    ZeroMemory(g_szWorkDir, sizeof(g_szWorkDir));
    StrCpy(g_szWorkDir, szWorkDir);

    lStyle = DS_CONTROL | DS_3DLOOK | DS_SETFONT | WS_CHILD;
    if(PrepareDlgTemplate(g_hInst, PtrToUint(dialog[nIndex].DlgId), (DWORD) lStyle, &lpTemplate) != S_OK)
        return NULL;

    hDialog = CreateDialogIndirect( g_hInst, (LPCDLGTEMPLATE) lpTemplate, hWnd, dialog[nIndex].dlgproc );
    if(hDialog == NULL)
        return NULL;

    CoTaskMemFree(lpTemplate);

    GetWindowRect( hDialog,  &r );
    MoveWindow( hDialog, x, y, r.right-r.left, r.bottom-r.top, TRUE );
    ShowWindow( hDialog, SW_SHOWNORMAL );
    return hDialog;
}


void InitializeInsDialogProcs()
{
    TCHAR szString[512];
    HINSTANCE hShell;
    SHELLFLAGSTATE sfs;
    int nIndex = 0;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_BTITLE );
    LoadString(g_hInst, IDS_BTITLE, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = TitleProc;
    dialog[nIndex++].pfnFinalCopy = NULL;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_CUSTICON );
    LoadString(g_hInst, IDS_CUSTICON2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = LogoProc;
    dialog[nIndex++].pfnFinalCopy = NULL;

    if (g_dwPlatformId == PLATFORM_WIN32)
    {
        dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_CABSIGN );
        LoadString(g_hInst, IDS_CABSIGN, szString, ARRAYSIZE(szString));
        dialog[nIndex].szName = StrDup(szString);
        dialog[nIndex].dlgproc = CabSignProc;
        dialog[nIndex++].pfnFinalCopy = NULL;
    }

    /*dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_ONLINESUPPORT );
    LoadString(g_hInst, IDS_ONLINESUPPORT, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = SupportProc;
    dialog[nIndex++].pfnFinalCopy = NULL;*/

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_FAVORITES );
    LoadString(g_hInst, IDS_FAVORITES2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = FavsProc;
    dialog[nIndex++].pfnFinalCopy = NULL;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_BTOOLBARS );
    LoadString(g_hInst, IDS_BTOOLBAR, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = BToolbarProc;
    dialog[nIndex++].pfnFinalCopy = BToolbarsFinalCopy;

    /*if (g_dwPlatformId == PLATFORM_WIN32)
    {
        dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_DWALLPAPER );
        LoadString(g_hInst, IDS_DWALLPAPER, szString, ARRAYSIZE(szString));
        dialog[nIndex].szName = StrDup(szString);
        dialog[nIndex].dlgproc = WallPaperProc;
        dialog[nIndex++].pfnFinalCopy = WallPaperFinalCopy;
    }*/

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_UASTRDLG );
    LoadString(g_hInst, IDS_UASTRDLG2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = UserAgentProc;
    dialog[nIndex++].pfnFinalCopy = NULL;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_CONNECTSET );
    LoadString(g_hInst, IDS_CONNECTSET, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = ConnectionSettingsDlgProc;
    dialog[nIndex++].pfnFinalCopy = ConnectionSettingsFinalCopy;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_QUERYAUTOCONFIG );
    LoadString(g_hInst, IDS_QUERYAUTOCONFIG, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = QueryAutoConfigDlgProc;
    dialog[nIndex++].pfnFinalCopy = NULL;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_PROXY );
    LoadString(g_hInst, IDS_PROXY2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = ProxyProc;
    dialog[nIndex++].pfnFinalCopy = NULL;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_STARTSEARCH );
    LoadString(g_hInst, IDS_STARTSEARCH2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = StartSearchProc;
    dialog[nIndex++].pfnFinalCopy = NULL;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_PROGRAMS );
    LoadString(g_hInst, IDS_PROGRAMS, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = ProgramsDlgProc;
    dialog[nIndex++].pfnFinalCopy = ProgramsFinalCopy;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_MAIL );
    LoadString(g_hInst, IDS_MAIL2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = MailServer;
    dialog[nIndex++].pfnFinalCopy = NULL;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_IMAP );
    LoadString(g_hInst, IDS_IMAP2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = IMAPSettings;
    dialog[nIndex++].pfnFinalCopy = NULL;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_OE );
    LoadString(g_hInst, IDS_OE2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = CustomizeOE;
    dialog[nIndex++].pfnFinalCopy = OEFinalCopy;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_PRECONFIG );
    LoadString(g_hInst, IDS_PRECONFIG2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = PreConfigSettings;
    dialog[nIndex++].pfnFinalCopy = NULL;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_OEVIEW );
    LoadString(g_hInst, IDS_OEVIEW2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = ViewSettings;
    dialog[nIndex++].pfnFinalCopy = NULL;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_SIG );
    LoadString(g_hInst, IDS_SIG2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = Signature;
    dialog[nIndex++].pfnFinalCopy = NULL;

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_LDAP );
    LoadString(g_hInst, IDS_LDAP2, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = LDAPServer;
    dialog[nIndex++].pfnFinalCopy = LDAPFinalCopy;

    ZeroMemory(&sfs, sizeof(sfs));
    sfs.fWin95Classic = 1;
    hShell = LoadLibrary(TEXT("SHELL32.DLL"));
    if (hShell)
    {
        void (WINAPI *pSHGetSet)(LPSHELLFLAGSTATE lpsfs, DWORD dwMask);

        sfs.fWin95Classic = TRUE;
        pSHGetSet = (void (WINAPI *)(LPSHELLFLAGSTATE lpsfs, DWORD dwMask))
                    GetProcAddress( hShell, "SHGetSettings" );
        if (pSHGetSet)
            pSHGetSet(&sfs, SSF_DESKTOPHTML | SSF_WIN95CLASSIC);
        FreeLibrary(hShell);
    }

    dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_SECURITY1 );
    LoadString(g_hInst, IDS_SECURITY, szString, ARRAYSIZE(szString));
    dialog[nIndex].szName = StrDup(szString);
    dialog[nIndex].dlgproc = SecurityZonesDlgProc;
    dialog[nIndex++].pfnFinalCopy = ZonesFinalCopy;

    if (g_dwPlatformId == PLATFORM_W2K)
    {
        dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_SECURITYAUTH );
        dialog[nIndex].dlgproc = SecurityAuthDlgProc;
        dialog[nIndex].pfnFinalCopy = AuthFinalCopy;
    }
    else
    {
        dialog[nIndex].DlgId = MAKEINTRESOURCE( IDD_SECURITYCERT );
        dialog[nIndex].dlgproc = SecurityCertsDlgProc;
        dialog[nIndex].pfnFinalCopy = CertsFinalCopy;
    }       
    LoadString(g_hInst, IDS_SECURITYCERT, szString, ARRAYSIZE(szString));
    dialog[nIndex++].szName = StrDup(szString);

    g_nInsDialogsVisible = nIndex;
}

void DestroyInsDialog(HWND hDlg)
{
    if (hDlg != NULL)
        SendMessage(hDlg, WM_CLOSE, 0, 0L);
}

BOOL SaveInsDialog(HWND hDlg, DWORD dwFlags)
{
    BOOL fSave = TRUE;

    if (hDlg != NULL)
    {
        if (*g_szInsFile != 0)
        {
            if (HasFlag(dwFlags, ITEM_SAVE) || HasFlag(dwFlags, ITEM_CHECKDIRTY))
            {
                BOOL fCheckDirty = HasFlag(dwFlags, ITEM_CHECKDIRTY);

                fSave = FALSE;
                SendMessage(hDlg, UM_SAVE, (WPARAM)&fSave, (LPARAM)fCheckDirty);
            }
        }
        if (fSave && HasFlag(dwFlags, ITEM_DESTROY))
            DestroyInsDialog(hDlg);
    }
    
    return fSave;
}

void SetDefaultInf(LPCTSTR szDefInf)
{
    ZeroMemory(g_szDefInf, sizeof(g_szDefInf));
    if(*szDefInf)
        StrCpy(g_szDefInf, szDefInf);
}

void ReInitializeInsDialogProcs()
{
    int nIndex;
    for(nIndex = 0; nIndex < g_nInsDialogsVisible; nIndex++)
    {
        if(dialog[nIndex].szName)
        {
            LocalFree((HLOCAL) dialog[nIndex].szName);
            ZeroMemory(&dialog[nIndex], sizeof(dialog[nIndex]));
        }
    }
    g_nInsDialogsVisible = 0;
    InitializeInsDialogProcs();
}

void SetPlatformInfo(DWORD dwCurrPlatformId)
{
    g_dwPlatformId = dwCurrPlatformId;
}

BOOL WINAPI InsDirty()
{
    return g_fInsDirty;
}

void WINAPI ClearInsDirtyFlag()
{
    g_fInsDirty = FALSE;
}

// This function informs the caller whether a check for extended characters in a path field
// is required for a particular dialog.
BOOL WINAPI CheckForExChar(int nDialogIndex)
{
    switch (PtrToUint(dialog[nDialogIndex].DlgId))
    {
        case IDD_BTITLE:
        case IDD_CUSTICON:
            return TRUE;

        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\pch.h ===
//
// PCH.H
//

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <shlobj.h>
#include <regstr.h>
#include <wininet.h>
#include <advpub.h>
#include <inetcpl.h>

#include <iedkbrnd.h>
#include "..\..\ieakutil\ieakutil.h"
#include "..\..\ieakeng\exports.h"

#include "..\ieakui\common.h"
#include "..\ieakui\resource.h"
#include "..\ieakui\insdll.h"
#include "..\ieakui\legacy.h"

#include "insdll.h"
#include "utils.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\seccerts.cpp ===
//
// SECCERTS.CPP
//

#include "pch.h"


INT_PTR CALLBACK SecurityCertsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        CheckRadioButton(hDlg, IDC_NOSC, IDC_IMPORTSC, IDC_NOSC);
        DisableDlgItem(hDlg, IDC_MODIFYSC);

        CheckRadioButton(hDlg, IDC_NOAUTH, IDC_IMPORTAUTH, IDC_NOAUTH);
        DisableDlgItem(hDlg, IDC_MODIFYAUTH);
        return TRUE;

    case UM_SAVE:
        {
            TCHAR szSecWorkDir[MAX_PATH];
            TCHAR szSiteCertInf[MAX_PATH];
            TCHAR szRootStr[MAX_PATH];
            TCHAR szCaStr[MAX_PATH];
            TCHAR szAuthCodeInf[MAX_PATH];
            HCURSOR hOldCur;
            BOOL  fCheckDirtyOnly = (BOOL) lParam;

            hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

            // prepare the work dir where the SITECERT.INF and *.STR would temporarily get copied to
            PathCombine(szSecWorkDir, g_szWorkDir, TEXT("sitecert.wrk"));
            PathCombine(szSiteCertInf, szSecWorkDir, TEXT("sitecert.inf"));
            PathCombine(szRootStr, szSecWorkDir, TEXT("root.str"));
            PathCombine(szCaStr, szSecWorkDir, TEXT("ca.str"));

            if (IsDlgButtonChecked(hDlg, IDC_IMPORTSC) == BST_CHECKED)
            {
                if (!fCheckDirtyOnly)
                {
                    ImportSiteCert(g_szInsFile, NULL, szSiteCertInf, TRUE);
                    
                    CheckRadioButton(hDlg, IDC_NOSC, IDC_IMPORTSC, IDC_NOSC);
                    DisableDlgItem(hDlg, IDC_MODIFYSC);
                }
                g_fInsDirty = TRUE;
            }
            

            // prepare the work dir where the AUTHCODE.INF would temporarily get copied to
            PathCombine(szSecWorkDir, g_szWorkDir, TEXT("authcode.wrk"));
            PathCombine(szAuthCodeInf, szSecWorkDir, TEXT("authcode.inf"));

            if (IsDlgButtonChecked(hDlg, IDC_IMPORTAUTH) == BST_CHECKED)
            {
                if (!fCheckDirtyOnly)
                {
                    ImportAuthCode(g_szInsFile, NULL, szAuthCodeInf, TRUE);
                    
                    CheckRadioButton(hDlg, IDC_NOAUTH, IDC_IMPORTAUTH, IDC_NOAUTH);
                    DisableDlgItem(hDlg, IDC_MODIFYAUTH);
                }
                g_fInsDirty = TRUE;
            }
            
            SetCursor(hOldCur);
        }
        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;

    case WM_COMMAND:
        switch (wParam)
        {
        case IDC_NOSC:
            DisableDlgItem(hDlg, IDC_MODIFYSC);
            return TRUE;

        case IDC_IMPORTSC:
            EnableDlgItem(hDlg, IDC_MODIFYSC);
            return TRUE;

        case IDC_MODIFYSC:
            ModifySiteCert(hDlg);
            SetFocus(GetDlgItem(hDlg, IDC_MODIFYSC));
            break;

        case IDC_NOAUTH:
            DisableDlgItem(hDlg, IDC_MODIFYAUTH);
            return TRUE;

        case IDC_IMPORTAUTH:
            EnableDlgItem(hDlg, IDC_MODIFYAUTH);
            return TRUE;

        case IDC_MODIFYAUTH:
            ModifyAuthCode(hDlg);
            SetFocus(GetDlgItem(hDlg, IDC_MODIFYAUTH));
            return TRUE;
        }
        break;
    }

    return FALSE;
}


HRESULT CertsFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState)
{
    TCHAR szFrom[MAX_PATH];

    if ((HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL) || HasFlag(dwFlags, PM_COPY))
    {
        TCHAR szFile[MAX_PATH];
        
        // move sitecert.inf, *.str and *.dis to pcszDestDir
        PathCombine(szFrom, g_szWorkDir, TEXT("sitecert.wrk"));

        PathCombine(szFile, szFrom, TEXT("sitecert.inf"));
        if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && PathFileExists(szFile))
            SetFlag(pdwCabState, CAB_TYPE_CONFIG);
        if (HasFlag(dwFlags, PM_COPY))
            CopyFileToDir(szFile, pcszDestDir);
    
        PathCombine(szFile, szFrom, TEXT("root.str"));
        if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && PathFileExists(szFile))
            SetFlag(pdwCabState, CAB_TYPE_CONFIG);
        if (HasFlag(dwFlags, PM_COPY))
            CopyFileToDir(szFile, pcszDestDir);

        PathCombine(szFile, szFrom, TEXT("root.dis"));
        if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && PathFileExists(szFile))
            SetFlag(pdwCabState, CAB_TYPE_CONFIG);
        if (HasFlag(dwFlags, PM_COPY))
            CopyFileToDir(szFile, pcszDestDir);

        PathCombine(szFile, szFrom, TEXT("ca.str"));
        if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && PathFileExists(szFile))
            SetFlag(pdwCabState, CAB_TYPE_CONFIG);
        if (HasFlag(dwFlags, PM_COPY))
            CopyFileToDir(szFile, pcszDestDir);

        // move authcode.inf to pcszDestDir
        PathCombine(szFrom, g_szWorkDir, TEXT("authcode.wrk"));
    
        PathCombine(szFile, szFrom, TEXT("authcode.inf"));
        if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && PathFileExists(szFile))
            SetFlag(pdwCabState, CAB_TYPE_CONFIG);
        if (HasFlag(dwFlags, PM_COPY))
            CopyFileToDir(szFile, pcszDestDir);
    }

    // blow away the work dirs
    if (HasFlag(dwFlags, PM_CLEAR))
    {
        PathCombine(szFrom, g_szWorkDir, TEXT("sitecert.wrk"));
        PathRemovePath(szFrom);

        PathCombine(szFrom, g_szWorkDir, TEXT("authcode.wrk"));
        PathRemovePath(szFrom);
    }

    return S_OK;
}


INT_PTR CALLBACK SecurityAuthDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        CheckRadioButton(hDlg, IDC_NOAUTH, IDC_IMPORTAUTH, IDC_NOAUTH);
        DisableDlgItem(hDlg, IDC_MODIFYAUTH);
    
        HideDlgItem(hDlg, IDC_TPL_TEXT);
        HideDlgItem(hDlg, IDC_TPL);
        break;

    case UM_SAVE:
        {   // process authenticode

            TCHAR   szInf[MAX_PATH];
            HCURSOR hOldCur;
            BOOL  fCheckDirtyOnly = (BOOL) lParam;

            hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
            
            PathCombine(szInf, g_szWorkDir, TEXT("authcode.wrk"));
            PathAppend(szInf, TEXT("authcode.inf"));

            if (IsDlgButtonChecked(hDlg, IDC_IMPORTAUTH) == BST_CHECKED)
            {
                if (!fCheckDirtyOnly)
                {
                    ImportAuthCode(g_szInsFile, NULL, szInf, TRUE);

                    CheckRadioButton(hDlg, IDC_NOAUTH, IDC_IMPORTAUTH, IDC_NOAUTH);
                    DisableDlgItem(hDlg, IDC_MODIFYAUTH);
                }
                g_fInsDirty = TRUE;
            }
            else
                if (!fCheckDirtyOnly)
                    ImportAuthCode(g_szInsFile, NULL, szInf, FALSE);

            SetCursor(hOldCur);
        }
        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_NOAUTH:
            DisableDlgItem(hDlg, IDC_MODIFYAUTH);
            break;

        case IDC_IMPORTAUTH:
            EnableDlgItem(hDlg, IDC_MODIFYAUTH);
            break;

        case IDC_MODIFYAUTH:
            ModifyAuthCode(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

HRESULT AuthFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState)
{
    TCHAR szFrom[MAX_PATH];

    if ((HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL) || HasFlag(dwFlags, PM_COPY))
    {
        TCHAR szFile[MAX_PATH];
        
        // move authcode.inf to pcszDestDir
        PathCombine(szFrom, g_szWorkDir, TEXT("authcode.wrk"));
    
        PathCombine(szFile, szFrom, TEXT("authcode.inf"));
        if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && PathFileExists(szFile))
            SetFlag(pdwCabState, CAB_TYPE_CONFIG);
        if (HasFlag(dwFlags, PM_COPY))
            CopyFileToDir(szFile, pcszDestDir);
    }

    // blow away the work dir
    if (HasFlag(dwFlags, PM_CLEAR))
    {
        PathCombine(szFrom, g_szWorkDir, TEXT("authcode.wrk"));
        PathRemovePath(szFrom);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\ie4chnl.cpp ===
#include "pch.h"

/////////////////////////////////////////////////////////////////////////////
// ChannelsFinalCopy

HRESULT ChannelsFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState)
{
    TCHAR szChlsWrkDir[MAX_PATH],
          szWrkChlsInf[MAX_PATH];

    PathCombine(szChlsWrkDir,  g_szWorkDir, TEXT("channels.wrk"));
    PathCombine(szWrkChlsInf, szChlsWrkDir, TEXT("ie4chnls.inf"));

    if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL)
    {
        if (PathFileExists(szWrkChlsInf))
            SetFlag(pdwCabState, CAB_TYPE_CONFIG);
        if (!PathIsEmptyPath(szChlsWrkDir, FILES_ONLY, szWrkChlsInf))
            SetFlag(pdwCabState, CAB_TYPE_DESKTOP);
    }

    // note: we are depending on copyfile to fail here if szWrkChlsInf
    // does not exist so we don't clobber szTo
    if (HasFlag(dwFlags, PM_COPY))
    {
        TCHAR szTo[MAX_PATH];

        // delete the ie4chnls.inf from the branding cab
        DeleteFileInDir(szWrkChlsInf, pcszDestDir);

        // put ie4chnls.inf in branding.cab for IE4 support
        if (PathFileExists(szWrkChlsInf))
        {
            CopyFileToDir(szWrkChlsInf, pcszDestDir);
            DeleteFile(szWrkChlsInf);
        }

        // move all the remaining files to pcszDestDir\"desktop"
        PathCombine(szTo, pcszDestDir, TEXT("desktop"));
        CopyFileToDir(szChlsWrkDir, szTo);
    }
    
    if (HasFlag(dwFlags, PM_CLEAR))
        PathRemovePath(szChlsWrkDir);

    return S_OK;
}

void HandleChannelsDeletion(LPCTSTR pszChlInf)
// Note. iMode == 1 means remove Channels, iMode == 2 means remove Software Updates, otherwise remove all;
{
    static const TCHAR c_szInfCleanUpAll[]  = TEXT("HKCU,\"%CleanKey%\\ieakCleanUp\",,,\r\n");

    HANDLE  hInf;

    hInf = CreateFile(pszChlInf, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    if (hInf == INVALID_HANDLE_VALUE)
        return;
    SetFilePointer(hInf, 0, NULL, FILE_END);


    WriteStringToFile(hInf, c_szInfCleanUpAll, StrLen(c_szInfCleanUpAll));
    CloseHandle(hInf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\seczones.cpp ===
//
// SECZONES.CPP
//

#include "pch.h"


INT_PTR CALLBACK SecurityZonesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        CheckRadioButton(hDlg, IDC_NOZONES, IDC_IMPORTZONES, IDC_NOZONES);
        DisableDlgItem(hDlg, IDC_MODIFYZONES);

        CheckRadioButton(hDlg, IDC_NORAT, IDC_IMPORTRAT, IDC_NORAT);
        DisableDlgItem(hDlg, IDC_MODIFYRAT);
        return TRUE;

    case UM_SAVE:
        {
            TCHAR szSecWorkDir[MAX_PATH];
            TCHAR szSecZonesInf[MAX_PATH];
            TCHAR szRatingsInf[MAX_PATH];
            HCURSOR hOldCur;
            BOOL  fCheckDirtyOnly = (BOOL) lParam;

            hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

            // prepare the work dir where the SECZONES.INF would temporarily get copied to
            PathCombine(szSecWorkDir, g_szWorkDir, TEXT("seczones.wrk"));
            PathCombine(szSecZonesInf, szSecWorkDir, TEXT("seczones.inf"));

            if (IsDlgButtonChecked(hDlg, IDC_IMPORTZONES) == BST_CHECKED)
            {
                if (!fCheckDirtyOnly)
                {
                    ImportZones(g_szInsFile, NULL, szSecZonesInf, TRUE);

                    CheckRadioButton(hDlg, IDC_NOZONES, IDC_IMPORTZONES, IDC_NOZONES);
                    DisableDlgItem(hDlg, IDC_MODIFYZONES);
                }
                g_fInsDirty = TRUE;
            }

            // prepare the work dir where the RATINGS.INF would temporarily get copied to
            PathCombine(szSecWorkDir, g_szWorkDir, TEXT("ratings.wrk"));
            PathCombine(szRatingsInf, szSecWorkDir, TEXT("ratings.inf"));

            if (IsDlgButtonChecked(hDlg, IDC_IMPORTRAT) == BST_CHECKED)
            {
                if (!fCheckDirtyOnly)
                {
                    ImportRatings(g_szInsFile, NULL, szRatingsInf, TRUE);

                    CheckRadioButton(hDlg, IDC_NORAT, IDC_IMPORTRAT, IDC_NORAT);
                    DisableDlgItem(hDlg, IDC_MODIFYRAT);
                }
                g_fInsDirty = TRUE;
            }

            SetCursor(hOldCur);
        }
        *((LPBOOL)wParam) = TRUE;
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        break;

    case WM_COMMAND:
        switch (wParam)
        {
        case IDC_NOZONES:
            DisableDlgItem(hDlg, IDC_MODIFYZONES);
            return TRUE;

        case IDC_IMPORTZONES:
            EnableDlgItem(hDlg, IDC_MODIFYZONES);
            return TRUE;

        case IDC_MODIFYZONES:
            ModifyZones(hDlg);
            SetFocus(GetDlgItem(hDlg, IDC_MODIFYZONES));
            return TRUE;

        case IDC_NORAT:
            DisableDlgItem(hDlg, IDC_MODIFYRAT);
            return TRUE;

        case IDC_IMPORTRAT:
            EnableDlgItem(hDlg, IDC_MODIFYRAT);
            return TRUE;

        case IDC_MODIFYRAT:
            ModifyRatings(hDlg);
            SetFocus(GetDlgItem(hDlg, IDC_MODIFYRAT));
            return TRUE;
        }
        break;
    }

    return FALSE;
}


HRESULT ZonesFinalCopy(LPCTSTR pcszDestDir, DWORD dwFlags, LPDWORD pdwCabState)
{
    TCHAR szFrom[MAX_PATH];

    if ((HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL) || HasFlag(dwFlags, PM_COPY))
    {
        TCHAR szFile[MAX_PATH];

        // move seczones.inf to pcszDestDir
        PathCombine(szFrom, g_szWorkDir, TEXT("seczones.wrk"));

        PathCombine(szFile, szFrom, TEXT("seczones.inf"));
        if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && PathFileExists(szFile))
            SetFlag(pdwCabState, CAB_TYPE_CONFIG);
        if (HasFlag(dwFlags, PM_COPY))
            CopyFileToDir(szFile, pcszDestDir);

        // move ratings.inf to pcszDestDir
        PathCombine(szFrom, g_szWorkDir, TEXT("ratings.wrk"));

        PathCombine(szFile, szFrom, TEXT("ratings.inf"));
        if (HasFlag(dwFlags, PM_CHECK) && pdwCabState != NULL && PathFileExists(szFile))
            SetFlag(pdwCabState, CAB_TYPE_CONFIG);
        if (HasFlag(dwFlags, PM_COPY))
            CopyFileToDir(szFile, pcszDestDir);
    }

    // blow away the work dirs
    if (HasFlag(dwFlags, PM_CLEAR))
    {
        PathCombine(szFrom, g_szWorkDir, TEXT("seczones.wrk"));
        PathRemovePath(szFrom);

        PathCombine(szFrom, g_szWorkDir, TEXT("ratings.wrk"));
        PathRemovePath(szFrom);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\exe\insedit.h ===
#define TREEVIEW_HEIGHT     250
#define TREEVIEW_WIDTH      205
#define MARGIN              5
#define INFOWINDOW_HEIGHT   70  
#define MAX_WINDOW_WIDTH    1000
#define MAX_WINDOW_HEIGHT   1000
#define NUMLANG             100
#define NUM_ICONS           8
#define PAGE_ERROR          2
#define SAVE_ERROR          3
#define SAVE_CANCEL         4
#define IDM_RECENTFILELIST  100

#define UM_SAVE_COMPLETE    WM_USER + 101
#define UM_INIT_TREEVIEW    WM_USER + 102

typedef struct _insdlg
{
    LPTSTR DlgId;
    LPTSTR szName;
    DLGPROC dlgproc;
    HTREEITEM hItem;
    HRESULT (WINAPI *pfnFinalCopy)(LPCTSTR psczDestDir, DWORD dwFlags, LPDWORD pdwCabState);
} INSDLG, *LPINSDLG;

typedef HWND     (WINAPI * CREATEINSDIALOG)(HWND, int, int, int, LPTSTR, LPTSTR);
typedef LPINSDLG (WINAPI * GETINSDLGSTRUCT)(int *);
typedef BOOL     (WINAPI * DESTROYINSDIALOG)(HWND);
typedef void     (WINAPI * SETDEFAULTINF)(LPCTSTR);
typedef void     (WINAPI * REINITIALIZEINSDIALOGPROCS)();
typedef void     (WINAPI * SETPLATFORMINFO)(DWORD);
typedef BOOL     (WINAPI * INSDIRTY)();
typedef void     (WINAPI * CLEARINSDIRTYFLAG)();
typedef BOOL     (WINAPI * SAVEINSDIALOG)(HWND, BOOL);
typedef BOOL     (WINAPI * CHECKFOREXCHAR)(int);

CREATEINSDIALOG             CreateInsDialog;
GETINSDLGSTRUCT             GetInsDlgStruct;
DESTROYINSDIALOG            DestroyInsDialog;
SETDEFAULTINF               SetDefaultInf;
REINITIALIZEINSDIALOGPROCS  ReInitializeInsDialogProcs;
SETPLATFORMINFO             SetPlatformInfo;
INSDIRTY                    InsDirty;
CLEARINSDIRTYFLAG           ClearInsDirtyFlag;
SAVEINSDIALOG               SaveInsDialog;
CHECKFOREXCHAR              CheckForExChar;


extern "C" HRESULT WINAPI ExtractFiles( LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags,
                             LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved);

BOOL    IsPolicyTree(HTREEITEM hItem);
void    CreateCabWorkDirs(LPCTSTR szWorkDir);
void    DeleteCabWorkDirs();
void    ExtractCabFile();
void    PrepareFolderForCabbing(LPCTSTR pcszDestDir, DWORD dwFlags);
BOOL    CompressCabFile();
void    CabUpFolder(HWND hWnd, LPTSTR szFolderPath, LPTSTR szDestDir, LPTSTR szCabname, BOOL fSubDirs = FALSE);
BOOL    DirectoryName(LPCTSTR lpDirectory, LPTSTR szDirectoryPath);
INT_PTR CALLBACK LanguageDialogProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
VOID    InitSysFont(HWND hDlg, INT iCtrlID);
INT_PTR CALLBACK SaveAsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
LPTSTR  GetCabName(LPCTSTR pcszInsFile, DWORD dwCabType, TCHAR szCabFullFileName[]);
BOOL    PathIsPathEmpty(LPCTSTR pcszPath);
INT_PTR CALLBACK DisplaySaveDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
void    GetDefaultInf(DWORD dwPlatformId);
void    GetDefaultCabName(DWORD dwCabType, LPCTSTR pcszPrefix, LPTSTR pszCabName);
BOOL    Is8_3FileFormat(LPCTSTR pszFile);
BOOL    InitializePlatform(HWND hWnd, HWND hInfoWnd, WORD wPlatform);
void    CopyDir(LPCTSTR szSrcDir, LPCTSTR szDestDir);
void    IeakPageHelp(HWND hWnd, LPCTSTR pszData);
void    UpdateRecentFileListMenu(HWND hWnd, TCHAR pRecentFileList[5][MAX_PATH]);
void    ReadRecentFileList(TCHAR pRecentFileList[5][MAX_PATH]);
void    UpdateRecentFileList(LPCTSTR pcszFile, BOOL fAdd, TCHAR pRecentFileList[5][MAX_PATH]);
void    WriteRecentFileList(TCHAR pRecentFileList[5][MAX_PATH]);
void    DrawTrackLine(HWND hWnd, int nXPos);
BOOL    IsDirty();
void    ClearDirtyFlag();
BOOL    SaveCurrentSelItem(HWND hTreeView, DWORD dwFlags);
void    SetInfoWindowText(HWND hInfoWnd, LPCTSTR pcszStatusText = NULL);
BOOL    PlatformExists(HWND hWnd, LPTSTR pLang, DWORD dwPlatform, BOOL fShowError = FALSE);
void    GetLangDesc(LPTSTR szLangId, LPTSTR szLangDesc, int cchLangDescSize, LPDWORD dwLangId);
BOOL    EnoughDiskSpace(LPCTSTR szSrcFile, LPCTSTR szDestFile, LPDWORD pdwSpaceReq, LPDWORD pdwSpaceFree);
DWORD   GetCabBuildStatus();
void    GetCabNameFromINS(LPCTSTR pcszInsFile, DWORD dwCabType, LPTSTR pszCabFullFileName, LPTSTR pszCabInfoLine = NULL);
BOOL    CabFilesExist(HWND hWnd, LPCTSTR pcszInsFile);
BOOL    IsWin32INSFile(LPCTSTR pcszIns);

// version.cpp stuff

void IncrementDotVer(LPTSTR pszVerStr);
void GenerateNewVersionStr(LPCTSTR pcszInsFile, LPTSTR pszNewVersionStr);
void SetOrClearVersionInfo(LPCTSTR pcszInsFile, DWORD dwCabType, LPCTSTR pcszCabName, 
                           LPCTSTR pcszCabsURLPath, LPTSTR pszNewVersionStr, BOOL fSet);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\dll\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

// macro definitions
#define MAX_URL INTERNET_MAX_URL_LENGTH

#ifndef ISNULL
#define ISNULL(psz)    (*(psz) == TEXT('\0'))
#endif

#ifndef ISNONNULL
#define ISNONNULL(psz) (*(psz) != TEXT('\0'))
#endif

// prototype declarations
void ShortPathName(LPTSTR pszFileName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\atl.inc ===
##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1991-96
#   All Rights Reserved.
#
##########################################################################

#
# Common include file 'sources' files ATL controls in the controls project.
#
#
# Required definitions:
#
#     CONTROLS_DIR
#        Path to controls root.
#
#     FREEBUILD
#        Set by makefile.def file.  One of the following:
#          0      - build debug
#          1      - build retail
#
#
# Definitions used if defined:
#
#     USE_LEGO
#        Define lego macros
#
#     TARGET_WIN95
#        Build component explicitly for the Win95 platform.  If this is
#        not defined, default is NT or both.
#
#     TARGET_BOTH
#        Build component to run on both platforms.
#
#     FULL_DEBUG
#        If set to 1, then debug builds will also have FULL_DEBUG defined.
#        Retail builds unaffected.
#
#     MEASURE_PERF
#        If set to 1, enables performance timing code for both debug and
#        retail builds.  This code squirts the timings for interesting
#        events to the debug terminal.
#

!if !defined(CONTROLS_DIR)
!error  CONTROLS_DIR must be defined in sources file
!endif

#
# Set private paths
#
INCLUDES        = \
		  $(SDK_INC_PATH)\atl21;\
	  $(INCLUDES)

#
# Set common options
#

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN= 1

# Don't link to the runtime libs
USE_NOLIBS      = 1

# Don't link to NTDLL if this runs on both platforms
!ifdef TARGET_BOTH
NO_NTDLL=1
!endif

!if defined(TARGET_WIN95)
#  Don't define WINNT
CHICAGO_PRODUCT = 1
!endif

UMTYPE          = windows

#
# Lego options
#
!if defined(USE_LEGO)
NTBBT           = 1
NTPROFILEINPUT  = 1
!endif

#
# Additional compiler flags
#

C_DEFINES       = $(C_DEFINES) -DWIN32 -D_WIN32

!if !defined(TARGET_WIN95)
C_DEFINES       = $(C_DEFINES) -DNT

!  if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!  endif
!endif

!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DDEBUG
LINKER_NOICF      = 1           # ICF is s-l-o-w

# Check for missing PURE directives in interface decls (debug only)
C_DEFINES       = $(C_DEFINES) -DNO_NOVTABLE

# Define FULL_DEBUG for asserts to break by default
!  if "$(FULL_DEBUG)" == "1"
C_DEFINES       = $(C_DEFINES) -DFULL_DEBUG
!  endif
!endif

!if "$(MEASURE_PERF)" == "1"
C_DEFINES       = $(C_DEFINES) -DMEASURE_PERF
!endif

!if "$(NO_PRIVATE_HEADERS)" == "1"
C_DEFINES       = $(C_DEFINES) -DNO_PRIVATE_HEADERS
!endif

# This define helps us distinguish our development environment
C_DEFINES       = $(C_DEFINES) -DWINNT_ENV

# Make warnings equivalent to errors

!if !defined(MSC_WARNING_LEVEL)
MSC_WARNING_LEVEL= /W3
!endif
MSC_WARNING_LEVEL= $(MSC_WARNING_LEVEL) /WX

!if defined(TARGET_WIN95) || defined(TARGET_BOTH)
USE_MAPSYM      = 1
!endif


!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keymaker\keymake.c ===
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>


// Note: this function is also in ..\wizard\keymake.cpp so make changes in both places

void MakeKey(char * pszSeed, int fCorp)
{
    int i;
    unsigned long dwKey;
    char szKey[5];

    i = strlen(pszSeed);
	
    if (i < 6)
    {
        // extend the input seed to 6 characters
        for (; i < 6; i++)
            pszSeed[i] = (char)('0' + i);
    }
	
    // let's calculate the DWORD key used for the last 4 chars of keycode

    // multiply by my first name

    dwKey = pszSeed[0] * 'O' + pszSeed[1] * 'L' + pszSeed[2] * 'I' +
        pszSeed[3] * 'V' + pszSeed[4] * 'E' + pszSeed[5] * 'R';

    // multiply the result by JONCE

    dwKey *= ('J' + 'O' + 'N' + 'C' + 'E');

    dwKey %= 10000;

    if (fCorp)
    {
        // give a separate keycode based on corp flag or not
        // 9 is chosen because is is a multiplier such that for any x,
        // (x+214) * 9 != x + 10000y
        // we have 8x = 10000y - 1926 which when y=1 gives us 8x = 8074 
        // since 8074 is not divisible by 8 where guaranteed to be OK since
        // the number on the right can only increase by 10000 increments which
        // are always divisible by 8

        dwKey += ('L' + 'E' + 'E');
        dwKey *= 9;
        dwKey %= 10000;
    }

    sprintf(szKey, "%04d", dwKey);

    strcpy(&pszSeed[6], szKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\exe\resource.h ===
#define IDI_ICON1                       1
#define IDI_ICON2                       2
#define IDI_ICON3                       3
#define IDI_ICON4                       4
#define IDI_ICON5                       5
#define IDI_ICON6                       6
#define IDI_ICON7                       7
#define IDI_ICON8                       8
#define IDI_ICON9                       9
#define IDS_TITLE                       1001
#define IDS_TITLE1                      1002
#define IDS_TITLE2                      1003
#define IDS_SAVE                        1004
#define IDS_UNTITLED                    1005
#define IDS_ERRDLL                      1006
#define IDS_ADMDELWARN                  1011
#define IDS_NOPOLICYFILE                1017
#define IDS_OPENFILEMSG                 1018
#define IDS_SAVEFILEMSG                 1019
#define IDS_IMPORTADMFILEMSG            1020
#define IDS_READYMSG                    1021
#define IDS_LOADADMFILEMSG              1022
#define IDS_CHKDUPKEYMSG                1023
#define IDS_WIZARDBRANCHTEXT            1024
#define IDS_WIZARDSETTINGS              1026
#define IDS_POLICYSETTINGS              1027
#define IDS_INSFILTERNAME               1031
#define IDS_LANGUAGE                    1032
#define IDS_NOIE                        1034
#define IDS_WIZARDBRANCHTITLE           1035
#define IDS_DSCRWNDFAIL                 1037
#define IDS_WRONGIE                     1038
#define IDS_FILENOTFOUND                1039
#define IDS_CABSIGN_ERROR               1040
#define IDS_INVALIDEXTN                 1041
#define IDS_CHECKFOREXCHAR              1042
#define IDS_STATUS                      1043
#define IDS_PROFILE_DIRTY               1044
#define IDS_PROFILE_NOCHANGE            1045
#define IDS_NOTAVAILABLE                1046
#define IDS_CABSURLPATH                 1047
#define IDS_VERSIONINFO                 1048
#define IDS_COMINITFAILURE              1049
#define IDS_NOLANGDIR                   1050
#define IDS_NOPLATFORMDIR               1051
#define IDS_WIN32                       1052
#define IDS_INSUFFICIENT_DISKSPACE      1055
#define IDS_CAB_DOESNOTEXIST            1056
#define IDS_W2K                         1057

// note: this ID depends on the one in ieakui\ieakui.h
#define IDS_LANGDIFFERS                 30451
#define IDS_UNSUPPORTED_PLATFORM        30454

// these values is used to display the ieak page help and
// hence uses the same ID's as in the ieak wizard resource.
#define IDD_ADM                         2072
#define IDD_CORPWELCOME                 2100
//

#define IDR_MAINMENU                    101
#define IDD_LANGDLG                     102
#define IDC_LANG                        103
#define IDC_STATIC                      -1

#define IDM_FILENEW                     40001
#define IDM_FILEOPEN                    40002
#define IDM_FILESAVE                    40003
#define IDM_FILESAVEAS                  40004
#define IDM_FILEEXIT                    40005
#define IDM_ADMIMPORT                   40006
#define IDM_ADMDELETE                   40007
#define IDM_CHKDUPKEYS                  40008
#define IDM_PLATFORM_WIN32              40009
#define IDM_HELP                        40012
#define IDM_PLATFORM_W2K                40013
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__48D17194_32CF_11D2_A337_00C04FD7C1FC__INCLUDED_)
#define AFX_DLLDATAX_H__48D17194_32CF_11D2_A337_00C04FD7C1FC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__48D17194_32CF_11D2_A337_00C04FD7C1FC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\exe\insedit.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <commctrl.h>
#include <stdlib.h>
#include <shellapi.h>
#include <objbase.h>
#include <wininet.h>
#include <shlwapi.h>
#include "iedkbrnd.h"
#include "treeview.h"
#include "resource.h"
#include "extract.h"
#include <advpub.h>
#include <mlang.h>
#include "..\..\ieakeng\exports.h"
#include "..\..\ieakutil\ieakutil.h"
#include "..\..\ieakui\insexe.h"
#include <htmlhelp.h>                           // for html help calls
#include "insedit.h"
#include "admparse.h"
#include <ntverp.h>      //these are for
#include <common.ver>    //ver_productversion_str


HINSTANCE g_hInst;
static HINSTANCE s_hInstIeakUI;

HWND  g_hMain;
TCHAR g_szInsFile[MAX_PATH];
TCHAR g_szFileName[MAX_PATH];

LPINSDLG g_pInsDialog;
int      g_nDialogs;

TCHAR g_szDesktopDir[MAX_PATH];

TCHAR g_szCabsURLPath[INTERNET_MAX_URL_LENGTH];
TCHAR g_szConfigURLPath[INTERNET_MAX_URL_LENGTH];
TCHAR g_szDesktopURLPath[INTERNET_MAX_URL_LENGTH];

TCHAR g_szConfigCabName[MAX_PATH];
TCHAR g_szDesktopCabName[MAX_PATH];

TCHAR g_szNewVersionStr[32];

static TCHAR s_szUnsignedFiles[MAX_PATH*3] = TEXT("");

// for Res2Str
TCHAR g_szTemp[1024];
TCHAR g_szTemp2[1024];

CTreeView     TreeView;

HWND      g_hDialog = NULL;
HTREEITEM g_hInsRootItem = NULL;
HTREEITEM g_hPolicyRootItem = NULL;
HWND      g_hWndAdmInstr = NULL;
int       g_InsSettingsOpen, g_InsSettingsClose, g_InsLeafItem, g_TreeLeaf, g_PolicyOpen,
          g_PolicyClose, g_ADMOpen, g_ADMClose;

TCHAR g_szCabWorkDir[MAX_PATH];
TCHAR g_szCabTempDir[MAX_PATH];
TCHAR g_szRoot[MAX_PATH];

TCHAR g_szLanguage[10];
DWORD g_dwLanguage = 0xffffffff;
TCHAR g_szDefInf[MAX_PATH];

TCHAR g_szCurrInsPath[MAX_PATH];

DWORD g_dwPlatformId = PLATFORM_WIN32;
TCHAR g_szCmdLine[MAX_PATH];

HWND  g_hWndHelp = NULL;

TCHAR *Res2Str(int nString)
{
    static BOOL fSet = FALSE;

    if(fSet)
    {
        if (LoadString(g_hInst, nString, g_szTemp, ARRAYSIZE(g_szTemp)) == 0)
            LoadString(s_hInstIeakUI, nString, g_szTemp, ARRAYSIZE(g_szTemp));
        fSet = FALSE;
        return(g_szTemp);
    }

    if (LoadString(g_hInst, nString, g_szTemp2, ARRAYSIZE(g_szTemp2)) == 0)
        LoadString(s_hInstIeakUI, nString, g_szTemp2, ARRAYSIZE(g_szTemp2));
    fSet = TRUE;
    return(g_szTemp2);
}

BOOL BrowseForFileEx(HWND hWnd, LPTSTR szFilter, LPTSTR szFileName, int cchSize, LPTSTR szDefExt)
{
    OPENFILENAME ofn;

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = g_hInst;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = cchSize;
    ofn.lpstrFileTitle = NULL;
    ofn.lpstrInitialDir = g_szCurrInsPath;
    ofn.lpstrTitle = NULL;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = szDefExt;

    return GetOpenFileName(&ofn);
}

BOOL BrowseForSave(HWND hWnd, LPTSTR szFilter, LPTSTR szFileName, int nSize, LPTSTR szDefExt)
{
    OPENFILENAME ofn;
    TCHAR szDir[MAX_PATH];
    LPTSTR lpExt;

    StrCpy(szDir, szFileName);
    lpExt = PathFindExtension(szFileName);
    if (*lpExt != TEXT('\0'))
    {
        StrCpy(szFileName, PathFindFileName(szDir));
        PathRemoveFileSpec(szDir);
    }
    else
        *szFileName = TEXT('\0');
    
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = g_hInst;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = nSize;
    ofn.lpstrFileTitle = NULL;
    ofn.lpstrInitialDir = szDir;
    ofn.lpstrTitle = NULL;
    ofn.Flags = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = szDefExt;

    return GetSaveFileName(&ofn);
}

void SetTitleBar(HWND hWnd, LPTSTR szFileName)
{
    TCHAR szTitleBar[1024];
    if(szFileName == NULL)
        wsprintf(szTitleBar, Res2Str(IDS_TITLE1));
    else
        wsprintf(szTitleBar, Res2Str(IDS_TITLE2), szFileName);

    SetWindowText(hWnd, szTitleBar);
}

void NewTempFile()
{
    TCHAR szTempPath[MAX_PATH];
    
    DeleteFile(g_szInsFile);
    ZeroMemory(g_szInsFile, sizeof(g_szInsFile));

    GetTempPath(ARRAYSIZE(szTempPath), szTempPath);
    GetTempFileName(szTempPath, TEXT("INS"), 0, g_szInsFile);
}

void SetStockFont(HWND hWnd)
{
    HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    SendMessage(hWnd, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
}

int GetSelIndex()
{
    int i;
    HTREEITEM hItem = TreeView.GetSel();

    for(i = 0; i < g_nDialogs; i++)
    {
        if(hItem == g_pInsDialog[i].hItem)
           return i;
    }
    return 0;
}


BOOL IsPolicyTree(HTREEITEM hItem)
{
    BOOL bRet = FALSE;
    HTREEITEM hParentItem = NULL;
    
    while(1)
    {
        hParentItem = TreeView_GetParent(TreeView.GetHandle(), hItem);
        if(hParentItem == NULL)
        {
            bRet = (hItem == g_hPolicyRootItem) ? TRUE : FALSE;
            break;
        }
        hItem = hParentItem;        
    };
    
    return bRet;
}

// Creates image list, adds bitmaps/icons to it, and associates the image
// list with the treeview control.
LRESULT InitImageList(HWND hTreeView)
{
    HIMAGELIST  hWndImageList;
    HICON       hIcon;

    hWndImageList = ImageList_Create(GetSystemMetrics (SM_CXSMICON),
                     GetSystemMetrics (SM_CYSMICON),
                     TRUE,
                     NUM_ICONS,
                     8);
    if(!hWndImageList)
    {
        return FALSE;
    }
    
    hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON2)); 
    g_InsSettingsOpen = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON3)); 
    g_InsSettingsClose = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON4)); 
    g_TreeLeaf = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON5)); 
    g_PolicyOpen = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON6)); 
    g_PolicyClose = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON7)); 
    g_ADMOpen = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON8)); 
    g_ADMClose = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON9));
    g_InsLeafItem = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    // Fail if not all images were added.
    if (ImageList_GetImageCount(hWndImageList) < NUM_ICONS)
    {
        // ERROR: Unable to add all images to image list.
        return FALSE;
    }
    
    // Associate image list with treeView control.
    TreeView_SetImageList(hTreeView, hWndImageList, TVSIL_NORMAL);
    return TRUE;
}

void InitTreeView(HWND hTreeView, HWND hInfoWnd)
{
    TCHAR szTemp[MAX_PATH];

    ShowADMWindow(hTreeView, FALSE);

    for(int i = 0; i < g_nDialogs; i++)
       g_pInsDialog[i].hItem = TreeView.AddItem(g_pInsDialog[i].szName, g_hInsRootItem);
    
    SetInfoWindowText(hInfoWnd, Res2Str(IDS_LOADADMFILEMSG));
    
    wsprintf(szTemp, TEXT("%sPolicies\\%s"), g_szRoot, g_szLanguage);
    LoadADMFiles(TreeView.GetHandle(), g_hPolicyRootItem, szTemp, g_szCabWorkDir, 
         g_dwPlatformId, ROLE_CORP, g_ADMClose, g_InsLeafItem);
    
    if(TreeView_GetChild(TreeView.GetHandle(), g_hPolicyRootItem) == NULL) // if no items in the tree view
        MessageBox(hTreeView, Res2Str(IDS_NOPOLICYFILE), Res2Str(IDS_TITLE), MB_ICONINFORMATION | MB_OK);
    
    SetInfoWindowText(hInfoWnd, Res2Str(IDS_READYMSG));
    
    TreeView_Expand(TreeView.GetHandle(), g_hPolicyRootItem, TVE_EXPAND);
    TreeView_Expand(TreeView.GetHandle(), g_hInsRootItem, TVE_EXPAND);

    ShowADMWindow(hTreeView, TRUE);
    TreeView.SetSel(g_hInsRootItem);
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int             i;
    int             nMinWidth  = 0;
    int             nMinHeight = 0;
    DWORD           dwType = REG_SZ;
    DWORD           dwSize = sizeof(g_szCurrInsPath);
    DWORD           dwDisposition;
    DWORD           dwCabBuildStatus;
    TCHAR           szItem[100];
    TCHAR           szTempFile[MAX_PATH];
    TCHAR           szMsg[MAX_PATH];
    TCHAR           szLangId[MAX_PATH];
    TCHAR           szTemp[MAX_PATH];
    TCHAR           szFilter[MAX_PATH];
    LPTSTR          pszFilter = NULL;
            
    NM_TREEVIEW     *lpNMTreeView;
    TV_ITEM         tvitem, tvitem1;
    HTREEITEM       hItem;
    HWND            hWndFocus;
    HMENU           hMenu;
    HKEY            hKey;
    RECT            rect1, rect2;
    LPMINMAXINFO    lpmmi = NULL;

    static BOOL     bSwitchScreen  = TRUE;
    static BOOL     fCanResize     = FALSE;
    static BOOL     fDirty         = FALSE;
    static HWND     hWndSizeBar    = NULL;
    static HWND     hInfoWnd       = NULL;
    static HCURSOR  hCurVTResize   = NULL;
    static int      nPrevXPos      = 0;
    static int      nTreeViewWidth = TREEVIEW_WIDTH;
    static TCHAR    szRecentFileList[5][MAX_PATH];
    static TCHAR    szFileToOpen[MAX_PATH];

    static HWND     hErrorDlgCtrl = NULL;
    
    switch(msg)
    {
    case WM_CREATE:
        SetWindowText(hWnd, Res2Str(IDS_TITLE));

        ZeroMemory(g_szCurrInsPath, sizeof(g_szCurrInsPath));
        if(RegOpenKeyEx(HKEY_CURRENT_USER, RK_IEAK_SERVER TEXT("\\ProfMgr"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            RegQueryValueEx(hKey, TEXT("LastOpenedPath"), NULL, &dwType, (LPBYTE) g_szCurrInsPath, &dwSize);
            dwType = REG_DWORD;
            dwSize = sizeof(nTreeViewWidth);
            if (RegQueryValueEx(hKey, TEXT("TreeviewWidth"), NULL, &dwType, (LPBYTE) &nTreeViewWidth, &dwSize) != ERROR_SUCCESS)
            nTreeViewWidth = TREEVIEW_WIDTH;
            RegCloseKey(hKey);
        }

        TreeView.Create(hWnd, MARGIN, MARGIN, nTreeViewWidth, TREEVIEW_HEIGHT);
        InitImageList(TreeView.GetHandle());

        // Create the INS dialog to get the intial size of the right hand pane
        g_hDialog = CreateInsDialog(hWnd, nTreeViewWidth + (2*MARGIN), 0, 0, g_szInsFile, g_szCabWorkDir);
        EnableWindow(g_hDialog, FALSE);

        hInfoWnd = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("STATIC"), TEXT(""), WS_CHILD | WS_VISIBLE, 0, 0, 0, 0, hWnd, NULL, g_hInst, 0);
        if (hInfoWnd)
            SetStockFont(hInfoWnd);
    
        GetWindowRect(g_hDialog, &rect1);
        GetWindowRect(hWnd, &rect2);
    
        nMinWidth  = (3 * MARGIN) + nTreeViewWidth + (rect1.right - rect1.left) + 
                 (2 * GetSystemMetrics(SM_CXFIXEDFRAME)) + 4;
        nMinHeight = (2 * MARGIN) + (rect1.bottom - rect1.top) + 
                 (hInfoWnd ? INFOWINDOW_HEIGHT : 0) +
                 GetSystemMetrics(SM_CYMENU) + GetSystemMetrics(SM_CYCAPTION) +
                 (2 * GetSystemMetrics(SM_CYFIXEDFRAME)) + 4;

        GetWindowRect(GetDesktopWindow(), &rect1); // center the window on the desktop
        rect2.left = ((rect1.right - rect1.left)/2) - (nMinWidth/2);
        rect2.top = ((rect1.bottom - rect1.top)/2) - (nMinHeight/2);
    
        MoveWindow(hWnd, (rect2.left > 0) ? rect2.left : 0, (rect2.top > 0) ? rect2.top : 0, nMinWidth, nMinHeight, TRUE);

        g_hWndAdmInstr = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("STATIC"), TEXT(""), 
                        WS_CHILD | WS_VISIBLE, 0, 0, 0, 0, hWnd, NULL, g_hInst, 0);

        CreateADMWindow(TreeView.GetHandle(), NULL, 0, 0, 0, 0);
        ShowADMWindow(TreeView.GetHandle(), FALSE);

        hWndSizeBar = CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("STATIC"), TEXT("SizeBarWnd"), 
                         WS_CHILD | WS_VISIBLE, 0, 0, 0, 0, hWnd, NULL, g_hInst, 0);

        LoadString(g_hInst, IDS_WIZARDSETTINGS, szMsg, ARRAYSIZE(szMsg));
        g_hInsRootItem = TreeView.AddItem(szMsg);

        DestroyInsDialog(g_hDialog);
        g_hDialog = NULL;

        LoadString(g_hInst, IDS_POLICYSETTINGS, szMsg, ARRAYSIZE(szMsg));
        g_hPolicyRootItem = TreeView.AddItem(szMsg);
    
        ShowWindow(hWnd, SW_SHOWNORMAL);

        ZeroMemory(g_szLanguage, sizeof(g_szLanguage));
        ZeroMemory(g_szDefInf, sizeof(g_szDefInf));
        DialogBox(g_hInst, MAKEINTRESOURCE(IDD_LANGDLG), hWnd, LanguageDialogProc);
        if(*g_szLanguage != TEXT('\0'))
        {
            // check whether the Optional Cab has been downloaded for a particular platform
            // and language.
            hMenu = GetSubMenu(GetMenu(hWnd), 2);
            CheckMenuItem(hMenu, IDM_PLATFORM_WIN32, MF_BYCOMMAND | MF_UNCHECKED);
            if (PlatformExists(hWnd, g_szLanguage, g_dwPlatformId)) // g_dwPlatformId = PLATFORM_WIN32
                CheckMenuItem(hMenu, IDM_PLATFORM_WIN32, MF_BYCOMMAND | MF_CHECKED);
            else
                g_dwPlatformId = 0;
        }

        if (*g_szLanguage == TEXT('\0') || !g_dwPlatformId)
        {
            TCHAR  szWin32Text[25];
            LPTSTR pMsg;

            StrCpy(szWin32Text, Res2Str(IDS_WIN32));
        
            pMsg = FormatString(Res2Str(IDS_NOLANGDIR), szWin32Text);
            MessageBox(hWnd, pMsg, Res2Str(IDS_TITLE), MB_ICONINFORMATION | MB_OK);
            LocalFree(pMsg);
        
            return -1;
        }
    
        // default inf
        GetDefaultInf(g_dwPlatformId);
        SetDefaultInf(g_szDefInf);
        SetPlatformInfo(g_dwPlatformId);

        ReInitializeInsDialogProcs();
        g_pInsDialog = GetInsDlgStruct(&g_nDialogs);
    
        SetFocus(g_hWndAdmInstr);
        EnableWindow(TreeView.GetHandle(), FALSE);

        // read the recent file list from the registry
        ReadRecentFileList(szRecentFileList);
        UpdateRecentFileListMenu(hWnd, szRecentFileList);

        hCurVTResize = LoadCursor(NULL, IDC_SIZEWE);
        SetInfoWindowText(hInfoWnd);

        // forcing the status info window to redraw entirely before initilaizing the treeview.
        RedrawWindow(hInfoWnd, NULL, NULL, RDW_ERASENOW | RDW_UPDATENOW);
    
        PostMessage(hWnd, UM_INIT_TREEVIEW, 0, 0L);

        if (*g_szCmdLine != TEXT('\0'))
        {
            StrCpy(szFileToOpen, g_szCmdLine);
            PostMessage(hWnd, WM_COMMAND, MAKEWPARAM(IDM_FILEOPEN, 0), 1L);
        }

        break;

    case UM_INIT_TREEVIEW:
        InitTreeView(TreeView.GetHandle(), hInfoWnd);
        break;

    case WM_GETMINMAXINFO:
        lpmmi = (LPMINMAXINFO) lParam;
        lpmmi->ptMaxTrackSize.x = MAX_WINDOW_WIDTH;
        lpmmi->ptMaxTrackSize.y = MAX_WINDOW_HEIGHT;
        return FALSE;
    
    case WM_SIZE:
        TreeView.MoveWindow(MARGIN, MARGIN, nTreeViewWidth, (int)HIWORD(lParam)-(2*MARGIN));
        MoveWindow(g_hWndAdmInstr, nTreeViewWidth + (2*MARGIN), 
               MARGIN, LOWORD(lParam) - (nTreeViewWidth + (2*MARGIN)) - MARGIN,
               (int)HIWORD(lParam) - (hInfoWnd ? INFOWINDOW_HEIGHT : 0) - 
               (2*MARGIN), TRUE);

        MoveADMWindow(TreeView.GetHandle(), nTreeViewWidth + (2*MARGIN) + 2, MARGIN + 2,
            LOWORD(lParam) - (nTreeViewWidth + (2*MARGIN)) - MARGIN - 4,
            (int)HIWORD(lParam) - (hInfoWnd ? INFOWINDOW_HEIGHT : 0) - 
            (2*MARGIN) - 4);

        MoveWindow(hWndSizeBar, nTreeViewWidth + MARGIN, MARGIN, 4, (int)HIWORD(lParam)-(2*MARGIN), TRUE);
        MoveWindow(hInfoWnd, nTreeViewWidth + (2*MARGIN), (int)HIWORD(lParam) - INFOWINDOW_HEIGHT - MARGIN,
               LOWORD(lParam) - (nTreeViewWidth + (3*MARGIN)), INFOWINDOW_HEIGHT, TRUE);
        RedrawWindow(hInfoWnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);

        if (g_hDialog)
        {
            SetWindowPos(g_hDialog, HWND_TOP, nTreeViewWidth + (2*MARGIN) + 2, MARGIN + 2, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
            RedrawWindow(g_hDialog, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
        }
        else
        {
            hItem = TreeView.GetSel(); // get selected item
            if (hItem != NULL && IsPolicyTree(hItem))
            {
            HTREEITEM hParentItem = TreeView_GetParent(TreeView.GetHandle(), hItem);
            if (hParentItem != NULL && hParentItem != g_hPolicyRootItem)
            {                                               // is a ADM category
                HWND hWndAdm = GetAdmWindowHandle(TreeView.GetHandle(), hItem); // category window handle
                if (hWndAdm)
                {   
                SetWindowPos(hWndAdm, HWND_TOP, nTreeViewWidth + (2*MARGIN) + 2, MARGIN + 2, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
                RedrawWindow(hWndAdm, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
                }
            }
            }
        }
        break;

    case WM_NOTIFY:
        lpNMTreeView = (NM_TREEVIEW FAR *) lParam;
        if(lpNMTreeView->hdr.code == TVN_SELCHANGED)
        {
            if(bSwitchScreen == FALSE)
            {
                bSwitchScreen = TRUE;
                break;
            }

            if (lpNMTreeView->itemOld.hItem == NULL)
                ; // do nothing.
            else if (!IsPolicyTree(lpNMTreeView->itemOld.hItem)) // is ins item
            {
                if (lpNMTreeView->itemOld.hItem == g_hInsRootItem) // is root ins item
                    ShowADMWindow(TreeView.GetHandle(), FALSE);
                else
                {
                    if(g_hDialog)
                    {
                        if (!(bSwitchScreen = SaveInsDialog(g_hDialog, ITEM_SAVE | ITEM_DESTROY)))
                        {
                            fDirty = !bSwitchScreen;
                            hErrorDlgCtrl = GetFocus();
                            TreeView.SetSel(lpNMTreeView->itemOld.hItem);
                            return 1;
                        }
                        else
                            g_hDialog = NULL;
                    }
                }
            }
            else // is policy item
            {
                if (lpNMTreeView->itemOld.hItem == g_hPolicyRootItem) // is root policy item
                    ShowADMWindow(TreeView.GetHandle(), FALSE);
                else
                    SelectADMItem(hWnd, TreeView.GetHandle(), &lpNMTreeView->itemOld, FALSE, FALSE);
            }

            if (lpNMTreeView->itemNew.hItem == NULL)
                ShowADMWindow(TreeView.GetHandle(), FALSE);
            else if (!IsPolicyTree(lpNMTreeView->itemNew.hItem)) // is ins item
            {
                if(lpNMTreeView->itemNew.hItem == g_hInsRootItem) // is root ins item
                {
                    SetADMWindowText(TreeView.GetHandle(), Res2Str(IDS_WIZARDBRANCHTITLE), Res2Str(IDS_WIZARDBRANCHTEXT));
                }
                else
                {
                    TreeView.GetItemText(lpNMTreeView->itemNew.hItem, szItem, ARRAYSIZE(szItem));
                    for (i = 0; i < g_nDialogs; i++)
                    {
                        if (StrCmp(szItem, g_pInsDialog[i].szName) == 0)
                        {
                            g_hDialog = CreateInsDialog(hWnd, nTreeViewWidth + (2*MARGIN) + 2, MARGIN + 2, i, g_szInsFile, g_szCabWorkDir);
                            if(lstrlen(g_szInsFile) == 0)
                            EnableWindow(g_hDialog, FALSE);
                            break;
                        }
                    }
                }
            }
            else // is policy item
                SelectADMItem(hWnd, TreeView.GetHandle(), &lpNMTreeView->itemNew, TRUE, ISNULL(g_szInsFile));

            SetInfoWindowText(hInfoWnd);
        }
        else if(lpNMTreeView->hdr.code ==  TVN_ITEMEXPANDED)
        {
            tvitem.mask = TVIF_IMAGE;
            tvitem.hItem = lpNMTreeView->itemNew.hItem;
            TreeView_GetItem(TreeView.GetHandle(), &tvitem);

            // If tree item is EXPANDING (opening up) and
            // current icon == CloseFolder, change icon to OpenFolder
            if(lpNMTreeView->action == TVE_EXPAND)
            {
                tvitem1.hItem = lpNMTreeView->itemNew.hItem;
                tvitem1.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                if(tvitem.iImage == g_InsSettingsClose)
                {
                    tvitem1.iImage = g_InsSettingsOpen;
                    tvitem1.iSelectedImage = g_InsSettingsOpen;
                }
                else if(tvitem.iImage == g_PolicyClose)
                {
                    tvitem1.iImage = g_PolicyOpen;
                    tvitem1.iSelectedImage = g_PolicyOpen;
                }
                else if(tvitem.iImage == g_ADMClose)
                {
                    tvitem1.iImage = g_ADMOpen;
                    tvitem1.iSelectedImage = g_ADMOpen;
                }
                else
                    break;
        
                TreeView_SetItem(TreeView.GetHandle(), &tvitem1);
            }
        
            // If tree item is COLLAPSING (closing up) and
            // current icon == OpenFolder, change icon to CloseFolder
            else if(lpNMTreeView->action == TVE_COLLAPSE)
            {
                tvitem1.hItem = lpNMTreeView->itemNew.hItem;
                tvitem1.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                if(tvitem.iImage == g_InsSettingsOpen)
                {
                    tvitem1.iImage = g_InsSettingsClose;
                    tvitem1.iSelectedImage = g_InsSettingsClose;
                }
                else if(tvitem.iImage == g_PolicyOpen)
                {
                    tvitem1.iImage = g_PolicyClose;
                    tvitem1.iSelectedImage = g_PolicyClose;
                }
                else if(tvitem.iImage == g_ADMOpen)
                {
                    tvitem1.iImage = g_ADMClose;
                    tvitem1.iSelectedImage = g_ADMClose;
                }
                else
                    break;
        
                TreeView_SetItem(TreeView.GetHandle(), &tvitem1);
            }
            break;
        }
        else if(lpNMTreeView->hdr.code ==  NM_SETFOCUS)
        {
            if (lpNMTreeView->hdr.hwndFrom == TreeView.GetHandle() && hErrorDlgCtrl != NULL)
            {
                SetFocus(g_hDialog);
                SetFocus(hErrorDlgCtrl);
                hErrorDlgCtrl = NULL;
            }
        }
        return DefWindowProc(hWnd, msg, wParam, lParam);

    case WM_COMMAND:
        // patch: if the message is a button down (return key), send the message to the
        // corresponding window
        if(g_hDialog && HIWORD(wParam) == BN_CLICKED)
        {
            hWndFocus = GetFocus();
            if(IsChild(g_hDialog, hWndFocus) && hWndFocus == (HWND) lParam)
            {
                SendMessage(g_hDialog, msg, MAKEWPARAM(LOWORD(GetDlgCtrlID(hWndFocus)), HIWORD(wParam)), (LPARAM) hWndFocus);
            }
        }

        switch (LOWORD(wParam))
        {
        case IDM_FILEEXIT:
            SendMessage(hWnd, WM_CLOSE, 0, 0);
            break;

        case IDM_FILENEW:
            if(lstrlen(g_szInsFile))
            {
                //save the current page
                SaveCurrentSelItem(TreeView.GetHandle(), ITEM_CHECKDIRTY);
                SetInfoWindowText(hInfoWnd);
                if (IsDirty())
                {
                    int nError;

                    wsprintf(szMsg, Res2Str(IDS_SAVE), lstrlen(g_szFileName) ? g_szFileName : Res2Str(IDS_UNTITLED));
                    switch(MessageBox(hWnd, szMsg, Res2Str(IDS_TITLE), MB_YESNOCANCEL))
                    {
                    case IDCANCEL:
                        return 1;

                    case IDYES:
                        nError = (int) SendMessage(hWnd, WM_COMMAND, MAKEWPARAM(IDM_FILESAVE, 0), 0);
                        if (nError == PAGE_ERROR || nError == SAVE_ERROR || nError == SAVE_CANCEL)
                            return 1;
                        break;
        
                    case IDNO:
                        break;
                    }
                }
                ZeroMemory(g_szFileName, sizeof(g_szFileName));
            }

            ZeroMemory(g_szCabsURLPath, sizeof(g_szCabsURLPath));

            ZeroMemory(g_szConfigURLPath, sizeof(g_szConfigURLPath));
            ZeroMemory(g_szDesktopURLPath, sizeof(g_szDesktopURLPath));

            ZeroMemory(g_szConfigCabName, sizeof(g_szConfigCabName));
            ZeroMemory(g_szDesktopCabName, sizeof(g_szDesktopCabName));

            ZeroMemory(g_szNewVersionStr, sizeof(g_szNewVersionStr));

            EnableWindow(TreeView.GetHandle(), TRUE);
            DeleteCabWorkDirs();
            SaveCurrentSelItem(TreeView.GetHandle(), ITEM_DESTROY);
            TreeView.SetSel(NULL);
            ResetAdmFiles(TreeView.GetHandle(), g_szCabWorkDir, FALSE);
            NewTempFile();
            CreateCabWorkDirs(TEXT("new"));
            SetTitleBar(hWnd, NULL);
            WritePrivateProfileString(TEXT("Branding"), TEXT("Language Locale"), g_szLanguage, g_szInsFile);
            if(g_dwLanguage != 0xffffffff)
            {
                wsprintf(szLangId, TEXT("%lu"), g_dwLanguage);
                WritePrivateProfileString(TEXT("Branding"), TEXT("Language ID"), szLangId, g_szInsFile);
            }
            WritePrivateProfileString(URL_SECT, TEXT("AutoConfig"), TEXT("0"), g_szInsFile);

            // Collapse all policy treeview items that has been expanded
            TreeView.CollapseChildNodes(g_hPolicyRootItem);

            TreeView.SetSel(g_pInsDialog[0].hItem);
            SetFocus(TreeView.GetHandle());
            ClearDirtyFlag();
            SetInfoWindowText(hInfoWnd);
            break;

        case IDM_FILESAVE:
            if (!SaveCurrentSelItem(TreeView.GetHandle(), ITEM_SAVE))
                return PAGE_ERROR;
            SetInfoWindowText(hInfoWnd);
        
            dwCabBuildStatus = GetCabBuildStatus();

            DirectoryName(g_szFileName, szTemp); // szTemp will contain the INS path.

            if((PathFileExists(g_szFileName) && 
               ((!HasFlag(dwCabBuildStatus, CAB_TYPE_CONFIG) && 
                !HasFlag(dwCabBuildStatus, CAB_TYPE_DESKTOP)) || *g_szCabsURLPath) &&
               (!HasFlag(dwCabBuildStatus, CAB_TYPE_CONFIG)   || *g_szConfigCabName)    &&
               (!HasFlag(dwCabBuildStatus, CAB_TYPE_DESKTOP)  || *g_szDesktopCabName)) &&
               !IsFileReadOnly(g_szFileName) && !IsFileReadOnly(g_szConfigCabName, szTemp) && 
               !IsFileReadOnly(g_szDesktopCabName, szTemp))
            {
                SetInfoWindowText(hInfoWnd, Res2Str(IDS_SAVEFILEMSG));
                wsprintf(szTemp, TEXT("%d"), g_dwPlatformId);
                WritePrivateProfileString(TEXT("Branding"), TEXT("Platform"), szTemp, g_szInsFile);
                SaveAdmFiles(TreeView.GetHandle(), g_szCabWorkDir, g_szInsFile);
                PrepareFolderForCabbing(g_szCabWorkDir, PM_COPY | PM_CLEAR);
                if (!DialogBox(s_hInstIeakUI, MAKEINTRESOURCE(IDD_DISPLAYSAVE), hWnd, DisplaySaveDlgProc))
                {
                    SetInfoWindowText(hInfoWnd, Res2Str(IDS_READYMSG));
                    return SAVE_ERROR;
                }
                SetInfoWindowText(hInfoWnd, Res2Str(IDS_READYMSG));
                ClearDirtyFlag();
                SetInfoWindowText(hInfoWnd);
                break;
            }
            // fallthrough

        case IDM_FILESAVEAS:
            if (LOWORD(wParam) == IDM_FILESAVEAS && !SaveCurrentSelItem(TreeView.GetHandle(), ITEM_SAVE))
                return PAGE_ERROR;
            SetInfoWindowText(hInfoWnd);
            StrCpy(szTempFile, g_szFileName);
            if(DialogBox(s_hInstIeakUI, MAKEINTRESOURCE(IDD_SAVEAS), hWnd, SaveAsDlgProc) == 0)
            {
                SetInfoWindowText(hInfoWnd, Res2Str(IDS_SAVEFILEMSG));
                wsprintf(szTemp, TEXT("%d"), g_dwPlatformId);
                WritePrivateProfileString(TEXT("Branding"), TEXT("Platform"), szTemp, g_szInsFile);
                SaveAdmFiles(TreeView.GetHandle(), g_szCabWorkDir, g_szInsFile);
                PrepareFolderForCabbing(g_szCabWorkDir, PM_COPY | PM_CLEAR);
                if (!DialogBox(s_hInstIeakUI, MAKEINTRESOURCE(IDD_DISPLAYSAVE), hWnd, DisplaySaveDlgProc))
                {
                    SetInfoWindowText(hInfoWnd, Res2Str(IDS_READYMSG));
            
                    // revert back the previous INS filename and CAB names.
                    StrCpy(g_szFileName, szTempFile);
                    GetCabName(g_szFileName, CAB_TYPE_CONFIG, g_szConfigCabName);
                    GetCabName(g_szFileName, CAB_TYPE_DESKTOP, g_szDesktopCabName);
            
                    return SAVE_ERROR;
                }
                SetTitleBar(hWnd, g_szFileName);
                UpdateRecentFileList(g_szFileName, TRUE, szRecentFileList);
                UpdateRecentFileListMenu(hWnd, szRecentFileList);
                SetInfoWindowText(hInfoWnd, Res2Str(IDS_READYMSG));
                ClearDirtyFlag();
                SetInfoWindowText(hInfoWnd);
            }
            else
                return SAVE_CANCEL;
            break;

        case IDM_FILEOPEN:
            if(lstrlen(g_szInsFile))
            {
                SaveCurrentSelItem(TreeView.GetHandle(), ITEM_CHECKDIRTY);
                SetInfoWindowText(hInfoWnd);
                if (IsDirty())
                {
                    int nError;
                    
                    wsprintf(szMsg, Res2Str(IDS_SAVE), lstrlen(g_szFileName) ? g_szFileName : Res2Str(IDS_UNTITLED));
                    switch(MessageBox(hWnd, szMsg, Res2Str(IDS_TITLE), MB_YESNOCANCEL))
                    {
                    case IDCANCEL:
                        return 1;

                    case IDYES:
                        nError = (int) SendMessage(hWnd, WM_COMMAND, MAKEWPARAM(IDM_FILESAVE, 0), 0);
                        if (nError == PAGE_ERROR || nError == SAVE_ERROR || nError == SAVE_CANCEL)
                            return 1;
                        break;

                    case IDNO:
                        break;
                    }
                }
            }

            ZeroMemory(szTempFile, sizeof(szTempFile));

            ZeroMemory(szFilter, sizeof(szFilter));
            LoadString(g_hInst, IDS_INSFILTERNAME, szFilter, ARRAYSIZE(szFilter));
            pszFilter = szFilter + lstrlen(szFilter) + 1;
            lstrcpy(pszFilter, TEXT("*.ins"));

            if (lParam == 0)
            {
                if (!BrowseForFileEx(hWnd, szFilter, szTempFile, ARRAYSIZE(szTempFile), TEXT("*.ins")))
                    break;
            }
            else
                StrCpy(szTempFile, szFileToOpen);

            if (PathFileExists(szTempFile))
            {
                LPTSTR pExtn;
                TCHAR szLang[10];
                DWORD dwInsPlatformId;
        
                pExtn = PathFindExtension(szTempFile);
                if (pExtn == NULL || ((StrCmpI(pExtn, TEXT(".ins")) != 0) && (StrCmpI(pExtn, TEXT(".INS")) != 0)))  //looks weird, but hack is needed for turkish locale
                {
                    MessageBox(hWnd, Res2Str(IDS_INVALIDEXTN), Res2Str(IDS_TITLE), MB_OK);
                    break;
                }
        
                // check if it is a Win32/W2K INS file
                if (!IsWin32INSFile(szTempFile))
                    break;

                // check if the associated cab files are available.
                if (CabFilesExist(hWnd, szTempFile))
                {
                    // check whether the INS language matches the language selected in the profile manager.
                    GetPrivateProfileString(TEXT("Branding"), TEXT("Language Locale"), TEXT(""), 
                                szLang, ARRAYSIZE(szLang), szTempFile);

                    if (StrCmpI(szLang, g_szLanguage) != 0)
                    {
                        TCHAR szMsg[MAX_PATH];

                        wsprintf(szMsg, Res2Str(IDS_LANGDIFFERS), szTempFile);
                        if (MessageBox(hWnd, szMsg, Res2Str(IDS_TITLE), 
                               MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDNO)
                            break;
                    }
        
                    // check if the selected platform Optional cab is available for the selected language.
                    dwInsPlatformId = GetPrivateProfileInt(TEXT("Branding"), TEXT("Platform"), 
                                           IDM_PLATFORM_WIN32, szTempFile);
        
                    if (!PlatformExists(hWnd, g_szLanguage, dwInsPlatformId, TRUE))
                        break;
                    
                    ZeroMemory(g_szCabsURLPath, sizeof(g_szCabsURLPath));

                    ZeroMemory(g_szConfigURLPath, sizeof(g_szConfigURLPath));
                    ZeroMemory(g_szDesktopURLPath, sizeof(g_szDesktopURLPath));

                    ZeroMemory(g_szConfigCabName, sizeof(g_szConfigCabName));
                    ZeroMemory(g_szDesktopCabName, sizeof(g_szDesktopCabName));

                    ZeroMemory(g_szNewVersionStr, sizeof(g_szNewVersionStr));

                    EnableWindow(TreeView.GetHandle(), TRUE);
                    SetInfoWindowText(hInfoWnd, Res2Str(IDS_OPENFILEMSG));
                    DeleteCabWorkDirs();
                    if (*g_szInsFile)
                    {
                        DeleteFile(g_szInsFile);
                        ZeroMemory(g_szInsFile, sizeof(g_szInsFile));
                    }
                    SaveCurrentSelItem(TreeView.GetHandle(), ITEM_DESTROY);
                    TreeView.SetSel(NULL);

                    ResetAdmFiles(TreeView.GetHandle(), g_szCabWorkDir, FALSE);

                    lstrcpy(g_szFileName, szTempFile);
                    SetTitleBar(hWnd, g_szFileName);

                    switch(dwInsPlatformId)
                    {
                    case PLATFORM_W2K:
                        SendMessage(hWnd, WM_COMMAND, MAKEWPARAM(IDM_PLATFORM_W2K, 0), 0L);
                        break;

                    case PLATFORM_WIN32:
                    default:
                        SendMessage(hWnd, WM_COMMAND, MAKEWPARAM(IDM_PLATFORM_WIN32, 0), 0L);
                        break;
                    }

                    NewTempFile();
                    CopyFile(g_szFileName, g_szInsFile, FALSE);
                    SetFileAttributes(g_szInsFile, FILE_ATTRIBUTE_NORMAL);

                    ExtractCabFile();

                    // Collapse all policy treeview items that has been expanded
                    TreeView.CollapseChildNodes(g_hPolicyRootItem);
        
                    TreeView.SetSel(g_pInsDialog[0].hItem);
                    SetFocus(TreeView.GetHandle());

                    ResetAdmFiles(TreeView.GetHandle(), g_szCabWorkDir, TRUE);
                    SetInfoWindowText(hInfoWnd, Res2Str(IDS_READYMSG));

                    lstrcpy(szTemp, szTempFile);
                    PathRemoveFileSpec(szTemp);
                    lstrcpy(g_szCurrInsPath, szTemp);
                
                    UpdateRecentFileList(szTempFile, TRUE, szRecentFileList);
                }
            }
            else
            {
                TCHAR szErrMsg[MAX_PATH + 20];
                TCHAR szStr[MAX_PATH];

                LoadString(g_hInst, IDS_FILENOTFOUND, szStr, ARRAYSIZE(szStr));
                wsprintf(szErrMsg, szStr, szTempFile);
                MessageBox(hWnd, szErrMsg, Res2Str(IDS_TITLE), MB_OK | MB_ICONEXCLAMATION);
                UpdateRecentFileList(szTempFile, FALSE, szRecentFileList);
            }
            UpdateRecentFileListMenu(hWnd, szRecentFileList);
            ClearDirtyFlag();
            SetInfoWindowText(hInfoWnd);
            break;

        case IDM_ADMIMPORT:
            wsprintf(szTemp, TEXT("%sPolicies\\%s"), g_szRoot, g_szLanguage);
            ImportADMFile(hWnd, TreeView.GetHandle(), szTemp, g_szCabWorkDir, ROLE_CORP, g_szInsFile);
            break;

        case IDM_ADMDELETE:
            LoadString(g_hInst, IDS_ADMDELWARN, szMsg, ARRAYSIZE(szMsg));
            if(MessageBox(hWnd, szMsg, Res2Str(IDS_TITLE), MB_ICONQUESTION|MB_YESNO) == IDYES)
            {
                hItem = TreeView.GetSel();
                DeleteADMItem(TreeView.GetHandle(), hItem, g_szCabWorkDir, g_szInsFile, TRUE, TRUE);
            }
            break;

        case IDM_CHKDUPKEYS:
            hItem = TreeView.GetSel();
            CheckForDupKeys(g_hMain, TreeView.GetHandle(), hItem, TRUE);
            break;

        case IDM_PLATFORM_WIN32:
        case IDM_PLATFORM_W2K:
            InitializePlatform(hWnd, hInfoWnd, LOWORD(wParam));
            break;

        case IDM_HELP:
            SendMessage(hWnd, WM_HELP, 0, 0L);
            break;
        }

        if (LOWORD(wParam) >= IDM_RECENTFILELIST && LOWORD(wParam) < IDM_RECENTFILELIST + 5)
        {
            if (!(LOWORD(wParam) == IDM_RECENTFILELIST && StrCmpI(g_szFileName, szRecentFileList[0]) == 0))
            {
                StrCpy(szFileToOpen, szRecentFileList[LOWORD(wParam) - IDM_RECENTFILELIST]);
                SendMessage(hWnd, WM_COMMAND, MAKEWPARAM(IDM_FILEOPEN, 0), 1L);
            }
        }
        break;

    case WM_MENUSELECT:
        if(LOWORD(wParam) == 0) // FILE menu
        {
            hMenu = GetSubMenu((HMENU) lParam, 0);
            if(lstrlen(g_szInsFile) == 0)
            {
                EnableMenuItem(hMenu, IDM_FILESAVE, MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem(hMenu, IDM_FILESAVEAS, MF_BYCOMMAND | MF_GRAYED);
            }
            else
            {
                EnableMenuItem(hMenu, IDM_FILESAVE, MF_BYCOMMAND | MF_ENABLED);
                EnableMenuItem(hMenu, IDM_FILESAVEAS, MF_BYCOMMAND | MF_ENABLED);
            }
        }
        else if(LOWORD(wParam) == 1) // POLICY menu
        {
            hItem = TreeView.GetSel();
            hMenu = GetSubMenu((HMENU) lParam, 1); 
            if(!IsPolicyTree(hItem) || hItem == g_hPolicyRootItem ||
               TreeView_GetParent(TreeView.GetHandle(), hItem) != g_hPolicyRootItem ||
               !CanDeleteADM(TreeView.GetHandle(), hItem))
            {
                EnableMenuItem(hMenu, IDM_ADMDELETE, MF_BYCOMMAND | MF_GRAYED);
            }
            else
                EnableMenuItem(hMenu, IDM_ADMDELETE, MF_BYCOMMAND | MF_ENABLED);
        
            if(!IsPolicyTree(hItem) || hItem == g_hPolicyRootItem ||
               TreeView_GetParent(TreeView.GetHandle(), hItem) != g_hPolicyRootItem)
            {
                EnableMenuItem(hMenu, IDM_CHKDUPKEYS, MF_BYCOMMAND | MF_GRAYED);
            }
            else
                EnableMenuItem(hMenu, IDM_CHKDUPKEYS, MF_BYCOMMAND | MF_ENABLED);

            if(lstrlen(g_szLanguage))
                EnableMenuItem(hMenu, IDM_ADMIMPORT, MF_BYCOMMAND | MF_ENABLED);
            else
                EnableMenuItem(hMenu, IDM_ADMIMPORT, MF_BYCOMMAND | MF_GRAYED);
        }
        break;

    case WM_HELP:
        if (GetForegroundWindow() != g_hMain)
            break;

        hItem = TreeView.GetSel();
        if (hItem != NULL)
        {
            if (TreeView_GetParent(TreeView.GetHandle(), hItem) != NULL && !IsPolicyTree(hItem))
            {
                TreeView.GetItemText(hItem, szItem, countof(szItem));
                for(i = 0; i < g_nDialogs; i++)
                {
                    if(StrCmp(szItem, g_pInsDialog[i].szName) == 0)
                    IeakPageHelp(hWnd, g_pInsDialog[i].DlgId);
                }
            }
            else if (hItem == g_hInsRootItem)
                IeakPageHelp(hWnd, MAKEINTRESOURCE(IDD_CORPWELCOME));
            else if (IsPolicyTree(hItem))
                IeakPageHelp(hWnd, MAKEINTRESOURCE(IDD_ADM));
        }
        break;

    case WM_MOUSEMOVE:
        fCanResize = FALSE;
        if (GetCapture() == hWnd)
        {
            DrawTrackLine(hWnd, nPrevXPos);
            DrawTrackLine(hWnd, LOWORD(lParam));
            nPrevXPos = LOWORD(lParam);
            break;
        }

        GetWindowRect(hWndSizeBar, &rect1);
        {
        int nXPos = LOWORD(lParam);
        int nYPos = HIWORD(lParam);
        POINT ptLeftTop;
        POINT ptRightBottom;

        ptLeftTop.x = rect1.left;
        ptLeftTop.y = rect1.top;
        ScreenToClient(hWnd, &ptLeftTop);

        ptRightBottom.x = rect1.right;
        ptRightBottom.y = rect1.bottom;
        ScreenToClient(hWnd, &ptRightBottom);

        if (nXPos >= ptLeftTop.x - 1 && nXPos <= ptRightBottom.x && nYPos >= ptLeftTop.y && nYPos <= ptRightBottom.y)
        {
            fCanResize = TRUE;
            SetCursor(hCurVTResize);
        }
        }
        break;

    case WM_LBUTTONDOWN:
        if (fCanResize)
        {
            POINT pt;
            RECT rectTrack;
            HDC hDC = NULL;

            GetWindowRect(TreeView.GetHandle(), &rect1);
            rect2.left = rect1.left + 10;
            rect2.top = rect1.top;
            rect2.right = rect2.left + TREEVIEW_WIDTH - 10 + 1;
            rect2.bottom = rect2.top + (rect1.bottom - rect1.top);
            ClipCursor(&rect2);
        
            pt.x = 0;
            pt.y = HIWORD(lParam);
            ClientToScreen(hWnd, &pt);
        
            GetWindowRect(hWndSizeBar, &rect1);

            SetCursor(hCurVTResize);
            SetCursorPos(rect1.left, pt.y);
            SetCapture(hWnd);

            pt.x = rect1.left;
            pt.y = 0;
            ScreenToClient(hWnd, &pt);

            DrawTrackLine(hWnd, pt.x);
            nPrevXPos = pt.x;
        }
        break;

    case WM_LBUTTONUP:
        if (GetCapture() == hWnd)
        {
            RECT rectWnd;

            ReleaseCapture();
            ClipCursor(NULL);
            DrawTrackLine(hWnd, nPrevXPos);

            nTreeViewWidth = nPrevXPos - MARGIN;

            GetWindowRect(TreeView.GetHandle(), &rect1);
            GetWindowRect(hWnd, &rectWnd);
            SetWindowPos(hWnd, HWND_TOP, 0, 0, (rectWnd.right - rectWnd.left) + (nTreeViewWidth - (rect1.right - rect1.left)),
                 rectWnd.bottom - rectWnd.top, SWP_NOMOVE | SWP_NOZORDER);
        }
        break;

    case WM_CLOSE:
        if(*g_szInsFile != TEXT('\0'))
        {
            SaveCurrentSelItem(TreeView.GetHandle(), ITEM_CHECKDIRTY);
            SetInfoWindowText(hInfoWnd);
            if (IsDirty())
            {
                int nError;

                wsprintf(szMsg, Res2Str(IDS_SAVE), (*g_szFileName != TEXT('\0')) ? g_szFileName : Res2Str(IDS_UNTITLED));
                switch(MessageBox(hWnd, szMsg, Res2Str(IDS_TITLE), MB_YESNOCANCEL))
                {
                case IDYES:
                    nError = (int) SendMessage(hWnd, WM_COMMAND, MAKEWPARAM(IDM_FILESAVE, 0), 0);
                    if (nError == PAGE_ERROR || nError == SAVE_ERROR || nError == SAVE_CANCEL)
                    return 1;
                    break;

                case IDCANCEL:
                    return 1;

                case IDNO:
                    break;
                }
            }
            ZeroMemory(g_szFileName, sizeof(g_szFileName));
            DeleteFile(g_szInsFile);
            ZeroMemory(g_szInsFile, sizeof(g_szInsFile));
        }

        if (RegCreateKeyEx(HKEY_CURRENT_USER, RK_IEAK_SERVER TEXT("\\ProfMgr"), 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
        {
            RegSetValueEx(hKey, TEXT("LastOpenedPath"), 0, dwType, (const BYTE*) g_szCurrInsPath, lstrlen(g_szCurrInsPath) + 1);
            RegSetValueEx(hKey, TEXT("TreeviewWidth"), 0, REG_DWORD, (const BYTE*) &nTreeViewWidth, sizeof(DWORD));
            RegCloseKey(hKey);
        }
    
        SaveCurrentSelItem(TreeView.GetHandle(), ITEM_DESTROY);
        DeleteADMItems(TreeView.GetHandle(), g_szCabWorkDir, g_szInsFile, TRUE);
        DestroyWindow(g_hWndAdmInstr);
        DestroyADMWindow(TreeView.GetHandle());
        DeleteCabWorkDirs();
        WriteRecentFileList(szRecentFileList);

        ReleaseCapture();
        ClipCursor(NULL);

        if (g_hWndHelp != NULL)
            SendMessage(g_hWndHelp, WM_CLOSE, 0, 0L);

        return DefWindowProc(hWnd, msg, wParam, lParam);

    case WM_DESTROY:
        DeleteFile(g_szInsFile);
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, msg, wParam, lParam);
    }
    return 1;
}

void DrawTrackLine(HWND hWnd, int nXPos)
{
    RECT rectTV;
    RECT rectTrack;
    HDC hDC = NULL;

    GetWindowRect(TreeView.GetHandle(), &rectTV);
    
    rectTrack.left = nXPos;
    rectTrack.top = MARGIN;
    rectTrack.right= nXPos + 4;
    rectTrack.bottom = rectTrack.top + (rectTV.bottom - rectTV.top);

    hDC = GetDC(hWnd);
    InvertRect(hDC, &rectTrack);
    ReleaseDC(hWnd, hDC);
}

BOOL CanOverwriteFiles(HWND hDlg)
{
    TCHAR szExistingFiles[MAX_PATH*5];
    TCHAR szTemp[MAX_PATH];
    TCHAR szDir[MAX_PATH];
    TCHAR szFile[MAX_PATH];
    TCHAR szReadOnlyFiles[MAX_PATH*5];

    *szExistingFiles = TEXT('\0');
    *szReadOnlyFiles = TEXT('\0');
    // check for file already exists in the destination directory.
    GetDlgItemText(hDlg, IDE_INSFILE, szTemp, ARRAYSIZE(szTemp));
    if (PathFileExists(szTemp))
    {
        StrCat(szExistingFiles, szTemp);
        StrCat(szExistingFiles, TEXT("\r\n"));

        if (IsFileReadOnly(szTemp))
            StrCpy(szReadOnlyFiles, szExistingFiles);
    }

    StrCpy(szDir, szTemp);
    PathRemoveFileSpec(szDir);
    
    if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB1NAME)))
    {
        GetDlgItemText(hDlg, IDE_CAB1NAME, szTemp, ARRAYSIZE(szTemp));
        PathCombine(szFile, szDir, szTemp);
        if (PathFileExists(szFile))
        {
            StrCat(szExistingFiles, szFile);
            StrCat(szExistingFiles, TEXT("\r\n"));

            if (IsFileReadOnly(szFile))
            {
                StrCat(szReadOnlyFiles, szFile);
                StrCat(szReadOnlyFiles, TEXT("\r\n"));
            }
        }
    }
    
    if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB2NAME)))
    {
        GetDlgItemText(hDlg, IDE_CAB2NAME, szTemp, ARRAYSIZE(szTemp));
        PathCombine(szFile, szDir, szTemp);
        if (PathFileExists(szFile))
        {
            StrCat(szExistingFiles, szFile);
            StrCat(szExistingFiles, TEXT("\r\n"));

            if (IsFileReadOnly(szFile))
            {
                StrCat(szReadOnlyFiles, szFile);
                StrCat(szReadOnlyFiles, TEXT("\r\n"));
            }
        }
    }
    
    if (*szReadOnlyFiles != TEXT('\0'))
    {
        TCHAR szMsg[MAX_PATH*6];

        wsprintf(szMsg, Res2Str(IDS_FILE_READONLY), szReadOnlyFiles);
        MessageBox(hDlg, szMsg, Res2Str(IDS_TITLE), MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }

    if (*szExistingFiles != TEXT('\0'))
    {
        TCHAR szMsg[MAX_PATH*6];

        wsprintf(szMsg, Res2Str(IDS_FILE_ALREADY_EXISTS), szExistingFiles);
        if (MessageBox(hDlg, szMsg, Res2Str(IDS_TITLE), 
                       MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2) == IDNO)
            return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK SaveAsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szInsFile[MAX_PATH];
    TCHAR szCabsURL[INTERNET_MAX_URL_LENGTH];
    TCHAR szPrefix[MAX_PATH];
    TCHAR szCabName[MAX_PATH];
    HWND hCtrl;
    TCHAR szFilter[MAX_PATH];
    LPTSTR pszFilter = NULL;
    TCHAR szTemp[MAX_PATH];
    DWORD dwCabBuildStatus = 0;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_INSFILE);                   // enable DBCS chars
        EnableDBCSChars(hDlg, IDE_CABSURL);
        EnableDBCSChars(hDlg, IDE_CAB1NAME);
        EnableDBCSChars(hDlg, IDE_CAB2NAME);

        // since base INS filename will be used as prefix to the respective
        // cab names and the largest cab suffix string is _channnels.cab (which has
        // 13 chars in it), the prefix can be at the max only 246 chars long.
        // So limit the text to be entered in the IDE_INSFILE to MAX_PATH - 20.
        Edit_LimitText(GetDlgItem(hDlg, IDE_INSFILE), ARRAYSIZE(g_szFileName) - 20);

        Edit_LimitText(GetDlgItem(hDlg, IDE_CABSURL), ARRAYSIZE(g_szCabsURLPath) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CAB1NAME), ARRAYSIZE(g_szConfigCabName) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CAB2NAME), ARRAYSIZE(g_szDesktopCabName) - 1);

        dwCabBuildStatus = GetCabBuildStatus();

        if (!HasFlag(dwCabBuildStatus, CAB_TYPE_CONFIG))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_CAB1TEXT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDE_CAB1NAME), FALSE);
        }

        if (!HasFlag(dwCabBuildStatus, CAB_TYPE_DESKTOP))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_CAB2TEXT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDE_CAB2NAME), FALSE);
        }

        if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB1NAME)) && 
            !IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB2NAME)))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_CABSURLTEXT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDE_CABSURL), FALSE);
        }
    
        *szPrefix = TEXT('\0');
        //----------------- InsFile
        if (PathFileExists(g_szFileName))
        {
            SetDlgItemText(hDlg, IDE_INSFILE, g_szFileName);

            GetBaseFileName(g_szFileName, szPrefix, ARRAYSIZE(szPrefix));
            if(StrCmpI(szPrefix, TEXT("install")) == 0)
                StrCpy(szPrefix, TEXT("Default"));
        }

        //----------------- CabsURLPath
        if (*g_szCabsURLPath)
            SetDlgItemText(hDlg, IDE_CABSURL, g_szCabsURLPath);

        
        //----------------- Config
        if (HasFlag(dwCabBuildStatus, CAB_TYPE_CONFIG))
        {
            if (*g_szConfigCabName == TEXT('\0'))
                GetDefaultCabName(CAB_TYPE_CONFIG, szPrefix, szCabName);
            else
                GetDefaultCabName(CAB_TYPE_CONFIG, g_szConfigCabName, szCabName);
            SetDlgItemText(hDlg, IDE_CAB1NAME, szCabName);
        }

        //----------------- Desktop
        if (HasFlag(dwCabBuildStatus, CAB_TYPE_DESKTOP))
        {
            if (*g_szDesktopCabName == TEXT('\0'))
                GetDefaultCabName(CAB_TYPE_DESKTOP, szPrefix, szCabName);
            else
                GetDefaultCabName(CAB_TYPE_DESKTOP, g_szDesktopCabName, szCabName);
            SetDlgItemText(hDlg, IDE_CAB2NAME, szCabName);
        }

        //----------------- Version
        if (*g_szNewVersionStr == TEXT('\0'))
            GenerateNewVersionStr(g_szFileName, g_szNewVersionStr);
        SetDlgItemText(hDlg, IDC_CABVERSION, g_szNewVersionStr);

        return TRUE;

    case WM_COMMAND:
        switch (wParam)
        {
        case IDOK:
            GetDlgItemText(hDlg, IDE_INSFILE, szInsFile, ARRAYSIZE(szInsFile));
            if(*szInsFile != TEXT('\0') && (StrCmpI(PathFindExtension(szInsFile), TEXT(".ins")) != 0) && (StrCmpI(PathFindExtension(szInsFile), TEXT(".INS")) != 0))
            {
                MessageBox(hDlg, Res2Str(IDS_INVALIDEXTN), Res2Str(IDS_TITLE), MB_OK);
                SendMessage(hCtrl = GetDlgItem(hDlg, IDE_INSFILE), EM_SETSEL, 0, -1);
                SetFocus(hCtrl);
            }
            else if (IsFileCreatable(szInsFile))
            {
                ZeroMemory(szCabsURL, sizeof(szCabsURL));
                if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_CABSURL)) ||
                    (GetDlgItemText(hDlg, IDE_CABSURL, szCabsURL, ARRAYSIZE(szCabsURL)) && PathIsURL(szCabsURL)))
                {
                    int nLen = 0;
                    if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB1NAME)) ||
                        ((nLen = GetDlgItemText(hDlg, IDE_CAB1NAME, szCabName, ARRAYSIZE(szCabName)))))
                    {
                        if (!IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB2NAME)) ||
                            ((nLen = GetDlgItemText(hDlg, IDE_CAB2NAME, szCabName, ARRAYSIZE(szCabName)))))
                        {
                            if(!CanOverwriteFiles(hDlg))
                                return TRUE;
                
                            StrCpy(g_szFileName, szInsFile);
                            StrCpy(g_szCabsURLPath, szCabsURL);

                            GetDlgItemText(hDlg, IDE_CAB1NAME, g_szConfigCabName, ARRAYSIZE(g_szConfigCabName));
                            GetDlgItemText(hDlg, IDE_CAB2NAME, g_szDesktopCabName, ARRAYSIZE(g_szDesktopCabName));

                            // clear out the version buffer so that it gets initialized properly in SetOrClearVersionInfo
                            ZeroMemory(g_szNewVersionStr, sizeof(g_szNewVersionStr));

                            EndDialog(hDlg, 0);
                            lstrcpy(szTemp, szInsFile);
                            PathRemoveFileSpec(szTemp);
                            lstrcpy(g_szCurrInsPath, szTemp);
                            break;
                        }
                        else
                            hCtrl = GetDlgItem(hDlg, IDE_CAB2NAME);
                    }
                    else
                        hCtrl = GetDlgItem(hDlg, IDE_CAB1NAME);

                    MessageBox(hDlg, Res2Str(IDS_MUSTSPECIFYNAME), Res2Str(IDS_TITLE), MB_OK);
                    SendMessage(hCtrl, EM_SETSEL, 0, -1);
                    SetFocus(hCtrl);
                }
                else
                {
                    hCtrl = GetDlgItem(hDlg, IDE_CABSURL);

                    MessageBox(hDlg, Res2Str(IDS_MUSTSPECIFYURL), Res2Str(IDS_TITLE), MB_OK);
                    SendMessage(hCtrl, EM_SETSEL, 0, -1);
                    SetFocus(hCtrl);
                }
            }
            else
            {
                MessageBox(hDlg, Res2Str(IDS_CANTCREATEFILE), Res2Str(IDS_TITLE), MB_OK);
                SendMessage(hCtrl = GetDlgItem(hDlg, IDE_INSFILE), EM_SETSEL, 0, -1);
                SetFocus(hCtrl);
            }
            return TRUE;

        case IDCANCEL:
            EndDialog(hDlg, -1);
            break;

        case IDC_INSBROWSE:
            *szInsFile = TEXT('\0');
            GetDlgItemText(hDlg, IDE_INSFILE, szInsFile, ARRAYSIZE(szInsFile));

            ZeroMemory(szFilter, sizeof(szFilter));
            LoadString(g_hInst, IDS_INSFILTERNAME, szFilter, ARRAYSIZE(szFilter));
            pszFilter = szFilter + lstrlen(szFilter) + 1;
            lstrcpy(pszFilter, TEXT("*.ins"));

            if (BrowseForSave(hDlg, szFilter, szInsFile, ARRAYSIZE(szInsFile), TEXT("*.ins")))
                SetDlgItemText(hDlg, IDE_INSFILE, szInsFile);
            return TRUE;

        }

        if (LOWORD(wParam) == IDE_INSFILE && HIWORD(wParam) == EN_CHANGE)
        {
            GetDlgItemText(hDlg, IDE_INSFILE, szInsFile, ARRAYSIZE(szInsFile));
            if(*szInsFile != TEXT('\0') && StrCmpI(PathFindExtension(szInsFile), TEXT(".ins")) == 0)
            {
                GetBaseFileName(szInsFile, szPrefix, ARRAYSIZE(szPrefix));
                if(StrCmpI(szPrefix, TEXT("install")) == 0)
                    StrCpy(szPrefix, TEXT("Default"));

                if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB1NAME)))
                {
                    TCHAR  szTempCabName[MAX_PATH];

                    GetDlgItemText(hDlg, IDE_CAB1NAME, szTempCabName, countof(szTempCabName));
                    if (*szTempCabName == TEXT('\0') ||
                        (StrStrI(szTempCabName, TEXT("_config.cab")) != NULL))
                    {
                        GetDefaultCabName(CAB_TYPE_CONFIG, szPrefix, szCabName);
                        SetDlgItemText(hDlg, IDE_CAB1NAME, szCabName);
                    }
                }

                if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CAB2NAME)))
                {
                    TCHAR  szTempCabName[MAX_PATH];

                    GetDlgItemText(hDlg, IDE_CAB2NAME, szTempCabName, countof(szTempCabName));
                    if (*szTempCabName == TEXT('\0') ||
                        (StrStrI(szTempCabName, TEXT("_desktop.cab")) != NULL))
                    {
                        GetDefaultCabName(CAB_TYPE_DESKTOP, szPrefix, szCabName);
                        SetDlgItemText(hDlg, IDE_CAB2NAME, szCabName);
                    }
                }
            }
        }
        break;
    }

    return FALSE;
}

int APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow)
{
    HANDLE hMutex;
    HINSTANCE hInsDll;
    WNDCLASSEX wc;
    MSG msg;
    TCHAR* pLastSlash = NULL;
    DWORD dwSize, dwIEVer;
    int iType;

    dwSize = sizeof(DWORD);

    if (SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\IEAK"), TEXT("Mode"), NULL, &iType, &dwSize) == ERROR_SUCCESS)
    {
        if ((iType == REDIST) || (iType == BRANDED))
        {
            ErrorMessageBox(NULL, IDS_REQUIRE_CORPMODE);
            return FALSE;
        }
    }

    // allow only one instance running at a time
    hMutex = CreateMutex(NULL, TRUE, TEXT("IEAK6ProfMgr.Mutex"));
    if ((hMutex != NULL) && (GetLastError() == ERROR_ALREADY_EXISTS))
    {
        CloseHandle(hMutex);
        ErrorMessageBox(NULL, IDS_ERROR_MULTPROFMGR);
        return FALSE;
    }

    g_hInst = hInst;
    s_hInstIeakUI = LoadLibrary(TEXT("ieakui.dll"));

    if (s_hInstIeakUI == NULL)
        return (int)FALSE;

    ZeroMemory(g_szFileName, sizeof(g_szFileName));
    ZeroMemory(g_szInsFile, sizeof(g_szInsFile));
    ZeroMemory(g_szCabWorkDir, sizeof(g_szCabWorkDir));

    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = 0;
    wc.lpfnWndProc = WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInst;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_ICON1));
    wc.hIconSm = LoadIcon(hInst, MAKEINTRESOURCE(IDI_ICON1));
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = TEXT("InsEdit4Class");
    
    if(!RegisterClassEx(&wc))
    {
        FreeLibrary(s_hInstIeakUI);
        return 0;
    }

    // if ie5.5 is not installed, bail out
    dwIEVer = GetIEVersion();
    if (HIWORD(dwIEVer) < 6)
    {
        TCHAR szMsgBoxTitle[128];
        TCHAR szMsgBoxText[MAX_PATH];

        LoadString(g_hInst, IDS_NOIE, szMsgBoxText, ARRAYSIZE(szMsgBoxText));
        LoadString(g_hInst, IDS_TITLE, szMsgBoxTitle, ARRAYSIZE(szMsgBoxTitle));
    
        MessageBox(NULL, szMsgBoxText, szMsgBoxTitle, MB_OK);
        FreeLibrary(s_hInstIeakUI);
        return FALSE;
    }

    dwSize = sizeof(g_szRoot);
    ZeroMemory(g_szRoot, sizeof(g_szRoot));
    GetModuleFileName(GetModuleHandle(NULL), g_szRoot, MAX_PATH);
    if(*g_szRoot == 0)
        SHGetValue(HKEY_LOCAL_MACHINE, CURRENTVERSIONKEY TEXT("\\App Paths\\IEAK6WIZ.EXE"), NULL, NULL, (LPVOID) g_szRoot, &dwSize);
    if(*g_szRoot != 0)
    {
        pLastSlash = StrRChr(g_szRoot, NULL, TEXT('\\'));
        if (pLastSlash)
            *(++pLastSlash) = 0;
        CharUpper(g_szRoot);
    }
    else
    {
        FreeLibrary(s_hInstIeakUI);
        return 0;
    }

    hInsDll = LoadLibrary(TEXT("insedit.dll"));
    if(!hInsDll)
    {
        MessageBox(NULL, Res2Str(IDS_ERRDLL), Res2Str(IDS_TITLE), MB_OK);
        FreeLibrary(s_hInstIeakUI);
        return 0;
    }

    CreateInsDialog = (CREATEINSDIALOG) GetProcAddress(hInsDll, "CreateInsDialog");
    GetInsDlgStruct = (GETINSDLGSTRUCT) GetProcAddress(hInsDll, "GetInsDlgStruct");
    DestroyInsDialog = (DESTROYINSDIALOG) GetProcAddress(hInsDll, "DestroyInsDialog");
    SetDefaultInf = (SETDEFAULTINF) GetProcAddress(hInsDll, "SetDefaultInf");
    ReInitializeInsDialogProcs = (REINITIALIZEINSDIALOGPROCS) GetProcAddress(hInsDll, "ReInitializeInsDialogProcs");
    SetPlatformInfo = (SETPLATFORMINFO) GetProcAddress(hInsDll, "SetPlatformInfo");
    InsDirty = (INSDIRTY) GetProcAddress(hInsDll, "InsDirty");
    ClearInsDirtyFlag = (CLEARINSDIRTYFLAG) GetProcAddress(hInsDll, "ClearInsDirtyFlag");
    SaveInsDialog = (SAVEINSDIALOG) GetProcAddress(hInsDll, "SaveInsDialog");
    CheckForExChar = (CHECKFOREXCHAR) GetProcAddress(hInsDll, "CheckForExChar");

    if(!CreateInsDialog || !GetInsDlgStruct || !DestroyInsDialog || !SetDefaultInf ||
       !ReInitializeInsDialogProcs || !SetPlatformInfo || !InsDirty || !ClearInsDirtyFlag ||
       !SaveInsDialog  || !CheckForExChar)
    {
        FreeLibrary(s_hInstIeakUI);
        return 0;
    }

    if (CoInitialize(NULL) != S_OK)
    {
        MessageBox(NULL, Res2Str(IDS_COMINITFAILURE), Res2Str(IDS_TITLE), MB_OK);
        return 0;
    }

    *g_szCmdLine = TEXT('\0');
    if (*lpCmdLine != TEXT('\0'))
    {
        PathUnquoteSpaces(lpCmdLine);
        if (lstrlen(lpCmdLine) < MAX_PATH)
            lstrcpy(g_szCmdLine, lpCmdLine);
    }
    
    g_pInsDialog = GetInsDlgStruct(&g_nDialogs);

    g_hMain = CreateWindowEx(0, TEXT("InsEdit4Class"), Res2Str(IDS_TITLE), WS_OVERLAPPEDWINDOW ^ (WS_THICKFRAME | WS_MAXIMIZEBOX),
    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL,
    LoadMenu(hInst, MAKEINTRESOURCE(IDR_MAINMENU)), hInst, NULL);

    if(g_hMain != NULL)
    {
        while(GetMessage(&msg, NULL, 0, 0))
        {
            if(msg.message == WM_QUIT)
                break;
        
            if(IsDialogMessage(g_hMain, &msg))
                continue;
        
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    if(hInsDll != NULL)
        FreeLibrary(hInsDll);

    FreeLibrary(s_hInstIeakUI);
    
    if (hMutex != NULL)
        CloseHandle(hMutex);

    CoUninitialize();

    return 1;
}

BOOL DirectoryName(LPCTSTR lpDirectory, LPTSTR szDirectoryPath)
{
    TCHAR* ptr = StrRChr((LPTSTR)lpDirectory, NULL, TEXT('\\'));

    ZeroMemory(szDirectoryPath, sizeof(szDirectoryPath));
    if(ptr == NULL)
        return FALSE;

    lstrcpyn(szDirectoryPath, lpDirectory, (int) (ptr - lpDirectory + 1));
    return TRUE;
}

void ExtractCabFile()
{
    TCHAR szBaseInsFileName[_MAX_FNAME];
    TCHAR szCabFullFileName[MAX_PATH];
    CHAR szCabFullNameA[MAX_PATH];
    CHAR szCabDirA[MAX_PATH];

    GetBaseFileName(g_szFileName, szBaseInsFileName, ARRAYSIZE(szBaseInsFileName));
    CreateCabWorkDirs(szBaseInsFileName);

    // read in the URL path for the cabs
    GetPrivateProfileString(BRANDING, CABSURLPATH, TEXT(""), g_szCabsURLPath, ARRAYSIZE(g_szCabsURLPath), g_szFileName);

    if (GetCabName(g_szFileName, CAB_TYPE_CONFIG, szCabFullFileName) != NULL)
    {
#ifdef UNICODE
        WideCharToMultiByte(CP_ACP, 0, szCabFullFileName, -1, szCabFullNameA, sizeof(szCabFullNameA), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, g_szCabWorkDir, -1, szCabDirA, sizeof(szCabDirA), NULL, NULL);
#else
        StrCpyA(szCabFullNameA, szCabFullFileName);
        StrCpyA(szCabDirA, g_szCabWorkDir);
#endif
        ExtractFiles(szCabFullNameA, szCabDirA, 0, NULL, NULL, NULL);
    }

    if (GetCabName(g_szFileName, CAB_TYPE_DESKTOP, szCabFullFileName) != NULL)
    {
#ifdef UNICODE
        WideCharToMultiByte(CP_ACP, 0, szCabFullFileName, -1, szCabFullNameA, sizeof(szCabFullNameA), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, g_szDesktopDir, -1, szCabDirA, sizeof(szCabDirA), NULL, NULL);
#else
        StrCpyA(szCabFullNameA, szCabFullFileName);
        StrCpyA(szCabDirA, g_szDesktopDir);
#endif
        ExtractFiles(szCabFullNameA, szCabDirA, 0, NULL, NULL, NULL);
    }

    if (GetCabName(g_szFileName, CAB_TYPE_CHANNELS, szCabFullFileName) != NULL)
    {
#ifdef UNICODE
        WideCharToMultiByte(CP_ACP, 0, szCabFullFileName, -1, szCabFullNameA, sizeof(szCabFullNameA), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, g_szDesktopDir, -1, szCabDirA, sizeof(szCabDirA), NULL, NULL);
#else
        StrCpyA(szCabFullNameA, szCabFullFileName);
        StrCpyA(szCabDirA, g_szDesktopDir);
#endif
        ExtractFiles(szCabFullNameA, szCabDirA, 0, NULL, NULL, NULL);
    }
}

void GetCabNameFromINS(LPCTSTR pcszInsFile, DWORD dwCabType, LPTSTR pszCabFullFileName, LPTSTR pszCabInfoLine /* = NULL*/)
{
    LPCTSTR pcszSection = NULL, pcszKey = NULL;
    TCHAR szCabFilePath[MAX_PATH];
    TCHAR szCabName[MAX_PATH];
    TCHAR szCabInfoLine[INTERNET_MAX_URL_LENGTH + 128];

    if (pcszInsFile == NULL || *pcszInsFile == TEXT('\0') || pszCabFullFileName == NULL)
        return;
    
    *pszCabFullFileName = TEXT('\0');

    if (pszCabInfoLine != NULL)
        *pszCabInfoLine = TEXT('\0');

    switch (dwCabType)
    {
    case CAB_TYPE_CONFIG:
        pcszSection = CUSTBRNDSECT;
        pcszKey = CUSTBRNDNAME;
        break;

    case CAB_TYPE_DESKTOP:
        pcszSection = CUSTDESKSECT;
        pcszKey = CUSTDESKNAME;
        break;

    case CAB_TYPE_CHANNELS:
        pcszSection = CUSTCHANSECT;
        pcszKey = CUSTCHANNAME;
        break;
    }

    if (pcszSection == NULL || pcszKey == NULL)
        return;

    DirectoryName(pcszInsFile, szCabFilePath);

    if (GetPrivateProfileString(pcszSection, pcszKey, TEXT(""), szCabInfoLine, ARRAYSIZE(szCabInfoLine), pcszInsFile) == 0)
        GetPrivateProfileString(CUSTOMVERSECT, pcszKey, TEXT(""), szCabInfoLine, ARRAYSIZE(szCabInfoLine), pcszInsFile);

    if (*szCabInfoLine)
    {
        LPTSTR pszT;

        if ((pszT = StrChr(szCabInfoLine, TEXT(','))) != NULL)
            *pszT = TEXT('\0');

        if ((pszT = PathFindFileName(szCabInfoLine)) > szCabInfoLine)
        {
            // cab URL path is specified
            *(pszT - 1) = TEXT('\0');           // nul the '/' char
        }

        StrCpy(szCabName, pszT);
        PathCombine(pszCabFullFileName, szCabFilePath, szCabName);

        if (pszCabInfoLine)
            StrCpy(pszCabInfoLine, szCabInfoLine);
    }
}

LPTSTR GetCabName(LPCTSTR pcszInsFile, DWORD dwCabType, TCHAR szCabFullFileName[])
// NOTE: It's assumed that the length of szCabName is atleast MAX_PATH
{
    TCHAR szCabName[MAX_PATH];
    TCHAR szCabInfoLine[INTERNET_MAX_URL_LENGTH + 128];
    TCHAR szCabFilePath[MAX_PATH];

    *szCabInfoLine = TEXT('\0');
    // first check if a cab file is already specified in pcszInsFile
    GetCabNameFromINS(pcszInsFile, dwCabType, szCabFullFileName, szCabInfoLine);
    if (*szCabFullFileName != TEXT('\0') && PathFileExists(szCabFullFileName))
    {
        switch (dwCabType)
        {
        case CAB_TYPE_CONFIG:
            StrCpy(g_szConfigURLPath, szCabInfoLine);
            StrCpy(g_szConfigCabName, PathFindFileName(szCabFullFileName));
            break;

        case CAB_TYPE_DESKTOP:
            StrCpy(g_szDesktopURLPath, szCabInfoLine);
            StrCpy(g_szDesktopCabName, PathFindFileName(szCabFullFileName));
            break;
        }

        return szCabFullFileName;
    }

    // use the default cab name output by ieakwiz.exe
    switch (dwCabType)
    {
    case CAB_TYPE_CONFIG:
        GetBaseFileName(pcszInsFile, szCabName, ARRAYSIZE(szCabName));
        if (StrCmpI(szCabName, TEXT("install")) == 0)
            StrCpy(szCabName, TEXT("branding"));
        StrCat(szCabName, TEXT(".cab"));
        break;

    case CAB_TYPE_DESKTOP:
        StrCpy(szCabName, TEXT("desktop.cab"));
        break;

    case CAB_TYPE_CHANNELS:
        StrCpy(szCabName, TEXT("chnls.cab"));
        break;
    }

    DirectoryName(pcszInsFile, szCabFilePath);
    PathCombine(szCabFullFileName, szCabFilePath, szCabName);

    if (PathFileExists(szCabFullFileName))
        return szCabFullFileName;
    else
        *szCabFullFileName = TEXT('\0');

    return NULL;
}     

void CabUpFolder(HWND hWnd, LPTSTR szFolderPath, LPTSTR szDestDir, LPTSTR szCabname, BOOL fSubDirs)
{
    TCHAR szFrom[MAX_PATH];
    TCHAR szCabPath[MAX_PATH];
    TCHAR szDiamondParams[MAX_PATH * 2];
    SHELLEXECUTEINFO shInfo;
    TCHAR szToolsFile[MAX_PATH];
    DWORD dwCode;

    wsprintf(szCabPath, TEXT("%s\\%s"), szDestDir, szCabname);
    
    if (fSubDirs)
        wsprintf(szDiamondParams, TEXT("-p -r n \"%s\" *.*"), szCabPath);
    else
        wsprintf(szDiamondParams, TEXT("n \"%s\" *.*"), szCabPath);

    ZeroMemory(&shInfo, sizeof(shInfo));
    shInfo.cbSize = sizeof(shInfo);
    shInfo.hwnd = hWnd;
    shInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    shInfo.lpVerb = TEXT("open");
    wsprintf(szToolsFile, TEXT("%stools\\CABARC.EXE"), g_szRoot);
    shInfo.lpFile = szToolsFile;
    shInfo.lpParameters = szDiamondParams;
    shInfo.lpDirectory = szFolderPath;
    shInfo.nShow = SW_MINIMIZE;
    SetCurrentDirectory(szFolderPath);
    
    ShellExecuteEx(&shInfo);
    while (MsgWaitForMultipleObjects(1, &shInfo.hProcess, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
    {
        MSG msg;

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    GetExitCodeProcess(shInfo.hProcess, &dwCode);
    CloseHandle(shInfo.hProcess);

    if (g_dwPlatformId == PLATFORM_WIN32)
    {
        TCHAR szDest[MAX_PATH];
    
        PathCombine(szToolsFile, g_szRoot, TEXT("tools\\signcode.exe"));
        PathCombine(szDest, szDestDir, TEXT("signcode.exe"));
        CopyFile(szToolsFile, szDest, FALSE);
    
        PathCombine(szToolsFile, g_szRoot, TEXT("tools\\signer.dll"));
        PathCombine(szDest, szDestDir, TEXT("signer.dll"));
        CopyFile(szToolsFile, szDest, FALSE);
    
        SignFile(szCabname, szDestDir, g_szInsFile, s_szUnsignedFiles);
    }

    SetCurrentDirectory(g_szRoot);
}

BOOL CompressCabFile()
{
    TCHAR szCabFilePath[MAX_PATH];
    TCHAR szCif[MAX_PATH];
    TCHAR szDisplayName[MAX_PATH];
    TCHAR szBaseInsFileName[_MAX_FNAME];
    TCHAR szCabSrcFile[MAX_PATH];
    TCHAR szCabDestFile[MAX_PATH];
    TCHAR szType[8];
    BOOL  fUpdateInsVer = FALSE;
    DWORD dwSpaceReq, dwSpaceFree;

    ZeroMemory(szCif, sizeof(szCif));
    ZeroMemory(szDisplayName, sizeof(szDisplayName));
    
    DirectoryName(g_szFileName, szCabFilePath);
    GetBaseFileName(g_szFileName, szBaseInsFileName, ARRAYSIZE(szBaseInsFileName));
    if(lstrcmpi(szBaseInsFileName, TEXT("install")) == 0)
        lstrcpy(szBaseInsFileName, TEXT("branding"));

    wsprintf(szCif, TEXT("%s\\%s.cif"), g_szCabTempDir, szBaseInsFileName);
    lstrcpy(szDisplayName, szBaseInsFileName);

    DeleteFileInDir(TEXT("*.cab"), g_szCabTempDir);

    //-------------------- Config
    if (*g_szConfigCabName != TEXT('\0') && !PathIsEmptyPath(g_szCabWorkDir))
    {
        TCHAR szConfigDir[MAX_PATH];

        PathCombine(szConfigDir, g_szCabWorkDir, TEXT("Config"));
        // before copying files to the config dir, clear the dir if there were old 
        // files from a previous save.
        PathRemovePath(szConfigDir);
        CopyDir(g_szCabWorkDir, szConfigDir);

        if (!PathIsEmptyPath(szConfigDir))
        {
            CabUpFolder(NULL, szConfigDir, g_szCabTempDir, TEXT("config.cab"));
        
            wsprintf(szCabSrcFile, TEXT("%s\\%s"), g_szCabTempDir, TEXT("config.cab"));
            wsprintf(szCabDestFile, TEXT("%s\\%s"), g_szCabTempDir, g_szConfigCabName);
            MoveFile(szCabSrcFile, szCabDestFile);
        }
    }

    //-------------------- Desktop
    if (*g_szDesktopCabName != TEXT('\0') && !PathIsEmptyPath(g_szDesktopDir, FILES_ONLY))
    {
        CabUpFolder(NULL, g_szDesktopDir, g_szCabTempDir, TEXT("desktop.cab"));
    
        wsprintf(szCabSrcFile, TEXT("%s\\%s"), g_szCabTempDir, TEXT("desktop.cab"));
        wsprintf(szCabDestFile, TEXT("%s\\%s"), g_szCabTempDir, g_szDesktopCabName);
        MoveFile(szCabSrcFile, szCabDestFile);
    }

    // Check for disk space availability
    while (!EnoughDiskSpace(g_szCabTempDir, szCabFilePath, &dwSpaceReq, &dwSpaceFree))
    {
        LPTSTR pMsg;
        int    nResult;

        pMsg = FormatString(Res2Str(IDS_INSUFFICIENT_DISKSPACE), dwSpaceReq, dwSpaceFree);
        nResult = MessageBox(g_hMain, pMsg, Res2Str(IDS_TITLE), MB_ICONQUESTION | MB_YESNO);
        LocalFree(pMsg);
    
        if (nResult == IDNO)
            return FALSE;
    }

    //flush temp INS file
    InsFlushChanges(g_szInsFile);
    
    //-------------------- Ins file
    SetFileAttributes(g_szFileName, FILE_ATTRIBUTE_NORMAL);
    CopyFile(g_szInsFile, g_szFileName, FALSE);
    
    //-------------------- Config
    wsprintf(szCabSrcFile, TEXT("%s\\%s"), g_szCabTempDir, g_szConfigCabName);
    if (*g_szConfigCabName != TEXT('\0') && PathFileExists(szCabSrcFile))
    {
        CopyFileToDir(szCabSrcFile, szCabFilePath);

        fUpdateInsVer = TRUE;
        SetOrClearVersionInfo(g_szFileName, CAB_TYPE_CONFIG, g_szConfigCabName,
            g_szCabsURLPath, g_szNewVersionStr, SET);
    }
    else
        SetOrClearVersionInfo(g_szFileName, CAB_TYPE_CONFIG, g_szConfigCabName, 
            g_szCabsURLPath, g_szNewVersionStr, CLEAR);

    //-------------------- Desktop
    wsprintf(szCabSrcFile, TEXT("%s\\%s"), g_szCabTempDir, g_szDesktopCabName);
    if (*g_szDesktopCabName != TEXT('\0') && PathFileExists(szCabSrcFile))
    {
        CopyFileToDir(szCabSrcFile, szCabFilePath);

        fUpdateInsVer = TRUE; 
        SetOrClearVersionInfo(g_szFileName, CAB_TYPE_DESKTOP, g_szDesktopCabName, 
            g_szCabsURLPath, g_szNewVersionStr, SET);
    }
    else
        SetOrClearVersionInfo(g_szFileName, CAB_TYPE_DESKTOP, g_szDesktopCabName, 
            g_szCabsURLPath, g_szNewVersionStr, CLEAR);

    WritePrivateProfileString(BRANDING, CABSURLPATH, fUpdateInsVer ? g_szCabsURLPath : NULL, g_szFileName);
    WritePrivateProfileString(BRANDING, INSVERKEY, fUpdateInsVer ? g_szNewVersionStr : NULL, g_szFileName);
    WritePrivateProfileString(BRANDING, PMVERKEY, A2CT(VER_PRODUCTVERSION_STR), g_szFileName);
    //clear other keys so we're sure this is profmgr
    WritePrivateProfileString(BRANDING, GPVERKEY, NULL, g_szFileName);
    WritePrivateProfileString(BRANDING, IK_WIZVERSION, NULL, g_szFileName);

    // write the type as INTRANET so that the branding DLL extracts and processes the cabs in the CUSTOM dir
    wsprintf(szType, TEXT("%u"), INTRANET);
    WritePrivateProfileString(BRANDING, TEXT("Type"), szType, g_szFileName);

    SetForegroundWindow(g_hMain);
    if (g_dwPlatformId == PLATFORM_WIN32) 
    {
        if (ISNONNULL(s_szUnsignedFiles))
        {
            TCHAR szMessage[MAX_PATH*3];
            TCHAR szMsg[64];
        
            LoadString(g_hInst, IDS_CABSIGN_ERROR, szMsg, ARRAYSIZE(szMsg));
            wsprintf(szMessage, szMsg, s_szUnsignedFiles);
            MessageBox(g_hMain, szMessage, TEXT(""), MB_OK | MB_SETFOREGROUND);
            ZeroMemory(s_szUnsignedFiles, sizeof(s_szUnsignedFiles));
        }
    }

    InsFlushChanges(g_szFileName);

    return TRUE;
}

void DeleteCabWorkDirs()
{
    if(*g_szCabWorkDir)
    {
        PathRemovePath(g_szCabWorkDir);
        ZeroMemory(g_szCabWorkDir, sizeof(g_szCabWorkDir));
    }
    if(*g_szCabTempDir)
    {
        PathRemovePath(g_szCabTempDir);
        ZeroMemory(g_szCabTempDir, sizeof(g_szCabTempDir));
    }
}

void CreateCabWorkDirs(LPCTSTR szWorkDir)
{
    TCHAR szTempPath[MAX_PATH];

    if(*g_szCabWorkDir)
        DeleteCabWorkDirs();

    GetTempPath(ARRAYSIZE(szTempPath), szTempPath);
    wsprintf(g_szCabWorkDir, TEXT("%s%scabwrk"), szTempPath, szWorkDir);
    CreateDirectory(g_szCabWorkDir, NULL);

    PathCombine(g_szDesktopDir, g_szCabWorkDir, TEXT("desktop"));
    CreateDirectory(g_szDesktopDir, NULL);

    wsprintf(g_szCabTempDir, TEXT("%scabtmp"), szTempPath);
    CreateDirectory(g_szCabTempDir, NULL);
}

void CopyDir(LPCTSTR szSrcDir, LPCTSTR szDestDir)
{
    WIN32_FIND_DATA wfdFind;
    HANDLE hFind;
    TCHAR szNewDir[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    TCHAR szTemp1[MAX_PATH];

    wsprintf(szTemp, TEXT("%s\\*.*"), szSrcDir);

    hFind = FindFirstFile(szTemp, &wfdFind);
    if(hFind == INVALID_HANDLE_VALUE)
        return;

    CreateDirectory(szDestDir, NULL);
    
    do
    {
        if(!(wfdFind.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            wsprintf(szTemp, TEXT("%s\\%s"), szSrcDir, wfdFind.cFileName);
            wsprintf(szTemp1, TEXT("%s\\%s"), szDestDir, wfdFind.cFileName);
            SetFileAttributes(szTemp, FILE_ATTRIBUTE_NORMAL);
            CopyFile(szTemp, szTemp1, FALSE); 
        }
    }while(FindNextFile(hFind, &wfdFind));

    FindClose(hFind);
}

void GetLangDesc(LPTSTR szLangId, LPTSTR szLangDesc, int cchLangDescSize, LPDWORD dwLangId)
{
    DWORD dwErr = 0;
    RFC1766INFO rInfo;
    LCID lcid;
    BOOL fDef = FALSE;
    LCID curLcid = GetUserDefaultLCID();
    LPMULTILANGUAGE pMLang = NULL;
    TCHAR szLocale[MAX_PATH];
    
    ZeroMemory(szLangDesc, cchLangDescSize * sizeof(TCHAR));

    wsprintf(szLocale, TEXT("%sLocale.ini"), g_szRoot);
    GetPrivateProfileString(TEXT("Strings"), szLangId, TEXT(""), szLangDesc, cchLangDescSize, szLocale);

    CharLower(szLangId);
    dwErr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage, (void **) &pMLang);
    if(pMLang)
    {
        if((dwErr = GetLcid(&lcid, szLangId, szLocale)) == NOERROR)
        {
            if(*szLangDesc == 0)
            {
                dwErr = pMLang->GetRfc1766Info(lcid, &rInfo);
#ifdef UNICODE
                StrCpyW(szLangDesc, rInfo.wszLocaleName);
#else
                WideCharToMultiByte(CP_ACP, 0, rInfo.wszLocaleName, -1, szLangDesc, 32, TEXT(" "), &fDef);
#endif
            }
        }
        else
            lcid = curLcid;
        pMLang->Release();
    }

    *dwLangId = lcid;
}

INT_PTR CALLBACK LanguageDialogProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WIN32_FIND_DATA wfdFind;
    HANDLE hFind;
    TCHAR szPolicyDir[MAX_PATH];
    TCHAR szLangDir[10];
    int nItems = 0;
    int nSelItem = -1;
    TCHAR szLangDesc[100];
    LPTSTR pLangId = NULL;
    int nIndex = -1;
    TCHAR szMsg[MAX_PATH];
    DWORD dwLangId = 0;
    typedef struct LangLocale
    {
        TCHAR szLang[10];
        DWORD dwLang;
    } LANGID;
    static LANGID lang[NUMLANG];

    switch(msg)
    {
    case WM_INITDIALOG:
        LoadString(g_hInst, IDS_LANGUAGE, szMsg, ARRAYSIZE(szMsg));
        SetWindowText(hDlg, szMsg);

        // get the all the directories under the ieak\policies directory
        wsprintf(szPolicyDir, TEXT("%s\\iebin\\*.*"), g_szRoot);

        hFind = FindFirstFile(szPolicyDir, &wfdFind);
        if(hFind == INVALID_HANDLE_VALUE)
        {
            EndDialog(hDlg, 1);
            break;
        }

        ZeroMemory(lang, sizeof(LANGID) * NUMLANG);

        do
        {
            if(wfdFind.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                // avoid the . and .. case
                if(StrCmp(wfdFind.cFileName, TEXT(".")) != 0 && StrCmp(wfdFind.cFileName, TEXT("..")) != 0)
                {
                    GetLangDesc(wfdFind.cFileName, szLangDesc, ARRAYSIZE(szLangDesc), &dwLangId);
                    if(*szLangDesc != TEXT('\0') && 
                       PlatformExists(hDlg, wfdFind.cFileName, PLATFORM_WIN32))
                    {
                        nIndex = (int) SendMessage(GetDlgItem(hDlg, IDC_LANG), CB_ADDSTRING, 0, (LPARAM) (LPCTSTR) szLangDesc);
                        if(nIndex != CB_ERR)
                        {
                            lstrcpy(lang[nIndex].szLang, wfdFind.cFileName);
                            lang[nIndex].dwLang = dwLangId;
                        }
                    }
                }
            }
        }while(FindNextFile(hFind, &wfdFind));
        FindClose(hFind);

        nItems = (int) SendMessage(GetDlgItem(hDlg, IDC_LANG), CB_GETCOUNT, 0, 0L);
        if(nItems == 0)
        {
            EndDialog(hDlg, 1);
            break;
        }
        else if(nItems == 1)
        {
            lstrcpy(g_szLanguage, lang[0].szLang);
            g_dwLanguage = lang[0].dwLang;
            EndDialog(hDlg, 1);
            break;
        }

        SendMessage(GetDlgItem(hDlg, IDC_LANG), CB_SETCURSEL, 0, 0L);
        EnableWindow(hDlg, TRUE);
        ShowWindow(hDlg, SW_SHOWNORMAL);
        break;

    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED && LOWORD(wParam) == IDOK)
        {
            int nSelItem = (int) SendMessage(GetDlgItem(hDlg, IDC_LANG), CB_GETCURSEL, 0, 0L);
            if(nSelItem != CB_ERR)
            {
                lstrcpy(g_szLanguage, lang[nSelItem].szLang);
                g_dwLanguage = lang[nSelItem].dwLang;
            }
            EndDialog(hDlg, 1);
        }
        break;

    case WM_DESTROY:
    case WM_CLOSE:
        SendMessage(GetDlgItem(hDlg, IDC_LANG), CB_RESETCONTENT, 0, 0L);
        break;

    default:
        return 0;
    }
    return 1;
}   

void PrepareFolderForCabbing(LPCTSTR pcszDestDir, DWORD dwFlags)
{
    int i;

    for (i = 0;  i < g_nDialogs;  i++)
        if (g_pInsDialog[i].pfnFinalCopy != NULL)
            g_pInsDialog[i].pfnFinalCopy(pcszDestDir, dwFlags, NULL);
}

BOOL DoCompressCabFile(LPVOID lpVoid)
{
    HWND hDlg = (HWND) lpVoid;
    BOOL fSuccess;

    fSuccess = CompressCabFile();
    PostMessage(hDlg, UM_SAVE_COMPLETE, 0, (LPARAM)fSuccess);
    return TRUE;
}

INT_PTR CALLBACK DisplaySaveDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static HANDLE hIcon = NULL;
    static HANDLE hThread;
    DWORD dwThread;

    switch(msg)
    {
    case WM_INITDIALOG:
        SetWindowText(hDlg, Res2Str(IDS_TITLE));
        Animate_Open( GetDlgItem( hDlg, IDC_ANIMATE ), IDA_GEARS );
        Animate_Play( GetDlgItem( hDlg, IDC_ANIMATE ), 0, -1, -1 );
        if((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) DoCompressCabFile, (LPVOID) hDlg, 0, &dwThread)) == NULL)
        {
            int nResult = CompressCabFile();
            
            EndDialog(hDlg, nResult);
        }
        break;

    case UM_SAVE_COMPLETE:
        EndDialog(hDlg, lParam);
        break;

    case WM_DESTROY:
        if (hThread != NULL)
            CloseHandle(hThread);
        if (hIcon != NULL)
            DestroyIcon((HICON) hIcon);
        break;

    default:
        return 0;
    }

    return 1;
}

DWORD GetCabBuildStatus()
// This is a real hacky function.  It checks whether the work dirs are empty or not and
// returns the cabs that will be built.
{
    DWORD dwCabsToBuild = 0;

    for (int nIndex = 0;  nIndex < g_nDialogs;  nIndex++)
    {
        if (g_pInsDialog[nIndex].pfnFinalCopy != NULL)
            g_pInsDialog[nIndex].pfnFinalCopy(g_szCabWorkDir, PM_CHECK, &dwCabsToBuild);
    }

    if (IsAdmDirty() || !PathIsEmptyPath(g_szCabWorkDir, FILES_ONLY))
        SetFlag(&dwCabsToBuild, CAB_TYPE_CONFIG);

    if (!PathIsEmptyPath(g_szDesktopDir, FILES_ONLY))
        SetFlag(&dwCabsToBuild, CAB_TYPE_DESKTOP);

    return dwCabsToBuild;
}

void GetDefaultInf(DWORD dwPlatformId)
{
    switch(dwPlatformId)
    {
    case PLATFORM_WIN32:
    case PLATFORM_W2K:
    default:
        wsprintf(g_szDefInf, TEXT("%siebin\\%s\\Optional\\DefFav.inf"), g_szRoot, g_szLanguage);
        break;
    }
}

void GetDefaultCabName(DWORD dwCabType, LPCTSTR pcszPrefix, LPTSTR pszCabName)
{
    TCHAR szActualPrefix[MAX_PATH];

    if (pszCabName == NULL)
        return;

    *pszCabName = TEXT('\0');

    if (pcszPrefix == NULL || *pcszPrefix == TEXT('\0'))
        return;
    
    if (StrChr(pcszPrefix, '.') != NULL)
    {
        lstrcpy(pszCabName, pcszPrefix);
        return;
    }
    
    lstrcpy(szActualPrefix, pcszPrefix);

    switch(dwCabType)
    {
    case CAB_TYPE_CONFIG:
        wsprintf(pszCabName, TEXT("%s_config.cab"), szActualPrefix);
        break;

    case CAB_TYPE_DESKTOP:
        wsprintf(pszCabName, TEXT("%s_desktop.cab"), szActualPrefix);
        break;
    }
}

BOOL InitializePlatform(HWND hWnd, HWND hInfoWnd, WORD wPlatform)
{
    TCHAR szTemp[MAX_PATH];
    HMENU hMenu = GetSubMenu(GetMenu(hWnd), 2);
    DWORD dwPlatformId;
    
    if (hMenu)
    {
        UINT nMenuState = GetMenuState(hMenu, wPlatform, MF_BYCOMMAND);
        if (nMenuState != 0xFFFFFFFF && (nMenuState & MF_CHECKED) == 0) // if not checked
        {
            TreeView.SetSel(g_hInsRootItem);
            if (TreeView.GetSel() != g_hInsRootItem) // error closing/saving the visible page
                return FALSE;

            if (wPlatform == IDM_PLATFORM_WIN32)
                dwPlatformId = PLATFORM_WIN32;
            else if (wPlatform == IDM_PLATFORM_W2K)
                dwPlatformId = PLATFORM_W2K;

            // check if the selected platform Optional cab is available for the language.
            if (!PlatformExists(hWnd, g_szLanguage, dwPlatformId))
            {
                TCHAR  szPlatformText[25],
                       szLangDesc[200];
                LPTSTR pMsg;
                DWORD  dwLangId;

                if (dwPlatformId == PLATFORM_WIN32)
                    StrCpy(szPlatformText, Res2Str(IDS_WIN32));
                else if (dwPlatformId == PLATFORM_W2K)
                    StrCpy(szPlatformText, Res2Str(IDS_W2K));
        
                GetLangDesc(g_szLanguage, szLangDesc, ARRAYSIZE(szLangDesc), &dwLangId);

                pMsg = FormatString(Res2Str(IDS_NOPLATFORMDIR), szPlatformText, szLangDesc);
                MessageBox(hWnd, pMsg, Res2Str(IDS_TITLE), MB_ICONINFORMATION | MB_OK);
                LocalFree(pMsg);

                return FALSE;
            }

            CheckMenuItem(hMenu, IDM_PLATFORM_WIN32, MF_BYCOMMAND | MF_UNCHECKED);
            CheckMenuItem(hMenu, IDM_PLATFORM_W2K, MF_BYCOMMAND | MF_UNCHECKED);
            CheckMenuItem(hMenu, wPlatform, MF_BYCOMMAND | MF_CHECKED);

            g_dwPlatformId = dwPlatformId;

            GetDefaultInf(g_dwPlatformId);
            SetDefaultInf(g_szDefInf);

            TreeView.DeleteNodes(g_hInsRootItem);
        
            SetPlatformInfo(g_dwPlatformId);
            ReInitializeInsDialogProcs();
            g_pInsDialog = GetInsDlgStruct(&g_nDialogs);

            DeleteADMItems(TreeView.GetHandle(), g_szCabWorkDir, g_szInsFile, TRUE);

            InitTreeView(TreeView.GetHandle(), hInfoWnd);            
        }
    }
    return TRUE;
}

void IeakPageHelp(HWND hWnd, LPCTSTR pszData)
{
    TCHAR szHelpPath[MAX_PATH];

    PathCombine(szHelpPath, g_szRoot, TEXT("ieakhelp.chm"));
    g_hWndHelp = HtmlHelp(NULL, szHelpPath, HH_HELP_CONTEXT, (ULONG_PTR) pszData);
    SetForegroundWindow(g_hWndHelp);
}

void UpdateRecentFileListMenu(HWND hWnd, TCHAR pRecentFileList[5][MAX_PATH])
{
    HMENU hMenu;
    MENUITEMINFO mii;

    hMenu = GetSubMenu(GetMenu(hWnd), 0);           // 0 is the position of the FILE menu
    int nMenuItems = GetMenuItemCount(hMenu);
    if (nMenuItems > 7)     // 7 is the no. of menu items in the list excluding the recent file list items
    {                       // delete all the recent file list menu items including the seperator
        for (int nIndex = 0; nIndex < nMenuItems - 7; nIndex++)
            DeleteMenu(hMenu, 6, MF_BYPOSITION);    // the recent file list items start at position 6 in the FILE menu
    }
       
    // add the recent file list menu items
    mii.cbSize = sizeof(MENUITEMINFO);
    for(int nIndex = 0; nIndex < 5; nIndex++)
    {
        if (*pRecentFileList[nIndex] != TEXT('\0'))
        {
            mii.fMask = MIIM_ID | MIIM_TYPE