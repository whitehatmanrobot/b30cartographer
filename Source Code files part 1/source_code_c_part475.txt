eTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetContainer\n", _pch));
    TRETURN(_p->GetContainer(ppContainer));
}

HRESULT STDMETHODCALLTYPE
ShowObject()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ShowObject\n", _pch));
    TRETURN(_p->ShowObject());
}

HRESULT STDMETHODCALLTYPE
OnShowWindow(BOOL fShow)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnShowWindow\n", _pch));
    TRETURN(_p->OnShowWindow(fShow));
}

HRESULT STDMETHODCALLTYPE
RequestNewObjectLayout ()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::RequestNewObjectLayout\n", _pch));
    TRETURN(_p->RequestNewObjectLayout());
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleInPlaceSiteWindowless
//
//---------------------------------------------------------------

BEGIN_TRACK(OleInPlaceSiteWindowless)

HRESULT STDMETHODCALLTYPE
GetWindow(HWND * lphwnd)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindow\n", _pch));
    TRETURN(_p->GetWindow(lphwnd));
}

HRESULT STDMETHODCALLTYPE
ContextSensitiveHelp(BOOL fEnterMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ContextSensitiveHelp\n", _pch));
    TRETURN(_p->ContextSensitiveHelp(fEnterMode));
}

HRESULT STDMETHODCALLTYPE
CanInPlaceActivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::CanInPlaceActivate\n", _pch));
    TRETURN(_p->CanInPlaceActivate());
}

HRESULT STDMETHODCALLTYPE
OnInPlaceActivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnInPlaceActivate\n", _pch));
    TRETURN(_p->OnInPlaceActivate());
}

HRESULT STDMETHODCALLTYPE
OnInPlaceActivateEx(BOOL *pf, DWORD dw)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnInPlaceActivate\n", _pch));
    TRETURN(_p->OnInPlaceActivateEx(pf, dw));
}

HRESULT STDMETHODCALLTYPE
RequestUIActivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::RequestUIActivate\n", _pch));
    TRETURN(_p->RequestUIActivate());
}

HRESULT STDMETHODCALLTYPE
OnUIActivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnUIActivate\n", _pch));
    TRETURN(_p->OnUIActivate());
}

HRESULT STDMETHODCALLTYPE
GetWindowContext(
                    LPOLEINPLACEFRAME *    lplpFrame,
                    LPOLEINPLACEUIWINDOW * lplpDoc,
                    LPRECT                 lprcPosRect,
                    LPRECT                 lprcClipRect,
                    LPOLEINPLACEFRAMEINFO  lpFrameInfo)
{
    HRESULT hr;

    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindowContext\n", _pch));

    hr = _p->GetWindowContext(
                    lplpFrame,
                    lplpDoc,
                    lprcPosRect,
                    lprcClipRect,
                    lpFrameInfo);

    InterlockedDecrement((LONG *)&g_ulNestingLevel);
    INDENT_NESTING2;
    if (lprcPosRect && lprcClipRect)
    {
        TraceTagEx((tagTrackItfVerbose, TAG_NONAME, "%s::GetWindowContext Returning "
                    "Pos=(%d,%d,%d,%d), Clip=(%d,%d,%d,%d) %hr.",
                    _pch,
                    lprcPosRect->left, lprcPosRect->top,
                    lprcPosRect->right, lprcPosRect->bottom,
                    lprcClipRect->left, lprcClipRect->top,
                    lprcClipRect->right, lprcClipRect->bottom,
                    hr));
    }
    else
    {
        TraceTagEx((tagTrackItfVerbose, TAG_NONAME, "%s::GetWindowContext Returning "
                    "Pos=(null), Clip=(null) %hr.", _pch, hr));
    }

    SRETURN(hr);
}

HRESULT STDMETHODCALLTYPE
Scroll(SIZE extent)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Scroll\n", _pch));
    TRETURN(_p->Scroll(extent));
}

HRESULT STDMETHODCALLTYPE
OnUIDeactivate(BOOL fUndoable)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnUIDeactivate\n", _pch));
    TRETURN(_p->OnUIDeactivate(fUndoable));
}

HRESULT STDMETHODCALLTYPE
OnInPlaceDeactivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnInPlaceDeactivate\n", _pch));
    TRETURN(_p->OnInPlaceDeactivate());
}

HRESULT STDMETHODCALLTYPE
OnInPlaceDeactivateEx(BOOL f)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnInPlaceDeactivateEx\n", _pch));
    TRETURN(_p->OnInPlaceDeactivateEx(f));
}

HRESULT STDMETHODCALLTYPE
DiscardUndoState()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DiscardUndoState\n", _pch));
    TRETURN(_p->DiscardUndoState());
}

HRESULT STDMETHODCALLTYPE
DeactivateAndUndo()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DeactivateAndUndo\n", _pch));
    TRETURN(_p->DeactivateAndUndo());
}

HRESULT STDMETHODCALLTYPE
OnPosRectChange(LPCRECT lprcPosRect)
{
    INDENT_NESTING;
    if (lprcPosRect)
    {
        TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnPosRectChange -- "
                    "Pos=(%d,%d,%d,%d)\n",
                    _pch,
                    lprcPosRect->left, lprcPosRect->top,
                    lprcPosRect->right, lprcPosRect->bottom
                    ));
    }
    else
    {
        TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnPosRectChange -- "
                    "Pos=(null)\n", _pch));
    }
    TRETURN(_p->OnPosRectChange(lprcPosRect));
}

HRESULT STDMETHODCALLTYPE
CanWindowlessActivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::CanWindowlessActivate\n", _pch));
    TRETURN(_p->CanWindowlessActivate());
}

HRESULT STDMETHODCALLTYPE
GetCapture()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetCapture\n", _pch));
    TRETURN(_p->GetCapture());
}

HRESULT STDMETHODCALLTYPE
SetCapture(BOOL fCapture)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetCapture\n", _pch));
    TRETURN(_p->SetCapture(fCapture));
}

HRESULT STDMETHODCALLTYPE
GetFocus()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetFocus\n", _pch));
    TRETURN(_p->GetFocus());
}

HRESULT STDMETHODCALLTYPE
SetFocus(BOOL fFocus)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetFocus\n", _pch));
    TRETURN(_p->SetFocus(fFocus));
}

HRESULT STDMETHODCALLTYPE
OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnDefWindowMessage\n", _pch));
    TRETURN(_p->OnDefWindowMessage(msg, wParam, lParam, plResult));
}

HRESULT STDMETHODCALLTYPE
GetDC(LPCRECT prc, DWORD dwFlags, HDC * phDC)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetFocus\n", _pch));
    TRETURN(_p->GetDC(prc, dwFlags, phDC));
}

HRESULT STDMETHODCALLTYPE
ReleaseDC(HDC hdc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ReleaseDC\n", _pch));
    TRETURN(_p->ReleaseDC(hdc));
}

HRESULT STDMETHODCALLTYPE
InvalidateRect(LPCRECT prc, BOOL fErase)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InvalidateRect\n", _pch));
    TRETURN(_p->InvalidateRect(prc, fErase));
}

HRESULT STDMETHODCALLTYPE
InvalidateRgn(HRGN hrgn, BOOL fErase)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InvalidateRgn\n", _pch));
    TRETURN(_p->InvalidateRgn(hrgn, fErase));
}

HRESULT STDMETHODCALLTYPE
ScrollRect(int dx, int dy, LPCRECT lprcScroll, LPCRECT lprcClip)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ScrollRect\n", _pch));
    TRETURN(_p->ScrollRect(dx, dy, lprcScroll, lprcClip));
}

HRESULT STDMETHODCALLTYPE
AdjustRect(LPRECT prc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::AdjustRect\n", _pch));
    TRETURN(_p->AdjustRect(prc));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IDataObject
//
//---------------------------------------------------------------

BEGIN_TRACK(DataObject)

HRESULT STDMETHODCALLTYPE
GetData(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetData\n", _pch));
    TRETURN(_p->GetData(pformatetc, pmedium));
}

HRESULT STDMETHODCALLTYPE
GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetDataHere\n", _pch));
    TRETURN(_p->GetDataHere(pformatetc, pmedium));
}

HRESULT STDMETHODCALLTYPE
QueryGetData(LPFORMATETC pformatetc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::QueryGetData\n", _pch));
    TRETURN(_p->QueryGetData(pformatetc));
}

HRESULT STDMETHODCALLTYPE
GetCanonicalFormatEtc(LPFORMATETC pformatetc,
        LPFORMATETC pformatetcOut)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetCanonicalFormat\n", _pch));
    TRETURN(_p->GetCanonicalFormatEtc(pformatetc, pformatetcOut));
}

HRESULT STDMETHODCALLTYPE
SetData(LPFORMATETC pformatetc,
        STGMEDIUM FAR *pmedium, BOOL fRelease)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetData\n", _pch));
    TRETURN(_p->SetData(pformatetc, pmedium, fRelease));
}

HRESULT STDMETHODCALLTYPE
EnumFormatEtc(DWORD dwDirection,
        LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnumFormatEtc\n", _pch));
    TRETURN(_p->EnumFormatEtc(dwDirection, ppenumFormatEtc));
}

HRESULT STDMETHODCALLTYPE
DAdvise(FORMATETC FAR* pFormatetc, DWORD advf,
        LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DAdvise\n", _pch));
    TRETURN(_p->DAdvise(pFormatetc, advf, pAdvSink, pdwConnection));
}

HRESULT STDMETHODCALLTYPE
DUnadvise(DWORD dwConnection)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DUnadvise\n", _pch));
    TRETURN(_p->DUnadvise(dwConnection));
}

HRESULT STDMETHODCALLTYPE
EnumDAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnumDAdvise\n", _pch));
    TRETURN(_p->EnumDAdvise(ppenumAdvise));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IViewObject
//
//---------------------------------------------------------------

BEGIN_TRACK(ViewObject)

HRESULT STDMETHODCALLTYPE
Draw(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR), ULONG_PTR dwContinue)
{
    INDENT_NESTING;
    RECTL  rc = { 0 }, rcBounds = { 0 };

    if (lprectl)
        rc = *lprectl;

    if (lprcWBounds)
        rcBounds = *lprcWBounds;

    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Draw -- rc=(%d,%d,%d,%d), "
                "rcBounds=(%d,%d,%d,%d)\n", _pch,
                rc.left, rc.top, rc.right, rc.bottom,
                rcBounds.left, rcBounds.top, rcBounds.right, rcBounds.bottom));

    TRETURN(_p->Draw(dwDrawAspect,
            lindex,
            pvAspect,
            ptd,
            hicTargetDev,
            hdcDraw,
            lprectl,
            lprcWBounds,
            pfnContinue,
            dwContinue));
}

HRESULT STDMETHODCALLTYPE
GetColorSet(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        LPLOGPALETTE FAR* ppColorSet)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetColorSet\n", _pch));
    TRETURN(_p->GetColorSet(dwDrawAspect,
            lindex,
            pvAspect,
            ptd,
            hicTargetDev,
            ppColorSet));
}

HRESULT STDMETHODCALLTYPE
Freeze(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DWORD FAR* pdwFreeze)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Freeze\n", _pch));
    TRETURN(_p->Freeze(dwDrawAspect, lindex, pvAspect, pdwFreeze));
}

HRESULT STDMETHODCALLTYPE
Unfreeze(DWORD dwFreeze)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Unfreeze\n", _pch));
    TRETURN(_p->Unfreeze(dwFreeze));
}

HRESULT STDMETHODCALLTYPE
SetAdvise(DWORD aspects, DWORD advf, LPADVISESINK pAdvSink)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetAdvise\n", _pch));
    TRETURN(_p->SetAdvise(aspects, advf, pAdvSink));
}

HRESULT STDMETHODCALLTYPE
GetAdvise(DWORD FAR* pAspects,
        DWORD FAR* pAdvf,
        LPADVISESINK FAR* ppAdvSink)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetAdvise\n", _pch));
    TRETURN(_p->GetAdvise(pAspects, pAdvf, ppAdvSink));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IPersistStorage
//
//---------------------------------------------------------------

BEGIN_TRACK(PersistStorage)


HRESULT STDMETHODCALLTYPE
GetClassID(LPCLSID lpClassID)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClassID\n", _pch));
    TRETURN(_p->GetClassID(lpClassID));
}

HRESULT STDMETHODCALLTYPE
IsDirty()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsDirty\n", _pch));
    TRETURN(_p->IsDirty());
}

HRESULT STDMETHODCALLTYPE
InitNew(LPSTORAGE pStg)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InitNew\n", _pch));
    TRETURN(_p->InitNew(pStg));
}

HRESULT STDMETHODCALLTYPE
Load(LPSTORAGE pStg)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Load(stg)\n", _pch));
    TRETURN(_p->Load(pStg));
}

HRESULT STDMETHODCALLTYPE
Save(LPSTORAGE pStg, BOOL fSameAsLoad)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Save(stg,)\n", _pch));
    TRETURN(_p->Save(pStg, fSameAsLoad));
}

HRESULT STDMETHODCALLTYPE
SaveCompleted(LPSTORAGE pStg)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SaveCompleted(stg)\n", _pch));
    TRETURN(_p->SaveCompleted(pStg));
}

HRESULT STDMETHODCALLTYPE
HandsOffStorage()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::HandsOffStorage\n", _pch));
    TRETURN(_p->HandsOffStorage());
}

END_TRACK()

//---------------------------------------------------------------
//
//  IPersistFile
//
//---------------------------------------------------------------

BEGIN_TRACK(PersistFile)

HRESULT STDMETHODCALLTYPE
GetClassID(LPCLSID lpClassID)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClassID\n", _pch));
    TRETURN(_p->GetClassID(lpClassID));
}

HRESULT STDMETHODCALLTYPE
IsDirty()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsDirty\n", _pch));
    TRETURN(_p->IsDirty());
}

HRESULT STDMETHODCALLTYPE
Load(LPCOLESTR lpszFileName, DWORD grfMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Load(%ls,)\n", _pch, OUTPUTSTR(lpszFileName)));
    TRETURN(_p->Load(lpszFileName, grfMode));
}

HRESULT STDMETHODCALLTYPE
Save(LPCOLESTR lpszFileName, BOOL fRemember)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Save(%ls,)\n", _pch, OUTPUTSTR(lpszFileName)));
    TRETURN(_p->Save(lpszFileName, fRemember));
}

HRESULT STDMETHODCALLTYPE
SaveCompleted(LPCOLESTR lpszFileName)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SaveCompleted(%ls)\n", _pch, OUTPUTSTR(lpszFileName)));
    TRETURN(_p->SaveCompleted(lpszFileName));
}

HRESULT STDMETHODCALLTYPE
GetCurFile (LPOLESTR FAR * ppstrFile)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetCurFile\n", _pch));
    TRETURN(_p->GetCurFile(ppstrFile));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IPersistStream
//
//---------------------------------------------------------------

BEGIN_TRACK(PersistStream)

HRESULT STDMETHODCALLTYPE
GetClassID(LPCLSID lpClassID)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClassID\n", _pch));
    TRETURN(_p->GetClassID(lpClassID));
}

HRESULT STDMETHODCALLTYPE
IsDirty()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsDirty\n", _pch));
    TRETURN(_p->IsDirty());
}

HRESULT STDMETHODCALLTYPE
Load(IStream * pStrm)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Load(strm)\n", _pch));
    TRETURN(_p->Load(pStrm));
}

HRESULT STDMETHODCALLTYPE
Save(IStream * pStrm, BOOL fClearDirty)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Save(strm,)\n", _pch));
    TRETURN(_p->Save(pStrm, fClearDirty));
}

HRESULT STDMETHODCALLTYPE
GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetSizeMax\n", _pch));
    TRETURN(_p->GetSizeMax(pcbSize));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IPersistStreamInit
//
//---------------------------------------------------------------

BEGIN_TRACK(PersistStreamInit)

HRESULT STDMETHODCALLTYPE
GetClassID(LPCLSID lpClassID)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClassID\n", _pch));
    TRETURN(_p->GetClassID(lpClassID));
}

HRESULT STDMETHODCALLTYPE
IsDirty()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsDirty\n", _pch));
    TRETURN(_p->IsDirty());
}

HRESULT STDMETHODCALLTYPE
Load(IStream * pStrm)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Load(strm)\n", _pch));
    TRETURN(_p->Load(pStrm));
}

HRESULT STDMETHODCALLTYPE
Save(IStream * pStrm, BOOL fClearDirty)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Save(strm,)\n", _pch));
    TRETURN(_p->Save(pStrm, fClearDirty));
}

HRESULT STDMETHODCALLTYPE
GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetSizeMax\n", _pch));
    TRETURN(_p->GetSizeMax(pcbSize));
}

HRESULT STDMETHODCALLTYPE
InitNew()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InitNew [Stream]\n", _pch));
    TRETURN(_p->InitNew());
}

END_TRACK()

//---------------------------------------------------------------
//
//  IPersistPropertyBag
//
//---------------------------------------------------------------

BEGIN_TRACK(PersistPropertyBag)

HRESULT STDMETHODCALLTYPE
GetClassID(LPCLSID lpClassID)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClassID\n", _pch));
    TRETURN(_p->GetClassID(lpClassID));
}

HRESULT STDMETHODCALLTYPE
InitNew()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InitNew [PropertyBag]\n", _pch));
    TRETURN(_p->InitNew());
}

HRESULT STDMETHODCALLTYPE
Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrLog)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Load(propbag)\n", _pch));
    TRETURN(_p->Load(pPropBag, pErrLog));
}

HRESULT STDMETHODCALLTYPE
Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Save(propbag,)\n", _pch));
    TRETURN(_p->Save(pPropBag, fClearDirty, fSaveAllProperties));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleInPlaceObject
//
//---------------------------------------------------------------

BEGIN_TRACK(OleInPlaceObject)


HRESULT STDMETHODCALLTYPE
GetWindow(HWND FAR* lphwnd)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindow\n", _pch));
    TRETURN(_p->GetWindow(lphwnd));
}

HRESULT STDMETHODCALLTYPE
ContextSensitiveHelp(BOOL fEnterMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ContextSensitiveHelp\n", _pch));
    TRETURN(_p->ContextSensitiveHelp(fEnterMode));
}

HRESULT STDMETHODCALLTYPE
InPlaceDeactivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InPlaceDeactivate\n", _pch));
    TRETURN(_p->InPlaceDeactivate());
}

HRESULT STDMETHODCALLTYPE
UIDeactivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::UIDeactivate\n", _pch));
    TRETURN(_p->UIDeactivate());
}

HRESULT STDMETHODCALLTYPE
SetObjectRects(LPCRECT lprcPos, LPCRECT lprcVisRect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetObjectRects(pPos,pClip) Pos=(%d,%d,%d,%d), Clip=(%d,%d,%d,%d)\n",
                _pch,
                lprcPos->left, lprcPos->top, lprcPos->right, lprcPos->bottom,
                lprcVisRect->left, lprcVisRect->top, lprcVisRect->right, lprcVisRect->bottom
                ));
    TRETURN(_p->SetObjectRects(lprcPos, lprcVisRect));
}

HRESULT STDMETHODCALLTYPE
ReactivateAndUndo()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ReactivateAndUndo\n", _pch));
    TRETURN(_p->ReactivateAndUndo());
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleControl
//
//---------------------------------------------------------------

BEGIN_TRACK(OleControl)

HRESULT STDMETHODCALLTYPE
GetControlInfo(CONTROLINFO * pCI)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetControlInfo\n", _pch));
    TRETURN(_p->GetControlInfo(pCI));
}

HRESULT STDMETHODCALLTYPE
OnMnemonic(LPMSG pMsg)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnMnemonic\n", _pch));
    TRETURN(_p->OnMnemonic(pMsg));
}

HRESULT STDMETHODCALLTYPE
OnAmbientPropertyChange(DISPID dispid)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnAmbientPropertyChange\n", _pch));
    TRETURN(_p->OnAmbientPropertyChange(dispid));
}

HRESULT STDMETHODCALLTYPE
FreezeEvents(BOOL fFreeze)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::FreezeEvents(%s)\n", _pch,
               ((fFreeze) ? "TRUE" : "FALSE")));
    TRETURN(_p->FreezeEvents(fFreeze));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleInPlaceActiveObject
//
//---------------------------------------------------------------

BEGIN_TRACK(OleInPlaceActiveObject)

HRESULT STDMETHODCALLTYPE
GetWindow(HWND FAR* lphwnd)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindow\n", _pch));
    TRETURN(_p->GetWindow(lphwnd));
}

HRESULT STDMETHODCALLTYPE
ContextSensitiveHelp(BOOL fEnterMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ContextSensitiveHelp\n", _pch));
    TRETURN(_p->ContextSensitiveHelp(fEnterMode));
}

HRESULT STDMETHODCALLTYPE
TranslateAccelerator(LPMSG lpmsg)
{
    return _p->TranslateAccelerator(lpmsg);
}

HRESULT STDMETHODCALLTYPE
OnFrameWindowActivate(BOOL fActivate)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnFrameWindowActivate\n", _pch));
    TRETURN(_p->OnFrameWindowActivate(fActivate));
}

HRESULT STDMETHODCALLTYPE
OnDocWindowActivate(BOOL fActivate)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnDocWindowActivate\n", _pch));
    TRETURN(_p->OnDocWindowActivate(fActivate));
}

HRESULT STDMETHODCALLTYPE
ResizeBorder(LPCRECT lprc,
        LPOLEINPLACEUIWINDOW pUIWindow,
        BOOL fFrameWindow)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ResizeBorder\n", _pch));
    TRETURN(_p->ResizeBorder(lprc, pUIWindow, fFrameWindow));
}

HRESULT STDMETHODCALLTYPE
EnableModeless(BOOL fEnable)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnableModeless\n", _pch));
    TRETURN(_p->EnableModeless(fEnable));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleInPlaceFrame
//
//---------------------------------------------------------------

BEGIN_TRACK(OleInPlaceFrame)

HRESULT STDMETHODCALLTYPE
GetWindow(HWND FAR* lphwnd)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindow\n", _pch));
    TRETURN(_p->GetWindow(lphwnd));
}

HRESULT STDMETHODCALLTYPE
ContextSensitiveHelp(BOOL fEnterMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ContextSensitiveHelp\n", _pch));
    TRETURN(_p->ContextSensitiveHelp(fEnterMode));
}

HRESULT STDMETHODCALLTYPE
GetBorder(LPRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetBorder\n", _pch));
    TRETURN(_p->GetBorder(lprect));
}

HRESULT STDMETHODCALLTYPE
RequestBorderSpace(LPCRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::RequestBorderSpace\n", _pch));
    TRETURN(_p->RequestBorderSpace(lprect));
}

HRESULT STDMETHODCALLTYPE
SetBorderSpace(LPCRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetBorderSpace\n", _pch));
    TRETURN(_p->SetBorderSpace(lprect));
}

HRESULT STDMETHODCALLTYPE
SetActiveObject(LPOLEINPLACEACTIVEOBJECT lpActiveObject,
            LPCOLESTR lpszObjName)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetActiveObject\n", _pch));
    TRETURN(_p->SetActiveObject(lpActiveObject, lpszObjName));
}

HRESULT STDMETHODCALLTYPE
InsertMenus(HMENU hmenuShared,
        LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InsertMenus\n", _pch));
    TRETURN(_p->InsertMenus(hmenuShared, lpMenuWidths));
}

HRESULT STDMETHODCALLTYPE
SetMenu(HMENU hmenuShared,
        HOLEMENU holemenu,
        HWND hwndActiveObject)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetMenu\n", _pch));
    TRETURN(_p->SetMenu(hmenuShared, holemenu, hwndActiveObject));
}

HRESULT STDMETHODCALLTYPE
RemoveMenus(HMENU hmenuShared)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::RemoveMenus\n", _pch));
    TRETURN(_p->RemoveMenus(hmenuShared));
}

HRESULT STDMETHODCALLTYPE
SetStatusText(LPCOLESTR lpszStatusText)
{
    return _p->SetStatusText(lpszStatusText);
}

HRESULT STDMETHODCALLTYPE
EnableModeless(BOOL fEnable)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnableModeless\n", _pch));
    TRETURN(_p->EnableModeless(fEnable));
}

HRESULT STDMETHODCALLTYPE
TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    return _p->TranslateAccelerator(lpmsg, wID);
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleInPlaceUIWindow
//
//---------------------------------------------------------------

BEGIN_TRACK(OleInPlaceUIWindow)

HRESULT STDMETHODCALLTYPE
GetWindow(HWND FAR* lphwnd)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindow\n", _pch));
    TRETURN(_p->GetWindow(lphwnd));
}

HRESULT STDMETHODCALLTYPE
ContextSensitiveHelp(BOOL fEnterMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ContextSensitiveHelp\n", _pch));
    TRETURN(_p->ContextSensitiveHelp(fEnterMode));
}

HRESULT STDMETHODCALLTYPE
GetBorder(LPRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetBorder\n", _pch));
    TRETURN(_p->GetBorder(lprect));
}

HRESULT STDMETHODCALLTYPE
RequestBorderSpace(LPCRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::RequestBorderSpace\n", _pch));
    TRETURN(_p->RequestBorderSpace(lprect));
}

HRESULT STDMETHODCALLTYPE
SetBorderSpace(LPCRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetBorderSpace\n", _pch));
    TRETURN(_p->SetBorderSpace(lprect));
}

HRESULT STDMETHODCALLTYPE
SetActiveObject(LPOLEINPLACEACTIVEOBJECT lpActiveObject,
            LPCOLESTR lpszObjName)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetActiveObject\n", _pch));
    TRETURN(_p->SetActiveObject(lpActiveObject, lpszObjName));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IAdviseSink
//
//---------------------------------------------------------------

BEGIN_TRACK(AdviseSink)

void STDMETHODCALLTYPE
OnDataChange(FORMATETC FAR* pFormatetc,
        STGMEDIUM FAR* pStgmed)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnDataChange\n", _pch));
    _p->OnDataChange(pFormatetc, pStgmed);
    InterlockedDecrement((LONG *)&g_ulNestingLevel);
}

void STDMETHODCALLTYPE
OnViewChange(DWORD dwAspects, LONG lindex)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnViewChange\n", _pch));
    _p->OnViewChange(dwAspects, lindex);
    InterlockedDecrement((LONG *)&g_ulNestingLevel);
}

void STDMETHODCALLTYPE
OnRename(LPMONIKER pmk)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnRename\n", _pch));
    _p->OnRename(pmk);
    InterlockedDecrement((LONG *)&g_ulNestingLevel);
}

void STDMETHODCALLTYPE
OnSave()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnSave\n", _pch));
    _p->OnSave();
    InterlockedDecrement((LONG *)&g_ulNestingLevel);
}

void STDMETHODCALLTYPE
OnClose()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnClose\n", _pch));
    _p->OnClose();
    InterlockedDecrement((LONG *)&g_ulNestingLevel);
}

END_TRACK()


//---------------------------------------------------------------
//
//  IOleItemContainer
//
//---------------------------------------------------------------

BEGIN_TRACK(OleItemContainer)


HRESULT STDMETHODCALLTYPE
ParseDisplayName(LPBC pbc,
        LPOLESTR lpszDisplayName,
        ULONG FAR* pchEaten,
        LPMONIKER FAR* ppmkOut)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS,
                   "%s::ParseDisplayName(,%ls,,)\n",
                   _pch,
                   OUTPUTSTR(lpszDisplayName)));

    TRETURN(_p->ParseDisplayName(pbc, lpszDisplayName, pchEaten, ppmkOut));
}

HRESULT STDMETHODCALLTYPE
EnumObjects(DWORD grfFlags,
        LPENUMUNKNOWN FAR* ppenumUnknown)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnumObjects\n", _pch));
    TRETURN(_p->EnumObjects(grfFlags, ppenumUnknown));
}

HRESULT STDMETHODCALLTYPE
LockContainer(BOOL fLock)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::LockContainer\n", _pch));
    TRETURN(_p->LockContainer(fLock));
}


HRESULT STDMETHODCALLTYPE
GetObject(LPOLESTR lpszItem,
        DWORD dwSpeedNeeded,
        LPBINDCTX pbc,
        REFIID iid, 
        LPVOID FAR* ppvObject)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetObject(%ls,,,,)\n", _pch, OUTPUTSTR(lpszItem)));
    TRETURN(_p->GetObject(lpszItem, dwSpeedNeeded, pbc, iid,  ppvObject));
}

HRESULT STDMETHODCALLTYPE
GetObjectStorage(LPOLESTR lpszItem,
        LPBINDCTX pbc,
        REFIID iid, 
        LPVOID FAR* ppvStorage)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetStorage(%ls,,,)\n", _pch, OUTPUTSTR(lpszItem)));
    TRETURN(_p->GetObjectStorage(lpszItem, pbc, iid,  ppvStorage));
}

HRESULT STDMETHODCALLTYPE
IsRunning(LPOLESTR lpszItem)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsRunning(%ls)\n", _pch, OUTPUTSTR(lpszItem)));
    TRETURN(_p->IsRunning(lpszItem));
}

END_TRACK()


//---------------------------------------------------------------
//
//  IOleCommandTarget
//
//---------------------------------------------------------------

BEGIN_TRACK(OleCommandTarget)

HRESULT STDMETHODCALLTYPE
QueryStatus(
            const GUID * pguidCmdGroup,
            ULONG cCmds,
            MSOCMD rgCmds[],
            MSOCMDTEXT * pcmdtext)
{
    INDENT_NESTING;

    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::QueryStatus(group %s, [",
        _pch, pguidCmdGroup ? "non-null" : "NULL"));
    ULONG i;
    for (i=0; i<cCmds; i++)
        TraceTagEx((tagTrackItfVerbose, TAG_FLAGS,
                       " %d",rgCmds[i].cmdID));
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, " ])\n"));

    TRETURN(_p->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext));
}

HRESULT STDMETHODCALLTYPE
Exec(
            const GUID * pguidCmdGroup,
            DWORD nCmdID,
            DWORD nCmdexecopt,
            VARIANTARG * pvarargIn,
            VARIANTARG * pvarargOut)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Exec(group %s, cmd %d, opts %x)\n",
        _pch, pguidCmdGroup ? "non-null" : "NULL", nCmdID, nCmdexecopt));

    TRETURN(_p->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IHlinkTarget
//
//---------------------------------------------------------------

BEGIN_TRACK(HlinkTarget)

HRESULT STDMETHODCALLTYPE
SetBrowseContext(IHlinkBrowseContext *pihlbc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetBrowseContext\n", _pch));
    TRETURN(_p->SetBrowseContext(pihlbc));
}

HRESULT STDMETHODCALLTYPE
GetBrowseContext(IHlinkBrowseContext **ppihlbc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetBrowseContext\n", _pch));
    TRETURN(_p->GetBrowseContext(ppihlbc));
}

HRESULT STDMETHODCALLTYPE
Navigate(DWORD grfHLNF, LPCWSTR wzJumpLocation)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Navigate(grfHLNF=%x, location=%ls)\n", _pch,
        grfHLNF, OUTPUTSTR(wzJumpLocation)));
    TRETURN(_p->Navigate(grfHLNF, wzJumpLocation));
}

HRESULT STDMETHODCALLTYPE
GetMoniker(LPCWSTR wzLocation, DWORD dwAssign, IMoniker **ppimkLocation)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetMoniker(dwAssign=%x, location=%ls)\n", _pch,
        dwAssign, OUTPUTSTR(wzLocation)));
    TRETURN(_p->GetMoniker(wzLocation, dwAssign, ppimkLocation));
}

HRESULT STDMETHODCALLTYPE
GetFriendlyName(LPCWSTR wzLocation, LPWSTR *pwzFriendlyName)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetFriendlyName(location=%ls)\n", _pch,
        OUTPUTSTR(wzLocation)));
    TRETURN(_p->GetFriendlyName(wzLocation, pwzFriendlyName));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IUnknown
//
//---------------------------------------------------------------

#if defined(_M_IX86)

class CUnknownTrack : public CTrack
{   
public:

    CUnknownTrack(IUnknown *p, REFIID iid, char *pch, BOOL fTrackOnQI);
    void *_apfnVTbl;
};

#define THUNK_IMPL(n)\
void __declspec(naked) TrackThunk##n()\
{                                           \
    /* this = thisArg                   */  \
    __asm mov eax, [esp + 4]                \
    /* pUnkObject = this->_p            */  \
    __asm mov ecx, [eax - 4]                \
    /* thisArg = pvObject               */  \
    __asm mov [esp + 4], ecx                \
    /* vtbl = punkObject->vtbl          */  \
    __asm mov ecx, [ecx]                    \
    /* pfn = vtbl[n]                    */  \
    __asm mov ecx, [ecx + (4 * n)]          \
    /* jump....                         */  \
    __asm jmp ecx                           \
}


#define THUNK_ADDR(n) &TrackThunk##n,

static ULONG STDMETHODCALLTYPE
UnknownTrackAddRef(void *pv)
{
    return ((CUnknownTrack *)((BYTE *)pv - offsetof(CUnknownTrack, _apfnVTbl)))->AddRef();
}

static ULONG STDMETHODCALLTYPE
UnknownTrackRelease(void *pv)
{
    return ((CUnknownTrack *)((BYTE *)pv - offsetof(CUnknownTrack, _apfnVTbl)))->Release();
}

static HRESULT STDMETHODCALLTYPE
UnknownTrackQueryInterface(void *pv, REFIID iid, void **ppv)
{
    return ((CUnknownTrack *)((BYTE *)pv - offsetof(CUnknownTrack, _apfnVTbl)))->QueryInterface(iid, ppv);
}

#define THUNK_IT(x) \
THUNK_##x(3)   THUNK_##x(4)   THUNK_##x(5)   THUNK_##x(6)   THUNK_##x(7)   THUNK_##x(8)   THUNK_##x(9)   THUNK_##x(10)  THUNK_##x(11)  THUNK_##x(12)  THUNK_##x(13)  \
THUNK_##x(14)  THUNK_##x(15)  THUNK_##x(16)  THUNK_##x(17)  THUNK_##x(18)  THUNK_##x(19)  THUNK_##x(20)  THUNK_##x(21)  THUNK_##x(22)  THUNK_##x(23)  THUNK_##x(24)  \
THUNK_##x(25)  THUNK_##x(26)  THUNK_##x(27)  THUNK_##x(28)  THUNK_##x(29)  THUNK_##x(30)  THUNK_##x(31)  THUNK_##x(32)  THUNK_##x(33)  THUNK_##x(34)  THUNK_##x(35)  \
THUNK_##x(36)  THUNK_##x(37)  THUNK_##x(38)  THUNK_##x(39)  THUNK_##x(40)  THUNK_##x(41)  THUNK_##x(42)  THUNK_##x(43)  THUNK_##x(44)  THUNK_##x(45)  THUNK_##x(46)  \
THUNK_##x(47)  THUNK_##x(48)  THUNK_##x(49)  THUNK_##x(50)  THUNK_##x(51)  THUNK_##x(52)  THUNK_##x(53)  THUNK_##x(54)  THUNK_##x(55)  THUNK_##x(56)  THUNK_##x(57)  \
THUNK_##x(58)  THUNK_##x(59)  THUNK_##x(60)  THUNK_##x(61)  THUNK_##x(62)  THUNK_##x(63)  THUNK_##x(64)  THUNK_##x(65)  THUNK_##x(66)  THUNK_##x(67)  THUNK_##x(68)  \
THUNK_##x(69)  THUNK_##x(70)  THUNK_##x(71)  THUNK_##x(72)  THUNK_##x(73)  THUNK_##x(74)  THUNK_##x(75)  THUNK_##x(76)  THUNK_##x(77)  THUNK_##x(78)  THUNK_##x(79)  \
THUNK_##x(80)  THUNK_##x(81)  THUNK_##x(82)  THUNK_##x(83)  THUNK_##x(84)  THUNK_##x(85)  THUNK_##x(86)  THUNK_##x(87)  THUNK_##x(88)  THUNK_##x(89)  THUNK_##x(90)  \
THUNK_##x(91)  THUNK_##x(92)  THUNK_##x(93)  THUNK_##x(94)  THUNK_##x(95)  THUNK_##x(96)  THUNK_##x(97)  THUNK_##x(98)  THUNK_##x(99)  THUNK_##x(100) THUNK_##x(101) \
THUNK_##x(102) THUNK_##x(103) THUNK_##x(104) THUNK_##x(105) THUNK_##x(106) THUNK_##x(107) THUNK_##x(108) THUNK_##x(109) THUNK_##x(110) THUNK_##x(111) THUNK_##x(112) \
THUNK_##x(113) THUNK_##x(114) THUNK_##x(115) THUNK_##x(116) THUNK_##x(117) THUNK_##x(118) THUNK_##x(119) THUNK_##x(120) THUNK_##x(121) THUNK_##x(122) THUNK_##x(123) \
THUNK_##x(124) THUNK_##x(125) THUNK_##x(126) THUNK_##x(127) THUNK_##x(128) THUNK_##x(129) THUNK_##x(130) THUNK_##x(131) THUNK_##x(132) THUNK_##x(133) THUNK_##x(134) \
THUNK_##x(135) THUNK_##x(136) THUNK_##x(137) THUNK_##x(138) THUNK_##x(139) THUNK_##x(140) THUNK_##x(141) THUNK_##x(142) THUNK_##x(143) THUNK_##x(144) THUNK_##x(145) \
THUNK_##x(146) THUNK_##x(147) THUNK_##x(148) THUNK_##x(149) THUNK_##x(150) THUNK_##x(151) THUNK_##x(152) THUNK_##x(153) THUNK_##x(154) THUNK_##x(155) THUNK_##x(156) \
THUNK_##x(157) THUNK_##x(158) THUNK_##x(159) THUNK_##x(160) THUNK_##x(161) THUNK_##x(162) THUNK_##x(163) THUNK_##x(164) THUNK_##x(165) THUNK_##x(166) THUNK_##x(167) \
THUNK_##x(168) THUNK_##x(169) THUNK_##x(170) THUNK_##x(171) THUNK_##x(172) THUNK_##x(173) THUNK_##x(174) THUNK_##x(175) THUNK_##x(176) THUNK_##x(177) THUNK_##x(178) \
THUNK_##x(179) THUNK_##x(180) THUNK_##x(181) THUNK_##x(182) THUNK_##x(183) THUNK_##x(184) THUNK_##x(185) THUNK_##x(186) THUNK_##x(187) THUNK_##x(188) THUNK_##x(189) \
THUNK_##x(190) THUNK_##x(191) THUNK_##x(192) THUNK_##x(193) THUNK_##x(194) THUNK_##x(195) THUNK_##x(196) THUNK_##x(197) THUNK_##x(198) THUNK_##x(199)

THUNK_IT(IMPL)

static void (*s_apfnVtbl[])() =
{
    PFNVOID(&UnknownTrackQueryInterface ),
    PFNVOID(&UnknownTrackAddRef ),
    PFNVOID(&UnknownTrackRelease ),
    THUNK_IT(ADDR)
};

CUnknownTrack::CUnknownTrack(IUnknown *p, REFIID iid, char *pch, BOOL fTrackOnQI) : 
    CTrack(p, iid, pch, fTrackOnQI), 
    _apfnVTbl(s_apfnVtbl) 
{ 
}

#endif

//+---------------------------------------------------------------
//
//  g_aIIDtoFN
//
//----------------------------------------------------------------

static struct 
{
    const IID *pIID;
    IUnknown * (*pfnCreate)(IUnknown *, char *, BOOL);
}
g_aIIDtoFN[] = 
{
    { &IID_IOleObject, COleObject::Create }, 
    { &IID_IParseDisplayName, COleItemContainer::Create }, 
    { &IID_IOleContainer, COleItemContainer::Create }, 
    { &IID_IOleItemContainer, COleItemContainer::Create }, 
    { &IID_IOleClientSite, COleClientSite::Create }, 
    { &IID_IOleInPlaceSite, COleInPlaceSiteWindowless::Create }, 
    { &IID_IOleInPlaceSiteWindowless, COleInPlaceSiteWindowless::Create }, 
    { &IID_IDataObject, CDataObject::Create }, 
    { &IID_IViewObject, CViewObject::Create }, 
    { &IID_IPersist, CPersistStorage::Create }, 
    { &IID_IPersistStorage, CPersistStorage::Create }, 
    { &IID_IPersistFile, CPersistFile::Create }, 
    { &IID_IPersistStream, CPersistStream::Create }, 
    { &IID_IPersistStreamInit, CPersistStreamInit::Create }, 
    { &IID_IPersistPropertyBag, CPersistPropertyBag::Create }, 
    { &IID_IOleInPlaceObject, COleInPlaceObject::Create }, 
    { &IID_IOleControl, COleControl::Create }, 
	{ &IID_IOleInPlaceActiveObject, COleInPlaceActiveObject::Create }, 
	{ &IID_IOleInPlaceFrame, COleInPlaceFrame::Create }, 
	{ &IID_IOleInPlaceUIWindow, COleInPlaceUIWindow::Create }, 
	{ &IID_IOleCommandTarget, COleCommandTarget::Create }, 
	{ &IID_IHlinkTarget, CHlinkTarget::Create }, 
};

//+---------------------------------------------------------------
//
//  Function:   DbgExTrackItf
//
//  Synopsis:   Wraps an interface pointer for the purpose of
//              tracing the method calls on that pointer
//
//  Arguments:  iid The interface of the pointer
//              pch A string prefix to use in the trace output
//              ppv  The pointer to the interface. Updated on return.
//
//----------------------------------------------------------------

void WINAPI
DbgExTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv)
{
    
    if (     
           *ppv == NULL
        || !(DbgExIsTagEnabled(tagTrackItf) || DbgExIsTagEnabled(tagTrackItfVerbose)) 
        || iid == IID_IUnknown 
#if defined(_M_IX86)
        || (void *)s_apfnVtbl == **(void ***)ppv
#endif
        )
    {
        return;
    }

    for (int i = ARRAY_SIZE(g_aIIDtoFN); --i >= 0; )
    {
        if (iid == *g_aIIDtoFN[i].pIID)
            break;
    }

    if (i < 0)
    {
#if defined(_M_IX86)
        CUnknownTrack * pUnknownTrack = new CUnknownTrack((IUnknown *)*ppv, iid, pch, fTrackOnQI);
        if (pUnknownTrack)
            *ppv = &pUnknownTrack->_apfnVTbl;
#endif
    }
    else
    {
        void *pv = g_aIIDtoFN[i].pfnCreate((IUnknown *)*ppv, pch, fTrackOnQI);
        if (pv)
            *ppv = pv;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\simfail.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       simfail.cxx
//
//  Contents:   Simulated failure testing.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

// Timer used to update Count display.
const UINT ID_TIMER = 1;

// Interval of update, in milliseconds.
const UINT TIMER_INTERVAL = 500;

// Number of times FFail is called after g_cfirstFailure is hit.
int     g_cFFailCalled;

// Number of success calls before first failure.  If 0, all calls successful.
int     g_firstFailure;

// Interval to repeat failures after first failure.
int     g_cInterval = 1;

// User defined error for simulated win32 failures.
const DWORD ERR_SIMWIN32 = 0x0200ABAB;

// Handle of simulated failures dialog.
HWND    g_hwndSimFailDlg;

DWORD WINAPI SimFailDlgThread(LPVOID lpThreadParameter);
extern "C" INT_PTR CALLBACK SimFailDlgProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam );

//+---------------------------------------------------------------------------
//
//  Function:   ResetFailCount
//
//  Synopsis:   Resets the count of calls to FFail.
//
//----------------------------------------------------------------------------

void
ResetFailCount()
{
    LOCK_GLOBALS;
    Assert(g_firstFailure >= 0);
    g_cFFailCalled = (g_firstFailure != 0) ? -g_firstFailure : INT_MIN;
}



//+---------------------------------------------------------------------------
//
//  Function:   DbgExSetSimFailCounts
//
//  Synopsis:   Sets the parameters for simulated failures, and resets the
//              count of failures.
//
//  Arguments:  [firstFailure] -- Number of successes - 1 before first failure.
//                                If 0, simulated failures are turned off.
//                                If -1, parameter is ignored.
//
//              [cInterval]    -- Interval at which success are repeated.
//                                If 0, set to 1.
//                                If -1, parameter is ignored.
//
//  Notes:      To reset the count of failures,
//              call DbgExSetSimFailCounts(-1, -1).
//
//----------------------------------------------------------------------------

void WINAPI
DbgExSetSimFailCounts(int firstFailure, int cInterval)
{
    EnsureThreadState();

    LOCK_GLOBALS;

    if (firstFailure >= 0)
    {
        g_firstFailure = firstFailure;
    }

    if (cInterval > 0)
    {
        g_cInterval = cInterval;
    }
    else if (cInterval == 0)
    {
        g_cInterval = 1;
    }

    ResetFailCount();
}



//+---------------------------------------------------------------------------
//
//  Function:   DbgExShowSimFailDlg
//
//  Synopsis:   Displays the simulated failures dialog in a separate thread.
//
//----------------------------------------------------------------------------

void WINAPI
DbgExShowSimFailDlg()
{
#ifndef _MAC
    THREAD_HANDLE  hThread = NULL;
    ULONG   idThread;

    EnsureThreadState();

    LOCK_RESDLG;

    if (g_hwndSimFailDlg)
    {
        BringWindowToTop(g_hwndSimFailDlg);
    }
    else
    {
        hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) SimFailDlgThread, NULL, 0, &idThread);
        if (!hThread)
        {
            TraceTag((tagError, "CreateThread failed DbgExShowSimFailDlg"));
            goto Cleanup;
        }

        CloseThread(hThread);
    }
Cleanup:
    ;
#else
    SimFailDlgThread(NULL);
#endif      // _MAC
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlgThread
//
//  Synopsis:   Creates the simulated failures dialog and runs a message loop
//              until the dialog is closed.
//
//----------------------------------------------------------------------------

DWORD WINAPI
SimFailDlgThread(LPVOID lpThreadParameter)
{
#ifndef _MAC
    MSG         msg;

    EnsureThreadState();

    g_hwndSimFailDlg = CreateDialog(
            g_hinstMain,
            MAKEINTRESOURCE(IDD_SIMFAIL),
            NULL,
            SimFailDlgProc);

    if (!g_hwndSimFailDlg)
    {
        TraceTag((tagError, "CreateDialogA failed in SimFailDlgEntry"));
        return (DWORD) -1;
    }

    SetWindowPos(
            g_hwndSimFailDlg,
            HWND_TOP,
            0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

    while (GetMessage((LPMSG) &msg, (HWND) NULL, 0, 0))
    {
        if (!g_hwndSimFailDlg || (!IsDialogMessage(g_hwndSimFailDlg, &msg)))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
#else
    int r;
    r = DialogBox(g_hinstMain, MAKEINTRESOURCE(IDD_SIMFAIL),
                                    NULL, SimFailDlgProc);
    if (r == -1)
    {
        MessageBoxA(NULL, "TRI Couldn't create sim failures dialog", "Error",
                   MB_OK | MB_ICONSTOP);
    }

    return (DWORD) g_hwndSimFailDlg;
#endif  // _MAC
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateTextControls
//
//  Synopsis:   Updates the FirstFail and FailInterval text controls.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateTextControls(HWND hwnd)
{
#ifndef _MACUNICODE
    TCHAR   ach[16];

    LOCK_GLOBALS;
    ach[ARRAY_SIZE(ach) - 1] = '\0';
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_firstFailure);
    Edit_SetText(GetDlgItem(hwnd, ID_TXTFAIL), ach);
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_cInterval);
    Edit_SetText(GetDlgItem(hwnd, ID_TXTINTERVAL), ach);
#else
    CHAR   ach[16];

    _snprintf(ach, ARRAY_SIZE(ach), ("%d"), g_firstFailure);
    SetWindowTextA((GetDlgItem(hwnd, ID_TXTFAIL)), ach);
    _snprintf(ach, ARRAY_SIZE(ach), ("%d"), g_cInterval);
    SetWindowTextA((GetDlgItem(hwnd, ID_TXTINTERVAL)), ach);
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateCount
//
//  Synopsis:   Updates the count text control.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateCount(HWND hwnd)
{
#ifndef _MACUNICODE
    TCHAR   ach[16];
    
    ach[ARRAY_SIZE(ach) - 1] = '\0';
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), DbgExGetFailCount());
    Edit_SetText(GetDlgItem(hwnd, ID_TXTCOUNT), ach);
#else
    CHAR   ach[16];

    _snprintf(ach, ARRAY_SIZE(ach), ("%d"), DbgExGetFailCount());
    SetWindowTextA(GetDlgItem(hwnd, ID_TXTCOUNT), ach);
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateValues
//
//  Synopsis:   Sets the simulated failure counts with values from the
//              dialog.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateValues(HWND hwnd)
{
    int     firstFail;
    int     cInterval;
#ifndef _MACUNICODE
    TCHAR   ach[16];
    LOCK_GLOBALS;

    Edit_GetText(GetDlgItem(hwnd, ID_TXTFAIL), ach, ARRAY_SIZE(ach));
    firstFail = _ttoi(ach);

    Edit_GetText(GetDlgItem(hwnd, ID_TXTINTERVAL), ach, ARRAY_SIZE(ach));
    cInterval = _ttoi(ach);
#else
    CHAR   ach[16];
    GetWindowTextA(GetDlgItem(hwnd, ID_TXTFAIL), ach, ARRAY_SIZE(ach));
    firstFail = atoi(ach);

    GetWindowTextA(GetDlgItem(hwnd, ID_TXTINTERVAL), ach, ARRAY_SIZE(ach));
    cInterval = atoi(ach);
#endif
    if (firstFail < 0)
    {
        firstFail = 0;
    }
    if (g_cInterval <= 0)
    {
        cInterval = 1;
    }

    DbgExSetSimFailCounts(firstFail, cInterval);
    SimFailDlg_UpdateTextControls(hwnd);
    SimFailDlg_UpdateCount(hwnd);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnInitDialog
//
//  Synopsis:   Initializes the dialog.
//
//----------------------------------------------------------------------------

BOOL
SimFailDlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    Edit_LimitText(GetDlgItem(hwnd, ID_TXTFAIL), 9);
    Edit_LimitText(GetDlgItem(hwnd, ID_TXTINTERVAL), 9);
    SimFailDlg_UpdateTextControls(hwnd);
    SimFailDlg_UpdateCount(hwnd);
    SetTimer(hwnd, ID_TIMER, TIMER_INTERVAL, NULL);
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnCommand
//
//  Synopsis:   Handles button clicks.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (codeNotify != BN_CLICKED)
        return;

    switch (id)
    {
    case ID_BTNUPDATE:
        SimFailDlg_UpdateValues(hwnd);
        break;

    case ID_BTNNEVER:
        DbgExSetSimFailCounts(0, 1);
        SimFailDlg_UpdateTextControls(hwnd);
        SimFailDlg_UpdateCount(hwnd);
        break;

    case ID_BTNRESET:
        ResetFailCount();
        SimFailDlg_UpdateCount(hwnd);
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnTimer
//
//  Synopsis:   Updates the failure count.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnTimer(HWND hwnd, UINT id)
{
    Assert(id == ID_TIMER);
    SimFailDlg_UpdateCount(hwnd);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnClose
//
//  Synopsis:   Closes the dialog.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnClose(HWND hwnd)
{
    Verify(DestroyWindow(g_hwndSimFailDlg));
    g_hwndSimFailDlg = NULL;
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnDestroy
//
//  Synopsis:   Cleans up.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnDestroy(HWND hwnd)
{
    g_hwndSimFailDlg = NULL;
    KillTimer(hwnd, ID_TIMER);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlgProc
//
//  Synopsis:   Dialog proc for simulated failures dialog.
//
//----------------------------------------------------------------------------

extern "C"
INT_PTR CALLBACK
SimFailDlgProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    switch (wMsg)
    {
    case WM_INITDIALOG:
        HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, SimFailDlg_OnInitDialog);
        return TRUE;

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hwnd, wParam, lParam, SimFailDlg_OnCommand);
        return TRUE;

    case WM_TIMER:
        HANDLE_WM_TIMER(hwnd, wParam, lParam, SimFailDlg_OnTimer);
        return TRUE;

    case WM_CLOSE:
        HANDLE_WM_CLOSE(hwnd, wParam, lParam, SimFailDlg_OnClose);
        return TRUE;

    case WM_DESTROY:
        HANDLE_WM_DESTROY(hwnd, wParam, lParam, SimFailDlg_OnDestroy);
        return TRUE;
    }

    return FALSE;
}



//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceFailL
//
//  Synopsis:   Traces failures.  Enable tagTestFailures to see trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [errExpr]  -- The expression to test.
//              [errTest]  -- The fail code to test against.  The only
//                              distinguishing factor is whether it is
//                              zero, negative, or positive.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [errExpr].
//
//----------------------------------------------------------------------------

LONG_PTR WINAPI
DbgExTraceFailL(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    LPSTR aapstr[2][2] =
    {
        "TRI TFAIL: Failure of \"%s\" at %s:%d <%d>",
        "TRI TFAIL: Simulated failure of \"%s\" at %s:%d <%d>",
        "TRI IGNORE_FAIL: Failure of \"%s\" at %s:%d <%d>",
        "TRI IGNORE_FAIL: Simulated failure of \"%s\" at %s:%d <%d>",
    };

    DbgExTraceExit(pstrExpr, pstrFile, line);

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    //
    // Check if errExpr is a success code:
    //     (a) If errTest < 0, then errExpr > 0.  This is for HRESULTs,
    //         list box error codes, etc.
    //     (b) If errTest == 0, the errExpr != 0.  This is for pointers.
    //     (c) If errTest > 0, then errExpr == 0.  This is for the case
    //         where any non-zero error code is an error.  Note that
    //         errTest must be less than the greatest signed integer
    //         (0x7FFFFFFF) for this to work.
    //

    if ((errTest < 0 && errExpr >= 0) ||
        (errTest == 0 && errExpr != 0) ||
        (errTest > 0 && errExpr == 0))
    {
        return errExpr;
    }

    TraceTagEx((
            fIgnore ? tagTestFailuresIgnore : tagTestFailures,
            TAG_NONAME,
            aapstr[fIgnore ? 1 : 0][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            (LONG)errExpr));

    return errExpr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceWin32L
//
//  Synopsis:   Traces Win32 failures, displaying the value of GetLastError if
//              the failure is not simulated.  Enable tagTestFailures to see
//              trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [errExpr]  -- The expression to test.
//              [errTest]  -- The fail code to test against.  The only
//                              distinguishing factor is whether it is
//                              zero, negative, or positive.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [errExpr].
//
//----------------------------------------------------------------------------

LONG_PTR WINAPI
DbgExTraceWin32L(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    LPSTR aapstr[2][2] =
    {
        "TRI TW32: Failure of \"%s\" at %s:%d <%d> GetLastError=<%d>",
        "TRI TW32: Simulated failure of \"%s\" at %s:%d <%d>",
        "TRI IGNORE_W32: Failure of \"%s\" at %s:%d <%d>",
        "TRI IGNORE_W32: Simulated failure of \"%s\" at %s:%d <%d>",
    };

    DbgExTraceExit(pstrExpr, pstrFile, line);

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    //
    // Check if errExpr is a success code:
    //     (a) If errTest < 0, then errExpr > 0.  This is for HRESULTs,
    //         list box error codes, etc.
    //     (b) If errTest == 0, the errExpr != 0.  This is for pointers.
    //     (c) If errTest > 0, then errExpr == 0.  This is for the case
    //         where any non-zero error code is an error.  Note that
    //         errTest must be less than the greatest signed integer
    //         (0x7FFFFFFF) for this to work.
    //

    if ((errTest < 0 && errExpr >= 0) ||
        (errTest == 0 && errExpr != 0) ||
        (errTest > 0 && errExpr == 0))
    {
        return errExpr;
    }

    if (JustFailed())
    {
        SetLastError(ERR_SIMWIN32);
    }

    TraceTagEx((
            fIgnore ? tagTestFailuresIgnore : tagTestFailures,
            TAG_NONAME,
            aapstr[fIgnore ? 1 : 0][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            (LONG)errExpr,
            GetLastError()));

    return errExpr;
}



//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceHR
//
//  Synopsis:   Traces HRESULT failures.  Enable tagTestFailures to see
//              trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [hrTest]   -- The expression to test.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [hrTest].
//
//----------------------------------------------------------------------------

HRESULT WINAPI
DbgExTraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    static LPSTR aapstr[2][2] =
    {
        "TRI THR: Failure of \"%s\" at %s:%d %hr",
        "TRI THR: Simulated failure of \"%s\" at %s:%d %hr",
        "TRI IGNORE_HR: Failure of \"%s\" at %s:%d %hr",
        "TRI IGNORE_HR: Simulated failure of \"%s\" at %s:%d %hr",
    };

    // Assert if we get one of the following errors.
    // The caller is doing something wrong if it gets one.

    static long ahrEvil[] = 
    {
        RPC_E_CANTPOST_INSENDCALL,
        RPC_E_CANTCALLOUT_INASYNCCALL,
        RPC_E_CANTCALLOUT_INEXTERNALCALL,
        RPC_E_CANTCALLOUT_AGAIN,
        RPC_E_CANTCALLOUT_ININPUTSYNCCALL,
        RPC_E_WRONG_THREAD,
        RPC_E_THREAD_NOT_INIT,
    };

    DbgExTraceExit(pstrExpr, pstrFile, line);

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    if (SUCCEEDED(hrTest))
        return hrTest;
    
    TraceTagEx((
            fIgnore ? tagTestFailuresIgnore : tagTestFailures,
            TAG_NONAME,
            aapstr[fIgnore ? 1 : 0][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            hrTest));

    for (int i = ARRAY_SIZE(ahrEvil); --i >= 0;)
    {
        if (hrTest == ahrEvil[i])
            Assert(0 && "Unexpected error code encoutered.");
    }

    if ( fIgnore ) {
        // Added if statement to be able to put a breakpoint
        // for failing THRs but not IGNOREHRs
        return hrTest;
    }

    return hrTest;
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceEnter
//
//  Synopsis:   Traces entrace to a THR-wrapped function call
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [hrTest].
//
//----------------------------------------------------------------------------

void WINAPI
DbgExTraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
//
//  THIS IS DEBUG TRACE CODE
//  To enter the call wrapped by THR, step out and back in. (VC Shift-F11, F11)
//
    TraceTagEx((
            tagTraceCalls,
            TAG_NONAME | TAG_INDENT,
            "TRI THR Enter \"%s\" at %s:%d",
            pstrExpr,
            pstrFile,
            line));
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceExit
//
//  Synopsis:   Traces exit from a THR-wrapped function call
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [hrTest].
//
//----------------------------------------------------------------------------

void WINAPI
DbgExTraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    TraceTagEx((
            tagTraceCalls,
            TAG_NONAME | TAG_OUTDENT,
            "TRI THR Exit  \"%s\" at %s:%d",
            pstrExpr,
            pstrFile,
            line));
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceOLE
//
//  Synopsis:   Traces OLE interface calls. Enable tagOLEWatch to see
//              trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [hrTest]   -- The expression to test.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [hrTest].
//
//----------------------------------------------------------------------------

HRESULT WINAPI
DbgExTraceOLE(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite)
{
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

	// Note that in the case of failure an imbedded call to the TRH() macro
	// performs the trace dump.
    if (FAILED(hrTest))
        return hrTest;

    TraceTagEx((
            tagOLEWatch,
            TAG_NONAME,
            "TRI THR_OLE:\"%s\" returns %hr at %s:%d site 0x%x",
            pstrExpr,
            hrTest,
            pstrFile,
            line,
			lpsite));

    return hrTest;
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgExCheckAndReturnResultList
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure, and asserts
//              if the HRESULT is not a permitted success code.
//
//  Arguments:  [hr]        -- the HRESULT to be checked.
//              [pstrFile]  -- the file where the HRESULT is being checked.
//              [line]      -- the line in the file where the HRESULT is
//                                  being checked.
//              [cSuccess]  -- the number of permitted non-zero success codes
//                               or failure SCODES that should not be traced.
//              [...]       -- list of HRESULTS.
//
//  Returns:    The return value is exactly the HRESULT passed in.
//
//  Notes:      This function should not be used directly.  Use
//              the SRETURN and RRETURN macros instead.
//
// HRESULTs passed in should either be permitted success codes, permitted
// non-OLE error codes, or expected OLE error codes.  Expected OLE error codes
// prevent a warning from being printed to the debugger, while the rest cause
// asserts if they're not given as an argument.
//
// An OLE error code has a facility not equal to FACILITY_ITF or is equal to
// FACILITY_ITF and the code is less than the current maximum value used.
//
//----------------------------------------------------------------------------

HRESULT __cdecl
DbgExCheckAndReturnResult(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, ...)
{
    HRESULT hrResult;
    va_list va;

    va_start(va, cHResult);
    hrResult = DbgExCheckAndReturnResultList(hr, fTrace, pstrFile, line, cHResult, va);
    va_end(va);

    return(hrResult);
}

HRESULT WINAPI
DbgExCheckAndReturnResultList(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list va)
{
    BOOL    fOLEError;
    BOOL    fOLEDBError;
    BOOL    fOKReturnCode;
    int     i;
    HRESULT hrArg;

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    //
    //  These xxx_E_LAST hresults are the highest-valued ones in FACILITY_ITF
    //  currently (at the time of coding).  These asserts should alert us if
    //  the numbers change, and our usage of CONNECT_E_LAST is no longer valid.
    //
    Assert(HRESULT_CODE(CONNECT_E_LAST) == HRESULT_CODE(SELFREG_E_LAST));
    Assert(HRESULT_CODE(CONNECT_E_LAST) == HRESULT_CODE(PERPROP_E_LAST));

    //
    // Check if code is a permitted error or success.
    //

    fOLEError = (hr < 0 &&
                 (HRESULT_FACILITY(hr) != FACILITY_ITF ||
                  HRESULT_CODE(hr) < HRESULT_CODE(CONNECT_E_LAST)));

    // Codes 0x0e00-0x0eff are reserved for the OLE DB group of
    // interfaces.  (So sayeth <oledberr.h>)
    fOLEDBError = HRESULT_FACILITY(hr) == FACILITY_ITF &&
                    0x0E00 <= HRESULT_CODE(hr) && HRESULT_CODE(hr) <= 0x0EFF;
    
    fOKReturnCode = ((cHResult == -1) || fOLEError || fOLEDBError || (hr == S_OK));

    if (cHResult > 0)
    {
        for (i = 0; i < cHResult; i++)
        {
            hrArg = va_arg(va, HRESULT);
            if (hr == hrArg)
            {
                fOKReturnCode = TRUE;

                if (fOLEError)
                    fTrace = FALSE;

                break;
            }
        }
    }

    //
    // Assert on non-permitted success code.
    //

    if (!fOKReturnCode)
    {
        TraceTag((
                tagError,
                "%s:%d returned unpermitted HRESULT %hr",
                pstrFile,
                line,
                hr));
        AssertLocSz(hr <= 0, pstrFile, line,
                    "An unpermitted success code was returned.");
        AssertLocSz(!(HRESULT_FACILITY(hr) == FACILITY_ITF && HRESULT_CODE(hr) >= 0x0200), pstrFile, line,
                    "An unpermitted FACILITY_ITF HRESULT was returned.");
    }

    //
    // Warn on error result.
    //

    if (fTrace && FAILED(hr))
    {
        TraceTagEx((
                tagRRETURN,
                TAG_NONAME,
                "RRETURN: %s:%d returned %hr",
                pstrFile,
                line,
                hr));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\_f3debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       _f3debug.h
//
//  Contents:   Misc internal debug definitions.
//
//----------------------------------------------------------------------------

//
// Shared macros
//

typedef void *  PV;
typedef char    CHAR;

#define ARRAY_SIZE(a)   (sizeof(a) / sizeof(a[0]))

#ifdef tagError
#undef tagError
#endif

#ifdef tagAssertExit
#undef tagAssertExit
#endif

#ifdef tagAssertStacks
#undef tagAssertStacks
#endif

#define tagNull     ((TRACETAG) 0)
#define tagMin      ((TRACETAG) 1)
#define tagMax      ((TRACETAG) 1024)


/*
 *  TGTY
 *
 *  Tag type.  Possible values:
 *
 *      tgtyTrace       Trace points
 *      tgtyOther       Other TAG'd switch
 */

typedef int TGTY;

#define tgtyNull    0
#define tgtyTrace   1
#define tgtyOther   2

/*
 *  Flags in TGRC that are written to disk.
 */

enum TGRC_FLAG
{
    TGRC_FLAG_VALID     =  0x00000001,
    TGRC_FLAG_DISK      =  0x00000002,
    TGRC_FLAG_BREAK     =  0x00000008,
    TGRC_FLAG_SORTFIRST =  0x00000010,
    TGRC_FLAG_INITED    =  0x00000020,
#ifdef _MAC
    TGRC_FLAG_MAX =     LONG_MAX    // needed to force enum to be dword
#endif

};

#define TGRC_DEFAULT_FLAGS (TGRC_FLAG_VALID)

/*
 *  TGRC
 *
 *  Tag record.  Gives the current state of a particular TAG.
 *  This includes enabled status, owner and description, and
 *  tag type.
 *
 */

struct TGRC
{
    /* For trace points, enabled means output will get sent */
    /* to screen or disk.  For native/pcode switching, enabled */
    /* means the native version will get called. */

    BOOL    fEnabled;

    DWORD   ulBitFlags;     /* Flags */
    CHAR *  szOwner;        /* Strings passed at init ... */
    CHAR *  szDescrip;
    TGTY    tgty;           /* TAG type */

    BOOL    TestFlag(TGRC_FLAG mask)
                { return (ulBitFlags & mask) != 0; }
    void    SetFlag(TGRC_FLAG mask)
                { (ULONG&) ulBitFlags |= mask; }
    void    ClearFlag(TGRC_FLAG mask)
                { (ULONG&) ulBitFlags &= ~mask; }
    void    SetFlagValue(TGRC_FLAG mask, BOOL fValue)
                { fValue ? SetFlag(mask) : ClearFlag(mask); }
};

struct INET_SYMBOL_INFO
{
    DWORD       dwOffset;
    char        achModule[12];  // Lengths are arbitrary.
    char        achSymbol[51];
};

#ifdef PRODUCT_96
#define STACK_WALK_DEPTH  5
#else
#define STACK_WALK_DEPTH  12
#endif

/*
 * MBOT
 *
 * Used by the assert code for passing information to the assert dialog
 *
 */

#define TOPURL_LENGTH 200

struct MBOT
{
    const char * szMessage;
    const char * szTitle;
    const char * szFile;
    char         achModule[50];
    char         achTopUrl[TOPURL_LENGTH];
    DWORD        dwLine;
    DWORD        pid;
    DWORD        tid;

    INET_SYMBOL_INFO  asiSym[50];
    int          cSym;

    // DWORD        dwFlags;
    int          id;
    DWORD        dwErr;
};

// This constant is used to determine the number of symbols we use to print to
// the debugger and dialog for an assert.

#define SHORT_SYM_COUNT 5


/*
 *  DBGTHREADSTATE
 *
 *  Per-thread globals
 *
 */
struct DBGTHREADSTATE      // tag: pts
{
    DBGTHREADSTATE *   ptsNext;
    DBGTHREADSTATE *   ptsPrev;

    // Add globals below
    void *          pvRequest;              // Last pointer seen by pre-hook function.
    size_t          cbRequest;              // Last size seen by pre-hook function.
    BOOL            fSymbols;               // Last AreSymbolsEnabled() by pre-hook function.
    int             cTrackDisable;          // Disable memory tracking count/flag
    int             cCoTrackDisable;        // Disable Co memory tracking count/flag
    int             iIndent;                // Indent for trace tags
    BOOL            fDirtyDlg;              // Debug UI dirty dialog flag
    BOOL            fSpyRegistered;         // IMallocSpy registered
    BOOL            fSpyAlloc;              // Allocation is from IMallocSpy
    PERFMETERTAG    mtSpy;                  // Meter to use for IMallocSpy
    PERFMETERTAG    mtSpyUser;              // Custom meter to use for IMallocSpy
    INET_SYMBOL_INFO     aSymbols[STACK_WALK_DEPTH]; // stored symbols for realloc
    MBOT *          pmbot;                      // Used by assert dialog
    char            achTopUrl[TOPURL_LENGTH];   // Unicode string containing the
                                                //   topmost URL of the current
                                                //   page for this thread.
};

HRESULT DllThreadAttach();
void    DllThreadDetach(DBGTHREADSTATE * pts);

inline HRESULT EnsureThreadState()
{
    extern DWORD    g_dwTls;
    if (!TlsGetValue(g_dwTls))
        return DllThreadAttach();
    return S_OK;
}

inline DBGTHREADSTATE * DbgGetThreadState()
{
    extern DWORD    g_dwTls;
    return (DBGTHREADSTATE *)TlsGetValue(g_dwTls);
}

#undef TLS
#define TLS(x)      (DbgGetThreadState()->x)

/*
 *  CLockGlobals, CLockTrace, CLockResDlg
 *
 *  Classes which automatically lock/unlock global state
 *
 */
#ifndef _MAC
extern CRITICAL_SECTION     g_csTrace;
extern CRITICAL_SECTION     g_csResDlg;
extern CRITICAL_SECTION     g_csDebug;
extern CRITICAL_SECTION     g_csHeapHack;
extern CRITICAL_SECTION     g_csSpy;

class CLockGlobal       // tag: glock
{
public:
    CLockGlobal()   { EnterCriticalSection(&g_csDebug); }
    ~CLockGlobal()  { LeaveCriticalSection(&g_csDebug); }
};

class CLockTrace        // tag: tlock
{
public:
    CLockTrace()   { EnterCriticalSection(&g_csTrace); }
    ~CLockTrace()  { LeaveCriticalSection(&g_csTrace); }
};

class CLockResDlg       // tag: rlock
{
public:
    CLockResDlg()   { EnterCriticalSection(&g_csResDlg); }
    ~CLockResDlg()  { LeaveCriticalSection(&g_csResDlg); }
};

#undef LOCK_GLOBALS
#define LOCK_GLOBALS    CLockGlobal glock
#define LOCK_TRACE      CLockTrace  tlock
#define LOCK_RESDLG     CLockResDlg rlock
#else
#define LOCK_GLOBALS
#define LOCK_TRACE
#define LOCK_RESDLG
#endif


//
// Shared globals
//
extern BOOL                 g_fInit;
extern HINSTANCE            g_hinstMain;
extern HANDLE               g_hProcess;
extern TGRC                 mptagtgrc[];

ExternTag(tagMac);
ExternTag(tagError);
ExternTag(tagAssertPop);
ExternTag(tagAssertExit);
ExternTag(tagAssertStacks);
ExternTag(tagTestFailures);
ExternTag(tagTestFailuresIgnore);
ExternTag(tagRRETURN);
ExternTag(tagTraceCalls);
ExternTag(tagLeaks);
ExternTag(tagValidate);
ExternTag(tagSymbols);
ExternTag(tagSpySymbols);
ExternTag(tagTrackItf);
ExternTag(tagTrackItfVerbose);
ExternTag(tagOLEWatch);  // trace all OLE interface calls made.

extern int  g_cFFailCalled;
extern int  g_firstFailure;
extern int  g_cInterval;
extern BOOL g_fOSIsNT;
extern BOOL g_fAbnormalProcessTermination;

//
//  Shared function prototypes
//

// IEUNIX uses C++ compiler and the following func.
// And need to convert the following to C type to fix build break.
#ifdef UNIX
extern "C" {
#endif

HRESULT         GetTopURLForThread(DWORD tid, char * psz);
BOOL            JustFailed();
VOID            SaveDefaultDebugState(void);
BOOL            AreSymbolsEnabled();
void            MagicInit();
void            MagicDeinit();
int             GetStackBacktrace(int iStart, int cTotal, DWORD * pdwEip, INET_SYMBOL_INFO * psiSym);
void            GetStringFromSymbolInfo(DWORD dwAddr, INET_SYMBOL_INFO *pai, CHAR * pszString);
int             hrvsnprintf(char * achBuf, int cchBuf, const char * pstrFmt, va_list valMarker);

#ifdef UNIX // UNIX needs to define the following in C type.
}
#endif

typedef HANDLE EVENT_HANDLE;
typedef HANDLE THREAD_HANDLE;
#define CloseEvent CloseHandle
#define CloseThread CloseHandle
#define IF_WIN16(x)
#define IF_NOT_WIN16(x) x

#define WIN16API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\viewer.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       view.cxx
//
//  Contents:   IViewObject viewer.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

typedef HRESULT (WINAPI * PFNOLEDRAW)(LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, LPCRECT lprcBounds);
typedef void (WINAPI * PFNRELEASESTGMEDIUM)(LPSTGMEDIUM pstgmed);
PFNOLEDRAW g_pfnOleDraw = NULL;
PFNRELEASESTGMEDIUM g_pfnReleaseStgMedium = NULL;

PFNOLEDRAW
GetPfnOleDraw()
{
    if (g_pfnOleDraw == NULL)
    {
        g_pfnOleDraw = (PFNOLEDRAW)GetProcAddress(GetModuleHandleA("ole32.dll"), "OleDraw");
        Assert(g_pfnReleaseStgMedium);
    }
    return(g_pfnOleDraw);
}

PFNRELEASESTGMEDIUM
GetPfnReleaseStgMedium()
{
    if (g_pfnReleaseStgMedium == NULL)
    {
        g_pfnReleaseStgMedium = (PFNRELEASESTGMEDIUM)GetProcAddress(GetModuleHandleA("ole32.dll"), "ReleaseStgMedium");
        Assert(g_pfnReleaseStgMedium);
    }
    return(g_pfnReleaseStgMedium);
}

#define IDM_REFRESH 20

enum
{
    TYPE_VIEW,
    TYPE_METAFILE,
    TYPE_ENHMETAFILE
};

static struct
{
    int         type;
    DWORD       dwAspect;
    int         mm;
} s_aModeInfo[] = {
    // Elements in this array correspond to the menu items in f3debug.rc
    { 0 },
    { TYPE_VIEW,        DVASPECT_CONTENT, MM_TEXT },
    { TYPE_VIEW,        DVASPECT_CONTENT, MM_ANISOTROPIC },
    { TYPE_VIEW,        DVASPECT_ICON,    MM_TEXT },
    { TYPE_VIEW,        DVASPECT_ICON,    MM_ANISOTROPIC },
    { TYPE_METAFILE,    DVASPECT_CONTENT, 0 },
    { TYPE_METAFILE,    DVASPECT_ICON,    0 },
    { TYPE_ENHMETAFILE, DVASPECT_CONTENT, 0 },
    { TYPE_ENHMETAFILE, DVASPECT_ICON,    0 },
};

static BOOL s_fWndClassRegistered = FALSE;
static SIZE s_sizePixelsPerInch;
static FORMATETC s_FormatEtcMetaFile =
    { (CLIPFORMAT) CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT };

class CViewer : public IAdviseSink2
{
public:

    CViewer();
    ~CViewer();

    // IUnknown methods

    STDMETHOD(QueryInterface) (REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IAdviseSink methods

    void STDMETHODCALLTYPE OnDataChange(
            FORMATETC FAR* pFormatetc,
            STGMEDIUM FAR* pStgmed);
    void STDMETHODCALLTYPE OnViewChange(
            DWORD dwAspect, LONG lindex);
    void STDMETHODCALLTYPE OnRename(LPMONIKER pmk);
    void STDMETHODCALLTYPE OnSave();
    void STDMETHODCALLTYPE OnClose();
    void STDMETHODCALLTYPE OnLinkSrcChange(IMoniker * pmk);

    // New methods

    void OnButtonDown(POINTS pts);
    void OnPaint();
    void OnCommand(int idm);
    void DrawMetaFile(HDC hdc, RECT *prc, DWORD dwApsect);
    void DrawEnhMetaFile(HDC hdc, RECT *prc, DWORD dwAspect);
    void DrawView(HDC hdc, RECT *prc, DWORD dwAspect, int mm);

    ULONG           _ulRef;
    HWND            _hwnd;
    IDataObject *   _pDO;
    IViewObject *   _pVO;
    int             _cDataChange;
    int             _idmMode;
    DWORD           _dwCookie;
};

CViewer::CViewer()
{
    _ulRef = 0;
    _hwnd  = NULL;
    _pDO  = NULL;
    _cDataChange = 0;
    _idmMode = 1;
    _dwCookie = 0;
}

CViewer::~CViewer()
{
    _ulRef = 256;

    if (_pDO)
    {
        if (_dwCookie)
        {
            _pDO->DUnadvise(_dwCookie);
            _dwCookie = 0;
        }
        _pDO->Release();
        _pDO = NULL;
    }

    if (_pVO)
    {
        _pVO->SetAdvise(DVASPECT_CONTENT, 0, NULL);
        _pVO->Release();
        _pVO = 0;
    }

    if (_hwnd)
    {
        SetWindowLongPtr(_hwnd, GWLP_USERDATA, 0);
        Verify(DestroyWindow(_hwnd));
        _hwnd = NULL;
    }
}

STDMETHODIMP
CViewer::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown ||
            iid == IID_IAdviseSink2 ||
            iid == IID_IAdviseSink)
    {
        *ppv = (IAdviseSink2 *)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CViewer::AddRef()
{
    return _ulRef += 1;
}

STDMETHODIMP_(ULONG)
CViewer::Release()
{
    _ulRef -= 1;
    if (_ulRef == 0)
    {
        delete this;
        return 0;
    }
    return _ulRef;
}

STDMETHODIMP_(void)
CViewer::OnDataChange(FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed)
{
    _cDataChange += 1;
    InvalidateRect(_hwnd, 0, FALSE);
}

STDMETHODIMP_(void)
CViewer::OnViewChange(DWORD dwAspects, LONG lindex)
{
    InvalidateRect(_hwnd, 0, FALSE);
}

STDMETHODIMP_(void)
CViewer::OnRename(LPMONIKER pmk)
{
}

STDMETHODIMP_(void)
CViewer::OnSave()
{
}

STDMETHODIMP_(void)
CViewer::OnClose()
{
}

STDMETHODIMP_(void)
CViewer::OnLinkSrcChange(IMoniker * pmk)
{
}

void
CViewer::OnCommand(int idm)
{
    switch (idm)
    {
    case IDM_REFRESH:
        InvalidateRect(_hwnd, NULL, TRUE);
        break;

    default:

        if (idm >= 1 && idm < ARRAY_SIZE(s_aModeInfo))
        {
            _idmMode = idm;
            InvalidateRect(_hwnd, NULL, TRUE);
        }
        break;
    }
}

void
CViewer::OnButtonDown(POINTS pts)
{
    POINT pt = { pts.x, pts.y };
    HMENU hmenu;
    HMENU hmenuSub;
    int   idm;

    hmenu = LoadMenuA(g_hinstMain, "ViewerMenu");
    if (hmenu)
    {
        ClientToScreen(_hwnd, &pt);
        hmenuSub = GetSubMenu(hmenu, 0);
        if (hmenuSub)
        {
            for (idm = 0; idm < ARRAY_SIZE(s_aModeInfo); idm++)
            {
                CheckMenuItem(hmenuSub,
                              idm,
                              (_idmMode == idm) ?
                              MF_BYCOMMAND|MF_CHECKED :
                              MF_BYCOMMAND|MF_UNCHECKED);
            }
#ifndef _MAC
            TrackPopupMenu(hmenuSub, TPM_LEFTALIGN | TPM_LEFTBUTTON,
#else
            TrackPopupMenu(hmenuSub, 0,
#endif
                           pt.x, pt.y, 0, _hwnd, NULL);
        }
        DestroyMenu(hmenu);
    }
}

void
CViewer::DrawView(HDC hdc, RECT *prc, DWORD dwAspect, int mm)
{
    HRESULT       hr;

    if (mm == MM_ANISOTROPIC)
    {
        // himetric
        LPtoDP(hdc, (POINT *)prc, 2);
        SetMapMode(hdc, mm);
        SetWindowExtEx(hdc, 2540, 2540, NULL);
        SetViewportExtEx(hdc,
                GetDeviceCaps(hdc, LOGPIXELSX),
                GetDeviceCaps(hdc, LOGPIXELSY), NULL);
        DPtoLP(hdc, (POINT *)prc, 2);
    }

#ifndef _MAC
    hr = (*GetPfnOleDraw())(_pVO, dwAspect, hdc, prc);
#else
	hr = _pVO->Draw(	 dwAspect,-1,0,0,0, hdc, (LPRECTL)prc, 0,0,0);
#endif
}

void
CViewer::DrawMetaFile(HDC hdc, RECT *prc, DWORD dwApsect)
{
    HRESULT         hr;
    STGMEDIUM       medium;
    METAFILEPICT *  pPict;
    FORMATETC       fmtetc =
        { CF_METAFILEPICT, NULL, dwApsect, -1, TYMED_MFPICT };

    memset(&medium, 0, sizeof(medium));

    hr = _pDO->GetData(&fmtetc, &medium);
    if (FAILED(hr))
        goto Cleanup;

    // STGFIX: t-gpease 8-13-97
    Assert(medium.tymed == TYMED_HGLOBAL);

    pPict = (METAFILEPICT *)GlobalLock(medium.hGlobal);

    SetMapMode(hdc, MM_ANISOTROPIC);
    SetWindowExtEx(hdc, pPict->xExt, pPict->yExt, NULL);
    SetViewportExtEx(hdc, prc->right - prc->left, prc->bottom - prc->top, NULL);
    // SetWindowExtEx(hdc, pPict->xExt, pPict->yExt, NULL);
    PlayMetaFile(hdc, pPict->hMF);

Cleanup:
    (*GetPfnReleaseStgMedium())(&medium);
}

void
CViewer::DrawEnhMetaFile(HDC hdc, RECT *prc, DWORD dwApsect)
{
#ifndef _MAC
    HRESULT         hr;
    STGMEDIUM       medium;
    FORMATETC       fmtetc =
        { CF_ENHMETAFILE, NULL, dwApsect, -1, TYMED_ENHMF };

    memset(&medium, 0, sizeof(medium));

    hr = _pDO->GetData(&fmtetc, &medium);
    if (FAILED(hr))
        goto Cleanup;
    PlayEnhMetaFile(hdc, medium.hEnhMetaFile, prc);

Cleanup:
    (*GetPfnReleaseStgMedium())(&medium);
#endif
}

void
CViewer::OnPaint()
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;
    char achMode[128];
    char achTitle[128];
    HMENU hmenu;
    HMENU hmenuSub;

    hmenu = LoadMenuA(g_hinstMain, "ViewerMenu");
    if (hmenu)
    {
        hmenuSub = GetSubMenu(hmenu, 0);
        if (hmenuSub)
            GetMenuStringA(hmenuSub, _idmMode, achMode, sizeof(achMode), MF_BYCOMMAND);
        DestroyMenu(hmenu);
    }
    wsprintfA(achTitle, "%s %d", achMode, _cDataChange);
    SetWindowTextA(_hwnd, achTitle);

    GetClientRect(_hwnd, &rc);
    hdc = ::BeginPaint(_hwnd, &ps);

    switch (s_aModeInfo[_idmMode].type)
    {
    case TYPE_VIEW:
        DrawView(
                hdc,
                &rc,
                s_aModeInfo[_idmMode].dwAspect,
                s_aModeInfo[_idmMode].mm);
        break;

    case TYPE_METAFILE:
        DrawMetaFile(
                hdc,
                &rc,
                s_aModeInfo[_idmMode].dwAspect);
        break;

    case TYPE_ENHMETAFILE:
        DrawEnhMetaFile(
                hdc,
                &rc,
                s_aModeInfo[_idmMode].dwAspect);
        break;
    }

    SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    EndPaint(_hwnd, &ps);
}

LRESULT CALLBACK
ViewerWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CViewer *pViewer;

    if (msg == WM_NCCREATE)
    {
        pViewer = (CViewer *) ((LPCREATESTRUCTW)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pViewer);
        pViewer->_hwnd = hwnd;
    }
    else
    {
        pViewer = (CViewer *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    if (pViewer)
    {
        switch (msg)
        {
        case WM_ERASEBKGND:
            if (s_aModeInfo[pViewer->_idmMode].dwAspect == DVASPECT_CONTENT)
                return TRUE;
            break;
            
        case WM_COMMAND:
            pViewer->OnCommand(GET_WM_COMMAND_ID(wParam, lParam));
            return 0;

        case WM_RBUTTONDOWN:
            pViewer->OnButtonDown(MAKEPOINTS(lParam));
            return 0;

        case WM_PAINT:
            pViewer->OnPaint();
            return 0;

        case WM_NCDESTROY:
            pViewer->_hwnd = NULL;
            delete pViewer;
            break;
        }
    }

    return DefWindowProcA(hwnd, msg, wParam, lParam);
}

void WINAPI 
DbgExOpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize)
{
    CViewer *           pViewer = NULL;
    IOleObject *        pObj = NULL;
    IOleClientSite *    pClientSite = NULL;
    IOleInPlaceSite *   pIPSite = NULL;
    IOleInPlaceFrame *  pIPFrame = NULL;
    IOleInPlaceUIWindow * pIPWin = NULL;
    OLEINPLACEFRAMEINFO FI;
    RECT            rcPos;
    RECT            rcClip;
    WNDCLASSA       wc;
    HRESULT         hr;
    SIZEL           sizel;
    SIZE            size;
    HDC             hdc;

    EnsureThreadState();

    pViewer = new CViewer;
    if (!pViewer)
        goto Error;

    {   LOCK_GLOBALS;

        if (!s_fWndClassRegistered)
        {
            hdc = GetDC(NULL);
            if (!hdc)
                goto Error;

            s_sizePixelsPerInch.cx = GetDeviceCaps(hdc, LOGPIXELSX);
            s_sizePixelsPerInch.cy = GetDeviceCaps(hdc, LOGPIXELSY);

            ReleaseDC(NULL, hdc);

            memset(&wc, 0, sizeof(wc));
            wc.style = CS_HREDRAW | CS_VREDRAW;
            wc.lpfnWndProc = ViewerWndProc;
            wc.hInstance = g_hinstMain;
            wc.lpszClassName = "F3Viewer";
            wc.hbrBackground = (HBRUSH)(COLOR_BACKGROUND + 1);

            if (RegisterClassA(&wc) == 0)
                goto Error;

            s_fWndClassRegistered = TRUE;
        }
    }

    hr = pUnk->QueryInterface(IID_IDataObject, (void **)&pViewer->_pDO);
    if (hr)
        goto Error;

    hr = pUnk->QueryInterface(IID_IViewObject, (void **)&pViewer->_pVO);
    if (FAILED(hr))
        goto Error;

    hr = pUnk->QueryInterface(IID_IOleObject, (void **)&pObj);
    if (hr)
        goto Error;

    hr = pObj->GetClientSite(&pClientSite);
    if (hr)
        goto Error;

    hr = pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **) &pIPSite);
    if (hr)
        goto Error;

    hr = pIPSite->GetWindowContext(
            &pIPFrame,
            &pIPWin,
            &rcPos,
            &rcClip,
            &FI);
    if (hr)
        goto Error;

    GetWindowRect(FI.hwndFrame, &rcPos);

    if (fUseFrameSize)
    {
        size.cx = rcPos.right - rcPos.left;
        size.cy = rcPos.bottom - rcPos.top;
    }
    else
    {
        RECT    rcClient;
        GetClientRect(FI.hwndFrame, &rcClient);

        hr = pObj->GetExtent(DVASPECT_CONTENT, &sizel);
        if (hr)
            goto Error;                
        size.cx = MulDiv(sizel.cx, s_sizePixelsPerInch.cx, 2540) + 
                (rcPos.right - rcPos.left) - (rcClient.right - rcClient.left);
        size.cy = MulDiv(sizel.cy, s_sizePixelsPerInch.cy, 2540) +
                (rcPos.bottom - rcPos.top) - (rcClient.bottom - rcClient.top);
    }

    if (CreateWindowExA(
            0,
            "F3Viewer",
            "IViewObject",
            WS_OVERLAPPEDWINDOW | WS_VISIBLE,
            rcPos.left,
            rcPos.bottom,
            size.cx,
            size.cy,
            hwndOwner,
            NULL,
            g_hinstMain,
            pViewer) == 0)
        goto Error;

    hr = pViewer->_pDO->DAdvise(
            &s_FormatEtcMetaFile,
            ADVF_NODATA,
            pViewer,
            &pViewer->_dwCookie);
    if (hr)
        goto Error;

    hr = pViewer->_pVO->SetAdvise(DVASPECT_CONTENT, 0, pViewer);
    if (hr)
        goto Error;

Cleanup:
    if (pObj)
        pObj->Release();
    if (pClientSite)
        pClientSite->Release();
    if (pIPSite)
        pIPSite->Release();
    if (pIPFrame)
        pIPFrame->Release();
    if (pIPWin)
        pIPWin->Release();
    return;

Error:
    delete pViewer;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debug\ws.cxx ===
//+------------------------------------------------------------------------
//  
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//  
//  File:       Working set test infrastructure
//  
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PSAPI_H_
#define X_PSAPI_H_
#include "psapi.h"
#endif

#define MAX_PAGE_ENTRIES 256
#define MAXMODULES 64
#define MAX_WS_DELTA_PAGES 1024

struct WSPAGEINFO
{
   DWORD fAttr      :  8;
   DWORD fShared    :  1;
   DWORD filler     :  3;
   DWORD addrPage   : 20;
};

struct WSPAGEENTRY
{
    DWORD addrStart;
    DWORD addrEnd;
    TCHAR szModule[16];
    TCHAR szSection[8];
    DWORD dwSize;
};

static WSPAGEENTRY s_aPE[MAX_PAGE_ENTRIES];
static PSAPI_WS_WATCH_INFORMATION s_aWsChanges[MAX_WS_DELTA_PAGES];
static DWORD s_cPageEntries = 0;
static HINSTANCE s_hmod = NULL;
static BOOL s_bWsDeltaStarted = FALSE;

static BOOL (WINAPI *s_pfnGetProcessMemoryInfo)(HANDLE Process, PPROCESS_MEMORY_COUNTERS ppmemctrs, DWORD cb);
static BOOL (WINAPI *s_pfnEmptyWorkingSet)(HANDLE hProcess);
static BOOL (WINAPI *s_pfnQueryWorkingSet)(HANDLE hProcess, PVOID pv, DWORD cb);
static BOOL (WINAPI *s_pfnEnumProcessModules)(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded);
static DWORD (WINAPI *s_pfnGetModuleBaseName)(HANDLE hProcess, HMODULE hModule, LPTSTR lpBaseName, DWORD nSize);
static BOOL (WINAPI *s_pfnGetWsChanges)(HANDLE hProcess, PPSAPI_WS_WATCH_INFORMATION lpWatchInfo, DWORD cb);
static BOOL (WINAPI *s_pfnInitializeProcessForWsWatch)(HANDLE hProcess);

HRESULT LoadPSAPI()
{
    if (s_hmod)
	{
        return S_OK;
	}

    s_hmod = LoadLibrary(_T("PSAPI"));
    if (!s_hmod)
	{
        RRETURN(E_FAIL);
	}

    *(void **)&s_pfnGetProcessMemoryInfo = GetProcAddress(s_hmod, "GetProcessMemoryInfo");
    *(void **)&s_pfnQueryWorkingSet = GetProcAddress(s_hmod, "QueryWorkingSet");
    *(void **)&s_pfnEmptyWorkingSet = GetProcAddress(s_hmod, "EmptyWorkingSet");
    *(void **)&s_pfnEnumProcessModules = GetProcAddress(s_hmod, "EnumProcessModules");
    *(void **)&s_pfnGetModuleBaseName = GetProcAddress(s_hmod, "GetModuleBaseNameW");
    *(void **)&s_pfnGetWsChanges = GetProcAddress(s_hmod, "GetWsChanges");
    *(void **)&s_pfnInitializeProcessForWsWatch = GetProcAddress(s_hmod, "InitializeProcessForWsWatch");

    return S_OK;
}

HRESULT UnLoadPSAPI()
{
    if (!s_hmod)
	{
        return S_OK;
	}

    if (!FreeLibrary(s_hmod))
	{
		RRETURN(E_FAIL);
	}

    s_hmod = NULL;
	s_pfnGetProcessMemoryInfo = NULL;
    s_pfnQueryWorkingSet = NULL;
    s_pfnEmptyWorkingSet = NULL;
    s_pfnEnumProcessModules = NULL;
    s_pfnGetModuleBaseName = NULL;
    s_pfnGetWsChanges = NULL;
    s_pfnInitializeProcessForWsWatch = NULL;

    return S_OK;
}

HRESULT WINAPI
DbgExWsClear(HANDLE hProcess)
{
	HRESULT hr;

    hr = LoadPSAPI();
    if (S_OK != hr)
	{
		// No PSAPI for Win95, so return doing nothing if
		// LoadLibrary fails!
		hr = S_OK;
        goto Cleanup;
	}

    if (!(*s_pfnEmptyWorkingSet)(hProcess))
    {
		hr = E_FAIL;
        goto Cleanup;
    }

    s_cPageEntries = 0;

Cleanup:
	RRETURN(hr);
}

DWORD AddModuleSections(HANDLE hProcess, PVOID pBase, WSPAGEENTRY **ppPE)
{
    BYTE *pifh;
    PIMAGE_SECTION_HEADER pish;
    ULONG i;
    ULONG cSections = 0;

    pifh = (BYTE *)pBase + ((PIMAGE_DOS_HEADER)pBase)->e_lfanew + sizeof(DWORD);
    
    cSections = ((PIMAGE_FILE_HEADER)pifh)->NumberOfSections;
    if (cSections + s_cPageEntries > MAX_PAGE_ENTRIES)
    {
        return cSections;
    }

    pish = (PIMAGE_SECTION_HEADER)(pifh + sizeof(IMAGE_FILE_HEADER) + ((PIMAGE_FILE_HEADER)pifh)->SizeOfOptionalHeader);

    for (i=0; i<cSections; i++, pish++, (*ppPE)++)
    {
        (*ppPE)->addrStart = (DWORD_PTR)pBase + pish->VirtualAddress;
        (*ppPE)->addrEnd = (DWORD_PTR)pBase + pish->VirtualAddress + pish->SizeOfRawData - 1;
        (*s_pfnGetModuleBaseName)(hProcess, (HMODULE)pBase, (*ppPE)->szModule, sizeof((*ppPE)->szModule));
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPCSTR)pish->Name, -1,
                            (LPWSTR)(*ppPE)->szSection,
                            ARRAY_SIZE((*ppPE)->szSection));
        (*ppPE)->dwSize = 0;
    }

    return cSections;
}

HRESULT FillPETable(HANDLE hProcess)
{
	HRESULT hr = S_OK;
    HMODULE ahModule[MAXMODULES];
    ULONG i;
    WSPAGEENTRY *pPE;
    MEMORY_BASIC_INFORMATION mbi;
    DWORD cb;

    if (!(*s_pfnEnumProcessModules)(hProcess, ahModule, sizeof(ahModule), &cb))
    {
	    hr = E_FAIL;
		goto Cleanup;
    }

    for (i = 0, pPE = s_aPE; i < cb / sizeof(HMODULE); i++)
    {
        s_cPageEntries += AddModuleSections(hProcess, (PVOID)ahModule[i], &pPE);

        if (s_cPageEntries > MAX_PAGE_ENTRIES)
        {
		    hr = E_OUTOFMEMORY;
			goto Cleanup;
        }
    }

    if (!VirtualQuery(GetProcessHeap(), &mbi, sizeof(mbi)))
    {
	    hr = E_FAIL;
		goto Cleanup;
    }

    pPE->addrStart = (DWORD_PTR)mbi.BaseAddress;
    pPE->addrEnd = (DWORD_PTR)mbi.BaseAddress + mbi.RegionSize;
    lstrcpy (pPE->szModule, _T("Process Heap"));
    pPE->szSection[0] = 0;
    pPE++->dwSize = 0;
    
    s_cPageEntries++;
    if (s_cPageEntries > MAX_PAGE_ENTRIES)
    {
        hr = E_OUTOFMEMORY;
	    goto Cleanup;
    }

    if (!VirtualQuery(&cb, &mbi, sizeof(mbi)))
    {
	    hr = E_FAIL;
		goto Cleanup;
    }

    pPE->addrStart = (DWORD_PTR)mbi.BaseAddress;
    pPE->addrEnd = (DWORD_PTR)mbi.BaseAddress + mbi.RegionSize;
    lstrcpy (pPE->szModule, _T("Thread Stack"));
    pPE->szSection[0] = 0;
    pPE++->dwSize = 0;

    s_cPageEntries++;
    if (s_cPageEntries > MAX_PAGE_ENTRIES)
    {
        hr = E_OUTOFMEMORY;
	    goto Cleanup;
    }

    pPE->addrStart = 0;
    pPE->addrEnd = 0xFFFFFFFF;
    lstrcpy (pPE->szModule, _T("(Unknown)"));
    pPE->szSection[0] = 0;
    pPE->dwSize = 0;

    s_cPageEntries++;
    if (s_cPageEntries > MAX_PAGE_ENTRIES)
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT WINAPI
DbgExWsTakeSnapshot(HANDLE hProcess)
{
	HRESULT hr = S_OK;
    DWORD i,j;
    WSPAGEINFO *pWSPages = NULL, *pBufHead = NULL;
    PROCESS_MEMORY_COUNTERS psvmctr;
    SYSTEM_INFO si;
    DWORD cPages = 0;

    memset(s_aPE, 0, sizeof(s_aPE));
    s_cPageEntries = 0;

    hr = LoadPSAPI();
    if (S_OK != hr)
	{
		// No PSAPI for Win95, so return doing nothing if
		// LoadLibrary fails!
		hr = S_OK;
        goto Cleanup;
	}

    if (!(*s_pfnGetProcessMemoryInfo)(hProcess, &psvmctr, sizeof(psvmctr)))
    {
	    hr = E_FAIL;
		goto Cleanup;
    }

    GetSystemInfo(&si);
    // Double the buffer size to make sure that QueryWorkingSet always succeeds!
    cPages = (psvmctr.WorkingSetSize / si.dwPageSize)*2 + 1;

    pWSPages = pBufHead = new WSPAGEINFO[cPages];
	if (!pWSPages)
    {
        hr = E_OUTOFMEMORY;
	    goto Cleanup;
    }

    if (!(*s_pfnQueryWorkingSet)(hProcess, pWSPages, cPages * sizeof(WSPAGEINFO)))
    {
	    hr = E_FAIL;
		goto Cleanup;
    }

    hr = FillPETable(hProcess);
	if (S_OK != hr)
    {
	    goto Cleanup;
    }
    
    cPages = *((DWORD *)pWSPages++);
    for (i=0; i<cPages; i++, pWSPages++)
    {
        for (j=0; j<s_cPageEntries; j++)
        {
            if ((*(DWORD *)pWSPages & 0xFFFFF000) >= s_aPE[j].addrStart && (*(DWORD*)pWSPages & 0xFFFFF000) <= s_aPE[j].addrEnd)
            {
                s_aPE[j].dwSize += si.dwPageSize;
                break;
            }
        }
    }

Cleanup:
    delete pBufHead;
    RRETURN(hr);
}

BSTR WINAPI
DbgExWsGetModule(long row)
{
    if (row >= 0 && (DWORD)row < s_cPageEntries)
        return (BSTR)s_aPE[row].szModule;
    else
        return NULL;
}

BSTR WINAPI
DbgExWsGetSection(long row)
{
    if (row >= 0 && (DWORD)row < s_cPageEntries)
        return (BSTR)s_aPE[row].szSection;
    else
        return NULL;
}

HRESULT WINAPI
DbgExWsStartDelta(HANDLE hProcess)
{
	HRESULT hr;

    hr = LoadPSAPI();
    if (S_OK != hr)
	{
		// No PSAPI for Win95, so return doing nothing if
		// LoadLibrary fails!
		hr = S_OK;
        goto Cleanup;
	}

    if (!(*s_pfnInitializeProcessForWsWatch)(hProcess))
    {
		hr = E_FAIL;
        goto Cleanup;
    }

    // clear all WS changes till before the call to DbgExWsStartDelta
    (*s_pfnGetWsChanges)(hProcess, s_aWsChanges, sizeof(s_aWsChanges));
    s_bWsDeltaStarted = TRUE;

Cleanup:
	RRETURN(hr);
}

long WINAPI
DbgExWsEndDelta(HANDLE hProcess)
{
    long nPageFaults = -1;
    PPSAPI_WS_WATCH_INFORMATION pWsChanges = s_aWsChanges;

    if (s_bWsDeltaStarted)
    {
        (*s_pfnGetWsChanges)(hProcess, s_aWsChanges, sizeof(s_aWsChanges));
        if (s_aWsChanges[MAX_WS_DELTA_PAGES-1].FaultingPc)
        {
            nPageFaults = MAX_WS_DELTA_PAGES;
        }
        else
        {
            while (pWsChanges->FaultingPc || pWsChanges->FaultingVa)
            {
                pWsChanges++;
            }
            
            nPageFaults = pWsChanges - s_aWsChanges;
        }

        s_bWsDeltaStarted = FALSE;
    }

    return nPageFaults;
}

long WINAPI
DbgExWsSize(long row)
{
    if (row >= 0 && (DWORD)row < s_cPageEntries)
        return (long)s_aPE[row].dwSize;
    else
        return 0;
}

long WINAPI
DbgExWsCount()
{
    return (long)s_cPageEntries;
}

long WINAPI
DbgExWsTotal()
{
    DWORD i;
    long total = 0;
    
    for (i=0; i<s_cPageEntries; i++)
    {
        total += (long)s_aPE[i].dwSize;
    }

    return total;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\dlc\typenav.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:       typenav.cxx
//
//  Contents:   Navigates an IDispatch's ITypeInfo.
//
//  Classes:    Priv
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TYPENAV_HXX_
#define X_TYPENAV_HXX_
#include "typenav.hxx"
#endif

DeclareTag(tagCTypeInfoNav, "CTypeInfoNav", "CTypeInfoNav methods");


CTypeInfoNav::CTypeInfoNav () :
      _pTI(0),
      _wVarCount(0),
      _wFuncCount(0),
      _uIndex(~0U),                      // Signal to Next() need to preload 1
      _wVarFlagsFilter(0),
      _fFuncDesc(FALSE),
      _pVD(0),
      _dispid(DISPID_UNKNOWN)
{
    TraceTag((tagCTypeInfoNav, "CTypeInfoNav::CTypeInfoNav() -> %p", this));
}


CTypeInfoNav::~CTypeInfoNav ()
{
    TraceTag((tagCTypeInfoNav, "CTypeInfoNav::~CTypeInfoNav() -> %p", this));

    //
    // Release the ITypeInfo and VARDESC or FUNCDESC pointers.
    //
    if (_pVD)
    {
        Assert(_pTI);
        if (_fFuncDesc)
            _pTI->ReleaseFuncDesc(_pFD);
        else
            _pTI->ReleaseVarDesc(_pVD);
    }

    ReleaseInterface(_pTI);
}


//+---------------------------------------------------------------------------
//
//  Function:   InitIDispatch
//
//  Synopsis:   Queries for an IDispatch to digout the ITypeInfo interface
//              and remember the actual number of entries in ITypeInfo for
//              iterating later.
//
//  Arguments:  [pUnk]      -- The interface which supports IDispatch.
//              [pITypeInfo]-- Returns an AddRef'd ITypeInfo if the pointer
//                             is not 0.
//              [wVFFilter] -- Variable or function filter to match (if zero
//                             then all properties are used).
//              [dispid]    -- dispid to match (if DISPID_UNKNOWN then look at
//                             each entry).
//
//  Returns:    HRESULT
//                  E_NOINTERFACE   - if pUnk doesn't support IID_Dispatch and
//                                    ITypeInfo.
//                  E_nnnn          - any HRESULT from:
//                                          QueryInterface,
//                                          IDispatch::GetTypeInfo
//                                          ITypeInfo::GetTypeAttr
//                  S_OK            - success.
//
//  Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT
CTypeInfoNav::InitIDispatch (IUnknown * pUnk,
                             ITypeInfo ** pITypeInfo,
                             WORD wVFFilter,
                             DISPID dispid)
{
    TraceTag((tagCTypeInfoNav,
              "CTypeInfoNav::InitIDispatch(%p, %p, %l, %l) -> %p",
              pUnk, pITypeInfo, wVFFilter, dispid, this));

    HRESULT     hr;
    IDispatch * pDisp = 0;

    Assert(pUnk);

    // Get typeinfo of control.
    hr = pUnk->QueryInterface(IID_IDispatch, (void **)&pDisp);
    if (hr)
        goto Cleanup;

    hr = InitIDispatch(pDisp, pITypeInfo, wVFFilter, dispid);

Cleanup:
    ReleaseInterface(pDisp);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   InitIDispatch
//
//  Synopsis:   Queries for an IDispatch to digout the ITypeInfo interface
//              and remember the actual number of entries in ITypeInfo for
//              iterating later.
//
//  Arguments:  [pDispatch] -- The IDispatch interface typeinfo to traverse.
//              [pITypeInfo]-- Returns an AddRef'd ITypeInfo if the pointer
//                             is not 0.
//              [wVFFilter] -- Variable or function filter to match (if zero
//                             then all properties are used).
//              [dispid]    -- dispid to match (if DISPID_UNKNOWN then look at
//                             each entry).
//
//  Returns:    HRESULT
//                  E_NOINTERFACE   - if pUnk doesn't support IID_Dispatch and
//                                    ITypeInfo.
//                  E_nnnn          - any HRESULT from:
//                                          QueryInterface,
//                                          IDispatch::GetTypeInfo
//                                          ITypeInfo::GetTypeAttr
//                  S_OK            - success.
//
//  Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT
CTypeInfoNav::InitIDispatch (IDispatch * pDisp,
                             ITypeInfo ** ppTypeInfo,
                             WORD wVFFilter,
                             DISPID dispid)
{
    TraceTag((tagCTypeInfoNav,
              "CTypeInfoNav::InitIDispatch(%p, %p, %l, %l) -> %p",
              pDisp, ppTypeInfo, wVFFilter, dispid, this));

    HRESULT     hr;

    Assert(pDisp);

    // Get typeinfo of control.
    hr = pDisp->GetTypeInfo(0, g_lcidUserDefault, &_pTI);
    if (hr)
        goto Cleanup;

    hr = InitITypeInfo(ppTypeInfo ? _pTI : 0, wVFFilter, dispid);

Cleanup:
    // We need to addref the ITypeInfo we're returning, InitITypeInfo
    // will do the addref for the copy we're returning.  GetTypeInfo
    // did the addref for the _pTI we're holding on to.
    if (ppTypeInfo)
    {
        *ppTypeInfo = hr ? NULL : _pTI;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   InitITypeInfo
//
//  Synopsis:   Given an ITypeInfo interface remember this ITypeInfo interface
//              and the actual number of entries in ITypeInfo for iteration.
//
//  Arguments:  [pTypeInfo] -- ITypeInfo.
//              [wVFFilter] -- Variable or function filter to match (if zero
//                             then all properties are used).
//              [dispid]    -- dispid to match (if DISPID_UNKNOWN then look at
//                             each entry).
//
//  Returns:    HRESULT
//                  E_POINTER   - if pTypeInfo is 0.
//                  E_nnnn      - any HRESULT from ITypeInfo::GetTypeAttr
//                  S_OK        - success.
//
//  Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT
CTypeInfoNav::InitITypeInfo (ITypeInfo * pTypeInfo,
                             WORD wVFFilter,
                             DISPID dispid)
{
    TraceTag((tagCTypeInfoNav,
              "CTypeInfoNav::InitITypeInfo(%p, %l, %l) -> %p",
              pTypeInfo, wVFFilter, dispid, this));

    HRESULT     hr;
    TYPEATTR *  pTA;

    Assert((pTypeInfo == 0 && _pTI) || pTypeInfo);

    _dispid = dispid;

    if (pTypeInfo)
    {
        _pTI = pTypeInfo;
        _pTI->AddRef();
    }

    hr = _pTI->GetTypeAttr(&pTA);
    Assert(!hr);
    if (!hr)
    {
        _wVarCount = pTA->cVars;
        _wFuncCount = pTA->cFuncs;
        
        _fIsDual = ((pTA->wTypeFlags & TYPEFLAG_FDUAL) != 0);

        _pTI->ReleaseTypeAttr(pTA);

        _wVarFlagsFilter = wVFFilter;
    }

    RRETURN(hr);
}



#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   DbgUserDefined
//
//  Synopsis:   Internal debugging code, for a property in the typelib traverse
//              the property type looking for a user defined type.
//
//  Arguments:  None
//
//  Returns:    None
//
//  Modifies:   Nothing
//
//----------------------------------------------------------------------------
void
CTypeInfoNav::DbgUserDefined ()
{
    HRESULT hr;

    // If the tag is on then output additional information.
    if (IsTagEnabled(tagCTypeInfoNav))
    {
        OutputDebugString(_T("Property Name = "));

        BSTR bstr = NULL;
        UINT cNames;
        _pTI->GetNames(_fFuncDesc ? _pFD->memid : _pVD->memid,
                       &bstr, 1, &cNames);
#ifndef _MACUNICODE
        OutputDebugString(bstr);
#else
        {
            CStr str;
            str.Set(bstr);
            OutputDebugString(str);
        }
#endif
        OutputDebugString(_T("\r\n"));

        FormsFreeString(bstr);

        if (_fFuncDesc)
        {
            if (_pFD->lprgelemdescParam)
            {
                if (_pFD->lprgelemdescParam->tdesc.vt == VT_USERDEFINED)
                {
                    HREFTYPE hreftype = 
                               _pFD->lprgelemdescParam->tdesc.hreftype;

                    ITypeInfo * pUserTI;
                    hr = _pTI->GetRefTypeInfo(hreftype, &pUserTI);
                    if (!hr)
                    {
                        TYPEATTR *pTypeAttr;
                        hr = pUserTI->GetTypeAttr(&pTypeAttr);
                        if (!hr)
                        {
                            OutputDebugString(
                                           _T("User define type\r\n") );
                            pUserTI->ReleaseTypeAttr(pTypeAttr);
                        }
                        ReleaseInterface(pUserTI);
                    }
                }
            }
        }
    }
}
#endif



//+---------------------------------------------------------------------------
//
//  Function:   Next
//
//  Synopsis:   Iterates through an ITypeInfo libraries looking only at
//              VAR_DISPATCH entries which match the _wVarFlagsFilter.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//                  E_POINTER           - if _pTINav or pTI are undefined (NULL)
//                  E_nnnn              - any HRESULT from ITypeInfo::GetVarDesc
//                  S_OK                - success
//                  S_FALSE             - No more items to iterate over
//
//  Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT
CTypeInfoNav::Next ()
{
    TraceTag((tagCTypeInfoNav, "CTypeInfoNav::Next() -> %p", this));

    HRESULT     hr = S_OK;
    WORD        wCount = _fIsDual ? _wFuncCount : _wFuncCount + _wVarCount;

    Assert(_pTI);

    while (++_uIndex < wCount)
    {
        // No, get the next one.

        UINT uIndex;        // index within current type (funcs or vars)

        // release the previous result
        if (_pVD)
        {
            if (_fFuncDesc)
                _pTI->ReleaseFuncDesc(_pFD);
            else
                _pTI->ReleaseVarDesc(_pVD);
            _pVD = 0;
        }

        // Get the description of the IDispatched variable.
        _fFuncDesc = (_uIndex < _wFuncCount);
        uIndex = _fFuncDesc ? _uIndex : (_uIndex - _wFuncCount);

        hr = _fFuncDesc ? _pTI->GetFuncDesc(uIndex, &_pFD) :
                          _pTI->GetVarDesc(uIndex, &_pVD);
        if (!hr)
        {
            TraceTag((tagCTypeInfoNav,
                     "  Next: dispid = %p; wVarFlags = %p -> %p",
                     _fFuncDesc ? _pFD->memid : _pVD->memid,
                     _fFuncDesc ? _pFD->wFuncFlags : _pVD->wVarFlags,
                     this));

#if DBG == 1
            DbgUserDefined();
#endif

            //
            // Can this variable only be accessed via IDispatch::Invoke?
            //
            if (_fFuncDesc ?
                ((_pFD->funckind == FUNC_DISPATCH) || (_pFD->funckind == FUNC_PUREVIRTUAL)) :
                (_pVD->varkind == VAR_DISPATCH))
            {
                DISPID dispid = _fFuncDesc ? _pFD->memid : _pVD->memid;

                // Are we trying to match to a particular dispid or if we found
                // the particular dispid then look at the filter.
                if ((_dispid == DISPID_UNKNOWN) || (_dispid == dispid))
                {
                    //
                    // If we have filters to check, then make sure the
                    // currentwVarFlags matches the filter before we say
                    // it's a match.
                    //
                    WORD wFlags = _fFuncDesc ? _pFD->wFuncFlags :
                                               _pVD->wVarFlags;
                    if (!_wVarFlagsFilter ||
                        (_wVarFlagsFilter & wFlags) == _wVarFlagsFilter)
                        break;
                }
            }            
        } else
            break;
    }      // end while loop

    //
    // If the internal index is larger than Count() then return
    // S_FALSE to signal there are no more entries to iterate over
    // or if we had an error then just the current error value in hr otherwise
    // we succeeded so return S_OK.
    //
    if (!hr)
        hr = (_uIndex >= wCount) ? S_FALSE : S_OK;

    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\coredisp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __COREDISP_H__
#define __COREDISP_H__
//;end_internal

//;begin_internal
//
// The following dispid must be the smallest possible dispid so that it
// always ends up first in our attr array.
// It does not need to be exposed to the outside world
#define DISPID_AAHEADER                 MINLONG             // DISPID is 0x80000000
#define DISPID_RECALC_INFO              MINLONG+1
//;end_internal


#define DISPID_XOBJ_MIN                 0x80010000
#define DISPID_XOBJ_MAX                 0x8001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN
#define DISPID_HTMLOBJECT               (DISPID_XOBJ_BASE   + 500)
#define DISPID_ELEMENT                  (DISPID_HTMLOBJECT  + 500)
#define DISPID_SITE                     (DISPID_ELEMENT     + 1000)
#define DISPID_OBJECT                   (DISPID_SITE        + 1000)
#define DISPID_STYLE                    (DISPID_OBJECT      + 1000)
#define DISPID_ATTRS                    (DISPID_STYLE       + 1000)
#define DISPID_EVENTS                   (DISPID_ATTRS       + 1000)
#define DISPID_XOBJ_EXPANDO             (DISPID_EVENTS      + 1000)
#define DISPID_XOBJ_ORDINAL             (DISPID_XOBJ_EXPANDO+ 1000)

//;begin_internal
// Expandos for ActiveX controls, note these are very limited compared to
// normal expandos on an element.

#define DISPID_ACTIVEX_EXPANDO_BASE      DISPID_XOBJ_EXPANDO
#define DISPID_ACTIVEX_EXPANDO_MAX       (DISPID_ACTIVEX_EXPANDO_BASE + 999)

#define DISPID_OBJECT_ORDINAL_BASE       DISPID_XOBJ_ORDINAL
#define DISPID_OBJECT_ORDINAL_MAX       (DISPID_OBJECT_ORDINAL_BASE + 999)

#define DISPID_COLLECTION_MIN           1000000
#define DISPID_COLLECTION_MAX           2999999

// Divide collection dispid space into "named member" half and "ordinal access" half
// for stylesheets collection.
#define DISPID_STYLESHEETSCOLLECTION_NAMED_BASE        (DISPID_COLLECTION_MIN)
#define DISPID_STYLESHEETSCOLLECTION_NAMED_MAX         (DISPID_COLLECTION_MIN+((DISPID_COLLECTION_MAX-DISPID_COLLECTION_MIN)/2))
#define DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE      (DISPID_STYLESHEETSCOLLECTION_NAMED_MAX+1)
#define DISPID_STYLESHEETSCOLLECTION_ORDINAL_MAX       (DISPID_COLLECTION_MAX)

// DISPID range for expandos not associated with an ActiveX control
#define DISPID_EXPANDO_BASE             3000000
#define DISPID_EXPANDO_MAX              3999999

#define IsStandardDispid(dispid)        (dispid <= 0)
#define IsExpandoDispid(dispid)         (DISPID_EXPANDO_BASE <= dispid && dispid <= DISPID_EXPANDO_MAX)

#define DISPID_EVENTHOOK_SENSITIVE_BASE   4000000
#define DISPID_EVENTHOOK_SENSITIVE_MAX    4499999
#define DISPID_EVENTHOOK_INSENSITIVE_BASE 4500000
#define DISPID_EVENTHOOK_INSENSITIVE_MAX  4999999

#define DISPID_PEER_HOLDER_BASE         5000000

#define IsPeerDispid(dispid)            (DISPID_PEER_HOLDER_BASE <= dispid)

//;end_internal

//;begin_internal
//
// IE 4 dispids that no longer exist
//
//;end_internal
#define DISPID_HTMLOPTIONBUTTONELEMENTEVENTS_ONCHANGE       DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONCHANGE

//;begin_internal
//
// Standard control properties
//
//;end_internal

//;begin_internal
//;QUESTION: rgardner - why do we use these names ???
//;end_internal
#define DISPID_CommonCtrl_FONTNAME        1
#define DISPID_CommonCtrl_FONTSIZE        2
#define DISPID_CommonCtrl_FONTBOLD        3
#define DISPID_CommonCtrl_FONTITAL        4
#define DISPID_CommonCtrl_FONTUNDER       5
#define DISPID_CommonCtrl_FONTSTRIKE      6
#define DISPID_CommonCtrl_FONTWEIGHT      7
#define DISPID_CommonCtrl_FONTCHARSET     8
#define DISPID_CommonCtrl_FONTSUPERSCRIPT 9
#define DISPID_CommonCtrl_FONTSUBSCRIPT   10

// Data Binding DISPID's
#define DISPID_MSDATASRCINTERFACE       (-3900)
#define DISPID_ADVISEDATASRCCHANGEEVENT (-3901)


//;begin_internal
// DISPID values for HTML Dialogs files per interface
//;end_internal

#define DISPID_HTMLDLG                          25000
#define DISPID_HTMLDLGMODEL                     26000

//;begin_internal
// DISPID values for HTML Popup files per interface
//;end_internal

#define DISPID_HTMLPOPUP                        27000

//;begin_internal
// DISPID values for HTML Application files per interface
//;end_internal

#define DISPID_HTMLAPP                          5000

//;begin_internal
//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These values match those used by VB and are for the benefit of controls
//  with hard coded knowledge of VB.
//
//----------------------------------------------------------------------------
//;end_internal

#define STDPROPID_XOBJ_NAME                 (DISPID_XOBJ_BASE + 0x0)
#define STDPROPID_XOBJ_INDEX                (DISPID_XOBJ_BASE + 0x1)
//;begin_internal
// for IE3 compatibility

#define STDPROPID_IE3XOBJ_OBJECTALIGN     (DISPID_XOBJ_BASE + 0x1) 

// STDPROPID_XOBJ_BASEHREF is a constant used by IE3
//;end_internal
#define STDPROPID_XOBJ_BASEHREF             (DISPID_XOBJ_BASE + 0x2) 
#define STDPROPID_XOBJ_LEFT                 (DISPID_XOBJ_BASE + 0x3)
#define STDPROPID_XOBJ_TOP                  (DISPID_XOBJ_BASE + 0x4)
#define STDPROPID_XOBJ_WIDTH                (DISPID_XOBJ_BASE + 0x5)
#define STDPROPID_XOBJ_HEIGHT               (DISPID_XOBJ_BASE + 0x6)
#define STDPROPID_XOBJ_VISIBLE              (DISPID_XOBJ_BASE + 0x7)
#define STDPROPID_XOBJ_PARENT               (DISPID_XOBJ_BASE + 0x8)
#define STDPROPID_XOBJ_DRAGMODE             (DISPID_XOBJ_BASE + 0x9)
#define STDPROPID_XOBJ_DRAGICON             (DISPID_XOBJ_BASE + 0xA)
#define STDPROPID_XOBJ_TAG                  (DISPID_XOBJ_BASE + 0xB)
#define STDPROPID_XOBJ_TABSTOP              (DISPID_XOBJ_BASE + 0xE)
#define STDPROPID_XOBJ_TABINDEX             (DISPID_XOBJ_BASE + 0xF)
#define STDPROPID_XOBJ_HELPCONTEXTID        (DISPID_XOBJ_BASE + 0x32)
#define STDPROPID_XOBJ_DEFAULT              (DISPID_XOBJ_BASE + 0x37)
#define STDPROPID_XOBJ_CANCEL               (DISPID_XOBJ_BASE + 0x38)
#define STDPROPID_XOBJ_LEFTNORUN            (DISPID_XOBJ_BASE + 0x39)
#define STDPROPID_XOBJ_TOPNORUN             (DISPID_XOBJ_BASE + 0x3A)
#define STDPROPID_XOBJ_ALIGNPERSIST         (DISPID_XOBJ_BASE + 0x3C)
#define STDPROPID_XOBJ_LINKTIMEOUT          (DISPID_XOBJ_BASE + 0x3D)
#define STDPROPID_XOBJ_LINKTOPIC            (DISPID_XOBJ_BASE + 0x3E)
#define STDPROPID_XOBJ_LINKITEM             (DISPID_XOBJ_BASE + 0x3F)
#define STDPROPID_XOBJ_LINKMODE             (DISPID_XOBJ_BASE + 0x40)
#define STDPROPID_XOBJ_DATACHANGED          (DISPID_XOBJ_BASE + 0x41)
#define STDPROPID_XOBJ_DATAFIELD            (DISPID_XOBJ_BASE + 0x42)
#define STDPROPID_XOBJ_DATASOURCE           (DISPID_XOBJ_BASE + 0x43)
#define STDPROPID_XOBJ_WHATSTHISHELPID      (DISPID_XOBJ_BASE + 0x44)
#define STDPROPID_XOBJ_CONTROLTIPTEXT       (DISPID_XOBJ_BASE + 0x45)
#define STDPROPID_XOBJ_STATUSBARTEXT        (DISPID_XOBJ_BASE + 0x46)
#define STDPROPID_XOBJ_APPLICATION          (DISPID_XOBJ_BASE + 0x47)
#define STDPROPID_XOBJ_BLOCKALIGN           (DISPID_XOBJ_BASE + 0x48)
#define STDPROPID_XOBJ_CONTROLALIGN         (DISPID_XOBJ_BASE + 0x49)
#define STDPROPID_XOBJ_STYLE                (DISPID_XOBJ_BASE + 0x4A)
#define STDPROPID_XOBJ_COUNT                (DISPID_XOBJ_BASE + 0x4B)
#define STDPROPID_XOBJ_DISABLED             (DISPID_XOBJ_BASE + 0x4C)
#define STDPROPID_XOBJ_RIGHT                (DISPID_XOBJ_BASE + 0x4D)
#define STDPROPID_XOBJ_BOTTOM               (DISPID_XOBJ_BASE + 0x4E)

//;begin_internal
//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These are events that are fired for all sites
//----------------------------------------------------------------------------
//;end_internal

#define STDDISPID_XOBJ_ONBLUR                           (DISPID_XOBJ_BASE)
#define STDDISPID_XOBJ_ONFOCUS                          (DISPID_XOBJ_BASE + 1)
#define STDDISPID_XOBJ_BEFOREUPDATE                     (DISPID_XOBJ_BASE + 4)
#define STDDISPID_XOBJ_AFTERUPDATE                      (DISPID_XOBJ_BASE + 5)
#define STDDISPID_XOBJ_ONROWEXIT                        (DISPID_XOBJ_BASE + 6)
#define STDDISPID_XOBJ_ONROWENTER                       (DISPID_XOBJ_BASE + 7)
#define STDDISPID_XOBJ_ONMOUSEOVER                      (DISPID_XOBJ_BASE + 8)
#define STDDISPID_XOBJ_ONMOUSEOUT                       (DISPID_XOBJ_BASE + 9)
#define STDDISPID_XOBJ_ONHELP                           (DISPID_XOBJ_BASE + 10)
#define STDDISPID_XOBJ_ONDRAGSTART                      (DISPID_XOBJ_BASE + 11)
#define STDDISPID_XOBJ_ONSELECTSTART                    (DISPID_XOBJ_BASE + 12)
#define STDDISPID_XOBJ_ERRORUPDATE                      (DISPID_XOBJ_BASE + 13)
#define STDDISPID_XOBJ_ONDATASETCHANGED                 (DISPID_XOBJ_BASE + 14)
#define STDDISPID_XOBJ_ONDATAAVAILABLE                  (DISPID_XOBJ_BASE + 15)
#define STDDISPID_XOBJ_ONDATASETCOMPLETE                (DISPID_XOBJ_BASE + 16)
#define STDDISPID_XOBJ_ONFILTER                         (DISPID_XOBJ_BASE + 17)
#define STDDISPID_XOBJ_ONLOSECAPTURE                    (DISPID_XOBJ_BASE + 18)
#define STDDISPID_XOBJ_ONPROPERTYCHANGE                 (DISPID_XOBJ_BASE + 19)
#define STDDISPID_XOBJ_ONDRAG                           (DISPID_XOBJ_BASE + 20)
#define STDDISPID_XOBJ_ONDRAGEND                        (DISPID_XOBJ_BASE + 21)
#define STDDISPID_XOBJ_ONDRAGENTER                      (DISPID_XOBJ_BASE + 22)
#define STDDISPID_XOBJ_ONDRAGOVER                       (DISPID_XOBJ_BASE + 23)
#define STDDISPID_XOBJ_ONDRAGLEAVE                      (DISPID_XOBJ_BASE + 24)
#define STDDISPID_XOBJ_ONDROP                           (DISPID_XOBJ_BASE + 25)
#define STDDISPID_XOBJ_ONCUT                            (DISPID_XOBJ_BASE + 26)
#define STDDISPID_XOBJ_ONCOPY                           (DISPID_XOBJ_BASE + 27)
#define STDDISPID_XOBJ_ONPASTE                          (DISPID_XOBJ_BASE + 28)
#define STDDISPID_XOBJ_ONBEFORECUT                      (DISPID_XOBJ_BASE + 29)
#define STDDISPID_XOBJ_ONBEFORECOPY                     (DISPID_XOBJ_BASE + 30)
#define STDDISPID_XOBJ_ONBEFOREPASTE                    (DISPID_XOBJ_BASE + 31)
#define STDDISPID_XOBJ_ONROWSDELETE                     (DISPID_XOBJ_BASE + 32)
#define STDDISPID_XOBJ_ONROWSINSERTED                   (DISPID_XOBJ_BASE + 33)
#define STDDISPID_XOBJ_ONCELLCHANGE                     (DISPID_XOBJ_BASE + 34)

//;begin_internal
//----------------------------------------------------------------------------
//
//  Base DISPIDs for each class.
//
//  Object and its base classes must use ids in the reserved x-object range.
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_NORMAL_FIRST                     1000
#define DISPID_ANCHOR                           DISPID_NORMAL_FIRST
#define DISPID_BLOCK                            DISPID_NORMAL_FIRST
#define DISPID_BODY                             (DISPID_TEXTSITE + 1000)
#define DISPID_BR                               DISPID_NORMAL_FIRST
#define DISPID_BGSOUND                          DISPID_NORMAL_FIRST
#define DISPID_DD                               DISPID_NORMAL_FIRST
#define DISPID_DIR                              DISPID_NORMAL_FIRST
#define DISPID_DIV                              DISPID_NORMAL_FIRST
#define DISPID_DL                               DISPID_NORMAL_FIRST
#define DISPID_DT                               DISPID_NORMAL_FIRST
#define DISPID_EFONT                            DISPID_NORMAL_FIRST
#define DISPID_FORM                             DISPID_NORMAL_FIRST
#define DISPID_HEADER                           DISPID_NORMAL_FIRST
#define DISPID_HEDELEMS                         DISPID_NORMAL_FIRST
#define DISPID_HR                               DISPID_NORMAL_FIRST
#define DISPID_LABEL                            DISPID_NORMAL_FIRST
#define DISPID_LI                               DISPID_NORMAL_FIRST
#define DISPID_IMGBASE                          DISPID_NORMAL_FIRST
#define DISPID_IMG                              (DISPID_IMGBASE + 1000)
#define DISPID_INPUTIMAGE                       (DISPID_IMGBASE + 1000)
#define DISPID_INPUT                            (DISPID_TEXTSITE + 1000)
#define DISPID_INPUTTEXTBASE                    (DISPID_INPUT+1000)
#define DISPID_INPUTTEXT                        (DISPID_INPUTTEXTBASE+1000)
#define DISPID_MENU                             DISPID_NORMAL_FIRST
#define DISPID_OL                               DISPID_NORMAL_FIRST
#define DISPID_PARA                             DISPID_NORMAL_FIRST
#define DISPID_SELECT                           DISPID_NORMAL_FIRST
#define DISPID_SELECTOBJ                        DISPID_NORMAL_FIRST
#define DISPID_TABLE                            DISPID_NORMAL_FIRST
#define DISPID_TEXTSITE                         DISPID_NORMAL_FIRST
#define DISPID_TEXTAREA                         (DISPID_INPUTTEXT + 1000)
#define DISPID_MARQUEE                          (DISPID_TEXTAREA + 1000)
#define DISPID_RICHTEXT                         (DISPID_MARQUEE + 1000)
#define DISPID_BUTTON                           (DISPID_RICHTEXT + 1000)
#define DISPID_UL                               DISPID_NORMAL_FIRST
#define DISPID_PHRASE                           DISPID_NORMAL_FIRST
#define DISPID_UNKNOWNPDL                       DISPID_NORMAL_FIRST
#define DISPID_COMMENTPDL                       DISPID_NORMAL_FIRST
#define DISPID_TABLECELL                        (DISPID_TEXTSITE + 1000)
#define DISPID_RANGE                            DISPID_NORMAL_FIRST
#define DISPID_SELECTION                        DISPID_NORMAL_FIRST
#define DISPID_OPTION                           DISPID_NORMAL_FIRST
#define DISPID_1D                               (DISPID_TEXTSITE + 1000)
#define DISPID_MAP                              DISPID_NORMAL_FIRST
#define DISPID_AREA                             DISPID_NORMAL_FIRST
#define DISPID_PARAM                            DISPID_NORMAL_FIRST
#define DISPID_TABLESECTION                     DISPID_NORMAL_FIRST
#define DISPID_TABLEROW                         DISPID_NORMAL_FIRST
#define DISPID_TABLECOL                         DISPID_NORMAL_FIRST
#define DISPID_SCRIPT                           DISPID_NORMAL_FIRST
#define DISPID_STYLESHEET                       DISPID_NORMAL_FIRST
#define DISPID_STYLERULE                        DISPID_NORMAL_FIRST
#define DISPID_STYLEPAGE                        DISPID_NORMAL_FIRST
#define DISPID_STYLESHEETS_COL                  DISPID_NORMAL_FIRST
#define DISPID_STYLERULES_COL                   DISPID_NORMAL_FIRST
#define DISPID_STYLEPAGES_COL                   DISPID_NORMAL_FIRST
#define DISPID_MIMETYPES_COL                    DISPID_NORMAL_FIRST
#define DISPID_PLUGINS_COL                      DISPID_NORMAL_FIRST
#define DISPID_2D                               DISPID_NORMAL_FIRST
#define DISPID_OMWINDOW                         DISPID_NORMAL_FIRST
#define DISPID_EVENTOBJ                         DISPID_NORMAL_FIRST
#define DISPID_PERSISTDATA                      DISPID_NORMAL_FIRST
#define DISPID_OLESITE                          DISPID_NORMAL_FIRST
#define DISPID_FRAMESET                         DISPID_NORMAL_FIRST
#define DISPID_LINK                             DISPID_NORMAL_FIRST
#define DISPID_STYLEELEMENT                     DISPID_NORMAL_FIRST
#define DISPID_FILTERS                          DISPID_NORMAL_FIRST
#define DISPID_TABLESECTION                     DISPID_NORMAL_FIRST
#define DISPID_OMRECT                           DISPID_NORMAL_FIRST
#define DISPID_DOMATTRIBUTE                     DISPID_NORMAL_FIRST
#define DISPID_DOMTEXTNODE                      DISPID_NORMAL_FIRST
#define DISPID_GENERIC                          DISPID_NORMAL_FIRST
#define DISPID_URN_COLL                         DISPID_NORMAL_FIRST
#define DISPID_NAMESPACE_COLLECTION             DISPID_NORMAL_FIRST
#define DISPID_NAMESPACE                        DISPID_NORMAL_FIRST
#define DISPID_TAGNAMES_COLLECTION              DISPID_NORMAL_FIRST

#define DISPID_HTMLDOCUMENT                     DISPID_NORMAL_FIRST
#define DISPID_OMDOCUMENT                       DISPID_NORMAL_FIRST
#define DISPID_DATATRANSFER                     DISPID_NORMAL_FIRST
#define DISPID_XMLDECL                          DISPID_NORMAL_FIRST
#define DISPID_DOCFRAG                          DISPID_NORMAL_FIRST
#define DISPID_ILINEINFO                        DISPID_NORMAL_FIRST
#define DISPID_IHTMLCOMPUTEDSTYLE               DISPID_NORMAL_FIRST
//;begin_internal
    // Special case for compatability with IE4 -> therefore the 1:
//;end_internal
#define DISPID_WINDOW                           1
#define DISPID_SCREEN                           DISPID_NORMAL_FIRST
#define DISPID_FRAMESCOLLECTION                 DISPID_NORMAL_FIRST
#define DISPID_HISTORY                          1
#define DISPID_LOCATION                         1
#define DISPID_NAVIGATOR                        1
#define DISPID_COLLECTION                       (DISPID_NORMAL_FIRST+500)
#define DISPID_OPTIONS_COL                      (DISPID_NORMAL_FIRST+500)

#define DISPID_CHECKBOX                         DISPID_NORMAL_FIRST
#define DISPID_RADIO                            (DISPID_CHECKBOX + 1000)

#define DISPID_FRAMESITE                        (DISPID_SITE        + 1000)
#define DISPID_FRAME                            (DISPID_FRAMESITE   + 1000)
#define DISPID_IFRAME                           (DISPID_FRAMESITE   + 1000)

#define WEBOC_DISPIDBASE                        (DISPID_FRAMESITE   + 2000)
#define WEBOC_DISPIDMAX                         (WEBOC_DISPIDBASE   +  100)

#define DISPID_PROTECTEDELEMENT                 DISPID_NORMAL_FIRST
#define DISPID_DEFAULTS                         DISPID_NORMAL_FIRST
#define DISPID_MARKUP                           DISPID_NORMAL_FIRST
#define DISPID_DOMIMPLEMENTATION                DISPID_NORMAL_FIRST

//;begin_internal
//----------------------------------------------------------------------------
//
//  Reserved negative DISPIDs
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_WINDOWOBJECT                     (-5500)
#define DISPID_LOCATIONOBJECT                   (-5506)
#define DISPID_HISTORYOBJECT                    (-5507)
#define DISPID_NAVIGATOROBJECT                  (-5508)
#define DISPID_SECURITYCTX                      (-5511)
#define DISPID_AMBIENT_DLCONTROL                (-5512)
#define DISPID_AMBIENT_USERAGENT                (-5513)
#define DISPID_SECURITYDOMAIN                   (-5514)
//;begin_internal
#define DISPID_DEBUG_ISSECUREPROXY              (-5515)
#define DISPID_DEBUG_TRUSTEDPROXY               (-5516)
#define DISPID_DEBUG_INTERNALWINDOW             (-5517)
#define DISPID_DEBUG_ENABLESECUREPROXYASSERTS   (-5518)
//;end_internal
#define DLCTL_DLIMAGES                          0x00000010
#define DLCTL_VIDEOS                            0x00000020
#define DLCTL_BGSOUNDS                          0x00000040
#define DLCTL_NO_SCRIPTS                        0x00000080
#define DLCTL_NO_JAVA                           0x00000100
#define DLCTL_NO_RUNACTIVEXCTLS                 0x00000200
#define DLCTL_NO_DLACTIVEXCTLS                  0x00000400
#define DLCTL_DOWNLOADONLY                      0x00000800
#define DLCTL_NO_FRAMEDOWNLOAD                  0x00001000
#define DLCTL_RESYNCHRONIZE                     0x00002000
#define DLCTL_PRAGMA_NO_CACHE                   0x00004000
#define DLCTL_NO_BEHAVIORS                      0x00008000
#define DLCTL_NO_METACHARSET                    0x00010000
#define DLCTL_URL_ENCODING_DISABLE_UTF8         0x00020000
#define DLCTL_URL_ENCODING_ENABLE_UTF8          0x00040000
#define DLCTL_NOFRAMES                          0x00080000
#define DLCTL_FORCEOFFLINE                      0x10000000
#define DLCTL_NO_CLIENTPULL                     0x20000000
#define DLCTL_SILENT                            0x40000000
#define DLCTL_OFFLINEIFNOTCONNECTED             0x80000000
#define DLCTL_OFFLINE                           DLCTL_OFFLINEIFNOTCONNECTED

//;begin_internal
//----------------------------------------------------------------------------
//
//  DISPID for each non xobject event
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_ONABORT                          (DISPID_NORMAL_FIRST)
#define DISPID_ONCHANGE                         (DISPID_NORMAL_FIRST + 1)
#define DISPID_ONERROR                          (DISPID_NORMAL_FIRST + 2)
#define DISPID_ONLOAD                           (DISPID_NORMAL_FIRST + 3)
#define DISPID_ONSELECT                         (DISPID_NORMAL_FIRST + 6)
#define DISPID_ONSUBMIT                         (DISPID_NORMAL_FIRST + 7)
#define DISPID_ONUNLOAD                         (DISPID_NORMAL_FIRST + 8)
#define DISPID_ONBOUNCE                         (DISPID_NORMAL_FIRST + 9)
#define DISPID_ONFINISH                         (DISPID_NORMAL_FIRST + 10)
#define DISPID_ONSTART                          (DISPID_NORMAL_FIRST + 11)
#define DISPID_ONLAYOUT                         (DISPID_NORMAL_FIRST + 13)
#define DISPID_ONSCROLL                         (DISPID_NORMAL_FIRST + 14)
#define DISPID_ONRESET                          (DISPID_NORMAL_FIRST + 15)
#define DISPID_ONRESIZE                         (DISPID_NORMAL_FIRST + 16)
#define DISPID_ONBEFOREUNLOAD                   (DISPID_NORMAL_FIRST + 17)
#define DISPID_ONCHANGEFOCUS                    (DISPID_NORMAL_FIRST + 18)
#define DISPID_ONCHANGEBLUR                     (DISPID_NORMAL_FIRST + 19)
#define DISPID_ONPERSIST                        (DISPID_NORMAL_FIRST + 20)
#define DISPID_ONPERSISTSAVE                    (DISPID_NORMAL_FIRST + 21)
#define DISPID_ONPERSISTLOAD                    (DISPID_NORMAL_FIRST + 22)
#define DISPID_ONCONTEXTMENU                    (DISPID_NORMAL_FIRST + 23)
#define DISPID_ONBEFOREPRINT                    (DISPID_NORMAL_FIRST + 24)
#define DISPID_ONAFTERPRINT                     (DISPID_NORMAL_FIRST + 25)
#define DISPID_ONSTOP                           (DISPID_NORMAL_FIRST + 26)
#define DISPID_ONBEFOREEDITFOCUS                (DISPID_NORMAL_FIRST + 27)
#define DISPID_ONMOUSEHOVER                     (DISPID_NORMAL_FIRST + 28)
#define DISPID_ONCONTENTREADY                   (DISPID_NORMAL_FIRST + 29)
#define DISPID_ONLAYOUTCOMPLETE                 (DISPID_NORMAL_FIRST + 30)
#define DISPID_ONPAGE                           (DISPID_NORMAL_FIRST + 31)
#define DISPID_ONLINKEDOVERFLOW                 (DISPID_NORMAL_FIRST + 32)
#define DISPID_ONMOUSEWHEEL                     (DISPID_NORMAL_FIRST + 33)
#define DISPID_ONBEFOREDEACTIVATE               (DISPID_NORMAL_FIRST + 34)
#define DISPID_ONMOVE                           (DISPID_NORMAL_FIRST + 35)
#define DISPID_ONCONTROLSELECT                  (DISPID_NORMAL_FIRST + 36)
#define DISPID_ONSELECTIONCHANGE                (DISPID_NORMAL_FIRST + 37)
#define DISPID_ONMOVESTART                      (DISPID_NORMAL_FIRST + 38)
#define DISPID_ONMOVEEND                        (DISPID_NORMAL_FIRST + 39)
#define DISPID_ONRESIZESTART                    (DISPID_NORMAL_FIRST + 40)
#define DISPID_ONRESIZEEND                      (DISPID_NORMAL_FIRST + 41)
#define DISPID_ONMOUSEENTER                     (DISPID_NORMAL_FIRST + 42)
#define DISPID_ONMOUSELEAVE                     (DISPID_NORMAL_FIRST + 43)
#define DISPID_ONACTIVATE                       (DISPID_NORMAL_FIRST + 44)
#define DISPID_ONDEACTIVATE                     (DISPID_NORMAL_FIRST + 45)
#define DISPID_ONMULTILAYOUTCLEANUP             (DISPID_NORMAL_FIRST + 46)
#define DISPID_ONBEFOREACTIVATE                 (DISPID_NORMAL_FIRST + 47)
#define DISPID_ONFOCUSIN                        (DISPID_NORMAL_FIRST + 48)
#define DISPID_ONFOCUSOUT                       (DISPID_NORMAL_FIRST + 49)

//;begin_internal
//----------------------------------------------------------------------------
//
//  DISPID for each unique HtmlAttribute/CssAttribute
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_A_FIRST                          DISPID_ATTRS
#define DISPID_A_MIN                            DISPID_ATTRS
#define DISPID_A_MAX                            (DISPID_ATTRS+999)

#define DISPID_A_BACKGROUNDIMAGE                (DISPID_A_FIRST+1)
#define DISPID_A_COLOR                          (DISPID_A_FIRST+2)
#define DISPID_A_TEXTTRANSFORM                  (DISPID_A_FIRST+4)
#define DISPID_A_NOWRAP                         (DISPID_A_FIRST+5)
#define DISPID_A_LINEHEIGHT                     (DISPID_A_FIRST+6)
#define DISPID_A_TEXTINDENT                     (DISPID_A_FIRST+7)
#define DISPID_A_LETTERSPACING                  (DISPID_A_FIRST+8)
#define DISPID_A_LANG                           (DISPID_A_FIRST+9)
#define DISPID_A_OVERFLOW                       (DISPID_A_FIRST+10)

#define DISPID_A_PADDING                        (DISPID_A_FIRST+11)
#define DISPID_A_PADDINGTOP                     (DISPID_A_FIRST+12)
#define DISPID_A_PADDINGRIGHT                   (DISPID_A_FIRST+13)
#define DISPID_A_PADDINGBOTTOM                  (DISPID_A_FIRST+14)
#define DISPID_A_PADDINGLEFT                    (DISPID_A_FIRST+15)

#define DISPID_A_CLEAR                          (DISPID_A_FIRST+16)
#define DISPID_A_LISTTYPE                       (DISPID_A_FIRST+17)
#define DISPID_A_FONTFACE                       (DISPID_A_FIRST+18)
#define DISPID_A_FONTSIZE                       (DISPID_A_FIRST+19)

#define DISPID_A_TEXTDECORATIONLINETHROUGH      (DISPID_A_FIRST+20)
#define DISPID_A_TEXTDECORATIONUNDERLINE        (DISPID_A_FIRST+21)
#define DISPID_A_TEXTDECORATIONBLINK            (DISPID_A_FIRST+22)
#define DISPID_A_TEXTDECORATIONNONE             (DISPID_A_FIRST+23)


#define DISPID_A_FONTSTYLE                      (DISPID_A_FIRST+24)
#define DISPID_A_FONTVARIANT                    (DISPID_A_FIRST+25)
#define DISPID_A_BASEFONT                       (DISPID_A_FIRST+26)
#define DISPID_A_FONTWEIGHT                     (DISPID_A_FIRST+27)

#define DISPID_A_TABLEBORDERCOLOR               (DISPID_A_FIRST+28)
#define DISPID_A_TABLEBORDERCOLORLIGHT          (DISPID_A_FIRST+29)
#define DISPID_A_TABLEBORDERCOLORDARK           (DISPID_A_FIRST+30)
#define DISPID_A_TABLEVALIGN                    (DISPID_A_FIRST+31)

#define DISPID_A_BACKGROUND                     (DISPID_A_FIRST+32)
#define DISPID_A_BACKGROUNDPOSX                 (DISPID_A_FIRST+33)
#define DISPID_A_BACKGROUNDPOSY                 (DISPID_A_FIRST+34)

#define DISPID_A_TEXTDECORATION                 (DISPID_A_FIRST+35)

#define DISPID_A_MARGIN                         (DISPID_A_FIRST+36)
#define DISPID_A_MARGINTOP                      (DISPID_A_FIRST+37)
#define DISPID_A_MARGINRIGHT                    (DISPID_A_FIRST+38)
#define DISPID_A_MARGINBOTTOM                   (DISPID_A_FIRST+39)
#define DISPID_A_MARGINLEFT                     (DISPID_A_FIRST+40)

#define DISPID_A_FONT                           (DISPID_A_FIRST+41)
#define DISPID_A_FONTSIZEKEYWORD                (DISPID_A_FIRST+42)
#define DISPID_A_FONTSIZECOMBINE                (DISPID_A_FIRST+43)

#define DISPID_A_BACKGROUNDREPEAT               (DISPID_A_FIRST+44)
#define DISPID_A_BACKGROUNDATTACHMENT           (DISPID_A_FIRST+45)
#define DISPID_A_BACKGROUNDPOSITION             (DISPID_A_FIRST+46)
#define DISPID_A_WORDSPACING                    (DISPID_A_FIRST+47)
#define DISPID_A_VERTICALALIGN                  (DISPID_A_FIRST+48)
#define DISPID_A_BORDER                         (DISPID_A_FIRST+49)
#define DISPID_A_BORDERTOP                      (DISPID_A_FIRST+50)
#define DISPID_A_BORDERRIGHT                    (DISPID_A_FIRST+51)
#define DISPID_A_BORDERBOTTOM                   (DISPID_A_FIRST+52)
#define DISPID_A_BORDERLEFT                     (DISPID_A_FIRST+53)
#define DISPID_A_BORDERCOLOR                    (DISPID_A_FIRST+54)
#define DISPID_A_BORDERTOPCOLOR                 (DISPID_A_FIRST+55)
#define DISPID_A_BORDERRIGHTCOLOR               (DISPID_A_FIRST+56)
#define DISPID_A_BORDERBOTTOMCOLOR              (DISPID_A_FIRST+57)
#define DISPID_A_BORDERLEFTCOLOR                (DISPID_A_FIRST+58)
#define DISPID_A_BORDERWIDTH                    (DISPID_A_FIRST+59)
#define DISPID_A_BORDERTOPWIDTH                 (DISPID_A_FIRST+60)
#define DISPID_A_BORDERRIGHTWIDTH               (DISPID_A_FIRST+61)
#define DISPID_A_BORDERBOTTOMWIDTH              (DISPID_A_FIRST+62)
#define DISPID_A_BORDERLEFTWIDTH                (DISPID_A_FIRST+63)
#define DISPID_A_BORDERSTYLE                    (DISPID_A_FIRST+64)
#define DISPID_A_BORDERTOPSTYLE                 (DISPID_A_FIRST+65)
#define DISPID_A_BORDERRIGHTSTYLE               (DISPID_A_FIRST+66)
#define DISPID_A_BORDERBOTTOMSTYLE              (DISPID_A_FIRST+67)
#define DISPID_A_BORDERLEFTSTYLE                (DISPID_A_FIRST+68)
#define DISPID_A_TEXTDECORATIONOVERLINE         (DISPID_A_FIRST+69)
#define DISPID_A_FLOAT                          (DISPID_A_FIRST+70)
#define DISPID_A_DISPLAY                        (DISPID_A_FIRST+71)
#define DISPID_A_LISTSTYLETYPE                  (DISPID_A_FIRST+72)
#define DISPID_A_LISTSTYLEPOSITION              (DISPID_A_FIRST+73)
#define DISPID_A_LISTSTYLEIMAGE                 (DISPID_A_FIRST+74)
#define DISPID_A_LISTSTYLE                      (DISPID_A_FIRST+75)
#define DISPID_A_WHITESPACE                     (DISPID_A_FIRST+76)
#define DISPID_A_PAGEBREAKBEFORE                (DISPID_A_FIRST+77)
#define DISPID_A_PAGEBREAKAFTER                 (DISPID_A_FIRST+78)
#define DISPID_A_SCROLL                         (DISPID_A_FIRST+79)
#define DISPID_A_VISIBILITY                     (DISPID_A_FIRST+80)
//;begin_internal
// This dispid is available
#define DISPID_A_HIDDEN                         (DISPID_A_FIRST+81)
//;end_internal
#define DISPID_A_FILTER                         (DISPID_A_FIRST+82)

#define DISPID_DEFAULTVALUE                     (DISPID_A_FIRST+83)

#define DISPID_A_BORDERCOLLAPSE                 (DISPID_A_FIRST+84)

#define DISPID_A_POSITION                       (DISPID_A_FIRST+90)
#define DISPID_A_ZINDEX                         (DISPID_A_FIRST+91)
#define DISPID_A_CLIP                           (DISPID_A_FIRST+92)
#define DISPID_A_CLIPRECTTOP                    (DISPID_A_FIRST+93)
#define DISPID_A_CLIPRECTRIGHT                  (DISPID_A_FIRST+94)
#define DISPID_A_CLIPRECTBOTTOM                 (DISPID_A_FIRST+95)
#define DISPID_A_CLIPRECTLEFT                   (DISPID_A_FIRST+96)

#define DISPID_A_FONTFACESRC                    (DISPID_A_FIRST+97)
#define DISPID_A_TABLELAYOUT                    (DISPID_A_FIRST+98)

//;begin_internal
// The style as a text string
//;end_internal
#define DISPID_A_STYLETEXT                      (DISPID_A_FIRST+99)

//;begin_internal
// Known attributes that have special meaning
//;end_internal
#define DISPID_A_LANGUAGE                       (DISPID_A_FIRST+100)

#define DISPID_A_VALUE                          (DISPID_A_FIRST+101)
#define DISPID_A_CURSOR                         (DISPID_A_FIRST+102)


//;begin_internal
//+-----------------------------------------------------------------------
//  A couple of dispids that are used internally for firing
//  events and prop notifies.
// Keep all the internal dispid's together, otherwise we'll trip up 

#define DISPID_A_EVENTSINK                      (DISPID_A_FIRST+103)
#define DISPID_A_PROPNOTIFYSINK                 (DISPID_A_FIRST+104)
#define DISPID_A_ROWSETNOTIFYSINK               (DISPID_A_FIRST+105)
#define DISPID_INTERNAL_INLINESTYLEAA           (DISPID_A_FIRST+106) // In line style Attr Array
#define DISPID_INTERNAL_CSTYLEPTRCACHE          (DISPID_A_FIRST+107) // Cached CStyle Ptr
#define DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE   (DISPID_A_FIRST+108) // runtime style ptr obj
#define DISPID_INTERNAL_INVOKECONTEXT           (DISPID_A_FIRST+109) // Cached Invoke context

#define DISPID_A_BGURLIMGCTXCACHEINDEX          (DISPID_A_FIRST+110)
#define DISPID_A_LIURLIMGCTXCACHEINDEX          (DISPID_A_FIRST+111)
#define DISPID_A_ROWSETASYNCHNOTIFYSINK         (DISPID_A_FIRST+112)
#define DISPID_INTERNAL_FILTERPTRCACHE          (DISPID_A_FIRST+113) // FilterCollection in AttrArray
#define DISPID_A_ROWPOSITIONCHANGESINK          (DISPID_A_FIRST+114)
//;end_internal

#define DISPID_A_BEHAVIOR                       (DISPID_A_FIRST+115) // xtags
#define DISPID_A_READYSTATE                     (DISPID_A_FIRST+116) // ready state

#define DISPID_A_DIR                            (DISPID_A_FIRST+117) // Complex Text support for bidi
#define DISPID_A_UNICODEBIDI                    (DISPID_A_FIRST+118) // Complex Text support for CSS2 unicode-bidi
#define DISPID_A_DIRECTION                      (DISPID_A_FIRST+119) // Complex Text support for CSS2 direction

#define DISPID_A_IMEMODE                        (DISPID_A_FIRST+120) 

#define DISPID_A_RUBYALIGN                      (DISPID_A_FIRST+121)
#define DISPID_A_RUBYPOSITION                   (DISPID_A_FIRST+122)
#define DISPID_A_RUBYOVERHANG                   (DISPID_A_FIRST+123)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_CONTENTREADY  (DISPID_A_FIRST+124)
#define DISPID_INTERNAL_ONBEHAVIOR_DOCUMENTREADY (DISPID_A_FIRST+125)
#define DISPID_INTERNAL_CDOMCHILDRENPTRCACHE     (DISPID_A_FIRST+126)
//;end_internal

#define DISPID_A_LAYOUTGRIDCHAR                 (DISPID_A_FIRST+127)
#define DISPID_A_LAYOUTGRIDLINE                 (DISPID_A_FIRST+128)
#define DISPID_A_LAYOUTGRIDMODE                 (DISPID_A_FIRST+129)
#define DISPID_A_LAYOUTGRIDTYPE                 (DISPID_A_FIRST+130)
#define DISPID_A_LAYOUTGRID                     (DISPID_A_FIRST+131)

#define DISPID_A_TEXTAUTOSPACE                  (DISPID_A_FIRST+132)

#define DISPID_A_LINEBREAK                      (DISPID_A_FIRST+133)
#define DISPID_A_WORDBREAK                      (DISPID_A_FIRST+134)

#define DISPID_A_TEXTJUSTIFY                    (DISPID_A_FIRST+135)
#define DISPID_A_TEXTJUSTIFYTRIM                (DISPID_A_FIRST+136)
#define DISPID_A_TEXTKASHIDA                    (DISPID_A_FIRST+137)

#define DISPID_A_OVERFLOWX                      (DISPID_A_FIRST+139)
#define DISPID_A_OVERFLOWY                      (DISPID_A_FIRST+140)

#define DISPID_A_HTCDISPATCHITEM_VALUE          (DISPID_A_FIRST+141)
#define DISPID_A_DOCFRAGMENT                    (DISPID_A_FIRST+142)

#define DISPID_A_HTCDD_ELEMENT                  (DISPID_A_FIRST+143)
#define DISPID_A_HTCDD_CREATEEVENTOBJECT        (DISPID_A_FIRST+144)

#define DISPID_A_URNATOM                        (DISPID_A_FIRST+145)
#define DISPID_A_UNIQUEPEERNUMBER               (DISPID_A_FIRST+146)

#define DISPID_A_ACCELERATOR                    (DISPID_A_FIRST+147)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_APPLYSTYLE       (DISPID_A_FIRST+148)
#define DISPID_INTERNAL_RUNTIMESTYLEAA              (DISPID_A_FIRST+149)
#define DISPID_A_HTCDISPATCHITEM_VALUE_SCRIPTSONLY  (DISPID_A_FIRST+150)
//;end_internal

#define DISPID_A_EXTENDEDTAGDESC                (DISPID_A_FIRST+151)

#define DISPID_A_ROTATE                         (DISPID_A_FIRST+152)
#define DISPID_A_ZOOM                           (DISPID_A_FIRST+153)

#define DISPID_A_HTCDD_PROTECTEDELEMENT         (DISPID_A_FIRST+154)
#define DISPID_A_LAYOUTFLOW                     (DISPID_A_FIRST+155)
// DISPID_A_FIRST+156 unused -- removing 'rectangular'
// #define DISPID_A_RECTANGULAR                    (DISPID_A_FIRST+156)

#define DISPID_A_HTCDD_ISMARKUPSHARED           (DISPID_A_FIRST+157)
#define DISPID_A_WORDWRAP                       (DISPID_A_FIRST+158)
#define DISPID_A_TEXTUNDERLINEPOSITION          (DISPID_A_FIRST+159)
#define DISPID_A_HASLAYOUT                      (DISPID_A_FIRST+160)
#define DISPID_A_MEDIA                          (DISPID_A_FIRST+161)
#define DISPID_A_EDITABLE                       (DISPID_A_FIRST+162)
#define DISPID_A_HIDEFOCUS                      (DISPID_A_FIRST+163)

//;begin_internal
#define DISPID_INTERNAL_LAYOUTRECTREGISTRYPTRCACHE  (DISPID_A_FIRST+164)
//;end_internal

#define DISPID_A_HTCDD_DEFAULTS                 (DISPID_A_FIRST+165)

#define DISPID_A_TEXTLINETHROUGHSTYLE           (DISPID_A_FIRST+166)
#define DISPID_A_TEXTUNDERLINESTYLE             (DISPID_A_FIRST+167)
#define DISPID_A_TEXTEFFECT                     (DISPID_A_FIRST+168)
#define DISPID_A_TEXTBACKGROUNDCOLOR            (DISPID_A_FIRST+169)
#define DISPID_A_RENDERINGPRIORITY              (DISPID_A_FIRST+170)

//;begin_internal
#define DISPID_INTERNAL_DWNPOSTPTRCACHE             (DISPID_A_FIRST+171)
#define DISPID_INTERNAL_CODEPAGESETTINGSPTRCACHE    (DISPID_A_FIRST+172)
#define DISPID_INTERNAL_DWNDOCPTRCACHE              (DISPID_A_FIRST+173)
#define DISPID_INTERNAL_DATABINDTASKPTRCACHE        (DISPID_A_FIRST+174)
#define DISPID_INTERNAL_URLLOCATIONCACHE            (DISPID_A_FIRST+175)
#define DISPID_INTERNAL_ARYELEMENTRELEASENOTIFYPTRCACHE (DISPID_A_FIRST+176)
#define DISPID_INTERNAL_PEERFACTORYURLMAPPTRCACHE   (DISPID_A_FIRST+177)
#define DISPID_INTERNAL_STMDIRTYPTRCACHE            (DISPID_A_FIRST+178)
//;end_internal

//;begin_internal
#define DISPID_INTERNAL_COMPUTEFORMATSTATECACHE     (DISPID_A_FIRST+179)
//;end_internal

//
#define DISPID_A_SCROLLBARBASECOLOR             (DISPID_A_FIRST+180)
#define DISPID_A_SCROLLBARFACECOLOR             (DISPID_A_FIRST+181)
#define DISPID_A_SCROLLBAR3DLIGHTCOLOR          (DISPID_A_FIRST+182)
#define DISPID_A_SCROLLBARSHADOWCOLOR           (DISPID_A_FIRST+183)
#define DISPID_A_SCROLLBARHIGHLIGHTCOLOR        (DISPID_A_FIRST+184)
#define DISPID_A_SCROLLBARDARKSHADOWCOLOR       (DISPID_A_FIRST+185)
#define DISPID_A_SCROLLBARARROWCOLOR            (DISPID_A_FIRST+186)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_CONTENTSAVE  (DISPID_A_FIRST+187)
//;end_internal

#define DISPID_A_DEFAULTTEXTSELECTION           (DISPID_A_FIRST+188)
#define DISPID_A_TEXTDECORATIONCOLOR            (DISPID_A_FIRST+189)
#define DISPID_A_TEXTCOLOR                      (DISPID_A_FIRST+190)
#define DISPID_A_STYLETEXTDECORATION            (DISPID_A_FIRST+191)

#define DISPID_A_WRITINGMODE                    (DISPID_A_FIRST+192)

//;begin_internal
#define DISPID_INTERNAL_MEDIA_REFERENCE         (DISPID_A_FIRST+193)
#define DISPID_INTERNAL_GENERICCOMPLUSREF       (DISPID_A_FIRST+194)
//;end_internal

//;begin_internal
#define DISPID_INTERNAL_FOCUSITEMS              (DISPID_A_FIRST+195)
//;end_internal

#define DISPID_A_SCROLLBARTRACKCOLOR            (DISPID_A_FIRST+196)

//;begin_internal
#define DISPID_INTERNAL_DWNHEADERCACHE          (DISPID_A_FIRST+197)
//;end_internal

#define DISPID_A_FROZEN                         (DISPID_A_FIRST+198)
#define DISPID_A_VIEWINHERITSTYLE               (DISPID_A_FIRST+199)

//;begin_internal
#define DISPID_INTERNAL_FRAMESCOLLECTION        (DISPID_A_FIRST+200)
//;end_internal

//;begin_internal
#define DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE    (DISPID_A_FIRST+201)
#define DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER  (DISPID_A_FIRST+202)
//;end_internal

#define DISPID_A_TEXTALIGNLAST                  (DISPID_A_FIRST+203)
#define DISPID_A_TEXTKASHIDASPACE               (DISPID_A_FIRST+204)

//;begin_internal
#define DISPID_INTERNAL_FONTHISTORYINDEX        (DISPID_A_FIRST+205)
//;end_internal

#define DISPID_A_ALLOWTRANSPARENCY              (DISPID_A_FIRST+206)

#define DISPID_INTERNAL_URLSEARCHCACHE          (DISPID_A_FIRST+207)

#define DISPID_A_ISBLOCK                        (DISPID_A_FIRST+208)

#define DISPID_A_TEXTOVERFLOW                   (DISPID_A_FIRST+209)

//;begin_internal
#define DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE  (DISPID_A_FIRST+210)
//;end_internal

#define DISPID_A_MINHEIGHT                      (DISPID_A_FIRST+211)

//;begin_internal
#define DISPID_INTERNAL_INVOKECONTEXTDOCUMENT   (DISPID_A_FIRST+212)
//;end_internal

//;begin_internal
//------------------------------------------------------------------------
//
//  Event property and method dispids
//
//------------------------------------------------------------------------
//;end_internal

#define DISPID_EVPROP_ONMOUSEOVER           (DISPID_EVENTS +  0)
#define DISPID_EVMETH_ONMOUSEOVER            STDDISPID_XOBJ_ONMOUSEOVER
#define DISPID_EVPROP_ONMOUSEOUT            (DISPID_EVENTS +  1)
#define DISPID_EVMETH_ONMOUSEOUT             STDDISPID_XOBJ_ONMOUSEOUT
#define DISPID_EVPROP_ONMOUSEDOWN           (DISPID_EVENTS +  2)
#define DISPID_EVMETH_ONMOUSEDOWN            DISPID_MOUSEDOWN
#define DISPID_EVPROP_ONMOUSEUP             (DISPID_EVENTS +  3)
#define DISPID_EVMETH_ONMOUSEUP              DISPID_MOUSEUP
#define DISPID_EVPROP_ONMOUSEMOVE           (DISPID_EVENTS +  4)
#define DISPID_EVMETH_ONMOUSEMOVE            DISPID_MOUSEMOVE
#define DISPID_EVPROP_ONKEYDOWN             (DISPID_EVENTS +  5)
#define DISPID_EVMETH_ONKEYDOWN              DISPID_KEYDOWN
#define DISPID_EVPROP_ONKEYUP               (DISPID_EVENTS +  6)
#define DISPID_EVMETH_ONKEYUP                DISPID_KEYUP
#define DISPID_EVPROP_ONKEYPRESS            (DISPID_EVENTS +  7)
#define DISPID_EVMETH_ONKEYPRESS             DISPID_KEYPRESS
#define DISPID_EVPROP_ONCLICK               (DISPID_EVENTS +  8)
#define DISPID_EVMETH_ONCLICK                DISPID_CLICK
#define DISPID_EVPROP_ONDBLCLICK            (DISPID_EVENTS +  9)
#define DISPID_EVMETH_ONDBLCLICK             DISPID_DBLCLICK
#define DISPID_EVPROP_ONSELECT              (DISPID_EVENTS + 10)
#define DISPID_EVMETH_ONSELECT               DISPID_ONSELECT
#define DISPID_EVPROP_ONSUBMIT              (DISPID_EVENTS + 11)
#define DISPID_EVMETH_ONSUBMIT               DISPID_ONSUBMIT
#define DISPID_EVPROP_ONRESET               (DISPID_EVENTS + 12)
#define DISPID_EVMETH_ONRESET                DISPID_ONRESET
#define DISPID_EVPROP_ONHELP                (DISPID_EVENTS + 13)
#define DISPID_EVMETH_ONHELP                 STDDISPID_XOBJ_ONHELP
#define DISPID_EVPROP_ONFOCUS               (DISPID_EVENTS + 14)
#define DISPID_EVMETH_ONFOCUS                STDDISPID_XOBJ_ONFOCUS
#define DISPID_EVPROP_ONBLUR                (DISPID_EVENTS + 15)
#define DISPID_EVMETH_ONBLUR                 STDDISPID_XOBJ_ONBLUR
#define DISPID_EVPROP_ONROWEXIT             (DISPID_EVENTS + 18)
#define DISPID_EVMETH_ONROWEXIT              STDDISPID_XOBJ_ONROWEXIT
#define DISPID_EVPROP_ONROWENTER            (DISPID_EVENTS + 19)
#define DISPID_EVMETH_ONROWENTER             STDDISPID_XOBJ_ONROWENTER
#define DISPID_EVPROP_ONBOUNCE              (DISPID_EVENTS + 20)
#define DISPID_EVMETH_ONBOUNCE               DISPID_ONBOUNCE
#define DISPID_EVPROP_ONBEFOREUPDATE        (DISPID_EVENTS + 21)
#define DISPID_EVMETH_ONBEFOREUPDATE         STDDISPID_XOBJ_BEFOREUPDATE
#define DISPID_EVPROP_ONAFTERUPDATE         (DISPID_EVENTS + 22)
#define DISPID_EVMETH_ONAFTERUPDATE          STDDISPID_XOBJ_AFTERUPDATE
#define DISPID_EVPROP_ONBEFOREDRAGOVER      (DISPID_EVENTS + 23)
#define DISPID_EVMETH_ONBEFOREDRAGOVER       EVENTID_CommonCtrlEvent_BeforeDragOver
#define DISPID_EVPROP_ONBEFOREDROPORPASTE   (DISPID_EVENTS + 24)
#define DISPID_EVMETH_ONBEFOREDROPORPASTE    EVENTID_CommonCtrlEvent_BeforeDropOrPaste
#define DISPID_EVPROP_ONREADYSTATECHANGE    (DISPID_EVENTS + 25)
#define DISPID_EVMETH_ONREADYSTATECHANGE     DISPID_READYSTATECHANGE
#define DISPID_EVPROP_ONFINISH              (DISPID_EVENTS + 26)
#define DISPID_EVMETH_ONFINISH               DISPID_ONFINISH
#define DISPID_EVPROP_ONSTART               (DISPID_EVENTS + 27)
#define DISPID_EVMETH_ONSTART                DISPID_ONSTART
#define DISPID_EVPROP_ONABORT               (DISPID_EVENTS + 28)
#define DISPID_EVMETH_ONABORT                DISPID_ONABORT
#define DISPID_EVPROP_ONERROR               (DISPID_EVENTS + 29)
#define DISPID_EVMETH_ONERROR                DISPID_ONERROR
#define DISPID_EVPROP_ONCHANGE              (DISPID_EVENTS + 30)
#define DISPID_EVMETH_ONCHANGE               DISPID_ONCHANGE
#define DISPID_EVPROP_ONSCROLL              (DISPID_EVENTS + 31)
#define DISPID_EVMETH_ONSCROLL               DISPID_ONSCROLL
#define DISPID_EVPROP_ONLOAD                (DISPID_EVENTS + 32)
#define DISPID_EVMETH_ONLOAD                 DISPID_ONLOAD
#define DISPID_EVPROP_ONUNLOAD              (DISPID_EVENTS + 33)
#define DISPID_EVMETH_ONUNLOAD               DISPID_ONUNLOAD
#define DISPID_EVPROP_ONLAYOUT              (DISPID_EVENTS + 34)
#define DISPID_EVMETH_ONLAYOUT               DISPID_ONLAYOUT
#define DISPID_EVPROP_ONDRAGSTART           (DISPID_EVENTS + 35)
#define DISPID_EVMETH_ONDRAGSTART            STDDISPID_XOBJ_ONDRAGSTART
#define DISPID_EVPROP_ONRESIZE              (DISPID_EVENTS + 36)
#define DISPID_EVMETH_ONRESIZE               DISPID_ONRESIZE
#define DISPID_EVPROP_ONSELECTSTART         (DISPID_EVENTS + 37)
#define DISPID_EVMETH_ONSELECTSTART          STDDISPID_XOBJ_ONSELECTSTART
#define DISPID_EVPROP_ONERRORUPDATE         (DISPID_EVENTS + 38)
#define DISPID_EVMETH_ONERRORUPDATE          STDDISPID_XOBJ_ERRORUPDATE
#define DISPID_EVPROP_ONBEFOREUNLOAD        (DISPID_EVENTS + 39)
#define DISPID_EVMETH_ONBEFOREUNLOAD         DISPID_ONBEFOREUNLOAD
#define DISPID_EVPROP_ONDATASETCHANGED      (DISPID_EVENTS + 40)
#define DISPID_EVMETH_ONDATASETCHANGED       STDDISPID_XOBJ_ONDATASETCHANGED
#define DISPID_EVPROP_ONDATAAVAILABLE       (DISPID_EVENTS + 41)
#define DISPID_EVMETH_ONDATAAVAILABLE        STDDISPID_XOBJ_ONDATAAVAILABLE
#define DISPID_EVPROP_ONDATASETCOMPLETE     (DISPID_EVENTS + 42)
#define DISPID_EVMETH_ONDATASETCOMPLETE      STDDISPID_XOBJ_ONDATASETCOMPLETE
#define DISPID_EVPROP_ONFILTER              (DISPID_EVENTS + 43)
#define DISPID_EVMETH_ONFILTER               STDDISPID_XOBJ_ONFILTER
#define DISPID_EVPROP_ONCHANGEFOCUS         (DISPID_EVENTS + 44)
#define DISPID_EVMETH_ONCHANGEFOCUS          DISPID_ONCHANGEFOCUS
#define DISPID_EVPROP_ONCHANGEBLUR          (DISPID_EVENTS + 45)
#define DISPID_EVMETH_ONCHANGEBLUR           DISPID_ONCHANGEBLUR
#define DISPID_EVPROP_ONLOSECAPTURE         (DISPID_EVENTS + 46)
#define DISPID_EVMETH_ONLOSECAPTURE          STDDISPID_XOBJ_ONLOSECAPTURE
#define DISPID_EVPROP_ONPROPERTYCHANGE      (DISPID_EVENTS + 47)
#define DISPID_EVMETH_ONPROPERTYCHANGE       STDDISPID_XOBJ_ONPROPERTYCHANGE
#define DISPID_EVPROP_ONPERSISTSAVE         (DISPID_EVENTS + 48)
#define DISPID_EVMETH_ONPERSISTSAVE          DISPID_ONPERSISTSAVE
#define DISPID_EVPROP_ONDRAG                (DISPID_EVENTS + 49)
#define DISPID_EVMETH_ONDRAG                 STDDISPID_XOBJ_ONDRAG
#define DISPID_EVPROP_ONDRAGEND             (DISPID_EVENTS + 50)
#define DISPID_EVMETH_ONDRAGEND              STDDISPID_XOBJ_ONDRAGEND
#define DISPID_EVPROP_ONDRAGENTER           (DISPID_EVENTS + 51)
#define DISPID_EVMETH_ONDRAGENTER            STDDISPID_XOBJ_ONDRAGENTER
#define DISPID_EVPROP_ONDRAGOVER            (DISPID_EVENTS + 52)
#define DISPID_EVMETH_ONDRAGOVER             STDDISPID_XOBJ_ONDRAGOVER
#define DISPID_EVPROP_ONDRAGLEAVE           (DISPID_EVENTS + 53)
#define DISPID_EVMETH_ONDRAGLEAVE            STDDISPID_XOBJ_ONDRAGLEAVE
#define DISPID_EVPROP_ONDROP                (DISPID_EVENTS + 54)
#define DISPID_EVMETH_ONDROP                 STDDISPID_XOBJ_ONDROP
#define DISPID_EVPROP_ONCUT                 (DISPID_EVENTS + 55)
#define DISPID_EVMETH_ONCUT                  STDDISPID_XOBJ_ONCUT
#define DISPID_EVPROP_ONCOPY                (DISPID_EVENTS + 56)
#define DISPID_EVMETH_ONCOPY                 STDDISPID_XOBJ_ONCOPY
#define DISPID_EVPROP_ONPASTE               (DISPID_EVENTS + 57)
#define DISPID_EVMETH_ONPASTE                STDDISPID_XOBJ_ONPASTE
#define DISPID_EVPROP_ONBEFORECUT           (DISPID_EVENTS + 58)
#define DISPID_EVMETH_ONBEFORECUT            STDDISPID_XOBJ_ONBEFORECUT
#define DISPID_EVPROP_ONBEFORECOPY          (DISPID_EVENTS + 59)
#define DISPID_EVMETH_ONBEFORECOPY           STDDISPID_XOBJ_ONBEFORECOPY
#define DISPID_EVPROP_ONBEFOREPASTE         (DISPID_EVENTS + 60)
#define DISPID_EVMETH_ONBEFOREPASTE          STDDISPID_XOBJ_ONBEFOREPASTE
#define DISPID_EVPROP_ONPERSISTLOAD         (DISPID_EVENTS + 61)
#define DISPID_EVMETH_ONPERSISTLOAD          DISPID_ONPERSISTLOAD
#define DISPID_EVPROP_ONROWSDELETE          (DISPID_EVENTS + 62)
#define DISPID_EVMETH_ONROWSDELETE           STDDISPID_XOBJ_ONROWSDELETE
#define DISPID_EVPROP_ONROWSINSERTED        (DISPID_EVENTS + 63)
#define DISPID_EVMETH_ONROWSINSERTED         STDDISPID_XOBJ_ONROWSINSERTED
#define DISPID_EVPROP_ONCELLCHANGE          (DISPID_EVENTS + 64)
#define DISPID_EVMETH_ONCELLCHANGE           STDDISPID_XOBJ_ONCELLCHANGE
#define DISPID_EVPROP_ONCONTEXTMENU         (DISPID_EVENTS + 65)
#define DISPID_EVMETH_ONCONTEXTMENU          DISPID_ONCONTEXTMENU
#define DISPID_EVPROP_ONBEFOREPRINT         (DISPID_EVENTS + 66)
#define DISPID_EVMETH_ONBEFOREPRINT          DISPID_ONBEFOREPRINT
#define DISPID_EVPROP_ONAFTERPRINT          (DISPID_EVENTS + 67)
#define DISPID_EVMETH_ONAFTERPRINT           DISPID_ONAFTERPRINT
#define DISPID_EVPROP_ONSTOP                (DISPID_EVENTS + 68)
#define DISPID_EVMETH_ONSTOP                DISPID_ONSTOP
#define DISPID_EVPROP_ONBEFOREEDITFOCUS     (DISPID_EVENTS + 69)
#define DISPID_EVMETH_ONBEFOREEDITFOCUS      DISPID_ONBEFOREEDITFOCUS
#define DISPID_EVPROP_ONATTACHEVENT         (DISPID_EVENTS + 70)
#define DISPID_EVPROP_ONMOUSEHOVER          (DISPID_EVENTS + 71)
#define DISPID_EVMETH_ONMOUSEHOVER           DISPID_ONMOUSEHOVER
#define DISPID_EVPROP_ONCONTENTREADY        (DISPID_EVENTS + 72)
#define DISPID_EVMETH_ONCONTENTREADY         DISPID_ONCONTENTREADY
#define DISPID_EVPROP_ONLAYOUTCOMPLETE      (DISPID_EVENTS + 73)
#define DISPID_EVMETH_ONLAYOUTCOMPLETE       DISPID_ONLAYOUTCOMPLETE
#define DISPID_EVPROP_ONPAGE                (DISPID_EVENTS + 74)
#define DISPID_EVMETH_ONPAGE                 DISPID_ONPAGE
#define DISPID_EVPROP_ONLINKEDOVERFLOW      (DISPID_EVENTS + 75)
#define DISPID_EVMETH_ONLINKEDOVERFLOW       DISPID_ONLINKEDOVERFLOW
#define DISPID_EVPROP_ONMOUSEWHEEL          (DISPID_EVENTS + 76)
#define DISPID_EVMETH_ONMOUSEWHEEL           DISPID_ONMOUSEWHEEL
#define DISPID_EVPROP_ONBEFOREDEACTIVATE    (DISPID_EVENTS + 77)
#define DISPID_EVMETH_ONBEFOREDEACTIVATE     DISPID_ONBEFOREDEACTIVATE
#define DISPID_EVPROP_ONMOVE                (DISPID_EVENTS + 78)
#define DISPID_EVMETH_ONMOVE                 DISPID_ONMOVE
#define DISPID_EVPROP_ONCONTROLSELECT       (DISPID_EVENTS + 79)
#define DISPID_EVMETH_ONCONTROLSELECT        DISPID_ONCONTROLSELECT
#define DISPID_EVPROP_ONSELECTIONCHANGE     (DISPID_EVENTS + 80)
#define DISPID_EVMETH_ONSELECTIONCHANGE      DISPID_ONSELECTIONCHANGE
#define DISPID_EVPROP_ONMOVESTART           (DISPID_EVENTS + 81)
#define DISPID_EVMETH_ONMOVESTART            DISPID_ONMOVESTART
#define DISPID_EVPROP_ONMOVEEND             (DISPID_EVENTS + 82)
#define DISPID_EVMETH_ONMOVEEND              DISPID_ONMOVEEND
#define DISPID_EVPROP_ONRESIZESTART         (DISPID_EVENTS + 83)
#define DISPID_EVMETH_ONRESIZESTART          DISPID_ONRESIZESTART
#define DISPID_EVPROP_ONRESIZEEND           (DISPID_EVENTS + 84)
#define DISPID_EVMETH_ONRESIZEEND            DISPID_ONRESIZEEND
#define DISPID_EVPROP_ONMOUSEENTER          (DISPID_EVENTS + 85)
#define DISPID_EVMETH_ONMOUSEENTER           DISPID_ONMOUSEENTER
#define DISPID_EVPROP_ONMOUSELEAVE          (DISPID_EVENTS + 86)
#define DISPID_EVMETH_ONMOUSELEAVE           DISPID_ONMOUSELEAVE
#define DISPID_EVPROP_ONACTIVATE            (DISPID_EVENTS + 87)
#define DISPID_EVMETH_ONACTIVATE             DISPID_ONACTIVATE
#define DISPID_EVPROP_ONDEACTIVATE          (DISPID_EVENTS + 88)
#define DISPID_EVMETH_ONDEACTIVATE           DISPID_ONDEACTIVATE
#define DISPID_EVPROP_ONMULTILAYOUTCLEANUP  (DISPID_EVENTS + 89)
#define DISPID_EVMETH_ONMULTILAYOUTCLEANUP   DISPID_ONMULTILAYOUTCLEANUP
#define DISPID_EVPROP_ONBEFOREACTIVATE      (DISPID_EVENTS + 90)
#define DISPID_EVMETH_ONBEFOREACTIVATE       DISPID_ONBEFOREACTIVATE
#define DISPID_EVPROP_ONFOCUSIN             (DISPID_EVENTS + 91)
#define DISPID_EVMETH_ONFOCUSIN              DISPID_ONFOCUSIN
#define DISPID_EVPROP_ONFOCUSOUT            (DISPID_EVENTS + 92)
#define DISPID_EVMETH_ONFOCUSOUT             DISPID_ONFOCUSOUT
#define DISPID_EVPROPS_COUNT                (                93)


//;begin_internal
#endif // __COREDISP_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\always.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       Common header file for the Trident project.
//
//  Note:       This file is very order-dependent.  Don't switch files around
//              just for the heck of it!
//
//----------------------------------------------------------------------------

#ifndef I_ALWAYS_H_
#define I_ALWAYS_H_

// COM+ shim.  Uncomment below line to build the COM+ shim.
//#define COMPLUS_SHIM

#ifndef INCMSG
#define INCMSG(x)
//#define INCMSG(x) message(x)
#endif

#pragma INCMSG("--- Beg 'always.h'")

#define _OLEAUT32_
#define INC_OLE2
#define WIN32_LEAN_AND_MEAN
#define OEMRESOURCE
#define _COMDLG32_

#ifndef X_TRIRT_H_
#define X_TRIRT_H_
#pragma INCMSG("--- Beg 'trirt.h'")
#include <trirt.h>
#pragma INCMSG("--- End 'trirt.h'")
#endif

// Windows includes

#ifndef X_COMMDLG_H_
#define X_COMMDLG_H_
#pragma INCMSG("--- Beg <commdlg.h>")
#include <commdlg.h>
#pragma INCMSG("--- End <commdlg.h>")
#endif

#ifndef X_PLATFORM_H_
#define X_PLATFORM_H_
#pragma INCMSG("--- Beg <platform.h>")
#include <platform.h>
#pragma INCMSG("--- End <platform.h>")
#endif

#ifndef X_DOCOBJ_H_
#define X_DOCOBJ_H_
#pragma INCMSG("--- Beg <docobj.h>")
#include <docobj.h>
#pragma INCMSG("--- End <docobj.h>")
#endif


// Core includes

#include <w4warn.h>

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include "coredisp.h"
#endif

#ifndef X_WRAPDEFS_H_
#define X_WRAPDEFS_H_
#include "wrapdefs.h"
#endif

#ifndef X_F3UTIL_HXX_
#define X_F3UTIL_HXX_
#include "f3util.hxx"
#endif

#ifndef X_TRANSFORM_HXX_
#define X_TRANSFORM_HXX_
#include "transform.hxx"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_CSTR_HXX_
#define X_CSTR_HXX_
#include "cstr.hxx"
#endif

#ifndef X_FORMSARY_HXX_
#define X_FORMSARY_HXX_
#include "formsary.hxx"
#endif

#ifndef X_ASSOC_HXX_
#define X_ASSOC_HXX_
#include <assoc.hxx>
#endif

#ifndef X_CDBASE_HXX_
#define X_CDBASE_HXX_
#include "cdbase.hxx"
#endif

#ifndef X_DLL_HXX_
#define X_DLL_HXX_
#include "dll.hxx"
#endif

#ifndef X_TYPES_H_
#define X_TYPES_H_
#pragma INCMSG("--- Beg 'types.h'")
#include "types.h"
#pragma INCMSG("--- End 'types.h'")
#endif


// This prevents you from having to include codepage.h if all you want is
// the typedef for CODEPAGE.

typedef UINT CODEPAGE;

#ifndef X_SHLWAPI_H_
#define X_SHLWAPI_H_
#pragma INCMSG("--- Beg <shlwapi.h>")
#include <shlwapi.h>
#pragma INCMSG("--- End <shlwapi.h>")
#endif

#ifndef X_SHLWAPIP_H_
#define X_SHLWAPIP_H_
#pragma INCMSG("--- Beg <shlwapip.h>")
#include <shlwapip.h>
#pragma INCMSG("--- End <shlwapip.h>")
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

// Allow old-style string functions until they're all gone

#define STRSAFE_NO_DEPRECATE

// Right now including strsafe at this point causes a 
// warning that it is using a deprecated function. Until
// we find the cause of this warning, we should ignore it.
// (This warning would only appear if you remove the above
// #define.)

#pragma warning ( disable : 4995 )

#ifndef X_STRSAFE_H_
#define X_STRSAFE_H_
#pragma INCMSG("--- Beg 'strsafe.h'")
#include "strsafe.h"
#pragma INCMSG("--- End 'strsafe.h'")
#endif

#pragma warning ( default : 4995 )


#pragma INCMSG("--- End 'always.h'")
#else
#pragma INCMSG("*** Dup 'always.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\debuglib\debuglib.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       debuglib.c
//
//  Contents:   Interface to debugging .dll (if available)
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <w4warn.h>
#include <limits.h>
#include <mshtmdbg.h>

#include "markcode.hxx"
#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef __cplusplus
extern "C" {
#endif

struct TAGINFO
{
    CHAR *  pchOwner;
    CHAR *  pchDesc;
    BOOL    fEnabled;
};

TAGINFO g_rgtaginfo[] =
{
    { "Debug",      "General debug output",                     TRUE    },  //  0: tagDefault
    { "Trace",      "Errors",                                   TRUE    },  //  1: tagError
    { "Trace",      "Warnings",                                 FALSE   },  //  2: tagWarning
    { "Thread",     "Thread related tracing",                   FALSE   },  //  3: tagThread
    { "Assert",     "Exit on asserts",                          FALSE   },  //  4: tagAssertExit
    { "Assert",     "Stacktraces on asserts",                   TRUE    },  //  5: tagAssertStacks
    { "Memory",     "Use VMem for MemAlloc",                    FALSE   },  //  6: tagMemoryStrict
    { "Memory",     "Use VMem for CoTaskMemAlloc",              FALSE   },  //  7: tagCoMemoryStrict
    { "Memory",     "Use VMem strict at end (vs beginning)",    FALSE   },  //  8: tagMemoryStrictTail
    { "Memory",     "VMem pad to quadword at end",              FALSE   },  //  9: tagMemoryStrictAlign
    { "Trace",      "All calls to OCX interfaces",              FALSE   },  // 10: tagOLEWatch
    { "Perf",       "Perf and size killers",                    FALSE   },  // 11: tagPerf
    { "Peer",       "Provide test host behaviors",              FALSE   },  // 12: tagHostInfoBehaviors
    { "FALSE",      "FALSE",                                    FALSE   },  // 13: tagFALSE
};

#define TAG_NONAME              0x01
#define TAG_NONEWLINE           0x02
#define ARRAY_SIZE(x)           (sizeof(x) / sizeof(x[0]))

#define tagDefault              ((TRACETAG)0)
#define tagError                ((TRACETAG)1)
#define tagWarning              ((TRACETAG)2)
#define tagThread               ((TRACETAG)3)
#define tagAssertExit           ((TRACETAG)4)
#define tagAssertStacks         ((TRACETAG)5)
#define tagMemoryStrict         ((TRACETAG)6)
#define tagCoMemoryStrict       ((TRACETAG)7)
#define tagMemoryStrictTail     ((TRACETAG)8)
#define tagMemoryStrictAlign    ((TRACETAG)9)
#define tagOLEWatch             ((TRACETAG)10)
#define tagPerf                 ((TRACETAG)11)
#define tagHostInfoBehavior     ((TRACETAG)12)
#define tagFALSE                ((TRACETAG)13)

HINSTANCE g_hInstDbg = NULL;
HINSTANCE g_hInstLeak = NULL;

char * GetModuleName(HINSTANCE hInst)
{
    static char achMod[MAX_PATH];
    achMod[0] = 0;
    GetModuleFileNameA(hInst, achMod, sizeof(achMod));
    char * psz = &achMod[lstrlenA(achMod)];
    while (psz > achMod && *psz != '\\' && *psz != '//') --psz;
    if (*psz == '\\' || *psz == '//') ++psz;
    return(psz);
}

void LeakDumpAppend(char * pszMsg, void * pvArg = NULL)
{
    HANDLE hFile;
    char ach[1024];
    DWORD dw;

    lstrcpyA(ach, GetModuleName(g_hInstLeak));
    lstrcatA(ach, ": ");
    wsprintfA(&ach[lstrlenA(ach)], pszMsg, pvArg);

    hFile = CreateFileA("c:\\leakdump.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hFile, 0, NULL, FILE_END);
        WriteFile(hFile, ach, lstrlenA(ach), &dw, NULL);
        WriteFile(hFile, "\r\n", 2, &dw, NULL);
        CloseHandle(hFile);
    }
}

DWORD WINAPI _DbgExGetVersion()
{
    return(MSHTMDBG_API_VERSION);
}

BOOL WINAPI _DbgExIsFullDebug()
{
    return(FALSE);
}

void WINAPI _DbgExSetDllMain(HANDLE hDllHandle, BOOL (WINAPI * pfnDllMain)(HANDLE, DWORD, LPVOID))
{
}

void WINAPI _DbgExDoTracePointsDialog(BOOL fWait)
{
}

void WINAPI _DbgExRestoreDefaultDebugState()
{
}

BOOL WINAPI _DbgExEnableTag(TRACETAG tag, BOOL fEnable)
{
    BOOL fOld = FALSE;

    if (tag > 0 && tag < ARRAY_SIZE(g_rgtaginfo) - 1)
    {
        fOld = g_rgtaginfo[tag].fEnabled;
        g_rgtaginfo[tag].fEnabled = fEnable;
    }

    return(fOld);
}

BOOL WINAPI _DbgExSetDiskFlag(TRACETAG tag, BOOL fSendToDisk)
{
    return(FALSE);
}

BOOL WINAPI _DbgExSetBreakFlag(TRACETAG tag, BOOL fBreak)
{
    return(FALSE);
}

BOOL WINAPI _DbgExIsTagEnabled(TRACETAG tag)
{
    return(tag >= 0 && tag < ARRAY_SIZE(g_rgtaginfo) && g_rgtaginfo[tag].fEnabled);
}

TRACETAG WINAPI _DbgExFindTag(char * szTagDesc)
{
    TAGINFO * pti = g_rgtaginfo;
    TRACETAG tag;

    for (tag = 0; tag < ARRAY_SIZE(g_rgtaginfo); ++tag, ++pti)
    {
        if (!lstrcmpiA(pti->pchDesc, szTagDesc))
        {
            return(tag);
        }
    }

    return(tagFALSE);
}

TRACETAG WINAPI _DbgExTagError()
{
    return(tagError);
}

TRACETAG WINAPI _DbgExTagWarning()
{
    return(tagWarning);
}

TRACETAG WINAPI _DbgExTagThread()
{
    return(tagThread);
}

TRACETAG WINAPI _DbgExTagAssertExit()
{
    return(tagAssertExit);
}

TRACETAG WINAPI _DbgExTagAssertStacks()
{
    return(tagAssertStacks);
}

TRACETAG WINAPI _DbgExTagMemoryStrict()
{
    return(tagMemoryStrict);
}

TRACETAG WINAPI _DbgExTagCoMemoryStrict()
{
    return(tagCoMemoryStrict);
}

TRACETAG WINAPI _DbgExTagMemoryStrictTail()
{
    return(tagMemoryStrictTail);
}

TRACETAG WINAPI _DbgExTagMemoryStrictAlign()
{
    return(tagMemoryStrictAlign);
}

TRACETAG WINAPI _DbgExTagOLEWatch()
{
    return(tagOLEWatch);
}

TRACETAG WINAPI _DbgExTagPerf()
{
    return(tagPerf);
}

TRACETAG WINAPI _DbgExTagRegisterTrace(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled)
{
    TAGINFO * pti = g_rgtaginfo;
    TRACETAG tag;

    for (tag = 0; tag < ARRAY_SIZE(g_rgtaginfo) - 1; ++tag, ++pti)
    {
        if (!lstrcmpiA(pti->pchDesc, szDescrip) && !lstrcmpiA(pti->pchOwner, szOwner))
        {
            return(tag);
        }
    }

    return(tagFALSE);
}

TRACETAG WINAPI _DbgExTagRegisterOther(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled)
{
    TAGINFO * pti = g_rgtaginfo;
    TRACETAG tag;

    for (tag = 0; tag < ARRAY_SIZE(g_rgtaginfo) - 1; ++tag, ++pti)
    {
        if (!lstrcmpiA(pti->pchDesc, szDescrip) && !lstrcmpiA(pti->pchOwner, szOwner))
        {
            return(tag);
        }
    }

    return(tagFALSE);
}

BOOL WINAPI _DbgExTaggedTraceListEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker)
{
    if (DbgExIsTagEnabled(tag))
    {
        CHAR    achDup[512], *pch;
        CHAR    achBuf[1024];
        LONG    cch = 0;

        lstrcpynA(achDup, szFmt, ARRAY_SIZE(achDup));

        for (pch = achDup; *pch; ++pch)
        {
            if (*pch == '%')
            {
                if (pch[1] == '%')
                {
                    ++pch;
                    continue;
                }

                if (pch[1] == 'h' && pch[2] == 'r')
                {
                    pch[1] = 'l';
                    pch[2] = 'X';
                    continue;
                }
            }
        }

        if (!(usFlags & TAG_NONAME))
        {
            strcpy(achBuf, "MSHTML: ");
            cch += 8;
        }

        cch += wvsprintfA(&achBuf[cch], szFmt, valMarker);

        if (!(usFlags & TAG_NONEWLINE))
        {
            strcpy(&achBuf[cch], "\r\n");
        }

        OutputDebugStringA(achBuf);
    }

    return(FALSE);
}

void WINAPI _DbgExTaggedTraceCallers(TRACETAG tag, int iStart, int cTotal)
{
}

BOOL WINAPI _DbgExAssertImpl(char const * szFile, int iLine, char const * szMessage)
{
    CHAR szBuf[4096];
    wsprintfA(szBuf, "MSHTML: Assertion Failure in file %s, line %ld:\r\nMSHTML:   %s\r\n",
              szFile ? szFile : "unknown", iLine, szMessage);
    OutputDebugStringA(szBuf);
    return TRUE;
}

void WINAPI _DbgExAssertThreadDisable(BOOL fDisable)
{
}

HRESULT WINAPI _DbgExCheckAndReturnResultList(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list valMarker)
{
    return(hr);
}

size_t WINAPI _DbgExPreAlloc(size_t cbRequest)
{
    return(cbRequest);
}

void * WINAPI _DbgExPostAlloc(void *pv)
{
    return(pv);
}

void * WINAPI _DbgExPreFree(void *pv)
{
    if (g_hInstDbg)
    {
        LeakDumpAppend("DbgExPreFree: freeing memory at %08lX", pv);
        pv = NULL;
    }

    return(pv);
}

void WINAPI _DbgExPostFree()
{
}

size_t WINAPI _DbgExPreRealloc(void *pvRequest, size_t cbRequest, void **ppv)
{
    *ppv = pvRequest;
    return(cbRequest);
}

void * WINAPI _DbgExPostRealloc(void *pv)
{
    return(pv);
}

void * WINAPI _DbgExPreGetSize(void *pvRequest)
{
    return(pvRequest);
}

size_t WINAPI _DbgExPostGetSize(size_t cb)
{
    return(cb);
}

void * WINAPI _DbgExPreDidAlloc(void *pvRequest)
{
    return(pvRequest);
}

BOOL WINAPI _DbgExPostDidAlloc(void *pvRequest, BOOL fActual)
{
    return(fActual);
}

void WINAPI _DbgExMemoryTrackDisable(BOOL fDisable)
{
}

void WINAPI _DbgExCoMemoryTrackDisable(BOOL fDisable)
{
}

void WINAPI _DbgExMemoryBlockTrackDisable(void * pv)
{
}

void WINAPI _DbgExMemSetHeader(void * pvRequest, size_t cb, PERFMETERTAG mt)
{
}

void * WINAPI _DbgExGetMallocSpy()
{
    return(NULL);
}

void WINAPI _DbgExTraceMemoryLeaks()
{
}

BOOL WINAPI _DbgExValidateInternalHeap()
{
    return(TRUE);
}

LONG_PTR WINAPI _DbgExTraceFailL(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return(errExpr);
}

LONG_PTR WINAPI _DbgExTraceWin32L(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return(errExpr);
}

HRESULT WINAPI _DbgExTraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return(hrTest);
}

HRESULT WINAPI _DbgExTraceOLE(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite)
{
    return(hrTest);
}

void WINAPI _DbgExTraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
}

void WINAPI _DbgExTraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
}

void WINAPI _DbgExSetSimFailCounts(int firstFailure, int cInterval)
{
}

void WINAPI _DbgExShowSimFailDlg()
{
}

BOOL WINAPI _DbgExFFail()
{
    return(FALSE);
}

int WINAPI _DbgExGetFailCount()
{
    return(INT_MIN);
}

void WINAPI _DbgExTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv)
{
}

void WINAPI _DbgExOpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize)
{
}

void WINAPI _DbgExOpenMemoryMonitor()
{
}

void WINAPI _DbgExOpenLogFile(LPCSTR szFName)
{
}

void * WINAPI _DbgExMemSetNameList(void * pvRequest, char * szFmt, va_list valMarker)
{
    return(pvRequest);
}

char * WINAPI _DbgExMemGetName(void *pvRequest)
{
    return("");
}

HRESULT WINAPI _DbgExWsClear(HANDLE hProcess)
{
    return(S_OK);
}

HRESULT WINAPI _DbgExWsTakeSnapshot(HANDLE hProcess)
{
    return(S_OK);
}

BSTR WINAPI _DbgExWsGetModule(long row)
{
    return(NULL);
}

BSTR WINAPI _DbgExWsGetSection(long row)
{
    return(NULL);
}

long WINAPI _DbgExWsSize(long row)
{
    return(0);
}

long WINAPI _DbgExWsCount()
{
    return(0);
}

long WINAPI _DbgExWsTotal()
{
    return(0);
}

HRESULT WINAPI _DbgExWsStartDelta(HANDLE hProcess)
{
    return(S_OK);
}

long WINAPI _DbgExWsEndDelta(HANDLE hProcess)
{
    return(-1);
}

void WINAPI _DbgExDumpProcessHeaps()
{
}

PERFTAG WINAPI _DbgExPerfRegister(char * szTag, char * szOwner, char * szDescrip)
{
    return(0);
}

void WINAPI _DbgExPerfLogFnList(PERFTAG tag, void * pvObj, const char * pchFmt, va_list valMarker)
{
}

void WINAPI _DbgExPerfDump()
{
}

void WINAPI _DbgExPerfClear()
{
}

void WINAPI _DbgExPerfTags()
{
}

void WINAPI _DbgExPerfEnable(BOOL fEnable)
{
}

char * WINAPI _DbgExDecodeMessage(UINT msg)
{
    return("");
}

PERFMETERTAG WINAPI _DbgExMtRegister(char * szTag, char * szOwner, char * szDescrip)
{
    return(0);
}

void WINAPI _DbgExMtAdd(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal)
{
}

void WINAPI _DbgExMtSet(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal)
{
}

char * WINAPI _DbgExMtGetName(PERFMETERTAG mt)
{
    return("");
}

char * WINAPI _DbgExMtGetDesc(PERFMETERTAG mt)
{
    return("");
}

BOOL WINAPI _DbgExMtSimulateOutOfMemory(PERFMETERTAG mt, LONG_PTR lNewValue)
{
    return(0);
}

void WINAPI _DbgExMtOpenMonitor()
{
}

void WINAPI _DbgExMtLogDump(LPSTR pchFile)
{
}

PERFMETERTAG WINAPI _DbgExMtLookupMeter(char * szTag)
{
    return 0;
}

long WINAPI _DbgExMtGetMeterCnt(PERFMETERTAG mt, BOOL fExclusive)
{
    return 0;
}

long WINAPI _DbgExMtGetMeterVal(PERFMETERTAG mt, BOOL fExclusive)
{
    return 0;
}


void WINAPI _DbgExSetTopUrl(LPWSTR pstrUrl)
{
}

void WINAPI _DbgExGetSymbolFromAddress(void * pvAddr, char * pszBuf, DWORD cchBuf)
{
    pszBuf[0] = 0;
}

BOOL WINAPI _DbgExGetChkStkFill(DWORD * pdwFill)
{
    *pdwFill = GetPrivateProfileIntA("chkstk", "fill", 0xCCCCCCCC, "mshtmdbg.ini");
    return(!GetPrivateProfileIntA("chkstk", "disable", FALSE, "mshtmdbg.ini"));
}

int WINAPI _DbgExGetStackTrace(int iStart, int cTotal, BYTE *pbBuffer, int cbBuffer, int cchModule, int cchSymbol)
{
	return 0;
}

// cdecl function "wrappers" to their va_list equivalent ----------------------

BOOL __cdecl
DbgExTaggedTrace(TRACETAG tag, CHAR * szFmt, ...)
{
    va_list va;
    BOOL    f;

    va_start(va, szFmt);
    f = DbgExTaggedTraceListEx(tag, 0, szFmt, va);
    va_end(va);

    return f;
}

BOOL __cdecl
DbgExTaggedTraceEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, ...)
{
    va_list va;
    BOOL    f;

    va_start(va, szFmt);
    f = DbgExTaggedTraceListEx(tag, usFlags, szFmt, va);
    va_end(va);

    return f;
}

HRESULT __cdecl
DbgExCheckAndReturnResult(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, ...)
{
    va_list va;
    HRESULT hrResult;

    va_start(va, cHResult);
    hrResult = DbgExCheckAndReturnResultList(hr, fTrace, pstrFile, line, cHResult, va);
    va_end(va);

    return(hrResult);
}

void * __cdecl
DbgExMemSetName(void *pvRequest, char * szFmt, ...)
{
    va_list va;
    void * pv;

    va_start(va, szFmt);
    pv = DbgExMemSetNameList(pvRequest, szFmt, va);
    va_end(va);

    return(pv);
}

void __cdecl
DbgExPerfLogFn(PERFTAG tag, void * pvObj, const char * pchFmt, ...)
{
    va_list va;

    va_start(va, pchFmt);
    DbgExPerfLogFnList(tag, pvObj, pchFmt, va);
    va_end(va);
}

// InitDebugLib ---------------------------------------------------------------

#define DBGEXFUNCTIONS() \
    DBGEXWRAP (DWORD, DbgExGetVersion, (), ()) \
    DBGEXWRAP (BOOL, DbgExIsFullDebug, (), ()) \
    DBGEXWRAP_(void, DbgExSetDllMain, (HANDLE hDllHandle, BOOL (WINAPI * pfnDllMain)(HANDLE, DWORD, LPVOID)), (hDllHandle, pfnDllMain)) \
    DBGEXWRAP_(void, DbgExDoTracePointsDialog, (BOOL fWait), (fWait)) \
    DBGEXWRAP_(void, DbgExRestoreDefaultDebugState, (), ()) \
    DBGEXWRAP (BOOL, DbgExEnableTag, (TRACETAG tag, BOOL fEnable), (tag, fEnable)) \
    DBGEXWRAP (BOOL, DbgExSetDiskFlag, (TRACETAG tag, BOOL fSendToDisk), (tag, fSendToDisk)) \
    DBGEXWRAP (BOOL, DbgExSetBreakFlag, (TRACETAG tag, BOOL fBreak), (tag, fBreak)) \
    DBGEXWRAP (BOOL, DbgExIsTagEnabled, (TRACETAG tag), (tag)) \
    DBGEXWRAP (TRACETAG, DbgExFindTag, (char * szTagDesc), (szTagDesc)) \
    DBGEXWRAP (TRACETAG, DbgExTagError, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagWarning, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagThread, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagAssertExit, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagAssertStacks, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagMemoryStrict, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagCoMemoryStrict, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagMemoryStrictTail, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagMemoryStrictAlign, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagOLEWatch, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagPerf, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagRegisterTrace, (CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled), (szOwner, szDescrip, fEnabled)) \
    DBGEXWRAP (TRACETAG, DbgExTagRegisterOther, (CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled), (szOwner, szDescrip, fEnabled)) \
    DBGEXWRAP (BOOL, DbgExTaggedTraceListEx, (TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker), (tag, usFlags, szFmt, valMarker)) \
    DBGEXWRAP_(void, DbgExTaggedTraceCallers, (TRACETAG tag, int iStart, int cTotal), (tag, iStart, cTotal)) \
    DBGEXWRAP (BOOL, DbgExAssertImpl, (char const * szFile, int iLine, char const * szMessage), (szFile, iLine, szMessage)) \
    DBGEXWRAP_(void, DbgExAssertThreadDisable, (BOOL fDisable), (fDisable)) \
    DBGEXWRAP (HRESULT, DbgExCheckAndReturnResultList, (HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list valMarker), (hr, fTrace, pstrFile, line, cHResult, valMarker)) \
    DBGEXWRAP (size_t, DbgExPreAlloc, (size_t cbRequest), (cbRequest)) \
    DBGEXWRAP (void *, DbgExPostAlloc, (void *pv), (pv)) \
    DBGEXWRAP (void *, DbgExPreFree, (void *pv), (pv)) \
    DBGEXWRAP_(void, DbgExPostFree, (), ()) \
    DBGEXWRAP (size_t, DbgExPreRealloc, (void *pvRequest, size_t cbRequest, void **ppv), (pvRequest, cbRequest, ppv)) \
    DBGEXWRAP (void *, DbgExPostRealloc, (void *pv), (pv)) \
    DBGEXWRAP (void *, DbgExPreGetSize, (void *pvRequest), (pvRequest)) \
    DBGEXWRAP (size_t, DbgExPostGetSize, (size_t cb), (cb)) \
    DBGEXWRAP (void *, DbgExPreDidAlloc, (void *pvRequest), (pvRequest)) \
    DBGEXWRAP (BOOL, DbgExPostDidAlloc, (void *pvRequest, BOOL fActual), (pvRequest, fActual)) \
    DBGEXWRAP_(void, DbgExMemoryTrackDisable, (BOOL fDisable), (fDisable)) \
    DBGEXWRAP_(void, DbgExCoMemoryTrackDisable, (BOOL fDisable), (fDisable)) \
    DBGEXWRAP_(void, DbgExMemoryBlockTrackDisable, (void * pv), (pv)) \
    DBGEXWRAP_(void, DbgExMemSetHeader, (void * pvRequest, size_t cb, PERFMETERTAG mt), (pvRequest, cb, mt)) \
    DBGEXWRAP (void *, DbgExGetMallocSpy, (), ()) \
    DBGEXWRAP_(void, DbgExTraceMemoryLeaks, (), ()) \
    DBGEXWRAP (BOOL, DbgExValidateInternalHeap, (), ()) \
    DBGEXWRAP (LONG_PTR, DbgExTraceFailL, (LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line), (errExpr, errTest, fIgnore, pstrExpr, pstrFile, line)) \
    DBGEXWRAP (LONG_PTR, DbgExTraceWin32L, (LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line), (errExpr, errTest, fIgnore, pstrExpr, pstrFile, line)) \
    DBGEXWRAP (HRESULT, DbgExTraceHR, (HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line), (hrTest, fIgnore, pstrExpr, pstrFile, line)) \
    DBGEXWRAP (HRESULT, DbgExTraceOLE, (HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite), (hrTest, fIgnore, pstrExpr, pstrFile, line, lpsite)) \
    DBGEXWRAP_(void, DbgExTraceEnter, (LPSTR pstrExpr, LPSTR pstrFile, int line), (pstrExpr, pstrFile, line)) \
    DBGEXWRAP_(void, DbgExTraceExit, (LPSTR pstrExpr, LPSTR pstrFile, int line), (pstrExpr, pstrFile, line)) \
    DBGEXWRAP_(void, DbgExSetSimFailCounts, (int firstFailure, int cInterval), (firstFailure, cInterval)) \
    DBGEXWRAP_(void, DbgExShowSimFailDlg, (), ()) \
    DBGEXWRAP (BOOL, DbgExFFail, (), ()) \
    DBGEXWRAP (int, DbgExGetFailCount, (), ()) \
    DBGEXWRAP_(void, DbgExTrackItf, (REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv), (iid, pch, fTrackOnQI, ppv)) \
    DBGEXWRAP_(void, DbgExOpenViewObjectMonitor, (HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize), (hwndOwner, pUnk, fUseFrameSize)) \
    DBGEXWRAP_(void, DbgExOpenMemoryMonitor, (), ()) \
    DBGEXWRAP_(void, DbgExOpenLogFile, (LPCSTR szFName), (szFName)) \
    DBGEXWRAP (void *, DbgExMemSetNameList, (void * pvRequest, char * szFmt, va_list valMarker), (pvRequest, szFmt, valMarker)) \
    DBGEXWRAP (char *, DbgExMemGetName, (void *pvRequest), (pvRequest)) \
    DBGEXWRAP (HRESULT, DbgExWsClear, (HANDLE hProcess), (hProcess)) \
    DBGEXWRAP (HRESULT, DbgExWsTakeSnapshot, (HANDLE hProcess), (hProcess)) \
    DBGEXWRAP (BSTR, DbgExWsGetModule, (long row), (row)) \
    DBGEXWRAP (BSTR, DbgExWsGetSection, (long row), (row)) \
    DBGEXWRAP (long, DbgExWsSize, (long row), (row)) \
    DBGEXWRAP (long, DbgExWsCount, (), ()) \
    DBGEXWRAP (long, DbgExWsTotal, (), ()) \
    DBGEXWRAP (HRESULT, DbgExWsStartDelta, (HANDLE hProcess), (hProcess)) \
    DBGEXWRAP (long, DbgExWsEndDelta, (HANDLE hProcess), (hProcess)) \
    DBGEXWRAP_(void, DbgExDumpProcessHeaps, (), ()) \
    DBGEXWRAP (PERFTAG, DbgExPerfRegister, (char * szTag, char * szOwner, char * szDescrip), (szTag, szOwner, szDescrip)) \
    DBGEXWRAP_(void, DbgExPerfLogFnList, (PERFTAG tag, void * pvObj, const char * pchFmt, va_list valMarker), (tag, pvObj, pchFmt, valMarker)) \
    DBGEXWRAP_(void, DbgExPerfDump, (), ()) \
    DBGEXWRAP_(void, DbgExPerfClear, (), ()) \
    DBGEXWRAP_(void, DbgExPerfTags, (), ()) \
    DBGEXWRAP_(void, DbgExPerfEnable, (BOOL fEnable), (fEnable)) \
    DBGEXWRAP (char *, DbgExDecodeMessage, (UINT msg), (msg)) \
    DBGEXWRAP(PERFMETERTAG, DbgExMtRegister, (char * szTag, char * szOwner, char * szDescrip), (szTag, szOwner, szDescrip)) \
    DBGEXWRAP_(void, DbgExMtAdd, (PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal), (mt, lCnt, lVal)) \
    DBGEXWRAP_(void, DbgExMtSet, (PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal), (mt, lCnt, lVal)) \
    DBGEXWRAP (char *, DbgExMtGetName, (PERFMETERTAG mt), (mt)) \
    DBGEXWRAP (char *, DbgExMtGetDesc, (PERFMETERTAG mt), (mt)) \
    DBGEXWRAP (BOOL, DbgExMtSimulateOutOfMemory, (PERFMETERTAG mt, LONG_PTR lNewValue), (mt, lNewValue)) \
    DBGEXWRAP_(void, DbgExMtOpenMonitor, (), ()) \
    DBGEXWRAP_(void, DbgExMtLogDump, (LPSTR pchFile), (pchFile)) \
    DBGEXWRAP (PERFMETERTAG, DbgExMtLookupMeter, (char * szTag), (szTag)) \
    DBGEXWRAP (long, DbgExMtGetMeterCnt, (PERFMETERTAG mt, BOOL fExclusive), (mt, fExclusive)) \
    DBGEXWRAP (long, DbgExMtGetMeterVal, (PERFMETERTAG mt, BOOL fExclusive), (mt, fExclusive)) \
    DBGEXWRAP_(void, DbgExSetTopUrl, (LPWSTR pstrUrl), (pstrUrl)) \
    DBGEXWRAP_(void, DbgExGetSymbolFromAddress, (void * pvAddr, char * pszBuf, DWORD cchBuf), (pvAddr, pszBuf, cchBuf)) \
    DBGEXWRAP (BOOL, DbgExGetChkStkFill, (DWORD * pdwFill), (pdwFill)) \
    DBGEXWRAP (int, DbgExGetStackTrace, (int iStart, int cTotal, BYTE *pbBuffer, int cbBuffer, int cchModule, int cchSymbol), (iStart, cTotal, pbBuffer, cbBuffer, cchModule, cchSymbol)) \

#undef  DBGEXWRAP
#undef  DBGEXWRAP_
#define DBGEXWRAP(ret, fn, formals, params) ret (WINAPI * g_##fn) formals = NULL;
#define DBGEXWRAP_(ret, fn, formals, params) ret (WINAPI * g_##fn) formals = NULL;

DBGEXFUNCTIONS()

#undef  DBGEXWRAP
#undef  DBGEXWRAP_
#define DBGEXWRAP(ret, fn, formals, params) ret WINAPI fn formals { return(g_##fn params); }
#define DBGEXWRAP_(ret, fn, formals, params) ret WINAPI fn formals { g_##fn params; }

DBGEXFUNCTIONS()

BOOL InitDebugProcedure(void ** ppv, char * pchFn)
{
    *ppv = (void *)GetProcAddress(g_hInstDbg, pchFn);

    if (*ppv == NULL)
    {
        char ach[512];
        wsprintfA(ach, "InitDebugLib: Can't find mshtmdbg.dll entrypoint %s\r\n", pchFn);
        OutputDebugStringA(ach);
        return(FALSE);
    }

    return(TRUE);
}

void InitDebugStubs()
{
    #undef  DBGEXWRAP
    #undef  DBGEXWRAP_
    #define DBGEXWRAP(ret, fn, formals, params) g_##fn = _##fn;
    #define DBGEXWRAP_(ret, fn, formals, params) g_##fn = _##fn;

    DBGEXFUNCTIONS()
}

void InitDebugLib(HANDLE hDllHandle, BOOL (WINAPI * pfnDllMain)(HANDLE, DWORD, LPVOID))
{
    g_hInstDbg = LoadLibraryA("mshtmdbg.dll");

    if (g_hInstDbg == NULL)
    {
//        OutputDebugStringA("InitDebugLib: Can't find mshtmdbg.dll.  Only partial debug support available.\r\n");
        goto dostubs;
    }

    #undef  DBGEXWRAP
    #undef  DBGEXWRAP_
    #define DBGEXWRAP(ret, fn, formals, params) if (!InitDebugProcedure((void **)&g_##fn, #fn)) goto dostubs;
    #define DBGEXWRAP_(ret, fn, formals, params) if (!InitDebugProcedure((void **)&g_##fn, #fn)) goto dostubs;

    DBGEXFUNCTIONS()

    if (DbgExGetVersion() != MSHTMDBG_API_VERSION)
    {
        char ach[512];
        wsprintfA(ach, "InitDebugLib: Version mismatch for MSHTMDBG.DLL.  Expected %ld but found %ld.\r\n",
                  MSHTMDBG_API_VERSION, DbgExGetVersion());
        OutputDebugStringA(ach);
        FreeLibrary(g_hInstDbg);
        g_hInstDbg = NULL;
        goto dostubs;
    }
    else
    {
        DbgExSetDllMain(hDllHandle, pfnDllMain);
    }

    return;

dostubs:

    InitDebugStubs();
}

void TermDebugLib(HANDLE hDllHandle, BOOL fFinal)
{
    if (g_hInstDbg == NULL)
        return;

    if (fFinal)
    {
        FreeLibrary(g_hInstDbg);
        g_hInstDbg = NULL;
    }
    else
    {
        DbgExSetDllMain(hDllHandle, NULL);
    }
}

#ifdef __cplusplus
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\ctrldisp.h ===
/**************************************************************************************


  (rgardner) This file is obsolete - please put all changes in COREDISP.H
  It will be delfile'd shortly in a cleanup pass
                                                

 **************************************************************************************/

#pragma error("Don't include this file")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\corerc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       corerc.h
//
//  Contents:   Resource identifiers for Core project.
//
//----------------------------------------------------------------------------
//
//  Resource identifier ranges.
//
//  Low resource identifiers are reserved for servers listed in the registry.
//  We need to do this because the ExtractIcon API uses the index of the icon,
//  not the resource identifier of icon.  By reserving this range for registered
//  servers, we can insure that the registered icon indices are correct.
//
//  00000 - 00019    Core registered servers
//  00020 - 00159    Ctrl '96 registered servers
//  00160 - 00199    Form registered servers
//  00200 - 00899    Ctrl '97 registered servers
//  00900 - 00999    Site registered servers (overlaps with ddoc)
//
//  02000 - 03999    Core miscellaneous
//  04000 - 05999    Ctrl miscellaneous
//  06000 - 07999    Form miscellaneous
//  08000 - 09999    Site miscellaneous (overlaps with ddoc)
//
//  10000 - 19999    Menu help string = IDS_MENUHELP(idm)
//  20000 - 29999    Tooltip text = IDS_TOOLTIP(idm)
//
//----------------------------------------------------------------------------
//
//  Naming convention
//
//  IDR_     Resource. Id must be unique per resource type, prefer
//           unique across resource types.
//  IDM_     Menu item, unique across product.
//  IDI_     Dialog item. Must be unique in dialog.
//  IDS_     String table element.
//  IDS_EA_  Action part of error message.
//  IDS_EE_  Error part of of error message.
//  IDS_ES_  Solution part of error message.
//  IDS_MSG_ Informational message.
//  IDS_E_   HRESULT to text mapping.
//
//----------------------------------------------------------------------------

#ifndef I_CORERC_H_
#define I_CORERC_H_
#pragma INCMSG("--- Beg 'corerc.h'")

#define IDS_MENUHELP(idm) (10000 + (idm))
#define IDS_TOOLTIP(idm)  (20000 + (idm))

//  resource ID offsets for class descriptor information
#define IDOFF_TOOLBOXBITMAP   5
#define IDOFF_ACCELS          6
#define IDOFF_MENU            7
#define IDOFF_MGW             8

// unfortunately, these macros can't be used in defining
//  the symbols below: the resource compiler doesn't like them.
#define IDS_USERTYPEFULL(base)  ((base)/5)
#define IDS_USERTYPESHORT(base) ((base)/5 + 1)
#define IDR_MENU(base)          ((base) + IDOFF_MENU)
#define IDR_TOOLBOXBITMAP(base) ((base) + IDOFF_TOOLBOXBITMAP)
#define IDR_ACCELS(base)        ((base) + IDOFF_ACCELS)

//----------------------------------------------------------------------------
//
// Registered servers (00xx)
//
//----------------------------------------------------------------------------

// Form

#define IDR_FORM_ICON             5

#define IDR_ACCELS_SITE_RUN             40
#define IDR_ACCELS_SITE_DESIGN          41
#define IDR_ACCELS_INPUTTXT_RUN         42
#define IDR_ACCELS_INPUTTXT_DESIGN      43
#define IDR_ACCELS_TCELL_RUN            44
#define IDR_ACCELS_TCELL_DESIGN         45
#define IDR_ACCELS_FRAMESET_RUN         46
#define IDR_ACCELS_FRAMESET_DESIGN      47
#define IDR_ACCELS_BODY_RUN             48
#define IDR_ACCELS_BODY_DESIGN          49
#define IDR_ACCELS_TXTSITE_RUN          50
#define IDR_ACCELS_TXTSITE_DESIGN       51


//+-------------------------------------------------------------------------
//
//  Cursors (20xx)
//
//--------------------------------------------------------------------------

#define IDC_SELBAR                      2008    // Text select cursor for text site

#define IDC_RESIZEROW2				    9804 
#define IDC_RESIZECOL2				    9805 


#define IDC_NOSCROLLVH                  2025
#define IDB_NOTLOADED                   2030
#define IDB_MISSING                     2031

//----------------------------------------------------------------------------
//
// Squeeze files (21xx)
//
//----------------------------------------------------------------------------

#define RT_DOCFILE                      256
#define RT_FILE                         2110

//+------------------------------------------------------------------------
//
//  Strings -- packed for size reason; start at multiple of 16.
    //      No existing ID can be changed once localization occurs
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Error strings
//
//-------------------------------------------------------------------------

#define IDS_E_CMDNOTSUPPORTED           2206
#define IDS_ERR_OD_E_OUTOFMEMORY        2207

//+------------------------------------------------------------------------
//
//  cdbase strings
//
//-------------------------------------------------------------------------

// 2210 starts string table chunk
#define IDS_USERTYPEAPP                 2212    // Microsoft Forms 2.0
#define IDS_MESSAGE_BOX_TITLE           2213    // Microsoft Forms
#define IDS_ERROR_SOLUTION              2214    // Solution:\n<0s>
#define IDS_UNKNOWN_ERROR               2215    // Unknown error <0x>
#define IDS_EA_SETTING_PROPERTY         2216    // Could not set property ...
#define IDS_EA_GETTING_PROPERTY         2217    // Could not get property ...
#define IDS_EE_INVALID_PROPERTY_VALUE   2218    // The value entered is not valid ..
#define IDS_ES_ENTER_VALUE_IN_RANGE     2220    // Enter a value between..
#define IDS_ES_ENTER_VALUE_GT_ZERO      2221    // Enter a value greater than
#define IDS_ES_ENTER_VALUE_GE_ZERO      2222    // Enter a value greater than
#define IDS_MSG_SAVE_MODIFIED_OBJECT    2223    // Save modified object?
#define IDS_EE_INVALIDPICTURETYPE       2227    // CTL_E_INVALIDPICTURETYPE mouse icon must be a mouse icon
#define IDS_EE_SETNOTSUPPORTEDATRUNTIME 2321    // Set property is not support at runtime.
#define IDS_EE_CANTMOVEFOCUSTOCTRL      2322    // can't move focus to control because...
#define IDS_EE_METHODNOTAPPLICABLE      2324
#define IDS_ES_ENTER_PROPER_VALUE       2325    // Enter a proper value
#define IDS_EA_CALLING_METHOD           2326    // Could not call method ...
#define IDS_EE_CONTROLNEEDSFOCUS        2327    // The control needs to have the focus
#define IDS_ES_CONTROLNEEDSFOCUS        2328    // Try setting the focus to the control using the SetFocus method
#define IDS_EE_UNEXPECTED               2329    // E_UNEXPECTED
#define IDS_EE_FAIL                     2330    // E_FAIL
#define IDS_EE_INVALIDPICTURE           2331    // CTL_E_INVALIDPICTURE
#define IDS_EE_INVALIDPROPERTYARRAYINDEX 2332   // CTL_E_INVALIDPROPERTYARRAYINDEX
#define IDS_EE_INVALIDPROPERTYVALUE     2333    // CTL_E_INVALIDPROPERTYVALUE
#define IDS_EE_OVERFLOW                 2334    // CTL_E_OVERFLOW
#define IDS_EE_PERMISSIONDENIED         2335    // CTL_E_PERMISSIONDENIED
#define IDS_EE_INVALIDARG               2336    // E_INVALIDARG
#define IDS_EE_NOTLICENSED              2337    // CLASS_E_NOTLICENSED
#define IDS_EE_INVALIDPASTETARGET       2338    // CTL_E_INVALIDPASTETARGET
#define IDS_EE_INVALIDPASTESOURCE       2339    // CTL_E_INVALIDPASTESOURCE

#define IDS_UNKNOWN                     2340

#define IDS_EE_INTERNET_INVALID_URL         2341
#define IDS_EE_INTERNET_NAME_NOT_RESOLVED   2342
#define IDS_EE_INET_E_UNKNOWN_PROTOCOL      2343
#define IDS_EE_INET_E_REDIRECT_FAILED       2344
#define IDS_EE_MISMATCHEDTAG                2345    // CTL_E_MISMATCHEDTAG
#define IDS_EE_INCOMPATIBLEPOINTERS         2346    // CTL_E_INCOMPATIBLEPOINTERS
#define IDS_EE_UNPOSITIONEDPOINTER          2347    // CTL_E_UNPOSITIONEDPOINTER
#define IDS_EE_UNPOSITIONEDELEMENT          2348    // CTL_E_UNPOSITIONEDELEMENT
#define IDS_EE_INVALIDLINE                  2349    // CTL_E_INVALIDLINE

//+------------------------------------------------------------------------
//
//  formkrnl strings
//
//-------------------------------------------------------------------------

#define IDS_CTRLPROPERTIES              2229
#define IDS_NAMEDCTRLPROPERTIES         2230
#define IDS_EA_PASTE_CONTROL            2235
#define IDS_EA_INSERT_CONTROL           2236
#define IDS_MSG_FIND_DIALOG_HACK        2237

//----------------------------------------------------------------------------
//
// Misc strings
//
//----------------------------------------------------------------------------

//  The following IDS's must be kept in order, such that the
//    string for a given unit has the id IDS_UNITS_BASE + units
//    Otherwise, the StringToHimetric and HimetricToString functions
//    in himetric.cxx will break.  (chrisz)

#define IDS_UNITS_BASE                  2240
#define IDS_UNITS_INCH                  (IDS_UNITS_BASE+0)
#define IDS_UNITS_CM                    (IDS_UNITS_BASE+1)
#define IDS_UNITS_POINT                 (IDS_UNITS_BASE+2)


//----------------------------------------------------------------------------
//
// Undo strings
//
//----------------------------------------------------------------------------

#define IDS_UNDO                        (IDS_UNITS_POINT + 1)
#define IDS_REDO                        (IDS_UNDO + 1)
#define IDS_CANTUNDO                    (IDS_UNDO + 2)
#define IDS_CANTREDO                    (IDS_UNDO + 3)
#define IDS_UNDONEWCTRL                 (IDS_UNDO + 4)
#define IDS_UNDODELETE                  (IDS_UNDO + 5)
#define IDS_UNDOPROPCHANGE              (IDS_UNDO + 6)
#define IDS_UNDOMOVE                    (IDS_UNDO + 7)
#define IDS_UNDODRAGDROP                (IDS_UNDO + 9)
#define IDS_UNDOPASTE                   (IDS_UNDO + 15)
#define IDS_UNDOTYPING                  (IDS_UNDO + 16)
#define IDS_UNDOGENERICTEXT             (IDS_UNDO + 19)
#define IDS_UNDOCHANGEVALUE             (IDS_UNDO + 20)
#define IDS_UNDOBACKSPACE               (IDS_UNDO + 21)

//----------------------------------------------------------------------------
//
// Misc (25xx)
//
//----------------------------------------------------------------------------

#define IDR_SELTOOLBMP                  2500    // Iconbar selection tool.
#define IDB_DITHER                      2502
#define IDR_HATCHBMP                    2503    // Bitmap for border hatching

#define IDS_DRAGMOVEHERE                2508
#define IDS_DRAGCOPYHERE                2509
#define IDR_THKHATCHBMP                 2510    // Bitmap for thick border hatching
#define IDS_UNKNOWNPROTOCOL             2511    
#define IDS_SECURECONNECTIONINFO        2512
#define IDS_SECURE_LOW                  2513
#define IDS_SECURE_MEDIUM               2514
#define IDS_SECURE_HIGH                 2515
#define IDS_SECURESOURCE                2516

//----------------------------------------------------------------------------
//
// Icons
//
//----------------------------------------------------------------------------

#define RES_ICO_HTML                    2661

//----------------------------------------------------------------------------
//
// Misc resources
//
//----------------------------------------------------------------------------

#define IDR_CLICKSOUND              800
#define IDR_SITECONTEXT             24624  //0x6030  // bad id - not in core range

// dependencies - shdocvw\resource.h
#define IDR_FORM_CONTEXT_MENU       24640  //0x6040  // bad id - not in core range
#define IDR_BROWSE_CONTEXT_MENU     24641  //0x6041  // bad id - not in core range

#define IDR_DRAG_CONTEXT_MENU       24645  //0x6045  // bad id - not in core range

#define CX_CONTEXTMENUOFFSET    2
#define CY_CONTEXTMENUOFFSET    2




//
//  Form dialogs
//

//----------------------------------------------------------------------------
//
// Tab order dialog (3250 - 3260)
//
//----------------------------------------------------------------------------
#define IDR_TABORDERLBL             3250
#define IDR_TABORDERLSTBOX          3251
#define IDR_BTNMOVEUP               3252
#define IDR_BTNMOVEDOWN             3253
//#define IDR_BTNAUTOORDER            3254
#define IDR_TABORDERDLG             3255
#define IDR_TABORDERMOVELBL         3256

//+----------------------------------------------------------------------------
//
// HTML Block Format String
//
//-----------------------------------------------------------------------------

#define IDS_BLOCKFMT_NORMAL    1000
#define IDS_BLOCKFMT_PRE       1001
#define IDS_BLOCKFMT_ADDRESS   1002
#define IDS_BLOCKFMT_H1        1003
#define IDS_BLOCKFMT_H2        1004
#define IDS_BLOCKFMT_H3        1005
#define IDS_BLOCKFMT_H4        1006
#define IDS_BLOCKFMT_H5        1007
#define IDS_BLOCKFMT_H6        1008
#define IDS_BLOCKFMT_OL        1009
#define IDS_BLOCKFMT_UL        1010
#define IDS_BLOCKFMT_DIR       1011
#define IDS_BLOCKFMT_MENU      1012
#define IDS_BLOCKFMT_DT        1013
#define IDS_BLOCKFMT_DD        1014
#define IDS_BLOCKFMT_P         1016

#define IDS_HELPABOUT_STRING   1017
#define IDS_URLAUTODETECTOR_QUOTE_MSG 1018

#define IDS_BEGIN_DELIMITER                     1033
#define IDS_END_DELIMITER                       1034
#define IDS_END_LINE_DELIMITER                  1035

//+----------------------------------------------------------------------------
//
// default title caption for untitled HTML documents
//
//-----------------------------------------------------------------------------

#define IDS_NULL_TITLE         1020

#pragma INCMSG("--- End 'corerc.h'")
#else
#pragma INCMSG("*** Dup 'corerc.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\coreguid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       coreguid.h
//
//  Contents:   extern references for forms guids
//
//----------------------------------------------------------------------------

// Please check \forms3\src\site\include\siteguid.h for information about GUID

#ifndef I_COREGUID_H_
#define I_COREGUID_H_
#pragma INCMSG("--- Beg 'coreguid.h'")

// TODO delete these. should be getting from public headers.
EXTERN_C const GUID CGID_ShellDocView;
EXTERN_C const GUID IID_IBrowseControl;
EXTERN_C const GUID IID_ITargetFrame2;
EXTERN_C const GUID CGID_MSHTML;

// Use PUBLIC_GUID for GUIDs used outside FORMS3.DLL.
// Use PRIVATE_GUID for all other GUIDS.

#ifndef PUBLIC_GUID
#define PUBLIC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

#ifndef PRIVATE_GUID
#define PRIVATE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

// GUID from classic MSHTML
PRIVATE_GUID(CGID_IWebBrowserPriv, 0xED016940L,0xBD5B,0x11cf, 0xBA,0x4E,0x00,0xC0,0x4F,0xD7,0x08,0x16)

// private GUID used by IOleCommandTarget support in CBaseBag
//
PRIVATE_GUID(CGID_DATAOBJECTEXEC, 0x3050f3e4L,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b)

// GUID for private command group in CElement::Exec
PRIVATE_GUID(CGID_ProtectedElementPrivate, 0x3050f6dd, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

// VARIANT conversion interface exposed by script engines (VBScript/JScript).
PUBLIC_GUID(SID_VariantConversion,  0x1f101481, 0xbccd, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9)

// Service GUID to return a pointer to the scoped obect, used in IObjectIdentity impls
PUBLIC_GUID(SID_ELEMENT_SCOPE_OBJECT, 0x3050f408,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b)

// CLSID to create the default recalc engine
PUBLIC_GUID(CLSID_CRecalcEngine, 0x3050f499, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

// CLSID for CBase (needed to allow the document to go from a IUnknown to a CBase
PUBLIC_GUID(CLSID_CBase, 0x3050f49a, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

// ********************** DO NOT REMOVE the below GUID. **********************
//
// IE4 shipped the interface IHTMLControlElementEvents with the same GUID as IControlEvents
// from forms^3 this is of course bad.  To resolve this problem Trident's
// GUID for IHTMLControlElementEvents has changed however, the old GUID remembered in
// the FindConnectionPt.  The only side affect is that using the old GUID will not marshall
// the interface correctly only the new GUID has the correct marshalling code.

// {9A4BBF53-4E46-101B-8BBD-00AA003E3B29}
PRIVATE_GUID(IID_IControlEvents, 0x9A4BBF53, 0x4E46, 0x101B, 0x8B, 0xBD, 0x00, 0xAA, 0x00, 0x3E, 0x3B, 0x29)

#pragma INCMSG("--- End 'coreguid.h'")
#else
#pragma INCMSG("*** Dup 'coreguid.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\empty.cxx ===
#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\dithers.h ===
#ifndef I_DITHERS_H_
#define I_DITHERS_H_
#pragma INCMSG("--- Beg 'dithers.h'")

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Dithering stuff.
//
// This code implements error-diffusion to an arbitrary set of colors,
// optionally with transparency.  Since the output colors can be arbitrary,
// the color picker for the dither is a 32k inverse-mapping table.  24bpp
// values are whacked down to 16bpp (555) and used as indices into the table.
// To compensate for posterization effects when converting 24bpp to 16bpp, an
// ordered dither (16bpp halftone) is used to generate the 555 color.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    int r, g, b;

} ERRBUF;

__inline size_t ErrbufBytes(size_t pels)
{
    return (pels + 2) * sizeof(ERRBUF);
}

///////////////////////////////////////////////////////////////////////////////

void Dith8to8(BYTE *dst, const BYTE *src, int dst_next_scan, int src_next_scan,
    const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT, const BYTE *map,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy);

void Convert8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap, UINT x, 
   UINT nWidth, UINT y, int nHeight );

void DithGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap,
   ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, UINT cx, UINT y, 
   int cy );

void ConvertGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, 
   int nHeight );

void DithGray8to1( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, ERRBUF* pCurrentError, ERRBUF* pNextError, 
   UINT x, UINT cx, UINT y, int cy );

void Dith8to8t(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y,
    int cy, BYTE indexTxpOUT, BYTE indexTxpIN);

void Dith8to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy);

void Dith8to16t(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy, WORD wColorTxpOUT, BYTE indexTxpIN);

void Dith24to8(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy);

void Dith24rto8(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy);

void Dith24rto1(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, 
    UINT x, UINT cx, UINT y, int cy);

void Convert24to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, 
   int nHeight );

void Dith24to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy);

void Dith24rto15(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy);

void Dith24rto16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy);

void Convert24rto15(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, UINT x, UINT cx, UINT y, int cy);

void Convert24rto16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, UINT x, UINT cx, UINT y, int cy);

void DithGray8to15( WORD* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, 
   UINT cx, UINT y, int cy );

void DithGray8to16( WORD* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, 
   UINT cx, UINT y, int cy );

HRESULT DitherTo8(  BYTE * pDestBits, LONG nDestPitch, 
                    BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc, 
                    RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                    BYTE * pbDestInvMap,
                    LONG x, LONG y, LONG cx, LONG cy,
                    LONG lDestTrans, LONG lSrcTrans);

HRESULT AllocDitherBuffers(LONG cx, ERRBUF **ppBuf1, ERRBUF **ppBuf2);

void FreeDitherBuffers(ERRBUF *pBuf1, ERRBUF *pBuf2);

///////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

#pragma INCMSG("--- End 'dithers.h'")
#else
#pragma INCMSG("*** Dup 'dithers.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\mfmwrap.h ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1995, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         MFmWrap.h
//
// Contents     Interface definition for Mac Unicode-friendly Forms Wrapper 
//              Interfaces
//
// Interfaces   CControlMac
//              
//
// Note:        These class definitions are required to convert internal
//              UNICODE strings to ANSI strings before passing them on to
//              the appropriate Mac Forms superclass method. By defining
//              the interface name as our subclass wrapper, the main body of
//              code does not need to concern itself with UNICODE vs ANSI -
//              the code will call the correct method.
//
//	History:	02/07/96    Created by kfl / black diamond.
//
//-----------------------------------------------------------------------------

#ifndef I_MFMWRAP_HXX_
#define I_MFMWRAP_HXX_
#pragma INCMSG("--- Beg 'mfmwrap.hxx'")

// Note:        The following typedefs are required by the Mac 
//              Unicode wrapper classes.  MFmWrap #defines
//              some of the forms interfaces so that the main body 
//              of code will use the wrapper classes instead of the
//              original forms interface.  However, in order to not 
//              have to wrap any method that refers to a pointer
//              to the wrapped interface, we need a way to reference
//              the original interface - thus the need for the pointer
//              typedef.
//

interface IControls;
typedef IControls *             LPCONTROLS;

#  if defined(_MACUNICODE) && !defined(_MAC)
// the rest of the code will only be used for Mac UNICODE  implementations
STDAPI FormsCreatePropertyFrameW(
            HWND        hwndOwner,
            UINT        x,
            UINT        y,
      const LPWSTR      lpszCaption,
            ULONG       cObjects,
            IUnknown**  ppunk,
            ULONG       cPages,
      const CLSID *     pPageClsID,
            LCID        lcid);
#define   FormsCreatePropertyFrame   FormsCreatePropertyFrameW

/*
STDAPI FormsOpenReadOnlyStorageOnResourceW(
    HINSTANCE hInst, LPCWSTR lpstrID, LPSTORAGE * ppStg);
#define   FormsOpenReadOnlyStorageOnResource   FormsOpenReadOnlyStorageOnResourceW
*/
#ifdef PRODUCT_97
//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
interface ITextBox95Mac : public ITextBox95
{
public:
    operator ITextBox95* () { return this; }

    virtual HRESULT __stdcall SetPasswordChar( 
        /* [in] */ OLECHAR wchar);
    virtual HRESULT __stdcall SetPasswordChar( 
        /* [in] */ WCHAR wchar) = 0;
    
    
    virtual HRESULT __stdcall GetPasswordChar( 
        /* [out] */ OLECHAR *wchar);
    virtual HRESULT __stdcall GetPasswordChar( 
        /* [out] */ WCHAR *wchar) = 0;
};
#define ITextBox95                    ITextBox95Mac
#endif  // PRODUCT_97

//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface IControlSelectorEventsMac : public IControlSelectorEvents
{
public:
    operator IControlSelectorEvents* () { return this; }

    virtual HRESULT __stdcall SelectionChange( 
        /* [in] */ REFCLSID clsid,
        /* [in] */ OLECHAR *szTooltip);
    
    virtual HRESULT __stdcall SelectionChange( 
        /* [in] */ REFCLSID clsid,
        /* [in] */ WCHAR *szTooltip) = 0;
};
#define IControlSelectorEvents                    IControlSelectorEventsMac


//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface IControlsMac : public IControls
{
public:
    operator IControls* () { return this; }

        virtual HRESULT __stdcall GetItemByName( 
            /* [in] */ LPCOLESTR pstr,
            /* [out] */ IControl **Control);
        
        virtual HRESULT __stdcall GetItemByName( 
            /* [in] */ LPCWSTR pstr,
            /* [out] */ IControl **Control) = 0;
        
};
#define IControls                    IControlsMac

//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface IControlPaletteEventsMac : public IControlPaletteEvents
{
public:
    operator IControlPaletteEvents* () { return this; }

        virtual HRESULT __stdcall SelectionChange( 
            /* [in] */ REFCLSID clsid,
            /* [in] */ LPOLESTR szTooltip);
        virtual HRESULT __stdcall SelectionChange( 
            /* [in] */ REFCLSID clsid,
            /* [in] */ LPWSTR szTooltip) = 0;
};
#define IControlPaletteEvents        IControlPaletteEventsMac

//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface IControlPaletteMac : public IControlPalette
{
public:
    operator IControlPalette* () { return this; }

        virtual HRESULT __stdcall AddPage( 
            /* [in] */ IStorage *pStg,
            /* [in] */ LPOLESTR szName,
            /* [out] */ long *plIndex);
        virtual HRESULT __stdcall AddPage( 
            /* [in] */ IStorage * pStg,
            /* [in] */ LPWSTR szName,
            /* [out] */ long *plIndex) = 0;
        
        
        virtual HRESULT __stdcall InsertPage( 
            /* [in] */ IStorage *pStg,
            /* [in] */ LPOLESTR szName,
            /* [in] */ long lIndex);
        
        virtual HRESULT __stdcall InsertPage( 
            /* [in] */ IStorage * pStg,
            /* [in] */ LPWSTR szName,
            /* [in] */ long lIndex) = 0;
        
};
#define IControlPalette        IControlPaletteMac

//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface IGetUniqueIDMac : public IGetUniqueID
{
public:
    operator IGetUniqueID* () { return this; }

        virtual HRESULT __stdcall GetUniqueName( 
            /* [in] */ LPWSTR pstrPrefix,
            /* [in] */ LPWSTR pstrSuggestedName,
            /* [out][in] */ ULONG *pulSuffix,
            /* [in] */ BOOL fAllowDupeCheck) = 0;
        virtual HRESULT __stdcall GetUniqueName( 
            /* [in] */ LPOLESTR pstrPrefix,
            /* [in] */ LPOLESTR pstrSuggestedName,
            /* [out][in] */ ULONG *pulSuffix,
            /* [in] */ BOOL fAllowDupeCheck);
};
#define IGetUniqueID                IGetUniqueIDMac

//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface ITabStripExpertEventsMac : public ITabStripExpertEvents
{
public:
    operator ITabStripExpertEvents* () { return this; }

        virtual HRESULT __stdcall DoRenameItem( 
            /* [in] */ long lIndex,
            /* [in] */ LPOLESTR bstr,
            /* [in] */ LPOLESTR bstrTip,
            /* [in] */ LPOLESTR bstrAccel,
            /* [out][in] */ VARIANT_BOOL *EnableDefault);
        virtual HRESULT __stdcall DoRenameItem( 
            /* [in] */ long lIndex,
            /* [in] */ LPWSTR bstr,
            /* [in] */ LPWSTR bstrTip,
            /* [in] */ LPWSTR bstrAccel,
            /* [out][in] */ VARIANT_BOOL *EnableDefault) = 0;
};

interface ITabStripExpertMac : public ITabStripExpert
{
public:
    operator ITabStripExpert* () { return this; }

        virtual HRESULT __stdcall SetTabStripExpertEvents( 
            ITabStripExpertEventsMac *pTabStripExpertEvents)  = 0;
        virtual HRESULT __stdcall SetTabStripExpertEvents( 
            ITabStripExpertEvents *pTabStripExpertEvents) 
        { return  SetTabStripExpertEvents ((ITabStripExpertEventsMac*)pTabStripExpertEvents);  }
};
#define ITabStripExpert                ITabStripExpertMac
#define ITabStripExpertEvents          ITabStripExpertEventsMac

#endif // _MACUNICODE

#pragma INCMSG("--- End 'mfmwrap.hxx'")
#else
#pragma INCMSG("*** Dup 'mfmwrap.hxx'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\f3debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
// File:      F3DEBUG.H
//
// Contains:  Debugging stuff for use in Forms^3
//            See CORE\DEBUG\F3DEBUG.TXT for more information.
//
//--------------------------------------------------------------------------

#ifndef I_F3DEBUG_H_
#define I_F3DEBUG_H_
#pragma INCMSG("--- Beg 'f3debug.h'")

#ifndef X_MSHTMDBG_H_
#define X_MSHTMDBG_H_
#pragma INCMSG("--- Beg <mshtmdbg.h>")
#include <mshtmdbg.h>
#pragma INCMSG("--- End <mshtmdbg.h>")
#endif

#ifndef X_MARKCODE_HXX_
#define X_MARKCODE_HXX_
#pragma INCMSG("--- Beg 'markcode.hxx'")
#include "markcode.hxx"
#pragma INCMSG("--- End 'markcode.hxx'")
#endif

//--------------------------------------------------------------------------
// Assert, Verify && WHEN_DBG
//--------------------------------------------------------------------------

#if defined(_M_IX86)
    #define F3DebugBreak() _asm { int 3 }
#else
    #define F3DebugBreak() DebugBreak()
#endif

#if DBG != 1 && HTMLPAD != 1

#define Verify(x)   x
#ifdef _PREFIX_
#define Assert(x) { if ( !(x) ) exit(1); }
#else
#define Assert(x)
#endif
#ifdef _PREFIX_
#define AssertSz(x, sz) { if ( !(x) ) exit(1); }
#else
#define AssertSz(x, sz)
#endif
#define Check(x)
#define CheckSz(x, sz)
#define IF_DBG(x)
#define WHEN_DBG(x)
#define IF_NOT_DBG(x) x
#define WHEN_NOT_DBG(x) x
#define StartupAssert(x)
#define AssertThreadDisable(fb)
#define DBG_COMMA


#else // #if DBG != 1

struct THREADSTATE;

#define AssertThreadDisable(fDisable)   DbgExAssertThreadDisable(fDisable)

extern DWORD g_dwFALSE;

#define Verify(x)       Assert(x)

// Note: For PREFIX runs, we need to make the compiler believe that we're going to exit upon a false Assert.
//       To do this, we redefine the Assert() and AssertSz() macros when _PREFIX_ is defined.
//

#ifdef _PREFIX_
#define Assert(x) { if ( !(x) ) exit(1); }
#else
#define Assert(x)       do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, #x)) {\
                               F3DebugBreak(); }} while (g_dwFALSE)
#endif

#ifdef _PREFIX_
#define AssertSz(x, sz) { if ( !(x) ) exit(1); }
#else
#define AssertSz(x, sz) do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, sz)) {\
                               F3DebugBreak(); }} while (g_dwFALSE)
#endif

#ifdef _PREFIX_
#define Check(x) 
#else
#define Check(x)       do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, #x) && DbgExIsFullDebug()) {\
                               F3DebugBreak(); }} while (g_dwFALSE)
#endif

#ifdef _PREFIX_
#define CheckSz(x, sz) 
#else
#define CheckSz(x, sz) do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, sz) && DbgExIsFullDebug()) {\
                               F3DebugBreak(); }} while (g_dwFALSE)
#endif

#define AssertLocSz(x, File, Line, sz)   do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(File, Line, sz)) {\
                               F3DebugBreak(); }} while (g_dwFALSE)
#define IF_DBG(x) x
#define WHEN_DBG(x) x
#define IF_NOT_DBG(x)
#define WHEN_NOT_DBG(x)
#define DBG_COMMA ,

//
// Startup assertion:
// The assertion is called by initializing a global variable with
// a function that performs the assertion and returns 1. The name
// of the global variable and function name are suffixed with the
// line number to make them unique. Unfortunatly, one cannot just
// write StartupAssert_##__LINE__, because __LINE__ is not an
// argument to the macro and so the expansion is, e.g. StartupAssert__##53.
// So we indirect through another macro which concatenates its
// two arguments.
//

#define concat_name(x, y) x##y
#define concat_line_impl(x, y) concat_name(x, y)
#define concat_LINE(x) concat_line_impl(x, __LINE__)

#define StartupAssert(x)                                                    \
static int                                                                  \
concat_LINE(StartupAssert_) ()                                              \
{                                                                           \
    Assert(x);                                                              \
    return 1;                                                               \
}                                                                           \
                                                                            \
static int concat_LINE(g_StartupAssert_) = concat_LINE(StartupAssert_)()    \

#endif // #if DBG != 1

//--------------------------------------------------------------------------
// Trace Tags
//--------------------------------------------------------------------------

#if DBG != 1 && HTMLPAD != 1
    #define TraceTag(x)
    #define TraceTagEx(x)
    #define TaggedTraceListEx(tag, usFlags, szFmt, valMarker)
    #define TraceCallers(tag, iStart, cTotal)
    #define DeclareTag(tag, szOwner, szDescription)
    #define DeclareTagEx(tag, szOwner, szDescription, fEnabled)
    #define DeclareTagOther(tag, szOwner, szDescription)
    #define ExternTag(tag)
    #define IsTagEnabled(tag) FALSE
    #define EnableTag(tag, fEnable)
    #define SetDiskFlag(tag, fSendToDisk)
    #define SetBreakFlag(tag, fBreak)
    #define FindTag(szTagDesc) NULL
    #define PerfDbgTag(tag, szOwner, szDescrip) \
            PerfTag(tag, szOwner, szDescrip)
    #define PerfDbgTagOther(tag, szOwner, szDescrip) \
            PerfTag(tag, szOwner, szDescrip)
    #define PerfDbgExtern(tag) \
            PerfExtern(tag)
    #define PerfDbgLog(tag,pv,f) PerfLog(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) PerfLog1(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) PerfLog2(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) PerfLog3(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) PerfLog4(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfLogFn x
    #define IsPerfDbgEnabled(tag) IsPerfEnabled(tag)

#else
    #define TraceTag(x)                         \
        do                                      \
        {                                       \
            if (TaggedTrace x) {                \
                F3DebugBreak();                 \
            }                                   \
        } while  (g_dwFALSE)

    #define TraceTagEx(x)                       \
        do                                      \
        {                                       \
            if (TaggedTraceEx x) {              \
                F3DebugBreak();                 \
            }                                   \
        } while  (g_dwFALSE)

    #define TraceCallers(tag, iStart, cTotal)   \
        TaggedTraceCallers(tag, iStart, cTotal)
    #define DeclareTag(tag, szOwner, szDescrip) \
        TRACETAG tag(DbgExTagRegisterTrace(szOwner, szDescrip, FALSE));
    #define DeclareTagEx(tag, szOwner, szDescrip, fEnabled) \
        TRACETAG tag(DbgExTagRegisterTrace(szOwner, szDescrip, fEnabled));
    #define DeclareTagOther(tag, szOwner, szDescrip) \
        TRACETAG tag(DbgExTagRegisterOther(szOwner, szDescrip, FALSE));
    #define ExternTag(tag) extern TRACETAG tag;
    #define PerfDbgTag(tag, szOwner, szDescrip) DeclareTag(tag, szOwner, szDescrip)
    #define PerfDbgTagOther(tag, szOwner, szDescrip) DeclareTagOther(tag, szOwner, szDescrip)
    #define PerfDbgExtern(tag) ExternTag(tag)
    #define PerfDbgLog(tag,pv,f) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfDbgLogFn x
    #define IsPerfDbgEnabled(tag) IsTagEnabled(tag)

    int __cdecl PerfDbgLogFn(int tag, void * pvObj, char * pchFmt, ...);

    // Tag trace functions

    #define TaggedTrace         DbgExTaggedTrace
    #define TaggedTraceEx       DbgExTaggedTraceEx
    #define TaggedTraceListEx   DbgExTaggedTraceListEx
    #define TaggedTraceCallers  DbgExTaggedTraceCallers

    // TaggedTraceEx usFlags parameter defines

    #define TAG_NONAME      0x01
    #define TAG_NONEWLINE   0x02
    #define TAG_USECONSOLE  0x04
    #define TAG_INDENT      0x08
    #define TAG_OUTDENT     0x10

    // Register a new tag.

    // Standard tags
    #define tagError                DbgExTagError()
    #define tagWarning              DbgExTagWarning()
    #define tagThread               DbgExTagThread()
    #define tagAssertExit           DbgExTagAssertExit()
    #define tagAssertStacks         DbgExTagAssertStacks()
    #define tagMemoryStrict         DbgExTagMemoryStrict()
    #define tagCoMemoryStrict       DbgExTagCoMemoryStrict()
    #define tagMemoryStrictTail     DbgExTagMemoryStrictTail()
    #define tagMemoryStrictAlign    DbgExTagMemoryStrictAlign()
    #define tagOLEWatch             DbgExTagOLEWatch()
    #define tagPerf                 DbgExTagPerf()

    // Get/Set tag enabled status.

    #define IsTagEnabled            DbgExIsTagEnabled
    #define EnableTag               DbgExEnableTag
    #define SetDiskFlag             DbgExSetDiskFlag
    #define SetBreakFlag            DbgExSetBreakFlag
    #define FindTag                 DbgExFindTag

#endif

//--------------------------------------------------------------------------
// Memory Allocation
//--------------------------------------------------------------------------

#if DBG != 1 && HTMLPAD != 1

    #define DbgPreAlloc(cb)             cb
    #define DbgPostAlloc(pv)            pv
    #define DbgPreFree(pv)              pv
    #define DbgPostFree()
    #define DbgPreRealloc(pv, cb, ppv)  cb
    #define DbgPostRealloc(pv)          pv
    #define DbgPreGetSize(pv)           pv
    #define DbgPostGetSize(cb)          cb
    #define DbgPreDidAlloc(pv)          pv
    #define DbgPostDidAlloc(pv, fAct)   fAct

    #define DbgMemoryTrackDisable(fb)
    #define DbgCoMemoryTrackDisable(fb)
    #define DbgMemoryBlockTrackDisable(pv)

    #define CHECK_HEAP()

#else

    #define DbgPreAlloc                 DbgExPreAlloc
    #define DbgPostAlloc                DbgExPostAlloc
    #define DbgPreFree                  DbgExPreFree
    #define DbgPostFree                 DbgExPostFree
    #define DbgPreRealloc               DbgExPreRealloc
    #define DbgPostRealloc              DbgExPostRealloc
    #define DbgPreGetSize               DbgExPreGetSize
    #define DbgPostGetSize              DbgExPostGetSize
    #define DbgPreDidAlloc              DbgExPreDidAlloc
    #define DbgPostDidAlloc             DbgExPostDidAlloc

    #define DbgMemoryTrackDisable       DbgExMemoryTrackDisable
    #define DbgCoMemoryTrackDisable     DbgExCoMemoryTrackDisable
    #define DbgMemoryBlockTrackDisable  DbgExMemoryBlockTrackDisable

    //
    // Use the CHECK_HEAP macro to do thorough heap validation.
    //
    BOOL CheckSmallBlockHeap();
    void WINAPI DbgExCheckHeap();
    #define CHECK_HEAP()                DbgExCheckHeap();

#endif


//+---------------------------------------------------------------------
//  Interface tracing.
//----------------------------------------------------------------------

#if DBG == 1 || HTMLPAD == 1
    #define DbgTrackItf     DbgExTrackItf
#else
    #define DbgTrackItf(iid, pch, fTrackOnQi, ppv)
#endif

//--------------------------------------------------------------------------
// Failure testing
//--------------------------------------------------------------------------

#if (DBG == 1 || HTMLPAD == 1) && defined(__cplusplus)

#define SetSimFailCounts    DbgExSetSimFailCounts
#define GetFailCount        DbgExGetFailCount
#define TraceFailL          DbgExTraceFailL
#define TraceWin32L         DbgExTraceWin32L
#define TraceHR             DbgExTraceHR
#define TraceOLE            DbgExTraceOLE
#define TraceEnter          DbgExTraceEnter
#define TraceExit           DbgExTraceExit

template <class t> inline t
TraceFail(t errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) DbgExTraceFailL((LONG_PTR) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

template <class t> inline t
TraceWin32(t errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) DbgExTraceWin32L((LONG_PTR) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

// disabled TraceEnter, we don't need it at this time
#undef TraceEnter
#define TraceEnter(x, y, z) NULL

#define TFAIL(e, x)             (TraceEnter(#x, __FILE__, __LINE__), TraceFail( (x), (e), FALSE, #x, __FILE__, __LINE__))
#define TW32(e, x)              (TraceEnter(#x, __FILE__, __LINE__), TraceWin32((x), (e), FALSE, #x, __FILE__, __LINE__))
#define THR(x)                  (TraceEnter(#x, __FILE__, __LINE__), TraceHR((x), FALSE, #x, __FILE__, __LINE__))

#define TFAIL_NOTRACE(e, x)     (x)
#define TW32_NOTRACE(e, x)      (x)
#define THR_NOTRACE(x)          (x)

#define IGNORE_FAIL(e, x)       (TraceEnter(#x, __FILE__, __LINE__), (void) TraceFail((x), (e), TRUE, #x, __FILE__, __LINE__))
#define IGNORE_W32(e,x)         (TraceEnter(#x, __FILE__, __LINE__), (void) TraceWin32((x), (e), TRUE, #x, __FILE__, __LINE__))
#define IGNORE_HR(x)            (TraceEnter(#x, __FILE__, __LINE__), (void) TraceHR((x), TRUE, #x, __FILE__, __LINE__))

#else // #if DBG == 1

#define SetSimFailCounts(firstFailure, cInterval)

#define TFAIL(e, x)             (x)
#define TW32(e, x)              (x)
#define THR(x)                  (x)

#define TFAIL_NOTRACE(e, x)     (x)
#define TW32_NOTRACE(e, x)      (x)
#define THR_NOTRACE(x)          (x)

#define IGNORE_FAIL(e, x)       (x)
#define IGNORE_W32(e,x)         (x)
#define IGNORE_HR(x)            (x)

#endif // #if DBG == 1

//+-------------------------------------------------------------------------
//  Return tracing
//--------------------------------------------------------------------------

#if DBG == 1 || HTMLPAD == 1

    #define SRETURN(hr) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, -1)
    #define RRETURN(hr) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 0)
    #define RRETURN1(hr, s1) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2(hr, s1, s2) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3(hr, s1, s2, s3) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 3, (s1), (s2), (s3))
    #define RRETURN4(hr, s1, s2, s3, s4) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 4, (s1), (s2), (s3), (s4))

    #define SRETURN_NOTRACE(hr) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, -1)
    #define RRETURN_NOTRACE(hr) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 0)
    #define RRETURN1_NOTRACE(hr, s1) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2_NOTRACE(hr, s1, s2) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3_NOTRACE(hr, s1, s2, s3) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 3, (s1), (s2), (s3))
    #define RRETURN4_NOTRACE(hr, s1, s2, s3, s4) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 4, (s1), (s2), (s3), (s4))

#else   // DBG == 0

    #define SRETURN(hr)                 return (hr)
    #define RRETURN(hr)                 return (hr)
    #define RRETURN1(hr, s1)            return (hr)
    #define RRETURN2(hr, s1, s2)        return (hr)
    #define RRETURN3(hr, s1, s2, s3)    return (hr)
    #define RRETURN4(hr, s1, s2, s3, s4)return (hr)

    #define SRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN1_NOTRACE(hr, s1)            return (hr)
    #define RRETURN2_NOTRACE(hr, s1, s2)        return (hr)
    #define RRETURN3_NOTRACE(hr, s1, s2, s3)    return (hr)
    #define RRETURN4_NOTRACE(hr, s1, s2, s3, s4)return (hr)

#endif  // DBG

//+-------------------------------------------------------------------------
//  Stack Spew
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

#pragma INCMSG("--- End 'f3debug.h'")
#else
#pragma INCMSG("*** Dup 'f3debug.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\platrisc.h ===
//+---------------------------------------------------------------------------
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       src\core\include\platrisc.h
//
//  Contents:   header file containing inline declarations for all Win95
//              functions used in Forms^3.  For RISC platforms ONLY.
//
//  History:    02-Nov-94   SumitC      Created
//
//----------------------------------------------------------------------------

#ifndef I_PLATRISC_H_
#define I_PLATRISC_H_
#pragma INCMSG("--- Beg 'platrisc.h'")

//
//  Definitions for the init and uninit functions.  These are to be called
//  as the first thing during DLL attach and the last thing during DLL detach,
//  respectively.
//
void InitWrappers();
void DeinitWrappers();


// definitions for all non-Intel platforms, i.e. MIPS, Alpha, PowerPC etc.

extern DWORD g_dwPlatformVersion;   // (dwMajorVersion << 16) + (dwMinorVersion)
extern DWORD g_dwPlatformID;        // VER_PLATFORM_WIN32S/WIN32_WINDOWS/WIN32_WINNT
extern BOOL g_fUnicodePlatform;

// All such platforms are Unicode-only, so there is no need for the Unicode
// wrapper functions.


#pragma INCMSG("--- End 'platrisc.h'")
#else
#pragma INCMSG("*** Dup 'platrisc.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\mstdwrap.h ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1995, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         MStdWrap.h
//
// Contents     Class definition for Mac Unicode-friendly Standard Wrapper 
//              Interfaces
//
//              
//
// Note:        These subclass definitions are required to convert internal
//              UNICODE strings to ANSI strings before passing them on to
//              the appropriate Mac Forms superclass method. By defining
//              the interface name as our subclass wrapper, the main body of
//              code does not need to concern itself with UNICODE vs ANSI -
//              the code will call the correct method.
//
//	History:	02/07/96    Created by kfl / black diamond.
//
//-----------------------------------------------------------------------------

#ifndef I_MSTDWRAP_HXX_
#define I_MSTDWRAP_HXX_
#pragma INCMSG("--- Beg 'mstdwrap.h'")

#if defined(_MACUNICODE) && !defined(_MAC)

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
interface IForms96BinderDispenserMac : public IForms96BinderDispenser
{
public:
    operator IForms96BinderDispenser* () { return this; }


        virtual HRESULT __stdcall ParseName( 
            /* [in] */ OLECHAR *pszName,
            /* [out] */ IForms96Binder **ppBinder);

        virtual HRESULT __stdcall ParseName( 
            /* [in] */ WCHAR *pszName,
            /* [out] */ IForms96Binder **ppBinder) = 0;


};
#define IForms96BinderDispenser                    IForms96BinderDispenserMac

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
interface ISimpleTabularDataMac : public ISimpleTabularData
{
public:
    operator ISimpleTabularData* () { return this; }

    virtual HRESULT __stdcall GetString( 
            /* [in] */ ULONG iRow,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [out] */ OLECHAR *pchBuf,
            /* [out] */ ULONG *pcchActual);
        virtual HRESULT __stdcall GetString( 
            /* [in] */ ULONG iRow,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [out] */ WCHAR *pchBuf,
            /* [out] */ ULONG *pcchActual) = 0;
        
        virtual HRESULT __stdcall SetString( 
            /* [in] */ ULONG iRow,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [in] */ OLECHAR *pchBuf);
        virtual HRESULT __stdcall SetString( 
            /* [in] */ ULONG iRow,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [in] */ WCHAR *pchBuf) = 0;

        virtual HRESULT __stdcall FindPrefixString( 
            /* [in] */ ULONG iRowStart,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [in] */ OLECHAR *pchBuf,
            /* [in] */ DWORD findFlags,
            /* [out] */ STDFIND *foundFlag,
            /* [out] */ ULONG *piRowFound);
        virtual HRESULT __stdcall FindPrefixString( 
            /* [in] */ ULONG iRowStart,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [in] */ WCHAR *pchBuf,
            /* [in] */ DWORD findFlags,
            /* [out] */ STDFIND *foundFlag,
            /* [out] */ ULONG *piRowFound) = 0;
};
#define ISimpleTabularData                    ISimpleTabularDataMac



#endif // _MACUNICODE

#pragma INCMSG("--- End 'mstdwrap.h'")
#else
#pragma INCMSG("*** Dup 'mstdwrap.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\privcid.h ===
#ifndef I_PRIVCID_H_
#define I_PRIVCID_H_
#ifndef RC_INVOKED
#pragma INCMSG("--- Beg 'privcid.h'")
#endif

#ifndef X_MSHTMCID_H_
#define X_MSHTMCID_H_
#include "mshtmcid.h"
#endif

//----------------------------------------------------------------------------
//
// Private Command IDs.
//
//----------------------------------------------------------------------------

#define IDM_TABKEY                  6000
#define IDM_SHTABKEY                6001
#define IDM_RETURNKEY               6002
#define IDM_ESCKEY                  6003

#if DBG == 1
// dependencies - shdocvw\resource.h
#define IDM_DEBUG_TRACETAGS         6004
#define IDM_DEBUG_RESFAIL           6005
#define IDM_DEBUG_DUMPOTRACK        6006
#define IDM_DEBUG_BREAK             6007
#define IDM_DEBUG_VIEW              6008
#define IDM_DEBUG_DUMPTREE          6009
#define IDM_DEBUG_DUMPLINES         6010
#define IDM_DEBUG_LOADHTML          6011
#define IDM_DEBUG_SAVEHTML          6012
#define IDM_DEBUG_MEMMON            6013
#define IDM_DEBUG_METERS            6014
#define IDM_DEBUG_DUMPDISPLAYTREE   6015
#define IDM_DEBUG_DUMPFORMATCACHES  6016
#define IDM_DEBUG_DUMPLAYOUTRECTS   6017
#define IDM_DEBUG_DUMPRECALC        6018
#endif

// IE4 Shdocvw Messages

#define IDM_SHDV_FINALTITLEAVAIL         6020
#define IDM_SHDV_MIMECSETMENUOPEN        6021
#define IDM_SHDV_PRINTFRAME              6022
#define IDM_SHDV_PUTOFFLINE              6022
#define IDM_SHDV_GOBACK                  6024   // different from IDM_GOBACK
#define IDM_SHDV_GOFORWARD               6025   // different from ISM_GOFORWARD
#define IDM_SHDV_CANGOBACK               6026
#define IDM_SHDV_CANGOFORWARD            6027
#define IDM_SHDV_CANSUPPORTPICS          6028
#define IDM_SHDV_CANDEACTIVATENOW        6029
#define IDM_SHDV_DEACTIVATEMENOW         6030
#define IDM_SHDV_NODEACTIVATENOW         6031
#define IDM_SHDV_SETPENDINGURL           6032
#define IDM_SHDV_ISDRAGSOURCE            6033
#define IDM_SHDV_DOCFAMILYCHARSET        6034
#define IDM_SHDV_DOCCHARSET              6035
#define IDM_SHDV_GETMIMECSETMENU         6036
#define IDM_SHDV_CANDOCOLORSCHANGE       6038
#define IDM_SHDV_ONCOLORSCHANGE                  6039

// Flavors of refresh

#define IDM_REFRESH_TOP                  6041   // Normal refresh, topmost doc
#define IDM_REFRESH_THIS                 6042   // Normal refresh, nearest doc
#define IDM_REFRESH_TOP_FULL             6043   // Full refresh, topmost doc
#define IDM_REFRESH_THIS_FULL            6044   // Full refresh, nearest doc

// placeholder for context menu extensions
#define IDM_MENUEXT_PLACEHOLDER          6047

// IE5 Webcheck messages
#define IDM_DWNH_SETDOWNLOAD             6048

// IE5 Shdocvw messages
#define IDM_ONPERSISTSHORTCUT            6050
#define IDM_SHDV_GETFONTMENU             6051
#define IDM_SHDV_FONTMENUOPEN            6052
#define IDM_SAVEASTHICKET                6053
#define IDM_SHDV_GETDOCDIRMENU           6054
#define IDM_SHDV_ADDMENUEXTENSIONS       6055
#define IDM_SHDV_PAGEFROMPOSTDATA        6056
#define IDM_SHDV_WINDOWOPEN              6057

#define IDM_GETSWITCHTIMERS              6998   // Used by MSHTMPAD for perf timings
#define IDM_WAITFORRECALC                6999   // Used by MSHTMPAD for perf timings

// JuliaC -- This is hack for InfoViewer's "Font Size" toolbar button
// For details, please see bug 45627
#define IDM_INFOVIEW_ZOOM                7000
#define IDM_INFOVIEW_GETZOOMRANGE        7001

#define IDM_ELEMENTP_SETREFERENCEMEDIA   7002   // set media on element

// IOleCommandTarget IDs
#define IDM_GETPUNKCONTROL               6048

// Reserve this range for Shdocvw's usage of CGID_DocHostCommandHandler
#define IDM_SHDOCVWDHCOMMAND_START       7050
#define IDM_SHDOCVWDHCOMMAND_END         7099

// Debug-only command for saving a document out to a stream
#if DBG==1
#define IDM_DEBUG_GETTREETEXT            7102
#endif

#ifndef RC_INVOKED
#pragma INCMSG("--- End 'privcid.h'")
#endif
#else
#ifndef RC_INVOKED
#pragma INCMSG("*** Dup 'privcid.h'")
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\shell.h ===
#ifndef I_SHELL_H_
#define I_SHELL_H_
#pragma INCMSG("--- Beg 'shell.h'")

#ifndef X_SHLOBJ_H_
#define X_SHLOBJ_H_
#include <shlobj.h>
#endif

#ifndef X_SHLOBJP_H_
#define X_SHLOBJP_H_
#include <shlobjp.h>
#endif

#pragma INCMSG("--- End 'shell.h'")
#else
#pragma INCMSG("*** Dup 'shell.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\w4warn.h ===
/*----------------------------------------------------------------------------
*  Note that we don't want to use a single line comment before the warning is
*   disabled.
*
*   Microsoft Windows
*   Copyright (C) Microsoft Corporation, 1992 - 1994.
*
*   File:       w4warn.h
*
*   Contents:   #pragmas to adjust warning levels.
*
*---------------------------------------------------------------------------*/

/*
 *   Level 4 warnings to suppress.
 */

#pragma warning(disable:4001) /* nonstandard extension 'extension' was used                            */
#pragma warning(disable:4097) /* typedef name 'type' used as synonym for class 'class'                 */
#pragma warning(disable:4100) /* unreferenced formal parameter                                         */
#pragma warning(disable:4115) /* named type definition in parentheses                                  */
#pragma warning(disable:4134) /* conversion between pointers to members of same class                  */
#pragma warning(disable:4152) /* nonstandard extension, function/data pointer conversion in expression */
#pragma warning(disable:4200) /* nonstandard extension used : zero-sized array in struct/union         */
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union                    */
#pragma warning(disable:4204) /* nonstandard extension used : non-constant aggregate initializer       */
#pragma warning(disable:4209) /* nonstandard extension used : benign typedef redefinition              */
#pragma warning(disable:4214) /* nonstandard extension used : bit field types other than int           */
#pragma warning(disable:4505) /* unreferenced local function has been removed                          */
#pragma warning(disable:4511) /* 'class' : copy constructor could not be generated                     */
#pragma warning(disable:4512) /* 'class': assignment operator could not be generated                   */
#pragma warning(disable:4514) /* 'function' : unreferenced inline function has been removed            */
#pragma warning(disable:4552) /* operator has no effect; expected operator with side-effect            */
#pragma warning(disable:4553) /* operator has no effect; did you intend '='?                           */
#pragma warning(disable:4705) /* statement has no effect                                               */
#pragma warning(disable:4710) /* function call not expanded                                            */
#pragma warning(disable:4711) /* function 'function' selected for inline expansion                     */
#pragma warning(disable:4068) /* unknown pragma */
/*
 * Warning 4244 is benign more often than not, so if you don't want it then
 * uncomment this to filter out those errors.
 *
 */
#pragma warning(disable:4244) /* conversion from 'type' to 'type', possible loss of data               */


/*
 * This helps to track down "Illegal attempt to instantiate abstract class" messages
 */
#pragma warning(error:4259) /* pure virtual function not defined                                       */

#pragma warning(error:4102) /* 'label' : unreferenced label                                            */

/*
 *   Level 4 warnings that we want treated as level 3 warnings.
 */

#pragma warning(3:4127) /* conditional expression is constant                                          */
#pragma warning(3:4702) /* unreachable code                                                            */
#pragma warning(3:4706) /* assignment within conditional expression                                    */

#pragma warning(disable:4041) /* compiler limit reached: terminating browser output                    */

#ifdef _MAC
#pragma warning(disable:4229) /* anachronism used : modifiers on data are ignored                      */
#pragma warning(disable:4798) /* pcode: constructors and destructors have native code generated        */
#endif

#ifdef _M_IA64
#pragma warning(disable:4268) /* 'variable' : 'const' static/global data initialized with compiler generated default constructor fills the object with zeros */
#endif

#pragma warning(disable:4407) // cast between different pointer to member represenations, compiler may generate incorrect code.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\qi_impl.h ===
#ifndef I_QI_IMPL_H_
#define I_QI_IMPL_H_
#pragma INCMSG("--- Beg 'qi_impl.h'")

#define Data1_IAdviseSink                  0x0000010f
#define Data1_IAdviseSink2                 0x00000125
#define Data1_IAdviseSinkEx                0x3af24290
#define Data1_IBindCtx                     0x0000000e
#define Data1_IBindHost                    0xfc4801a1
#define Data1_IBrowserService              0x02ba3b52
#define Data1_ICDataDoc                    0xF413E4C0
#define Data1_IClassFactory                0x00000001
#define Data1_IClassFactory2               0xb196b28f
#define Data1_IConnectionPoint             0xb196b286
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_ICreateErrorInfo             0x22f03340
#define Data1_ICreateTypeInfo              0x00020405
#define Data1_ICreateTypeLib               0x00020406
#define Data1_IDataAdviseHolder            0x00000110
#define Data1_IDataObject                  0x0000010e
#define Data1_DataSource                   0x7c0ffab3
#define Data1_DataSourceListener           0x7c0ffab2
#define Data1_IDATASRCListener             0x3050f380
#define Data1_IDispatch                    0x00020400
#define Data1_IDispObserver                0x3050f442
#define Data1_IDropSource                  0x00000121
#define Data1_IDropTarget                  0x00000122
#define Data1_IEnumCallback                0x00000108
#define Data1_IEnumConnectionPoints        0xb196b285
#define Data1_IEnumConnections             0xb196b287
#define Data1_IEnumFORMATETC               0x00000103
#define Data1_IEnumGeneric                 0x00000106
#define Data1_IEnumHolder                  0x00000107
#define Data1_IEnumMoniker                 0x00000102
#define Data1_IEnumOLEVERB                 0x00000104
#define Data1_IEnumSTATDATA                0x00000105
#define Data1_IEnumSTATSTG                 0x0000000d
#define Data1_IEnumString                  0x00000101
#define Data1_IEnumOleUndoUnits            0xb3e7c340
#define Data1_IEnumUnknown                 0x00000100
#define Data1_IEnumVARIANT                 0x00020404
#define Data1_IErrorInfo                   0x1cf2b120
#define Data1_IExternalConnection          0x00000019
#define Data1_IFont                        0xbef6e002
#define Data1_IFontDisp                    0xbef6e003
#define Data1_IForm                        0x04598fc8
#define Data1_IFormExpert                  0x04598fc5
#define Data1_IGangConnectWithDefault      0x6d5140c0
#define Data1_IHlinkTarget                 0x79eac9c4
#define Data1_IInternalMoniker             0x00000011
#define Data1_ILockBytes                   0x0000000a
#define Data1_IMalloc                      0x00000002
#define Data1_IMarshal                     0x00000003
#define Data1_IMessageFilter               0x00000016
#define Data1_IMoniker                     0x0000000f
#define Data1_IMonikerProp                 0xa5ca5f7f
#define Data1_IOleCommandTarget            0xb722bccb
#define Data1_IOleDocument                 0xb722bcc5
#define Data1_IOleDocumentView             0xb722bcc6
#define Data1_IOleAdviseHolder             0x00000111
#define Data1_IOleCache                    0x0000011e
#define Data1_IOleCache2                   0x00000128
#define Data1_IOleCacheControl             0x00000129
#define Data1_IOleClientSite               0x00000118
#define Data1_IOleParentUndoUnit           0xa1faf330
#define Data1_IOleContainer                0x0000011b
#define Data1_IOleControl                  0xb196b288
#define Data1_IOleControlSite              0xb196b289
#define Data1_IOleInPlaceActiveObject      0x00000117
#define Data1_IOleInPlaceFrame             0x00000116
#define Data1_IOleInPlaceObject            0x00000113
#define Data1_IOleInPlaceObjectWindowless  0x1c2056cc
#define Data1_IOleInPlaceSite              0x00000119
#define Data1_IOleInPlaceSiteEx            0x9c2cad80
#define Data1_IOleInPlaceSiteWindowless    0x922eada0
#define Data1_IOleInPlaceUIWindow          0x00000115
#define Data1_IOleItemContainer            0x0000011c
#define Data1_IOleLink                     0x0000011d
#define Data1_IOleManager                  0x0000011f
#define Data1_IOleObject                   0x00000112
#define Data1_IOlePresObj                  0x00000120
#define Data1_IOlePropertyFrame            0xb83bb801
#define Data1_IOleStandardTool             0xd97877c4
#define Data1_IOleUndoUnit                 0x894ad3b0
#define Data1_IOleUndoManager              0xd001f200
#define Data1_IOleWindow                   0x00000114
#define Data1_IPSFactory                   0x00000009
#define Data1_IPSFactoryBuffer             0xd5f569d0
#define Data1_IParseDisplayName            0x0000011a
#define Data1_IPerPropertyBrowsing         0x376bd3aa
#define Data1_IPersist                     0x0000010c
#define Data1_IPersistFile                 0x0000010b
#define Data1_IPersistHistory              0x91A565C1
#define Data1_IPersistMoniker              0x79eac9c9
#define Data1_IPersistStorage              0x0000010a
#define Data1_IPersistStream               0x00000109
#define Data1_IPersistStreamInit           0x7fd52380
#define Data1_IPersistPropertyBag          0x37D84F60
#define Data1_IPersistHTML                 0x049948d1
#define Data1_IPicture                     0x7bf80980
#define Data1_IPictureDisp                 0x7bf80981
#define Data1_IPointerInactive             0x55980ba0
#define Data1_IPropertyNotifySink          0x9bfbbc02
#define Data1_IPropertyPage                0xb196b28d
#define Data1_IPropertyPage2               0x01e44665
#define Data1_IPropertyPage3               0xb83bb803
#define Data1_IPropertyPageInPlace         0xb83bb802
#define Data1_IPropertyPageSite            0xb196b28c
#define Data1_IPropertyPageSite2           0xb83bb804
#define Data1_IProvideClassInfo            0xb196b283
#define Data1_IProvideClassInfo2           0xa6bc3ac0
#define Data1_IProvideDynamicClassInfo     0x6d5140d1
#define Data1_IProvideMultipleClassInfo    0xa7aba9c1
#define Data1_IQuickActivate               0xcf51ed10
#define Data1_IRequireClasses              0x6d5140d0
#define Data1_IRootStorage                 0x00000012
#define Data1_IRunnableObject              0x00000126
#define Data1_IRunningObjectTable          0x00000010
#define Data1_ISelectionContainer          0x6d5140c6
#define Data1_IServiceProvider             0x6d5140c1
#define Data1_ISimpleFrameSite             0x742b0e01
#define Data1_ISpecifyPropertyPages        0xb196b28b
#define Data1_IStdMarshalInfo              0x00000018
#define Data1_IStorage                     0x0000000b
#define Data1_IStream                      0x0000000c
#define Data1_ISupportErrorInfo            0xdf0b3d60
#define Data1_ITargetContainer             0x7847EC01
#define Data1_ITargetEmbedding             0x548793c0
#define Data1_ITargetFrame                 0xd5f78c80
#define Data1_ITargetFrame2                0x3abac181
#define Data1_ITargetNotify                0x863a99a0
#define Data1_ITargetNotify2               0x3050f6b1
#define Data1_ITypeComp                    0x00020403
#define Data1_ITypeInfo                    0x00020401
#define Data1_ITypeLib                     0x00020402
#define Data1_IUnknown                     0x00000000
#define Data1_IViewObject                  0x0000010d
#define Data1_IViewObject2                 0x00000127
#define Data1_IViewObjectEx                0x3af24292
#define Data1_IWeakRef                     0x0000001a
#define Data1_ICategorizeProperties        0x4d07fc10
#define Data1_IAccessible                  0x618736e0
#define Data1_IHTMLFrameBase               0x3050f311
#define Data1_IHTMLTextSite                0x1ff6aa71
#define Data1_IHTMLImageSite               0x49A4B4C0
#define Data1_IHTMLBodyElement             0x3050f1d8
#define Data1_IHTMLFontElement             0x3050f1d9
#define Data1_IHTMLAnchorElement           0x3050f1da
#define Data1_IHTMLAnchorElement2          0x3050f825
#define Data1_IHTMLUListElement            0x3050f1dd
#define Data1_IHTMLOListElement            0x3050f1de
#define Data1_IHTMLLIElement               0x3050f1e0
#define Data1_IHTMLBRElement               0x3050f1f0
#define Data1_IHTMLDListElement            0x3050f1f1
#define Data1_IHTMLDDElement               0x3050f1f2
#define Data1_IHTMLDTElement               0x3050f1f3
#define Data1_IHTMLHRElement               0x3050f1f4
#define Data1_IHTMLParaElement             0x3050f1f5
#define Data1_IHTMLHeaderElement           0x3050f1f6
#define Data1_IHTMLDivElement              0x3050f200
#define Data1_IHTMLBaseFontElement         0x3050f202
#define Data1_IGetUniqueID                 0xaf8665b0
#define Data1_CSubForm                     0x3050f1c7
#define Data1_IBoundObjectSite             0x9BFBBC01
#define Data1_IBitmapSurface               0x3050f2ef 
#define Data1_IGdiSurface                  0x3050f2f0 
#define Data1_IDDSurface                   0x3050f2f1 
#define Data1_IBitmapSurfaceFactory        0x3050f2f2 
#define Data1_IGdiSurfaceFactory           0x3050f2f3 
#define Data1_IDDSurfaceFactory            0x3050f2f4 
#define Data1_IRGBColorTable               0x3050f2f5 
#define Data1_IDispatchEx                  0xa6ef9860
#define Data1_IHTMLEventObj                0x3050f32d
#define Data1_IHTMLWindow2                 0x332c4427
#define Data1_IHTMLWindow3                 0x3050f4ae
#define Data1_IHTMLWindow4                 0x3050f6cf
#define Data1_IHTMLFramesCollection2       0x332c4426
#define Data1_IHTMLDocument                0x626FC520
#define Data1_IHTMLDocument2               0x332c4425
#define Data1_IHTMLDocument3               0x3050f485
#define Data1_IHTMLDocument4               0x3050f69a
#define Data1_IHTMLDocument5               0x3050f80c
#define Data1_IHTMLDataTransfer            0x3050f4b3
#define Data1_IMarqueeInfo                 0x0bdc6ae0
#define Data1_IObjectSafety                0xcb5bdc81
#define Data1_IShellPropSheetExt           0x000214E9
#define Data1_IHTMLScreen                  0x3050f35c
#define Data1_IHTMLScreen2                 0x3050f84a
#define Data1_IHTMLViewFilter              0x3050f2f1
#define Data1_IHTMLViewFilterSite          0x3050f2f4
#define Data1_ITimerService                0x3050f35f
#define Data1_ITimer                       0x3050f360
#define Data1_ITimerSink                   0x3050f361
#define Data1_IHTMLLocation                0x163BB1E0
#define Data1_IHTMLElement                 0x3050f1ff
#define Data1_IHTMLElement2                0x3050f434
#define Data1_IHTMLElement3                0x3050f673
#define Data1_IHTMLElement4                0x3050f80f
#define Data1_IInternetHostSecurityManager 0x3af280b6
#define Data1_IHTMLTxtRange                0x3050F220
#define Data1_IHTMLTxtRangeCollection      0x3050f7ed
#define Data1_IHTMLTextRangeMetrics        0x3050F40B
#define Data1_IHTMLTextRangeMetrics2       0x3050f4a6
#define Data1_ICustomDoc                   0x3050f3f0
#define Data1_ICSSFilterSite               0x3050f3ed
#define Data1_IHTMLDatabinding             0x3050f3f2
#define Data1_IObjectIdentity              0xCA04B7E6
#define Data1_IHTMLTableRow                0x3050f23c
#define Data1_IHTMLTableRowMetrics         0x3050f413
#define Data1_IBindStatusCallback          0x79eac9c1
#define Data1_IWindowForBindingUI          0x79EAC9D5
#define Data1_IDebugDocumentHost           0x51973C27
#define Data1_IHTMLEventObj2               0x3050f48B
#define Data1_IWebBridge                   0xAE24FDAD
#define Data1_IElementBehavior             0x3050f425
#define Data1_IElementBehaviorUI           0x3050f4bf
#define Data1_IElementBehaviorSite         0x3050f427
#define Data1_IElementBehaviorSiteOM       0x3050f489
#define Data1_IElementBehaviorSiteOM2      0x3050f659
#define Data1_IElementBehaviorSiteRender   0x3050f4a7
#define Data1_IElementBehaviorSiteCategory 0x3050f4ee
#define Data1_IElementBehaviorSiteLayout   0x3050f6b7
#define Data1_IElementBehaviorSiteLayout2  0x3050f847
#define Data1_IElementBehaviorFactory      0x3050f429
#define Data1_IElementNamespaceTable       0x3050f670
#define Data1_IElementNamespace            0x3050f671
#define Data1_IElementNamespaceFactory     0x3050f672
#define Data1_IHTCDefaultDispatch          0x3050f4fd
#define Data1_IHTCPropertyBehavior         0x3050f5df
#define Data1_IHTCEventBehavior            0x3050f4ff
#define Data1_IHTCAttachBehavior           0x3050f5f4
#define Data1_IProfferService              0xcb728b20
#define Data1_IPersistPropertyBag2         0x22F55881
#ifdef VSTUDIO7
#define Data1_IIdentityBehavior            0x3050f60c
#define Data1_IIdentityBehaviorFactory     0x3050f60d
#endif //VSTUDIO7
#define Data1_ICSSFilter                   0x3050f3ec
#define Data1_IHTMLRect                    0x3050f4a3
#define Data1_IHTMLRectCollection          0x3050f4a4
#define Data1_IHTMLTableRow2               0x3050f4a1
#define Data1_IHTMLTableRow3               0x3050f82c
#define Data1_IRecalcEngine                0x3050f496
#define Data1_IRecalcHost                  0x3050f497
#define Data1_IObjectWithSite              0xFC4801A3
#define Data1_IMarkupPointer               0x3050f49f
#define Data1_IMarkupPointer2              0x3050f675
#define Data1_IMarkupServices              0x3050f4a0
#define Data1_IMarkupServices2             0x3050f682
#define Data1_IMarkupContainer             0x3050f5f9
#define Data1_IMarkupContainer2            0x3050f648
#define Data1_IHTMLChangeLog               0x3050f649
#define Data1_IHTMLChangePlayback          0x3050f6e0
#define Data1_IHTMLViewServices            0x3050f603
#define Data1_IHTMLPopup                   0x3050f666
#if DBG==1
#define Data1_IHTMLChangeSink              0x3050f64a
#endif // DBG==1
#define Data1_IHTMLEventObj2               0x3050f48B
#define Data1_IHTMLPersistDataOLD          0x3050f48e
#define Data1_IHTMLPersistDataOM           0x3050f4c0
#define Data1_IHTMLPersistData             0x3050f4c5
#define Data1_IActiveScriptSite            0xdb01a1e3
#define Data1_IScriptletHandler            0xa001a870
#define Data1_IScriptletHandlerConstructor 0xa3d52a50
#define Data1_IClassFactoryEx              0x342d1ea0
#define Data1_IHTMLDOMNode                 0x3050f5da
#define Data1_IHTMLDOMNode2                0x3050f80b
#define Data1_IHTMLDOMTextNode             0x3050f4b1
#define Data1_IHTMLDOMTextNode2            0x3050f809
#define Data1_IHTMLDOMAttribute            0x3050f4b0
#define Data1_IHTMLDOMAttribute2           0x3050f810
#define Data1_IHTMLDOMCollectionator       0x3050f4af
#define Data1_IHTMLAttributeCollection     0x3050f4c3
#define Data1_IHTMLAttributeCollection2    0x3050f80a
#define Data1_IHTMLUniqueName              0x3050f4d0
#define Data1_IHTMLObjectElement           0x3050f24f
#define Data1_IHTMLObjectElement2          0x3050f4cd
#define Data1_IHTMLObjectElement3          0x3050f827
#define Data1_IHTMLTable                   0x3050f21e
#define Data1_IHTMLTable2                  0x3050f4ad
#define Data1_IHTMLTable3                  0x3050f829
#define Data1_IScriptletSite               0xc5f21c30
#define Data1_IHTMLIFrameElement2          0x3050f4e6
#define Data1_IHTMLLinkElement2            0x3050f4e5
#define Data1_IHTMLLinkElement3            0x3050f81e
#define Data1_IHTMLIFrameElement           0x3050f315
#define Data1_IHTMLLinkElement             0x3050f205
#define Data1_ISegmentList                 0x3050f605
#define Data1_ISegment                     0x3050f683
#define Data1_IHighlightRenderingServices  0x3050f606
#define Data1_IHTMLFormElement2            0x3050f4f6
#define Data1_IHTMLFormElement3            0x3050f836
#define Data1_IHTMLCaret                   0x3050f604
#define Data1_IDispClient                  0x3050f437
#define Data1_IElementAdorner              0x3050f607
#define Data1_IHTMLAppBehavior             0x3050f5ca
#define Data1_IHTMLAppBehavior2            0x3050f5c9
#define Data1_IHTMLAppBehavior3            0x3050f5cd
#define Data1_IHTMLInputElement            0x3050f5d2
#define Data1_IHTMLInputElement2           0x3050f821
#define Data1_IHTMLInputTextElement        0x3050f2a6
#define Data1_IHTMLInputHiddenElement      0x3050f2a4
#define Data1_IHTMLInputImage              0x3050f2c2
#define Data1_IHTMLInputButtonElement      0x3050f2b2
#define Data1_IHTMLDialog2                 0x3050f5e0
#define Data1_IHTMLInputFileElement        0x3050f2ad
#define Data1_IHTMLOptionButtonElement     0x3050f2bc
#define Data1_IRecalcProperty              0x3050f5d6
#define Data1_IHTMLDocumentFragment        0x3050f5e5
#define Data1_IHTMLElementCollection2      0x3050f5ee
#define Data1_IHTMLElementCollection3      0x3050f835
#define Data1_IHTMLAreasCollection2        0x3050f5ec
#define Data1_IHTMLAreasCollection3        0x3050f837
#define Data1_IHTMLSelectElement2          0x3050f5ed
#define Data1_IHTMLSelectElement4          0x3050f838
#define Data1_IHTMLControlRange            0x3050f29c
#define Data1_IHTMLControlRange2           0x3050f65e
#define Data1_IEditDebugServices           0x3050f60b
#define Data1_IRecalcHostDebug             0x3050f5f7
#define Data1_IMarkupTextFrags             0x3050f5fa
#define Data1_ISecureUrlHost               0xc81984c4
#define Data1_IHTMLElementLayout           0x3050f637
#define Data1_IHTMLLayoutFactory           0x3050f638
#define Data1_IHTMLLayout                  0x3050f639
#define Data1_IHTMLLayoutContext           0x3050f63a
#define Data1_IHTMLBreakTable              0x3050f63b
#define Data1_IXMLGenericParse             0xe4e23071
#define Data1_IHTMLStyle                   0x3050f25e
#define Data1_IHTMLStyle2                  0x3050f4a2
#define Data1_IHTMLStyle3                  0x3050f656
#define Data1_IHTMLStyle4                  0x3050f816
#define Data1_IHTMLRuleStyle               0x3050f3cf
#define Data1_IHTMLRuleStyle2              0x3050f4ac
#define Data1_IHTMLRuleStyle3              0x3050f657
#define Data1_IHTMLRuleStyle4              0x3050f817
#define Data1_IHTMLCurrentStyle            0x3050f3db
#define Data1_IHTMLCurrentStyle2           0x3050f658
#define Data1_IHTMLCurrentStyle3           0x3050f818
#define Data1_IHTMLRenderStyle             0x3050f6ae
#define Data1_IHTMLSubmitData              0x3050f645
#define Data1_IElementBehaviorSubmit       0x3050f646
#define Data1_IHTMLProtectedElement        0x3050f65a
#define Data1_IHTMLElementDefaults         0x3050f6c9
#define Data1_IHTMLElementRender           0x3050f669
#define Data1_ITravelLogClient             0x3050f67a
#define Data1_IWebBrowser                  0xeab22ac1
#define Data1_IWebBrowserApp               0x0002df05
#define Data1_IWebBrowser2                 0xd30c1661
#define Data1_IHTMLPrivateWindow           0x3050f6dc
#define Data1_IHTMLPrivateWindow2          0x3050f7e5
#define Data1_IHTMLPrivateWindow3          0x3050f840
#define Data1_IHTMLEventObj3               0x3050f680
#define Data1_IHTMLEventObj4               0x3050f814
#define Data1_IHTMLPaintSite               0x3050f6a7
#define Data1_IHTMLFilterPaintSite         0x3050f6d3
#define Data1_IHlinkFrame                  0x79eac9c5 
#define Data1_IHTMLPainter                 0x3050f6a6
#define Data1_IHTMLPainterEventInfo        0x3050f6df
#define Data1_IDisplayServices             0x3050f69d
#define Data1_IIMEServices                 0x3050f6ca
#define Data1_IPrivacyServices             0x3050f84b
#define Data1_IHTCAttachBehavior2          0x3050f7eb
#define Data1_IHTMLStyleSheet              0x3050f2e3
#define Data1_IHTMLStyleSheet2             0x3050f3d1
#define Data1_IHTMLFrameElement            0x3050f313
#define Data1_IHTMLFrameElement2           0x3050f7f5
#define Data1_IElementNamespacePrivate     0x3050f7ff
#define Data1_IInternetSecurityMgrSite     0x79eac9ed
#define Data1_IInternetSecurityManager     0x79eac9ee
#define Data1_ITargetFramePriv             0x9216E421
#define Data1_IUrlHistoryNotify            0xbc40bec1 
#define Data1_IElementNamespaceFactory2    0x3050f805
#define Data1_IHTMLCommentElement          0x3050f20c
#define Data1_IHTMLCommentElement2         0x3050f813
#define Data1_IHTMLDOMImplementation       0x3050f80d
#define Data1_IHTMLHtmlElement             0x3050f81c
#define Data1_IHTMLHeadElement             0x3050f81d
#define Data1_IHTMLMetaElement             0x3050f203
#define Data1_IHTMLMetaElement2            0x3050f81f
#define Data1_IHTMLTableSection            0x3050f23b
#define Data1_IHTMLTableSection2           0x3050f5c7
#define Data1_IHTMLTableSection3           0x3050f82b
#define Data1_IHTMLOptionElement           0x3050f211
#define Data1_IHTMLOptionElement3          0x3050f820
#define Data1_IHTMLTableCell               0x3050f23d
#define Data1_IHTMLTableCell2              0x3050f82d
#define Data1_IHTMLListElement             0x3050f20e
#define Data1_IHTMLListElement2            0x3050f822
#define Data1_IHTMLBlockElement            0x3050f208
#define Data1_IHTMLBlockElement2           0x3050f823
#define Data1_IHTMLPhraseElement           0x3050f20a
#define Data1_IHTMLPhraseElement2          0x3050f824
#define Data1_IHTMLImgElement2             0x3050f826
#define Data1_IHTMLScriptElement2          0x3050f828
#define Data1_IHTMLTableCol                0x3050f23a
#define Data1_IHTMLTableCol2               0x3050f82a
#define Data1_IHTMLIsIndexElement          0x3050f206
#define Data1_IHTMLIsIndexElement2         0x3050f82f
#define Data1_IHTMLLabelElement            0x3050f32a
#define Data1_IHTMLLabelElement2           0x3050f832
#define Data1_IHTMLLegendElement           0x3050f3ea
#define Data1_IHTMLLegendElement2          0x3050f834
#define Data1_IHTMLFieldSetElement         0x3050f3e7
#define Data1_IHTMLFieldSetElement2        0x3050f833
#define Data1_IHTMLTextContainer           0x3050f230
#define Data1_IEnumPrivacyRecords          0x3050f844

#if DBG==1
#define Data1_IDebugWindowProxy            0x3050f592
#define Data1_IDebugWindow                 0x3050f593
#endif


#define QI_INHERITS(pObj, itf)              \
    case Data1_##itf:                       \
        if (iid == IID_##itf)               \
        {                                   \
        *ppv = (itf *)pObj;                 \
        }                                   \
        break;                              \

#define QI_INHERITS2(pObj, itf, itfDerived) \
    case Data1_##itf:                       \
        if (iid == IID_##itf)               \
        {                                   \
        *ppv = (itfDerived *)pObj;          \
        }                                   \
        break;                              \

#define QI_TEAROFF(pObj, itf, pUnkOuter)    \
    case Data1_##itf:                       \
        if (iid == IID_##itf)               \
        {                                   \
        HRESULT hr = CreateTearOffThunk(    \
            pObj,                           \
            (void *)pObj->s_apfn##itf,      \
            pUnkOuter,                      \
            ppv);                           \
        if (hr)                             \
            RRETURN(hr);                    \
        }                                   \
        break;                              \

#define QI_TEAROFF2(pObj, itf, itfDerived, pUnkOuter) \
    case Data1_##itf:                                 \
        if (iid == IID_##itf)                         \
        {                                             \
        HRESULT hr = CreateTearOffThunk(              \
            pObj,                                     \
            (void *)pObj->s_apfn##itfDerived,         \
            pUnkOuter,                                \
            ppv);                                     \
        if (hr)                                       \
            RRETURN(hr);                              \
        }                                             \
        break;                                        \

#define QI_HTML_TEAROFF(pObj, itf, pUnkOuter)    \
    case Data1_##itf:                       \
        if (iid == IID_##itf)               \
        {                                   \
        HRESULT hr = CreateTearOffThunk(    \
            pObj,                           \
            (void *)pObj->s_apfnpd##itf,    \
            pUnkOuter,                      \
            ppv,                            \
            (void *)s_ppropdescsInVtblOrder##itf);                 \
        if (hr)                             \
            RRETURN(hr);                    \
        }                                   \
        break;                              \


extern const IID * const g_apIID_IDispatchEx[];

#define QI_TEAROFF_DISPEX(pObj, pUnkOuter) \
    case Data1_IDispatch:                             \
    case Data1_IDispatchEx:                           \
        if (iid == IID_IDispatch || iid == IID_IDispatchEx)\
        {                                             \
        HRESULT hr = CreateTearOffThunk(              \
            pObj,                                     \
            pObj->s_apfnIDispatchEx,                 \
            pUnkOuter,                                \
            ppv,                                      \
            NULL,                                     \
            NULL,                                     \
            0,                                        \
            g_apIID_IDispatchEx);                     \
        if (hr)                                       \
            RRETURN(hr);                              \
        }                                             \
        break;                                        \

#define QI_FALLTHRU(itfName1__, itfName2__) case Data1_##itfName1__: if (iid == IID_##itfName1__) goto handle_##itfName2__; else break; 
#define QI_CASE(itfName__) case Data1_##itfName__: if (iid == IID_##itfName__) goto handle_##itfName__; else break; handle_##itfName__: ;

#pragma INCMSG("--- End 'qi_impl.h'")
#else
#pragma INCMSG("*** Dup 'qi_impl.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\misc\coreid.c ===
/*
   coreid.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#include <windef.h>
#include <basetyps.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define PRIVATE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)

#define INCMSG(x)

#include <coreguid.h>
// NOTE: oleacc.h contains a whole bunch of guids which all are 
// being loaded.  
// CONSIDER: Copying out only guids that we need and put in here.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\uwininet.h ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       uwininet.h
//
//  Contents:   Redefinitions of unicode versions of some Wininet APIs
//              which are declared incorrectly in wininet.h and unimplemented
//              in wininet.dll.
//
//              Note that this workaround doesn't solve the whole problem
//              since INTERNET_CACHE_ENTRY_INFO contains a non-unicode
//              lpszSourceUrlName which too much trouble to convert in our
//              wrapper (at any rate, we don't use it).
//
//----------------------------------------------------------------------------

#ifndef I_UWININET_H_
#define I_UWININET_H_
#pragma INCMSG("--- Beg 'uwininet.h'")

#ifndef X_WININET_H_
#define X_WININET_H_
#pragma INCMSG("--- Beg <wininet.h>")
#define _WINX32_
#include <wininet.h>
#pragma INCMSG("--- End <wininet.h>")
#endif

// to get all the defs, winineti.h requires wincrypt.h be included before it!
#ifndef X_WINCRYPT_H
#define X_WINCRYPT_H
#pragma INCMSG("--- Beg <wincrypt.h>")
#include "wincrypt.h"
#pragma INCMSG("--- End <wincrypt.h>")
#endif

#ifndef X_WININETI_H_
#define X_WININETI_H_
#pragma INCMSG("--- Beg <winineti.h>")
#define _WINX32_
#include <winineti.h>
#pragma INCMSG("--- End <winineti.h>")
#endif

#define DATE_STR_LENGTH 30

#define LPCBYTE         const BYTE *


// urlmon unicode wrapper for ansi api
STDAPI ObtainUserAgentStringW(DWORD dwOption, LPWSTR lpszUAOut, DWORD* cbSize);

//
//  Wrap CreateUrlCacheEntry
//--------------------------------------------------
URLCACHEAPI_(BOOL) CreateUrlCacheEntryBugW ( IN LPCWSTR lpszUrlName, 
                       IN DWORD dwFileSize, 
                       IN LPCWSTR lpszExtension, 
                       OUT LPWSTR lpszFileName, 
                       IN DWORD dwRes);

#undef CreateUrlCacheEntry  
#ifdef UNICODE
#define CreateUrlCacheEntry CreateUrlCacheEntryBugW
#else
#define CreateUrlCacheEntry CreateUrlCacheEntryA
#endif

//
// Wrap CommitUrlCachEntry
//--------------------------------------------------

URLCACHEAPI_(BOOL) CommitUrlCacheEntryBugW ( 
                       IN LPCWSTR  lpszUrlName,
                       IN LPCWSTR  lpszLocalFileName,
                       IN FILETIME ExpireTime,
                       IN FILETIME LastModifiedTime,
                       IN DWORD    dwCachEntryType,
                       IN LPCBYTE  lpHeaderInfo,
                       IN DWORD    dwHeaderSize,
                       IN LPCWSTR  lpszFileExtension,
                       IN DWORD    dwReserved);

#undef CommitUrlCacheEntry
#ifdef UNICODE  
#define CommitUrlCacheEntry CommitUrlCacheEntryBugW
#else
#define CommitUrlCacheEntry CommitUrlCacheEntryA
#endif




URLCACHEAPI_(BOOL) GetUrlCacheEntryInfoBugW(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    );

#undef GetUrlCacheEntryInfo // remove the buggy version

#ifdef UNICODE
#define GetUrlCacheEntryInfo GetUrlCacheEntryInfoBugW
#else
#define GetUrlCacheEntryInfo GetUrlCacheEntryInfoA
#endif // !UNICODE


// Same Problem here

BOOLAPI GetUrlCacheEntryInfoExBugW(
	IN LPCWSTR lpszUrl,
	OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
	IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
	OUT LPSTR lpszRedirectUrl,
	IN OUT LPDWORD lpdwRedirectUrlBufSize,
	LPVOID lpReserved,
	DWORD dwReserved
);

#undef GetUrlCacheEntryInfoEx // remove the buggy version

#ifdef UNICODE
#define GetUrlCacheEntryInfoEx GetUrlCacheEntryInfoExBugW
#else
#define GetUrlCacheEntryInfoEx GetUrlCacheEntryInfoExA
#endif // !UNICODE

// Same problem here
URLCACHEAPI_(BOOL) SetUrlCacheEntryInfoBugW(
    IN LPCWSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,
    IN DWORD dwFieldControl
    );

#undef SetUrlCacheEntryInfo 

#ifdef UNICODE
#define SetUrlCacheEntryInfo  SetUrlCacheEntryInfoBugW
#else
#define SetUrlCacheEntryInfo  SetUrlCacheEntryInfoA
#endif // !UNICODE

// again, but worse...
BOOL
WINAPI
DeleteUrlCacheEntryBugW(LPCWSTR lpszUrlName);

BOOL
WINAPI
DeleteUrlCacheEntryA(LPCSTR lpszUrlName);

#undef DeleteUrlCacheEntry

#ifdef UNICODE
#define DeleteUrlCacheEntry  DeleteUrlCacheEntryBugW
#else
#define DeleteUrlCacheEntry  DeleteUrlCacheEntryA
#endif // !UNICODE


// Get/Set helpers for URL components.
enum URLCOMP_ID
{
    URLCOMP_HOST,
    URLCOMP_HOSTNAME,
    URLCOMP_PATHNAME,
    URLCOMP_PORT,
    URLCOMP_PROTOCOL,
    URLCOMP_SEARCH,
    URLCOMP_HASH,
    URLCOMP_WHOLE
};

UINT GetUrlScheme(const TCHAR * pchUrlIn);

BOOL IsURLSchemeCacheable(UINT uScheme);

BOOL IsUrlSecure(const TCHAR * pchUrl);

HRESULT GetUrlComponentHelper(const TCHAR * pchUrlIn,
                      CStr *        pstrComp,
                      DWORD         dwFlags,
                      URLCOMP_ID    ucid,
                      BOOL          fUseOmLocationFormat = FALSE);
HRESULT SetUrlComponentHelper(const TCHAR * pchUrlIn,
                      TCHAR *       pchUrlOut,
                      DWORD         dwBufLen,
                      const BSTR *  pstrComp,
                      URLCOMP_ID    ucid);
HRESULT ComposeUrl(SHURL_COMPONENTS * puc,
                   DWORD              dwFlags,
                   TCHAR            * pchUrlOut,
                   DWORD            * pdwSize);

//Other helper routines and wininetapi wrappers
HRESULT ConvertDateTimeToString(FILETIME Time, 
                               BSTR * pchDateStr, 
                               BOOL   fReturnTime);


//GetDateFormat is UNICODE on NT ONLY
int 
WINAPI
GetDateFormat_BugW(LCID Locale, 
              DWORD dwFlags, 
              CONST SYSTEMTIME * lpDate, 
              LPCTSTR lpFormat,
              LPTSTR lpDateStr, 
              int cchDate);
#undef GetDateFormat
#ifdef UNICODE
#define GetDateFormat GetDateFormat_BugW
#else
#define GetDateFormat GetDateFormatA
#endif // !UNICODE


//GetTimeFormat is UNICODE on NT ONLY
int 
WINAPI
GetTimeFormat_BugW(LCID Locale, 
              DWORD dwFlags, 
              CONST SYSTEMTIME * lpTime, 
              LPCTSTR lpFormat,
              LPTSTR lpTimeStr, 
              int cchDate);
#undef GetTimeFormat
#ifdef UNICODE
#define GetTimeFormat GetTimeFormat_BugW
#else
#define GetTimeFormat GetTimeFormatA
#endif // !UNICODE

URLCACHEAPI_(BOOL) RetrieveUrlCacheEntryFileBugW(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    );

#undef RetrieveUrlCacheEntryFile // remove the buggy version

#ifdef UNICODE
#define RetrieveUrlCacheEntryFile RetrieveUrlCacheEntryFileBugW
#else
#define RetrieveUrlCacheEntryFile RetrieveUrlCacheEntryFileA
#endif // !UNICODE

#ifdef DLOAD1
#define UWININET_EXTERN_C extern "C"
#else
#define UWININET_EXTERN_C
#endif

// These are exported but not defined in any header file. (cthrash)
#ifdef UNICODE
#ifdef DLOAD1

// NOTE: Unicode version doesn't exist in WININET.DLL
//       The function definition does not correspond to the export.
//       If it actually works, it is a miracle.
UWININET_EXTERN_C
INTERNETAPI_(BOOL) InternetGetCertByURL(LPCWSTR lpszURL,
                     LPWSTR lpszCertText,
                     DWORD dwcbCertText);

#else

UWININET_EXTERN_C
BOOLAPI InternetGetCertByURLW(LPCWSTR lpszURL,
                      LPWSTR lpszCertText,
                      DWORD dwcbCertText);

#define InternetGetCertByURL InternetGetCertByURLW

#endif // DLOAD1
#else

UWININET_EXTERN_C
BOOLAPI InternetGetCertByURLA(LPCSTR lpszURL,
                      LPSTR lpszCertText,
                      DWORD dwcbCertText);

#define InternetGetCertByURL InternetGetCertByURLA

#endif //UNICODE

URLCACHEAPI_(BOOL) UnlockUrlCacheEntryFileBugW(
    IN LPCWSTR lpszUrlName,
    IN DWORD dwReserved
    );

#undef UnlockUrlCacheEntryFile // remove the buggy version

#ifdef UNICODE
#define DoUnlockUrlCacheEntryFile UnlockUrlCacheEntryFileBugW
#else
#define DoUnlockUrlCacheEntryFile UnlockUrlCacheEntryFileA
#endif

HRESULT ShortCutSetUrlHelper(const TCHAR * pchUrlIn,
                             TCHAR       * pchUrlOut,
                             DWORD         dwBufLen,
                             const BSTR  * pstrComp,
                             URLCOMP_ID    ucid,
                             BOOL          fUseOmLocationFormat = FALSE);

#pragma INCMSG("--- End 'uwininet.h'")
#else
#pragma INCMSG("*** Dup 'uwininet.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\misc\coreidpr.c ===
/*
   coreidpr.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#include <windef.h>
#include <basetyps.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define PUBLIC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)
#define INCMSG(x)
#include <coreguid.h>

DEFINE_GUID(IID_IProvideMultipleClassInfo,
    0xA7ABA9C1,0x8983,0x11CF,0x8F,0x20,0x00,0x80,0x5F,0x2C,0xD0,0x64);
DEFINE_GUID(IID_IPersistPropertyBag2,
    0x22F55881,0x280B,0x11d0,0xA8,0xA9,0x00,0xA0,0xC9,0x0C,0x20,0x04);
DEFINE_GUID(IID_IPropertyBag2,
    0x22F55882,0x280B,0x11d0,0xA8,0xA9,0x00,0xA0,0xC9,0x0C,0x20,0x04);
DEFINE_GUID(IID_IActiveDesigner,
    0x51AAE3E0,0x7486,0x11CF,0xA0,0xC2,0x00,0xAA,0x00,0x62,0xBE,0x57);

DEFINE_GUID(CLSID_Mshtmled,
    0x3050f494,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(IID_IScriptletConstructor, 
	0xc265fb00,0x9fa4,0x11d1,0x89,0xb6,0x00,0x60,0x08,0xc3,0xfb,0xfc);
DEFINE_GUID(CLSID_ScriptletConstructor,
    0x21617250,0xa071,0x11d1,0x89,0xb6,0x00,0x60,0x08,0xc3,0xfb,0xfc);
DEFINE_GUID(IScriptletHandlerConstructor,
    0xa3d52a50,0xb7ff,0x11d1,0xa3,0x5a,0x00,0x60,0x08,0xc3,0xfb,0xfc);
DEFINE_GUID(SID_SEditCommandTarget,
    0x3050f4b5,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(CGID_EditStateCommands,
    0x3050f4b6,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(IID_IThumbnailView,
    0x7bb0b520,0xb1a7,0x11d2,0xbb,0x23,0x0,0xc0,0x4f,0x79,0xab,0xcd);
DEFINE_GUID(IID_IRenMailEditor,
    0x000670ba,0x0000,0x0000,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID(CLSID_HTMLServerDoc,
    0x3050f4e7,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(SID_SHTMLEditServices,
    0x3050f7f9,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(CLSID_HTMLEditor,
    0x3050f4f5,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);    
DEFINE_GUID(IID_IHTMLEditorViewManager,
    0x53A2D5B0,0xD2FC,0x11D0,0x84,0xE0,0x00,0x60,0x97,0xC9,0x98,0x7D);
DEFINE_GUID(SID_SHTMLEditorViewManager,
    0x53A2D5B1,0xD2FC,0x11D0,0x84,0xE0,0x00,0x60,0x97,0xC9,0x98,0x7D);
DEFINE_GUID(IID_IRenVersionCheck, 
    0X3F9DF312,0X78EE,0X11D2,0X83,0XB9,0X0,0X60,0XB0,0XEC,0XD,0XFF);
DEFINE_GUID(IID_IXMLViewerIdentity, 
    0xcc0baf51,0x3321,0x11d2,0xae,0x28,0x00,0x80,0xc7,0x33,0x7e,0xa1);
DEFINE_GUID(SID_DefView,
    0x6D12FE80,0x7911,0x11CF,0x95,0x34,0x00,0x00,0xC0,0x5B,0xAE,0x0B);
DEFINE_GUID(SID_SHTMEDDesignerHost,
    0xAD7F6C62,0xF6BD,0x11d2,0x95,0x9b,0x00,0x60,0x97,0xc5,0x53,0xc8);
DEFINE_GUID(SID_SMenuBandHandler,           
    0xd14e31c, 0xd8c0, 0x11d0, 0x98,0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);
DEFINE_GUID(SID_SMarsPanel,
    0x24ec0ae8,0x734e,0x4c18,0xb1,0x91,0x6d,0x3b,0xf1,0xd9,0x41,0x3b);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\wrapfns.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       wrapfns.h
//
//  Contents:   The list of Unicode functions wrapped for Win95.  Each
//              wrapped function should listed in alphabetical order with
//              the following format:
//
//      STRUCT_ENTRY(FunctionName, ReturnType, (Param list with args), (Argument list))
//
//              For example:
//
//      STRUCT_ENTRY(RegisterClass, ATOM, (CONST WNDCLASSW * pwc), (pwc))
//
//      For functions which return void, use the following:
//
//      STRUCT_ENTRY_VOID(FunctionName, (Param list with args), (Argument list))
//
//      For functions which do no conversions, use STRUCT_ENTRY_NOCONVERT
//      and STRUCT_ENTRY_VOID_NOCONVERT
//
//----------------------------------------------------------------------------


#ifndef NOOVERRIDE
#undef ChooseColor
#define ChooseColor __ChooseColor
STRUCT_ENTRY_NOCONVERT2(ChooseColor, BOOL, (LPCHOOSECOLORW lpcc), (lpcc))
#else
STRUCT_ENTRY_NOCONVERT(ChooseColor, BOOL, (LPCHOOSECOLORW lpcc), (lpcc))
#endif

#ifndef NOOVERRIDE
#undef ChooseFont
#define ChooseFont __ChooseFont
STRUCT_ENTRY2(ChooseFont, BOOL, (LPCHOOSEFONTW lpcf), (lpcf))
#else
STRUCT_ENTRY(ChooseFont, BOOL, (LPCHOOSEFONTW lpcf), (lpcf))
#endif

#if DBG==1
STRUCT_ENTRY_NOCONVERT(LoadLibrary, HINSTANCE, (LPCWSTR lpsz), (lpsz))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\include\wrapdefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       wrapdefs.h
//
//  Contents:   Definitions of variables and functions required for wrapping
//              functions where there are differences between Windows95 and
//              Windows NT.
//
//              If you want to add your own wrapped function, see the
//              directions in wrapfns.h.
//----------------------------------------------------------------------------

#ifndef I_WRAPDEFS_HXX_
#define I_WRAPDEFS_HXX_
#pragma INCMSG("--- Beg 'wrapdefs.h'")

// define some other languages until ntdefs.h catches up
#ifndef LANG_YIDDISH
#define LANG_YIDDISH      0x3d       
#endif
#ifndef LANG_MONGOLIAN
#define LANG_MONGOLIAN    0x50       // Mongolia
#endif
#ifndef LANG_TIBETAN
#define LANG_TIBETAN      0x51       // Tibet
#endif
#ifndef LANG_KHMER
#define LANG_KHMER        0x53       // Cambodia
#endif
#ifndef LANG_LAO
#define LANG_LAO          0x54       // Laos
#endif
#ifndef LANG_BURMESE
#define LANG_BURMESE      0x55       // Burma/Myanmar
#endif
#ifndef LANG_MANIPURI
#define LANG_MANIPURI     0x58       
#endif
#ifndef LANG_SINDHI
#define LANG_SINDHI       0x59
#endif
#ifndef LANG_SYRIAC
#define LANG_SYRIAC       0x5a
#endif
#ifndef LANG_SINHALESE
#define LANG_SINHALESE    0x5b      // Sinhalese - Sri Lanca
#endif
#ifndef LANG_KASHMIRI
#define LANG_KASHMIRI     0x60       
#endif
#ifndef LANG_NAPALI
#define LANG_NAPALI       0x61       
#endif
#ifndef LANG_PASHTO
#define LANG_PASHTO       0x63       
#endif


extern DWORD g_dwPlatformID;        // VER_PLATFORM_WIN32S/WIN32_WINDOWS/WIN32_WINNT
extern DWORD g_dwPlatformVersion;   // (dwMajorVersion << 16) + (dwMinorVersion)
extern BOOL  g_fUnicodePlatform;
extern BOOL  g_fTerminalServer;     // TRUE if running under NT Terminal Server, FALSE otherwise
extern BOOL  g_fTermSrvClientSideBitmaps; // TRUE if TS supports client-side bitmaps
extern BOOL  g_fNLS95Support;
extern BOOL  g_fFarEastWin9X;
extern BOOL  g_fFarEastWinNT;
extern BOOL  g_fExtTextOutWBuggy;
extern BOOL  g_fExtTextOutGlyphCrash;
extern BOOL  g_fBidiSupport;        // COMPLEXSCRIPT
extern BOOL  g_fComplexScriptInput;
extern BOOL  g_fMirroredBidiLayout;

void InitUnicodeWrappers();
UINT GetLatinCodepage();            // Most likely 1252
HRESULT DoFileDownLoad(const TCHAR * pchHref);

#if defined(_M_IX86) && !defined(WINCE)
    #define USE_UNICODE_WRAPPERS 1
#else
    #define USE_UNICODE_WRAPPERS 0
#endif

BOOL IsTerminalServer();


//+------------------------------------------------------------------------
//
// Returns the global function pointer for a unicode function.
//
//-------------------------------------------------------------------------

#if USE_UNICODE_WRAPPERS==1
    #define UNICODE_FN(fn)  g_pufn##fn
#else
    #define UNICODE_FN(fn)  fn
#endif

//+------------------------------------------------------------------------
//
// Turn off warnings from dllimport.
//
//-------------------------------------------------------------------------
BOOL IsFarEastLCID( LCID lcid );
BOOL IsBidiLCID( LCID lcid ); // COMPLEXSCRIPT
BOOL IsComplexLCID( LCID lcid );

#ifndef BYPASS_UNICODE_WRAPPERS

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#define _SHELL32_
#define _SHDOCVW_
#pragma INCMSG("--- Beg <shellapi.h>")
#include <shellapi.h>
#pragma INCMSG("--- End <shellapi.h>")
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#undef WINCOMMCTRLAPI
#define WINCOMMCTRLAPI
#pragma INCMSG("--- Beg <commctrl.h>")
#include <commctrl.h>
#pragma INCMSG("--- End <commctrl.h>")
#endif

#ifndef X_COMCTRLP_H_
#define X_COMCTRLP_H_
#undef WINCOMMCTRLAPI
#define WINCOMMCTRLAPI
#pragma INCMSG("--- Beg <comctrlp.h>")
#include <comctrlp.h>
#pragma INCMSG("--- End <comctrlp.h>")
#endif

#ifndef X_INTSHCUT_H_
#define X_INTSHCUT_H_
#define _INTSHCUT_
#pragma INCMSG("--- Beg <intshcut.h>")
#include <intshcut.h>
#pragma INCMSG("--- End <intshcut.h>")
#endif

#endif

//+------------------------------------------------------------------------
//
//  Declaration of global function pointers to unicode or wrapped functions.
//
//-------------------------------------------------------------------------

#if USE_UNICODE_WRAPPERS==1

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs) \
        extern FnType (__stdcall *g_pufn##FnName) FnParamList;

#define STRUCT_ENTRY2(FnName, FnType, FnParamList, FnArgs) \
        extern FnType (__stdcall *g_pufn##FnName) FnParamList;
        
#define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs) \
        extern void (__stdcall *g_pufn##FnName) FnParamList;

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
        extern FnType (__stdcall *g_pufn##FnName) FnParamList;

#define STRUCT_ENTRY_NOCONVERT2(FnName, FnType, FnParamList, FnArgs) \
        extern FnType (__stdcall *g_pufn##FnName) FnParamList;

#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs) \
        extern void (__stdcall *g_pufn##FnName) FnParamList;

#include "wrapfns.h"

#undef STRUCT_ENTRY
#undef STRUCT_ENTRY2
#undef STRUCT_ENTRY_VOID
#undef STRUCT_ENTRY_NOCONVERT
#undef STRUCT_ENTRY_NOCONVERT2
#undef STRUCT_ENTRY_VOID_NOCONVERT

#endif


//+------------------------------------------------------------------------
//
//  Define inline functions which call functions in the table. The
//  functions are defined from entries in wrapfns.h.
//
//-------------------------------------------------------------------------

#if USE_UNICODE_WRAPPERS==1 && !defined(BYPASS_UNICODE_WRAPPERS)

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs) \
        inline FnType __stdcall FnName FnParamList {return (*g_pufn##FnName) FnArgs;}
#define STRUCT_ENTRY2(FnName, FnType, FnParamList, FnArgs) \
        inline FnType __stdcall __##FnName FnParamList {return (*g_pufn##FnName) FnArgs;}

#define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs) \
        inline void __stdcall FnName FnParamList {(*g_pufn##FnName) FnArgs;}

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
        inline FnType __stdcall FnName FnParamList {return (*g_pufn##FnName) FnArgs;}
#define STRUCT_ENTRY_NOCONVERT2(FnName, FnType, FnParamList, FnArgs) \
        inline FnType __stdcall __##FnName FnParamList {return (*g_pufn##FnName) FnArgs;}

#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs) \
        inline void __stdcall FnName FnParamList {(*g_pufn##FnName) FnArgs;}


#include "wrapfns.h"

#undef STRUCT_ENTRY
#undef STRUCT_ENTRY_VOID
#undef STRUCT_ENTRY_NOCONVERT
#undef STRUCT_ENTRY_VOID_NOCONVERT

//-------------------------------------------------------------------------
//
// Handle wsprintf specially, as it has a variable length argument list.
//
//-------------------------------------------------------------------------

#undef wsprintf

inline int
__cdecl wsprintf(LPTSTR pwszOut, LPCTSTR pwszFormat, ...)
{
    int i;
    va_list arglist;

    va_start(arglist, pwszFormat);
    i = wvsprintf(pwszOut, pwszFormat, arglist);
    va_end(arglist);

    return i;
}

#endif

#pragma INCMSG("--- End 'wrapdefs.h'")
#else
#pragma INCMSG("*** Dup 'wrapdefs.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\misc\docobj.c ===
/*
   docobj.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#include <windef.h>
#include <basetyps.h>
#include "urlhist.h"   

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+----------------------------------------------------------------------------
//
//  File:       docobj.c
//
//  Synopsis:   IIDs gleaned from the Sterling libs. We need to have it
//              in source form for Lego and the Mac folks.
//
//  Comment:    This is from docobj.lib
//
//-----------------------------------------------------------------------------

DEFINE_GUID(IID_IMsoMailEditor,            0xb722bcce, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IMsoMailSite,              0xb722bccd, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);

DEFINE_GUID(IID_IMsoFormSite,              0xb722bccc, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IOleCommandTarget,         0xb722bccb, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IPrint,                    0xb722bcc9, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IContinueCallback,         0xb722bcca, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IEnumOleDocumentViews,     0xb722bcc8, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IOleDocumentView,          0xb722bcc6, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IOleDocumentSite,          0xb722bcc7, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IOleDocument,              0xb722bcc5, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
//TODO -- Nuke when the build is switched to the NT build -- BharatS
DEFINE_GUID(SID_STopLevelBrowser,         0x4C96BE40L, 0x915C, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);


DEFINE_GUID(IID_IDummy,                    0xb722bcc4, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\misc\multimon.c ===
#include <windows.h>

#include "markcode.hxx"
#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//=============================================================================
//
// This file defines the MULTIMON stub module that fakes multiple monitor 
// apis on pre Memphis Win32 OSes
// this is the only file that defines COMPILE_MULTIMON_STUBS 
//=============================================================================

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\misc\dbuuid.c ===
/*
   dbuuid.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#include <windef.h>
#include <basetyps.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

// I copied the following lines from <oledb.h> to get the definition
// of LPOLESTR.  Surely we don't need all of them.
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

//+----------------------------------------------------------------------------
//
//  File:       dbuuid.c
//
//  Synopsis:   IIDs gleaned from the OLE-DB libs. We need to have it
//              in source form for Lego and the Mac folks.  We also pull out
//              of oledb.h only those special GUIDS which we need.
//
//  Comment:    This is from dbuuid.lib
//
//-----------------------------------------------------------------------------

DEFINE_GUID(IID_IRowsetAsynch,                         0x0c733a0f, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
DEFINE_GUID(IID_IRowsetNewRowAfter,                    0x0c733a71, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);

DEFINE_GUID(DBCOL_SPECIALCOL,                          0xc8b52232, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
DEFINE_GUID(DBPROPSET_ROWSET,                          0xc8b522be, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);

// IID used by ICursor-consuming controls
DEFINE_GUID(IID_IRowCursor,                            0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_IVBDSC,                                0x1ab42240, 0x8c70, 0x11ce, 0x94, 0x21, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

// GUIDs for IRowPosition family
DEFINE_GUID(CLSID_CRowPosition,                        0x2048eee6,0x7fa2,0x11d0,0x9e,0x6a,0x00,0xa0,0xc9,0x13,0x8c,0x29);

// GUIDS for ADO
#define DEFINE_DAOGUID(name, l) \
    DEFINE_GUID(name, l, 0, 0x10, 0x80,0,0,0xAA,0,0x6D,0x2E,0xA4)
DEFINE_DAOGUID(IID_IADORecordsetConstruction,     0x00000283);
DEFINE_DAOGUID(CLSID_CADORecordset,      0x00000535);
DEFINE_DAOGUID(IID_IADORecordset15,		 0x0000050E);

// GUIDS for CurrentRecord
DEFINE_GUID(IID_ICurrentRecordInstance,                0x3050f328,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);

// GUIDS for data source interfaces
DEFINE_GUID(IID_IDATASRCListener,                      0x3050f380,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(IID_DataSourceListener,                    0x7c0ffab2,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);
DEFINE_GUID(IID_DataSource,                            0x7c0ffab3,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\misc\objextid.c ===
/*
   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#ifndef _MAC
#include <windef.h>
#include <basetyps.h>
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

// Include the object extensions GUID's
//
// These weird stuff with windows.h is necessary because it reenables warning
// 4001 and generally causes havoc at warning level 4.
//
#pragma warning(disable:4115) // named type in parenthses

#include <windows.h>
#include <w4warn.h>
#include <servprov.h>
#include <ole2.h>
#include <objext.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\comdlg32.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       comdlg32.cxx
//
//  Contents:   Dynamic wrappers for common dialog procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

DYNLIB g_dynlibCOMDLG32 = { NULL, NULL, "COMDLG32.dll" };

BOOL APIENTRY
ChooseColorW(LPCHOOSECOLORW lpcc)
{
    static DYNPROC s_dynprocChooseColorW =
            { NULL, &g_dynlibCOMDLG32, "ChooseColorW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocChooseColorW);
    if (hr)
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPCHOOSECOLORW))s_dynprocChooseColorW.pfn)
            (lpcc);
}

BOOL APIENTRY
ChooseColorA(LPCHOOSECOLORA lpcc)
{
    static DYNPROC s_dynprocChooseColorA =
            { NULL, &g_dynlibCOMDLG32, "ChooseColorA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocChooseColorA);
    if (hr)
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPCHOOSECOLORA))s_dynprocChooseColorA.pfn)
            (lpcc);
}


BOOL APIENTRY
ChooseFontW(LPCHOOSEFONTW lpcf)
{
    static DYNPROC s_dynprocChooseFontW =
            { NULL, &g_dynlibCOMDLG32, "ChooseFontW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocChooseFontW);
    if (hr)
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPCHOOSEFONTW))s_dynprocChooseFontW.pfn)
            (lpcf);
}

BOOL APIENTRY
ChooseFontA(LPCHOOSEFONTA lpcf)
{
    static DYNPROC s_dynprocChooseFontA =
            { NULL, &g_dynlibCOMDLG32, "ChooseFontA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocChooseFontA);
    if (hr)
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPCHOOSEFONTA))s_dynprocChooseFontA.pfn)
            (lpcf);
}

DWORD APIENTRY
CommDlgExtendedError()
{
    static DYNPROC s_dynprocCommDlgExtendedError =
            { NULL, &g_dynlibCOMDLG32, "CommDlgExtendedError" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocCommDlgExtendedError);
    if (hr)
        return CDERR_INITIALIZATION;

    return ((DWORD (APIENTRY *)())s_dynprocCommDlgExtendedError.pfn)
            ();
}

BOOL APIENTRY
PrintDlgA(PRINTDLGA* pprintdlg)
{
    static DYNPROC s_dynprocPrintDlgA =
            { NULL, &g_dynlibCOMDLG32, "PrintDlgA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocPrintDlgA);
    if (hr)
        return NULL;

    return ((BOOL (APIENTRY *)(PRINTDLGA*))s_dynprocPrintDlgA.pfn)
            (pprintdlg);
}

BOOL APIENTRY
PrintDlgW(PRINTDLGW* pprintdlg)
{
    static DYNPROC s_dynprocPrintDlgW =
            { NULL, &g_dynlibCOMDLG32, "PrintDlgW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocPrintDlgW);
    if (hr)
        return NULL;

    return ((BOOL (APIENTRY *)(PRINTDLGW*))s_dynprocPrintDlgW.pfn)
            (pprintdlg);
}

#ifdef UNIX
extern "C" char *APIENTRY
MwFilterType(char *filter, BOOL b)
{
    static DYNPROC s_dynprocMwFilterType =
            { NULL, &g_dynlibCOMDLG32, "MwFilterType" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocMwFilterType);
    if (hr)
        return NULL;

    return ((char *(APIENTRY *)(char *, BOOL))s_dynprocMwFilterType.pfn)
            (filter, b);
}
#endif // UNIX


#if !defined(_M_IX86_)

BOOL APIENTRY
GetOpenFileNameW(LPOPENFILENAMEW pofnw)
{
    static DYNPROC s_dynprocGetOpenFileNameW =
            { NULL, &g_dynlibCOMDLG32, "GetOpenFileNameW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetOpenFileNameW);
    if (hr)
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPOPENFILENAMEW))s_dynprocGetOpenFileNameW.pfn)
            (pofnw);
}

BOOL APIENTRY
GetSaveFileNameW(LPOPENFILENAMEW pofnw)
{
    static DYNPROC s_dynprocGetSaveFileNameW =
            { NULL, &g_dynlibCOMDLG32, "GetSaveFileNameW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetSaveFileNameW);
    if (hr)
        return FALSE;

    return ((BOOL (APIENTRY *)(LPOPENFILENAMEW))s_dynprocGetSaveFileNameW.pfn)
            (pofnw);
}



#endif

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\misc\uuid16.c ===
#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define INITGUID
#include <w4warn.h>
#include <windows.h>
#include <basetyps.h>
#include <olectl.h>

DEFINE_GUID(IID_IRequireClasses, 0x6d5140d0, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
DEFINE_GUID(IID_IActiveScriptSiteInterruptPoll, 0x539698a0, 0xcdca, 0x11cf, 0xa5, 0xeb, 0x00, 0xaa, 0x00, 0x47, 0xa0, 0x63);

// These are bogus IIDs.  We still need to sync up with the standard ID values
DEFINE_OLEGUID(IID_IAdviseSinkEx, 0x00000419, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSiteWindowless, 0x00000408, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSiteEx, 0x00000417, 0, 0);
DEFINE_OLEGUID(IID_IProvideClassInfo2, 0x00000410, 0, 0);
DEFINE_OLEGUID(IID_IOleParentUndoUnit, 0x00000422, 0, 0);
DEFINE_OLEGUID(IID_IOleUndoManager, 0x0000040c, 0, 0);
DEFINE_OLEGUID(IID_IEnumOleUndoUnits, 0x00000423, 0, 0);
DEFINE_OLEGUID(IID_IOleUndoUnit, 0x00000424, 0, 0);
DEFINE_OLEGUID(IID_IViewObjectEx, 0x0000041d, 0, 0);
DEFINE_OLEGUID(IID_IQuickActivate, 0x0000040b, 0, 0);
DEFINE_OLEGUID(IID_ICategorizeProperties, 0x0000042a, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObjectWindowless, 0x00000416, 0, 0);
DEFINE_OLEGUID(IID_ILocalRegistry, 0x0000041e, 0, 0);
DEFINE_OLEGUID(IID_ISelectionContainer, 0x00000428, 0, 0);
DEFINE_OLEGUID(IID_ICodeNavigate, 0x00000429, 0, 0);
DEFINE_OLEGUID(IID_IObjectWithSite, 0x0000042c, 0, 0);
DEFINE_OLEGUID(IID_IPointerInactive, 0x0000042d, 0, 0);
DEFINE_OLEGUID(IID_ILicensedClassManager, 0x00000412, 0, 0);
DEFINE_OLEGUID(IID_IVideoWindow, 0x00000430, 0, 0);
DEFINE_OLEGUID(CLSID_FilterGraph, 0x00000431, 0, 0);
DEFINE_OLEGUID(IID_IGraphBuilder, 0x00000432, 0, 0);
DEFINE_OLEGUID(IID_IBasicAudio, 0x00000433, 0, 0);
DEFINE_OLEGUID(IID_IBasicVideo, 0x00000434, 0, 0);
DEFINE_OLEGUID(IID_IMediaControl, 0x00000436, 0, 0);
DEFINE_OLEGUID(IID_IMediaPosition, 0x00000437, 0, 0);
DEFINE_OLEGUID(IID_IMediaEventEx, 0x00000435, 0, 0);
DEFINE_OLEGUID(IID_IMediaEvent, 0x00000438, 0, 0);
DEFINE_OLEGUID(IID_ITypeInfo2,      0x00020412L, 0, 0);


DEFINE_OLEGUID(IID_IBoundObject,      0x00000439L, 0, 0);
DEFINE_OLEGUID(IID_IBoundObjectSite,      0x00000440L, 0, 0);
DEFINE_OLEGUID(IID_ICursor,      0x00000441L, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\imgutil.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       imgutil.cxx
//
//  Contents:   Dynamic wrappers for plugin image decoder support DLL.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OCMM_H_
#define X_OCMM_H_
#include "ocmm.h"
#endif

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

#ifdef UNIX
#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include <ddraw.h>
#endif
#endif

DYNLIB g_dynlibIMGUTIL = { NULL, NULL, "imgutil.dll" };

void APIENTRY
InitImgUtil(void)
{
    static DYNPROC s_dynprocInitImgUtil =
            { NULL, &g_dynlibIMGUTIL, "InitImgUtil" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocInitImgUtil);
    if (hr)
        return ;

    (*(void (APIENTRY *)(void))s_dynprocInitImgUtil.pfn)
            ();
}

STDAPI DecodeImage( IStream* pStream, IMapMIMEToCLSID* pMap, 
   IUnknown* pEventSink )
{
    static DYNPROC s_dynprocDecodeImage =
            { NULL, &g_dynlibIMGUTIL, "DecodeImage" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocDecodeImage);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(IStream*, IMapMIMEToCLSID*, IUnknown*))s_dynprocDecodeImage.pfn)
            (pStream, pMap, pEventSink);
}

STDAPI CreateMIMEMap( IMapMIMEToCLSID** ppMap )
{
    static DYNPROC s_dynprocCreateMIMEMap =
            { NULL, &g_dynlibIMGUTIL, "CreateMIMEMap" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocCreateMIMEMap);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(IMapMIMEToCLSID**))s_dynprocCreateMIMEMap.pfn)
            (ppMap);
}

STDAPI GetMaxMIMEIDBytes( ULONG* pnMaxBytes )
{
    static DYNPROC s_dynprocGetMaxMIMEIDBytes =
            { NULL, &g_dynlibIMGUTIL, "GetMaxMIMEIDBytes" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetMaxMIMEIDBytes);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(ULONG*))s_dynprocGetMaxMIMEIDBytes.pfn)
            (pnMaxBytes);
}

STDAPI IdentifyMIMEType( const BYTE* pbBytes, ULONG nBytes, 
   UINT* pnFormat )
{
    static DYNPROC s_dynprocIdentifyMIMEType =
            { NULL, &g_dynlibIMGUTIL, "IdentifyMIMEType" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocIdentifyMIMEType);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(const BYTE*, ULONG, UINT*))s_dynprocIdentifyMIMEType.pfn)
            (pbBytes, nBytes, pnFormat);
}

STDAPI SniffStream( IStream* pInStream, UINT* pnFormat, 
   IStream** ppOutStream )
{
    static DYNPROC s_dynprocSniffStream =
            { NULL, &g_dynlibIMGUTIL, "SniffStream" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocSniffStream);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(IStream*, UINT*, IStream**))s_dynprocSniffStream.pfn)
            (pInStream, pnFormat, ppOutStream);
}

STDAPI ComputeInvCMAP(const RGBQUAD *pRGBColors, ULONG nColors, BYTE *pInvTable, ULONG cbTable)
{
    static DYNPROC s_dynprocComputeInvCMAP =
            { NULL, &g_dynlibIMGUTIL, "ComputeInvCMAP" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocComputeInvCMAP);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(const RGBQUAD *, ULONG, BYTE *, ULONG))s_dynprocComputeInvCMAP.pfn)
            (pRGBColors, nColors, pInvTable, cbTable);
}

STDAPI CreateDDrawSurfaceOnDIB(HBITMAP hbmDib, IDirectDrawSurface **ppSurface)
{
    static DYNPROC s_dynprocCreateDDrawSurfaceOnDIB =
            { NULL, &g_dynlibIMGUTIL, "CreateDDrawSurfaceOnDIB" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocCreateDDrawSurfaceOnDIB);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(HBITMAP, IDirectDrawSurface **))s_dynprocCreateDDrawSurfaceOnDIB.pfn)
            (hbmDib, ppSurface);
}

#if 0

// KENSY: This functionality is folded into MSHTML so that IMGUTIL doesn't
//        have to be loaded

STDAPI DitherTo8( BYTE * pDestBits, LONG nDestPitch, 
                   BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc, 
                   RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                   BYTE * pbDestInvMap,
                   LONG x, LONG y, LONG cx, LONG cy,
                   LONG lDestTrans, LONG lSrcTrans)
{
    static DYNPROC s_dynprocDitherTo8 =
            { NULL, &g_dynlibIMGUTIL, "DitherTo8" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocDitherTo8);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(BYTE *, LONG, BYTE *, LONG, REFGUID, RGBQUAD *, RGBQUAD *, BYTE *, LONG, LONG, LONG, LONG, LONG, LONG))s_dynprocDitherTo8.pfn)
        (pDestBits, nDestPitch, pSrcBits, nSrcPitch, bfidSrc, prgbDestColors, prgbSrcColors, pbDestInvMap, x, y, cx, cy, lDestTrans, lSrcTrans);
}

#endif

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\comctl32.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       comctl32.cxx
//
//  Contents:   Dynamic wrappers for common control procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#undef WINCOMMCTRLAPI
#define WINCOMMCTRLAPI
#include <commctrl.h>

#ifndef X_COMCTRLP_H_
#define X_COMCTRLP_H_
#include "comctrlp.h"
#endif

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

DYNLIB g_dynlibCOMCTL32 = { NULL, NULL, "comctl32.dll" };

void APIENTRY
InitCommonControls(void)
{
    static DYNPROC s_dynprocInitCommonControls =
            { NULL, &g_dynlibCOMCTL32, "InitCommonControls" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocInitCommonControls);
    if (hr)
        return ;

    (*(void (APIENTRY *)(void))s_dynprocInitCommonControls.pfn)
            ();
}


BOOL APIENTRY
InitCommonControlsEx(LPINITCOMMONCONTROLSEX lpICC)
{
    static DYNPROC s_dynprocInitCommonControlsEx =
            { NULL, &g_dynlibCOMCTL32, "InitCommonControlsEx" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocInitCommonControlsEx);
    if (hr)
        return FALSE;

    return(*(BOOL (APIENTRY *)(LPINITCOMMONCONTROLSEX))s_dynprocInitCommonControlsEx.pfn)
            (lpICC);
}


HIMAGELIST APIENTRY
WINAPI ImageList_Create(int cx,int cy,UINT flags,int cInitial,int cGrow)
{
    static DYNPROC s_dynprocImageList_Create =
            { NULL, &g_dynlibCOMCTL32, "ImageList_Create" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocImageList_Create);
    if (hr)
        return NULL;

    return(*(HIMAGELIST (APIENTRY *)(int ,int ,UINT ,int ,int ))s_dynprocImageList_Create.pfn)
            (cx,cy,flags,cInitial, cGrow);
}


int APIENTRY
WINAPI ImageList_AddMasked( HIMAGELIST  himl,   // handle to the image list
                            HBITMAP  hbmImage,  // handle to the bitmap
                            COLORREF  crMask    // color used to generate mask
                            )
{
    static DYNPROC s_dynprocImageList_AddMasked =
            { NULL, &g_dynlibCOMCTL32, "ImageList_AddMasked" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocImageList_AddMasked);
    if (hr)
        return -1;

    return(*(int (APIENTRY *)(HIMAGELIST ,HBITMAP , COLORREF ))s_dynprocImageList_AddMasked.pfn)
            (himl,hbmImage,crMask);
}


HIMAGELIST APIENTRY
WINAPI ImageList_Merge(HIMAGELIST  himl1,
                       int  i1,
                       HIMAGELIST  himl2,
                       int  i2,
                       int  dx,
                       int  dy
                       )
{
    static DYNPROC s_dynprocImageList_Merge =
            { NULL, &g_dynlibCOMCTL32, "ImageList_Merge" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocImageList_Merge);
    if (hr)
        return NULL;

    return(*(HIMAGELIST (APIENTRY *)(HIMAGELIST,int, HIMAGELIST,int,int,int))s_dynprocImageList_Merge.pfn)
            (himl1, i1,himl2, i2, dx, dy);
}


HICON APIENTRY
WINAPI ImageList_GetIcon( HIMAGELIST himl, int  i, UINT  flags )
{
    static DYNPROC s_dynprocImageList_GetIcon =
            { NULL, &g_dynlibCOMCTL32, "ImageList_GetIcon" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocImageList_GetIcon);
    if (hr)
        return NULL;

    return(*(HICON (APIENTRY *)(HIMAGELIST , int, UINT  ))s_dynprocImageList_GetIcon.pfn)
            (himl,  i, flags );
}



BOOL APIENTRY
WINAPI ImageList_Destroy( HIMAGELIST  himl)
{
    static DYNPROC s_dynprocImageList_Destroy =
            { NULL, &g_dynlibCOMCTL32, "ImageList_Destroy" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocImageList_Destroy);
    if (hr)
        return FALSE;

    return(*(BOOL (APIENTRY *)(HIMAGELIST ))s_dynprocImageList_Destroy.pfn)
            (himl);

}

WINCOMMCTRLAPI void APIENTRY
WINAPI DoReaderMode(PREADERMODEINFO prmi)
{
    // use ordinal instead of function name
    //
    static DYNPROC s_dynprocDoReaderMode =
#ifdef UNIX
            { NULL, &g_dynlibCOMCTL32, "DoReaderMode"};
#else
            { NULL, &g_dynlibCOMCTL32, (LPSTR) 383 };
#endif

    HRESULT hr;
    hr = LoadProcedure(&s_dynprocDoReaderMode);
    if (hr)
        return;

    (*(void (APIENTRY *) (PREADERMODEINFO )) s_dynprocDoReaderMode.pfn) (prmi);
}

#ifndef PRODUCT_96

HWND APIENTRY
WINAPI CreateToolbarEx(HWND        hwnd,
                       DWORD       ws,
                       UINT        wID,
                       int         nBitmaps,
                       HINSTANCE   hBMInst,
                       UINT        wBMID,
                       LPCTBBUTTON lpButton,
                       int         iNumButtons,
                       int         dxButton,
                       int         dyButton,
                       int         dxBitmap,
                       int         dyBitmap,
                       UINT        uStructSize)
{
    static DYNPROC s_dynprocCreateToolbarEx =
            { NULL, &g_dynlibCOMCTL32, "CreateToolbarEx" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocCreateToolbarEx);
    if (hr)
        return FALSE;

    return(*(HWND (APIENTRY *)(HWND,DWORD,UINT,int,HINSTANCE,UINT,LPCTBBUTTON,int,int,int,int,int,UINT ))s_dynprocCreateToolbarEx.pfn)
            (hwnd,ws,wID,nBitmaps,hBMInst,wBMID,lpButton,iNumButtons,dxButton,dyButton,dxBitmap,dyBitmap,uStructSize);

}

#endif


#ifdef VSTUDIO7


WINCOMMCTRLAPI
BOOL
WINAPI _TrackMouseEvent(LPTRACKMOUSEEVENT lpTME)
{
    static DYNPROC s_dynprocTrackMouseEvent =
            { NULL, &g_dynlibCOMCTL32, "_TrackMouseEvent" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocTrackMouseEvent);
    if (hr)
        return FALSE;

    return(*(BOOL (APIENTRY *)(LPTRACKMOUSEEVENT))s_dynprocTrackMouseEvent.pfn)
            (lpTME);
}

#endif

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\imm32.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       imm32.cxx
//
//  Contents:   Dynamic wrappers for imm32.dll functions
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_IMM_H_
#define X_IMM_H_
#include "imm.h"
#endif

#ifndef X_DIMM_H_
#define X_DIMM_H_
#include "dimm.h"
#endif

#ifndef NO_IME

DYNLIB g_dynlibIMM32 = { NULL, NULL, "IMM32.DLL" };

extern BOOL HasActiveIMM();
extern IActiveIMMApp * GetActiveIMM();

//----------------------------------------------------------------------------
// ActiveIMM wrappers
//----------------------------------------------------------------------------

HIMC ImmAssociateContextDIMM(HWND hWnd, HIMC hIMC)
{
    Assert(HasActiveIMM());

    HIMC hPrev;

    GetActiveIMM()->AssociateContext(hWnd, hIMC, &hPrev);

    return hPrev;
}

LRESULT ImmEscapeADIMM(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData)
{
    Assert(HasActiveIMM());

    LRESULT lResult;

    GetActiveIMM()->EscapeA(hKL, hIMC, uEscape, lpData, &lResult);

    return lResult;
}

LRESULT ImmEscapeWDIMM(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData)
{
    Assert(HasActiveIMM());

    LRESULT lResult;

    GetActiveIMM()->EscapeW(hKL, hIMC, uEscape, lpData, &lResult);

    return lResult;
}

BOOL ImmGetCandidateWindowDIMM(HIMC hIMC, DWORD dwBufLen, LPCANDIDATEFORM lpCandidate)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->GetCandidateWindow(hIMC, dwBufLen, lpCandidate));
}

LONG ImmGetCompositionStringADIMM(HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen)
{
    Assert(HasActiveIMM());
    
    LONG lCopied;

    GetActiveIMM()->GetCompositionStringA(hIMC, dwIndex, dwBufLen, &lCopied, lpBuf);

    return lCopied;
}

LONG ImmGetCompositionStringWDIMM(HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen)
{
    Assert(HasActiveIMM());
    
    LONG lCopied;

    GetActiveIMM()->GetCompositionStringW(hIMC, dwIndex, dwBufLen, &lCopied, lpBuf);

    return lCopied;
}

BOOL ImmSetCompositionStringADIMM(HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen, LPVOID lpRead, DWORD dwBufRead)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->SetCompositionStringA(hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwBufRead));
}

BOOL ImmSetCompositionStringWDIMM(HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen, LPVOID lpRead, DWORD dwBufRead)
{
    Assert(HasActiveIMM());
    
    return SUCCEEDED(GetActiveIMM()->SetCompositionStringW(hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwBufRead));
}

HIMC ImmGetContextDIMM(HWND hWnd)
{
    Assert(HasActiveIMM());

    HIMC hIMC;

    GetActiveIMM()->GetContext(hWnd, &hIMC);

    return hIMC;
}

BOOL ImmGetConversionStatusDIMM(HIMC hIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence));
}

BOOL ImmSetConversionStatusDIMM(HIMC hIMC, DWORD dwConversion, DWORD dwSentence)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->SetConversionStatus(hIMC, dwConversion, dwSentence));
}

BOOL ImmGetOpenStatusDIMM(HIMC hIMC)
{
    Assert(HasActiveIMM());

    return (GetActiveIMM()->GetOpenStatus(hIMC) == S_OK);
}

BOOL ImmSetOpenStatusDIMM(HIMC hIMC, BOOL fOpen)
{
    Assert(HasActiveIMM());

    return (GetActiveIMM()->SetOpenStatus(hIMC, fOpen) == S_OK);
}

DWORD ImmGetPropertyDIMM(HKL hKL, DWORD dwFlags)
{
    Assert(HasActiveIMM());

    DWORD dwProperty;

    GetActiveIMM()->GetProperty(hKL, dwFlags, &dwProperty);

    return dwProperty;
}

UINT ImmGetVirtualKeyDIMM(HWND hWnd)
{
    Assert(HasActiveIMM());

    UINT uVirtualKey;

    GetActiveIMM()->GetVirtualKey(hWnd, &uVirtualKey);

    return uVirtualKey;
}

BOOL ImmNotifyIMEDIMM(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->NotifyIME(hIMC, dwAction, dwIndex, dwValue));
}

BOOL ImmReleaseContextDIMM(HWND hWnd, HIMC hIMC)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->ReleaseContext(hWnd, hIMC));
}

BOOL ImmSetCandidateWindowDIMM(HIMC hIMC, LPCANDIDATEFORM lpCandidate)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->SetCandidateWindow(hIMC, lpCandidate));
}

BOOL ImmSetCompositionFontADIMM(HIMC hIMC, LPLOGFONTA lplf)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->SetCompositionFontA(hIMC, lplf));
}

BOOL ImmSetCompositionWindowDIMM(HIMC hIMC, LPCOMPOSITIONFORM lpcf)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->SetCompositionWindow(hIMC, lpcf));
}

BOOL ImmIsIMEDIMM(HKL hklCurrent)
{
    if(HasActiveIMM())
    {
        return GetActiveIMM()->IsIME(hklCurrent);
    }
    return FALSE;
}

#ifndef DLOAD1
//----------------------------------------------------------------------------
// Active wrapper functions
//----------------------------------------------------------------------------

#define WRAPIT(fn, rettype, errret, a1, a2)\
rettype WINAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibIMM32, #fn };\
    \
    if (HasActiveIMM()) \
        return fn##DIMM a2; \
    \
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        return errret;\
    return (*(rettype (WINAPI *) a1)s_dynproc##fn.pfn) a2;\
}

WRAPIT(ImmAssociateContext,
       HIMC,
       NULL,
       (HWND hwnd, HIMC himc),
       (hwnd, himc))

WRAPIT(ImmEscapeA,
       LRESULT,
       0,
       (HKL hkl, HIMC himc, UINT uEscape, LPVOID lpData),
       (hkl, himc, uEscape, lpData))

WRAPIT(ImmEscapeW,
       LRESULT,
       0,
       (HKL hkl, HIMC himc, UINT uEscape, LPVOID lpData),
       (hkl, himc, uEscape, lpData))

WRAPIT(ImmGetCandidateWindow,
       BOOL,
       0,
       (HIMC himc, DWORD dwBufLen, LPCANDIDATEFORM lpCandidate),
       (himc, dwBufLen, lpCandidate))

WRAPIT(ImmGetCompositionStringA,
       LONG,
       IMM_ERROR_GENERAL,
       (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen),
       (hIMC, dwIndex, lpBuf, dwBufLen))

WRAPIT(ImmGetCompositionStringW,
       LONG,
       IMM_ERROR_GENERAL,
       (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen),
       (hIMC, dwIndex, lpBuf, dwBufLen))

WRAPIT(ImmSetCompositionStringA,
       BOOL,
       0,
       (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen, LPVOID lpRead, DWORD dwBufRead),
       (hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwBufRead))

WRAPIT(ImmSetCompositionStringW,
       BOOL,
       0,
       (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen, LPVOID lpRead, DWORD dwBufRead),
       (hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwBufRead))

WRAPIT(ImmGetContext,
       HIMC,
       NULL,
       (HWND hwnd),
       (hwnd))

WRAPIT(ImmGetConversionStatus,
       BOOL,
       0,
       (HIMC himc, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence),
       (himc, lpfdwConversion, lpfdwSentence))

WRAPIT(ImmSetConversionStatus,
       BOOL,
       0,
       (HIMC himc, DWORD dwConversion, DWORD dwSentence),
       (himc, dwConversion, dwSentence))

WRAPIT(ImmGetOpenStatus,
       BOOL,
       FALSE,
       (HIMC himc),
       (himc))

WRAPIT(ImmSetOpenStatus,
       BOOL,
       FALSE,
       (HIMC himc, BOOL fOpen),
       (himc, fOpen))

WRAPIT(ImmGetProperty,
       DWORD,
       0,
       (HKL hkl, DWORD dwFlags),
       (hkl, dwFlags))

WRAPIT(ImmGetVirtualKey,
       UINT,
       0,
       (HWND hwnd),
       (hwnd))

WRAPIT(ImmNotifyIME,
       BOOL,
       0,
       (HIMC himc, DWORD dwAction, DWORD dwIndex, DWORD dwValue),
       (himc, dwAction, dwIndex, dwValue))

WRAPIT(ImmReleaseContext,
       BOOL,
       0,
       (HWND hwnd, HIMC himc),
       (hwnd, himc))

WRAPIT(ImmSetCandidateWindow,
       BOOL,
       0,
       (HIMC himc, LPCANDIDATEFORM lpCandidate),
       (himc, lpCandidate))

WRAPIT(ImmSetCompositionFontA,
       BOOL,
       0,
       (HIMC himc, LPLOGFONTA lplf),
       (himc, lplf))

WRAPIT(ImmSetCompositionWindow,
       BOOL,
       0,
       (HIMC himc, LPCOMPOSITIONFORM lpcf),
       (himc, lpcf))

WRAPIT(ImmIsIME,
       BOOL,
       FALSE,
       (HKL hklCurrent),
       (hklCurrent))
#endif // DLOAD1

//----------------------------------------------------------------------------
// Helpers
//----------------------------------------------------------------------------

HRESULT GetKeyboardCodePageDIMM(UINT *puCodePage)
{
    HRESULT hr;

    if (!HasActiveIMM())
    {
        UINT ConvertLanguageIDtoCodePage(WORD langid);

        *puCodePage = ConvertLanguageIDtoCodePage((WORD)(DWORD_PTR)GetKeyboardLayout(0 /*idThread*/));
        hr = S_FALSE;
    }
    else
    {
        hr = THR( GetActiveIMM()->GetCodePageA(GetKeyboardLayout(0), puCodePage) );
    }

    RRETURN1(hr,S_FALSE);
}

//
// Actually returns an LCID with SortID == 0, matching the behavior
// of GetKeyboardLCID.
//

HRESULT GetKeyboardLCIDDIMM(LCID *plid)
{
    HKL hKL = GetKeyboardLayout(0 /*idThread*/);

    if (HasActiveIMM())
    {
        HRESULT hr;
        LANGID langid;

        hr = THR( GetActiveIMM()->GetLangId(hKL, &langid) );
        if (OK(hr))
        {
            *plid = LCID(langid);
            return S_OK;
        }
    }

    *plid = (WORD)(DWORD_PTR)hKL;

    return S_FALSE;
}

#endif // ndef NO_IME

static const WORD s_CodePageTable[] =
{
// CodePage       PLID  primary language
// -------------------------------------
       0,       // 00 - undefined
    1256,       // 01 - Arabic
    1251,       // 02 - Bulgarian
    1252,       // 03 - Catalan
     950,       // 04 - Taiwan, Hong Kong (PRC and Singapore are 936)
    1250,       // 05 - Czech
    1252,       // 06 - Danish
    1252,       // 07 - German
    1253,       // 08 - Greek
    1252,       // 09 - English
    1252,       // 0a - Spanish
    1252,       // 0b - Finnish
    1252,       // 0c - French
    1255,       // 0d - Hebrew
    1250,       // 0e - Hungarian
    1252,       // 0f - Icelandic
    1252,       // 10 - Italian
     932,       // 11 - Japan
     949,       // 12 - Korea
    1252,       // 13 - Dutch
    1252,       // 14 - Norwegian
    1250,       // 15 - Polish
    1252,       // 16 - Portuguese
       0,       // 17 - Rhaeto-Romanic
    1250,       // 18 - Romanian
    1251,       // 19 - Russian
    1250,       // 1a - Croatian
    1250,       // 1b - Slovak
    1250,       // 1c - Albanian
    1252,       // 1d - Swedish
     874,       // 1e - Thai
    1254,       // 1f - Turkish
       0,       // 20 - Urdu
    1252,       // 21 - Indonesian
    1251,       // 22 - Ukranian
    1251,       // 23 - Byelorussian
    1250,       // 24 - Slovenian
    1257,       // 25 - Estonia
    1257,       // 26 - Latvian
    1257,       // 27 - Lithuanian
       0,       // 28 - undefined
    1256,       // 29 - Farsi
    1258,       // 2a - Vietnanese
       0,       // 2b - undefined
       0,       // 2c - undefined
    1252,       // 2d - Basque
       0,       // 2e - Sorbian
    1251,       // 2f - FYRO Macedonian
    1252,       // 30 - Sutu        *** use 1252 for the following ***
    1252,       // 31 - Tsonga
    1252,       // 32 - Tswana
    1252,       // 33 - Venda
    1252,       // 34 - Xhosa
    1252,       // 35 - Zulu
    1252,       // 36 - Africaans (uses 1252)
    1252,       // 38 - Faerose
    1252,       // 39 - Hindi
    1252,       // 3a - Maltese
    1252,       // 3b - Sami
    1252,       // 3c - Gaelic
    1252,       // 3e - Malaysian
       0,       // 3f -
       0,       // 40 -
    1252,       // 41 - Swahili
       0,       // 42 - 
       0,       // 43 - 
       0,       // 44 - 
    1252,       // 45 - Bengali *** The following languages use 1252, but
    1252,       // 46 - Gurmuki     actually have only Unicode characters ***
    1252,       // 47 - Gujarait
    1252,       // 48 - Oriya
    1252,       // 49 - Tamil
    1252,       // 4a - Telugu
    1252,       // 4b - Kannada
    1252,       // 4c - Malayalam
       0,       // 4d - 
       0,       // 4e - 
       0,       // 4f - 
    1252,       // 50 - Mongolian
    1252,       // 51 - Tibetan
       0,       // 52 - 
    1252,       // 53 - Khmer
    1252,       // 54 - Lao
    1252,       // 55 - Burmese
       0,       // 56 - LANG_MAX
};

#define ns_CodePageTable  (sizeof(s_CodePageTable)/sizeof(s_CodePageTable[0]))

#if !defined(lidSerbianCyrillic)
  #define lidSerbianCyrillic 0xc1a
#else
  #if lidSerbianCyrillic != 0xc1a
    #error "lidSerbianCyrillic macro value has changed"
  #endif // lidSerbianCyrillic
#endif

/*
 *  ConvertLanguageIDtoCodePage (lid)
 *
 *  @mfunc      Maps a language ID to a Code Page
 *
 *  @rdesc      returns Code Page
 *
 *  @devnote:
 *      This routine takes advantage of the fact that except for Chinese,
 *      the code page is determined uniquely by the primary language ID,
 *      which is given by the low-order 10 bits of the lcid.
 *
 *      The WORD s_CodePageTable could be replaced by a BYTE with the addition
 *      of a couple of if's and the BYTE table replaced by a nibble table
 *      with the addition of a shift and a mask.  Since the table is only
 *      92 bytes long, it seems that the simplicity of using actual code page
 *      values is worth the extra bytes.
 */

UINT
ConvertLanguageIDtoCodePage(WORD langid)
{
    WORD langidT = PRIMARYLANGID(langid);       // langidT = primary language (Plangid)
    CODEPAGE cp;

#if !defined(UNIX)
    if(langidT >= LANG_CROATIAN)                // Plangid = 0x1a
    {
        if(langid == lidSerbianCyrillic)        // Special case for langid = 0xc1a
            return 1251;                        // Use Cyrillic code page

        if(langidT >= ns_CodePageTable)         // Africans Plangid = 0x36, which
            return CP_ACP;                      //  is outside table
    }
#endif // !UNIX

    cp = s_CodePageTable[langidT];              // Translate Plangid to code page

    if(cp != 950 || (langid & 0x400))           // All but Singapore, PRC, and Serbian
        return cp != 0 ? cp : CP_ACP;           // Remember there are holes in the array
                                                // that may not always be there.

    return 936;                                 // Singapore and PRC
}

/*
 *  GetKeyboardCodePage ()
 *
 *  @mfunc      Gets Code Page for keyboard active on current thread
 *
 *  @rdesc      returns Code Page
 */

UINT GetKeyboardCodePage()
{
#if !defined(MACPORT) && !defined(WINCE)
  #ifndef NO_IME
    UINT uCodePage;
    return SUCCEEDED(GetKeyboardCodePageDIMM(&uCodePage)) ? uCodePage : GetACP();
  #else
    return ConvertLanguageIDtoCodePage((WORD)(DWORD)GetKeyboardLayout(0 /*idThread*/));
  #endif  
#else
    return ConvertLanguageIDtoCodePage(GetUserDefaultLCID());
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\dynwrap.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dynwrap.cxx
//
//  Contents:   Utility for dynamically loaded procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

extern void MLangUnload();
extern BOOL IsMLangLoaded();

// List of loaded libraries.

DeclareTag(tagLoadDll, "!Perf", "Trace callers on DLL loads");

static DYNLIB * s_pdynlibHead;

#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   DeinitDynamicLibrary
//
//  Synopsis:   Unloads library
//
//----------------------------------------------------------------------------
void
DeinitDynamicLibrary(LPCTSTR pchLib)
{
    DYNLIB * pdynlib, ** ppdynlibPrev;
    char buf[200];
    int l;

    l = WideCharToMultiByte(CP_ACP, 0, pchLib, _tcslen(pchLib), buf, ARRAY_SIZE(buf), NULL, NULL);

    if (!StrCmpNICA(buf, "mlang.dll", l))
    {
        MLangUnload();
    }
    else
    {
        ppdynlibPrev = &s_pdynlibHead;
        for (pdynlib = s_pdynlibHead; pdynlib; )
        {
            if (!StrCmpNICA(buf, pdynlib->achName, l))
            {
                if (pdynlib->hinst)
                {
                    FreeLibrary(pdynlib->hinst);
                    pdynlib->hinst = NULL;
                    *ppdynlibPrev = pdynlib = pdynlib->pdynlibNext;
                }
            }
            else
            {
                ppdynlibPrev = &pdynlib->pdynlibNext;
                pdynlib = pdynlib->pdynlibNext;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IsDynamicLibraryLoaded
//
//  Synopsis:   Check if library loaded
//
//----------------------------------------------------------------------------
BOOL
IsDynamicLibraryLoaded(LPCTSTR pchLib)
{
    DYNLIB * pdynlib;
    char buf[200];
    int l;

    l = WideCharToMultiByte(CP_ACP, 0, pchLib, _tcslen(pchLib), buf, ARRAY_SIZE(buf), NULL, NULL);

    if (!StrCmpNICA(buf, "mlang.dll", l))
    {
        return IsMLangLoaded();
    }
    else
    {
        for (pdynlib = s_pdynlibHead; pdynlib; pdynlib = pdynlib->pdynlibNext)
        {
            if (!StrCmpNICA(buf, pdynlib->achName, l))
            {
                if (pdynlib->hinst)
                {
                    return TRUE;
                }
                break;
            }
        }
    }

    return FALSE;
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   DeinitDynamicLibraries
//
//  Synopsis:   Undoes the work of LoadProcedure.
//
//----------------------------------------------------------------------------
void
DeinitDynamicLibraries()
{
    DYNLIB * pdynlib;

    for (pdynlib = s_pdynlibHead; pdynlib; pdynlib = pdynlib->pdynlibNext)
    {
        if (pdynlib->hinst)
        {
            FreeLibrary(pdynlib->hinst);
            pdynlib->hinst = NULL;
        }
    }
    s_pdynlibHead = NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadProcedure
//
//  Synopsis:   Load library and get address of procedure.
//
//              Declare DYNLIB and DYNPROC globals describing the procedure.
//              Note that several DYNPROC structures can point to a single
//              DYNLIB structure.
//
//                  DYNLIB g_dynlibOLEDLG = { NULL, "OLEDLG.DLL" };
//                  DYNPROC g_dynprocOleUIInsertObjectA =
//                          { NULL, &g_dynlibOLEDLG, "OleUIInsertObjectA" };
//                  DYNPROC g_dynprocOleUIPasteSpecialA =
//                          { NULL, &g_dynlibOLEDLG, "OleUIPasteSpecialA" };
//
//              Call LoadProcedure to load the library and get the procedure
//              address.  LoadProcedure returns immediatly if the procedure
//              has already been loaded.
//
//                  hr = LoadProcedure(&g_dynprocOLEUIInsertObjectA);
//                  if (hr)
//                      goto Error;
//
//                  uiResult = (*(UINT (__stdcall *)(LPOLEUIINSERTOBJECTA))
//                      g_dynprocOLEUIInsertObjectA.pfn)(&ouiio);
//
//              Release the library at shutdown.
//
//                  void DllProcessDetach()
//                  {
//                      DeinitDynamicLibraries();
//                  }
//
//  Arguments:  pdynproc  Descrition of library and procedure to load.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
LoadProcedure(DYNPROC *pdynproc)
{
    HINSTANCE   hinst;
    DYNLIB *    pdynlib = pdynproc->pdynlib;
    DWORD       dwError;

    if (pdynproc->pfn && pdynlib->hinst)
        return S_OK;

    if (!pdynlib->hinst)
    {
        TraceTag((tagPerf, "Loading library %s", pdynlib->achName));
        TraceTag((tagLoadDll, "%s initially loaded by:", pdynlib->achName));
        TraceCallers(tagLoadDll, 0, 10);
        
        // Try to load the library using the normal mechanism.

        hinst = LoadLibraryA(pdynlib->achName);

#ifdef WINCE
        if (!hinst)
        {
            goto Error;
        }
#endif // WINCE

#if !defined(WINCE)
        // If that failed because the module was not be found,
        // then try to find the module in the directory we were
        // loaded from.

        if (!hinst)
        {
            dwError = GetLastError();

            if (   dwError == ERROR_MOD_NOT_FOUND
                || dwError == ERROR_DLL_NOT_FOUND)
            {
                char achBuf1[MAX_PATH];
                char achBuf2[MAX_PATH];
                char *pch;

                // Get path name of this module.
                if (GetModuleFileNameA(g_hInstCore, achBuf1, ARRAY_SIZE(achBuf1)) == 0)
                    goto Error;

                // Find where the file name starts in the module path.
                if (GetFullPathNameA(achBuf1, ARRAY_SIZE(achBuf2), achBuf2, &pch) == 0)
                    goto Error;

                // Chop off the file name to get a directory name.
                *pch = 0;

                // See if there's a dll with the given name in the directory.
                if (SearchPathA(
                        achBuf2,
                        pdynlib->achName,
                        NULL,
                        ARRAY_SIZE(achBuf1),
                        achBuf1,
                        NULL) != 0)
                {
                    // Yes, there's a dll. Load it.
                    hinst = LoadLibraryExA(
                                achBuf1,
                                NULL,
                                LOAD_WITH_ALTERED_SEARCH_PATH);
                }
            }
        }
        if (!hinst)
        {
            goto Error;
        }
#endif // !defined(WINCE)

        // Link into list for DeinitDynamicLibraries

        {
            LOCK_GLOBALS;

            if (pdynlib->hinst)
                FreeLibrary(hinst);
            else
            {
                pdynlib->hinst = hinst;
                pdynlib->pdynlibNext = s_pdynlibHead;
                s_pdynlibHead = pdynlib;
            }
        }
    }

    pdynproc->pfn = GetProcAddress(pdynlib->hinst, pdynproc->achName);
    if (!pdynproc->pfn)
    {
        goto Error;
    }

    return S_OK;

Error:
    RRETURN(GetLastWin32Error());
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeDynlib
//
//  Synopsis:   Free a solitary dynlib entry from the link list of dynlibs
//
//  Arguments:  Pointer to DYNLIB to be freed
//
//  Returns:    S_OK
//
//----------------------------------------------------------------------------

HRESULT
FreeDynlib(DYNLIB *pdynlib)
{
    DYNLIB ** ppdynlibPrev;

    LOCK_GLOBALS;

    if (pdynlib == s_pdynlibHead)
    {
        ppdynlibPrev = &s_pdynlibHead;
    }
    else
    {
        DYNLIB * pdynlibPrev;

        for (pdynlibPrev = s_pdynlibHead;
             pdynlibPrev && pdynlibPrev->pdynlibNext != pdynlib;
             pdynlibPrev = pdynlibPrev->pdynlibNext);

        ppdynlibPrev = pdynlibPrev ? &pdynlibPrev->pdynlibNext : NULL;
    }

    if (ppdynlibPrev)
    {
        if (pdynlib->hinst)
        {
            FreeLibrary(pdynlib->hinst);
            pdynlib->hinst = NULL;
        }
        
        *ppdynlibPrev = pdynlib->pdynlibNext;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\hlink.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       hlink.cxx
//
//  Contents:   Dynamic wrappers for Hlink.dll functions
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_HLINK_H_
#define X_HLINK_H_
#include "hlink.h"
#endif

DYNLIB g_dynlibHLINK = { NULL, NULL, "HLINK.DLL" };

#define WRAPIT(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibHLINK, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}


WRAPIT(HlinkCreateFromMoniker,
    (IMoniker * pimkTrgt, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, IHlinkSite * pihlsite,
     DWORD dwSiteData, IUnknown * piunkOuter, REFIID riid, void ** ppvObj),
    (pimkTrgt, pwzLocation, pwzFriendlyName, pihlsite, dwSiteData, piunkOuter, riid, ppvObj))

WRAPIT(HlinkCreateFromString,
    (LPCWSTR pwzTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, IHlinkSite * pihlsite,
     DWORD dwSiteData, IUnknown * piunkOuter, REFIID riid, void ** ppvObj),
    (pwzTarget, pwzLocation, pwzFriendlyName, pihlsite, dwSiteData, piunkOuter, riid, ppvObj))


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\inetcomm.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       inetcomm.cxx
//
//  Contents:   Dynamic wrappers for INETCOMM.DLL.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"
#endif

#ifndef X_WINCRYPT_H_
#define X_WINCRYPT_H_
#include "wincrypt.h"
#endif

// #define _WIN32_OE  0x0500 // TODO: until this is globally visible - and only if your want MHTML
#ifndef X_MIMEOLE_H_
#define X_MIMEOLE_H_
#define _MIMEOLE_   // To avoid having DECLSPEC_IMPORT
#include "mimeole.h"
#endif

// Turn on DEFINE_GUID
#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
  
// {35461E30-C488-11d1-960E-00C04FBD7C09}
DEFINE_GUID(CLSID_IMimeObjResolver, 0x35461e30, 0xc488, 0x11d1, 0x96, 0xe, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

// {FECEAFFD-C441-11d1-960E-00C04FBD7C09}
DEFINE_GUID(IID_IMimeObjResolver, 0xfeceaffd, 0xc441, 0x11d1, 0x96, 0xe, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

DYNLIB g_dynlibINETCOMM = { NULL, NULL, "INETCOMM.DLL" };        

//+---------------------------------------------------------------------------
//
//  Function:   MimeOleObjectFromMoniker
//
//  Synopsis:   Wraps either IMimeObjResolver.MimeOleObjectFromMoniker or 
//              imported function MimeOleObjectFromMoniker from INETCOMM.DLL
//              First, we attempt to cocreate an IMimeObjResolver. If this
//              fails, we try to call the INETCOMM.DLL directly. If this
//              fails, many bad things will happen.
//
//----------------------------------------------------------------------------

HRESULT WINAPI  MimeOleObjectFromMoniker(
            /* in */        BINDF               bindf,
            /* in */        IMoniker            *pmkOriginal,
            /* in */        IBindCtx            *pBindCtx,
            /* in */        REFIID              riid, 
            /* out */       LPVOID              *ppvObject,
            /* out */       IMoniker            **ppmkNew )
{
    HRESULT hr = E_FAIL;

    // Load IMimeObjResolver from CoCreateInstance
    IMimeObjResolver * pObjResolver = NULL;

    hr = THR( CoCreateInstance( CLSID_IMimeObjResolver, 
                                NULL, 
                                CLSCTX_INPROC_SERVER,
                                IID_IMimeObjResolver,
                                (void **) &pObjResolver ));

    if(! FAILED( hr ))
    {
        // If we sucessfully cocreated the object, dispatch to it
        hr = pObjResolver->MimeOleObjectFromMoniker( bindf, pmkOriginal, pBindCtx, riid, ppvObject, ppmkNew );
        pObjResolver->Release();
        pObjResolver = NULL;
    }
    else
    {
        // LoadLibrary and call the exported function directly
        static DYNPROC s_dynprocMOOFM = { NULL, &g_dynlibINETCOMM, "MimeOleObjectFromMoniker" };
        hr = THR( LoadProcedure( &s_dynprocMOOFM ));
        
        if (hr)
            goto Cleanup;
            
        // The following mess is defining, derefing, and calling a function pointer pfn                                    
        hr = THR((* ( HRESULT (WINAPI *) (  BINDF bindf, 
                                            IMoniker *pmkOriginal, 
                                            IBindCtx *pBindCtx, 
                                            REFIID riid, 
                                            LPVOID *ppvObject, 
                                            IMoniker **ppmkNew )        // api of fn ptr
                    ) s_dynprocMOOFM.pfn )( bindf,                      // call to fn ptr
                                            pmkOriginal, 
                                            pBindCtx, 
                                            riid, 
                                            ppvObject, 
                                            ppmkNew )  );
    }

Cleanup:
    RRETURN2( hr, S_FALSE, MK_S_ASYNCHRONOUS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\msjava.cxx ===
#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define JAVAVMAPI                  // avoid dll linkage errors

#ifndef X_NATIVE_H_
#define X_NATIVE_H_
#include "native.h"
#endif

#ifndef X_NATIVCOM_H_
#define X_NATIVCOM_H_
#include "nativcom.h"
#endif



DYNLIB g_dynlibMSJAVA = { NULL, NULL, "MSJAVA.DLL" };
extern DYNLIB g_dynlibSHDOCVW;

#define EXTERNC extern "C"

EXTERNC long __cdecl execute_java_dynamic_method(ExecEnv *ee, HObject *obj, const char
        *method_name, const char *signature, ...)
{
    va_list arg;
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "execute_java_dynamic_methodV" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    va_start(arg, signature);

    int64_t retVal = (*(int64_t (__cdecl *)(ExecEnv*, HObject*, const char *,
        const char*, va_list))s_dynproc.pfn)
            ( ee, obj, method_name, signature, arg);
    va_end(arg);
    return (long)retVal;
}

EXTERNC int64_t __cdecl execute_java_dynamic_method64(ExecEnv *ee, HObject *obj, const char
        *method_name, const char *signature, ...)
{
    va_list arg;
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "execute_java_dynamic_methodV" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    va_start(arg, signature);

    int64_t retVal = (*(int64_t (__cdecl *)(ExecEnv*, HObject*, const char *,
        const char*, va_list))s_dynproc.pfn)
            ( ee, obj, method_name, signature, arg);
    va_end(arg);
    return retVal;
}

EXTERNC HObject* __cdecl execute_java_constructor(ExecEnv *ee, const char *classname,       \
        ClassClass *cb, const char *signature, ...)
{
    va_list arg;
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "execute_java_constructorV" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return NULL;

    va_start(arg, signature);

    HObject* retVal = (*(HObject* (__cdecl *)(ExecEnv*, const char *,
        ClassClass*, const char*, va_list))s_dynproc.pfn)
            ( ee, classname, cb, signature, arg );
    va_end(arg);
    return retVal;
}

EXTERNC BOOL __cdecl is_instance_of(JHandle *phobj,ClassClass *dcb,ExecEnv *ee)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "is_instance_of" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return FALSE;

    return (*(BOOL (__cdecl *)(JHandle*,ClassClass*,ExecEnv*))s_dynproc.pfn)
            ( phobj, dcb, ee );
}

EXTERNC Hjava_lang_String* __cdecl makeJavaStringW(const unicode *pszwSrc, int cch)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "makeJavaStringW" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    return (*(Hjava_lang_String* (__cdecl *)(const unicode*,int))s_dynproc.pfn)
            ( pszwSrc, cch );
}

EXTERNC ClassClass* __cdecl FindClass(ExecEnv *ee, PCUTF8 classname, bool_t resolve)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "FindClass" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    return (*(ClassClass* (__cdecl *)(ExecEnv*, PCUTF8, bool_t))s_dynproc.pfn)
            ( ee, classname, resolve );
}

EXTERNC unicode * __cdecl javaStringStart (HString *string)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "javaStringStart" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    return (*(unicode* (__cdecl *)(HString*))s_dynproc.pfn)
            ( string );
}

EXTERNC int __cdecl javaStringLength(Hjava_lang_String *string)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "javaStringLength" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    return (*(int (__cdecl *)(HString*))s_dynproc.pfn)
            ( string );
}

Hjava_lang_Object * __cdecl convert_IUnknown_to_Java_Object(IUnknown *punk,
                                                            Hjava_lang_Object *phJavaClass,
                                                            int       fAssumeThreadSafe)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "convert_IUnknown_to_Java_Object" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return NULL;

    return (*(Hjava_lang_Object* (__cdecl *)(IUnknown*,
                                              Hjava_lang_Object*,
                                              int))s_dynproc.pfn)
            ( punk, phJavaClass, fAssumeThreadSafe );
}

IUnknown * __cdecl convert_Java_Object_to_IUnknown(Hjava_lang_Object *phJavaObject, const IID *pIID)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "convert_Java_Object_to_IUnknown" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return NULL;

    return (*(IUnknown* (__cdecl *)(Hjava_lang_Object*,
                                     const IID*))s_dynproc.pfn)
            ( phJavaObject, pIID );
}

void __cdecl GCFramePush(PVOID pGCFrame, PVOID pObjects, DWORD cbObjectStructSize)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "GCFramePush" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return;

    (*(void (__cdecl *)(PVOID, PVOID, DWORD))s_dynproc.pfn)
            ( pGCFrame, pObjects, cbObjectStructSize );
}

void __cdecl GCFramePop(PVOID pGCFrame)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "GCFramePop" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return;

    (*(void (__cdecl *)(PVOID))s_dynproc.pfn) ( pGCFrame );
}

void* __cdecl jcdwGetData(Hjava_lang_Object * phJCDW)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "jcdwGetData" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return NULL;

    return (*(void* (__cdecl *)(Hjava_lang_Object*))s_dynproc.pfn)
            ( phJCDW );
}

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\msls.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       msls.cxx
//
//  Contents:   Dynamic wrappers for Line Services procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LSDEFS_H_
#define X_LSDEFS_H_
#include "lsdefs.h"
#endif

#ifndef X_LSFRUN_H_
#define X_LSFRUN_H_
#include "lsfrun.h"
#endif

#ifndef X_FMTRES_H_
#define X_FMTRES_H_
#include "fmtres.h"
#endif

#ifndef X_PLSDNODE_H_
#define X_PLSDNODE_H_
#include "plsdnode.h"
#endif

#ifndef X_PLSSUBL_H_
#define X_PLSSUBL_H_
#include "plssubl.h"
#endif

#ifndef X_LSKJUST_H_
#define X_LSKJUST_H_
#include "lskjust.h"
#endif

#ifndef X_LSCONTXT_H_
#define X_LSCONTXT_H_
#include "lscontxt.h"
#endif

#ifndef X_LSLINFO_H_
#define X_LSLINFO_H_
#include "lslinfo.h"
#endif

#ifndef X_PLSLINE_H_
#define X_PLSLINE_H_
#include "plsline.h"
#endif

#ifndef X_PLSSUBL_H_
#define X_PLSSUBL_H_
#include "plssubl.h"
#endif

#ifndef X_PDOBJ_H_
#define X_PDOBJ_H_
#include "pdobj.h"
#endif

#ifndef X_PHEIGHTS_H_
#define X_PHEIGHTS_H_
#include "pheights.h"
#endif

#ifndef X_PLSRUN_H_
#define X_PLSRUN_H_
#include "plsrun.h"
#endif

#ifndef X_LSESC_H_
#define X_LSESC_H_
#include "lsesc.h"
#endif

#ifndef X_POBJDIM_H_
#define X_POBJDIM_H_
#include "pobjdim.h"
#endif

#ifndef X_LSPRACT_H_
#define X_LSPRACT_H_
#include "lspract.h"
#endif

#ifndef X_LSBRK_H_
#define X_LSBRK_H_
#include "lsbrk.h"
#endif

#ifndef X_LSDEVRES_H_
#define X_LSDEVRES_H_
#include "lsdevres.h"
#endif

#ifndef X_LSEXPAN_H_
#define X_LSEXPAN_H_
#include "lsexpan.h"
#endif

#ifndef X_LSPAIRAC_H_
#define X_LSPAIRAC_H_
#include "lspairac.h"
#endif

#ifndef X_LSKTAB_H_
#define X_LSKTAB_H_
#include "lsktab.h"
#endif

#ifndef X_LSKEOP_H_
#define X_LSKEOP_H_
#include "lskeop.h"
#endif

#ifndef X_PLSQSINF_H_
#define X_PLSQSINF_H_
#include "plsqsinf.h"
#endif

#ifndef X_PCELLDET_H_
#define X_PCELLDET_H_
#include "pcelldet.h"
#endif

#ifndef X_PLSCELL_H_
#define X_PLSCELL_H_
#include "plscell.h"
#endif

#ifndef X_BRKPOS_H_
#define X_BRKPOS_H_
#include "brkpos.h"
#endif

#ifndef X_LSFUNCWRAP_HXX_
#define X_LSFUNCWRAP_HXX_
#include "lsfuncwrap.hxx"
#endif

// Define the DYNLIB for MSLS
DYNLIB g_dynlibMSLS = { NULL, NULL, "MSLS31.DLL" };

// Define the DYNPROC for all MSLS functions
#define LSWRAP(fn,a1,a2) DYNPROC g_dynproc##fn = { NULL, &g_dynlibMSLS, #fn };
LSFUNCS()
#undef LSWRAP

HRESULT 
InitializeLSDynProcs()
{
    HRESULT hr;

    // It is okay to call LoadProcedure multiple times and on different threads -- we just do this for perf.
    static  BOOL fDLLInited = FALSE;

    if (fDLLInited)
        return S_OK;

#define LSWRAP(fn,a1,a2) \
    hr = THR(LoadProcedure(&g_dynproc##fn));\
    if (hr)\
        goto Cleanup;

    LSFUNCS();
#undef LSWRAP

Cleanup:
    if (!hr)
        fDLLInited = TRUE;

    RRETURN (hr);
}


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\oleaut32.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       oleaut32.cxx
//
//  Contents:   Dynamic wrappers for OLE Automation monikers.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

DYNLIB g_dynlibOLEAUT32 = { NULL, NULL, "oleaut32.dll" };

#define WRAP_HR(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEAUT32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

#define WRAP_HR_NOTHR(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEAUT32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = (*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2;\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

#define WRAP(t, fn, a1, a2)\
STDAPI_(t) fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEAUT32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        return 0;\
    return (*(t (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAP_VOID(fn, a1, a2)\
STDAPI_(void) fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEAUT32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        return;\
    (*(void (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2;\
}

WINOLEAUTAPI_(void )
VariantInit(VARIANTARG *pvarg)
{
	pvarg->vt = VT_EMPTY;
}

WINOLEAUTAPI
VariantClear(VARIANTARG *pvarg)
{
    HRESULT hr;
    static DYNPROC s_dynprocVariantClear = { NULL, &g_dynlibOLEAUT32, "VariantClear" };

	switch (pvarg->vt)
	{
	case VT_I1:
	case VT_I2:
	case VT_I4:
	case VT_R4:
	case VT_R8:
	case VT_CY:
	case VT_NULL:
	case VT_EMPTY:
	case VT_BOOL:
		break;
		
	case VT_DISPATCH:
	case VT_UNKNOWN:
		ReleaseInterface(V_UNKNOWN(pvarg));
		break;

    case VT_SAFEARRAY:
        THR(SafeArrayDestroy(V_ARRAY(pvarg)));
        break;
		
	default:
		hr = THR(LoadProcedure(&s_dynprocVariantClear));
		if (hr)
			RRETURN(hr);
		hr = THR((*(HRESULT (STDAPICALLTYPE *) (VARIANTARG *))s_dynprocVariantClear.pfn)(pvarg));
		RRETURN(hr);
	}

	V_VT(pvarg) = VT_EMPTY;
	RRETURN(S_OK);
}

WRAP_HR(RegisterTypeLib,
    (ITypeLib *ptlib, OLECHAR *szFullPath, OLECHAR *szHelpDir),
    (ptlib, szFullPath, szHelpDir))

WRAP_HR(LoadTypeLib,
    (const OLECHAR *szFile, ITypeLib **pptlib), 
    (szFile, pptlib))

WRAP_HR(SetErrorInfo,
   (unsigned long dwReserved, IErrorInfo*perrinfo), 
   (dwReserved, perrinfo))

WRAP_HR(GetErrorInfo, 
    (ULONG dwReserved, IErrorInfo ** pperrinfo), 
    (dwReserved, pperrinfo))

WRAP_HR(LoadRegTypeLib,
    (REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib **pptlib),
    (rguid, wVerMajor, wVerMinor, lcid, pptlib))

WINOLEAUTAPI
VariantCopy(VARIANTARG *pvargDest, VARIANTARG *pvargSrc)
{
    HRESULT hr;
    static DYNPROC s_dynprocVariantCopy = { NULL, &g_dynlibOLEAUT32, "VariantCopy" };

	switch (pvargSrc->vt)
	{
	case VT_I1:
	case VT_I2:
	case VT_I4:
	case VT_R4:
	case VT_R8:
	case VT_CY:
	case VT_NULL:
	case VT_EMPTY:
	case VT_BOOL:
        hr = S_OK;
		break;
		
	case VT_DISPATCH:
	case VT_UNKNOWN:
        hr = S_OK;
		if ( V_UNKNOWN(pvargSrc) )
			V_UNKNOWN(pvargSrc)->AddRef();
		break;

    case VT_SAFEARRAY:
        hr = S_OK;
        pvargDest->vt = VT_SAFEARRAY;
        if (V_ARRAY(pvargSrc))
            hr = THR(SafeArrayCopy(V_ARRAY(pvargSrc), &V_ARRAY(pvargDest)));
        else
            V_ARRAY(pvargDest) = NULL;
        RRETURN(hr);
        break;

	default:
		hr = THR(LoadProcedure(&s_dynprocVariantCopy));
		if (hr)
			RRETURN(hr);
		hr = THR((*(HRESULT (STDAPICALLTYPE *) (VARIANTARG *, VARIANTARG *))s_dynprocVariantCopy.pfn)(pvargDest, pvargSrc));
		RRETURN(hr);
	}

    VariantClear(pvargDest);
    *pvargDest = *pvargSrc;
	RRETURN(hr);
}

WRAP_HR(VariantChangeType,
    (VARIANTARG *pvargDest, VARIANTARG *pvarSrc, unsigned short wFlags, VARTYPE vt),
    (pvargDest, pvarSrc, wFlags, vt))

WRAP(BSTR, SysAllocStringLen,
    (const OLECHAR*pch, unsigned int i), (pch, i))

WRAP(BSTR, SysAllocString,
    (const OLECHAR*pch), (pch))

WRAP(BSTR, SysAllocStringByteLen, (LPCSTR psz, UINT len), (psz, len))

STDAPI_(void) SysFreeString(BSTR bs)
{
    if (bs)
    {
        HRESULT hr;
        static DYNPROC s_dynprocSysFreeString = { NULL, &g_dynlibOLEAUT32, "SysFreeString" };
        hr = THR(LoadProcedure(&s_dynprocSysFreeString));
        if (hr)
            return;
        (*(void (STDAPICALLTYPE *) (BSTR bs))s_dynprocSysFreeString.pfn)(bs);
    }
}

WRAP_HR(DispGetIDsOfNames,
    (ITypeInfo*ptinfo, OLECHAR **rgszNames, UINT cNames, DISPID*rgdispid),
    (ptinfo, rgszNames, cNames, rgdispid))

WRAP_HR(DispInvoke, 
        (void * _this, ITypeInfo * ptinfo, DISPID dispidMember, WORD wFlags, 
         DISPPARAMS * pparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr),
        ( _this, ptinfo, dispidMember, wFlags, pparams, pvarResult, pexcepinfo, puArgErr))

WRAP_HR(CreateErrorInfo,
    (ICreateErrorInfo **pperrinfo), (pperrinfo))

WRAP(SAFEARRAY *, SafeArrayCreateVector,
    (VARTYPE vt, long iBound, ULONG cElements), (vt, iBound, cElements) );

WRAP_HR(SafeArrayAccessData,
    (SAFEARRAY * psa, void HUGEP** ppvData), (psa, ppvData))

WRAP_HR(SafeArrayUnaccessData,
    (SAFEARRAY * psa), (psa) );

WRAP(UINT, SafeArrayGetElemsize,
    (SAFEARRAY * psa), (psa) );

WRAP_HR(SafeArrayGetUBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plUBound),
    (psa,nDim,plUBound))

WRAP_HR(SafeArrayGetElement,
    (SAFEARRAY * psa, LONG * rgIndices, void * pv), (psa, rgIndices, pv))

WRAP(UINT, SafeArrayGetDim,
    (SAFEARRAY * psa), (psa))

WRAP(UINT, SysStringLen,
    (BSTR bstr), (bstr))

WRAP_HR(SafeArrayDestroy,
    (SAFEARRAY * psa), (psa))

WRAP(INT, DosDateTimeToVariantTime,
    (USHORT wDosDate, USHORT wDosTime, DOUBLE * pvtime), (wDosDate, wDosTime, pvtime))

WRAP(UINT, SysStringByteLen, (BSTR bstr), (bstr))

WRAP_HR_NOTHR(VariantChangeTypeEx, 
    (VARIANTARG * pvargDest, VARIANTARG * pvarSrc, LCID lcid, USHORT wFlags, VARTYPE vt),
    (pvargDest, pvarSrc, lcid, wFlags, vt))

WRAP_HR(CreateTypeLib2,
    (SYSKIND syskind, LPCOLESTR szFile, ICreateTypeLib2 **ppctlib),
    (syskind, szFile, ppctlib))

WRAP(SAFEARRAY *, SafeArrayCreate,
        (VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound),
        (vt, cDims, rgsabound))

WRAP_HR(SafeArrayPutElement,
        (SAFEARRAY * psa, LONG * rgIndices, void * pv),
        (psa, rgIndices, pv))

WRAP_HR(UnRegisterTypeLib,
    (REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind),
    (libID, wVerMajor, wVerMinor, lcid, syskind))

WRAP_HR(SafeArrayDestroyData,
    (SAFEARRAY * psa),
    (psa))

WRAP_HR(SafeArrayGetLBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plLbound),
    (psa, nDim, plLbound))

WRAP_HR(SafeArrayCopy,
    (SAFEARRAY * psa, SAFEARRAY ** ppsaOut),
    (psa, ppsaOut))

WRAP(INT, SysReAllocString, (BSTR *a, const OLECHAR *b), (a, b))
WRAP(INT, SysReAllocStringLen, (BSTR *a, const OLECHAR *b, UINT c), (a, b, c))

WRAP_HR(VarUI1FromI2, (SHORT sIn, BYTE * pbOut), (sIn, pbOut))
WRAP_HR(VarUI1FromI4, (LONG lIn, BYTE * pbOut), (lIn, pbOut))
WRAP_HR(VarUI1FromR4, (FLOAT fltIn, BYTE * pbOut), (fltIn, pbOut))
WRAP_HR(VarUI1FromR8, (DOUBLE dblIn, BYTE * pbOut), (dblIn, pbOut))
WRAP_HR(VarUI1FromCy, (CY cyIn, BYTE * pbOut), (cyIn, pbOut))
WRAP_HR(VarUI1FromDate, (DATE dateIn, BYTE * pbOut), (dateIn, pbOut))
WRAP_HR(VarUI1FromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, BYTE * pbOut), (strIn, lcid, dwFlags, pbOut))
WRAP_HR(VarUI1FromDisp, (IDispatch * pdispIn, LCID lcid, BYTE * pbOut), (pdispIn, lcid, pbOut))
WRAP_HR(VarUI1FromBool, (VARIANT_BOOL boolIn, BYTE * pbOut), (boolIn, pbOut))
WRAP_HR(VarUI1FromI1, (CHAR cIn, BYTE *pbOut), (cIn, pbOut))
WRAP_HR(VarUI1FromUI2, (USHORT uiIn, BYTE *pbOut), (uiIn, pbOut))
WRAP_HR(VarUI1FromUI4, (ULONG ulIn, BYTE *pbOut), (ulIn, pbOut))
WRAP_HR(VarUI1FromDec, (DECIMAL *pdecIn, BYTE *pbOut), (pdecIn, pbOut))
WRAP_HR(VarI2FromUI1, (BYTE bIn, SHORT * psOut), (bIn, psOut))
WRAP_HR(VarI2FromI4, (LONG lIn, SHORT * psOut), (lIn, psOut))
WRAP_HR(VarI2FromR4, (FLOAT fltIn, SHORT * psOut), (fltIn, psOut))
WRAP_HR(VarI2FromR8, (DOUBLE dblIn, SHORT * psOut), (dblIn, psOut))
WRAP_HR(VarI2FromCy, (CY cyIn, SHORT * psOut), (cyIn, psOut))
WRAP_HR(VarI2FromDate, (DATE dateIn, SHORT * psOut), (dateIn, psOut))
WRAP_HR(VarI2FromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, SHORT * psOut), (strIn, lcid, dwFlags, psOut))
WRAP_HR(VarI2FromDisp, (IDispatch * pdispIn, LCID lcid, SHORT * psOut), (pdispIn, lcid, psOut))
WRAP_HR(VarI2FromBool, (VARIANT_BOOL boolIn, SHORT * psOut), (boolIn, psOut))
WRAP_HR(VarI2FromI1, (CHAR cIn, SHORT *psOut), (cIn, psOut))
WRAP_HR(VarI2FromUI2, (USHORT uiIn, SHORT *psOut), (uiIn, psOut))
WRAP_HR(VarI2FromUI4, (ULONG ulIn, SHORT *psOut), (ulIn, psOut))
WRAP_HR(VarI2FromDec, (DECIMAL *pdecIn, SHORT *psOut), (pdecIn, psOut))
WRAP_HR(VarI4FromUI1, (BYTE bIn, LONG * plOut), (bIn, plOut))
WRAP_HR(VarI4FromI2, (SHORT sIn, LONG * plOut), (sIn, plOut))
WRAP_HR(VarI4FromR4, (FLOAT fltIn, LONG * plOut), (fltIn, plOut))
WRAP_HR(VarI4FromR8, (DOUBLE dblIn, LONG * plOut), (dblIn, plOut))
WRAP_HR(VarI4FromCy, (CY cyIn, LONG * plOut), (cyIn, plOut))
WRAP_HR(VarI4FromDate, (DATE dateIn, LONG * plOut), (dateIn, plOut))
WRAP_HR(VarI4FromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, LONG * plOut), (strIn, lcid, dwFlags, plOut))
WRAP_HR(VarI4FromDisp, (IDispatch * pdispIn, LCID lcid, LONG * plOut), (pdispIn, lcid, plOut))
WRAP_HR(VarI4FromBool, (VARIANT_BOOL boolIn, LONG * plOut), (boolIn, plOut))
WRAP_HR(VarI4FromI1, (CHAR cIn, LONG *plOut), (cIn, plOut))
WRAP_HR(VarI4FromUI2, (USHORT uiIn, LONG *plOut), (uiIn, plOut))
WRAP_HR(VarI4FromUI4, (ULONG ulIn, LONG *plOut), (ulIn, plOut))
WRAP_HR(VarI4FromDec, (DECIMAL *pdecIn, LONG *plOut), (pdecIn, plOut))
//WRAP_HR(VarI4FromInt, (INT intIn, LONG *plOut), (intIn, plOut))
WRAP_HR(VarR4FromUI1, (BYTE bIn, FLOAT * pfltOut), (bIn, pfltOut))
WRAP_HR(VarR4FromI2, (SHORT sIn, FLOAT * pfltOut), (sIn, pfltOut))
WRAP_HR(VarR4FromI4, (LONG lIn, FLOAT * pfltOut), (lIn, pfltOut))
WRAP_HR(VarR4FromR8, (DOUBLE dblIn, FLOAT * pfltOut), (dblIn, pfltOut))
WRAP_HR(VarR4FromCy, (CY cyIn, FLOAT * pfltOut), (cyIn, pfltOut))
WRAP_HR(VarR4FromDate, (DATE dateIn, FLOAT * pfltOut), (dateIn, pfltOut))
WRAP_HR(VarR4FromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, FLOAT *pfltOut), (strIn, lcid, dwFlags, pfltOut))
WRAP_HR(VarR4FromDisp, (IDispatch * pdispIn, LCID lcid, FLOAT * pfltOut), (pdispIn, lcid, pfltOut))
WRAP_HR(VarR4FromBool, (VARIANT_BOOL boolIn, FLOAT * pfltOut), (boolIn, pfltOut))
WRAP_HR(VarR4FromI1, (CHAR cIn, FLOAT *pfltOut), (cIn, pfltOut))
WRAP_HR(VarR4FromUI2, (USHORT uiIn, FLOAT *pfltOut), (uiIn, pfltOut))
WRAP_HR(VarR4FromUI4, (ULONG ulIn, FLOAT *pfltOut), (ulIn, pfltOut))
WRAP_HR(VarR4FromDec, (DECIMAL *pdecIn, FLOAT *pfltOut), (pdecIn, pfltOut))
WRAP_HR(VarR8FromUI1, (BYTE bIn, DOUBLE * pdblOut), (bIn, pdblOut))
WRAP_HR(VarR8FromI2, (SHORT sIn, DOUBLE * pdblOut), (sIn, pdblOut))
WRAP_HR(VarR8FromI4, (LONG lIn, DOUBLE * pdblOut), (lIn, pdblOut))
WRAP_HR(VarR8FromR4, (FLOAT fltIn, DOUBLE * pdblOut), (fltIn, pdblOut))
WRAP_HR(VarR8FromCy, (CY cyIn, DOUBLE * pdblOut), (cyIn, pdblOut))
WRAP_HR(VarR8FromDate, (DATE dateIn, DOUBLE * pdblOut), (dateIn, pdblOut))
WRAP_HR(VarR8FromStr, (OLECHAR *strIn, LCID lcid, ULONG dwFlags, DOUBLE *pdblOut), (strIn, lcid, dwFlags, pdblOut))
WRAP_HR(VarR8FromDisp, (IDispatch * pdispIn, LCID lcid, DOUBLE * pdblOut), (pdispIn, lcid, pdblOut))
WRAP_HR(VarR8FromBool, (VARIANT_BOOL boolIn, DOUBLE * pdblOut), (boolIn, pdblOut))
WRAP_HR(VarR8FromI1, (CHAR cIn, DOUBLE *pdblOut), (cIn, pdblOut))
WRAP_HR(VarR8FromUI2, (USHORT uiIn, DOUBLE *pdblOut), (uiIn, pdblOut))
WRAP_HR(VarR8FromUI4, (ULONG ulIn, DOUBLE *pdblOut), (ulIn, pdblOut))
WRAP_HR(VarR8FromDec, (DECIMAL *pdecIn, DOUBLE *pdblOut), (pdecIn, pdblOut))
WRAP_HR(VarDateFromUI1, (BYTE bIn, DATE * pdateOut), (bIn, pdateOut))
WRAP_HR(VarDateFromI2, (SHORT sIn, DATE * pdateOut), (sIn, pdateOut))
WRAP_HR(VarDateFromI4, (LONG lIn, DATE * pdateOut), (lIn, pdateOut))
WRAP_HR(VarDateFromR4, (FLOAT fltIn, DATE * pdateOut), (fltIn, pdateOut))
WRAP_HR(VarDateFromR8, (DOUBLE dblIn, DATE * pdateOut), (dblIn, pdateOut))
WRAP_HR(VarDateFromCy, (CY cyIn, DATE * pdateOut), (cyIn, pdateOut))
WRAP_HR(VarDateFromStr, (OLECHAR *strIn, LCID lcid, ULONG dwFlags, DATE *pdateOut), (strIn, lcid, dwFlags, pdateOut))
WRAP_HR(VarDateFromDisp, (IDispatch * pdispIn, LCID lcid, DATE * pdateOut), (pdispIn, lcid, pdateOut))
WRAP_HR(VarDateFromBool, (VARIANT_BOOL boolIn, DATE * pdateOut), (boolIn, pdateOut))
WRAP_HR(VarDateFromI1, (CHAR cIn, DATE *pdateOut), (cIn, pdateOut))
WRAP_HR(VarDateFromUI2, (USHORT uiIn, DATE *pdateOut), (uiIn, pdateOut))
WRAP_HR(VarDateFromUI4, (ULONG ulIn, DATE *pdateOut), (ulIn, pdateOut))
WRAP_HR(VarDateFromDec, (DECIMAL *pdecIn, DATE *pdateOut), (pdecIn, pdateOut))
WRAP_HR(VarCyFromUI1, (BYTE bIn, CY * pcyOut), (bIn, pcyOut))
WRAP_HR(VarCyFromI2, (SHORT sIn, CY * pcyOut), (sIn, pcyOut))
WRAP_HR(VarCyFromI4, (LONG lIn, CY * pcyOut), (lIn, pcyOut))
WRAP_HR(VarCyFromR4, (FLOAT fltIn, CY * pcyOut), (fltIn, pcyOut))
WRAP_HR(VarCyFromR8, (DOUBLE dblIn, CY * pcyOut), (dblIn, pcyOut))
WRAP_HR(VarCyFromDate, (DATE dateIn, CY * pcyOut), (dateIn, pcyOut))
WRAP_HR(VarCyFromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, CY * pcyOut), (strIn, lcid, dwFlags, pcyOut))
WRAP_HR(VarCyFromDisp, (IDispatch * pdispIn, LCID lcid, CY * pcyOut), (pdispIn, lcid, pcyOut))
WRAP_HR(VarCyFromBool, (VARIANT_BOOL boolIn, CY * pcyOut), (boolIn, pcyOut))
WRAP_HR(VarCyFromI1, (CHAR cIn, CY *pcyOut), (cIn, pcyOut))
WRAP_HR(VarCyFromUI2, (USHORT uiIn, CY *pcyOut), (uiIn, pcyOut))
WRAP_HR(VarCyFromUI4, (ULONG ulIn, CY *pcyOut), (ulIn, pcyOut))
WRAP_HR(VarCyFromDec, (DECIMAL *pdecIn, CY *pcyOut), (pdecIn, pcyOut))
WRAP_HR(VarBstrFromUI1, (BYTE bVal, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (bVal, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromI2, (SHORT iVal, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (iVal, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromI4, (LONG lIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (lIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromR4, (FLOAT fltIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (fltIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromR8, (DOUBLE dblIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (dblIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromCy, (CY cyIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (cyIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromDate, (DATE dateIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (dateIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromDisp, (IDispatch * pdispIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (pdispIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromBool, (VARIANT_BOOL boolIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (boolIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromI1, (CHAR cIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut), (cIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromUI2, (USHORT uiIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut), (uiIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromUI4, (ULONG ulIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut), (ulIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromDec, (DECIMAL *pdecIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut), (pdecIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBoolFromUI1, (BYTE bIn, VARIANT_BOOL * pboolOut), (bIn, pboolOut))
WRAP_HR(VarBoolFromI2, (SHORT sIn, VARIANT_BOOL * pboolOut), (sIn, pboolOut))
WRAP_HR(VarBoolFromI4, (LONG lIn, VARIANT_BOOL * pboolOut), (lIn, pboolOut))
WRAP_HR(VarBoolFromR4, (FLOAT fltIn, VARIANT_BOOL * pboolOut), (fltIn, pboolOut))
WRAP_HR(VarBoolFromR8, (DOUBLE dblIn, VARIANT_BOOL * pboolOut), (dblIn, pboolOut))
WRAP_HR(VarBoolFromDate, (DATE dateIn, VARIANT_BOOL * pboolOut), (dateIn, pboolOut))
WRAP_HR(VarBoolFromCy, (CY cyIn, VARIANT_BOOL * pboolOut), (cyIn, pboolOut))
WRAP_HR(VarBoolFromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, VARIANT_BOOL * pboolOut), (strIn, lcid, dwFlags, pboolOut))
WRAP_HR(VarBoolFromDisp, (IDispatch * pdispIn, LCID lcid, VARIANT_BOOL * pboolOut), (pdispIn, lcid, pboolOut))
WRAP_HR(VarBoolFromI1, (CHAR cIn, VARIANT_BOOL *pboolOut), (cIn, pboolOut))
WRAP_HR(VarBoolFromUI2, (USHORT uiIn, VARIANT_BOOL *pboolOut), (uiIn, pboolOut))
WRAP_HR(VarBoolFromUI4, (ULONG ulIn, VARIANT_BOOL *pboolOut), (ulIn, pboolOut))
WRAP_HR(VarBoolFromDec, (DECIMAL *pdecIn, VARIANT_BOOL *pboolOut), (pdecIn, pboolOut))
WRAP_HR(VarI1FromUI1, (BYTE bIn, CHAR *pcOut), (bIn, pcOut))
WRAP_HR(VarI1FromI2, (SHORT uiIn, CHAR *pcOut), (uiIn, pcOut))
WRAP_HR(VarI1FromI4, (LONG lIn, CHAR *pcOut), (lIn, pcOut))
WRAP_HR(VarI1FromR4, (FLOAT fltIn, CHAR *pcOut), (fltIn, pcOut))
WRAP_HR(VarI1FromR8, (DOUBLE dblIn, CHAR *pcOut), (dblIn, pcOut))
WRAP_HR(VarI1FromDate, (DATE dateIn, CHAR *pcOut), (dateIn, pcOut))
WRAP_HR(VarI1FromCy, (CY cyIn, CHAR *pcOut), (cyIn, pcOut))
WRAP_HR(VarI1FromStr, (OLECHAR *strIn, LCID lcid, ULONG dwFlags, CHAR *pcOut), (strIn, lcid, dwFlags, pcOut))
WRAP_HR(VarI1FromDisp, (IDispatch *pdispIn, LCID lcid, CHAR *pcOut), (pdispIn, lcid, pcOut))
WRAP_HR(VarI1FromBool, (VARIANT_BOOL boolIn, CHAR *pcOut), (boolIn, pcOut))
WRAP_HR(VarI1FromUI2, (USHORT uiIn, CHAR *pcOut), (uiIn, pcOut))
WRAP_HR(VarI1FromUI4, (ULONG ulIn, CHAR *pcOut), (ulIn, pcOut))
WRAP_HR(VarI1FromDec, (DECIMAL *pdecIn, CHAR *pcOut), (pdecIn, pcOut))
WRAP_HR(VarUI2FromUI1, (BYTE bIn, USHORT *puiOut), (bIn, puiOut))
WRAP_HR(VarUI2FromI2, (SHORT uiIn, USHORT *puiOut), (uiIn, puiOut))
WRAP_HR(VarUI2FromI4, (LONG lIn, USHORT *puiOut), (lIn, puiOut))
WRAP_HR(VarUI2FromR4, (FLOAT fltIn, USHORT *puiOut), (fltIn, puiOut))
WRAP_HR(VarUI2FromR8, (DOUBLE dblIn, USHORT *puiOut), (dblIn, puiOut))
WRAP_HR(VarUI2FromDate, (DATE dateIn, USHORT *puiOut), (dateIn, puiOut))
WRAP_HR(VarUI2FromCy, (CY cyIn, USHORT *puiOut), (cyIn, puiOut))
WRAP_HR(VarUI2FromStr, (OLECHAR *strIn, LCID lcid, ULONG dwFlags, USHORT *puiOut), (strIn, lcid, dwFlags, puiOut))
WRAP_HR(VarUI2FromDisp, (IDispatch *pdispIn, LCID lcid, USHORT *puiOut), (pdispIn, lcid, puiOut))
WRAP_HR(VarUI2FromBool, (VARIANT_BOOL boolIn, USHORT *puiOut), (boolIn, puiOut))
WRAP_HR(VarUI2FromI1, (CHAR cIn, USHORT *puiOut), (cIn, puiOut))
WRAP_HR(VarUI2FromUI4, (ULONG ulIn, USHORT *puiOut), (ulIn, puiOut))
WRAP_HR(VarUI2FromDec, (DECIMAL *pdecIn, USHORT *puiOut), (pdecIn, puiOut))
WRAP_HR(VarUI4FromUI1, (BYTE bIn, ULONG *pulOut), (bIn, pulOut))
WRAP_HR(VarUI4FromI2, (SHORT uiIn, ULONG *pulOut), (uiIn, pulOut))
WRAP_HR(VarUI4FromI4, (LONG lIn, ULONG *pulOut), (lIn, pulOut))
WRAP_HR(VarUI4FromR4, (FLOAT fltIn, ULONG *pulOut), (fltIn, pulOut))
WRAP_HR(VarUI4FromR8, (DOUBLE dblIn, ULONG *pulOut), (dblIn, pulOut))
WRAP_HR(VarUI4FromDate, (DATE dateIn, ULONG *pulOut), (dateIn, pulOut))
WRAP_HR(VarUI4FromCy, (CY cyIn, ULONG *pulOut), (cyIn, pulOut))
WRAP_HR(VarUI4FromStr, (OLECHAR *strIn, LCID lcid, ULONG dwFlags, ULONG *pulOut), (strIn, lcid, dwFlags, pulOut))
WRAP_HR(VarUI4FromDisp, (IDispatch *pdispIn, LCID lcid, ULONG *pulOut), (pdispIn, lcid, pulOut))
WRAP_HR(VarUI4FromBool, (VARIANT_BOOL boolIn, ULONG *pulOut), (boolIn, pulOut))
WRAP_HR(VarUI4FromI1, (CHAR cIn, ULONG *pulOut), (cIn, pulOut))
WRAP_HR(VarUI4FromUI2, (USHORT uiIn, ULONG *pulOut), (uiIn, pulOut))
WRAP_HR(VarUI4FromDec, (DECIMAL *pdecIn, ULONG *pulOut), (pdecIn, pulOut))
WRAP_HR(VarFormatCurrency, 
    (LPVARIANT pvarIn, int iNumDig, int iIncLead, int iUseParens, int iGroup, ULONG dwFlags, BSTR *pbstrOut),
    (pvarIn, iNumDig, iIncLead, iUseParens, iGroup, dwFlags, pbstrOut))

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\shell32.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       Shell32.cxx
//
//  Contents:   Dynamic wrappers for shell procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#define _SHELL32_
#define _SHDOCVW_
#include <shellapi.h>
#endif

#ifndef X_SHFOLDER_HXX_
#define X_SHFOLDER_HXX_
#define _SHFOLDER_
#include "shfolder.h"
#endif

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

#ifndef DLOAD1
int UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch = -1);

DYNLIB g_dynlibSHELL32 = { NULL, NULL, "SHELL32.DLL" };
DYNLIB g_dynlibSHFOLDER = { NULL, NULL, "SHFOLDER.DLL" };
#endif // DLOAD1

extern DYNLIB g_dynlibSHDOCVW;

#ifndef DLOAD1
HINSTANCE APIENTRY
ShellExecuteA(HWND hwnd,	LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameter, LPCSTR lpDirectory, INT nShowCmd)
{
    static DYNPROC s_dynprocShellExecuteA =
            { NULL, &g_dynlibSHELL32, "ShellExecuteA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocShellExecuteA);
    if (hr) 
        return (HINSTANCE)NULL;

    return (*(HINSTANCE (APIENTRY *)(HWND, LPCSTR, LPCSTR, LPCSTR, LPCSTR, INT))s_dynprocShellExecuteA.pfn)
            (hwnd, lpOperation, lpFile, lpParameter, lpDirectory, nShowCmd);
}

HINSTANCE APIENTRY
ShellExecuteW(HWND hwnd,	LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameter, LPCWSTR lpDirectory, INT nShowCmd)
{
    CStrIn strInOperation(lpOperation);
    CStrIn strInFile(lpFile);
    CStrIn strInParameter(lpParameter);
    CStrIn strInDirectory(lpDirectory);

    return ShellExecuteA(hwnd, strInOperation, strInFile, strInParameter, strInDirectory, nShowCmd);
}


DWORD_PTR WINAPI 
SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA FAR *psfi, UINT cbFileInfo, UINT uFlags)
{
    static DYNPROC s_dynprocSHGetFileInfoA =
            { NULL, &g_dynlibSHELL32, "SHGetFileInfoA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocSHGetFileInfoA);
    if (hr) 
        return 0;

    return (*(DWORD_PTR (APIENTRY *)(LPCSTR, DWORD, SHFILEINFOA *, UINT, UINT))s_dynprocSHGetFileInfoA.pfn)
            (pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
}

DWORD_PTR WINAPI 
SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW FAR *psfi, UINT cbFileInfo, UINT uFlags)
{
    Assert(cbFileInfo == sizeof(SHFILEINFOW));
    Assert(psfi);

    if (!g_fUnicodePlatform)
    {
        CStrIn      strPath(pszPath);
        SHFILEINFOA sfi;
        DWORD_PTR   dw;

        memset(&sfi, 0, sizeof(sfi));
        dw = SHGetFileInfoA(strPath, dwFileAttributes, &sfi, sizeof(sfi), uFlags);

        psfi->hIcon = sfi.hIcon;
        psfi->iIcon = sfi.iIcon;
        psfi->dwAttributes = sfi.dwAttributes;
        UnicodeFromMbcs(psfi->szDisplayName, ARRAY_SIZE(psfi->szDisplayName), sfi.szDisplayName);
        UnicodeFromMbcs(psfi->szTypeName, ARRAY_SIZE(psfi->szTypeName), sfi.szTypeName);

        return dw;
    }
    else
    {
        static DYNPROC s_dynprocSHGetFileInfoW =
                { NULL, &g_dynlibSHELL32, "SHGetFileInfoW" };

        HRESULT hr;

        hr = LoadProcedure(&s_dynprocSHGetFileInfoW);
        if (hr) 
            return 0;

        return (*(DWORD_PTR (APIENTRY *)(LPCWSTR, DWORD, SHFILEINFOW *, UINT, UINT))s_dynprocSHGetFileInfoW.pfn)
                (pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
    }
}

#if !defined(_M_IX86) || defined(WINCE)

UINT WINAPI ExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON FAR *phiconLarge, 
	HICON FAR *phiconSmall, UINT nIcons)
{
    static DYNPROC s_dynprocExtractIconExW =
            { NULL, &g_dynlibSHELL32, "ExtractIconExW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocExtractIconExW);
    if (hr) 
        return 0;

    return (*(UINT (APIENTRY *)(LPCWSTR, int, HICON FAR *, HICON FAR *, UINT))s_dynprocExtractIconExW.pfn)
            (lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons);
}

HICON WINAPI ExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex)
{
    static DYNPROC s_dynprocExtractIconW =
            { NULL, &g_dynlibSHELL32, "ExtractIconW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocExtractIconW);
    if (hr) 
        return 0;

    return (*(HICON (APIENTRY *)(HINSTANCE, LPCWSTR, UINT))s_dynprocExtractIconW.pfn)
            (hInst, lpszExeFileName, nIconIndex);  
}

#endif

#endif // DLOAD1

//+---------------------------------------------------------------------------
//
//  Function:   DoFileDownLoad
//
//  Synopsis:   calls the DoFileDownload proc in SHDOCVW.DLL
//
//  Arguments:  [pchHref]   ref to file to download
//
//
//----------------------------------------------------------------------------
HRESULT
DoFileDownLoad(const TCHAR * pchHref)
{
    static DYNPROC s_dynprocFileDownload =
            { NULL, &g_dynlibSHDOCVW, "DoFileDownload" };
    HRESULT hr = LoadProcedure(&s_dynprocFileDownload);

    Assert(pchHref);

    if (!hr)
    {
        hr = (*(HRESULT (APIENTRY*)(LPCWSTR))s_dynprocFileDownload.pfn)(pchHref); 
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

#ifdef NO_MARSHALLING

SHDOCAPI APIENTRY CoCreateInternetExplorer( REFIID iid, DWORD dwClsContext, void **ppvunk );

HRESULT APIENTRY
CoCreateInternetExplorer( REFIID iid, DWORD dwClsContext, void **ppvunk )
{
    static DYNPROC s_dynprocCoCreateInternetExplorer =
            { NULL, &g_dynlibSHDOCVW, "CoCreateInternetExplorer" };
    HRESULT hr = LoadProcedure(&s_dynprocCoCreateInternetExplorer);

    if (!hr)
    {
            hr = (*(HRESULT (APIENTRY*)(REFIID, DWORD, void**))s_dynprocCoCreateInternetExplorer.pfn)(iid, dwClsContext, ppvunk); 
    }
    else
    {
            hr = E_FAIL;
    }

    return hr;
}

#endif

#ifndef DLOAD1

HICON APIENTRY
ExtractAssociatedIconA(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon)
{
    static DYNPROC s_dynprocExtractAssociatedIconA =
            { NULL, &g_dynlibSHELL32, "ExtractAssociatedIconA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocExtractAssociatedIconA);
    if (hr) 
        return (HICON) NULL;

    return (*(HICON (APIENTRY *)(HINSTANCE, LPSTR, LPWORD))s_dynprocExtractAssociatedIconA.pfn)
            (hInst, lpIconPath, lpiIcon);
}

HICON APIENTRY
ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon)
{
    CStrIn strIconPath(lpIconPath);

    return ExtractAssociatedIconA(hInst, strIconPath, lpiIcon);
}

extern BOOL g_fUseShell32InsteadOfSHFolder;

STDAPI
SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, TCHAR * pchPath)
{
    static DYNPROC s_dynprocSHFOLDERSHGetFolderPath =
            { NULL, &g_dynlibSHFOLDER, "SHGetFolderPathW" };
    static DYNPROC s_dynprocSHELL32SHGetFolderPath =
            { NULL, &g_dynlibSHELL32, "SHGetFolderPathW" };
    void *pfnSHGetFolderPath = NULL;

    HRESULT hr = E_FAIL;

    if (g_fUseShell32InsteadOfSHFolder)
    {
        hr = LoadProcedure(&s_dynprocSHELL32SHGetFolderPath);
        pfnSHGetFolderPath = s_dynprocSHELL32SHGetFolderPath.pfn;

        AssertSz(SUCCEEDED(hr), "Coudn't find ShGetFolderPathW in SHELL32.DLL");
    }
    
    // If we aren't on NT5+ or WinME+ then try shfolder32
    if (hr)
    {
        hr = LoadProcedure(&s_dynprocSHFOLDERSHGetFolderPath);
        pfnSHGetFolderPath = s_dynprocSHFOLDERSHGetFolderPath.pfn;

        if (hr) 
            return hr;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HWND, int, HANDLE, DWORD, LPWSTR))pfnSHGetFolderPath)
            (hwnd, csidl, hToken, dwFlags, pchPath);
}

STDAPI
SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pchPath)
{
    static DYNPROC s_dynprocSHFOLDERSHGetFolderPath =
            { NULL, &g_dynlibSHFOLDER, "SHGetFolderPathA" };
    static DYNPROC s_dynprocSHELL32SHGetFolderPath =
            { NULL, &g_dynlibSHELL32, "SHGetFolderPathA" };
    void *pfnSHGetFolderPath = NULL;

    HRESULT hr = E_FAIL;

    if (g_fUseShell32InsteadOfSHFolder)
    {
        hr = LoadProcedure(&s_dynprocSHELL32SHGetFolderPath);
        pfnSHGetFolderPath = s_dynprocSHELL32SHGetFolderPath.pfn;

        AssertSz(SUCCEEDED(hr), "Coudn't find ShGetFolderPathA in SHELL32.DLL");
    }

    if (hr)
    {
        hr = LoadProcedure(&s_dynprocSHFOLDERSHGetFolderPath);
        pfnSHGetFolderPath = s_dynprocSHFOLDERSHGetFolderPath.pfn;

        if (hr) 
            return hr;
    }


    return (*(HRESULT (STDAPICALLTYPE *)(HWND, int, HANDLE, DWORD, LPSTR))pfnSHGetFolderPath)
            (hwnd, csidl, hToken, dwFlags, pchPath);
}

#endif // DLOAD1

HRESULT
IEParseDisplayNameWithBCW(UINT uiCP, LPCWSTR pwszPath, IBindCtx * pbc, LPITEMIDLIST * ppidlOut)
{
    static DYNPROC s_dynprocIEParseDisplayNameWithBCW =
            { NULL, &g_dynlibSHDOCVW, (LPSTR) 218 };

    HRESULT hr = LoadProcedure(&s_dynprocIEParseDisplayNameWithBCW);

    if (S_OK == hr)
    {
        hr = (*(HRESULT (APIENTRY*)(UINT uiCP, LPCWSTR pwszPath, IBindCtx * pbc, LPITEMIDLIST * ppidlOut))
                s_dynprocIEParseDisplayNameWithBCW.pfn)(uiCP, pwszPath, pbc, ppidlOut);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

#ifndef DLOAD1

BOOL
IsIEDefaultBrowser()
{
    BOOL bResult;

    static DYNPROC s_dynprocIsIEDefaultBrowser =
            { NULL, &g_dynlibSHDOCVW, (LPSTR) 167 };

    HRESULT hr = LoadProcedure(&s_dynprocIsIEDefaultBrowser);

    if (S_OK == hr)
    {
        bResult = (*(BOOL (APIENTRY*)())
                s_dynprocIsIEDefaultBrowser.pfn)();
    }
    else
    {
        bResult = FALSE;
    }

    return bResult;
}

// Note: the shell32 function is actually called SHSimpleIDListFromPath.
// I had to rename it due to a naming conflict. (scotrobe 01/24/2000)
//
LPITEMIDLIST
SHSimpleIDListFromPathPriv(LPCTSTR pszPath)
{
    static DYNPROC s_dynprocSHSimpleIDListFromPathPriv =
            { NULL, &g_dynlibSHELL32, (LPSTR) 162 };

    if (S_OK == LoadProcedure(&s_dynprocSHSimpleIDListFromPathPriv))
    {
        return (*(LPITEMIDLIST (APIENTRY*)(LPCTSTR pszPath))s_dynprocSHSimpleIDListFromPathPriv.pfn)(pszPath);
    }

    return NULL;
}

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\urlmon.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       urlmon.cxx
//
//  Contents:   Dynamic wrappers for URL monikers.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef DLOAD1

DYNLIB g_dynlibURLMON = { NULL, NULL, "URLMON.DLL" };
DYNLIB g_dynlibMPR = { NULL, NULL, "MPR.DLL" };


#define WRAPIT(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibURLMON, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR_NOTRACE((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN2(hr, S_FALSE, MK_S_ASYNCHRONOUS);\
}

WRAPIT(CreateURLMoniker,
    (IMoniker * pMkCtx, LPCWSTR szURL, IMoniker **ppmk),
    (pMkCtx, szURL, ppmk))

WRAPIT(CreateURLMonikerEx,
    (IMoniker * pMkCtx, LPCWSTR szURL, IMoniker **ppmk, DWORD dwFlags),
    (pMkCtx, szURL, ppmk, dwFlags))

WRAPIT(CreateAsyncBindCtx,
    (DWORD reserved, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEFetc, IBindCtx **ppBC),
    (reserved, pBSCb, pEFetc, ppBC))

WRAPIT(CreateAsyncBindCtxEx,
    (IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb,
        IEnumFORMATETC *pEnum, IBindCtx **ppBC, DWORD reserved),
    (pbc, dwOptions, pBSCb, pEnum, ppBC, reserved));

WRAPIT(MkParseDisplayNameEx,
    (IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten, LPMONIKER *ppmk),
    (pbc, szDisplayName, pchEaten, ppmk))

WRAPIT(RegisterBindStatusCallback,
    (LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback ** ppBSCBPrev, DWORD dwReserved),
    (pBC, pBSCb, ppBSCBPrev, dwReserved))

WRAPIT(RevokeBindStatusCallback,
        (LPBC pBC, IBindStatusCallback *pBSCb),
        (pBC, pBSCb))

WRAPIT(RegisterAsyncBindCtx,
    (LPBC pBC, IBindStatusCallback *pBSCb, DWORD reserved),
    (pBC, pBSCb, reserved))

WRAPIT(HlinkSimpleNavigateToMoniker,
    (IMoniker *pmkTarget, LPCWSTR szLocation, LPCWSTR szAddParams, IUnknown *pUnk, IBindCtx *pbc, IBindStatusCallback *pbsc, DWORD grfHLNF, DWORD dwReserved),
    (pmkTarget, szLocation, szAddParams, pUnk, pbc, pbsc, grfHLNF, dwReserved))

WRAPIT(CoGetClassObjectFromURL,
    (REFCLSID rclsid, LPCWSTR szCode, DWORD dwFileVersionMS, DWORD dwFileVersionLS, LPCWSTR szTYPE, IBindCtx *pBindCtx, DWORD dwClsContext, void *pvReserved, REFIID riid, LPVOID * ppv),
    (rclsid, szCode, dwFileVersionMS, dwFileVersionLS, szTYPE, pBindCtx, dwClsContext, pvReserved, riid, ppv))

WRAPIT(GetClassFileOrMime,
    (LPBC pBC, LPCWSTR pwzFilename, LPVOID pBuffer, DWORD cbSize, LPCWSTR pwzMimeIn, DWORD dwReserved, CLSID *pclsid),
    (pBC, pwzFilename, pBuffer, cbSize, pwzMimeIn, dwReserved, pclsid))

WRAPIT(RegisterMediaTypes,
    (UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes),
    (ctypes, rgszTypes, rgcfTypes));

WRAPIT(IsAsyncMoniker,
    (IMoniker * pmk),
    (pmk));

WRAPIT(FindMimeFromData,
    (LPBC pBC, LPCWSTR pwzUrl, LPVOID pBuffer, DWORD cbSize, LPCWSTR pwzMimeProposed, DWORD dwMimeFlags, LPWSTR *ppwzMimeOut, DWORD dwReserved),
    (pBC, pwzUrl, pBuffer, cbSize, pwzMimeProposed, dwMimeFlags, ppwzMimeOut, dwReserved));

WRAPIT(CoInternetParseUrl,
    (LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved),
    (pwzUrl, ParseAction, dwFlags, pszResult, cchResult, pcchResult, dwReserved));

WRAPIT(CoInternetCombineUrl,
    (LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved),
    (pwzBaseUrl, pwzRelativeUrl, dwFlags, pszResult, cchResult, pcchResult, dwReserved));

WRAPIT(CoInternetCreateSecurityManager,
    (IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved),
    (pSP, ppSM, dwReserved));

WRAPIT(CoInternetGetSession,
    (DWORD dwMode, IInternetSession **ppInternetSession, DWORD dwReserved),
    (dwMode, ppInternetSession, dwReserved));

WRAPIT(CoInternetCompareUrl,
    (LPCWSTR pwzUrl1, LPCWSTR pwzUrl2, DWORD dwFlags),
    (pwzUrl1, pwzUrl2, dwFlags));

WRAPIT(CoInternetQueryInfo,
    (LPCWSTR pwzUrl, QUERYOPTION QueryOption, DWORD dwQueryFlags, LPVOID pvBuffer, DWORD cbBuffer, DWORD *pcbBuffer, DWORD dwReserved),
    (pwzUrl, QueryOption, dwQueryFlags, pvBuffer, cbBuffer, pcbBuffer, dwReserved));

WRAPIT(CoInternetCreateZoneManager,
    (IServiceProvider *pSP, IInternetZoneManager **ppUZM, DWORD dwReserved),
    (pSP, ppUZM, dwReserved));

WRAPIT(FaultInIEFeature,
    (HWND hWnd, uCLSSPEC *pClassSpec, QUERYCONTEXT *pQuery, DWORD dwFlags),
    (hWnd, pClassSpec, pQuery, dwFlags));

WRAPIT(CompareSecurityIds,
    (BYTE * pbSecurityId1, DWORD dwLen1, BYTE * pbSecurityId2, DWORD dwLen2, DWORD dwReserved),
    (pbSecurityId1, dwLen1, pbSecurityId2, dwLen2, dwReserved));

WRAPIT(ObtainUserAgentString,
    (DWORD dwOption, LPSTR pszUAOut, DWORD* cbSize),
    (dwOption, pszUAOut, cbSize));

WRAPIT(URLOpenBlockingStreamW,
    (LPUNKNOWN pCaller, LPCWSTR szUrl, LPSTREAM *ppStream, DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB),
    (pCaller, szUrl, ppStream, dwReserved, lpfnCB));

#endif // DLOAD1

STDAPI ObtainUserAgentStringW(DWORD dwOption, LPWSTR lpszUAOut, DWORD* cbSize)
{
    CStrOut strUAOut(lpszUAOut, MAX_PATH);

    return ObtainUserAgentString(dwOption, strUAOut, cbSize);
}

#ifndef DLOAD1

#define WRAPIT_VOID(fn, a1, a2)\
STDAPI_(void) fn a1\
{\
    HRESULT hr; \
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibURLMON, #fn }; \
    hr = THR(LoadProcedure(&s_dynproc##fn)); \
    if (!hr) \
    { \
        ((*(void (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2); \
    } \
}

WRAPIT_VOID(ReleaseBindInfo,
    (BINDINFO * pbindinfo),
    (pbindinfo));

#endif // DLOAD1

HRESULT FaultInIEFeatureHelper(HWND hWnd,
            uCLSSPEC *pClassSpec,
            QUERYCONTEXT *pQuery, DWORD dwFlags)
{
    HRESULT hr = FaultInIEFeature(hWnd, pClassSpec, pQuery, dwFlags);

    RRETURN1((hr == E_ACCESSDENIED) ? S_OK : hr, S_FALSE);
}

#ifndef DLOAD1

#define MPR_WRAPIT(fn, a1, a2)\
STDAPI_(DWORD) fn a1\
{\
    DWORD dw = ERROR_INVALID_PARAMETER; \
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMPR, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    dw = ((*(DWORD (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    return dw; \
}

MPR_WRAPIT(WNetOpenEnumA,
    (DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum),
    (dwScope, dwType, dwUsage, lpNetResource, lphEnum));

MPR_WRAPIT(WNetOpenEnumW,
    (DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum),
    (dwScope, dwType, dwUsage, lpNetResource, lphEnum));

MPR_WRAPIT(WNetCloseEnum,
    (HANDLE dwEnum),
    (dwEnum));

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\msrating.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       msrating.cxx
//
//  Contents:   Dynamic wrappers for msrating functions
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef UNIX // UNIX doesn't use this file

#ifndef X_MSRATING_HXX_
#define X_MSRATING_HXX_
#include "msrating.hxx"
#endif

DYNLIB g_dynlibMSRATING = { NULL, NULL, "MSRATING.DLL" };

#define WRAPIT(wrapper, fn, a1, a2)\
STDAPI wrapper a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMSRATING, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

WRAPIT(AreRatingsEnabled, RatingEnabledQuery, (), ());

#endif // UNIX doesn't use this file.

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\olepro32.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       olepro32.cxx
//
//  Contents:   Dynamic wrappers for OLE Automation monikers.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef UNIX
DYNLIB g_dynlibOLEPRO32 = { NULL, NULL, "olepro32.dll" };
#else
DYNLIB g_dynlibOLEPRO32 = { NULL, NULL, "oleaut32.dll" };
#endif

#define WRAP_HR(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEPRO32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

#define WRAP(t, fn, a1, a2)\
STDAPI_(t) fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEPRO32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        return 0;\
    return (*(t (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAP_VOID(fn, a1, a2)\
STDAPI_(void) fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEPRO32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        return;\
    (*(void (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2;\
}



WRAP_HR(OleLoadPicture, 
    (LPSTREAM lpstream, LONG lSize, BOOL fRunmode, REFIID riid, LPVOID FAR* lplpvObj),
    (lpstream, lSize, fRunmode, riid, lplpvObj))

WRAP_HR(OleLoadPicturePath, 
    (LPOLESTR  szURLorPath, LPUNKNOWN punkCaller, DWORD dwReserved, OLE_COLOR clrReserved, REFIID riid, LPVOID *  ppvRet),
    (szURLorPath, punkCaller, dwReserved, clrReserved, riid, ppvRet))

WRAP_HR(OleCreateFontIndirect,
    (LPFONTDESC lpFontDesc, REFIID riid, LPVOID FAR* lplpvObj),
    (lpFontDesc, riid, lplpvObj))

WRAP_HR(OleCreatePropertyFrame,
    (HWND hwndOwner, UINT x, UINT y, LPCOLESTR lpszCaption, ULONG cObjects, LPUNKNOWN FAR* ppUnk, ULONG cPages, LPCLSID pPageClsID, LCID lcid, DWORD dwReserved, LPVOID pvReserved),
    (hwndOwner, x, y, lpszCaption, cObjects, ppUnk, cPages, pPageClsID, lcid, dwReserved, pvReserved))

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\usp.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       usp.cxx
//
//  Contents:   Dynamic wrappers for USP.dll (UniScribe) functions.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_USP_HXX_
#define X_USP_HXX_
#include "usp.hxx"
#endif

DYNLIB g_dynlibUSP = { NULL, NULL, "USP10.DLL" };

#define WRAPIT(fn, a1, a2)\
HRESULT WINAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibUSP, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (*) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN(hr);\
}

#define WRAPIT_(type, fn, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibUSP, #fn };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return NULL;\
    return (*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAPIT_ERR1(fn, a1, a2, e1)\
HRESULT WINAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibUSP, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (*) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, e1);\
}


WRAPIT(ScriptFreeCache,
    (SCRIPT_CACHE *psc),
    (psc))

WRAPIT_ERR1(ScriptItemize,
    (PCWSTR pwcInChars, int cInChars, int cMaxItems, const SCRIPT_CONTROL *psControl,
     const SCRIPT_STATE *psState, SCRIPT_ITEM *pItems, PINT pcItems),
    (pwcInChars, cInChars, cMaxItems, psControl, psState, pItems, pcItems),
    E_OUTOFMEMORY)

WRAPIT_ERR1(ScriptShape,
    (HDC hdc, SCRIPT_CACHE *psc, const WCHAR *pwcChars, int cChars, int cMaxGlyphs,
     SCRIPT_ANALYSIS *psa, WORD *pwOutGlyphs, WORD *pwLogClust, SCRIPT_VISATTR *psva, int *pcGlyphs),
    (hdc, psc, pwcChars, cChars, cMaxGlyphs, psa, pwOutGlyphs, pwLogClust, psva, pcGlyphs),
    E_OUTOFMEMORY)

WRAPIT(ScriptPlace,
    (HDC hdc, SCRIPT_CACHE *psc, const WORD *pwGlyphs, int cGlyphs, const SCRIPT_VISATTR *psva,
     SCRIPT_ANALYSIS *psa, int *piAdvance, GOFFSET *pGoffset, ABC *pABC),
    (hdc, psc, pwGlyphs, cGlyphs, psva, psa, piAdvance, pGoffset, pABC))

WRAPIT(ScriptTextOut,
    (const HDC hdc, SCRIPT_CACHE *psc, int x, int y, UINT fuOptions, const RECT  *lprc, 
     const SCRIPT_ANALYSIS *psa, const WCHAR *pwcInChars, int cChars, const WORD *pwGlyphs, 
     int cGlyphs, const int *piAdvance, const int *piJustify, const GOFFSET *pGoffset),
    (hdc, psc, x, y, fuOptions, lprc, 
     psa, pwcInChars, cChars, pwGlyphs, 
     cGlyphs, piAdvance, piJustify, pGoffset))

WRAPIT(ScriptBreak,
    (PCWSTR pwcChars, int cChars,const SCRIPT_ANALYSIS *psa, SCRIPT_LOGATTR *psla),
    (pwcChars, cChars, psa, psla))

WRAPIT(ScriptGetCMap,
    (HDC hdc, SCRIPT_CACHE * psc, PCWSTR pwcInChars, int cChars, DWORD dwFlags, PWORD pwOutGlyphs),
    (hdc, psc, pwcInChars, cChars, dwFlags, pwOutGlyphs))

WRAPIT(ScriptGetProperties,
    (const SCRIPT_PROPERTIES ***ppSp, int *piNumScripts),
    (ppSp, piNumScripts))

WRAPIT(ScriptGetFontProperties,
    (HDC hdc, SCRIPT_CACHE *psc, SCRIPT_FONTPROPERTIES  *sfp),
    (hdc, psc, sfp))

WRAPIT(ScriptStringAnalyse,
    (HDC hdc, const void *pString, int cString, int cGlyphs, int iCharset, DWORD dwFlags,
     int iReqWidth, SCRIPT_CONTROL *psControl, SCRIPT_STATE *psState, const int *piDx, 
     SCRIPT_TABDEF *pTabdef, const BYTE *pbInClass, SCRIPT_STRING_ANALYSIS *pssa),
    (hdc, pString, cString, cGlyphs, iCharset, dwFlags, iReqWidth, psControl, psState,
     piDx, pTabdef, pbInClass, pssa))

WRAPIT(ScriptStringGetLogicalWidths,
    (SCRIPT_STRING_ANALYSIS ssa, int *piDx),
    (ssa, piDx))

WRAPIT(ScriptStringOut,
    (SCRIPT_STRING_ANALYSIS ssa, int iX, int iY, UINT uOptions, const RECT *prc,
     int iMinSel, int iMaxSel, BOOL fDisabled),
    (ssa, iX, iY, uOptions, prc, iMinSel, iMaxSel, fDisabled))

WRAPIT(ScriptStringFree,
    (SCRIPT_STRING_ANALYSIS *pssa),
    (pssa))

WRAPIT_(const SIZE*,
        ScriptString_pSize,
        (SCRIPT_STRING_ANALYSIS ssa),
        (ssa))

WRAPIT_(const int*,
        ScriptString_pcOutChars,
        (SCRIPT_STRING_ANALYSIS ssa),
        (ssa))


WRAPIT_(const SCRIPT_LOGATTR*,
        ScriptString_pLogAttr,
        (SCRIPT_STRING_ANALYSIS ssa),
        (ssa))


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\winmm.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       winmm.cxx
//
//  Contents:   Dynamic wrappers for multi media
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MMSYSTEM_H_
#define X_MMSYSTEM_H_
#define _WINMM_
#include <mmsystem.h>
#endif

DYNLIB g_dynlibWINMM = { NULL, NULL, "WINMM.DLL" };

BOOL WINAPI
PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound)
{
    static DYNPROC s_dynprocPlaySoundA =
            { NULL, &g_dynlibWINMM, "PlaySoundA" };

    if (THR(LoadProcedure(&s_dynprocPlaySoundA)))
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPCSTR, HMODULE, DWORD))s_dynprocPlaySoundA.pfn)
            (pszSound, hmod, fdwSound);

}

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\theme.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995-2000
//
//  File:       theme.cxx
//
//  Contents:   Dynamic wrappers for Theme procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

#ifndef X_UXTHEME_H_
#define X_UXTHEME_H_
#undef  _UXTHEME_
#define _UXTHEME_
#include "uxtheme.h"
#endif

#ifndef X_WINUSER32_H_
#define X_WINUSER32_H_
#undef  _WINUSER32_
#define _WINUSER32_
#include "winuser.h"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

DYNLIB g_dynlibTheme    = { NULL, NULL, "UXTHEME.dll" };
DYNLIB g_dynlibKERNEL32 = { NULL, NULL, "KERNEL32.dll" };

extern DYNLIB g_dynlibUSER32;
extern BOOL   g_fThemedPlatform;
extern DWORD  g_dwPlatformBuild;

THEMEAPI_(HTHEME)
OpenThemeData(HWND hwnd, LPCWSTR pstrClassList)
{
    static DYNPROC s_dynprocOpenThemeData =
            { NULL, &g_dynlibTheme, "OpenThemeData" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocOpenThemeData);
    
    if (hr)
    {
        return NULL;
    }

    return (*(HTHEME (STDAPICALLTYPE *)(HWND, LPCWSTR))
            s_dynprocOpenThemeData.pfn)
            (hwnd, pstrClassList);
}

THEMEAPI_(HTHEME)
OpenThemeDataEx(HWND hwnd, LPCWSTR pstrClassList, DWORD dwFlags)
{
    static DYNPROC s_dynprocOpenThemeDataEx =
            { NULL, &g_dynlibTheme, (LPSTR) 61 };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocOpenThemeDataEx);
    
    if (hr)
    {
        // FOR IE INSTALLED ON DOWNLEVEL WHISTLER
        // OpenThemeDataEx will not be available
        // so we can default to OpenThemeData
        // This can be changed to return NULL
        // before we ship.
        return OpenThemeData(hwnd, pstrClassList);
    }

    return (*(HTHEME (STDAPICALLTYPE *)(HWND, LPCWSTR, DWORD))
            s_dynprocOpenThemeDataEx.pfn)
            (hwnd, pstrClassList, dwFlags);
}

THEMEAPI
SetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, LPCWSTR pszSubIdList)
{
    static DYNPROC s_dynprocSetWindowTheme =
            { NULL, &g_dynlibTheme, "SetWindowTheme" };
    
    HRESULT hr;

    hr = LoadProcedure(&s_dynprocSetWindowTheme);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HWND, LPCWSTR, LPCWSTR))
            s_dynprocSetWindowTheme.pfn)
            (hwnd, pszSubAppName, pszSubIdList);
}

THEMEAPI
DrawThemeBorder(
    HTHEME hTheme, 
    HDC hdc, 
    int iStateId, 
    const RECT *pRect
)
{
    static DYNPROC s_dynprocDrawThemeBorder =
            { NULL, &g_dynlibTheme, "DrawThemeBorder" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocDrawThemeBorder);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, const RECT *))
            s_dynprocDrawThemeBorder.pfn)
            (hTheme, hdc, iStateId, pRect);
}

THEMEAPI
DrawThemeBackground(   HTHEME hTheme,
                       HDC hdc,
                       int iPartId,
                       int iStateId,
                       const RECT *pRect,
                       const RECT *pClipRect)
{
    static DYNPROC s_dynprocDrawThemeBackground =
            { NULL, &g_dynlibTheme, "DrawThemeBackground" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocDrawThemeBackground);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int, const RECT *, const RECT *))
            s_dynprocDrawThemeBackground.pfn)
            (hTheme, hdc, iPartId, iStateId, pRect, pClipRect);
}

THEMEAPI
GetThemeTextMetrics(   HTHEME hTheme,
                       HDC hdc,
                       int iPartId,
                       int iStateId,
                       TEXTMETRIC *ptm)
{
    static DYNPROC s_dynprocGetThemeTextMetrics =
            { NULL, &g_dynlibTheme, "GetThemeTextMetrics" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeTextMetrics);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int, TEXTMETRIC *))
            s_dynprocGetThemeTextMetrics.pfn)
            (hTheme, hdc, iPartId, iStateId, ptm);
}

THEMEAPI
GetThemeBackgroundContentRect(
    HTHEME hTheme, 
    HDC    hdc /*optional*/,
    int iPartId, 
    int iStateId, 
    const RECT *pBoundingRect /*optional*/, 
    RECT *pContentRect
)
{
    static DYNPROC s_dynprocGetThemeBackgroundContentRect =
            { NULL, &g_dynlibTheme, "GetThemeBackgroundContentRect" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeBackgroundContentRect);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int,  const RECT*, RECT *))
            s_dynprocGetThemeBackgroundContentRect.pfn)
            (hTheme, hdc, iPartId, iStateId, pBoundingRect, pContentRect);
}

THEMEAPI
GetThemeBackgroundExtent(
    HTHEME hTheme, 
    HDC    hdc /*optional*/,
    int iPartId, 
    int iStateId, 
    const RECT *pContentRect, 
    RECT *pExtentRect
)
{
    static DYNPROC s_dynprocGetThemeBackgroundExtent =
            { NULL, &g_dynlibTheme, "GetThemeBackgroundExtent" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeBackgroundExtent);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int,  const RECT*, RECT *))
            s_dynprocGetThemeBackgroundExtent.pfn)
            (hTheme, hdc, iPartId, iStateId, pContentRect, pExtentRect);
}

THEMEAPI 
GetThemeColor(
    HTHEME hTheme, 
    int iPartId, 
    int iStateId, 
    int iPropId, 
    COLORREF *pColor
)
{
    static DYNPROC s_dynprocGetThemeColor =
            { NULL, &g_dynlibTheme, "GetThemeColor" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeColor);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, int, int,  int, COLORREF *))
            s_dynprocGetThemeColor.pfn)
            (hTheme, iPartId, iStateId, iPropId, pColor);
}

THEMEAPI
GetThemeFont(   HTHEME hTheme,
                       HDC hdc,
                       int iPartId,
                       int iStateId,
                       int iPropId,
                       LOGFONT *pFont)
{
    static DYNPROC s_dynprocGetThemeFont =
            { NULL, &g_dynlibTheme, "GetThemeFont" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeFont);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int,  int, LOGFONT *))
            s_dynprocGetThemeFont.pfn)
            (hTheme, hdc, iPartId, iStateId, iPropId, pFont);
}


THEMEAPI
GetThemeTextExtent(
    HTHEME hTheme, 
    HDC hdc, 
    int iPartId, 
    int iStateId, 
    LPCWSTR pstrText, 
    int iCharCount,
    DWORD dwTextFlags, 
    const RECT *pBoundingRect, 
    RECT *pExtentRect
)
{
    static DYNPROC s_dynprocGetThemeTextExtent =
            { NULL, &g_dynlibTheme, "GetThemeTextExtent" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeTextExtent);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int, LPCWSTR, int, DWORD, const RECT*, RECT *))
            s_dynprocGetThemeTextExtent.pfn)
            (hTheme, hdc, iPartId, iStateId, pstrText, iCharCount, dwTextFlags, pBoundingRect, pExtentRect);
}

THEMEAPI_(BOOL) IsThemePartDefined(
    HTHEME hTheme, 
    int iPartId, 
    int iStateId
    )
{
    static DYNPROC s_dynprocIsThemePartDefined =
            { NULL, &g_dynlibTheme, "IsThemePartDefined" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocIsThemePartDefined);
    
    if (hr)
    {
        return FALSE;
    }

    return (*(BOOL (STDAPICALLTYPE *)(HTHEME, int, int))
            s_dynprocIsThemePartDefined.pfn)
            (hTheme, iPartId, iStateId);
}

THEMEAPI
CloseThemeData(HTHEME hTheme)
{
    static DYNPROC s_dynprocCloseThemeData =
            { NULL, &g_dynlibTheme, "CloseThemeData" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocCloseThemeData);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME))
            s_dynprocCloseThemeData.pfn)
            (hTheme);
}

THEMEAPI_(BOOL)
IsAppThemed()
{
    static DYNPROC s_dynprocIsAppThemed =
            { NULL, &g_dynlibTheme, "IsAppThemed" };

    HRESULT hr;

    if (!g_fThemedPlatform)
        return FALSE;
    
    hr = LoadProcedure(&s_dynprocIsAppThemed);
    
    if (hr)
    {
        return FALSE;
    }

    return (*(BOOL (STDAPICALLTYPE *)())
            s_dynprocIsAppThemed.pfn)
            ();
}

THEMEAPI_(DWORD)
GetThemeAppProperties()
{
    static DYNPROC s_dynprocGetThemeAppProperties =
            { NULL, &g_dynlibTheme, "GetThemeAppProperties" };

    HRESULT hr;

    if (!g_fThemedPlatform)
        return 0;

    hr = LoadProcedure(&s_dynprocGetThemeAppProperties);
    
    if (hr)
    {
        return 0;
    }

    return (*(DWORD (STDAPICALLTYPE *)())
            s_dynprocGetThemeAppProperties.pfn)
            ();
}

THEMEAPI_(VOID)
SetThemeAppProperties(DWORD dwFlags)
{
    static DYNPROC s_dynprocSetThemeAppProperties =
            { NULL, &g_dynlibTheme, "SetThemeAppProperties" };

    HRESULT hr;

    if (!g_fThemedPlatform)
        return;

    hr = LoadProcedure(&s_dynprocSetThemeAppProperties);
    
    if (hr)
    {
        return;
    }

    return (*(VOID (STDAPICALLTYPE *)(DWORD))
            s_dynprocSetThemeAppProperties.pfn)
            (dwFlags);
}
THEMEAPI_(BOOL)
IsThemeActive()
{
    static DYNPROC s_dynprocIsThemeActive =
            { NULL, &g_dynlibTheme, "IsThemeActive" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return FALSE;

    hr = LoadProcedure(&s_dynprocIsThemeActive);
    
    if (hr)
    {
        return FALSE;
    }

    return (*(BOOL (STDAPICALLTYPE *)())
            s_dynprocIsThemeActive.pfn)
            ();
}

THEMEAPI HitTestThemeBackground(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId,
    DWORD dwOptions,
    const RECT *pRect,
    OPTIONAL HRGN hrgn,
    POINT ptTest,
    OUT WORD *pwHitTestCode)
{
    static DYNPROC s_dynprocHitTestThemeBackground =
            { NULL, &g_dynlibTheme, "HitTestThemeBackground" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocHitTestThemeBackground);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int, DWORD, const RECT *, HRGN, POINT, OUT WORD *))
            s_dynprocHitTestThemeBackground.pfn)
            (hTheme, hdc, iPartId, iStateId, dwOptions, pRect, hrgn, ptTest, pwHitTestCode);
}

VOID
WINAPI
ReleaseActCtx(HANDLE hActCtx)
{
    static DYNPROC s_dynprocReleaseActCtx =
            { NULL, &g_dynlibKERNEL32, "ReleaseActCtx" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return;

    hr = LoadProcedure(&s_dynprocReleaseActCtx);
    
    if (hr)
    {
        return;
    }

    return (*(VOID (STDAPICALLTYPE *)(HANDLE))
            s_dynprocReleaseActCtx.pfn)
            (hActCtx);

/*

    VOID (WINAPI *pfn)(HANDLE);
 
    if (!g_fThemedPlatform)
    {
        return;
    }
    
    pfn = (VOID (WINAPI *)(HANDLE))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "ReleaseActCtx");

    if (pfn)
    {
        pfn(hActCtx);
    }

    return;
*/    
}

HANDLE
WINAPI
CreateActCtxW(PCACTCTXW pActCtx)
{
    static DYNPROC s_dynprocCreateActCtxW =
            { NULL, &g_dynlibKERNEL32, "CreateActCtxW" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return NULL;

    hr = LoadProcedure(&s_dynprocCreateActCtxW);
    
    if (hr)
    {
        return NULL;
    }

    return (*(HANDLE (STDAPICALLTYPE *)(PCACTCTXW))
            s_dynprocCreateActCtxW.pfn)
            (pActCtx);

/*
    HANDLE (WINAPI *pfn)(PCACTCTXW);

    if (!g_fThemedPlatform)
    {
        return NULL;
    }
    
    pfn = (HANDLE (WINAPI *)(PCACTCTXW))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "CreateActCtxW");

    if (pfn)
    {
        return pfn(pActCtx);
    }

    return NULL;
*/
}

HANDLE
WINAPI
CreateActCtxA(PCACTCTXA pActCtx)
{
    static DYNPROC s_dynprocCreateActCtxA =
            { NULL, &g_dynlibKERNEL32, "CreateActCtxA" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return NULL;

    hr = LoadProcedure(&s_dynprocCreateActCtxA);
    
    if (hr)
    {
        return NULL;
    }

    return (*(HANDLE (STDAPICALLTYPE *)(PCACTCTXA))
            s_dynprocCreateActCtxA.pfn)
            (pActCtx);
}

BOOL
WINAPI
ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
{        
    static DYNPROC s_dynprocActivateActCtx =
            { NULL, &g_dynlibKERNEL32, "ActivateActCtx" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return FALSE;

    hr = LoadProcedure(&s_dynprocActivateActCtx);
    
    if (hr)
    {
        return FALSE;
    }

    return (*(BOOL (STDAPICALLTYPE *)(HANDLE, ULONG_PTR *))
            s_dynprocActivateActCtx.pfn)
            (hActCtx, lpCookie);

/*
    BOOL (WINAPI *pfn)(HANDLE, ULONG*);

    if (!g_fThemedPlatform)
    {
        return NULL;
    }
    
    pfn = (BOOL (WINAPI *)(HANDLE, ULONG*))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "ActivateActCtx");

    if (pfn)
    {
        return pfn(hActCtx, lpCookie);
    }

    return FALSE;
*/
}

BOOL
WINAPI
DeactivateActCtx(ULONG dwFlags, ULONG_PTR lpCookie)
{
    static DYNPROC s_dynprocDeactivateActCtx =
            { NULL, &g_dynlibKERNEL32, "DeactivateActCtx" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return FALSE;

    hr = LoadProcedure(&s_dynprocDeactivateActCtx);
    
    if (hr)
    {
        return FALSE;
    }

    return (*(BOOL (STDAPICALLTYPE *)(ULONG, ULONG_PTR))
            s_dynprocDeactivateActCtx.pfn)
            (dwFlags, lpCookie);

/*
    BOOL (WINAPI *pfn)(ULONG);

    if (!g_fThemedPlatform)
    {
        return NULL;
    }
    
    pfn = (BOOL (WINAPI *)(ULONG))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "DeactivateActCtxW");

    if (pfn)
    {
        return pfn(lpCookie);
    }

    return FALSE;
*/
}

UINT 
Wrap_GetSystemWindowsDirectory(LPTSTR lpBuffer, UINT uSize)
{
#ifdef UNICODE
    static DYNPROC s_dynprocGetSystemWindowsDirectory =
            { NULL, &g_dynlibKERNEL32, "GetSystemWindowsDirectoryW" };
#else
    static DYNPROC s_dynprocGetSystemWindowsDirectory =
            { NULL, &g_dynlibKERNEL32, "GetSystemWindowsDirectoryA" };
#endif // !UNICODE

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return 0;

    hr = LoadProcedure(&s_dynprocGetSystemWindowsDirectory);
    
    if (hr)
    {
        return 0;
    }

    return (*(UINT (STDAPICALLTYPE *)(LPTSTR, UINT))
            s_dynprocGetSystemWindowsDirectory.pfn)
            (lpBuffer, uSize);
}

//
// we need this thing to compile
// this is defined in winuser.h
//

/*
 * Combobox information
 */
typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT  rcItem;
    RECT  rcButton;
    DWORD stateButton;
    HWND  hwndCombo;
    HWND  hwndItem;
    HWND  hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;
//
// end of winuser story
//

BOOL
WINAPI
GetComboBoxInfo(
    HWND hwndCombo,
    PCOMBOBOXINFO pcbi
)
{
    static DYNPROC s_dynprocGetComboBoxInfo =
            { NULL, &g_dynlibUSER32, "GetComboBoxInfo" };
    
    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetComboBoxInfo);

    if (hr)
    {
        return NULL;
    }

    return (*(BOOL (STDAPICALLTYPE *)(HWND, PCOMBOBOXINFO))
            s_dynprocGetComboBoxInfo.pfn)
            (hwndCombo, pcbi);
}

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\unicwrap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       unicwrap.cxx
//
//  Contents:   Wrappers for all Unicode functions used in the Forms^3 project.
//              Any Unicode parameters/structure fields/buffers are converted
//              to ANSI, and then the corresponding ANSI version of the function
//              is called.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#define _SHELL32_
#define _SHDOCVW_
#include <shellapi.h>
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include <commctrl.h>       // for treeview
#endif

#ifndef X_USP_HXX_
#define X_USP_HXX_
#include "usp.hxx"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_ICADD_H_
#define X_ICADD_H_
typedef LONG NTSTATUS;      // from <ntdef.h> - needed by winsta.h
#include <winsta.h>
#include <icadd.h>
#endif

DeclareTag(tagUniWrap, "UniWrap", "Unicode wrappers information");
DeclareTag(tagTerminalServer, "Doc", "Use Terminal Server mode");

MtDefine(CStrInW_pwstr, Utilities, "CStrInW::_pwstr")
MtDefine(CStrIn_pstr,   Utilities, "CStrIn::_pstr")
MtDefine(CStrOut_pstr,  Utilities, "CStrOut::_pstr")
MtDefine(IsTerminalServer_szProductSuite, Utilities, "IsTerminalServer_szProductSuite");

DWORD   g_dwPlatformVersion;            // (dwMajorVersion << 16) + (dwMinorVersion)
DWORD   g_dwPlatformID;                 // VER_PLATFORM_WIN32S/WIN32_WINDOWS/WIN32_WINNT
DWORD   g_dwPlatformBuild;              // Build number
DWORD   g_dwPlatformServicePack;        // Service Pack
UINT    g_uLatinCodepage;
BOOL    g_fUnicodePlatform;
BOOL    g_fTerminalServer;              // TRUE if running under NT Terminal Server, FALSE otherwise
BOOL    g_fTermSrvClientSideBitmaps;    // TRUE if TS supports client-side bitmaps
BOOL    g_fNLS95Support;
BOOL    g_fGotLatinCodepage = FALSE;
BOOL    g_fFarEastWin9X;
BOOL    g_fFarEastWinNT;
BOOL    g_fExtTextOutWBuggy;
BOOL    g_fExtTextOutGlyphCrash;
BOOL    g_fBidiSupport; // COMPLEXSCRIPT
BOOL    g_fComplexScriptInput;
BOOL    g_fMirroredBidiLayout;
BOOL    g_fThemedPlatform;
BOOL    g_fWhistlerOS;
BOOL    g_fUseShell32InsteadOfSHFolder;

DeclareTagOther(tagHackGDICoords,"DocHackGDICoords","simulate Win95 GDI coordinate limitation")
DeclareTag(tagCheck16bitLimitations, "Display", "Assert if GDI coordinates are out of 16-bit space");


//+------------------------------------------------------------------------
//
//  Define prototypes of wrapped functions.
//
//-------------------------------------------------------------------------

#if USE_UNICODE_WRAPPERS==1 /* { */

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
        FnType _stdcall FnName##Wrap FnParamList ;

#define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs)      \
        void _stdcall FnName##Wrap FnParamList ;

#if DBG==1 /* { */

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
        FnType _stdcall FnName##Wrap FnParamList ;

#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs) \
        void _stdcall FnName##Wrap FnParamList ;

#else

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs)
#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)

#endif /* } */

#define NOOVERRIDE
        
#include "wrapfns.h"

#undef STRUCT_ENTRY
#undef STRUCT_ENTRY_VOID
#undef STRUCT_ENTRY_NOCONVERT
#undef STRUCT_ENTRY_VOID_NOCONVERT


//+------------------------------------------------------------------------
//
//  Unicode function globals initialized to point to wrapped functions.
//
//-------------------------------------------------------------------------

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
        FnType (_stdcall *g_pufn##FnName) FnParamList = &FnName##Wrap;

#define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs)      \
        void   (_stdcall *g_pufn##FnName) FnParamList = &FnName##Wrap;

#if DBG==1 /* { */

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
        FnType (_stdcall *g_pufn##FnName) FnParamList = &FnName##Wrap;

#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)    \
        void   (_stdcall *g_pufn##FnName) FnParamList = &FnName##Wrap;

#else

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
        FnType (_stdcall *g_pufn##FnName) FnParamList;

#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)    \
        void   (_stdcall *g_pufn##FnName) FnParamList;

#endif /* } */

#include "wrapfns.h"

#undef STRUCT_ENTRY
#undef STRUCT_ENTRY_VOID
#undef STRUCT_ENTRY_NOCONVERT
#undef STRUCT_ENTRY_VOID_NOCONVERT

#endif /* } */

//+---------------------------------------------------------------------------
//
//  Function:       IsFarEastLCID(lcid)
//
//  Returns:        True iff lcid is a East Asia locale.
//
//----------------------------------------------------------------------------

BOOL
IsFarEastLCID(LCID lcid)
{
    switch (PRIMARYLANGID(LANGIDFROMLCID(lcid)))
    {
        case LANG_CHINESE:
        case LANG_JAPANESE:
        case LANG_KOREAN:
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//  COMPLEXSCRIPT
//  Function:       IsBidiLCID(lcid)
//
//  Returns:        True iff lcid is a right to left locale.
//
//----------------------------------------------------------------------------
#define lcidKashmiri 0x0860
#define lcidUrduIndia     0x0820

BOOL 
IsBidiLCID(LCID lcid)
{
    switch(PRIMARYLANGID(LANGIDFROMLCID(lcid)))
    {
        case LANG_ARABIC:
        case LANG_FARSI:
        case LANG_HEBREW:
        case LANG_KASHMIRI:
            if (lcid == lcidKashmiri)
                return FALSE;
        case LANG_PASHTO:
        case LANG_SINDHI:
        case LANG_SYRIAC:
        case LANG_URDU:
            if (lcid == lcidUrduIndia)
                return FALSE;
        case LANG_YIDDISH:
            return TRUE;
            break;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//  COMPLEXSCRIPT
//  Function:       IsComplexLCID(lcid)
//
//  Returns:        True iff lcid is a complex script locale.
//
//----------------------------------------------------------------------------

BOOL 
IsComplexLCID(LCID lcid)
{
    switch(PRIMARYLANGID(LANGIDFROMLCID(lcid)))
    {
        case LANG_ARABIC:
        case LANG_ASSAMESE:
        case LANG_BENGALI:
        case LANG_BURMESE:
        case LANG_FARSI:
        case LANG_GUJARATI:
        case LANG_HEBREW:
        case LANG_HINDI:
        case LANG_KANNADA:
        case LANG_KASHMIRI:
        case LANG_KHMER:
        case LANG_KONKANI:
        case LANG_LAO:
        case LANG_MALAYALAM:
        case LANG_MANIPURI:
        case LANG_MARATHI:
        case LANG_MONGOLIAN:
        case LANG_NAPALI:
        case LANG_ORIYA:
        case LANG_PASHTO:
        case LANG_PUNJABI:
        case LANG_SANSKRIT:
        case LANG_SINDHI:
        case LANG_SINHALESE:
        case LANG_SYRIAC:
        case LANG_TAMIL:
        case LANG_TELUGU:
        case LANG_THAI:
        case LANG_TIBETAN:
        case LANG_URDU:
        case LANG_VIETNAMESE:
        case LANG_YIDDISH:
           return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   DebugSetTerminalServer
//
//  Synopsis:   Sets terminal server mode
//
//----------------------------------------------------------------------------

#if DBG==1
void
DebugSetTerminalServer()
{
    static int s_Real_fTerminalServer = -2;

    if (s_Real_fTerminalServer == -2)
    {
        s_Real_fTerminalServer = IsTerminalServer();
    }

    g_fTerminalServer = IsTagEnabled(tagTerminalServer) ? TRUE
                                                        : s_Real_fTerminalServer;
}
#endif

/************************************ B E G I N   O F   S H E L L   C O D E
* (dmitryt)
* This code is borrowed from shell (file shell\lib\stockthk\rtlmir.cpp)
* to employ the same functionality in deciding whether we should apply WS_EX_LAYOUTRTL
* bit or not. This logic is used in 2 places - when we create HTA window and when we 
* create a HTML dialog.
* We use this code to set a single flag, g_fMirroredBidiLayout.
* 
***************************************************************************/

typedef LANGID (WINAPI *PFNGETUSERDEFAULTUILANGUAGE)(void);  // kernel32!GetUserDefaultUILanguage
typedef BOOL (WINAPI *PFNENUMUILANGUAGES)(UILANGUAGE_ENUMPROC, DWORD, LONG_PTR); // kernel32!EnumUILanguages

typedef struct {
    LANGID LangID;
    BOOL   bInstalled;
    } MUIINSTALLLANG, *LPMUIINSTALLLANG;

#ifdef UNICODE
#define ConvertHexStringToInt ConvertHexStringToIntW
#else
#define ConvertHexStringToInt ConvertHexStringToIntA
#endif

/*----------------------------------------------------------
Purpose: Returns TRUE/FALSE if the platform is the given OS_ value.

*/
BOOL IEisOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOEXA s_osvi = {0};
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;
        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        if (!GetVersionExA((OSVERSIONINFOA*)&s_osvi))
        {
            // If it failed, it must be a down level platform
            s_osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            GetVersionExA((OSVERSIONINFOA*)&s_osvi);
        }
    }

    switch (dwOS)
    {
/*
    case OS_TERMINALCLIENT:
        // WARNING: this will only return TRUE for REMOTE TS sessions (eg you are comming in via tsclient).
        // If you want to see if TS is enabled or if the user is on the TS console, the use one of the other flags.
        bRet = GetSystemMetrics(SM_REMOTESESSION);
        break;

    case OS_WIN2000TERMINAL:
        // WARNING: this flag is VERY ambiguous... you probably want to use one of 
        // OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or  OS_PERSONALTERMINALSERVER instead.
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use one of OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or OS_PERSONALTERMINALSERVER instead !");
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                s_osvi.dwMajorVersion >= 5);
        break;

    case OS_TERMINALSERVER:
        // NOTE: be careful about using OS_TERMINALSERVER. It will only return true for nt server boxes
        // configured in what used to be called "Applications Server" mode in the win2k days. It is now simply called
        // "Terminal Server" (hence the name of this flag).
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                !(VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask));
#ifdef DEBUG
        if (bRet)
        {
            // all "Terminal Server" machines have to be server (cannot be per/pro)
            ASSERT(VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType);
        }
#endif
        break;

    case OS_TERMINALREMOTEADMIN:
        // this checks to see if TS has been installed in the "Remote Administration" mode. This is
        // the default for server installs on win2k and whistler
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                (VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask));
        break;

    case OS_PERSONALTERMINALSERVER:
        bRet = ((VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask) &&
                !(VER_SUITE_TERMINAL & s_osvi.wSuiteMask));
        break;

    case OS_FASTUSERSWITCHING:
        bRet = (((VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS) & s_osvi.wSuiteMask) &&
                IsWinlogonRegValueSet(HKEY_LOCAL_MACHINE,
                                      "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                      "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
                                      "AllowMultipleTSSessions"));
        break;

    case OS_FRIENDLYLOGONUI:
        bRet = (!IsMachineDomainMember() &&
                !IsWinlogonRegValuePresent(HKEY_LOCAL_MACHINE,
                                           "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                           "GinaDLL") &&
                IsWinlogonRegValueSet(HKEY_LOCAL_MACHINE,
                                      "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                      "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
                                      "LogonType"));
        break;

    case OS_DOMAINMEMBER:
        bRet = IsMachineDomainMember();
        ASSERT(VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId); // has to be a NT machine to be on a domain!
        break;

    case 4: // used to be OS_NT5, is the same as OS_WIN2000ORGREATER so use that instead
*/
    case OS_WIN2000ORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;
/*
    // NOTE: The flags in this section are bogus and SHOULD NOT BE USED 
    //       (but the ie4 shell32 uses them, so don't RIP on downlevel platforms)
    case OS_WIN2000PRO:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_PROFESSIONAL instead of OS_WIN2000PRO !");
        bRet = (VER_NT_WORKSTATION == s_osvi.wProductType &&
                s_osvi.dwMajorVersion == 5);
        break;
    case OS_WIN2000ADVSERVER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_ADVSERVER instead of OS_WIN2000ADVSERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000DATACENTER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_DATACENTER instead of OS_WIN2000DATACENTER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000SERVER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_SERVER instead of OS_WIN2000SERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask) && 
                !(VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask)  && 
                s_osvi.dwMajorVersion == 5);
        break;
    // END bogus Flags

    case OS_EMBEDDED:
        bRet = (VER_SUITE_EMBEDDEDNT & s_osvi.wSuiteMask);
        break;

    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
        break;

    case OS_WIN95:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_WIN95GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 0 &&
                LOWORD(s_osvi.dwBuildNumber) == 950);
        break;
*/
    case OS_WIN98ORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;
/*
    case OS_WIN98_GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 10 &&
                LOWORD(s_osvi.dwBuildNumber) == 1998);
        break;

    case OS_MILLENNIUMORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 90) ||
                s_osvi.dwMajorVersion > 4));
        break;

    case OS_NT4:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_WHISTLERORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion > 5) ||
                (s_osvi.dwMajorVersion == 5 && (s_osvi.dwMinorVersion > 0 ||
                (s_osvi.dwMinorVersion == 0 && LOWORD(s_osvi.dwBuildNumber) > 2195)))));
        break;

    case OS_PERSONAL:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                (VER_SUITE_PERSONAL & s_osvi.wSuiteMask));
        break;

    case OS_PROFESSIONAL:
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId) && 
                (VER_NT_WORKSTATION == s_osvi.wProductType));
        break;

    case OS_DATACENTER:
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                (VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;

    case OS_ADVSERVER:
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                (VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;

    case OS_SERVER:
        // NOTE: be careful! this specifically means Server -- will return false for Avanced Server and Datacenter machines
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask) && 
                !(VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask));
        break;

    case OS_ANYSERVER:
        // this is for people who want to know if this is ANY type of NT server machine (eg dtc, ads, or srv)
        bRet = ((VER_NT_SERVER == s_osvi.wProductType) || (VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType));
        break;
*/
    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}   


/***************************************************************************\
* ConvertHexStringToIntA
*
* Converts a hex numeric string into an integer.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
BOOL ConvertHexStringToIntA( CHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    CHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextA(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            CHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}

/***************************************************************************\
* ConvertHexStringToIntW
*
* Converts a hex numeric string into an integer.
*
* History:
* 14-June-1998 msadek    Created
\***************************************************************************/
BOOL ConvertHexStringToIntW( WCHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    WCHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextW(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            WCHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}



/***************************************************************************\
* Mirror_GetUserDefaultUILanguage
*
* Reads the User UI language on NT5
*
* History:
* 22-June-1998 samera    Created
\***************************************************************************/
LANGID Mirror_GetUserDefaultUILanguage( void )
{
    LANGID langId=0;
    static PFNGETUSERDEFAULTUILANGUAGE pfnGetUserDefaultUILanguage=NULL;

    if( NULL == pfnGetUserDefaultUILanguage )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnGetUserDefaultUILanguage = (PFNGETUSERDEFAULTUILANGUAGE)
                                          GetProcAddress(hmod, "GetUserDefaultUILanguage");
    }

    if( pfnGetUserDefaultUILanguage )
        langId = pfnGetUserDefaultUILanguage();

    return langId;
}

/***************************************************************************\
* Mirror_EnumUILanguagesProc
*
* Enumerates MUI installed languages on W2k
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/

BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR 
lParam)
{
    int langID = 0;

    ConvertHexStringToInt(lpUILanguageString, &langID);

    if((LANGID)langID == ((LPMUIINSTALLLANG)lParam)->LangID)
    {
        ((LPMUIINSTALLLANG)lParam)->bInstalled = TRUE;
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* Mirror_IsUILanguageInstalled
*
* Verifies that the User UI language is installed on W2k
*
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/
BOOL Mirror_IsUILanguageInstalled( LANGID langId )
{

    MUIINSTALLLANG MUILangInstalled = {0};
    MUILangInstalled.LangID = langId;
    
    static PFNENUMUILANGUAGES pfnEnumUILanguages=NULL;

    if( NULL == pfnEnumUILanguages )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnEnumUILanguages = (PFNENUMUILANGUAGES)
                                          GetProcAddress(hmod, "EnumUILanguagesW");
    }

    if( pfnEnumUILanguages )
        pfnEnumUILanguages(Mirror_EnumUILanguagesProc, 0, (LONG_PTR)&MUILangInstalled);

    return MUILangInstalled.bInstalled;
}


/***************************************************************************\
* IsBiDiLocalizedSystemEx
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL IsBiDiLocalizedSystemEx( LANGID *pLangID )
{
    HKEY          hKey;
    DWORD         dwType;
    CHAR          szResourceLocale[12];
    DWORD         dwSize = sizeof(szResourceLocale)/sizeof(CHAR);
    int           iLCID=0L;
    static BOOL   bRet = (BOOL)(DWORD)-1;
    static LANGID langID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (bRet != (BOOL)(DWORD)-1)
    {
        if (bRet && pLangID)
        {
            *pLangID = langID;
        }
        return bRet;
    }

    bRet = FALSE;
    if(IEisOS(OS_WIN2000ORGREATER))
    {
        /*
         * Need to use NT5 detection method (Multiligual UI ID)
         */
        langID = Mirror_GetUserDefaultUILanguage();

        if( langID )
        {
            WCHAR wchLCIDFontSignature[16];
            iLCID = MAKELCID( langID , SORT_DEFAULT );

            /*
             * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
             * convert to decimal value and call GetLocaleInfo afterwards.
             * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
             */

            if( GetLocaleInfoW( iLCID , 
                                LOCALE_FONTSIGNATURE , 
                                (WCHAR *) &wchLCIDFontSignature[0] ,
                                (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
            {
      
                /* Let's verify the bits we have a BiDi UI locale */
                if(( wchLCIDFontSignature[7] & (WCHAR)0x0800) && Mirror_IsUILanguageInstalled(langID) )
                {
                    bRet = TRUE;
                }
            }
        }
    } else {

        /*
         * Check if BiDi-Memphis is running with Lozalized Resources (
         * i.e. Arabic/Hebrew systems) -It should be enabled ofcourse-.
         */
        if(IEisOS(OS_WIN98ORGREATER) && GetSystemMetrics(SM_MIDEASTENABLED))
        {

            if( RegOpenKeyExA( HKEY_CURRENT_USER , 
                               "Control Panel\\Desktop\\ResourceLocale" , 
                               0, 
                               KEY_READ, &hKey) == ERROR_SUCCESS) 
            {
                RegQueryValueExA( hKey , "" , 0 , &dwType , (LPBYTE)szResourceLocale , &dwSize );
                szResourceLocale[(sizeof(szResourceLocale)/sizeof(CHAR))-1] = 0;

                RegCloseKey(hKey);

                if( ConvertHexStringToIntA( szResourceLocale , &iLCID ) )
                {
                    iLCID = PRIMARYLANGID(LANGIDFROMLCID(iLCID));
                    if( (LANG_ARABIC == iLCID) || (LANG_HEBREW == iLCID) )
                    {
                        bRet = TRUE;
                        langID = LANGIDFROMLCID(iLCID);
                    }
                }
            }
        }
    }

    if (bRet && pLangID)
    {
        *pLangID = langID;
    }
    return bRet;
}

BOOL IsBiDiLocalizedSystem( void )
{
    return IsBiDiLocalizedSystemEx(NULL);
}

//************************************ E N D   O F   S H E L L   C O D E


//+---------------------------------------------------------------------------
//
//  Function:   InitUnicodeWrappers
//
//  Synopsis:   Determines the platform we are running on and
//              initializes pointers to unicode functions.
//
//----------------------------------------------------------------------------

void
InitUnicodeWrappers()
{
#ifndef WINCE
    OSVERSIONINFOA ovi;
#else //WINCE
    OSVERSIONINFO ovi;
#endif //WINCE
    const UINT acp = GetACP();
#ifndef UNIX
    const BOOL fFarEastLCID = IsFarEastLCID(GetSystemDefaultLCID());
#else
    const BOOL fFarEastLCID = FALSE;  // UNIXTODO
#endif

#ifndef WINCE
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    Verify(GetVersionExA(&ovi));
#else //WINCE
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    Verify(GetVersionEx(&ovi));
#endif //WINCE

    g_dwPlatformVersion     = (ovi.dwMajorVersion << 16) + ovi.dwMinorVersion;
    g_dwPlatformID          = ovi.dwPlatformId;
    g_dwPlatformBuild       = ovi.dwBuildNumber;
    g_fThemedPlatform       = (g_dwPlatformID  == VER_PLATFORM_WIN32_NT &&  g_dwPlatformVersion > 0x00050000) ? 
                              TRUE :
                              FALSE;

    // We realize that this is the same code with the line above, 
    // just worried that theming becomes available for downlevel OS'. 
    g_fWhistlerOS           = (g_dwPlatformID  == VER_PLATFORM_WIN32_NT &&  g_dwPlatformVersion > 0x00050000) ? 
                              TRUE :
                              FALSE;

    // NOTE:    On Millennium or W2k we should use Shell32 for SHGetFolderPath
    //          instead of SHFolder.
    g_fUseShell32InsteadOfSHFolder = (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID 
                                        && (g_dwPlatformVersion >= 0x0004005a))
                                     || (VER_PLATFORM_WIN32_NT == g_dwPlatformID 
                                        && g_dwPlatformVersion >= 0x00050000);

    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        char * pszBeg = ovi.szCSDVersion;

        if (*pszBeg)
        {
            char * pszEnd = pszBeg + lstrlenA(pszBeg);
            
            while (pszEnd > pszBeg)
            {
                char c = pszEnd[-1];

                if (c < '0' || c > '9')
                    break;

                pszEnd -= 1;
            }

            while (*pszEnd)
            {
                g_dwPlatformServicePack *= 10;
                g_dwPlatformServicePack += *pszEnd - '0';
                pszEnd += 1;
            }
        }
    }

#ifndef WINCE
    g_fUnicodePlatform      = (g_dwPlatformID == VER_PLATFORM_WIN32_NT ||
                               g_dwPlatformID == VER_PLATFORM_WIN32_UNIX);

    g_fNLS95Support         = (g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS ||
                              (g_dwPlatformID == VER_PLATFORM_WIN32_NT &&
                                 ovi.dwMajorVersion >= 3)) ? TRUE : FALSE;

    g_fFarEastWin9X         = fFarEastLCID &&
                              g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS;

    g_fFarEastWinNT         = fFarEastLCID &&
                              g_dwPlatformID == VER_PLATFORM_WIN32_NT;

    // NB (cthrash) ExtTextOutW and related functions are buggy under the
    // following OSes: Win95 PRC All, Win95 TC Golden
    
    g_fExtTextOutWBuggy     = g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS &&
                              ((   acp == 950 // CP_TWN
                                && g_dwPlatformVersion == 0x00040000) ||
                               (   acp == 936 // CP_CHN_GB
                                && g_dwPlatformVersion < 0x0004000a ));

    // NB (mikejoch) ExtTextOut(... , ETO_GLYPH_INDEX, ...) crashes under all
    // FE Win95 OSes -- JPN, KOR, CHT, & CHS. Fixed for Win98.
    g_fExtTextOutGlyphCrash = fFarEastLCID &&
                              g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS &&
                              g_dwPlatformVersion < 0x0004000a;
/*
    g_fMirroredBidiLayout  = ((g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS &&
                                g_dwPlatformVersion >= 0x0004000a) ||
                               (g_dwPlatformID == VER_PLATFORM_WIN32_NT &&
                                g_dwPlatformVersion >= 0x00050000));
*/

    g_fMirroredBidiLayout  = IsBiDiLocalizedSystem();


#ifndef UNIX
    HKL aHKL[32];
    UINT uKeyboards = GetKeyboardLayoutList(32, aHKL);
    // check all keyboard layouts for existance of a RTL language.
    // bounce out when the first one is encountered.
    for(UINT i = 0; i < uKeyboards; i++)
    {
        if(IsBidiLCID(LOWORD(aHKL[i])))
        {
            g_fBidiSupport = TRUE;
            g_fComplexScriptInput = TRUE;
            break;
        }

        if(IsComplexLCID(LOWORD(aHKL[i])))
        {
            g_fComplexScriptInput = TRUE;
        }
        
    }
#else //UNIX
    g_fBidiSupport = FALSE;
    g_fComplexScriptInput = FALSE;
#endif
#else //WINCE
    g_fUnicodePlatform      = TRUE;

    g_fNLS95Support         = TRUE;

    g_fFarEastWin9X         = FALSE;

    g_fFarEastWinNT         = fFarEastLCID;

    g_fExtTextOutWBuggy     = FALSE;

    g_fExtTextOutGlyphCrash = FALSE;

    g_fBidiSupport          = FALSE;

    g_fComplexScriptInput   = FALSE;

    g_fMirroredBidiLayout = FALSE;

#endif //WINCE



#if USE_UNICODE_WRAPPERS==1     /* { */

    //
    // If the platform is unicode, then overwrite function table to point
    // to the unicode functions.
    //

    if (g_fUnicodePlatform)
    {
        #define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
                g_pufn##FnName = &FnName##W;

        #define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs)      \
                g_pufn##FnName = &FnName##W;

        #define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
                g_pufn##FnName = &FnName##W;

        #define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)    \
                g_pufn##FnName = &FnName##W;

        #include "wrapfns.h"

        #undef STRUCT_ENTRY
        #undef STRUCT_ENTRY_VOID
        #undef STRUCT_ENTRY_NOCONVERT
        #undef STRUCT_ENTRY_VOID_NOCONVERT
    }
    else
    {
        //
        // If we are not doing conversions of trivial wrapper functions, initialize pointers
        // to point to operating system functions.
        //

        #define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)
        #define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs)
        #define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
                g_pufn##FnName = (FnType (_stdcall *)FnParamList) &FnName##A;

        #define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)    \
                g_pufn##FnName = (void (_stdcall *)FnParamList) &FnName##A;

        #include "wrapfns.h"

        #undef STRUCT_ENTRY
        #undef STRUCT_ENTRY_VOID
        #undef STRUCT_ENTRY_NOCONVERT
        #undef STRUCT_ENTRY_VOID_NOCONVERT

    }
#else
    {
        // RISC workaround for CP wrappers.

        #define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)
        #define STRUCT_ENTRY2(FnName, FnType, FnParamList, FnArgs)
        #define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs)
        #define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs)
        #define STRUCT_ENTRY_NOCONVERT2(FnName, FnType, FnParamList, FnArgs)
        #define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)

        #include "wrapfns.h"

        #undef STRUCT_ENTRY
        #undef STRUCT_ENTRY_VOID
        #undef STRUCT_ENTRY_NOCONVERT
        #undef STRUCT_ENTRY_VOID_NOCONVERT
    }    
#endif /* } */

    g_fTerminalServer = IsTerminalServer();

    if (g_fTerminalServer)
    {
        // see whether TS supports client-side bitmaps, by asking about a 1x1
        // bitmap.  If that doesn't work, we won't bother trying anything
        // larger.
        ICA_DEVICE_BITMAP_INFO info;
        HDC hdc = ::GetDC(NULL);
        INT rc, bSucc;

        info.cx = info.cy = 1;

        bSucc = ExtEscape(
                    hdc,
                    ESC_GET_DEVICEBITMAP_SUPPORT,
                    sizeof(info),
                    (LPSTR)&info,
                    sizeof(rc),
                    (LPSTR)&rc
                    );

        g_fTermSrvClientSideBitmaps = !!bSucc;
    }

#if DBG == 1
    DebugSetTerminalServer();
#endif
}

//+------------------------------------------------------------------------
//
//  Wrapper function utilities.
//  NOTE: normally these would also be surrounded by an #ifndef NO_UNICODE_WRAPPERS
//        but the string conversion functions are needed for dealing with
//        wininet.
//
//-------------------------------------------------------------------------

int MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr, int cwch = -1);
int UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch = -1);


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStr::Free()
{
    if (_pstr != _ach && HIWORD64(_pstr) != 0)
    {
        delete [] _pstr;
    }

    _pstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStrW::Free()
{
    if (_pwstr != _awch && HIWORD64(_pwstr) != 0)
    {
        delete [] _pwstr;
    }

    _pwstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Function:   ConvertibleCodePage, static
//
//  Synopsis:   Returns a codepage appropriate for WideCharToMultiByte.
//
//  Comment:    WideCharToMultiByte obviously cannot convert cp1200 (Unicode)
//              to multibyte.  Hence we bail out and use CP_ACP.
//
//              cp50000 is x-user-defined.  This by definition is to use
//              CP_ACP.
//
//----------------------------------------------------------------------------

UINT
ConvertibleCodePage(UINT uCP)
{
    return (uCP == 1200 || uCP == 50000) ? CP_ACP : uCP;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::Init
//
//  Synopsis:   Converts a LPSTR function argument to a LPWSTR.
//
//  Arguments:  [pstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD64(pwstr) == 0).
//
//              [cch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrInW::Init(LPCSTR pstr, int cch)
{
    int cchBufReq;

    _cwchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pstr) == 0)
    {
        _pwstr = (LPWSTR) pstr;
        return;
    }

    Assert(cch == -1 || cch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //
    // Since the passed in buffer may not be null terminated, we have
    // a problem if cch==ARRAYSIZE(_awch), because MultiByteToWideChar
    // will succeed, and we won't be able to null terminate the string!
    // Decrease our buffer by one for this case.
    //
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _awch, ARRAY_SIZE(_awch)-1);

    if (_cwchLen > 0)
    {
        // Some callers don't NULL terminate.
        //
        // We could check "if (-1 != cch)" before doing this,
        // but always doing the null is less code.
        //
        _awch[_cwchLen] = 0;

        if(_awch[_cwchLen-1] == 0)
            _cwchLen--;                // account for terminator

        _pwstr = _awch;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    cchBufReq = MultiByteToWideChar( CP_ACP, 0, pstr, cch, NULL, 0 );

    // Again, leave room for null termination
    cchBufReq++;

    Assert(cchBufReq > 0);
    _pwstr = new(Mt(CStrInW_pwstr)) WCHAR[cchBufReq];
    if (!_pwstr)
    {
        // On failure, the argument will point to the empty string.
        _awch[0] = 0;
        _pwstr = _awch;
        return;
    }

    Assert(HIWORD64(_pwstr));
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _pwstr, cchBufReq );

    // Again, make sure we're always null terminated
    Assert(_cwchLen < cchBufReq);
    _pwstr[_cwchLen] = 0;

    if (0 == _pwstr[_cwchLen-1]) // account for terminator
        _cwchLen--;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline this function or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrIn::CStrIn(LPCWSTR pwstr) : CConvertStr(CP_ACP)
{
    Init(pwstr, -1);
}


CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr) : CConvertStr(ConvertibleCodePage(uCP))
{
    Init(pwstr, -1);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::Init
//
//  Synopsis:   Converts a LPWSTR function argument to a LPSTR.
//
//  Arguments:  [pwstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD64(pwstr) == 0).
//
//              [cwch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrIn::Init(LPCWSTR pwstr, int cwch)
{
    int cchBufReq;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    _cchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pwstr) == 0)
    {
        _pstr = (LPSTR) pwstr;
        return;
    }

    if ( cwch == 0 )
    {
        *_ach = '\0';
        _pstr = _ach;
        return;
    }

    Assert(cwch == -1 || cwch > 0);
    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _ach, ARRAY_SIZE(_ach)-1, NULL, NULL);

    if (_cchLen > 0)
    {
        // This is DBCS safe since byte before _cchLen is last character
        _ach[_cchLen] = 0;
        // TODO DBCS REVIEW: this may not be safe if the last character
        // was a multibyte character...
        if (_ach[_cchLen-1]==0)
            _cchLen--;          // account for terminator
        _pstr = _ach;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //
    cchBufReq = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, NULL, 0, NULL, NULL);

    Assert(cchBufReq > 0);

    cchBufReq++; // may need to append NUL

    TraceTag((tagUniWrap, "CStrIn: Allocating buffer for argument (_uCP=%ld,cwch=%ld,pwstr=%lX,cchBufReq=%ld)",
             _uCP, cwch, pwstr, cchBufReq));

    _pstr = new(Mt(CStrIn_pstr)) char[cchBufReq];
    if (!_pstr)
    {
        // On failure, the argument will point to the empty string.
        TraceTag((tagUniWrap, "CStrIn: No heap space for wrapped function argument."));
        _ach[0] = 0;
        _pstr = _ach;
        return;
    }

    Assert(HIWORD64(_pstr));
    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _pstr, cchBufReq, NULL, NULL);

#if DBG == 1 /* { */
    if (_cchLen < 0)
    {
        errcode = GetLastError();
        TraceTag((tagError, "WideCharToMultiByte failed with errcode %ld", errcode));
        Assert(0 && "WideCharToMultiByte failed in unicode wrapper.");
    }
#endif /* } */

        // Again, make sure we're always null terminated
    Assert(_cchLen < cchBufReq);
    _pstr[_cchLen] = 0;
    if (0 == _pstr[_cchLen-1]) // account for terminator
        _cchLen--;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInMulti::CStrInMulti
//
//  Synopsis:   Converts mulitple LPWSTRs to a multiple LPSTRs.
//
//  Arguments:  [pwstr] -- The strings to convert.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

CStrInMulti::CStrInMulti(LPCWSTR pwstr)
{
    LPCWSTR pwstrT;

    // We don't handle atoms because we don't need to.
    Assert(HIWORD64(pwstr));

    //
    // Count number of characters to convert.
    //

    pwstrT = pwstr;
    if (pwstr)
    {
        do {
            while (*pwstrT++)
                ;

        } while (*pwstrT++);
    }

    Init(pwstr, pwstrT - pwstr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::CStrOut
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pwstr]   -- The Unicode buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cwchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOut::CStrOut(LPWSTR pwstr, int cwchBuf) : CConvertStr(CP_ACP)
{
    Assert(cwchBuf >= 0);

    _pwstr = pwstr;
    _cwchBuf = cwchBuf;

    if (!pwstr)
    {
        _cwchBuf = 0;
        _pstr = NULL;
        return;
    }

    Assert(HIWORD64(pwstr));

    // Initialize buffer in case Windows API returns an error.
    _ach[0] = 0;

    // Use preallocated buffer if big enough.
    if (cwchBuf * 2 <= ARRAY_SIZE(_ach))
    {
        _pstr = _ach;
        return;
    }

    // Allocate buffer.
    TraceTag((tagUniWrap, "CStrOut: Allocating buffer for wrapped function argument."));
    _pstr = new(Mt(CStrOut_pstr)) char[cwchBuf * 2];
    if (!_pstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        TraceTag((tagUniWrap, "CStrOut: No heap space for wrapped function argument."));
        Assert(cwchBuf > 0);
        _pwstr[0] = 0;
        _cwchBuf = 0;
        _pstr = _ach;
        return;
    }

    Assert(HIWORD64(_pstr));
    _pstr[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertIncludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count INCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertIncludingNul()
{
    int cch;

    if (!_pstr)
        return 0;

    cch = MultiByteToWideChar(_uCP, 0, _pstr, -1, _pwstr, _cwchBuf);

#if DBG == 1 /* { */
    if (cch <= 0 && _cwchBuf > 0)
    {
        int errcode = GetLastError();
        AssertSz(errcode != S_OK, "MultiByteToWideChar failed in unicode wrapper.");
    }
#endif /* } */

    Free();
    return cch;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertExcludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count EXCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertExcludingNul()
{
    int ret = ConvertIncludingNul();
    if (ret > 0)
    {
        ret -= 1;
    }
    return ret;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::~CStrOut
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both ConvertIncludingNul() and CConvertStr::~CConvertStr will be
//              called inline.
//
//----------------------------------------------------------------------------

CStrOut::~CStrOut()
{
    ConvertIncludingNul();
}

//+---------------------------------------------------------------------------
//
//  Function:   MbcsFromUnicode
//
//  Synopsis:   Converts a string to MBCS from Unicode.
//
//  Arguments:  [pstr]  -- The buffer for the MBCS string.
//              [cch]   -- The size of the MBCS buffer, including space for
//                              NULL terminator.
//
//              [pwstr] -- The Unicode string to convert.
//              [cwch]  -- The number of characters in the Unicode string to
//                              convert, including NULL terminator.  If this
//                              number is -1, the string is assumed to be
//                              NULL terminated.  -1 is supplied as a
//                              default argument.
//
//  Returns:    If [pstr] is NULL or [cch] is 0, 0 is returned.  Otherwise,
//              the number of characters converted, including the terminating
//              NULL, is returned (note that converting the empty string will
//              return 1).  If the conversion fails, 0 is returned.
//
//  Modifies:   [pstr].
//
//----------------------------------------------------------------------------

int
MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr, int cwch)
{
    int ret;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    Assert(cch >= 0);
    if (!pstr || cch == 0)
        return 0;

    Assert(pwstr);
    Assert(cwch == -1 || cwch > 0);

    ret = WideCharToMultiByte(CP_ACP, 0, pwstr, cwch, pstr, cch, NULL, NULL);

#if DBG == 1 /* { */
    if (ret <= 0)
    {
        errcode = GetLastError();
        Assert(0 && "WideCharToMultiByte failed in unicode wrapper.");
    }
#endif /* } */

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnicodeFromMbcs
//
//  Synopsis:   Converts a string to Unicode from MBCS.
//
//  Arguments:  [pwstr] -- The buffer for the Unicode string.
//              [cwch]  -- The size of the Unicode buffer, including space for
//                              NULL terminator.
//
//              [pstr]  -- The MBCS string to convert.
//              [cch]  -- The number of characters in the MBCS string to
//                              convert, including NULL terminator.  If this
//                              number is -1, the string is assumed to be
//                              NULL terminated.  -1 is supplied as a
//                              default argument.
//
//  Returns:    If [pwstr] is NULL or [cwch] is 0, 0 is returned.  Otherwise,
//              the number of characters converted, including the terminating
//              NULL, is returned (note that converting the empty string will
//              return 1).  If the conversion fails, 0 is returned.
//
//  Modifies:   [pwstr].
//
//----------------------------------------------------------------------------

int
UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch)
{
    int ret;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    Assert(cwch >= 0);

    if (!pwstr || cwch == 0)
        return 0;

    Assert(pstr);
    Assert(cch == -1 || cch > 0);

    ret = MultiByteToWideChar(CP_ACP, 0, pstr, cch, pwstr, cwch);

#if DBG == 1 /* { */
    if (ret <= 0)
    {
        errcode = GetLastError();
        Assert(0 && "MultiByteToWideChar failed in unicode wrapper.");
    }
#endif /* } */

    return ret;
}



//+------------------------------------------------------------------------
//
//  Implementation of the wrapped functions
//
//-------------------------------------------------------------------------

#if USE_UNICODE_WRAPPERS==1 /* { */

#if DBG==1 /* { */
BOOL WINAPI
ChooseColorWrap(LPCHOOSECOLORW lpcc)
{
    Assert(!lpcc->lpTemplateName);
    return ChooseColorA((LPCHOOSECOLORA) lpcc);
}
#endif /* } */


BOOL WINAPI
ChooseFontWrap(LPCHOOSEFONTW lpcfw)
{
    BOOL            ret;
    CHOOSEFONTA     cfa;
    LOGFONTA        lfa;
    LPLOGFONTW      lplfw;

    Assert(!lpcfw->lpTemplateName);
    Assert(!lpcfw->lpszStyle);

    Assert(sizeof(CHOOSEFONTA) == sizeof(CHOOSEFONTW));
    memcpy(&cfa, lpcfw, sizeof(CHOOSEFONTA));

    memcpy(&lfa, lpcfw->lpLogFont, offsetof(LOGFONTA, lfFaceName));
    MbcsFromUnicode(lfa.lfFaceName, ARRAY_SIZE(lfa.lfFaceName), lpcfw->lpLogFont->lfFaceName);

    cfa.lpLogFont = &lfa;

    ret = ChooseFontA(&cfa);

    if (ret)
    {
        lplfw = lpcfw->lpLogFont;
        memcpy(lpcfw, &cfa, sizeof(CHOOSEFONTW));
        lpcfw->lpLogFont = lplfw;

        memcpy(lpcfw->lpLogFont, &lfa, offsetof(LOGFONTW, lfFaceName));
        UnicodeFromMbcs(lpcfw->lpLogFont->lfFaceName, ARRAY_SIZE(lpcfw->lpLogFont->lfFaceName), (LPCSTR)(lfa.lfFaceName));
    }
    return ret;
}

#if DBG == 1 /* { */
HINSTANCE WINAPI
LoadLibraryWrap(LPCWSTR lpLibFileName)
{
    Assert(0 && "LoadLibrary called - use LoadLibraryEx instead");
    return 0;
}
#endif /* } */
#endif /* } */

// Everything after this is present on all platforms (Unicode or not)

//+---------------------------------------------------------------------------
//      GetLatinCodepage
//----------------------------------------------------------------------------

UINT
GetLatinCodepage()
{
    if (!g_fGotLatinCodepage)
    {
        // When converting Latin-1 characters, we will use g_uLatinCodepage.
        // The first choice is to use Windows-1252 (Windows Latin-1).  That
        // should be present in all systems, unless deliberately removed.  If
        // that fails, we go for our second choice, which is MS-DOS Latin-1.
        // If that fails, we'll just go with CP_ACP. (cthrash)

        if ( !IsValidCodePage( g_uLatinCodepage = 1252 ) &&
             !IsValidCodePage( g_uLatinCodepage = 850 ) )
        {
                g_uLatinCodepage = CP_ACP;
        }

        g_fGotLatinCodepage = TRUE;
    }

    return(g_uLatinCodepage);
}


// NOTE: these definitions come from shlwapip.h.  The right way to use them
// is to #include <shlwapi.h> with _WIN32_IE set to 0x501 or better, which
// is done by changing WIN32_IE_VERSION in common.inc.  However, doing this
// causes conflicts between shlwapip.h and shellapi.h.  So until the shell
// folks get their story straight, I'm just reproducing the definitions I
// need here. (SamBent)

#if !defined(GMI_TSCLIENT)
//
//  GMI_TSCLIENT tells you whether you are running as a Terminal Server
//  client and should disable your animations.
//
#define GMI_TSCLIENT            0x0003  // Returns nonzero if TS client

STDAPI_(DWORD_PTR) SHGetMachineInfo(UINT gmi);

#endif // !defined(GMI_TSCLIENT)


BOOL IsTerminalServer()
{
    return !!SHGetMachineInfo(GMI_TSCLIENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\ctrl\project.inc ===
# project.inc - project specific settings

CTRL_INC_DIRS=$(SRCROOT)\ctrl\base $(SRCROOT)\ctrl\include $(SRCROOT)\core\include
CTRL_INC_DIRS=$(CTRL_INC_DIRS) $(SRCROOT)\site\include $(SRCROOT)\f3\include $(SDKDIR)
CTRL_INC_DIRS=$(CTRL_INC_DIRS) $(TOOLSINCLUDE) $(TOOLSMISCINCLUDE) $(BLDROOT)\types
CTRL_INC_DIRS=$(CTRL_INC_DIRS) $(SRCROOT)\..\tools\riched\inc $(ROOT)\help
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\winspool.cxx ===
------DEADDEADDEAD------

This file is being removed, it should not be compiled. 
The class involved is no longer referenced.

------DEADDEADDEAD------

//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       winspool.cxx
//
//  Contents:   Wrappers for non-unicode winspool functions
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_WINSPOOL_H_
#define X_WINSPOOL_H_
#include "winspool.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifdef UNIX
DYNLIB g_dynlibWINSPOOL = { NULL, NULL, "MW32.DLL" };
#else
DYNLIB g_dynlibWINSPOOL = { NULL, NULL, "WINSPOOL.DRV" };
#endif 

#define WRAPIT_(type, fn, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibWINSPOOL, #fn };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return FALSE;\
    return ((*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2);\
}
#define WRAPIT(fn, a1, a2) WRAPIT_(BOOL, fn, a1, a2)

#define DOCINFO(x) (Level==1)?((DOC_INFO_1W *)pDocInfo)->x:((DOC_INFO_2W *)pDocInfo)->x
#define DOCINFO2(x) (Level==1)?0:((DOC_INFO_2W *)pDocInfo)->x
#define JOBINFO1W(x) ((JOB_INFO_1W *)pJob)->x
#define JOBINFO1A(x) ((JOB_INFO_1A *)pJobA)->x
#define COPY_JOBINFO1A_MEMBER(x)\
    if (JOBINFO1A(x))\
    {\
        strcpy((LPSTR) strOutString, JOBINFO1A(x));\
        JOBINFO1W(x) = pNextString;\
    }\
    else\
    {\
        JOBINFO1W(x) = NULL;\
    }
#define COPY_JOBINFO1W_MEMBER(x)\
    memcpy(((LPBYTE)pJobA)+cbTaken, x##A, x##A.strlen()+1);\
    JOBINFO1A(x) = ((LPBYTE)pJobA)+cbTaken;\
    cbTaken += x##A.strlen()+1;



WRAPIT(OpenPrinterA,
    (LPSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSA pDefault),
    (pPrinterName, phPrinter, pDefault));

BOOL WINAPI OpenPrinterW(
   LPWSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSW pDefault
)
{
    Assert(!pDefault && "Default parameter not supported in OpenPrinter wrapper.  See src\\core\\wrappers\\winspool.cxx");
    CStrIn strInPrinterName(pPrinterName);

    return OpenPrinterA(strInPrinterName, phPrinter, NULL);
}

WRAPIT(ClosePrinter, (HANDLE hPrinter), (hPrinter));

/* if we ever need a wrapper for SetPrinter (Level 0), uncomment this
WRAPIT(SetPrinterA,
    (HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD Command),
    (hPrinter, Level, pPrinter, Command));

BOOL WINAPI SetPrinterW(
   HANDLE hPrinter,
   DWORD Level,
   LPBYTE pPrinter,
   DWORD Command
)
{
    Assert(!Level && !pPrinter && "Only level 0 supported in SetPrinter wrapper.  See src\\core\\wrappers\\winspool.cxx");

    return SetPrinterA(hPrinter, 0, NULL, Command);
}
*/

WRAPIT_(DWORD, StartDocPrinterA,
    (HANDLE hPrinter, DWORD Level, LPBYTE pDocInfo),
    (hPrinter, Level, pDocInfo));

DWORD
WINAPI
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    if (!pDocInfo || Level < 1 || Level > 2)
    {
        return 0;
    }

    // Need to convert pDocInfo strings
    CStrIn strInDocName( DOCINFO(pDocName) );
    CStrIn strInOutputFile( DOCINFO(pOutputFile) );
    CStrIn strInDatatype( DOCINFO(pDatatype) );
    DOC_INFO_1A DocInfo1A = { strInDocName, strInOutputFile, strInDatatype };
    DOC_INFO_2A DocInfo2A = { strInDocName, strInOutputFile, strInDatatype, DOCINFO2(dwMode), DOCINFO2(JobId) };

    return StartDocPrinterA(hPrinter, Level, (Level==1) ? (LPBYTE)&DocInfo1A : (LPBYTE)&DocInfo2A );
}

WRAPIT(EndDocPrinter, (HANDLE hPrinter), (hPrinter));

WRAPIT(GetJobA,
    (HANDLE hPrinter, DWORD JobId, DWORD Level, LPBYTE pJob, DWORD cbBuf, LPDWORD pcbNeeded),
    (hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded));

BOOL
WINAPI
GetJobW(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
)
{
    // Allocate another buffer whose length matches the buffer passed in in non-unicode (byte) units.
    // That way we hope to simply propagate any buffer size errors in and out.
    DWORD cbBufA = cbBuf/sizeof(TCHAR) - sizeof(JOB_INFO_1W)/sizeof(TCHAR) + sizeof(JOB_INFO_1A);
    LPBYTE pJobA = (BYTE *)MemAlloc(Mt(Mem), cbBufA);
    DWORD cbNeededA;
    BOOL fResult = FALSE;

    Assert(Level == 1 && "GetJob wrapper only supports Level 1 in wrapper.  See src\\core\\wrappers\\winspool.cxx");
    Assert(pJob && pcbNeeded);

    if (!pJobA)
    {
        goto Cleanup;
    }

    fResult = GetJobA(hPrinter, JobId, Level, pJobA, cbBufA, &cbNeededA);

    if (!fResult)
    {
        goto Cleanup;
    }
    else
    {
        DWORD cbTaken = sizeof(JOB_INFO_1W);
        LONG index;

        // Copy the JOBINFO structure.
        memcpy(pJob, pJobA, sizeof(JOB_INFO_1W));

        // Copy and convert all output strings.
        for ( index = 1 ; index <= 6 ; index++ )
        {
            LPWSTR pNextString = (LPWSTR)pJob + cbTaken;
            {
                CStrOut strOutString(pNextString, cbBuf - cbTaken);

                switch (index)
                {
                case 1:
                    COPY_JOBINFO1A_MEMBER(pPrinterName)
                    break;
                case 2:
                    COPY_JOBINFO1A_MEMBER(pMachineName)
                    break;
                case 3:
                    COPY_JOBINFO1A_MEMBER(pUserName)
                    break;
                case 4:
                    COPY_JOBINFO1A_MEMBER(pDocument)
                    break;
                case 5:
                    COPY_JOBINFO1A_MEMBER(pDatatype)
                    break;
                case 6:
                    COPY_JOBINFO1A_MEMBER(pStatus)
                    break;
                }

                cbTaken += strOutString.ConvertIncludingNul();
            }
        }
    }

    // Convert pcbNeeded back to unicode units.
    *pcbNeeded = cbNeededA*sizeof(TCHAR) - sizeof(JOB_INFO_1A)*sizeof(TCHAR) + sizeof(JOB_INFO_1W);

Cleanup:

    if (pJobA)
    {
        MemFree(pJobA);
    }

    return fResult;
}


WRAPIT(SetJobA, (HANDLE hPrinter, DWORD JobId, DWORD Level, LPBYTE Job, DWORD Command), (hPrinter, JobId, Level, Job, Command));

BOOL
WINAPI
SetJobW(
    HANDLE hPrinter,
    DWORD JobId,
    DWORD Level,
    LPBYTE Job,
    DWORD Command)
{
    Assert(Level == 0 && Job == NULL && "SetJob wrapper only supports Level 0 in wrapper.  See src\\core\\wrappers\\winspool.cxx");

    return SetJobA(hPrinter, JobId, 0, NULL, Command);

/* If we ever need SetJob at level 1, we can use this code:
    else if (Level == 1)
    {
        LPBYTE pJob = Job;
        CStrIn pPrinterNameA(JOBINFO1W(pPrinterName));
        CStrIn pMachineNameA(JOBINFO1W(pMachineName));
        CStrIn pUserNameA(JOBINFO1W(pUserName));
        CStrIn pDocumentA(JOBINFO1W(pDocument));
        CStrIn pDatatypeA(JOBINFO1W(pDatatype));
        CStrIn pStatusA(JOBINFO1W(pStatus));
        BYTE   pJobA[sizeof(JOB_INFO_1A) + 6*MAX_PATH];
        DWORD  cbTaken = sizeof(JOB_INFO_1A);
        LONG   index;

        Assert(Job);

        memcpy(pJobA, pJob, sizeof(JOB_INFO_1A));

        // Copy and convert all output strings.
        for ( index = 1 ; index <= 6 ; index++ )
        {
            switch (index)
            {
            case 1:
                COPY_JOBINFO1W_MEMBER(pPrinterName)
                break;
            case 2:
                COPY_JOBINFO1W_MEMBER(pMachineName)
                break;
            case 3:
                COPY_JOBINFO1W_MEMBER(pUserName)
                break;
            case 4:
                COPY_JOBINFO1W_MEMBER(pDocument)
                break;
            case 5:
                COPY_JOBINFO1W_MEMBER(pDatatype)
                break;
            case 6:
                COPY_JOBINFO1W_MEMBER(pStatus)
                break;
            }
        }

        return SetJobA(hPrinter, JobId, 1, pJobA, Command);
    }
    */
}


WRAPIT_(LONG, DocumentPropertiesA,
    (HWND hWnd, HANDLE hPrinter, LPSTR pDeviceName, PDEVMODEA pDevModeOutput, PDEVMODEA pDevModeInput, DWORD fMode),
    (hWnd, hPrinter, pDeviceName, pDevModeOutput, pDevModeInput, fMode));

LONG
WINAPI
DocumentPropertiesW(
    HWND hWnd,
    HANDLE hPrinter,
    LPWSTR pDeviceName,
    PDEVMODEW pDevModeOutput,
    PDEVMODEW pDevModeInput,
    DWORD fMode)
{
    CStrIn strInDeviceName(pDeviceName);

    // IMPORTANT: We are not converting the DEVMODE structure back and forth
    // from ASCII to Unicode on Win95 anymore because we are not touching the
    // two strings or any other member.  Converting the DEVMODE structure can
    // be tricky because of potential and common discrepancies between the
    // value of the dmSize member and sizeof(DEVMODE).  (25155)

    // Since we are not converting the DEVMODE structure back and forth, we can
    // simply forward the call to DocumentPropertiesA.  Note that both pDevModeOutput
    // and pDevModeInput (if not NULL) have to point to DEVMODEA buffers.

    return DocumentPropertiesA(hWnd, hPrinter, strInDeviceName, (PDEVMODEA) pDevModeOutput, (PDEVMODEA) pDevModeInput, fMode);

    // We do this instead of converting as follows (left here in case we ever have to go back):
    /*
    LONG lReturn;

    // Different semantics depending on value of fMode.
    switch (fMode)
    {
    case DM_OUT_BUFFER:
    {
        CStrOut strOutDeviceName(&(pDevModeOutput->dmDeviceName[0]), CCHDEVICENAME);
        CStrOut strOutFormName(&(pDevModeOutput->dmFormName[0]), CCHFORMNAME);
        LONG lSize = DocumentPropertiesA(0, hPrinter, strInDeviceName, NULL, NULL, 0);
        HGLOBAL hDevModeAOutput = (lSize>0)?GlobalAlloc(GHND, lSize):0;
        DEVMODEA *pDevModeAOutput;

        Assert(!pDevModeInput && "pDevModeInput parameter not supported in DocumentProperties wrapper.  See src\\core\\wrappers\\winspool.cxx.");

        if (hDevModeAOutput)
        {
            pDevModeAOutput = (LPDEVMODEA) GlobalLock(hDevModeAOutput);

            if (pDevModeAOutput)
            {
                lReturn = DocumentPropertiesA(hWnd, hPrinter, strInDeviceName, pDevModeAOutput, NULL, fMode);

                // Copy portion between the two strings.
                memcpy(&(pDevModeOutput->dmSpecVersion), &(pDevModeAOutput->dmSpecVersion), ((BYTE *)&(pDevModeAOutput->dmFormName)) - ((BYTE *)&(pDevModeAOutput->dmSpecVersion)));

                // Adjust dmSize member for wide-character strings.
                pDevModeOutput->dmSize = pDevModeAOutput->dmSize + CCHDEVICENAME + CCHFORMNAME;

                // Copy portion following the second string, including the driver specific stuff following the
                // allocation of the DEVMODEA structure.
                memcpy(&(pDevModeOutput->dmLogPixels), &(pDevModeAOutput->dmLogPixels), ((BYTE *)pDevModeAOutput) + sizeof(DEVMODEA) - ((BYTE *)&(pDevModeAOutput->dmLogPixels)) + pDevModeAOutput->dmDriverExtra);

                // Copy the two strings (the cause of this headache).

                strcpy((LPSTR) strOutDeviceName, (const char *) &(pDevModeAOutput->dmDeviceName[0]));
                strOutDeviceName.ConvertIncludingNul();

                strcpy((LPSTR) strOutFormName, (const char *) &(pDevModeAOutput->dmFormName[0]));
                strOutFormName.ConvertIncludingNul();

                GlobalUnlock(hDevModeAOutput);
            }

            GlobalFree(hDevModeAOutput);
        }
    }
        break;

    case 0:
    {
        // Obtain size of DEVMODE structure.
        lReturn = DocumentPropertiesA(hWnd, hPrinter, strInDeviceName, NULL, NULL, 0);

        // Since we don't convert the DEVMODE structure back and forth (see IMPORTANT statement
        // above), the size of the structure doesn't increase, and we don't have to
        // add additional space needed by DEVMODEW:
        // lReturn += (lReturn>0)?(CCHDEVICENAME + CCHFORMNAME):0;
    }
        break;

    default:

        lReturn = -1;

        Assert(!"Given fMode not supported in DocumentProperties wrapper.  See src\\core\\wrappers\\winspool.cxx.");
    }

    return lReturn;
    */
}

WRAPIT(GetPrinterDriverA,
    (HANDLE hPrinter, LPSTR pEnvironment, DWORD Level, LPBYTE pDriverInfo, DWORD cbBuf, LPDWORD pcbNeeded),
    (hPrinter, pEnvironment, Level, pDriverInfo, cbBuf, pcbNeeded));


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\wrappers\wininet.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       wininet.cxx
//
//  Contents:   Dynamic wrappers for InternetCombineUrl
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef DLOAD1

DYNLIB g_dynlibWININET = { NULL, NULL, "WININET.DLL" };

#ifdef _MAC // temporarily redefine macros to warn about missing code.

#define WRAPIT_(type, fn, a1, a2)\
type WINAPI fn a1\
{\
    DEBUGSTR("\pWinInet Missing Implementation");\
    return (type) 0;\
}
#define WRAPIT(fn, a1, a2) WRAPIT_(BOOL, fn, a1, a2)

#define WRAPIT2_(type, fn, fn2, a1, a2)\
type WINAPI fn a1\
{\
    DEBUGSTR("\pWinInet Missing Implementation");\
    return (type) 0;\
}
#define WRAPIT2(fn, fn2, a1, a2) WRAPIT2_(BOOL, fn, fn2, a1, a2)

#else

#define WRAPIT_(type, fn, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibWININET, #fn };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return FALSE;\
    return ((*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2);\
}
#define WRAPIT(fn, a1, a2) WRAPIT_(BOOL, fn, a1, a2)

#define WRAPIT2_(type, fn, fn2, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibWININET, fn2 };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return FALSE;\
    return ((*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2);\
}
#define WRAPIT2(fn, fn2, a1, a2) WRAPIT2_(BOOL, fn, fn2, a1, a2)

#endif // _MAC

WRAPIT(InternetCanonicalizeUrlA,
    (LPCSTR lpszUrl, LPSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags),
    (lpszUrl, lpszBuffer, lpdwBufferLength, dwFlags));

WRAPIT(InternetCanonicalizeUrlW,
    (LPCWSTR lpszUrl, LPWSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags),
    (lpszUrl, lpszBuffer, lpdwBufferLength, dwFlags));

WRAPIT_( DWORD, InternetConfirmZoneCrossingA,
    (HWND hWnd, LPSTR szUrlPrev, LPSTR szUrlNew,BOOL bPost),
    (hWnd, szUrlPrev, szUrlNew, bPost) );

INTERNETAPI_(DWORD)
InternetConfirmZoneCrossingW(
    IN HWND hWnd,
    IN LPWSTR szUrlPrev,
    IN LPWSTR szUrlNew,
    IN BOOL bPost
    )
{
    CStrIn cstrUrlPrev( szUrlPrev );
    CStrIn cstrUrlNew( szUrlNew );

    return( InternetConfirmZoneCrossingA(hWnd,cstrUrlPrev,cstrUrlNew,bPost) );
}



//
// Wrapper for CreateUrlCacheEntry
//-----------------------------------------------------------------------
WRAPIT(CreateUrlCacheEntryA,
       (LPCSTR lpszUrlName, DWORD dwFileSize, LPCSTR lpszExt, LPSTR lpszFileName, DWORD dwRes),
       (lpszUrlName, dwFileSize, lpszExt, lpszFileName, dwRes));
#endif // DLOAD1

BOOL WINAPI CreateUrlCacheEntryBugW( IN  LPCWSTR lpszUrlName,
                                  IN  DWORD dwFileSize,
                                  IN  LPCWSTR lpszExtension,
                                  OUT LPWSTR lpszFileName,
                                  IN  DWORD dwRes)
{
    CStrIn strInUrl(lpszUrlName);
    CStrIn strInExt(lpszExtension);
    CStrOut strOutName(lpszFileName, MAX_PATH);

    return CreateUrlCacheEntryA(strInUrl, dwFileSize, strInExt, strOutName, dwRes);
}


#ifndef DLOAD1
//
//  Wrapper for CommitUrlCacheEntry
//----------------------------------------------------------------------------
WRAPIT(CommitUrlCacheEntryA,
       (LPCSTR lpszUrl, LPCSTR lpszLocalName, FILETIME Expires, FILETIME lastMod,
            DWORD dwType, LPBYTE lpHeaderInfo, DWORD dwHeaderSize, LPCSTR lpszFileExtension, LPCSTR dwRes),
       (lpszUrl, lpszLocalName, Expires, lastMod, dwType, lpHeaderInfo, dwHeaderSize, lpszFileExtension, dwRes));

#endif // DLOAD1

BOOL WINAPI CommitUrlCacheEntryBugW (
                                   IN LPCWSTR   lpszUrlName,
                                   IN LPCWSTR   lpszLocalFileName,
                                   IN FILETIME  ExpireTime,
                                   IN FILETIME  LastModifiedTime,
                                   IN DWORD     dwCachEntryType,
                                   IN LPCBYTE   lpHeaderInfo,
                                   IN DWORD     dwHeaderSize,
                                   IN LPCWSTR   lpszFileExtension,
                                   IN DWORD     dwReserved)
{
    CStrIn strInUrl(lpszUrlName);
    CStrIn strInFile(lpszLocalFileName);
    CStrIn strInExt(lpszFileExtension);

    return CommitUrlCacheEntryA(strInUrl,
                                strInFile,
                                ExpireTime,
                                LastModifiedTime,
                                dwCachEntryType,
                                (LPBYTE) lpHeaderInfo,
                                dwHeaderSize,
                                strInExt,
                                (LPCSTR)(ULongToPtr(dwReserved)));
}

#ifndef DLOAD1

//
// Wrapper for GetUrlCacheEntryInfo
//--------------------------------------------------------------------------
WRAPIT(GetUrlCacheEntryInfoA,
    (LPCSTR lpszUrl, LPINTERNET_CACHE_ENTRY_INFO pcai, LPDWORD pcb),
    (lpszUrl, pcai, pcb));

BOOL WINAPI GetUrlCacheEntryInfoBugW(
    LPCWSTR lpszUrl,
    LPINTERNET_CACHE_ENTRY_INFO pcai,
    LPDWORD pcb)
{
    CStrIn strInUrl(lpszUrl);

    return GetUrlCacheEntryInfoA(strInUrl, pcai, pcb);
}


WRAPIT(GetUrlCacheEntryInfoExA,
    (IN LPCSTR lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
    OUT LPSTR lpszRedirectUrl,
    IN OUT LPDWORD lpdwRedirectUrlBufSize,
    LPVOID lpReserved,
    DWORD dwReserved),
    (lpszUrl, lpCacheEntryInfo,lpdwCacheEntryInfoBufSize,lpszRedirectUrl,lpdwRedirectUrlBufSize,lpReserved,dwReserved));



BOOL WINAPI
GetUrlCacheEntryInfoExBugW(
    IN LPCWSTR lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
    OUT LPSTR lpszRedirectUrl,
    IN OUT LPDWORD lpdwRedirectUrlBufSize,
    LPVOID lpReserved,
    DWORD dwReserved)
{
    CStrIn strInUrl(lpszUrl);

    return GetUrlCacheEntryInfoExA(strInUrl, lpCacheEntryInfo,
                                    lpdwCacheEntryInfoBufSize, lpszRedirectUrl,
                                    lpdwRedirectUrlBufSize, lpReserved,
                                    dwReserved);
}

WRAPIT2(DeleteUrlCacheEntryA, "DeleteUrlCacheEntry",
       (LPCSTR lpszUrlName),
       (lpszUrlName));

#endif // DLOAD1

BOOL WINAPI
DeleteUrlCacheEntryBugW(LPCWSTR lpszUrlName)
{
    CStrIn strInUrl(lpszUrlName);

    return DeleteUrlCacheEntryA(strInUrl);
}


#ifndef DLOAD1

WRAPIT(SetUrlCacheEntryInfoA,
       (LPCSTR lpszUrlName, LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
        DWORD dwFieldControl),
       (lpszUrlName, lpCacheEntryInfo, dwFieldControl));
#endif // DLOAD1

BOOL WINAPI SetUrlCacheEntryInfoBugW(
    LPCWSTR lpszUrlName,
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,
    DWORD dwFieldControl)
{
    CStrIn strInUrl(lpszUrlName);

    // NOTE: does this work? Casting LPINTERNET_CACHE_ENTRY_INFO to LPINTERNET_CACHE_ENTRY_INFOA w/o Unicode conversion
    return SetUrlCacheEntryInfoA(strInUrl, (LPINTERNET_CACHE_ENTRY_INFOA) lpCacheEntryInfo, dwFieldControl);
}

#ifndef DLOAD1

WRAPIT(InternetQueryOptionA,
    (IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength),
    (hInternet, dwOption, lpBuffer, lpdwBufferLength));


WRAPIT(RetrieveUrlCacheEntryFileA,
    (LPCSTR lpszUrl, LPINTERNET_CACHE_ENTRY_INFOA pcai, LPDWORD pcb, DWORD res),
    (lpszUrl, pcai, pcb, res));

#endif // DLOAD1

BOOL WINAPI RetrieveUrlCacheEntryFileBugW(
    LPCWSTR lpszUrl,
    LPINTERNET_CACHE_ENTRY_INFO pcai,
    LPDWORD pcb,
    DWORD res)
{
#ifndef UNIX
    BYTE                        buf[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFO * pInfo = (INTERNET_CACHE_ENTRY_INFO *) buf;
#else
    union
    {
        double alignOn8ByteBoundary;
        BYTE   alignedBuf[MAX_CACHE_ENTRY_INFO_SIZE];
    } buf;
    INTERNET_CACHE_ENTRY_INFO * pInfo = (INTERNET_CACHE_ENTRY_INFO *)&buf;
#endif // UNIX

    DWORD                       cInfo = sizeof(buf);
    CStrIn                      strInUrl(lpszUrl);

    // NOTE: does this work? Casting LPINTERNET_CACHE_ENTRY_INFO to LPINTERNET_CACHE_ENTRY_INFOA w/o Unicode conversion
    if (!RetrieveUrlCacheEntryFileA(strInUrl, (LPINTERNET_CACHE_ENTRY_INFOA) pInfo, &cInfo, res))
    {
        // NOTE: (rodc) This test is here because sometimes an error is
        // reported even if the local file can be returned. In this case
        // ERROR_INVALID_DATA is the last error. Since all we want is the
        // file name pretend all is well.
        if (GetLastError() != ERROR_INVALID_DATA)
            return FALSE;
    }

    cInfo = (*pcb - sizeof(INTERNET_CACHE_ENTRY_INFO))/sizeof(WCHAR);
    pcai->lpszLocalFileName = (TCHAR *) (((BYTE *) pcai) + sizeof(INTERNET_CACHE_ENTRY_INFO));
    MultiByteToWideChar(
            CP_ACP,
            0,
            (char *) pInfo->lpszLocalFileName,
            -1,
            pcai->lpszLocalFileName,
            cInfo);
    pcai->LastModifiedTime.dwHighDateTime = pInfo->LastModifiedTime.dwHighDateTime;
    pcai->LastModifiedTime.dwLowDateTime = pInfo->LastModifiedTime.dwLowDateTime;
    pcai->ExpireTime.dwHighDateTime = pInfo->LastModifiedTime.dwHighDateTime;
    pcai->ExpireTime.dwLowDateTime = pInfo->LastModifiedTime.dwLowDateTime;

    return TRUE;
}

#ifndef DLOAD1

WRAPIT(InternetCrackUrlA,
    (LPCSTR lpszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTS lpUrlComponents),
    (lpszUrl, dwUrlLength, dwFlags, lpUrlComponents));

#ifndef WINCE
BOOL WINAPI InternetCrackUrlW(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS puc
    )
{
    CStrIn  strInUrl(lpszUrl);
    CStrOut strOutScheme    (puc->lpszScheme,   puc->dwSchemeLength);
    CStrOut strOutHostName  (puc->lpszHostName, puc->dwHostNameLength);
    CStrOut strOutUserName  (puc->lpszUserName, puc->dwUserNameLength);
    CStrOut strOutPassword  (puc->lpszPassword, puc->dwPasswordLength);
    CStrOut strOutUrlPath   (puc->lpszUrlPath,  puc->dwUrlPathLength);
    CStrOut strOutExtraInfo (puc->lpszExtraInfo,puc->dwExtraInfoLength);
    BOOL    fRet;

 #ifdef _MAC
    URL_COMPONENTSA ucA;

    Assert(puc->dwStructSize==sizeof(URL_COMPONENTS));

    memmove(&ucA, puc, sizeof(ucA));

    ucA.lpszScheme       = ((LPSTR)strOutScheme);
    ucA.lpszHostName     = ((LPSTR)strOutHostName);
    ucA.lpszUserName     = ((LPSTR)strOutUserName);
    ucA.lpszPassword     = ((LPSTR)strOutPassword);
    ucA.lpszUrlPath      = ((LPSTR)strOutUrlPath);
    ucA.lpszExtraInfo    = ((LPSTR)strOutExtraInfo);

    fRet = InternetCrackUrlA((char*)strInUrl, dwUrlLength, dwFlags, &ucA);

#else

   URL_COMPONENTS ucA;

    Assert(puc->dwStructSize==sizeof(URL_COMPONENTS));

    memmove(&ucA, puc, sizeof(ucA));

    ucA.lpszScheme       = (LPTSTR)((LPSTR)strOutScheme);
    ucA.lpszHostName     = (LPTSTR)((LPSTR)strOutHostName);
    ucA.lpszUserName     = (LPTSTR)((LPSTR)strOutUserName);
    ucA.lpszPassword     = (LPTSTR)((LPSTR)strOutPassword);
    ucA.lpszUrlPath      = (LPTSTR)((LPSTR)strOutUrlPath);
    ucA.lpszExtraInfo    = (LPTSTR)((LPSTR)strOutExtraInfo);

    fRet = InternetCrackUrlA(strInUrl, dwUrlLength, dwFlags, &ucA);

#endif // _MAC

    if (fRet)
    {
        puc->dwStructSize       = ucA.dwStructSize;
        puc->dwSchemeLength     = strOutScheme.ConvertExcludingNul();
        puc->nScheme            = ucA.nScheme;
        puc->dwHostNameLength   = strOutHostName.ConvertExcludingNul();
        puc->nPort              = ucA.nPort;
        puc->dwUserNameLength   = strOutUserName.ConvertExcludingNul();
        puc->dwPasswordLength   = strOutPassword.ConvertExcludingNul();
        puc->dwUrlPathLength    = strOutUrlPath.ConvertExcludingNul();
        puc->dwExtraInfoLength  = strOutExtraInfo.ConvertExcludingNul();
    }
    else
    {
        puc->dwStructSize       = ucA.dwStructSize;
        puc->dwSchemeLength     = ucA.dwSchemeLength;
        puc->nScheme            = ucA.nScheme;
        puc->dwHostNameLength   = ucA.dwHostNameLength;
        puc->nPort              = ucA.nPort;
        puc->dwUserNameLength   = ucA.dwUserNameLength;
        puc->dwPasswordLength   = ucA.dwPasswordLength;
        puc->dwUrlPathLength    = ucA.dwUrlPathLength;
        puc->dwExtraInfoLength  = ucA.dwExtraInfoLength;
    }

    return fRet;
}
#else //WINCE
WRAPIT(InternetCrackUrlW,
    (LPCWSTR lpszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTS lpUrlComponents),
    (lpszUrl, dwUrlLength, dwFlags, lpUrlComponents));
#endif //WINCE

WRAPIT(InternetCreateUrlA,
    (LPURL_COMPONENTS lpUrlComponents, DWORD dwFlags, LPSTR lpszUrl, LPDWORD lpdwUrlLength),
    (lpUrlComponents, dwFlags, lpszUrl, lpdwUrlLength));

BOOL WINAPI InternetCreateUrlW(
    IN LPURL_COMPONENTS puc,
    IN DWORD dwFlags,
    OUT LPWSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    )
{
    CStrOut  strOutUrl(lpszUrl, *lpdwUrlLength);

    CStrIn strInScheme    (puc->lpszScheme,   puc->dwSchemeLength);
    CStrIn strInHostName  (puc->lpszHostName, puc->dwHostNameLength);
    CStrIn strInUserName  (puc->lpszUserName, puc->dwUserNameLength);
    CStrIn strInPassword  (puc->lpszPassword, puc->dwPasswordLength);
    CStrIn strInUrlPath   (puc->lpszUrlPath,  puc->dwUrlPathLength);
    CStrIn strInExtraInfo (puc->lpszExtraInfo,puc->dwExtraInfoLength);
    BOOL    fRet;

    URL_COMPONENTS ucA;

    Assert(puc->dwStructSize==sizeof(URL_COMPONENTS));

    // Only the pointer members need to be changed, so copy all the
    // data and then set the pointer members to their correct values.
    memmove(&ucA, puc, sizeof(ucA));

    ucA.lpszScheme       = (LPTSTR)((LPSTR)strInScheme);
    ucA.lpszHostName     = (LPTSTR)((LPSTR)strInHostName);
    ucA.lpszUserName     = (LPTSTR)((LPSTR)strInUserName);
    ucA.lpszPassword     = (LPTSTR)((LPSTR)strInPassword);
    ucA.lpszUrlPath      = (LPTSTR)((LPSTR)strInUrlPath);
    ucA.lpszExtraInfo    = (LPTSTR)((LPSTR)strInExtraInfo);

    fRet = InternetCreateUrlA(&ucA, dwFlags, strOutUrl, lpdwUrlLength);

    if (fRet)
    {
        *lpdwUrlLength = strOutUrl.ConvertExcludingNul();
    }
    return fRet;
}

WRAPIT(InternetGetCertByURL,
        (LPCTSTR lpszURL, LPTSTR lpszCertText, DWORD dwcbCertText),
        (lpszURL, lpszCertText, dwcbCertText));

WRAPIT(InternetShowSecurityInfoByURL,
       (LPTSTR lpszURL, HWND hwndParent),
       (lpszURL, hwndParent));

WRAPIT(InternetAlgIdToStringA,
        (ALG_ID algID, LPSTR lpsz, LPDWORD lpdw, DWORD dwReserved),
        (algID, lpsz, lpdw, dwReserved));

WRAPIT(InternetAlgIdToStringW,
        (ALG_ID algID, LPWSTR lpwz, LPDWORD lpdw, DWORD dwReserved),
        (algID, lpwz, lpdw, dwReserved));

WRAPIT(InternetSecurityProtocolToStringA,
        (DWORD dwProtocol, LPSTR lpsz, LPDWORD lpdw, DWORD dwReserved),
        (dwProtocol, lpsz, lpdw, dwReserved));

WRAPIT(InternetSecurityProtocolToStringW,
        (DWORD dwProtocol, LPWSTR lpwz, LPDWORD lpdw, DWORD dwReserved),
        (dwProtocol, lpwz, lpdw, dwReserved));

WRAPIT_(HANDLE, FindFirstUrlCacheEntryA,
    (LPCSTR lpszUrlSearchPattern, LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo, LPDWORD lpdwFirstCacheEntryInfoBufferSize),
    (lpszUrlSearchPattern, lpFirstCacheEntryInfo, lpdwFirstCacheEntryInfoBufferSize));
WRAPIT(FindNextUrlCacheEntryA,
    (HANDLE hEnumHandle, LPINTERNET_CACHE_ENTRY_INFOA lpNextCacheEntryInfo, LPDWORD lpdwNextCacheEntryInfoBufferSize),
    (hEnumHandle, lpNextCacheEntryInfo, lpdwNextCacheEntryInfoBufferSize));
WRAPIT(DeleteUrlCacheEntry,
    (LPCSTR lpszUrlName),
    (lpszUrlName));
WRAPIT(FindCloseUrlCache,
    (HANDLE hEnumHandle),
    (hEnumHandle));

WRAPIT_(DWORD, InternetErrorDlg,
     (HWND hWnd, HINTERNET hRequest, DWORD dwError, DWORD dwFlags, LPVOID * lppvData),
     (hWnd, hRequest, dwError, dwFlags, lppvData));

#endif // DLOAD1

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Misc
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL
IsURLSchemeCacheable(UINT uScheme)
{
    switch(uScheme)
    {
    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
    case URL_SCHEME_GOPHER:
    case URL_SCHEME_FTP:
        return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsSecureUrl
//
//  Synopsis:   Returns TRUE for https, FALSE for anything else
//
//              Starting with an IE 4.01 QFE in 1/98, IsUrlSecure returns TRUE
//              for javascript:, vbscript:, and about: if the source
//              document in the wrapped URL is secure.
//
//----------------------------------------------------------------------------
BOOL
IsUrlSecure(const TCHAR *pchUrl)
{
    BOOL fSecure;
    ULONG cb;

    if (!pchUrl)
        return FALSE;

    switch(GetUrlScheme(pchUrl))
    {
    case URL_SCHEME_HTTPS:
        return TRUE;

    case URL_SCHEME_HTTP:
    case URL_SCHEME_FILE:
    case URL_SCHEME_RES:
    case URL_SCHEME_FTP:
        return FALSE;

    default:
        if (!CoInternetQueryInfo(pchUrl, QUERY_IS_SECURE, 0, &fSecure, sizeof(fSecure), &cb, 0) && cb == sizeof(fSecure))
            return fSecure;
        return FALSE;
    }
}

UINT
GetUrlScheme(const TCHAR * pchUrlIn)
{
    PARSEDURL      puw = {0};

    if (!pchUrlIn)
        return (UINT)URL_SCHEME_INVALID;

    puw.cbSize = sizeof(PARSEDURL);

    return (SUCCEEDED(ParseURL(pchUrlIn, &puw))) ?
                puw.nScheme : URL_SCHEME_INVALID;
}


INTERNET_PORT
GetDefaultPort(SHINTERNET_SCHEME nScheme)
{
    switch (nScheme)
    {
    case SHINTERNET_SCHEME_FTP:
        return INTERNET_DEFAULT_FTP_PORT;
    case SHINTERNET_SCHEME_GOPHER:
        return INTERNET_DEFAULT_GOPHER_PORT;
    case SHINTERNET_SCHEME_HTTP:
        return INTERNET_DEFAULT_HTTP_PORT;
    case SHINTERNET_SCHEME_HTTPS:
        return INTERNET_DEFAULT_HTTPS_PORT;
    case SHINTERNET_SCHEME_SOCKS:
        return INTERNET_DEFAULT_SOCKS_PORT;
    default:
        return INTERNET_INVALID_PORT_NUMBER;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlComponentHelper
//
//  Synopsis:   Cracks the Url and returns the specified component.
//
//              The parameter fUseOmLocationFormat is used to decide whether
//              to preserve Nav/IE5 compat in returning a component of
//              window.location. This parameter is not set when returning
//              a component of the href of an A or an AREA.
//
//              Setting fUseOmLocationFormat has the following effect:
//              1. The leading '\' is preserved in the 'pathname'.
//              2. The default port is suppressed in 'host' and 'port'.
//
//----------------------------------------------------------------------------
HRESULT
GetUrlComponentHelper(const TCHAR * pchUrlIn,
                      CStr *        pstrComp,
                      DWORD         dwFlags,
                      URLCOMP_ID    ucid,
                      BOOL          fUseOmLocationFormat)
{
    HRESULT          hr = E_INVALIDARG;
    SHURL_COMPONENTS uc;
    TCHAR            achUrl[pdlUrlLen];
    TCHAR            achComp[pdlUrlLen];
    DWORD            dw, dwLength = ARRAY_SIZE(achUrl);
    TCHAR            chTarget, chDelimit;

    if (!pstrComp || !pchUrlIn)
        goto Cleanup;

    if (!InternetCanonicalizeUrl(pchUrlIn, achUrl, &dwLength, dwFlags))
        goto Cleanup;

    hr = S_OK;

    // Clear everything and set only those fields that we are interested in
    memset(&uc, 0, sizeof(uc));
    uc.dwStructSize = sizeof(SHURL_COMPONENTS);
    switch(ucid)
    {
    case URLCOMP_HOST:
    case URLCOMP_HOSTNAME:
    case URLCOMP_PORT:
        uc.lpszHostName = achComp;
        uc.dwHostNameLength = ARRAY_SIZE(achComp);
        break;
    case URLCOMP_PATHNAME:
        uc.lpszUrlPath = achComp;
        uc.dwUrlPathLength = ARRAY_SIZE(achComp);
        break;
    case URLCOMP_PROTOCOL:
        uc.lpszScheme = achComp;
        uc.dwSchemeLength = ARRAY_SIZE(achComp);
        break;
    case URLCOMP_HASH:
    case URLCOMP_SEARCH:
        uc.lpszExtraInfo = achComp;
        uc.dwExtraInfoLength = ARRAY_SIZE(achComp);
        break;
    }

    if (!UrlCrackW(achUrl, 0, 0, &uc))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    switch(ucid)
    {
    case URLCOMP_HOST:
        hr = THR(pstrComp->Set(uc.lpszHostName));
        if (hr)
            goto Cleanup;

		// Add the port number if there is a "host" (e.g. there is no host for "file:\\server\share")
		// and - for OM Location compatibility reasons - it is NOT the default port
        if (uc.dwHostNameLength && !(fUseOmLocationFormat && uc.nPort == GetDefaultPort(uc.nScheme)))
        {
            hr = THR(pstrComp->Append(_T(":")));
            if (hr)
                goto Cleanup;
            _itot(uc.nPort, achComp, 10);
            hr = THR(pstrComp->Append(achComp));
        }
        break;
    case URLCOMP_HOSTNAME:
        hr = THR(pstrComp->Set(uc.lpszHostName));
        break;
    case URLCOMP_PATHNAME:
        // get rid of the leading '/' if any
        if (!fUseOmLocationFormat && _T('/') == uc.lpszUrlPath[0])
        {
            uc.lpszUrlPath++;
            uc.dwUrlPathLength--;
        }

        // Hack for  for "file://" location -- prepend a '/' (#100998)
        else if (       fUseOmLocationFormat
                 &&     INTERNET_SCHEME_FILE == uc.nScheme
                 &&     _T('/') != uc.lpszUrlPath[0]
                )
        {
            for (dw = uc.dwUrlPathLength+1; dw > 0; dw--)
            {
                uc.lpszUrlPath[dw] = uc.lpszUrlPath[dw-1];
            }
            uc.lpszUrlPath[0] = _T('/');
            uc.dwUrlPathLength++;
        }
        else if ( fUseOmLocationFormat
                  && SHINTERNET_SCHEME_UNKNOWN == uc.nScheme )
        {
            //
            // Bug # 15575. Match shdocvw 5.01 behavior.
            // Calling pathname on about:blank - returned /blank
            //
            UINT ulScheme = GetUrlScheme(pchUrlIn);

            //
            // 5.01 always added a / for about: protocol
            //
            // there are other differences as well
            // ( we're throwing extra escape characters
            // for example about:<body>foo</body> in 5.5
            // is %3Cbody%3E etc. (endcoded)
            // in 5.01 is <body>
            //
            // however - only think about:blank is interesting.
            //
            if ( ulScheme == URL_SCHEME_ABOUT)
            {
                for (dw = uc.dwUrlPathLength+1; dw > 0; dw--)
                {
                    uc.lpszUrlPath[dw] = uc.lpszUrlPath[dw-1];
                }
                uc.lpszUrlPath[0] = _T('/');
                uc.dwUrlPathLength++;
            }
        }
        // ignore the 'search' portion starting from the first
        // '?' or '#'
        for (dw = 0; dw < uc.dwUrlPathLength; dw++)
        {
            if (_T('?') == uc.lpszUrlPath[dw] ||
                _T('#') == uc.lpszUrlPath[dw])
            {
                uc.dwUrlPathLength = dw;
                break;
            }
        }
        hr = THR(pstrComp->Set(uc.lpszUrlPath, uc.dwUrlPathLength));
        break;
    case URLCOMP_PORT:
		// Add the port number if there is a "host" (e.g. there is no host for "file:\\server\share")
		// and - for OM Location compatibility reasons - it is NOT the default port
        if (uc.dwHostNameLength && !(fUseOmLocationFormat && uc.nPort == GetDefaultPort(uc.nScheme)))
        {
            _itot(uc.nPort, achComp, 10);
            hr = THR(pstrComp->Set(achComp));
        }
        else
        {
            hr = THR(pstrComp->Set(g_Zero.ach));
        }
        break;
    case URLCOMP_PROTOCOL:
        hr = THR(pstrComp->Set(uc.lpszScheme));
        if (hr)
            goto Cleanup;
        hr = THR(pstrComp->Append(_T(":")));
        break;

    case URLCOMP_HASH:
        chTarget = _T('#');
        chDelimit = _T('?');
        goto ExtractExtraInfo;
        break;

    case URLCOMP_SEARCH:
        chTarget = _T('?');
        chDelimit = _T('#');
ExtractExtraInfo:
        // extra info returns both hash/search in the same slot. Find the part
        // that has ?abc
        {
            TCHAR * pchSearch = _tcschr(uc.lpszExtraInfo, chTarget);
            if (pchSearch)
            {
                TCHAR * pchHashPart = NULL;
                DWORD   cch = uc.dwExtraInfoLength;

                // for the location object oriented calls, we mimic the shdocvw behavior in
                // 5.01 and return the '?' character even if it is not followed by a search string
                if (cch==1 && !fUseOmLocationFormat)
                {
                    cch--;
                    pchSearch++;
                }

                pchHashPart = _tcschr(pchSearch, chDelimit);

                cch = (pchHashPart) ? pchHashPart - pchSearch : _tcslen(pchSearch);

                hr = THR(pstrComp->Set(pchSearch, cch));
            }
        }
        break;

    }

Cleanup:
    RRETURN(hr);
}


HRESULT
SetUrlComponentHelper(const TCHAR * pchUrlIn,
                      TCHAR       * pchUrlOut,
                      DWORD         dwBufLen,
                      const BSTR  * pstrOriginal,
                      URLCOMP_ID    ucid)
{
    HRESULT          hr = E_INVALIDARG;
    SHURL_COMPONENTS uc;
    TCHAR            achHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR            achScheme[INTERNET_MAX_SCHEME_LENGTH];
    TCHAR            achUrlPath[INTERNET_MAX_PATH_LENGTH];
    TCHAR            achExtraInfo[INTERNET_MAX_PATH_LENGTH];
    TCHAR            achUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR            achPassword[INTERNET_MAX_PASSWORD_LENGTH];
    DWORD            dwLength = dwBufLen;
    TCHAR *          pchPort = NULL;
    BOOL             fPrefixExists;
    TCHAR *          pstrComp = NULL;
    int              iCompLen;


    if (!pstrOriginal || dwLength < pdlUrlLen)
        goto Cleanup;
    if (!pchUrlIn || _tcslen(pchUrlIn) >= dwLength)
        goto Cleanup;
    if (!InternetCanonicalizeUrl(pchUrlIn, pchUrlOut, &dwLength, 0))
        goto Cleanup;

    hr = S_OK;

    uc.dwStructSize = sizeof(SHURL_COMPONENTS);
    uc.lpszScheme = achScheme;
    uc.dwSchemeLength = ARRAY_SIZE(achScheme);
    uc.lpszHostName = achHostName;
    uc.dwHostNameLength = ARRAY_SIZE(achHostName);
    uc.lpszUserName = achUserName;
    uc.dwUserNameLength = ARRAY_SIZE(achUserName);
    uc.lpszPassword = achPassword;
    uc.dwPasswordLength = ARRAY_SIZE(achPassword);
    uc.lpszUrlPath = achUrlPath;
    uc.dwUrlPathLength = ARRAY_SIZE(achUrlPath);
    uc.lpszExtraInfo = achExtraInfo;
    uc.dwExtraInfoLength = ARRAY_SIZE(achExtraInfo);
    uc.nPort = 0;

    if (!_tcslen(pchUrlOut))
    {
        // there is no current url, so set all fields to 0, we will
        // only set the one ...
        uc.dwSchemeLength = 0;
        uc.dwHostNameLength = 0;
        uc.dwUserNameLength = 0;
        uc.dwPasswordLength = 0;
        uc.dwUrlPathLength = 0;
        uc.dwExtraInfoLength = 0;
    }
    else if (!UrlCrackW(pchUrlOut, 0, 0, &uc))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    iCompLen = SysStringLen(*pstrOriginal);
    pstrComp = *pstrOriginal;

    // pull off leading and trailing /'s for NS compatibility
    while (iCompLen && (*pstrComp == _T('/') || *pstrComp == _T('\\')))
    {
        pstrComp++;
        iCompLen--;
    }

    while (iCompLen && (*(pstrComp+iCompLen-1) == _T('/') ||
                        *(pstrComp+iCompLen-1) ==_T('\\')))
    {
        iCompLen--;
    }

    switch(ucid)
    {
    case URLCOMP_HOST:
        // set port first
        pchPort = _tcsrchr(pstrComp, _T(':'));
        if (pchPort)
            uc.nPort = (USHORT)StrToInt(pchPort+1);
        // fall through
    case URLCOMP_HOSTNAME:
        uc.dwHostNameLength = min( (LONG)((pchPort) ? pchPort - pstrComp : (UINT)iCompLen),
                                   (LONG)(ARRAY_SIZE(achHostName) -1));
        _tcsncpy(uc.lpszHostName, pstrComp, uc.dwHostNameLength);
        break;

    case URLCOMP_PATHNAME:
        uc.dwUrlPathLength = min( (UINT)iCompLen,
                                  (UINT) ARRAY_SIZE(achUrlPath)-1 );
        _tcsncpy(uc.lpszUrlPath, pstrComp, uc.dwUrlPathLength);
        break;
    case URLCOMP_PORT:
        uc.nPort = (USHORT)StrToInt(pstrComp);
        break;
    case URLCOMP_PROTOCOL:
        uc.dwSchemeLength = min( (UINT)iCompLen,
                                 (UINT) ARRAY_SIZE(achScheme));
        _tcsncpy(uc.lpszScheme, pstrComp, uc.dwSchemeLength);

        // Remove trailing ':' if any.
        if (uc.dwSchemeLength > 0 &&
            _T(':') == uc.lpszScheme[uc.dwSchemeLength - 1])
        {
             uc.lpszScheme[--uc.dwSchemeLength] = 0;
        }
        break;
    case URLCOMP_SEARCH:
        // Must prefix this with '?'
        fPrefixExists = (uc.dwExtraInfoLength > 0);
        uc.dwExtraInfoLength = iCompLen + 1;
        if (uc.dwExtraInfoLength >= ARRAY_SIZE(achExtraInfo))
            goto Cleanup;
        uc.lpszExtraInfo[0] = _T('?');
         _tcsncpy(uc.lpszExtraInfo + 1, pstrComp, iCompLen);
        break;
    case URLCOMP_HASH:
        // Must prefix this with '#'
        fPrefixExists = (uc.dwExtraInfoLength > 0);
        uc.dwExtraInfoLength = iCompLen + 1;
        if (uc.dwExtraInfoLength >= ARRAY_SIZE(achExtraInfo))
            goto Cleanup;
        uc.lpszExtraInfo[0] = _T('#');
         _tcsncpy(uc.lpszExtraInfo + 1, pstrComp, iCompLen);
        break;
    }

    dwLength = dwBufLen;
    hr = THR(ComposeUrl(&uc, 0, pchUrlOut, & dwLength));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------
//
//  method  :   ComposeUrl()
//
//  Synopsis : The core of this was stolen from ie, and modified to be
//      more general and robust.  it creates a single url string from
//      the componenet pieces.
//
//----------------------------------------------------------------

HRESULT
ComposeUrl(SHURL_COMPONENTS * puc,
           DWORD              dwFlags,
           TCHAR            * pchUrlOut,
           DWORD            * pdwSize)
{
	HRESULT   hr = S_OK;
    ULONG     lRequiredSize;
    TCHAR     achSchemeSep[]  = _T("://");
    TCHAR     achPort[18];
    TCHAR   * pchCopyHere = NULL;
    const int iSchemeSepLen = _tcslen(achSchemeSep);
    int       nPortLength;
    int       iTch =  sizeof(TCHAR);

    // set up for the port component
    _itot(puc->nPort, achPort, 10);
    nPortLength = _tcslen(achPort);

    // is there enough space in the buffer?
    lRequiredSize = puc->dwSchemeLength    +     // http
                   iSchemeSepLen          +     // ://
                   puc->dwHostNameLength  +     // www.myserver.org
                   nPortLength  + 1       +     // :##
                   puc->dwUserNameLength  +
                   ((puc->dwUserNameLength != 0) ? 1 : 0) +  // +1 for '@'
                   puc->dwPasswordLength  +
                   ((puc->dwPasswordLength != 0) ? 1 : 0) +  // +1 for ':'
                   1                      +     // /
                   puc->dwUrlPathLength   +     // the rest
                   1                      +     // '#' or '?'
                   puc->dwExtraInfoLength +     // search string, hash-name
                   1;                           // +1 for '\0'

    if (lRequiredSize > *pdwSize)
    {
        hr = STG_E_INSUFFICIENTMEMORY;
        goto Cleanup;
    }

    // start building the string...
    pchCopyHere = pchUrlOut;

    if (puc->dwSchemeLength)
    {
	    _tcsncpy(pchCopyHere, puc->lpszScheme, puc->dwSchemeLength);
        pchCopyHere += puc->dwSchemeLength;

        _tcsncpy(pchCopyHere, achSchemeSep, iSchemeSepLen);
        pchCopyHere += iSchemeSepLen;
    }

    if (puc->dwUserNameLength)
    {
        _tcsncpy(pchCopyHere, puc->lpszUserName, puc->dwUserNameLength);
        pchCopyHere += puc->dwUserNameLength;

        if (puc->dwPasswordLength)
        {
            _tcsncpy(pchCopyHere, _T(":"), iTch);
            pchCopyHere ++;

            _tcsncpy(pchCopyHere, puc->lpszPassword, puc->dwPasswordLength);
            pchCopyHere += puc->dwPasswordLength;
        }
        _tcsncpy(pchCopyHere, _T("@"), iTch);
        pchCopyHere ++;
    }

	if (puc->dwHostNameLength)
	{
		_tcsncpy(pchCopyHere, puc->lpszHostName, puc->dwHostNameLength);
		pchCopyHere += puc->dwHostNameLength;

		if (nPortLength)
		{
			_tcsncpy(pchCopyHere, _T(":"), iTch);
			pchCopyHere ++;

			_tcsncpy(pchCopyHere, achPort, nPortLength);
			pchCopyHere += nPortLength;
		}
	}

    if (puc->dwUrlPathLength)
    {
        if (puc->dwHostNameLength && *puc->lpszUrlPath != _T('/'))
        {
            _tcsncpy(pchCopyHere, _T("/"), iTch);
            pchCopyHere ++;
        }

        _tcsncpy(pchCopyHere, puc->lpszUrlPath, puc->dwUrlPathLength);
        pchCopyHere += puc->dwUrlPathLength;
    }

    if (puc->dwExtraInfoLength)
    {
        _tcsncpy(pchCopyHere, puc->lpszExtraInfo, puc->dwExtraInfoLength);
        pchCopyHere += puc->dwExtraInfoLength;
    }

    *pchCopyHere= _T('\0');

Cleanup:
    RRETURN(hr);
}

#ifndef DLOAD1


WRAPIT(InternetGetCookie,
       (LPCTSTR lpszUrl, LPCTSTR lpszCookieName, LPTSTR lpCookieData, LPDWORD lpdwSize),
       (lpszUrl, lpszCookieName, lpCookieData, lpdwSize));

WRAPIT(InternetGetCookieEx,
       (LPCTSTR lpszUrl, LPCTSTR lpszCookieName, LPTSTR lpszCookieData, LPDWORD lpdwSize, DWORD dwFlags, LPVOID dwReserved),
       (lpszUrl, lpszCookieName, lpszCookieData, lpdwSize, dwFlags, dwReserved));

WRAPIT(InternetSetCookie,
       (LPCTSTR lpszUrl, LPCTSTR lpszCookieName, LPCTSTR lpszCookieData),
       (lpszUrl, lpszCookieName, lpszCookieData));

WRAPIT_(DWORD,InternetSetCookieExW,
       (LPCTSTR lpszUrl, LPCTSTR lpszCookieName, LPCTSTR lpszCookieData, DWORD dwFlags, DWORD_PTR dwReserved),
       (lpszUrl, lpszCookieName, lpszCookieData, dwFlags, dwReserved));

WRAPIT_(DWORD,InternetSetCookieExA,
       (LPCTSTR lpszUrl, LPCTSTR lpszCookieName, LPCTSTR lpszCookieData, DWORD dwFlags, DWORD_PTR dwReserved),
       (lpszUrl, lpszCookieName, lpszCookieData, dwFlags, dwReserved));

//+-----------------------------------------------------------------------
//
// GetDateFormat() and GetTimeFormat() only have unicode version on NT
//
//-----------------------------------------------------------------------

WRAPIT(GetDateFormatA,
       (LCID locale, DWORD dwFlags, CONST SYSTEMTIME * lpDate, LPCTSTR lpFormat,
            LPTSTR lpDateStr, int cchDate),
       (locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate));

int WINAPI GetDateFormat_BugW( IN LCID Locale,
                               IN DWORD dwFlags,
                               IN CONST SYSTEMTIME * lpDate,
                               IN LPCTSTR lpFormat,
                               OUT LPTSTR lpDateStr,
                               IN int cchDate)
{
#ifndef WINCE
    int    iValue;
    CStrIn strInFormat(lpFormat);
    CStrOut strOutDateStr(lpDateStr, cchDate);

    iValue = GetDateFormatA(Locale, dwFlags, lpDate, strInFormat, strOutDateStr, cchDate);

    if (iValue)
    {
        iValue = strOutDateStr.ConvertIncludingNul();
    }

    return iValue;
#else //WINCE
	return GetDateFormat(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);
#endif //WINCE
}

WRAPIT(GetTimeFormatA,
       (LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpTime, LPCTSTR lpFormat,
            LPTSTR lpTimeStr, int cchTime),
       (Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime));

int WINAPI GetTimeFormat_BugW( IN LCID Locale,
                               IN DWORD dwFlags,
                               IN CONST SYSTEMTIME * lpTime,
                               IN LPCTSTR lpFormat,
                               OUT LPTSTR lpTimeStr,
                               IN int cchTime)
{
#ifndef WINCE
    int   iValue;
    CStrIn strInFormat(lpFormat);
    CStrOut strOutTimeStr(lpTimeStr, cchTime);

    iValue = GetTimeFormatA(Locale, dwFlags, lpTime, strInFormat, strOutTimeStr, cchTime);

    if (iValue)
    {
        iValue = strOutTimeStr.ConvertIncludingNul();
    }
    return iValue;
#else //WINCE
    return GetTimeFormat(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
#endif //WINCE
}

#endif // DLOAD1

//+---------------------------------------------------------------------------
//
//  method : ConvertDateTimeToString
//
//  Synopsis:
//          Converts given date and time if requested to string using the local time
//          in a fixed format mm/dd/yyyy or mm/dd/yyy hh:mm:ss
//
//----------------------------------------------------------------------------

// NB (cthrash) This function produces a standard(?) format date, of the form
// MM/DD/YY HH:MM:SS (in military time.) The date format *will not* be tailored
// for the locale.  This is for Netscape compatibility, and is a departure from
// how IE3 worked.  If you want the date in the format of the document's locale,
// you should use the Java Date object.

HRESULT
ConvertDateTimeToString(FILETIME Time, BSTR * pBstr, BOOL fReturnTime)
{
    HRESULT    hr;
    SYSTEMTIME SystemTime;
    TCHAR pchDateStr[DATE_STR_LENGTH];
    FILETIME     ft;

    Assert(pBstr);

    // We want to return local time as Nav not GMT
    if (!FileTimeToLocalFileTime(&Time, &ft))
    {
        hr  = GetLastWin32Error();
        goto Cleanup;
    }

    if (!FileTimeToSystemTime( &ft, &SystemTime ))
    {
        hr  = GetLastWin32Error();
        goto Cleanup;
    }

    // We want Gregorian dates and 24-hour time.
    if(fReturnTime)
    {
        hr = THR(Format( 0, pchDateStr, ARRAY_SIZE(pchDateStr),
                     _T("<0d2>/<1d2>/<2d4> <3d2>:<4d2>:<5d2>"),
                     SystemTime.wMonth,
                     SystemTime.wDay,
                     SystemTime.wYear,
                     SystemTime.wHour,
                     SystemTime.wMinute,
                     SystemTime.wSecond ));
    }
    else
    {
        hr = THR(Format( 0, pchDateStr, ARRAY_SIZE(pchDateStr),
                     _T("<0d2>/<1d2>/<2d4>"),
                     SystemTime.wMonth,
                     SystemTime.wDay,
                     SystemTime.wYear));
    }

    if (hr)
        goto Cleanup;

    hr = THR(FormsAllocString(pchDateStr, pBstr));

Cleanup:
    RRETURN(hr);
}

#ifndef DLOAD1

WRAPIT(InternetTimeToSystemTime,
       (LPCTSTR lpszTime, SYSTEMTIME *pst, DWORD dwReserved),
       (lpszTime, pst, dwReserved));

WRAPIT(UnlockUrlCacheEntryFileA,
    (LPCSTR lpszUrl, DWORD dwReserved),
    (lpszUrl, dwReserved));

#endif // DLOAD1

BOOL WINAPI UnlockUrlCacheEntryFileBugW(
    LPCWSTR lpszUrl,
    DWORD dwReserved)
{
    CStrIn strInUrl(lpszUrl);

    return UnlockUrlCacheEntryFileA(strInUrl, dwReserved);
}

#ifndef DLOAD1

// These calls are used by pluginst.cxx to track down the mime
// type.  These are all specifically ANSI calls because wonderful
// wininet.dll does not support the wide-char versions, even though
// it happily exports them.

WRAPIT_( HINTERNET, InternetOpenA,
    (LPCSTR lpszAgent,DWORD dwAccessType,LPCSTR lpszProxy,LPCSTR lpszProxyBypass,DWORD dwFlags),
    (lpszAgent,dwAccessType,lpszProxy,lpszProxyBypass,dwFlags));

INTERNETAPI_(HINTERNET)
InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )
{
    CStrIn szAgent( lpszAgent );
    CStrIn szProxy( lpszProxy );
    CStrIn szProxyBypass( lpszProxyBypass );

    return( InternetOpenA( szAgent, dwAccessType, szProxy, szProxyBypass, dwFlags ) );
}


WRAPIT_( HINTERNET, InternetOpenUrlA,
    (HINTERNET hInternet,LPCSTR lpszUrl,LPCSTR lpszHeaders,DWORD dwHeadersLength,DWORD dwFlags,DWORD_PTR dwContext),
    (hInternet,lpszUrl,lpszHeaders,dwHeadersLength,dwFlags,dwContext));

INTERNETAPI_(HINTERNET)
InternetOpenUrlW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    CStrIn szUrl( lpszUrl );
    CStrIn szHeaders( lpszHeaders );

    return( InternetOpenUrlA(hInternet,szUrl,szHeaders,dwHeadersLength,dwFlags,dwContext) );
}

WRAPIT_( BOOL, InternetSetOptionA,
    (HINTERNET hInternet,DWORD dwOption,LPVOID lpBuffer,DWORD dwBufferLength),
    (hInternet,dwOption,lpBuffer,dwBufferLength)
);

//
// W A R N I N G:
//
//   This wrapper does not handle all types of calls to this
//   routine.  It does no Wide-char to ascii conversion, and
//   so only handles the calls such as INTERNET_SET_CONNECT_TIMETOUT
//   which do NOT take strings in the lpBuffer parameter.
//
// W A R N I N G
//

BOOLAPI InternetSetOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    return( InternetSetOptionA( hInternet, dwOption, lpBuffer, dwBufferLength ) );
}

WRAPIT_( BOOL, HttpQueryInfoA,
    (HINTERNET hRequest,DWORD dwInfoLevel,LPVOID lpBuffer,LPDWORD lpdwBufferLength,LPDWORD lpdwIndex),
    (hRequest,dwInfoLevel,lpBuffer,lpdwBufferLength,lpdwIndex)
);


BOOLAPI HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )
{
    CStrOut     strOutMime((WCHAR*)lpBuffer, MAX_PATH);
    BOOL        fRet;

    fRet = HttpQueryInfoA(hRequest,dwInfoLevel,strOutMime,lpdwBufferLength,lpdwIndex);

    strOutMime.ConvertIncludingNul();

    return( fRet );
}

WRAPIT( InternetCloseHandle,
    (HINTERNET hInternet),
    (hInternet));

WRAPIT(InternetUnlockRequestFile,
    (HANDLE hLock),
    (hLock));

WRAPIT(InternetGetConnectedState,
    (LPDWORD lpdwFlags, DWORD dwReserved),
    (lpdwFlags, dwReserved));

WRAPIT(IsUrlCacheEntryExpiredW,
    (LPCWSTR lpszUrlName, DWORD dwFlags, FILETIME * pftLastModifiedTime),
    (lpszUrlName, dwFlags, pftLastModifiedTime));

#endif // DLOAD1

//+--------------------------------------------------------------------------
//
//  Function : ShortCutUrlHelper
//
//  Synopsis : the helper's helper. in this cas (HASH and SEARCH setting we
//          do not need the over head of the full SetUrlCode. i.e. we are
//          either appending or replacing existing parts
//
//---------------------------------------------------------------------------

HRESULT
ShortCutSetUrlHelper(const TCHAR * pchUrlIn,
                     TCHAR       * pchUrlOut,
                     DWORD         dwBufLen,
                     const BSTR  * pstrComp,
                     URLCOMP_ID    ucid,
                     BOOL          fUseOmLocationFormat)
{
    HRESULT        hr = S_OK;
    DWORD          cch = 0;
    const TCHAR    chTarget = (ucid==URLCOMP_HASH) ? _T('#') : _T('?');
    const TCHAR  * pchComp = (*pstrComp) ? *pstrComp : _T("");
    long           lLength = SysStringLen(*pstrComp)+1;  // +1 for \0

    Assert((ucid==URLCOMP_HASH) || (ucid==URLCOMP_SEARCH));

    // copy over the base url
    if (pchUrlIn)
    {
        while (*pchUrlIn && (*pchUrlIn != chTarget) && (cch++ < (dwBufLen-1)))
        {
            *pchUrlOut++ = * pchUrlIn++;
        }
    }

    // deal with the hash/search character
    // NS always appends a '#' but never a '?'
    // Only add the '#' if the pstrComp does not start with '#' in location case.

    // SHDOCVW implementation always added the '?' to the beginning of the
    // URL in case it was not there.

    if ((ucid==URLCOMP_HASH && (!fUseOmLocationFormat || (*pchComp != chTarget))) ||
        (ucid==URLCOMP_SEARCH && fUseOmLocationFormat && (*pchComp != chTarget)))
    {
        (*pchUrlOut++) = chTarget;
        cch++;
    }

    // add the search/hash property. Truncate if too long
    if (cch+lLength > dwBufLen)
        lLength = dwBufLen - cch;

    _tcsncpy(pchUrlOut, pchComp, lLength);
    *(pchUrlOut+lLength-1) = _T('\0');
    hr = S_OK;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\dl\bookmark.cxx ===
//+---------------------------------------------------------------------------
//
//  Maintained by: Jerry, Terry and Ted
//
//  Microsoft DataDocs
//  Copyright (C) Microsoft Corporation, 1994-1995
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  File:       ddoc\dl\bookmark.cxx
//
//  Contents:   Data Layer Bookmark/Chapter helper object
//
//  Classes:    CDataLayerBookmarkHelper
//
//  Functions:  None.
//

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DLCURSOR_HXX_
#define X_DLCURSOR_HXX_
#include "dlcursor.hxx"
#endif

DeclareTag(tagDataLayerBookmarkHelper, "DataLayerBookmark's",
           "Nile (OLE DB) bookmarks/chapters" );

MtDefine(CDataLayerBookmarkHelperRep, DataBind, "CDataLayerBookmarkHelperRep")

//+---------------------------------------------------------------------------
//
//  CDataLayerBookmarkHelperRep is the refcounted object which holds the real
//  bookmark.  Note:  This is not a OLE refcount!  Iff the Bookmark/Chapter
//  is null the pointer to this rep (_pRep) is null.  Iff the Bookmark/Chapter
//  is a predefined DBBMK_* iSize is eSimple and _dbbmk holds that byte (use
//  IsSimple() to check for this.)  Iff iSize is eFabricated then this bookmark
//  is a fabricated bookmark for use by an DataLayerCursor (use IsFabricated().)
//  _pDataLayerCursor is only used for Nile bookmarks (i.e. IsVarying, IsULONG
//  and IsHROW.)  Be sure to look at IsValidObjects routines at the bottom of
//  this file for this and other representation invariants.
//

class CDataLayerBookmarkHelperRep
{
public:
    unsigned long           _uRefCount;
    CDataLayerCursor *const _pDataLayerCursor;
    const size_t            _iSize;
    enum
        {
        eSimple = -1,
        eULONG = -2
        };
    BOOL IsSimple()      const { return _iSize == eSimple; }


    BOOL IsULONG()       const { return _iSize == eULONG; }
    BOOL IsVarying()     const { return int(_iSize) >= 0; }
    BOOL IsHCHAPTER()    const { return FALSE; }
    BOOL IsFabricated()  const { return FALSE; }
    union // NOTE:  This must be the last field in this structure! (see new).
    {
        BYTE                      _abData[1];
        ULONG                     _uData;
        HROW                      _hRow;
    };
    CDataLayerBookmarkHelperRep(CDataLayerCursor *const, const size_t iSize,
        const void *pvData );
    CDataLayerBookmarkHelperRep(CDataLayerCursor *const, const ULONG &);
    // overload new && delete to enable caching of 
    // bookmark creation (frankman 1/23/96)
    void *operator new (size_t uCompilerSize, size_t uDataSize);
    void *operator new (size_t);
    void operator delete( void* p );

    // two fixed bookmarks
    static CDataLayerBookmarkHelperRep TheFirst;
    static CDataLayerBookmarkHelperRep TheLast;

private:
//    NO_COPY(CDataLayerBookmarkHelperRep);
    CDataLayerBookmarkHelperRep(const BYTE &dbbmk ) :
        _uRefCount(1), _pDataLayerCursor(NULL), _iSize((const size_t)eSimple)
    {
        _abData[0] = dbbmk;
    }

public:
};

typedef CDataLayerBookmarkHelperRep CRep;

//+---------------------------------------------------------------------------
//
//  Member:     Constructor - Create a simple, "predefined" bookmark
//

CDataLayerBookmarkHelper::CDataLayerBookmarkHelper(const BYTE &dbbmk)
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmarkHelper::constructor(%p{%u})", this, dbbmk ));

    if (dbbmk == DBBMK_FIRST)
    {
        _pRep = &CDataLayerBookmarkHelperRep::TheFirst;
    }
    else
    {
        Assert(dbbmk == DBBMK_LAST);
        _pRep = &CDataLayerBookmarkHelperRep::TheLast;
    }
    IS_VALID(this);
}

// Initialize statics

// as good a place as any to define these
extern const BYTE g_bBmkLast = DBBMK_LAST;

#ifdef _MAC
CRep CRep::TheFirst((BYTE) DBBMK_FIRST);
CRep CRep::TheLast((BYTE) DBBMK_LAST);
#else
CRep CRep::TheFirst = CRep((BYTE) DBBMK_FIRST);
CRep CRep::TheLast = CRep((BYTE) DBBMK_LAST);
#endif
const CDataLayerBookmark CDataLayerBookmark::TheNull = CDataLayerBookmark();
const CDataLayerBookmark CDataLayerBookmark::TheFirst = CDataLayerBookmark((BYTE) DBBMK_FIRST);
const CDataLayerBookmark CDataLayerBookmark::TheLast = CDataLayerBookmark((BYTE) DBBMK_LAST);


CDataLayerBookmarkHelperRep::CDataLayerBookmarkHelperRep(
    CDataLayerCursor *const pDataLayerCursor,
    const size_t iSize, const void *pvData ) :
    _uRefCount(1), _pDataLayerCursor(pDataLayerCursor), _iSize(iSize)
{
    memcpy(_abData, pvData, iSize);
}
CDataLayerBookmarkHelperRep::CDataLayerBookmarkHelperRep(
    CDataLayerCursor *const pDataLayerCursor, const ULONG &rul ) :
    _uRefCount(1), _pDataLayerCursor(pDataLayerCursor), _iSize((const size_t)eULONG)
{
    _uData = rul;
}


inline void *
CDataLayerBookmarkHelperRep::operator new(size_t uCompilerSize,
                                          size_t uDataSize)
                                          
{
    return ::new(Mt(CDataLayerBookmarkHelperRep)) BYTE[uCompilerSize + uDataSize - sizeof(void*)];
}

inline void *
CDataLayerBookmarkHelperRep::operator new(size_t uCompilerSize)
                                          
{
    return ::new(Mt(CDataLayerBookmarkHelperRep)) BYTE[uCompilerSize];
}


inline void 
CDataLayerBookmarkHelperRep::operator delete (void *p)
{
    ::delete p;
}

//+---------------------------------------------------------------------------
//
//  getDataPointer and getDataSize are used when using a bookmark/chapter with
//  Nile.  They decode the internal rep and return appropriate info.
//

const BYTE *
CDataLayerBookmarkHelper::getDataPointer() const
{
    const BYTE *ret = IsNull() ? NULL
                               : _pRep->_abData;
    return ret;
}


size_t
CDataLayerBookmarkHelper::getDataSize() const
{
    size_t ret = IsNull() ? 0 :
                 _pRep->IsSimple() ? 1 :
                 _pRep->IsVarying() ? _pRep->_iSize :
                sizeof(ULONG);
    return ret;
}

// TODO: should be in-line now, but outside world doesn't know about CRep
BOOL
CDataLayerBookmarkHelper::IsDBBMK_FIRST() const
{
    // we only allow the world to have one Rep for the for DBBMK_FIRST
    Assert((_pRep == &CRep::TheFirst)
        == (_pRep && _pRep->IsSimple() && _pRep->_abData[0] == DBBMK_FIRST) );
    return _pRep == &CRep::TheFirst;
}


// TODO: should be in-line now, but outside world doesn't know about CRep
BOOL
CDataLayerBookmarkHelper::IsDBBMK_LAST() const
{
    // we only allow the world to have one Rep for the for DBBMK_LAST
    Assert((_pRep == &CRep::TheLast)
        == (_pRep && _pRep->IsSimple() && _pRep->_abData[0] == DBBMK_LAST) );
    return _pRep == &CRep::TheLast;
}


#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Trace is used for TraceTag because decoding the rep on the fly is not easy.
//

void
CDataLayerBookmarkHelper::Trace(LPSTR pstr)
{
    if (IsNull())
    {
        TraceTag((tagDataLayerBookmarkHelper,
                  "CDataLayerBookmarkHelper::%s(%p{0})", pstr, this ));
    }
    else
    {
        TraceTag((tagDataLayerBookmarkHelper,
                  "CDataLayerBookmarkHelper::%s(%p{%p, %u, %u, %p})",
                  pstr, this, _pRep, _pRep->_uRefCount, _pRep->_iSize,
                  _pRep->_pDataLayerCursor ));
    }
}
#define TRACE(x) Trace(x)
#else
#define TRACE(x) 0
#endif



//+---------------------------------------------------------------------------
//
//  Member:     Copy Constructor
//

CDataLayerBookmarkHelper::CDataLayerBookmarkHelper(
    const CDataLayerBookmarkHelper &rdlb ) : _pRep(rdlb._pRep)
{
    TRACE("constructor");

    IS_VALID(this);

    if (!IsNull())
    {
        _pRep->_uRefCount += 1;
    }
}




//+---------------------------------------------------------------------------
//
//  Member:     Constructor - construct from a DBVECTOR
//
//  Iff we run out of memory the resultant Bookmark/Chapter is null (use IsNull)
//

CDataLayerBookmarkHelper::CDataLayerBookmarkHelper(
    CDataLayerCursor &rDataLayerCursor, const DBVECTOR &rdbv )
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmarkHelper::constructor(%p{%p, %u})",
              this, &rDataLayerCursor, rdbv.size ));

    _pRep = new (rdbv.size) CRep(&rDataLayerCursor, rdbv.size, rdbv.ptr);
    CoTaskMemFree(rdbv.ptr);
    IS_VALID(this);
}


//+---------------------------------------------------------------------------
//
//  Member:     Constructor - construct from a ULONG
//
//  Iff we run out of memory the resultant Bookmark/Chapter is null (use IsNull)
//

CDataLayerBookmarkHelper::CDataLayerBookmarkHelper(
    CDataLayerCursor &rDataLayerCursor, const ULONG &rul )
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmarkHelper::constructor(%p{%p, %u})",
              this, &rDataLayerCursor, rul ));

    _pRep = new CRep(&rDataLayerCursor, rul);
    IS_VALID(this);
}


#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     Destructor
//

CDataLayerBookmarkHelper::~CDataLayerBookmarkHelper()
{
    TRACE("destructor");

    IS_VALID(this);

    Assert("Passivate wasn't called before destructor" &&
           (IsNull()) );
}
#endif



//+---------------------------------------------------------------------------
//
//  Member:     Unlink
//
//  Decrement ref count and release if gone.
//

void
CDataLayerBookmarkHelper::Unlink()
{
    TRACE("Unlink");

    IS_VALID(this);

    if (!IsNull())
    {
        _pRep->_uRefCount -= 1;
        if (!_pRep->_uRefCount)
        {
            if (!_pRep->IsSimple())
            {
                delete _pRep;
                _pRep = 0;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     Assignment operator
//

CDataLayerBookmarkHelper &
CDataLayerBookmarkHelper::operator=(const CDataLayerBookmarkHelper &rdlb)
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmarkHelper::%p = %p", this, &rdlb ));

    IS_VALID(this);
    if (_pRep != rdlb._pRep)
    {
        Unlink();
        _pRep = rdlb._pRep;
        if (!IsNull())
        {
            _pRep->_uRefCount += 1;
        }
    }
    return *this;
}


//+---------------------------------------------------------------------------
//
//  Member:     operator==
//
//  Synopsis:   Compare two bookmarks
//

BOOL
CDataLayerBookmark::operator==(const CDataLayerBookmark &rdlb) const
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmark::%p == %p", this, &rdlb ));

    IS_VALID((CDataLayerBookmark*)this);
    IS_VALID((CDataLayerBookmark*)&rdlb);

    if (_pRep == rdlb._pRep)
    {
        return TRUE;
    }
    if (IsNull() || rdlb.IsNull())
    {
        return FALSE;
    }

    if (_pRep->IsVarying() != rdlb._pRep->IsVarying())
    {
        return (FALSE);
    }
    if (!_pRep->IsVarying())
    {
        if (_pRep->_iSize != rdlb._pRep->_iSize)
        {
            return FALSE;
        }
        if (_pRep->IsULONG())
        {
            goto RowsetCompare;
        }

        Assert(_pRep->IsSimple());      // last case must be simple..
        // we only have two static bookmarks, and we already checked if
        //  the two _pReps matched!
        Assert(_pRep->_abData[0] != rdlb._pRep->_abData[0]);
        return FALSE;
    }
    else
    {
RowsetCompare:
        Assert(_pRep->_pDataLayerCursor == rdlb._pRep->_pDataLayerCursor);
        DBCOMPARE dbc;
        return !_pRep->_pDataLayerCursor->_pRowsetLocate->Compare(
                   _pRep->_pDataLayerCursor->_hChapter,
                   getDataSize(), getDataPointer(),
                   rdlb.getDataSize(), rdlb.getDataPointer(), &dbc ) &&
               dbc == DBCOMPARE_EQ;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     operator<
//
//  Synopsis:   Compare two bookmarks
//

BOOL
CDataLayerBookmark::operator<(const CDataLayerBookmark &rdlb) const
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmark::%p < %p", this, &rdlb ));

    IS_VALID((CDataLayerBookmark*)this);
    IS_VALID((CDataLayerBookmark*)&rdlb);

    if (_pRep == rdlb._pRep || rdlb.IsNull())
    {
        return FALSE;
    }
    if (IsNull())
    {
        return TRUE;
    }
    if (_pRep->IsSimple() || rdlb._pRep->IsSimple())
    {
        return !rdlb._pRep->IsSimple() ||
               _pRep->_abData[0] < rdlb._pRep->_abData[0];
    }

    Assert((_pRep->IsVarying() || _pRep->IsULONG()) &&
           (rdlb._pRep->IsVarying() || rdlb._pRep->IsULONG()) );

    Assert(_pRep->_pDataLayerCursor == rdlb._pRep->_pDataLayerCursor);

    const BYTE *pbBookmarkData1 = getDataPointer();
    size_t      cbBookmarkSize1 = getDataSize();
    const BYTE *pbBookmarkData2 = rdlb.getDataPointer();
    size_t      cbBookmarkSize2 = rdlb.getDataSize();
    DBCOMPARE   dbc;

    if (_pRep->_pDataLayerCursor->_pRowsetLocate->Compare(
            _pRep->_pDataLayerCursor->_hChapter,
            cbBookmarkSize1, pbBookmarkData1,
            cbBookmarkSize2, pbBookmarkData2, &dbc ) ||
        dbc == DBCOMPARE_NE || dbc == DBCOMPARE_NOTCOMPARABLE )
    {
        int cmp = memcmp(pbBookmarkData1, pbBookmarkData2,
                         min(cbBookmarkSize1, cbBookmarkSize2) );
        return cmp < 0 || (cmp == 0 && cbBookmarkSize1 < cbBookmarkSize2);
    }
    else
    {
        Assert(dbc == DBCOMPARE_EQ || dbc == DBCOMPARE_LT ||
               dbc == DBCOMPARE_GT );
        return (dbc == DBCOMPARE_LT);
    }
}


#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     IsValidObject
//
//  Synopsis:   Validation method, called by macro IS_VALID(p)
//

BOOL
CDataLayerBookmarkHelper::IsValidObject()
{
    if (!IsNull())
    {
        Assert("_pRep must be exactly one type" &&
               (_pRep->IsSimple()  + _pRep->IsFabricated() +
                _pRep->IsVarying() + _pRep->IsULONG() == 1 ) );
        Assert("Nile and HROW Bookmarks (only) should have cursors" &&
               ((_pRep->IsVarying() || _pRep->IsULONG()) ==
                !!_pRep->_pDataLayerCursor ) );
        Assert("Only two fixed Reps for Simple bookmarks" &&
                (_pRep == &CRep::TheFirst || _pRep == &CRep::TheLast)
                    == _pRep->IsSimple() );
        Assert("Cursors must be active" &&
               (!_pRep->_pDataLayerCursor ||
                _pRep->_pDataLayerCursor->IsActive() ) );
        Assert("Refcounts must not underflow" &&
               (_pRep->_uRefCount != (unsigned long)-1l) );
    }
    return TRUE;
}


BOOL
CDataLayerBookmark::IsValidObject()
{
    super::IsValidObject();
    return TRUE;
}


char s_achCDataLayerBookmarkHelper[] = "CDataLayerBookmarkHelper";
char s_achCDataLayerBookmark[]       = "CDataLayerBookmark";

//+---------------------------------------------------------------------------
//
//  Member:     Dump
//
//  Synopsis:   Dump function, called by macro DUMP(p,dc)
//

void
CDataLayerBookmarkHelper::Dump(CDumpContext&)
{
    TraceTag((tagDataLayerBookmarkHelper, "CDataLayerBookmarkHelper::Dump(%p)",
              this ));

    IS_VALID(this);
}


void
CDataLayerBookmark::Dump(CDumpContext& dc)
{
    TraceTag((tagDataLayerBookmarkHelper, "CDataLayerBookmark::Dump(%p)",
              this ));

    super::Dump(dc);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetClassName
//
//  Synopsis:   GetClassName function. (virtual)
//

char *
CDataLayerBookmarkHelper::GetClassName()
{
    return s_achCDataLayerBookmarkHelper;
}


char *
CDataLayerBookmark::GetClassName()
{
    return s_achCDataLayerBookmark;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\include\empty.cxx ===
#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\dl\dbllink.cxx ===
//-----------------------------------------------------------------------------
//
// Handy-Dandy doubly linked list package.
//
// Created by tedsmith
//
// See comments in dbllink.hxx  (this stuff is boring anyway)

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DBLLINK_HXX_
#define X_DBLLINK_HXX_
#include "dbllink.hxx"
#endif

void
CDblLinkedListBase::Remove(Node *pNode)
{
    Assert("Node must exist in Linked list" &&
           (pNode && !IsAnchor(pNode) && Contains(pNode)) );

    pNode->_pNext->_pPrev = pNode->_pPrev;
    pNode->_pPrev->_pNext = pNode->_pNext;
#if DBG == 1
    pNode->_pPrev = pNode->_pNext = NULL;
#endif
}


void
CDblLinkedListBase::InsertAfter(Node *pPosition, Node *pNewNode)
{
    Assert("A node can only be in one TIntrusive... at a time" &&
           (!pNewNode->_pPrev && !pNewNode->_pNext) );
    Assert("Node must exist in Linked list" &&
           (pPosition && Contains(pPosition)) );

    pNewNode->_pNext = pPosition->_pNext;
    pNewNode->_pPrev = pPosition;
    pPosition->_pNext->_pPrev = pNewNode;
    pPosition->_pNext = pNewNode;
}


void
CDblLinkedListBase::InsertBefore(Node *pPosition, Node *pNewNode)
{
    Assert("A node can only be in one TIntrusive... at a time" &&
           (!pNewNode->_pPrev && !pNewNode->_pNext) );
    Assert("Node must exist in Linked list" &&
           (pPosition && Contains(pPosition)) );

    pNewNode->_pNext = pPosition;
    pNewNode->_pPrev = pPosition->_pPrev;
    pPosition->_pPrev->_pNext = pNewNode;
    pPosition->_pPrev = pNewNode;
}


#if DBG == 1
BOOL
CDblLinkedListBase::Contains(const Node *pNode) const
{
    CALL_ISVALIDOBJECT(this);

    // We must implement this routine without using our abstract access
    //   routines since it is used to validate the arguments of those routines.
    const Node *pCur;
    for (pCur = &_Anchor; pCur != pNode; pCur = pCur->_pNext)
    {
        if (pCur == _Anchor._pPrev)
        {
            pCur = NULL;
            break;
        }
    }
    return !!pCur;
}


void
CDblLinkedListBase::IsValidObject() const
{
    const Node *pCur = &_Anchor;
    do
    {
        Assert(pCur->_pPrev);
        Assert(pCur->_pNext);
        Assert(pCur->_pPrev->_pNext == pCur);
        Assert(pCur->_pNext->_pPrev == pCur);
        pCur = pCur->_pNext;
    }
    while (!IsAnchor(pCur));
}


void
CDblLinkedListBaseIterator::IsValidObject() const
{
    Assert("A list must be associated with this Iterator" &&
           (_pList) );
    _pList->IsValidObject();
    Assert("Node must exist in Linked list" &&
           (!_pNode || _pList->Contains(_pNode)) );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\dl\dlcursor.cxx ===
//+-----------------------------------------------------------------------------
//
//  Maintained by: Jerry, Terry and Ted
//
//  Microsoft DataDocs
//  Copyright (C) Microsoft Corporation, 1994-1995
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  File:       ddoc\dl\dlcursor.cxx
//
//  Contents:   Data Layer cursor object
//
//  Classes:    CDataLayerCursor
//
//  Functions:  None.
//

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DLCURSOR_HXX_
#define X_DLCURSOR_HXX_
#include "dlcursor.hxx"
#endif

DeclareTag(tagDataLayerCursor, "DataLayerCursor",
           "Nile (OLE DB) cursor helper class" );

MtDefine(CDataLayerBookmark, DataBind, "CDataLayerBookmark")
MtDefine(CDataLayerCursor, DataBind, "CDataLayerCursor")
MtDefine(CDataLayerCursor_adlColInfo, CDataLayerCursor, "CDataLayerCursor::_adlColInfo")
MtDefine(CDataLayerCursorDeleteRows_aRowStatus, DataBind, "CDataLayerCursor::DeleteRows aRowStatus")

//+-----------------------------------------------------------------------------
//
//  Default Constructor
//
CDataLayerCursor::CDataLayerCursor(CDataLayerCursorEvents *pDLCEvents) :
    _DLNotify(pDLCEvents, GetCurrentThreadId()),
    _ulRefs(1),
    _ulAllRefs(1),
    _pAccessor(NULL),
    _pColumnsInfo(NULL),
    _pRowsetChange(NULL),
    _pRowsetExactScroll(NULL),
    _pRowsetLocate(NULL),
    _pRowsetNewRowAfter(NULL),
    _pRowsetFind(NULL),
    _pRowsetIdentity(NULL),
    _pChapteredRowset(NULL),
    _pRowsetChapterMember(NULL),
    _pcpRowsetNotify(NULL),
    _pcpDBAsynchNotify(NULL),
    _wAdviseCookieRowsetNotify(0),
    _wAdviseCookieDBAsynchNotify(0),
    _cColumns(0),
    _adlColInfo(NULL),
    _cStrBlk(NULL),
    _hBookmarkAccessor(NULL),
    _pRowsetUpdate(NULL),
    _pRowsetScroll(NULL),
    _pSupportErrorInfo(NULL),
    _hNullAccessor(NULL),
    _rcCapabilities(0),
    _uChapterSize(~0ul),
    _fNewRowsSinceLastAsynchRatioFinishedCall(FALSE),
    _fFixedSizedBookmark(FALSE),
    _fDeleteAllInProgress(FALSE)
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::constructor() -> %p", this ));
}




#if DBG == 1
//+-----------------------------------------------------------------------------
//
//  Destructor
//
CDataLayerCursor::~CDataLayerCursor()
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::destructor(%p)", this));

    Assert("Passivate wasn't called before destructor" &&
           (!_pColumnsInfo      && !_pRowsetChange      &&
            !_pRowsetExactScroll &&
            !_pRowsetLocate     && !_pRowsetNewRowAfter &&
            !_pRowsetFind       && !_pRowsetIdentity    &&
            !_pcpRowsetNotify               &&  !_pcpDBAsynchNotify        && 
            !_wAdviseCookieRowsetNotify    && !_wAdviseCookieDBAsynchNotify &&
            !_rcCapabilities     && !_pAccessor ) );
}
#endif



//+-------------------------------------------------------------------------
// Member:      AddRef (public, IUnknown)
//
// Synopsis:    increase refcount
//
// Returns:     new refcount

ULONG
CDataLayerCursor::AddRef()
{
    ULONG ulRefs = ++_ulRefs;
    return ulRefs;
}


//+-------------------------------------------------------------------------
// Member:      Release (public, IUnknown)
//
// Synopsis:    decrease refcount, passivate if 0
//
// Returns:     new refcount

ULONG
CDataLayerCursor::Release()
{
    ULONG ulRefs = --_ulRefs;
    if (ulRefs == 0)
    {
        Passivate();
        SubRelease();
    }
    return ulRefs;
}


//+-------------------------------------------------------------------------
// Member:      SubAddRef
//
// Synopsis:    increase sub-refcount
//
// Returns:     new sub-refcount

ULONG
CDataLayerCursor::SubAddRef()
{
    ULONG ulAllRefs = ++_ulAllRefs;
    return ulAllRefs;
}


//+-------------------------------------------------------------------------
// Member:      SubRelease
//
// Synopsis:    decrease sub-refcount, die if 0
//
// Returns:     new refcount

ULONG
CDataLayerCursor::SubRelease()
{
    ULONG ulAllRefs = --_ulAllRefs;
    if (ulAllRefs == 0)
    {
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }
    return ulAllRefs;
}



//+-----------------------------------------------------------------------------
//
//  Passivate - Cleanup and go back to the pre-Init state
//
void
CDataLayerCursor::Passivate()
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Passivate(%p)", this));

    if (_pRowsetLocate)
    {
        IS_VALID(this);


        // Stop getting notifications:
        if (_wAdviseCookieRowsetNotify)
        {
            _pcpRowsetNotify->Unadvise(_wAdviseCookieRowsetNotify);
            _wAdviseCookieRowsetNotify = 0;
        }

        // Stop getting notifications:
        if (_wAdviseCookieDBAsynchNotify)
        {
            _pcpDBAsynchNotify->Unadvise(_wAdviseCookieDBAsynchNotify);
            _wAdviseCookieDBAsynchNotify = 0;
        }

        if (_hChapter && _pChapteredRowset)
        {
            DL_THR(ChapteredRowset, ReleaseChapter(_hChapter, NULL) );
        }

        ReleaseAccessor(_hNullAccessor);
        ReleaseAccessor(_hBookmarkAccessor);
        if (_adlColInfo)
        {
            delete [] _adlColInfo;
            _adlColInfo = NULL;
        }
        if (_cStrBlk)
        {
            CoTaskMemFree(_cStrBlk);
            _cStrBlk = NULL;
        }
        _cColumns = 0;
        ClearInterface(&_pRowsetChapterMember);
        ClearInterface(&_pChapteredRowset);
        ClearInterface(&_pRowsetIdentity);
        ClearInterface(&_pRowsetFind);
        ClearInterface(&_pRowsetNewRowAfter);
        ClearInterface(&_pRowsetExactScroll);
        ClearInterface(&_pRowsetChange);
        ClearInterface(&_pAccessor);
        ClearInterface(&_pColumnsInfo);
        ClearInterface(&_pRowsetUpdate);
        ClearInterface(&_pRowsetScroll);
        ClearInterface(&_pAsynchStatus);
        ClearInterface(&_pSupportErrorInfo);
        ClearInterface(&_pcpRowsetNotify);
        ClearInterface(&_pcpDBAsynchNotify);
        _rcCapabilities = 0;
        _fNewRowsSinceLastAsynchRatioFinishedCall = FALSE;
        _fFixedSizedBookmark = FALSE;
        _fDeleteAllInProgress = FALSE;
        ClearInterface(&_pRowsetLocate);
    }
}


//+-----------------------------------------------------------------------------
//
//  CDataLayerCursor Init method
//
HRESULT
CDataLayerCursor::Init(IUnknown *pUnkRowset, HCHAPTER hChapter, DWORD dwFlags)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Init(%p, %p)",
              this, pUnkRowset ));

    HRESULT hr;

    Assert("Passivate wasn't called before Init" &&
           (!_pRowsetChange      &&
            !_pRowsetExactScroll &&
            !_pRowsetLocate     && !_pRowsetNewRowAfter &&
            !_pRowsetFind       && !_pRowsetIdentity    &&
            !_pcpRowsetNotify               && !_wAdviseCookieRowsetNotify  &&
            !_rcCapabilities    && !_pAccessor &&
            !_pcpDBAsynchNotify           && !_wAdviseCookieDBAsynchNotify) );

    Assert("We must be passed a valid pUnkRowset" && pUnkRowset);

    _hChapter = hChapter;
    
    // we just gotta have an IRowsetLocate to get started
    hr = pUnkRowset->QueryInterface(IID_IRowsetLocate,
                                              (void **)&_pRowsetLocate);
    if (hr)
        goto Error;
    
    // look for pSupportErrorIno before anything else, so that all
    // other start up processing can feedback rich errors, if supported
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_ISupportErrorInfo,
                                              (void **)&_pSupportErrorInfo));

    if (dwFlags & DLC_SinkNotifications)
    {
        IConnectionPointContainer *pCPC = NULL;
        
        THR_NOTRACE(pUnkRowset->QueryInterface(IID_IConnectionPointContainer,
                                                  (void **)&pCPC));
        if (pCPC)
        {
            THR_NOTRACE(pCPC->FindConnectionPoint(IID_IRowsetNotify, &_pcpRowsetNotify));
            if (_pcpRowsetNotify)
            {
                THR_NOTRACE(_pcpRowsetNotify->Advise((IRowsetNotify *)&_DLNotify, &_wAdviseCookieRowsetNotify));
            }

            THR_NOTRACE(pCPC->FindConnectionPoint(IID_IDBAsynchNotify, &_pcpDBAsynchNotify));
            if (_pcpDBAsynchNotify)
            {
                THR_NOTRACE(_pcpDBAsynchNotify->Advise((IDBAsynchNotify *)&_DLNotify, &_wAdviseCookieDBAsynchNotify));
            }

            ClearInterface(&pCPC);
        }
    }

    _fFilterNotificationsToChapter = !!(dwFlags & DLC_FilterNotificationsToChapter);

    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetChange,
                                              (void **)&_pRowsetChange));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetExactScroll,
                                              (void **)&_pRowsetExactScroll));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetNewRowAfter,
                                              (void **)&_pRowsetNewRowAfter));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetFind,
                                              (void **)&_pRowsetFind));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetUpdate,
                                              (void **)&_pRowsetUpdate));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetScroll,
                                              (void **)&_pRowsetScroll));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IDBAsynchStatus,
                                              (void **)&_pAsynchStatus));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IChapteredRowset,
                                              (void **)&_pChapteredRowset));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetChapterMember,
                                              (void **)&_pRowsetChapterMember));

    if (_hChapter && _pChapteredRowset)
    {
        DL_THR(ChapteredRowset, AddRefChapter(_hChapter, NULL) );
    }

    if (_pRowsetExactScroll)
    {
        _rcCapabilities |= RCOrdinalIndex;
    }
    if (_pRowsetScroll)
    {
        _rcCapabilities |= RCScrollable;
    }
    
    if (_pAsynchStatus)
    {
        DBCOUNTITEM ulProgress, ulProgressMax;
        DBASYNCHPHASE ulStatusCode;
        
        _rcCapabilities |= RCAsynchronous;
        _pAsynchStatus->GetStatus(_hChapter, DBASYNCHOP_OPEN,
                                 &ulProgress, &ulProgressMax,
                                 &ulStatusCode, NULL);
        _fComplete = (ulStatusCode == DBASYNCHPHASE_COMPLETE);
    }
    else
    {
        _fComplete = TRUE;
    }

    hr = FetchRowsetIdentity();
    if (hr)
        goto Error;

    hr = DL_THR(RowsetLocate, QueryInterface(IID_IAccessor,
                                       (void **)&_pAccessor ) );
    if (hr)
    {
        goto Error;
    }

    CacheColumnInfo(_pRowsetLocate);

    
Cleanup:
    RRETURN(hr);

Error:
    Assert(hr);
    Passivate();
    goto Cleanup;
}

HRESULT
CDataLayerCursor::CacheColumnInfo(IUnknown *RowsetLocate)
{
    HRESULT hr;
    DBCOLUMNINFO *aColInfoTemp = NULL;

    if (!_pColumnsInfo)
    {
        hr = DL_THR(RowsetLocate, QueryInterface(IID_IColumnsInfo,
                                               (void **)&_pColumnsInfo ) );
        if (hr)
        {
            goto Cleanup;
        }
    }

    // CacheColumnInfo should only be called once per rowset.
    Assert(!_cStrBlk && !_adlColInfo);

    hr = DL_THR(ColumnsInfo, GetColumnInfo(&_cColumns, &aColInfoTemp, &_cStrBlk));
    if (hr)
    {
        goto Cleanup;
    }

    // Allocate cache:
    _adlColInfo = new(Mt(CDataLayerCursor_adlColInfo)) ColumnInfo[_cColumns];
    if (!_adlColInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    {
        DBCOLUMNINFO *pInfoTempIndex;
        ColumnInfo *pInfoIndex;
        ULONG i;

        for (i = 0, pInfoTempIndex = aColInfoTemp, pInfoIndex = _adlColInfo;
             i < _cColumns;
             i++, pInfoTempIndex++, pInfoIndex++ )
        {
            pInfoIndex->pwszName    = pInfoTempIndex->pwszName;
            pInfoIndex->iNumber     = pInfoTempIndex->iOrdinal;
            pInfoIndex->dwFlags     = pInfoTempIndex->dwFlags;
            pInfoIndex->dwType      = pInfoTempIndex->wType;
            pInfoIndex->cbMaxLength = pInfoTempIndex->ulColumnSize;
        }
    }

    _uChapterSize = ~0ul; // We don't know anything about the size.

    Assert(hr == S_OK);

Cleanup:
    // Deallocate temp column info and string buffer:
    if (aColInfoTemp) CoTaskMemFree(aColInfoTemp);
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  FetchRowsetIdentity (private method, called by Init())
//      See whether the provider allows bitwise comparison of HROWs.
//      If not, fetch _pRowsetIdentity interface pointer.
//
//  Params:  none
//
//  Returns: S_OK if everything was fine

HRESULT
CDataLayerCursor::FetchRowsetIdentity()
//  Only fetch _pRowsetIdentity if required by provider.
{
    Assert(_pRowsetLocate && "must have valid IRowsetLocate");

    HRESULT hr = S_OK;
    IRowsetInfo *pRowsetInfo;
    const int kRowset=0;            // index into aPropIDSets
    DBPROPIDSET aPropIDSets[kRowset + 1];
    const int kLiteralIdentity=0;   // indexes into aPropertyIDs
    const int kStrongIdentity=1;
    DBPROPID aPropertyIDs[kStrongIdentity + 1];
    ULONG cPropSets=0;
    DBPROPSET *aPropSets = NULL;
    DBPROP *pLiteralIdentity, *pStrongIdentity;
    BOOL bBitCompareOK = TRUE;  // does provider approve comparing HROWs bitwise?
    // NOTE defaulting to TRUE even if properties are unsupported?
    
    if (THR(_pRowsetLocate->QueryInterface(IID_IRowsetInfo,
                                        (void **)&pRowsetInfo)))
    {
        // Assume true identity
        goto Cleanup;
    }

    // prepare query to IRowsetInfo::GetProperties
    aPropIDSets[kRowset].rgPropertyIDs = aPropertyIDs;
    aPropIDSets[kRowset].cPropertyIDs = ARRAY_SIZE(aPropertyIDs);
    aPropIDSets[kRowset].guidPropertySet = DBPROPSET_ROWSET;
    aPropertyIDs[kLiteralIdentity] = DBPROP_LITERALIDENTITY;
    aPropertyIDs[kStrongIdentity] = DBPROP_STRONGIDENTITY;

    hr = THR(HandleError(IID_IRowsetInfo, pRowsetInfo->GetProperties(
                                        ARRAY_SIZE(aPropIDSets), aPropIDSets,
                                        &cPropSets, &aPropSets ) ) );
    ClearInterface(&pRowsetInfo);
    if (hr)
    {
        goto Cleanup;
    }

    // see if rowset lets us compare HROWS bitwise
    pLiteralIdentity = & aPropSets[kRowset].rgProperties[kLiteralIdentity];
    pStrongIdentity = & aPropSets[kRowset].rgProperties[kStrongIdentity];

    if (pLiteralIdentity->dwStatus == DBPROPSTATUS_OK &&
        V_BOOL(&pLiteralIdentity->vValue) == VARIANT_FALSE)
    {
        bBitCompareOK = FALSE;
    }

    if (! bBitCompareOK)
    {
        hr = DL_THR(RowsetLocate, QueryInterface(IID_IRowsetIdentity,
                                        (void **) &_pRowsetIdentity ) );
        if (hr == E_NOINTERFACE)
            hr = S_OK;          // degrade to comparing HROWs directly
        if (hr)
            goto Cleanup;
    }

Cleanup:
    // release memory returned by query
    if (cPropSets > 0)
    {
        ULONG iPropSet;
        for (iPropSet=0; iPropSet<cPropSets; ++iPropSet)
            CoTaskMemFree(aPropSets[iPropSet].rgProperties);
        CoTaskMemFree(aPropSets);
    }

    RRETURN(hr);
}



//+-----------------------------------------------------------------------------
//
//  NewRowAfter - Inserts a new HROW in a given Chapter at position just after
//                Bookmark, the row will have no data in it and must be filled
//                in before Update is called
//
//  Params:  rdlb  Reference to Bookmark to add row just after
//           pHRow Pointer to HROW to receive new (ref-counted) row or
//                 NULL iff no record is needed just now of that row.
//
//  Returns: S_OK if everything was fine
//           E_...  error in standard OLE range on actual error
//           if no records could be returned, then *pHRow filled in with NULL
//
HRESULT
CDataLayerCursor::NewRowAfter(const CDataLayerBookmark &rdlb, HROW *pHRow)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::NewRowAfter(%p, %p)",
              this, &rdlb ));

    IS_VALID(this);

    HROW hRow = NULL;
    HRESULT hr = S_OK;

    if (!_hNullAccessor)
    {
        hr = THR(CreateAccessor(_hNullAccessor,
                                DBACCESSOR_ROWDATA,
                                NULL, 0 ));
        if (hr)
        {
            goto Cleanup;
        }
    }

    Assert(_hNullAccessor);

    if (_pRowsetNewRowAfter)
    {
        ULONG cbBookmark = 0; 
        const BYTE* pBookmark = NULL;   // to keep compiler happy

        // caller sends us DBBMK_FIRST to insert a new "first" row.
        // In this case, we give IRowsetNewRowAfter::SetNewDataAfter
        // what it wants for this situation, namely a bookmark of length 0
        if (!rdlb.IsDBBMK_FIRST())
        {
            cbBookmark = rdlb.getDataSize();
            pBookmark = rdlb.getDataPointer();
        }

        hr = DL_THR(RowsetNewRowAfter, SetNewDataAfter(
            _hChapter,
            cbBookmark, pBookmark,
            _hNullAccessor, NULL, &hRow ));
        hr = ClampITFResult(hr);
    }
    else
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // If we are not receiving notifications from below, we should fire
    //   events ourselves.
    if (!_wAdviseCookieRowsetNotify)
    {
        IGNORE_HR(_DLNotify.OnRowChange(_pRowsetLocate, 1, &hRow,
                                DBREASON_ROW_INSERT, DBEVENTPHASE_DIDEVENT,
                                TRUE));
    }

Cleanup:
    if (pHRow)
    {
        *pHRow = hr ? NULL : hRow;
    }
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  GetRowAt - Retrieves the specified HROW in a given Chapter
//
//  Params:  rdlb  Reference to Bookmark to start fetching at
//
//  Returns: S_OK if everything was fine
//           S_FALSE if no record could be returned for "normal" reasons
//           E_...  error in standard OLE range on actual error
//           if no records could be returned, then *pHRow filled in with NULL
//
HRESULT
CDataLayerCursor::GetRowAt(const CDataLayerBookmark &rdlb, HROW *pHRow)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::GetRowAt(%p, %p)",
              this, &rdlb ));

    IS_VALID(this);
    HRESULT hr;
    DBCOUNTITEM cRows;

    hr = GetRowsAt(rdlb, 0, 1, &cRows, pHRow);
    if (!cRows)
    {
        *pHRow = NULL;
    }

    RRETURN2(hr, S_FALSE, DB_S_BOOKMARKSKIPPED);
}


//+-----------------------------------------------------------------------------
//
//  GetRowsAt - Retrieves the next set of HROW's in a given Chapter.
//
//  Params:  rdlb           Reference to Bookmark to start fetching at
//           iOffset        Offset from rdlb to the first row to fetch
//           iRows          number of rows to fetch, signed, < 0 to go backwards
//           puFetchedRows  pointer to return the number of rows fetched
//           pHRows         caller allocated array of HROW's for result
//
//  Returns: S_OK -- everything OK
//           S_FALSE -- not all records retrieved (possibly 0), but no error
//           DB_S_BOOKMARKSKIPPED iff rdlb refers to a deleted hrow
//           DB_S_ENDOFROWSET if our fetch went past end of rowset
//           E_...  "standard" error code (no other OLE DB errors propagated)
//
//  Comments: We have to be carefull to return the new rows which have been
//            added to the cursor but not commited, iff this cursor doesn't do
//            this for us.
//
HRESULT
CDataLayerCursor::GetRowsAt(const  CDataLayerBookmark &rdlb,
                            DBROWOFFSET iOffset,
                            DBROWCOUNT  iRows,
                            DBCOUNTITEM *puFetchedRows,
                            HROW  *pHRows )
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::GetRowsAt(%p, %p, %i, %u)",
              this, &rdlb, iOffset, iRows ));

    IS_VALID(this);
    Assert(!rdlb.IsNull());
    Assert(puFetchedRows);
    Assert(pHRows);

    *puFetchedRows = 0;

    HRESULT     hr              = S_OK;
    const BYTE *pbBookmarkData  = rdlb.getDataPointer();
    size_t      uBookmarkSize   = rdlb.getDataSize();
    
    hr = DL_THR(RowsetLocate, GetRowsAt(DBWATCHREGION_NULL,
            _hChapter, uBookmarkSize, pbBookmarkData,
            iOffset, iRows, puFetchedRows, &pHRows ));

    RRETURN2(hr, DB_S_ENDOFROWSET, DB_S_BOOKMARKSKIPPED);
}


//+-----------------------------------------------------------------------------
//
//  DeleteRows - Deletes the given hRows
//
//  Params:  uRows   of rows to delete
//           pHRows  array of hRows to delete
//
HRESULT
CDataLayerCursor::DeleteRows(size_t uRows, HROW *pHRows)
{
    HRESULT hr;
    HCHAPTER hcDummy = 0;       // reserved arg for DeleteRows
    DBROWSTATUS *aRowStatus = new(Mt(CDataLayerCursorDeleteRows_aRowStatus)) DBROWSTATUS[uRows];

    if (aRowStatus == 0) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // If we are not receiving notifications from below, we should fire
    //   events ourselves.
    if (!_wAdviseCookieRowsetNotify)
    {
        hr = THR(_DLNotify.OnRowChange(_pRowsetLocate, uRows, pHRows,
                             DBREASON_ROW_DELETE, DBEVENTPHASE_ABOUTTODO,
                             FALSE ));
        if (FAILED(hr) || hr == S_FALSE)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        Assert(!hr);    // AndrewL 5/96 Why do we allow success codes other than S_FALSE?
    }


    hr = DL_THR(RowsetChange, DeleteRows(hcDummy, uRows, pHRows, aRowStatus));

    // If we are not receiving notifications from below, we should fire
    //   events ourselves.
    if (!_wAdviseCookieRowsetNotify)
    {
        // TODO: Handle partial success correctly
        Assert(hr != DB_S_ERRORSOCCURRED);
        IGNORE_HR(_DLNotify.OnRowChange(_pRowsetLocate, uRows, pHRows,
                              DBREASON_ROW_DELETE,
                              (hr == S_OK ? DBEVENTPHASE_FAILEDTODO
                                                : DBEVENTPHASE_DIDEVENT ),
                              TRUE ));
    }


Cleanup:
    delete [] aRowStatus;
    RRETURN(hr);
}



//+-----------------------------------------------------------------------------
//
//  GetData - reads data from an HROW using the specifed accessor
//
//  Params:  hRow       the row to read from
//           hAccessor  the accessor handle to use
//           pData      caller allocated databuffer (buffer MUST be big enough)
//           fOriginal  callers wants unmodified data
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::GetData(HROW hRow, HACCESSOR hAccessor, void *pData,
                          BOOL fOriginal)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::GetData(%p)", this));

    IS_VALID(this);

    if (fOriginal && _pRowsetUpdate)
    {
        return DL_THR(RowsetUpdate, GetOriginalData(hRow, hAccessor,
                                                    (BYTE *)pData ) ); 
    }
    else
    {
        return DL_THR(RowsetLocate, GetData(hRow, hAccessor,
                                            (BYTE *)pData ) );
    }
}




//+-----------------------------------------------------------------------------
//
//  SetData - set data from an HROW using the specifed accessor
//
//  Params:  hRow      the row to set
//           hAccessor the accessor handle to use
//           pData     caller allocated databuffer (buffer MUST be big enough)
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::SetData(HROW hRow, HACCESSOR hAccessor, void *pData)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::SetData(%p)", this));

    IS_VALID(this);

    HRESULT hr = E_ACCESSDENIED;

    if (_pRowsetChange)
    {
        hr = DL_THR(RowsetChange, SetData(hRow, hAccessor, (BYTE *)pData));
    }

    if (hr)
    {
        goto Cleanup;
    }

    // If we are not receiving notifications from below, we should fire
    //   events ourselves.
    if (!_wAdviseCookieRowsetNotify)
    {
        // TODO: this should be a FieldChange, not a RowChange
        IGNORE_HR(_DLNotify.OnRowChange(_pRowsetLocate, 1, &hRow,
                                DBREASON_COLUMN_SET, DBEVENTPHASE_DIDEVENT,
                                TRUE));
    }

Cleanup:
    return hr;
}




//+-----------------------------------------------------------------------------
//
//  Update - flush data to the database
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::Update()
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Update(%p)", this));

    IS_VALID(this);

    HRESULT hr = S_OK;

    if (_pRowsetUpdate)
    {
        hr = DL_THR(RowsetUpdate, Update(NULL, 0, NULL, NULL, NULL, NULL));
        hr = ClampITFResult(hr);
    }

    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Update - flush one record's data to the database
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::Update(HROW hrow)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Update(%p %p)", this, hrow));

    IS_VALID(this);

    HRESULT hr = S_OK;

    if (_pRowsetUpdate)
    {
        hr = DL_THR(RowsetUpdate, Update(NULL, 1, &hrow, NULL, NULL, NULL));
        hr = ClampITFResult(hr);
    }

    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Undo - discard all pending changes
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::Undo()
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Undo(%p)", this));

    IS_VALID(this);

    HRESULT hr = S_OK;

    if (_pRowsetUpdate)
    {
        hr = DL_THR(RowsetUpdate, Undo(NULL, 0, NULL, NULL, NULL, NULL));
        hr = ClampITFResult(hr);
    }

    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Undo - discard pending changes to one row
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::Undo(HROW hrow)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Undo(%p, %p)", this, hrow));

    IS_VALID(this);

    HRESULT hr = S_OK;

    if (_pRowsetUpdate)
    {
        hr = DL_THR(RowsetUpdate, Undo(NULL, 1, &hrow, NULL, NULL, NULL));
        hr = ClampITFResult(hr);
    }

    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  GetRowStatus - return pending row status for given row, using the OLE DB M9
//                  definitions.
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::GetRowStatus(HROW hrow, LONG *pstatus)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Undo(%p, %p)", this, hrow));

    IS_VALID(this);

    // assume success, data not changed
    HRESULT hr = S_OK;
    *pstatus = DBPENDINGSTATUS_UNCHANGED;

    if (_pRowsetUpdate)
    {
        DBCOUNTITEM cRows;
        HROW *aRows;
        DBROWSTATUS *aStatus;
        DBPENDINGSTATUS dwRowStatus = DBPENDINGSTATUS_NEW |
                                DBPENDINGSTATUS_CHANGED | DBPENDINGSTATUS_DELETED;
        
        hr = DL_THR(RowsetUpdate, GetPendingRows(NULL, dwRowStatus,
                                                 &cRows, &aRows, &aStatus));
        if (hr)
        {
            if (hr == S_FALSE)
            {
                Assert(cRows == 0);
                Assert(aRows == NULL);
                Assert(aStatus == NULL);
                hr = S_OK;
            }
            goto Cleanup;
        }

        Assert(cRows != 0);
        Assert(aRows != NULL);
        Assert(aStatus != NULL);

        HROW *pRowLoop;
        ULONG cRowLoop;
        
        for (pRowLoop = aRows, cRowLoop = cRows;
             cRowLoop;
             --cRowLoop, pRowLoop++ )
        {
            if (IsSameRow(*pRowLoop, hrow))
            {
                switch(aStatus[cRows - cRowLoop])
                {
                case DBPENDINGSTATUS_NEW:
                case DBPENDINGSTATUS_CHANGED:
                case DBPENDINGSTATUS_DELETED:
                    *pstatus = aStatus[cRows - cRowLoop];
                    break;
                default:
                    Assert(!"Unknown Row Status");
                    break;
                }
                break;
            }
        }

        ReleaseRows(cRows, aRows);
        CoTaskMemFree(aRows);
        CoTaskMemFree(aStatus);
    }

Cleanup:
    hr = ClampITFResult(hr);
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  GetPositionAndSize - Return the ordinal position within a given Chapter.
//
//  Params:  rdlb           Reference to Bookmark whose position is desired
//           puFetchedRows  pointer to ULONG to return the position in
//           puChapterSize  pointer to ULONG to return the size in
//
//  Comments:
//          NULL's are accepted and may be more efficient
//
//  Returns: S_OK -- everything OK
//           E_...  "standard" error code (no OLE DB errors propagated)
//
HRESULT
CDataLayerCursor::GetPositionAndSize(const CDataLayerBookmark &rdlb,
                                     DBCOUNTITEM *puPosition, DBCOUNTITEM *puChapterSize )
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::GetPositionAndSize(%p)", this ));

    IS_VALID(this);

    HRESULT hr = E_FAIL;
    DBCOUNTITEM   uPosition    = 0;
    DBCOUNTITEM   uChapterSize = _uChapterSize;

    if (_pRowsetExactScroll)
    {
        hr = DL_THR(RowsetExactScroll, GetExactPosition(
            _hChapter,
            rdlb.getDataSize(), rdlb.getDataPointer(),
            &uPosition, &uChapterSize ));
        hr = ClampITFResult(hr);
    }
    if (hr && _pRowsetScroll)
    {
        hr = DL_THR(RowsetScroll, GetApproximatePosition(
            _hChapter,
            rdlb.getDataSize(), rdlb.getDataPointer(),
            &uPosition, &uChapterSize ));
        hr = ClampITFResult(hr);
    }

    if (!hr)
    {
        if (puPosition)
        {
            *puPosition = uPosition;
        }
        if (puChapterSize)
        {
            _uChapterSize = uChapterSize;
            *puChapterSize = uChapterSize;
        }
    }
    RRETURN(hr);
}



//+-----------------------------------------------------------------------------
//
//  GetPositionAndSize - Return the ordinal position within a given Chapter.
//
//  Params:  rdlch          Reference to Chapter which contains...
//           hRow           hRow whose position is desired
//           puFetchedRows  pointer to ULONG to return the position in
//           puChapterSize  pointer to ULONG to return the size in
//
//  Comments:
//          NULL's are accepted and may be more efficient
//
//  Returns: S_OK -- everything OK
//           E_...  "standard" error code (no OLE DB errors propagated)
//
HRESULT
CDataLayerCursor::GetPositionAndSize(HROW hRow,
                                     DBCOUNTITEM *puPosition, DBCOUNTITEM *puChapterSize )
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::GetPositionAndSize(%p)", this ));

    IS_VALID(this);

    CDataLayerBookmark dlb;
    HRESULT hr = THR(CreateBookmark(hRow, &dlb));
    if (!hr)
    {
        hr = GetPositionAndSize(dlb, puPosition, puChapterSize);
    }
    RRETURN(hr);
}



//+-----------------------------------------------------------------------------
//
//  GetSize - Return the number of rows within a given Chapter.
//
//  Params:  rdlch          Reference to Chapter which contains...
//           puChapterSize  pointer to ULONG to return the size in
//
//  Returns: S_OK -- everything OK
//           E_...  "standard" error code (no OLE DB errors propagated)
//

HRESULT
CDataLayerCursor::GetSize(DBCOUNTITEM *puChapterSize)
{
    Assert(puChapterSize);

    return GetPositionAndSize(CDataLayerBookmark::TheFirst,
                              NULL, puChapterSize );
}



//+-----------------------------------------------------------------------------
//
//
//    AddRefRows
//
//    Params:   pHRows  caller allocated array of HROWS to AddRef
//              ulcb    number of elements in the array
//
//    Comments: NULL hRows are acceptable and will be ignored
//
void
CDataLayerCursor::AddRefRows(int ulcb, HROW *pHRows)
{
    for (; ulcb--; pHRows += 1)
    {
        if (*pHRows)
        {
            {
                DL_VERIFY_OK(RowsetLocate, AddRefRows(1, pHRows, NULL, NULL));
            }
        }
    }
}



//+-----------------------------------------------------------------------------
//
//
//    ReleaseRows
//
//    Params:   pHRows  caller allocated array of HROWS to release
//              ulcb    number of elements in the array
//
//    Comments: NULL hRows are acceptable and will be ignored
//
void
CDataLayerCursor::ReleaseRows(int ulcb, HROW *pHRows)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::ReleaseRows(%p)", this));

    IS_VALID(this);
    

    for (; ulcb--; pHRows += 1)
    {
        if (*pHRows)
        {
            {
                DL_VERIFY_OK(RowsetLocate, ReleaseRows(1, pHRows, NULL, NULL, NULL));
            }
        }
    }
}



//+-----------------------------------------------------------------------------
//
//  GetColumnNumberFromName : Gives back the number of a column given its name
//
//  Params:  pstrName     Pointer to the name of the column
//           ulColumnNum  The place to put the column index of the cursor
//                          (smallest index = 1, greatest index = NrOfColumns)
//
//  Returns: E_FAIL if the column name is invalid,
//           S_OK   if valid
//
HRESULT
CDataLayerCursor::GetColumnNumberFromName(LPCTSTR pstrName, DBORDINAL &ulColumnNum)
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::GetColumnNumberFromName(%p)", this ));

    IS_VALID(this);

    Assert("Non-null Name pointer required" && pstrName);

    HRESULT hr = S_OK;
    DBID colid = {{0}, DBKIND_NAME, {const_cast<LPTSTR>(pstrName)}};

    ulColumnNum = DB_INVALIDCOLUMN;

    Assert(_pColumnsInfo);

    hr = DL_THR(ColumnsInfo, MapColumnIDs(1, &colid, &ulColumnNum));
    if (hr)
    {
        hr = E_FAIL;
    }

    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  GetColumnNameFromNumber : Gives back the name of a column given its number
//
//  Params:  ulColumnNum  The column index
//           ppstrName    Pointer to the name of the column
//
//  Returns: E_FAIL if the column number is invalid,
//           S_OK   if valid
//

HRESULT 
CDataLayerCursor::GetColumnNameFromNumber(DBORDINAL ulColumnNum, LPCTSTR *ppstrName)
{
    HRESULT hr;

    if (0<ulColumnNum && ulColumnNum<=_cColumns)
    {
        *ppstrName = _adlColInfo[ulColumnNum].pwszName;
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  CreateBookmark
//
//  Creates and returns a bookmark coresponding to the given row
//
//  Returns:
//      S_OK iff bookmark is returned
//
HRESULT
CDataLayerCursor::CreateBookmark(HROW hRow,
                                 CDataLayerBookmark *pdlb )
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::CreateBookmark(%p, %p, %p)",
              this, hRow, pdlb ));

    IS_VALID(this);
    IS_VALID(pdlb);

    Assert(hRow);

    HRESULT hr;

    if (!_hBookmarkAccessor)
    {
        hr = InitBookmarkAccessor();
        if (hr)
        {
            goto Cleanup;
        }
    }
    if (_fFixedSizedBookmark)
    {
        ULONG uBookmark;
        hr = THR(GetData(hRow, _hBookmarkAccessor, &uBookmark));
        if (!hr)
        {
            *pdlb = CDataLayerBookmark(*this, uBookmark);
        }
    }
    else
    {
        DBVECTOR dbv;
        hr = THR(GetData(hRow, _hBookmarkAccessor, &dbv));
        if (!hr)
        {
            *pdlb = CDataLayerBookmark(*this, dbv);
        }
    }

Cleanup:
    return hr; // RRETURN(hr); TODO: until we figure out better clamping (ICS)
}


//+-----------------------------------------------------------------------------
//
//  InitBookmarkAccessor
//
//  Creates an accessor handle for only 1 column : the bookmark
//
//  Returns:
//      S_OK if everything is cool
//      E_FAIL sets _hBookmarkAccessor handle to 0
//
HRESULT
CDataLayerCursor::InitBookmarkAccessor()
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::InitBookmarkAccessor(%p)", this ));

    IS_VALID(this);

    HRESULT hr = E_FAIL;

    Assert(!_hBookmarkAccessor);

    ULONG         cColumns    = _cColumns;
    ColumnInfo *pdlColumnInfo = _adlColInfo;

    for (; cColumns--; pdlColumnInfo++)
    {
        if (pdlColumnInfo->dwFlags & DBCOLUMNFLAGS_ISBOOKMARK)
        {
            DBBINDING binding;
            _fFixedSizedBookmark = (pdlColumnInfo->dwFlags &
                                    DBCOLUMNFLAGS_ISFIXEDLENGTH ) &&
                                    pdlColumnInfo->cbMaxLength == sizeof(ULONG);
            binding.eParamIO = DBPARAMIO_NOTPARAM;
            binding.iOrdinal = pdlColumnInfo->iNumber;
            binding.dwPart    = DBPART_VALUE;
            binding.bPrecision = 0;
            binding.bScale   = 0;
            binding.obValue  = 0;
            binding.dwMemOwner = DBMEMOWNER_CLIENTOWNED;
            binding.pBindExt = 0;
            binding.dwFlags  = 0;
            if (_fFixedSizedBookmark)
            {
                binding.cbMaxLen = sizeof(ULONG);
                binding.wType = DBTYPE_UI4;
            }
            else
            {
                binding.cbMaxLen = sizeof(DBVECTOR);
                binding.wType = DBTYPE_UI1 | DBTYPE_VECTOR;
            }
                                                     
            hr = THR(CreateAccessor(_hBookmarkAccessor,
                                    DBACCESSOR_ROWDATA,
                                    &binding, 1 ));
            break;
        }
    }

    RRETURN(hr);
}




//+-----------------------------------------------------------------------------
//
//  CreateAccessor - Creates an accessor handle, default is complete row by ref
//
//  Params:   rhAccessor  reference to an accessor handle
//            dwAccFlags  specifies the accessor type, default is read
//            rgBindings  caller allocated array of binding information
//            ulcb        number of elements in the array
//
//  Returns:  S_OK if everything is cool, E_FAIL sets the accessor handle to 0
//
HRESULT
CDataLayerCursor::CreateAccessor(HACCESSOR      &rhAccessor,
                                 DBACCESSORFLAGS dwAccFlags,
                                 const DBBINDING rgBindings[],
                                 int             ulcb )
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::CreateAccessor(%p)", this ));

    IS_VALID(this);

    Assert(_pRowsetLocate);

    rhAccessor = NULL;

    RRETURN1(DL_THR(Accessor, CreateAccessor(dwAccFlags,
                                             (ULONG)ulcb,
                                             rgBindings,
                                             0,
                                             &rhAccessor,
                                             NULL )),
              DB_E_BYREFACCESSORNOTSUPPORTED );
}




//+-----------------------------------------------------------------------------
//
//  ReleaseAccessor - releases an accessor created with CreateAccessor
//
//  Params:   rhAccessor  reference to an accessor handle (which may be NULL)
//
//  Comments: rhAccessor will always be set to NULL
//
void
CDataLayerCursor::ReleaseAccessor(HACCESSOR &rhAccessor)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::ReleaseAccessor(%p, %p)",
             this, rhAccessor ));

    IS_VALID(this);

    if (rhAccessor)
    {
        DL_VERIFY_OK(Accessor, ReleaseAccessor(rhAccessor, NULL));
        rhAccessor = NULL;
    }
}




//+-----------------------------------------------------------------------------
//
//  GetColumnCount : Gives back the number of columns in the cursor
//
//  Params:  cWidth   Place to put the number of columns.
//
//  Returns: S_OK
//
HRESULT
CDataLayerCursor::GetColumnCount(DBORDINAL &cColumns)
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::GetColumnCount(%p)", this ));

    IS_VALID(this);

    DBORDINAL cCnt = _cColumns;
    ColumnInfo *pdlColumnInfo = _adlColInfo;

    cColumns = 0;
    for ( ; cCnt-- ; pdlColumnInfo++)
    {
        cColumns += !(pdlColumnInfo->dwFlags & (DBCOLUMNFLAGS_ISBOOKMARK ));
    }

    RRETURN(THR(S_OK));
}




//+-----------------------------------------------------------------------------
//
//  GetPColumnInfo : helper function to get a pointer to our internal
//                   ColumnInfo structure for a given column number,
//                   including error checking to make sure that this
//                   is an ordinary (non-bookmark, etc.) column
//
//  Params:   ulColumnNum  Column index into the cursor
//            ppColumnInfo  Receiver of pointer
//
//  Returns:  S_OK          everything is fine
//            E_INVALIDARG  column out of range, or not a regular column
//
HRESULT
CDataLayerCursor::GetPColumnInfo(DBORDINAL ulColumnNum,
                                 const ColumnInfo **ppColumnInfo)
{
    HRESULT hr = E_INVALIDARG;

    TraceTag((tagDataLayerCursor, "CDataLayerCursor::GetPColumnInfo(%p)", this));

    IS_VALID(this);

    if (ulColumnNum < _cColumns)
    {
        *ppColumnInfo = &_adlColInfo[ulColumnNum];

        if (((*ppColumnInfo)->dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) == 0)
        {
            hr = S_OK;
        }
    }

    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  FilterRowsToChapter : helper function to comb through a list of HROWs
//                  keeping only the ones belonging to my chapter.  This
//                  is useful for IRowsetNotify methods.  A chaptered
//                  rowset will notify about all HROWs, but we should only
//                  react to the HROWs from my chapter.
//
//  Params:   cRows     number of HROWs in the list
//            rghRows   list of HROWs
//            pcRows    pointer to number of good HROWs (returned)
//            prghRows  pointer to list of good HROWs (returned)
//
//  Note:   The caller should compare the pointer returned through prghRows
//          with the pointer passed in as rghRows.  If they differ, the caller
//          should free the memory allocated for the returned list by executing
//          "delete *prghRows".  However, this routine will use the original
//          list whenever possible, avoiding unneeded memory allocations.
//
//  Returns:  S_OK          everything is fine
//            E_INVALIDARG  pcRows or prghRows not valid
//
HRESULT
CDataLayerCursor::FilterRowsToChapter(
        DBROWCOUNT cRows,
        const HROW rghRows[  ],
        DBROWCOUNT *pcRows,
        const HROW **prghRows
        )
{
    HRESULT hr = S_OK;
    DBROWCOUNT cRowsGood = 0;
    BOOL fNeedAllocation = FALSE;
    DBROWCOUNT i;
    const HROW *pHrow;

    if (pcRows == NULL  ||  prghRows == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // assume most common case - reuse the input array in the output
    *prghRows = rghRows;

    // special case - chapter 0 means all rows are OK
    if (_hChapter == DB_NULL_HCHAPTER)
    {
        *pcRows = cRows;
        goto Cleanup;
    }

    // bad case - no IRowsetChapterMember means we can't even tell which
    // rows belong.  Be paranoid and say none of them.
    if (_pRowsetChapterMember == NULL)
    {
        *pcRows = 0;
        goto Cleanup;
    }

    // walk through the input array and see which HROWs belong to my chapter
    for (i=0, pHrow=rghRows;  i<cRows;  ++i, ++pHrow)
    {
        hr = DL_THR(RowsetChapterMember, IsRowInChapter(_hChapter, *pHrow));
        if (hr == S_OK)
        {
            if (cRowsGood < i)
                fNeedAllocation = TRUE;
            ++ cRowsGood;
        }
    }

    // if we need to allocate an array to return to the caller, do so now
    // and fill it in.
    if (fNeedAllocation)
    {
        HROW *pHrowReturn = new HROW[cRowsGood];

        *prghRows = pHrowReturn;

        for (i=0, pHrow=rghRows;  i<cRows;  ++i, ++pHrow)
        {
            hr = DL_THR(RowsetChapterMember, IsRowInChapter(_hChapter, *pHrow));
            if (hr == S_OK)
            {
                *pHrowReturn = *pHrow;
                ++ pHrowReturn;
            }
        }
    }

    // tell caller how many rows were good
    *pcRows = cRowsGood;
    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


#if DBG == 1
//+-----------------------------------------------------------------------------
//
//  Validation method, called by macro IS_VALID(p)
//
BOOL
CDataLayerCursor::IsValidObject()
{
    ULONG i;

    Assert(this);
    Assert("We must have an IRowsetLocate" &&
           (_pRowsetLocate) );

    // _adlColInfo may not be set yet, if Init() fails for some reason
    if (_adlColInfo)
    {
        for (i = 0; i < _cColumns; i++)
        {
            Assert(_adlColInfo[i].iNumber == i);
        }
    }
    
    return TRUE;
}



char s_achCDataLayerCursor[] = "CDataLayerCursor";


//+-----------------------------------------------------------------------------
//
//  Dump function, called by macro DUMP(p,dc)
//
void
CDataLayerCursor::Dump(CDumpContext &dc)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Dump(%p)", this));

    IS_VALID(this);
}



//+---------------------------------------------------------------------------
//
//  Member:     GetClassName
//
char *
CDataLayerCursor::GetClassName()
{
    return s_achCDataLayerCursor;
}
#endif


///////////////////////////////////////////////////////////////////////
//
//      CDataLayerNotify subobject

HRESULT
CDataLayerNotify::CheckCallbackThread()
{
    HRESULT hr = S_OK;

    if (_dwTID != GetCurrentThreadId())
    {
        Assert(!"OLEDB callback on wrong thread");
        hr = E_UNEXPECTED;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     QueryInterface
//
//  Synopsis:   Normal IUnknown QI
//
//  Arguments:  riid            IID of requested interface
//              ppv             Interface object to return
//
//  Returns:    S_OK            Interface supported
//              E_NOINTERFACE   Interface not supported.
//

STDMETHODIMP
CDataLayerNotify::QueryInterface (REFIID riid, LPVOID *ppv)
{
    Assert(ppv);

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IRowsetNotify *)this;
    }
    else if (IsEqualIID(riid, IID_IRowsetNotify))
    {
        *ppv = (IRowsetNotify *)this;        
    }
    else if (IsEqualIID(riid, IID_IDBAsynchNotify))
    {
        *ppv = (IDBAsynchNotify *)this;
    }
    else
    {
        *ppv = NULL;
    }

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+-------------------------------------------------------------------------
// Member:      AddRef (public, IUnknown)
//
// Synopsis:    increase refcount
//
// Returns:     new refcount

ULONG
CDataLayerNotify::AddRef()
{
    return MyDLC()->SubAddRef();
}


//+-------------------------------------------------------------------------
// Member:      Release (public, IUnknown)
//
// Synopsis:    decrease refcount, die if 0
//
// Returns:     new refcount

ULONG
CDataLayerNotify::Release()
{
    return MyDLC()->SubRelease();
}


//+---------------------------------------------------------------------------
//  Member:     OnFieldChange
//
//  Synopsis:   Called by Nile when a field changes
//              Note that the notification we receive map perfectly to the
//              events we fire.
//

STDMETHODIMP
CDataLayerNotify::OnFieldChange (IRowset *pRowset, HROW hRow,
                                 DBORDINAL cColumns, DBORDINAL aColumns[],
                                 DBREASON eReason, DBEVENTPHASE ePhase,
                                 BOOL /* fCantDeny */)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::OnFieldChange(%p, %p)",
             this, pRowset ));

    HRESULT hr = CheckCallbackThread();
    if (hr)
        goto Cleanup;

    Assert(pRowset);
    if (_pDLCEvents && (ePhase == DBEVENTPHASE_DIDEVENT))  // only fire once
    {
        DBROWCOUNT cRowsGood;
        const HROW *pHrow;

        // check that hRow belongs to my chapter
        if (MyDLC()->_fFilterNotificationsToChapter)
        {
            hr = MyDLC()->FilterRowsToChapter(1, &hRow, &cRowsGood, &pHrow);
            if (hr || cRowsGood==0)
                goto Cleanup;
            Assert(pHrow == &hRow);     // Filter should never allocate an array for only one row
        }
        
        IGNORE_HR(_pDLCEvents->FieldsChanged(hRow, cColumns, aColumns));
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     OnRowChange
//
//  Synopsis:   Called by Nile when a HROW changes
//

STDMETHODIMP
CDataLayerNotify::OnRowChange (IRowset *pRowset, DBCOUNTITEM cRows,
                               const HROW ahRows[],
                               DBREASON eReason, DBEVENTPHASE ePhase,
                               BOOL /* fCantDeny */)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::OnRowChange(%p, %p)",
             this, pRowset ));

    DBROWCOUNT cRowsGood = cRows;
    const HROW *pHrowsGood = ahRows;
    
    CDataLayerCursor *pDLC = MyDLC();
    HRESULT hr = CheckCallbackThread();
    if (hr)
        goto Cleanup;

    Assert(pRowset);

    // ignore rows that don't belong to my chapter
    if (MyDLC()->_fFilterNotificationsToChapter)
    {
        hr = pDLC->FilterRowsToChapter(cRows, ahRows, &cRowsGood, &pHrowsGood);
        if (hr || cRowsGood == 0)
            goto Cleanup;
    }

    // Note that we want to update _uChapterSize even if nobody is listening.
    switch (ePhase)      // fire any given notification exactly once
    {
    case DBEVENTPHASE_OKTODO:
        if (eReason == DBREASON_ROW_DELETE || eReason == DBREASON_ROW_UNDOINSERT)
        {
            if (_pDLCEvents && !pDLC->_fDeleteAllInProgress)
            {
                hr = THR(_pDLCEvents->DeletingRows(cRowsGood, pHrowsGood));
            }
        }
        break;

    case DBEVENTPHASE_FAILEDTODO:
        if (eReason == DBREASON_ROW_DELETE || eReason == DBREASON_ROW_UNDOINSERT)
        {
            if (_pDLCEvents && !pDLC->_fDeleteAllInProgress)
            {
                IGNORE_HR(_pDLCEvents->DeleteCancelled(cRowsGood, pHrowsGood));
            }
        }
        break;

    case DBEVENTPHASE_DIDEVENT:
        switch (eReason)
        {
        case DBREASON_ROW_DELETE:
        case DBREASON_ROW_UNDOINSERT:
            if (pDLC->_uChapterSize != ~0ul)
            {
                pDLC->_uChapterSize -= cRowsGood;
            }
            if (_pDLCEvents && !pDLC->_fDeleteAllInProgress)
            {
                IGNORE_HR(_pDLCEvents->RowsDeleted(cRowsGood, pHrowsGood));
            }
            break;

        case DBREASON_ROW_INSERT:
        case DBREASON_ROW_ASYNCHINSERT:
        case DBREASON_ROW_UNDODELETE:
            if (pDLC->_uChapterSize != ~0ul)
            {
                pDLC->_uChapterSize += cRowsGood;
            }
            if (_pDLCEvents)
            {
                IGNORE_HR(_pDLCEvents->RowsInserted(cRowsGood, pHrowsGood));
            }
            break;

        case DBREASON_COLUMN_RECALCULATED:
        case DBREASON_COLUMN_SET:
        case DBREASON_ROW_RESYNCH:
        case DBREASON_ROW_UNDOCHANGE:
            if (_pDLCEvents)
            {
                IGNORE_HR(_pDLCEvents->RowsChanged(cRowsGood, pHrowsGood));
            }
            break;
        }
    }

Cleanup:
    if (pHrowsGood != ahRows)
        delete const_cast<HROW *>(pHrowsGood);
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Member:     OnRowsetChange
//
//  Synopsis:   Called by Nile when the rowset has changed
//

STDMETHODIMP
CDataLayerNotify::OnRowsetChange (IRowset *pRowset, DBREASON eReason,
                                    DBEVENTPHASE ePhase, BOOL)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::OnRowsetChange(%p, %p)",
             this, pRowset ));

    HRESULT hr = CheckCallbackThread();
    if (hr)
        goto Cleanup;

//$ ISSUE: (dinartem) Trident now calls ExecStop at the beginning of
//$         UnloadContents which causes OnRowsetChange to be called with a
//$         pRowset of NULL.
//$    Assert(pRowset);

    switch (eReason)
    {
    case DBREASON_ROWSET_CHANGED:
        if (ePhase == DBEVENTPHASE_DIDEVENT)        // only fire once
        {
            if (_pDLCEvents)
            {
                IGNORE_HR(_pDLCEvents->AllChanged());
            }
        }
        break;

    default:
        hr = DB_S_UNWANTEDREASON;
        break;
    }

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CDataLayerNotify::OnLowResource(DB_DWRESERVE dwReserved)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDataLayerNotify::OnProgress( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP ulOperation,
            /* [in] */ DBCOUNTITEM ulProgress,
            /* [in] */ DBCOUNTITEM ulProgressMax,
            /* [in] */ DBASYNCHPHASE ulStatusCode,
            /* [in] */ LPOLESTR pwszStatusText)
{
    HRESULT hr = CheckCallbackThread();
    if (hr)
        goto Cleanup;

    if (_pDLCEvents && ulStatusCode==DBASYNCHPHASE_POPULATION)
    {
        IGNORE_HR(_pDLCEvents->RowsAdded());
        // Fire PopulationComplete in the OnStop event..
    }

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CDataLayerNotify::OnStop( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ ULONG ulOperation,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LPOLESTR pwszStatusText)
{
    HRESULT hr = CheckCallbackThread();
    if (hr)
        goto Cleanup;

    MyDLC()->_fComplete = TRUE;

    if (_pDLCEvents)
    {
        // Add reason arguments soon..
        IGNORE_HR(_pDLCEvents->PopulationComplete());
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//  Member:     HandleError
//
//  Synopsis:   Error notification wrapper for Nile function calls,
//              notifies DL client of errors.
//
//  Arguments:  riid            IID of interface which was called
//              hr              HRESULT returned (may be success)
//
//  Returns:    HRESULT         hresult passed in
//

HRESULT
CDataLayerCursor::HandleError(REFIID riid, HRESULT hr)
{
    BOOL fSupportsErrorInfo = TRUE;
    
    if (SUCCEEDED(hr))
    {
        goto Cleanup;
    }

    if (!_pSupportErrorInfo
            || _pSupportErrorInfo->InterfaceSupportsErrorInfo(riid))
    {
        // to avoid any confusion, make sure we don't have ErrorInfo lying
        //  around for some other failuer.
        ::SetErrorInfo(0, NULL);
        fSupportsErrorInfo = FALSE;
    }
    
    if (_DLNotify._pDLCEvents)
    {
        IGNORE_HR(_DLNotify._pDLCEvents->OnNileError(hr, fSupportsErrorInfo));
    }

Cleanup:
    return hr;
}



//+---------------------------------------------------------------------------
//  Member:     CDataLayerCursorEvents::OnNileError
//
//  Synopsis:   Default implementation of OnError event sink.
//
//  Arguments:  HRESULT         hresult of error (must be failure code)
//              BOOL            indicates if ErrorInfo corresponds to error
//
//  Returns:    S_OK            error message/notification handled
//              S_FALSE         error message/notification not handled
//              E_*             unexpected error blocking message/notification
//

HRESULT
CDataLayerCursorEvents::OnNileError(HRESULT, BOOL)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\async.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  File:       stdevent.cxx
//  Author:     Charles Frankston (cfranks)
//
//  Contents:   IRowsetAsynch methods
//

//
//
#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

//+-----------------------------------------------------------------------
//
//  Member:    GetStatus (IDBAsynchStatus public member)
//
//  Synopsis:  Returns the fraction of an async rowset currently populated.
//             Since we don't know what portion of an async rowset remains
//             to be populated, we use a gross approximation:
//                - if the rowset is still being populated, return 1/2
//                - if the rowset is done, return count/count, or 1
//
//  Returns:   S_OK             all OK.
//

STDMETHODIMP
CImpIRowset::GetStatus(HCHAPTER hChapter, DBASYNCHOP ulOperation,
                       DBCOUNTITEM *pulProgress, DBCOUNTITEM *pulProgressMax,
                       DBASYNCHPHASE *pulStatusCode, LPOLESTR *ppwszStatusText)
{
    HRESULT hr = S_OK;
    DBCOUNTITEM lProgressDummy, lProgressMaxDummy;
    DBASYNCHPHASE lStatusCodeDummy;
    COSPData *pOSPData = GetpOSPData(hChapter);

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    if (ppwszStatusText)
        *ppwszStatusText = NULL;            // We don't support status text

    if (!pulProgress) pulProgress = &lProgressDummy;
    if (!pulProgressMax) pulProgressMax = &lProgressMaxDummy;
    if (!pulStatusCode) pulStatusCode = &lStatusCodeDummy;

    if (!pOSPData->_fPopulationComplete)
    {
        *pulStatusCode = DBASYNCHPHASE_POPULATION;
        *pulProgress = pOSPData->_cSTDRows;
        hr = GetpOSP(hChapter)->getEstimatedRows((DBROWCOUNT *)pulProgressMax);
        if (FAILED(hr) || *pulProgressMax==0)
            *pulProgressMax = 2 * pOSPData->_cSTDRows;    // Arbitrary
    }
    else
    {
        *pulProgress = pOSPData->_cSTDRows;
        // pulProgressMax might be used as the denominator of a ratio.
        // Best it never be zero..
        *pulProgressMax = *pulProgress ? *pulProgress : 1;
        *pulStatusCode = DBASYNCHPHASE_COMPLETE;
    }

Cleanup:
    return hr;
}
        
//+-----------------------------------------------------------------------
//
//  Member:    Abort (IDBAsynchStatus public member)
//
//  Synopsis:  Stops any asynch data transfer that may be in progress
//
//  Returns:   S_OK if the STD returned success
//             E_FAIL if not.
//
STDMETHODIMP
CImpIRowset::Abort(HCHAPTER	hChapter,
                   ULONG     ulOperation)
{
    HRESULT hr;

    if (GetpOSPData(hChapter) == NULL)
        hr = DB_E_BADCHAPTER;
    else if (SUCCEEDED(GetpOSP(hChapter)->stopTransfer()))
        hr = S_OK;
    else
        hr = E_FAIL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\include\dlayrc.h ===
To be removed

//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       dlayrc.h
//
//  Contents:   Resource identifiers for Dlay project.
//
//----------------------------------------------------------------------------
//
//  Resource identifier ranges.
//  See corerc.h for a complete listing of ranges used in Forms3.
//
//  09000 - 09999    dlay miscellaneous
//
//----------------------------------------------------------------------------

#ifndef __DLAYRC_H__
#define __DLAYRC_H__

#define IDS_DLAY_ERROR_BASE      8999

#define IDS_MSG_DB_CANTSAVE         (IDS_DLAY_ERROR_BASE + 1)

#define IDS_EE_DB_COERCE            (IDS_DLAY_ERROR_BASE + 2)
#define IDS_EE_DB_DELROW            (IDS_DLAY_ERROR_BASE + 3)
#define IDS_EE_DB_READ              (IDS_DLAY_ERROR_BASE + 4)
#define IDS_EE_DB_SCHEMA            (IDS_DLAY_ERROR_BASE + 5)
#define IDS_EE_DB_CANCELED          (IDS_DLAY_ERROR_BASE + 6)
#define IDS_EE_DB_OTHER_STATUS      (IDS_DLAY_ERROR_BASE + 7)

#endif // __DLAYRC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\change.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  Author:     Terry L. Lucas (TerryLu)
//
//  Contents:   CImpIRowsetChange object implementation
//


#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetChange specific interfaces
//
////////////////////////////////////////////////////////////////////////////////




//+-----------------------------------------------------------------------
//
//  Member:    DeleteRows (public member)
//
//  Synopsis:  Given an array of of HROWs, this will remove the rows from
//             the table.  Note that the rows, in the case of the STD, are
//             immediately removed.  If there are any errors, error
//             information will be returned to the user, provided the user
//              has allocated an array for the information.
//
//  Arguments: hReserved        future use.  Ignored
//             cRows            number of rows to delete
//             ahRows           an array of HROWs to remove
//              aRowStatus      array for errors, one per HROW (or NULL)
//
//  Returns:   Success           if inputs are valid.
//             E_INVALIDARG      if cRows>0 but ahRows is NULL
//             E_FAIL            if STD reports an error
//             DB_E_NOTREENTRANT illegal reentrancy
//             DB_S_ERRORSOCCURRED  something failed, but at least one row
//                                  was deleted
//

STDMETHODIMP
CImpIRowset::DeleteRows (HCHAPTER hChapter, DBCOUNTITEM cRows, const HROW ahRows[],
                         DBROWSTATUS aRowStatus[])
{
    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::DeleteRows(%p {%p, %u, %p, %p})",
              this, hChapter, cRows, ahRows, aRowStatus));

    HRESULT hr = S_OK;
    BOOL    fRowsDeleted = FALSE;           // were rows actually deleted
    BOOL    fRowsNotDeleted = FALSE;        // did any rows fail to delete
    const HROW *phRow = ahRows;                 // index for stepping HROWs

    if (cRows && !ahRows)                   // no input array
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (FAnyPhaseInProgress(DBREASON_ROW_DELETE)
            || FAnyPhaseInProgress(DBREASON_ROW_INSERT))
    {
        hr = DB_E_NOTREENTRANT;
        goto Cleanup;
    }

    if (GetpOSPData(hChapter) == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    // mark all the rows OK.  later events may change this
    LogErrors(aRowStatus, 0, cRows, DBROWSTATUS_S_OK);

    // we attempt to coalesce runs of consecutive ascending or descending rows,
    //  because our overhead in handling notifications will be much more
    //  manageable.
    while(cRows)
    {
        const HROW *phRowStartRun = phRow;
        DBCOUNTITEM ulRow;
        HRESULT hrT;
        HCHAPTER hChapter;              // chapter for this hRow

        hr = HROW2Index(*phRow, ulRow);
        if (hr)
        {
            // Advance loop variable, and log one error
            DBROWSTATUS dbs = hr==DB_E_DELETEDROW   ? DBROWSTATUS_E_DELETED
                                                    : DBROWSTATUS_E_INVALID;
            (++phRow, --cRows);

            LogErrors(aRowStatus, phRowStartRun-ahRows, 1, dbs);
            fRowsNotDeleted = TRUE;
            hr = S_OK;
        }
        else
        {
            DBCOUNTITEM ulRow2;
            DBCOUNTITEM cRowsRun;
            INT iDirection = 1; // algorithm works even if uninitialized, but
                                //  this keeps the compiler happy/
            DBROWCOUNT cRowsDeleted;

            hChapter = ChapterFromHRow((ChRow) *phRow);

            // Advance loop variables, continue advance if run length > 1
            phRow++;
            --cRows;
            if (cRows && !HROW2Index(*phRow, ulRow2))
            {
                iDirection = ulRow2 - ulRow;

                if (iDirection == 1 || iDirection == -1)
                {
                    // we've got a run!  Advance loop variables to past end.
                    for (;;)
                    {
                        DBCOUNTITEM ulRowTemp;

                        ulRow2 += iDirection;
                        if ((phRow++, --cRows) == 0)
                            break;
                        // Break this run if we ran off the end, changed chapter
                        // (not technically legal), or are simply not contiguous.
                        if (HROW2Index(*phRow, ulRowTemp) ||
                            ChapterFromHRow((ChRow) *phRow) != hChapter ||
                            ulRowTemp != ulRow2)
                        {
                            break;
                        }
                    }
                }
            }

            cRowsRun = (phRow - phRowStartRun);

            // Note that if cRowsRun == 1, then any value of iDirection
            //  produces identical results.  So it's OK that we may hit here
            //  with a garbage iDirection in certain circumstances.

            Assert(iDirection == -1 || iDirection == 1 || cRowsRun == 1);
            if (iDirection < 0)
                ulRow -= cRowsRun - 1;

            hrT = GetpOSP(hChapter)->deleteRows((LONG)ulRow, (LONG)cRowsRun, &cRowsDeleted);
            if (cRowsDeleted > 0)
                fRowsDeleted = TRUE;

            // Note that Indexes insides HROWs (CImpRows) should just
            //  have been fixed up!

            if (hrT)
            {
                fRowsNotDeleted = TRUE;
                Assert((DBROWCOUNT)cRowsDeleted != (DBROWCOUNT)cRowsRun);
                if (iDirection > 0)
                {
                    phRowStartRun += cRowsDeleted;
                }
                LogErrors(aRowStatus, phRowStartRun - ahRows,
                                cRowsRun - cRowsDeleted, DBROWSTATUS_E_CANCELED);
            }
            else
            {
                Assert((DBROWCOUNT)cRowsDeleted == (DBROWCOUNT)cRowsRun);
            }
        }
    }
Cleanup:
    if (hr == S_OK)     // no global errors - see whether row deletions worked
        hr = fRowsNotDeleted    ? fRowsDeleted  ? DB_S_ERRORSOCCURRED
                                                : DB_E_ERRORSOCCURRED
                                : S_OK;
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    InsertRow (public member)
//
//  Synopsis:  Create and initialize a new row in the STD.
//
//  Arguments: hChapter    chapter handle [IN]
//             hAccessor   Accessor to use [IN]
//             pData       Pointer to buffer of data to set [IN]
//             phRow       Row Handle [OUT]
//
//  Returns:   S_OK                    if data changed successfully
//             E_FAIL                  if Catch all (NULL pData, etc.)
//             E_INVALIDARG            if pcErrors!=NULL and paErrors==NULL
//             E_OUTOFMEMORY           if output error array couldn't be allocated
//             DB_E_BADACCESSORHANDLE  if invalid accessor
//             DB_E_BADCHAPTER         if chapter passed in
//

STDMETHODIMP
CImpIRowset::InsertRow(HCHAPTER   hChapter,
                        HACCESSOR  hAccessor, void *pData,
                        HROW      *phRow )
{
    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::InsertRow(%p {%p %p})",
              this, hAccessor, pData ));
    return SetNewDataAfter(hChapter, 1, &g_bBmkLast,
                           hAccessor, (BYTE*)pData, phRow );
}


//+-----------------------------------------------------------------------
//
//  Member:     SetData (public member)
//
//  Synopsis:   Sets new data values into fields of a row.
//
//  Arguments:  hRow        Row Handle [IN]
//              hAccessor   Accessor to use [IN]
//              pData       Pointer to buffer of data to set [IN/OUT]
//
//  Returns:    S_OK                    Data changed successfully
//              DB_S_ERRORSOCCURRED     Parital success
//              DB_E_ERRORSOCCURRED     All columns failed
//              DB_E_BADACCESSORHANDLE  Invalid accessor
//              DB_E_BADROWHANDLE       Bad HROW (0)
//              E_FAIL                  Catch all (including out-of-mem)
//              DB_E_NOTREENTRANT       Illegal reentrancy
//
//  Sets status field (in *pData) for each column that has one

STDMETHODIMP
CImpIRowset::SetData (HROW hRow, HACCESSOR hAccessor, void* pData)
{
    TraceTag((tagNileRowsetProvider,
             "IRowsetChange::SetData(%p {%p, %p, %p})",
             this, hRow, hAccessor, pData ));

    HRESULT         hr;
    HRESULT         hrLastFailure;
    AccessorFormat  *pAccessor;
    ULONG           cBindings;
    DBBINDING       *pBinding;
    ULONG           ibind;
    ULONG           ulErrorCount = 0;
    DBCOUNTITEM     uStdRow;
    HCHAPTER        hChapter;

    // check that accessor is valid
    pAccessor = (AccessorFormat *)hAccessor;
    if (pAccessor == NULL)
    {
        hr = DB_E_BADACCESSORHANDLE;
        goto Cleanup;
    }
    if (!(pAccessor->dwAccFlags & DBACCESSOR_ROWDATA))
    {
        hr = DB_E_BADACCESSORTYPE;
        goto Cleanup;
    }

    cBindings = pAccessor->cBindings;
    pBinding  = pAccessor->aBindings;

    // check that hrow is valid
    hr = HROW2Index(hRow, uStdRow);
    if (hr)
    {
        goto Cleanup;
    }

    hChapter = ChapterFromHRow((ChRow) hRow);

    // Ensure a place to put data, unless the accessor is the null accessor then
    // a NULL pData is okay.
    if (pData == NULL && cBindings > 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Apply accessor to data.
    for (ibind = 0; ibind < cBindings; ++ibind)
    {
        XferInfo        xInfo;
        DBBINDING &     currBinding = pBinding[ibind];
        DBPART          dwPart = currBinding.dwPart;
        ULONG           iord = currBinding.iOrdinal;
        CSTDColumnInfo &stdColInfo = _astdcolinfo[ColToDBColIndex(iord)];
        DBLENGTH        dblenDummyLength;
        DBSTATUS        dbDummyStatus;

        xInfo.dwDBType = stdColInfo.dwType;
        xInfo.dwAccType = currBinding.wType;

        xInfo.pData = dwPart & DBPART_VALUE ?
            ((BYTE *)pData + currBinding.obValue) : NULL;
        xInfo.pdblenXferLength = dwPart & DBPART_LENGTH ?
            (DBLENGTH *)((BYTE *)pData + currBinding.obLength) : &dblenDummyLength;
        xInfo.pdbStatus = dwPart & DBPART_STATUS ?
            (DBSTATUS *)((BYTE *)pData + currBinding.obStatus) : &dbDummyStatus;
        xInfo.dblenDataMaxLength = stdColInfo.cbMaxLength;

        // check that the accessor is allowed to write to this column
        if (!(stdColInfo.dwFlags & DBCOLUMNFLAGS_WRITE) )
        {
            *xInfo.pdbStatus = DBROWSTATUS_E_PERMISSIONDENIED;
            ++ ulErrorCount;
            continue;
        }

        hr = DataCoerce(DataToProvider, hChapter, uStdRow, iord, xInfo);

        if (hr)
        {
            Assert(FAILED(hr));
            hrLastFailure = hr;
            ++ ulErrorCount;
        }
    }

    hr = ulErrorCount == 0 ?            S_OK :
         ulErrorCount == cBindings ?    DB_E_ERRORSOCCURRED :
                                        DB_S_ERRORSOCCURRED;

Cleanup:
    Assert(hr != E_OUTOFMEMORY);    // would conflict with Nile spec
    return hr;
}



//+-----------------------------------------------------------------------
//
//  Member:    LogErrors (private member)
//
//  Synopsis:  Helper function to fill in an array of DBROWSTATUS objects
//
//  Arguments: aRowStatus       array of DBROWSTATUSs, one per HROW.  If this
//                              is 0, this routine does nothing.
//             iFirstRow        index of first row to log error
//             cErrorRows       number of rows to log errors for
//             dbrsStatus       What status code to return for each HROW
//
//  Returns:   nothing
//

void
CImpIRowset::LogErrors(DBROWSTATUS aRowStatus[], DBCOUNTITEM iFirstRow, DBCOUNTITEM cErrorRows,
                       DBROWSTATUS dbrs)
{
    if (aRowStatus) {
        for ( ; cErrorRows>0; --cErrorRows, ++iFirstRow)
        {
            aRowStatus[iFirstRow] = dbrs;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\coerce.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  File:       coerce.cxx
//  Author:     Terry L. Lucas (TerryLu)
//
//  Contents:   Implemenation of data coercion for CImpIRowset object.
//


#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

MtDefine(CImpIRowsetDataCoerce_pData, DataBind, "CImpIRowset::DataCoerce pData")

////////////////////////////////////////////////////////////////////////////////
//
//  Internal support routines:
//
////////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//  Member:     CanConvert (public member)
//
//  Synopsis:   Inform our client about the type conversions we support
//
//  Arguments:  dwSrcType               Source data type
//              dwDstType               Destination data type
//              dwConvertFlags          0x0 for Rowset conversion
//                                      0x1 for Command conversion (irrevelant)
//
//  Returns:    S_OK                    Can convert
//              S_FALSE                   Unable to convert
//
STDMETHODIMP
CImpIRowset::CanConvert(DBTYPE wFromType,
                        DBTYPE wToType,
                        DBCONVERTFLAGS dwConvertFlags)
{
    HRESULT hr;

    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::CanConvert(%p {%p, %l, %l, %l})",
              this, wFromType, wToType, dwConvertFlags));

    if (dwConvertFlags != DBCONVERTFLAGS_COLUMN)
    {
        hr = DB_E_BADCONVERTFLAG;
        goto Cleanup;
    }
    
    // We can intraconvert any of these.
    hr = ((wFromType == DBTYPE_VARIANT    ||
           wFromType == DBTYPE_STR     ||
           wFromType == DBTYPE_BSTR    ||
           wFromType == DBTYPE_WSTR )  && (wToType == DBTYPE_VARIANT ||
                                           wToType == DBTYPE_STR     ||
                                           wToType == DBTYPE_BSTR    ||
                                           wToType == DBTYPE_WSTR ))
         ? S_OK : S_FALSE;

Cleanup:
    return hr;
}

#ifdef NEVER
//+---------------------------------------------------------------------------
//  Member:     DataCoerce_STR (private member)
//
//  Synopsis:   Convert source data type to a string buffer in pSrc.
//
//  Arguments:  uRow                    Current row
//              uCol                    Current column
//              fBSTR                   Keep the BSTR allocated in fact pDst
//                                      wants the BSTR address.
//              xferData                Information necessary to get/set data
//
//  Returns:    None
//

void
CImpIRowset::DataCoerce_STR (HCHAPTER hChapter, ULONG uRow, ULONG uCol,
                             BOOL fBSTR, XferInfo & xferData )
{
    HRESULT     hr;
    DBLENGTH    dblenBuffMaxCharLen;
    VARIANTARG  vari;
    VARIANTARG  variChange;
    VARIANTARG  *pVar = &variChange;

    *xferData.pdblenXferLength = 0;

    FastVariantInit(&vari);
    FastVariantInit(&variChange);

    // Get the string value of the cell..
    hr = GetpOSP(hChapter)->getVariant(uRow, uCol, OSPFORMAT_FORMATTED, &vari);
    if (hr)
    {
        *xferData.pdbStatus = DBSTATUS_E_CANTCREATE;
        goto Cleanup;
    }

    // Compute the max # of characters capable of being in pData.
    dblenBuffMaxCharLen = xferData.dblenDataMaxLength / sizeof(TCHAR);

    Assert(dblenBuffMaxCharLen);                    // Can't be zero.

    switch (vari.vt)
    {
    case VT_EMPTY:
        // Former code.  See bug 7640.  (AndrewL)
        // Assert(!"Uninitialized rowset element (VT_EMPTY).");
        //*xferData.pwStatus = DBSTATUS_CANTCONVERTVALUE;
        //goto Cleanup;
        //
        // Fall through. This says that an uninitialized array of any size
        // is treated as though it were prefilled with nulls, which is 
        // pretty close to typical database behavior. 

    case VT_NULL:
        hr = S_FALSE;                           // Signal NULL data.
        break;

    case VT_BSTR:
    {
        if (!fBSTR)
        {
            pVar = &vari;
        }
        else
        {
            // Return the BSTR.
            *(BSTR *)xferData.pData = vari.bstrVal;
        }
        hr = S_OK;
        break;
    }

    default:
        Assert(!"getVariant didn't return BSTR!");        
        *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
        goto Cleanup;
    }

    if (!hr)
    {
        // BSTR to free?
        if (fBSTR)
        {
            // No, we're keeping the BSTR therefore, the size is BSTR
            *xferData.pdbStatus = DBSTATUS_S_OK;
            *xferData.pdblenXferLength = sizeof(BSTR *);
        }
        else if (pVar->vt == VT_BSTR)
        {
            // Yes, don't return the BSTR copy it to the buffer passed.
            DBLENGTH cDataSz = SysStringLen(pVar->bstrVal);
            DBLENGTH dblenActual = (cDataSz < dblenBuffMaxCharLen) ? cDataSz :
                                                            dblenBuffMaxCharLen - 1;

            _tcsncpy((TCHAR *)xferData.pData, (TCHAR *)(pVar->bstrVal), dblenActual);
            ((TCHAR *)xferData.pData)[dblenActual] = _T('\0');

            SysFreeString(pVar->bstrVal);           // Release the BSTR.

            if (dblenBuffMaxCharLen > cDataSz)
            {
                *xferData.pdbStatus = DBSTATUS_S_OK;

                // Number of bytes.
                *xferData.pdblenXferLength = cDataSz * sizeof(TCHAR);
            }
            else
            {
                *xferData.pdbStatus = DBSTATUS_S_TRUNCATED;

                // Number of bytes.
                *xferData.pdblenXferLength = xferData.dblenDataMaxLength;
            }
        }
        else
        {
            Assert(!"Should never get here, if so bigger problem above.");
            *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
        }
    }
    else if (hr == S_FALSE)
    {
        // NULL value.
        *((TCHAR *)xferData.pData) = _T('\0');

        *xferData.pdbStatus = DBSTATUS_S_ISNULL;
    }
    else
    {
        *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
    }

Cleanup:
    ;
}
#endif


//+---------------------------------------------------------------------------
//  Member:     DataToWSTR (private member)
//
//  Synopsis:   Helper function to fetch or set WSTR data.  This is needed 3
//              times in DataCoerce, so we moved the common code out to this
//              routine.
//
//  Arguments:  dDirection              Get/Set the data to/from provider
//              hChapter                Chapter handle
//              uRow                    Row number
//              uCol                    Column number
//              xferData                Information used to get/set data
//
//  Returns:    Values based on Nile spec for GetData and SetData:
//              S_OK                    if everything is fine (or NULL)
//              DB_E_UNSUPPORTEDCONVERSION Could not coerce a column value
//              E_OUTOFMEMORY           Out of Memory (GetData only)
//              E_FAIL                  Serious conversion problems
//

HRESULT
CImpIRowset::DataToWSTR (DATA_DIRECTION dDirection, HCHAPTER hChapter,
                         ULONG uRow, ULONG uCol, XferInfo & xferData)
{
    HRESULT hr=S_OK;
    VARIANT tempVar;
    DBLENGTH dblenDataMaxChar;
    DBLENGTH dblenXferSize;

    *xferData.pdbStatus = DBSTATUS_S_OK;

    // Do we have data to set/get?
    if (xferData.pData != NULL)
    {
        if (dDirection == DataFromProvider)
        {
            dblenDataMaxChar = xferData.dblenDataMaxLength / sizeof(OLECHAR);
            
            FastVariantInit(&tempVar);
            hr = GetpOSP(hChapter)->getVariant(uRow, uCol, OSPFORMAT_FORMATTED, &tempVar);

            if (hr == S_OK && tempVar.vt==VT_BSTR)
            {
                *xferData.pdblenXferLength = SysStringLen(tempVar.bstrVal);
                dblenXferSize = min(*xferData.pdblenXferLength,
                                dblenDataMaxChar ? dblenDataMaxChar-1 : 0);
                _tcsncpy((TCHAR *)xferData.pData, tempVar.bstrVal, dblenXferSize);

                // NULL terminate the string.
                if (dblenDataMaxChar)
                {
                    ((OLECHAR *)xferData.pData)[dblenXferSize] = _T('\0');
                }
                
                // Let our consumer know if we had more data than we could
                // transfer.
                if (*xferData.pdblenXferLength > dblenXferSize)
                    *xferData.pdbStatus = DBSTATUS_S_TRUNCATED;
            }
            else
            {
                *((OLECHAR *)xferData.pData) = _T('\0');        // NULL value.
                if (hr==S_FALSE || (hr==S_OK && tempVar.vt!=VT_BSTR))
                {
                    *xferData.pdbStatus = DBSTATUS_S_ISNULL;
                    *xferData.pdblenXferLength = 0;
                    if (hr==S_OK)
                        VariantClear(&tempVar);
                    hr = S_OK;              // This is not an error to our caller.
                }
                else                                                    // failure
                {
                    // getVariant failed.  Assume it was unable
                    // to perform the conversion.
                    *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
                }
            }
        }
        else
        {
            FastVariantInit(&tempVar);
            // We now also deal with the case of SETTING a DBSTATUS_ISNULL..
            if (*xferData.pdbStatus!=DBSTATUS_S_ISNULL)
            {
                tempVar.vt = VT_BSTR;
                tempVar.bstrVal = SysAllocString((OLECHAR *)xferData.pData);
                if (tempVar.bstrVal == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                hr = GetpOSP(hChapter)->setVariant(uRow, uCol, OSPFORMAT_FORMATTED,
                                       tempVar);
                *xferData.pdblenXferLength = SysStringLen(tempVar.bstrVal);
                VariantClear(&tempVar);
            }
            else
            {
                tempVar.vt = VT_NULL;
                hr = GetpOSP(hChapter)->setVariant(uRow, uCol, OSPFORMAT_RAW, tempVar);
            }

        }

        if (hr)
            *xferData.pdbStatus = DBSTATUS_E_CANTCREATE;
    }

    // The buffer length is always byte count not character count.
    // NOTE: The OLE-DB spec says DON'T COUNT THE NULL!!
    *xferData.pdblenXferLength = (*xferData.pdblenXferLength) * sizeof(OLECHAR);

Cleanup:
    return hr;
}
    

//+---------------------------------------------------------------------------
//  Member:     DataCoerce (private member)
//
//  Synopsis:   Convert the source data to the destination's format.  The
//              xferData describes the data to get/set, max length of the data,
//              and the status and length of data set/get.
//
//              Because STD mapper deals with only strings and variants, only
//              possible values for *xferData.pwStatus are DBSTATUS_OK,
//              DBSTATUS_ISNULL, DBSTATUS_CANTCONVERTVALUE,
//              and DBSTATUS_CANTCREATE.
//
//
//  Arguments:  dDirection              Get/Set the data to/from provider
//              hChapter                Chapter handle
//              uRow                    Row number
//              uCol                    Column number
//              xferData                Information used to get/set data
//
//  Returns:    Values based on Nile spec for GetData and SetData:
//              S_OK                    if everything is fine (or NULL)
//              DB_E_UNSUPPORTEDCONVERSION Could not coerce a column value
//              E_OUTOFMEMORY           Out of Memory (GetData only)
//              E_FAIL                  Serious conversion problems
//

HRESULT
CImpIRowset::DataCoerce (DATA_DIRECTION dDirection, HCHAPTER hChapter,
                         ULONG uRow, ULONG uCol, XferInfo & xferData)
{
    HRESULT hr = S_OK;
    WCHAR wchBuf[128];      // intermediate buffer to recieve WSTR.
    DBLENGTH dblenXferLength;   // length of intermediate WSTR received.
    XferInfo xferBuf;       // intermediate (WSTR) xfer info.

    xferBuf.pData = wchBuf;     // first xfer will be to intermediate

    // Do not allow the destination length and status to be aliased.
    Assert((void*)xferData.pdblenXferLength != (void*)xferData.pdbStatus);

    // We don't use arrays or byref of things. 
    if ( (xferData.dwAccType & DBTYPE_ARRAY) ||
         (xferData.dwAccType & DBTYPE_BYREF) ||
         (xferData.dwDBType  & DBTYPE_ARRAY) ||
         (xferData.dwDBType  & DBTYPE_BYREF) )
    {
        *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
        goto Cleanup;
    }


    *xferData.pdbStatus = DBSTATUS_S_OK;

    switch (xferData.dwAccType)
    {

    case DBTYPE_VARIANT:
    {
        VARIANTARG *pVar = (VARIANTARG *)xferData.pData;

        if (xferData.pData != NULL)
        {
            if (dDirection == DataFromProvider)
            {
                FastVariantInit(pVar);      // for bad VB providers
                hr = GetpOSP(hChapter)->getVariant(uRow, uCol, OSPFORMAT_RAW, pVar);
            }
            else
            {
                hr = GetpOSP(hChapter)->setVariant(uRow, uCol, OSPFORMAT_RAW, *pVar);
            }

            *xferData.pdbStatus = hr ? DBSTATUS_E_CANTCREATE :
                                       DBSTATUS_S_OK;
        }
        
        // Just get the size of the string.
        *xferData.pdblenXferLength = sizeof(VARIANT);
        break;
    }

    case DBTYPE_BSTR:
        // Do we have data to set/get?
        if (xferData.pData == NULL)
            break;

        if (dDirection == DataFromProvider)
        {
            VARIANT tempVar;
            FastVariantInit(&tempVar);      // for bad VB providers
            hr = GetpOSP(hChapter)->getVariant(uRow, uCol, OSPFORMAT_FORMATTED, &tempVar);

            if (hr == S_OK && tempVar.vt == VT_BSTR)    // we got what we asked for
            {
                *(BSTR *)xferData.pData = tempVar.bstrVal;  // copy the BSTR ptr
            }
            else
            {
                *(BSTR *)xferData.pData = NULL;     // for people who ignore status
                // TODO The MFC-based TDC control returns DISP_E_TYPEMISMATCH when
                // asked for values from missing columns.  Treat as null for now.
                if (hr==DISP_E_TYPEMISMATCH ||
                    hr==S_FALSE || (hr==S_OK && tempVar.vt!=VT_BSTR))   // NULL
                {
                    *xferData.pdbStatus = DBSTATUS_S_ISNULL;
                    if (hr == S_OK)
                        VariantClear(&tempVar);
                }
                else                                                    // failure
                {
                    // getVariant failed.  Assume it was unable
                    // to perform the conversion.
                    *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
                }
            }
            *xferData.pdblenXferLength = sizeof(BSTR);
        }
        else
        {
            // else dDirection==DataToProvider ..
            VARIANT tempVar;
            tempVar.vt = VT_BSTR;
            tempVar.bstrVal = *(BSTR *)xferData.pData;
            hr = GetpOSP(hChapter)->setVariant(uRow, uCol, OSPFORMAT_FORMATTED, tempVar);
            if (FAILED(hr))
            {
                *xferData.pdbStatus = DBSTATUS_E_CANTCREATE;
            }
        }

        break;

    case DBTYPE_WSTR:
        // The whole DBTYPE_WSTR case contained a lot of code needed in
        // common with DBTYPE_STR, so its a subroutine here..
        hr = DataToWSTR (dDirection, hChapter, uRow, uCol, xferData);
        break;

    case DBTYPE_STR:
        xferBuf.pdblenXferLength = &dblenXferLength;
        xferBuf.dblenDataMaxLength = sizeof(wchBuf);
        xferBuf.pdbStatus = xferData.pdbStatus; // borrow client's status word

        // If we're setting data into the STD, then that data must be WSTR
        if (dDirection == DataToProvider)
        {
            // Get length of incoming char string in narrow chars (incl nul).
            dblenXferLength = strlen((char *) xferData.pData) + 1;

            // If there's any Chance the narrow char version won't fit in
            // wchBuf (worst case -- all single byte chars).
            if (dblenXferLength*sizeof(WCHAR) > sizeof(wchBuf))
            {
                xferBuf.dblenDataMaxLength = dblenXferLength;
                // then allocate a buffer instead
                xferBuf.pData = new(Mt(CImpIRowsetDataCoerce_pData)) WCHAR[dblenXferLength];
                if (!xferBuf.pData) // if alloc failed, quit, partial
                {                   // transfers are not desirable.
                    *xferData.pdbStatus = DBSTATUS_E_CANTCREATE;
                    goto Cleanup;
                }
            }
                
            // Do the conversion to wide char into our buffer.
            // Note after this piont ulXferLength becomes a WCHAR count!
            dblenXferLength =
                 MultiByteToWideChar(CP_ACP, 0,              // CP & flags
                                     (char *)xferData.pData, // STR
                                     dblenXferLength,        // STR len
                                     (WCHAR *)xferBuf.pData, // WSTR
                                     (xferBuf.dblenDataMaxLength/
                                      sizeof(WCHAR))); // WSTR buf size

            
            // MultiByteToWideChar has a peculiar way of indicating errors
            if (xferBuf.dblenDataMaxLength!=0 && dblenXferLength==0)
            {
                if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
                {
                    *xferData.pdbStatus = DBSTATUS_S_TRUNCATED;
                }
                goto Cleanup;
            }

            // *xferData.pulXferLength is a byte count, make sure to *2..
            *xferData.pdblenXferLength = dblenXferLength*sizeof(WCHAR);
            break;
        }

        // NOTE! This DataToWSTR call is shared by the To & From cases!
        hr = DataToWSTR (dDirection, hChapter, uRow, uCol, xferBuf);

        if (dDirection == DataFromProvider)
        {
            if (FAILED(hr))     // Note truncation is not considered failure!
            {
                // If our intermediate xfer failed, return error codes            
                // xferData.pdbStatus already set.
                *xferData.pdblenXferLength = dblenXferLength;
                break;
            }

            // If our internal buffer wasn't big enough we need to allocate
            // Note that ulXferLength here is in Bytes (set by DataToWSTR above)
            if (dblenXferLength > sizeof(wchBuf))
            {
                xferBuf.pData = new(Mt(CImpIRowsetDataCoerce_pData)) WCHAR[dblenXferLength/sizeof(WCHAR)];
                if (!xferBuf.pData)
                {
                    *xferData.pdbStatus = DBSTATUS_E_CANTCREATE;                    
                    goto Cleanup;
                }
                hr = DataToWSTR (dDirection, hChapter, uRow, uCol, xferBuf);
                if (FAILED(hr))
                    goto Cleanup;
            }

            *xferData.pdblenXferLength =
                 WideCharToMultiByte(CP_ACP, 0,                 // CP & flags
                                     (WCHAR *)xferBuf.pData,    // WSTR
                                     -1,                // WSTR len (null-terminated)
                                     (char *)xferData.pData,    // STR
                                     xferData.dblenDataMaxLength,  // STR buf size
                                     NULL, NULL);        // Default char & flag

            // WideCharToMultiByte has a peculiar way of indicating errors
            if (xferData.dblenDataMaxLength!=0 && *xferData.pdblenXferLength==0)
            {
                if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
                {
                    *xferData.pdbStatus = DBSTATUS_S_TRUNCATED;
                    // An even more peculiar way of getting the actual length req'd.
                    *xferData.pdblenXferLength =
                         WideCharToMultiByte(CP_ACP, 0,       // CP & flags
                                             (WCHAR *)xferBuf.pData, // WSTR
                                             dblenXferLength, // WSTR len
                                             NULL,            // STR (not used)
                                             0,               // STR len
                                             NULL, NULL);   // Default char & flag
                }
            }
            else
            {   // WideCharToMultiByte counts the terminating null character, but
                // OLE-DB doesn't
                -- *xferData.pdblenXferLength;
            }
        }
        break;

    default:
        //Assert(! "Unknown destination data type in DataCoerce.");
        *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
        break;
    }

Cleanup:
    if (xferBuf.pData!=wchBuf)
    {
        delete xferBuf.pData;
    }

    switch (*xferData.pdbStatus)
    {
    case DBSTATUS_S_OK:
    case DBSTATUS_S_ISNULL:
        hr = S_OK;
        break;
    case DBSTATUS_E_CANTCREATE:
        hr = (dDirection == DataFromProvider) ? E_OUTOFMEMORY : E_FAIL;
        break;
    case DBSTATUS_S_TRUNCATED:
        hr = S_OK;
        break;
    default:
        hr = DB_E_UNSUPPORTEDCONVERSION;
        break;
    }

    RRETURN1(hr, DB_E_UNSUPPORTEDCONVERSION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\delete.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      delete.cxx
//  Authors:   Jerry Dunietz (jerryd@microsoft.com)
//             Ido Ben-Shachar (t-idoben@microsoft.com)
//
//  Contents:  Implementation of RowsetDelete
//
//------------------------------------------------------------------------

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetDelete specific interface
//
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\property.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Author:     Sam Bent (sambent)
//
//  Contents:   CDBProperties object implementation
//
//  History:
//  07/31/96    SamBent     Creation

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

DeclareTag(tagDBProperties, "CDBProperties", "OLE_DB provider properties");

MtDefine(CDBProperties, DataBind, "CDBProperties")
MtDefine(CDBProperties_aPropSets, CDBProperties, "CDBProperties::_aPropSets")
MtDefine(CDBProperties_rgProperties, CDBProperties, "CDBProperties::_aPropSets::_rgProperties")

////////////////////////////////////////////////////////////////////////////////
//
//  CDBProperties specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//  Member:     constructor (public member)
//
//  Synopsis:   instantiate a CDBProperties
//
//  Arguments:  none

CDBProperties::CDBProperties():
	_cPropSets(0),
	_aPropSets(0)
{
    TraceTag((tagDBProperties,
             "CDBProperties::constructor -> %p", this ));
}


//+---------------------------------------------------------------------------
//  Member:     destructor (public member)
//
//  Synopsis:   release storage used by CDBProperties

CDBProperties::~CDBProperties()
{
    TraceTag((tagDBProperties,
             "CDBProperties::destructor -> %p", this ));

	ULONG iPropSet;
	for (iPropSet=0; iPropSet<_cPropSets; ++iPropSet)
	{
		delete [] _aPropSets[iPropSet].rgProperties;
	}
	delete [] _aPropSets;
}


//+---------------------------------------------------------------------------
//  Member:     GetPropertySet (public member)
//
//  Synopsis:   look up a property set by its GUID
//
//  Arguments:  guid            GUID of desired property set
//
//  Returns:    pointer to desired property set, or 0 if not found

DBPROPSET*
CDBProperties::GetPropertySet(const GUID& guid) const
{
    TraceTag((tagDBProperties,
             "CDBProperties::GetPropertySet({%p} %p)", this, guid ));

	DBPROPSET* pPropSet = 0;		// the answer, assume not found
	
	// linear search
	ULONG iPropSet;
	for (iPropSet=0; iPropSet<_cPropSets; ++iPropSet)
	{
		if (IsEqualGUID(guid, _aPropSets[iPropSet].guidPropertySet))
		{
			pPropSet = &_aPropSets[iPropSet];
			break;
		}
	}

	return pPropSet;
}


//+---------------------------------------------------------------------------
//  Member:     CopyPropertySet (public member)
//
//  Synopsis:   make a copy of a property set, given its GUID
//
//  Arguments:  guid            GUID of desired property set
//              pPropSetDst     ptr to DBPROPSET where copy should go
//
//  Returns:    S_OK            it worked
//              E_OUTOFMEMORY   no bytes
//              E_FAIL          no property set for given GUID

HRESULT
CDBProperties::CopyPropertySet(const GUID& guid, DBPROPSET* pPropSetDst) const
{
    TraceTag((tagDBProperties,
             "CDBProperties::CopyPropertySet({%p} %p, %p)", this, guid, pPropSetDst ));
    Assert(pPropSetDst && "must supply a PropSet pointer");

    HRESULT hr = S_OK;
	const DBPROPSET* pPropSetSrc = GetPropertySet(guid);
	ULONG iProp;

    if (pPropSetSrc == 0)       // not found
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // start with shallow copy
    *pPropSetDst = *pPropSetSrc;
    
    // allocate property array
    pPropSetDst->rgProperties = (DBPROP*)
                    CoTaskMemAlloc(pPropSetSrc->cProperties * sizeof(DBPROP));
    if (pPropSetDst->rgProperties == 0)
    {
        pPropSetDst->cProperties = 0;       // defensive
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // copy the property array
    for (iProp=0; iProp<pPropSetSrc->cProperties; ++iProp)
    {
        pPropSetDst->rgProperties[iProp] = pPropSetSrc->rgProperties[iProp];
    }
    
Cleanup:
	return hr;
}


//+---------------------------------------------------------------------------
//  Member:     GetProperty (public member)
//
//  Synopsis:   look up a property by its property set GUID and ID.
//
//  Arguments:  guid            guid of desired property
//              dwId            id of desired property
//
//  Returns:    pointer to DBPROP for the property, or 0 if not found

const DBPROP*
CDBProperties::GetProperty(const GUID& guid, DBPROPID dwId) const
{
    TraceTag((tagDBProperties,
             "CDBProperties::GetProperty({%p} %p, %lu)", this, guid, dwId ));

	ULONG iProp;
	const DBPROPSET* pPropSet = GetPropertySet(guid);
	const DBPROP*	pProp = 0;		// the answer, assume not found

	if (pPropSet == 0)			// no properties for desired property set
		goto Cleanup;
	
	// look up the desired property in the property set
	for (iProp=0; iProp<pPropSet->cProperties; ++iProp)
	{
		if (dwId == pPropSet->rgProperties[iProp].dwPropertyID)
		{
			pProp = & pPropSet->rgProperties[iProp];
			break;
		}
	}

Cleanup:
	return pProp;
}


//+---------------------------------------------------------------------------
//  Member:     SetProperty (public member)
//
//  Synopsis:   add a new property, or reset an existing one
//
//  Arguments:  guid			property set GUID of desired property
//								prop.dwPropertyID contains its ID.
//				prop			(reference to) DBPROP describing new property.
//
//  Returns:    S_OK            property added/reset
//              E_OUTOFMEMORY   no memory for new property set or new property

HRESULT
CDBProperties::SetProperty(const GUID& guid, const DBPROP& prop)
{
    TraceTag((tagDBProperties,
             "CDBProperties::SetProperty({%p}, %p, %p)", this, guid, prop ));

	HRESULT hr;
	DBPROP *pProp;			// pointer to array entry for new property
	ULONG iProp;
	DBPROPSET* pPropSet = GetPropertySet(guid);

	if (pPropSet == 0)				// no properties yet in desired property set
	{
		ULONG iPropSet;
		
		// get a new property set array
		DBPROPSET * aNewPropSets = new(Mt(CDBProperties_aPropSets)) DBPROPSET[_cPropSets + 1];
		if (aNewPropSets == 0)
		{
			hr = E_OUTOFMEMORY;
			goto Cleanup;
		}

		// copy the old array into the new
		for (iPropSet=0; iPropSet<_cPropSets; ++iPropSet)
		{
			aNewPropSets[iPropSet] = _aPropSets[iPropSet];
		}

		// add the new property set
		pPropSet = & aNewPropSets[_cPropSets];
		pPropSet->guidPropertySet = guid;
		pPropSet->cProperties = 0;
		pPropSet->rgProperties = 0;

		// release the old array, install the new one
		delete [] _aPropSets;
		_aPropSets = aNewPropSets;
		++ _cPropSets;
	}

	// look for the desired property.
	pProp = 0;
	for (iProp=0; iProp<pPropSet->cProperties; ++iProp)
	{
		if (pPropSet->rgProperties[iProp].dwPropertyID == prop.dwPropertyID)
		{
			pProp = &pPropSet->rgProperties[iProp];
			break;
		}
	}

	// if it's a new property, add it.  OLE-DB doesn't provide for any "unused"
	// portion in the array of DBPROPS, so we must reallocate the array every
	// time we add a property.  
	if (pProp == 0)
	{
		// allocate new property array
		DBPROP* aNewProperties = new(Mt(CDBProperties_rgProperties)) DBPROP[pPropSet->cProperties + 1];
		if (aNewProperties == 0)
		{
			hr = E_OUTOFMEMORY;
			goto Cleanup;
		}

		// copy old array into new
		for (iProp=0; iProp<pPropSet->cProperties; ++iProp)
		{
			aNewProperties[iProp] = pPropSet->rgProperties[iProp];
		}

		// prepare to use new property entry
		pProp = & aNewProperties[pPropSet->cProperties];

		// release old array, install new
		delete [] pPropSet->rgProperties;
		pPropSet->rgProperties = aNewProperties;
		++ pPropSet->cProperties;
	}

	// copy the property into my array
	*pProp = prop;

	hr = S_OK;

Cleanup:
	RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\locate.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      locate.cxx
//  Author:    Ted Smith
//
//  Contents:  Implementation of RowsetLocate
//
//------------------------------------------------------------------------

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetLocate specific interfaces
//
////////////////////////////////////////////////////////////////////////////////

//+-----------------------------------------------------------------------
//
//  Member:    Bookmark2HRowNumber (private member)
//
//  Synopsis:  Figure out what a row number from a bookmark, given
//             arguments passed to various Nile methods.
//
//  Arguments: cbBookmark       number of bytes in the bookmark
//             pBookmark        pointer to bookmark
//             rulRow           where to return row number
//
//  Returns:   S_OK             all OK.
//             DB_S_BOOKMARKSKIPPED if initial bookmark referred to
//                              to a deleted row
//             DB_E_BADBOOKMARK bad bookmark: malformed, row 0,
//                              or row > 0x7fffffff
//

HRESULT
CImpIRowset::Bookmark2HRowNumber(HCHAPTER hChapter, DBBKMARK cbBookmark,
                                 const BYTE *pBookmark, DBCOUNTITEM &rulRow)
{
    HRESULT hr = S_OK;
    DBCOUNTITEM ulRow;
    
    if (!pBookmark)
    {
        goto BadBookmark;
    }

    if (cbBookmark == 1)
    {
        if (*pBookmark == DBBMK_FIRST)
        {
            ulRow = 1;
        }
        else if (*pBookmark == DBBMK_LAST)
        {
            COSPData *pOSPData = GetpOSPData(hChapter);
            if (pOSPData)
            {
                ulRow = pOSPData->_cSTDRows;
            }
            else
            {
                hr = DB_E_BADCHAPTER;
                goto Cleanup;
            }
        }
        else
        {
            goto BadBookmark;
        }
    }
    else if (cbBookmark == sizeof(ULONG))
    {
        ulRow = IndexFromHRow((ChRow)(HROW)(* (ULONG *) pBookmark));
        if (FhRowDeleted((ChRow)(HROW)(* (ULONG *) pBookmark)))
        {
            hr = DB_S_BOOKMARKSKIPPED;  // Note this is not a fatal error!
        }
        if ((LONG) ulRow < 1)
        {
            goto BadBookmark;
        }
    }
    else
    {
        goto BadBookmark;
    }

    rulRow = ulRow;
    
Cleanup:
    return hr;

BadBookmark:
    hr = DB_E_BADBOOKMARK;
    goto Cleanup;
}


//+-----------------------------------------------------------------------
//
//  Member:    GenerateHRowsFromHRowNumber (private member)
//
//  Synopsis:  Returns a set of contiguous rows within the rowset, starting
//             at the specified HRow number (which may not correspond to
//             index if a deletion is in progress).  The user can allocate
//             memory for the returned row handles by setting pahRows
//             to a block of memory.  If it is NULL, this function will
//             allocate that memory using CoTaskMemAlloc.
//
//  Arguments: ulFirstRow       the row number of the first HROW to return
//             lRowsOffset      number of rows to skip over
//             cRows            rows to fetch and direction to fetch in
//             pcRowsObtained   rows obtained
//             pahRows          handles of rows obtained
//
//  Returns:   S_OK             if all rows could be fetched.
//             DB_S_BOOKMARKSKIPPED if initial HRowNumber referred to
//                              to a deleted row
//             DB_S_ENDOFROWSET if we straddled the end of the rowset,
//                              but didn't set DB_S_BOOKMARKSKIPPED
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADBOOKMARK if bookmark was invalid.
//             DB_E_NOTREENTRANT on re-entrancy problem
//             
//

HRESULT
CImpIRowset::GenerateHRowsFromHRowNumber(HCHAPTER hChapter, DBCOUNTITEM ulFirstRow,
                                         DBROWOFFSET lRowsOffset, DBROWCOUNT cRows, 
                                         DBCOUNTITEM *pcRowsObtained, HROW **pahRows )
{

    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::GenerateHRowsFromHRowNumber(%p {%u %d %d %p %p})",
              this, ulFirstRow, lRowsOffset, cRows, pcRowsObtained, pahRows ));

    const ULONG ucRows     = (cRows < 0 ? -cRows : cRows); // true count
    const int   sIncrement = (cRows < 0 ? -1     : 1);     // increment
    HRESULT     hr = S_OK;
    ULONG       cGetRows;               // number of rows to fetch
    BOOL        fEndOfRowset = FALSE;   // did we hit end of rowset?
    BOOL        fRowsAllocated = FALSE; // did we allocate space for the HROWs
    COSPData    *pOSPData = GetpOSPData(hChapter);

    Assert(pcRowsObtained);
    Assert(pahRows);

    // In case of errors:
    *pcRowsObtained = 0;

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    if ((LONG) ulFirstRow < 0)
    {
        hr = DB_E_BADBOOKMARK;
        goto Cleanup;
    }
    

    ulFirstRow += lRowsOffset;

    // We know that index was non-negative before the above operation.
    // So we can only overflow with large positive index, lRowsOffset...
    // Check for numeric overflow, arrange for appropriate error below
    if ((LONG) ulFirstRow < 0 && lRowsOffset > 0)
    {
        ulFirstRow = pOSPData->_cSTDRows + 1;
    }

    // Now we need to figure out how many rows to fetch, so that we can
    //   allocate a memory block big enough to hold the handles.
    //   Calculate max number of rows which can be fetched in direction first.
    
    // If index is out of bounds, then we have either hit
    //  end of Rowset, or else we consider ourselves to have a bad bookmark.
    // TODO: once Nile spec details are finalized, we can do better than
    //  bad bookmark in some cases.
    {
        BOOL fTooSmall = (LONG) ulFirstRow < 1;

        if (fTooSmall || (ulFirstRow > pOSPData->_cSTDRows))
        {
            if ((cRows < 0) !=  fTooSmall)
            {
                hr = DB_E_BADSTARTPOSITION;
                goto Cleanup;
            }
            else
            {
                // DB_S_ENDOFROWSET will be set below
                ulFirstRow = cRows < 0 ? 0 : pOSPData->_cSTDRows + 1;
            }
        }
    }

    // compute maximum available rows
    Assert(sIncrement < 0 || ulFirstRow > 0);
    cGetRows = (sIncrement < 0 ? ulFirstRow : pOSPData->_cSTDRows - ulFirstRow + 1);
    if ((LONG) cGetRows < 0)
    {
        cGetRows = 0;
    }
    
    if (ucRows <= cGetRows)
    {
        cGetRows = ucRows;
    }
    else
    {
        fEndOfRowset = TRUE;     // passed end of rowset.  not a failure.
    }

    // Allocate memory block if we need to:
    if (!*pahRows)
    {
        *pahRows = (HROW *)CoTaskMemAlloc(sizeof(HROW) * cGetRows);
        if (!*pahRows)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        fRowsAllocated = TRUE;
    }

    // Setup returned HROWs:
    {
        HROW *phRows;
        ULONG i;

        for (i = cGetRows, phRows = *pahRows;
             i;
             i--, ulFirstRow += sIncrement )
        {
            hr = THR(HRowNumber2HROWQuiet(hChapter, ulFirstRow, *phRows++));
            if (hr)
            {
                ReleaseRowsQuiet(cGetRows - i, *pahRows);
                if (fRowsAllocated)
                {
                    CoTaskMemFree(*pahRows);
                    *pahRows = NULL;
                }
                goto Cleanup;
            }
        }
    }

    *pcRowsObtained = cGetRows;
    if (fEndOfRowset)
    {
            hr = DB_S_ENDOFROWSET;
    }
           
Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Index2HROWQuiet (private member)
//
//  Synopsis:  Wrapper to convert an index to a HROW, without generating
//             notification of row activation.  (Up to caller).
//
//  Arguments: ulIndex      row index to convert to HROW
//             rhrow        reference to fill in with HROW
//
//  Returns:   hr           S_OK or E_OUTOFMEMORY or DB_E_NOTREENTRANT
//

HRESULT
CImpIRowset::Index2HROW(HCHAPTER hChapter, DBCOUNTITEM ulIndex, HROW &rhrow)
{
    RRETURN2(HRowNumber2HROWQuiet(hChapter, ulIndex, rhrow),
             DB_E_NOTREENTRANT, E_OUTOFMEMORY);
}

//+-----------------------------------------------------------------------
//
//  Member:    HRowNumber2HROWQuiet (private member)
//
//  Synopsis:  Wrapper to convert a HRow number to a HROW, without generating
//             notification of row activation.  (Up to caller).
//
//  Arguments: ulHRowNumber HRow number to convert to HROW
//             rhrow        reference to fill in with HROW
//
//  Returns:   hr           S_OK or E_OUTOFMEMORY or DB_E_NOTREENTRANT
//

HRESULT
CImpIRowset::HRowNumber2HROWQuiet(HCHAPTER hChapter, DBCOUNTITEM ulHRowNumber, HROW &rhrow)
{

    HRESULT hr = S_OK;
    ChRow href;

    href = HRowFromIndex(hChapter, ulHRowNumber);
    if (href.FHrefValid())
    {
        rhrow = href.ToNileHRow();
    }
    else
    {
        // We have an implicit assumption that the ONLY reason
        // an rhrow could not be created was out of memory.
        hr = E_OUTOFMEMORY;
        rhrow = 0;
    }

    RRETURN2(hr, DB_E_NOTREENTRANT, E_OUTOFMEMORY);
}


//+-----------------------------------------------------------------------
//
//  Member:    HROW2Index (private member)
//
//  Synopsis:  Given a HROW return the index
//
//  Arguments: hRow         HROW to convert
//             rulIndex     reference to fill in row number
//
//  Returns:   S_OK, DB_E_BADROWHANDLE, DB_E_DELETEDROW
//

HRESULT
CImpIRowset::HROW2Index(HROW hRow, DBCOUNTITEM &rulIndex)
{
    HRESULT hr = S_OK;
    rulIndex = IndexFromHRow((ChRow) hRow);

    if (FhRowDeleted((ChRow) hRow))
    {
        hr = DB_E_DELETEDROW;
    }

    if (rulIndex == 0)
    {
        hr = DB_E_BADROWHANDLE;
    }

    RRETURN2(hr, DB_E_BADROWHANDLE, DB_E_DELETEDROW);
}

//+-----------------------------------------------------------------------
//
//  Member:    GetRowsAt (public member)
//
//  Synopsis:  Given a bookmark and offset, returns the cRows HROWs found there.
//
//  Arguments: hChapter         chapter handle
//             cbBookmark       number of bytes in the bookmark
//             pBookmark        pointer to bookmark
//             lRowsOffset      offset from bookmark to first desired row
//             cRows            maximum number of HROWs to return
//             pcRowsObtained   number of HROWs actually returned  (OUT)
//             paRows           array of HROWs returned            (OUT)
//
//  Returns:   S_OK             if all rows could be fetched.
//             DB_S_ENDOFROWSET if we straddled the end of the rowset
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark was invalid.
//             DB_E_BADSTARTPOSITION if the offset goes off the end
//                              or beginning of the rowset
//             DB_S_BOOKMARKSKIPPED if initial bookmark referred to
//                              to a deleted row


STDMETHODIMP
CImpIRowset::GetRowsAt(HWATCHREGION, HCHAPTER hChapter,
                       DBBKMARK cbBookmark,  const BYTE *pBookmark,
                       DBROWOFFSET  lRowsOffset,     DBROWCOUNT  cRows,
                       DBCOUNTITEM *pcRowsObtained, HROW **pahRows )
{
    HRESULT thr = S_OK;                 // "temporary" hr

    HRESULT hr;
    DBCOUNTITEM ulRow;

    hr = Bookmark2HRowNumber(hChapter, cbBookmark, pBookmark, ulRow);

    // Note under the old scheme DB_S_BOOKMARKSKIPPED was returned from
    // GenerateHRowsFromRowNumber.  That scheme was fake.  We must detect
    // deleted rows now while we still have a bookmark, because once we're
    // working in terms of row numbers deleted rows are invisible.
    if (hr)
    {
        if (FAILED(hr))
            goto Cleanup;
        thr = hr;
    }

    // adjust the offset to take the skipped bookmark into account
    if (hr==DB_S_BOOKMARKSKIPPED)
    {
        if (lRowsOffset > 0)
        {
            -- lRowsOffset;
        }
        else if (lRowsOffset < 0)
        {
            ++ lRowsOffset;
            -- ulRow;
        }
    }

    hr = THR(GenerateHRowsFromHRowNumber(hChapter, ulRow, lRowsOffset, cRows,
                                         pcRowsObtained, pahRows ));

    // If we already have DB_S_BOOKMARKSKIPPED, then it takes precedence
    // over any S_ code that GenerateHRowsFromHRowNumber may return.
    if (thr && SUCCEEDED(hr))
    {
        Assert(thr == DB_S_BOOKMARKSKIPPED);
        hr = thr;
    }

Cleanup:
    return hr;
}



//+-----------------------------------------------------------------------
//
//  Member:    Compare (public member)
//
//  Synopsis:  Compare two bookmarks
//
//  Arguments: hChapter         chapter handle
//             cbBookmark1      number of bytes in the first bookmark
//             pBookmark1       pointer to first bookmark
//             cbBookmark2      number of bytes in the second bookmark
//             pBookmark2       pointer to second bookmark
//             pComparison      pointer to answer                  (OUT)
//
//  Returns:   S_OK             if we could do the comparison
//             E_INVALIDARG     if output pointer is null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark was invalid.
//

STDMETHODIMP
CImpIRowset::Compare(HCHAPTER hChapter,
                     DBBKMARK cbBookmark1, const BYTE *pBookmark1,
                     DBBKMARK cbBookmark2, const BYTE *pBookmark2,
                     DBCOMPARE *pComparison )
{
    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::Compare(%p {%u %p %u %p})",
              this, cbBookmark1, pBookmark1, cbBookmark2, pBookmark2 ));

    HRESULT hr = S_OK;

    if (!pComparison || !pBookmark1 || !pBookmark2 ||
    	cbBookmark1==0 || cbBookmark2==0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pComparison = DBCOMPARE_NOTCOMPARABLE; // In case something goes wrong

    DBCOUNTITEM ulRow1, ulRow2;

    // special case: one of the bookmarks is "first" or "last"
    if (cbBookmark1 == 1 && (*pBookmark1==DBBMK_FIRST || *pBookmark1==DBBMK_LAST))
    {
        if (cbBookmark2 == 1 && *pBookmark1 == *pBookmark2)
            *pComparison = DBCOMPARE_EQ;
        else
            *pComparison = DBCOMPARE_NE;
        goto Cleanup;
    }
    else if (cbBookmark2 == 1 && (*pBookmark2==DBBMK_FIRST || *pBookmark2==DBBMK_LAST))
    {
        if (cbBookmark1 == 1 && *pBookmark1 == *pBookmark2)
            *pComparison = DBCOMPARE_EQ;
        else
            *pComparison = DBCOMPARE_NE;
        goto Cleanup;
    }

    // normal case: first check that the bookmarks have the right shape
    if (cbBookmark1 != sizeof(ULONG) || cbBookmark2 != sizeof(ULONG) )
    {
        hr = DB_E_BADBOOKMARK;
        goto Cleanup;
    }

    // We use Bookmark2HRowNumber because it does First & Last bookmark special
    // cases for us, as well as DeleteInProgress handling (which might be
    // relevant? -cfranks), as well as all the bad bookmark tests.
    hr = Bookmark2HRowNumber(hChapter, cbBookmark1, pBookmark1, ulRow1);
    if (hr)
    {
        if (hr != DB_S_BOOKMARKSKIPPED) goto Cleanup;
        hr = S_OK;      // this call does not return DB_S_BOOKMARKSKIPPED
    }

    hr = Bookmark2HRowNumber(hChapter, cbBookmark2, pBookmark2, ulRow2);
    if (hr)
    {
        if (hr != DB_S_BOOKMARKSKIPPED) goto Cleanup;
        hr = S_OK;      // this call does not return DB_S_BOOKMARKSKIPPED
    }

    *pComparison = ulRow1 <  ulRow2 ? DBCOMPARE_LT :
                     ulRow1 == ulRow2 ? DBCOMPARE_EQ :
                     DBCOMPARE_GT;

Cleanup:
    return hr;
}



//+-----------------------------------------------------------------------

STDMETHODIMP
CImpIRowset::GetRowsByBookmark(HCHAPTER    hChapter,
                               DBCOUNTITEM cRows,
                               const DBBKMARK acbBookmarks[],
                               const BYTE *apBookmarks[],
                               HROW        ahRows[],
                               DBROWSTATUS aRowStatus[] )
{
#if 0                                   // started, but incomplete -cfranks
    HRESULT thr = S_OK;                 // "temporary" hr
    ULONG i, j;
    ULONG ulRow;

    HRESULT hr;
    ULONG   ulRow;
    ULONG	cErrors = 0;		// number of rows with bad status

    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::GetRowsAt(%p {%u %p %i %i})",
          this, cbBookmark, pBookmark, lRowsOffset, cRows) );

    j = 0;                              // j is output index (pahRows)
    for(i=0; i<cRows; i++)              // i is input index (acbBookmarks)
    {

        hr = Bookmark2HRowNumber(hChapter, acbBookmark[i], apBookmark[i], ulRow);

        // Note under the old scheme DB_S_BOOKMARKSKIPPED was returned from
        // GenerateHRowsFromRowNumber.  That scheme was fake.  We must detect
        // deleted rows now while we still have a bookmark, because once we're
        // working in terms of row numbers deleted rows are invisible.
        if (hr)
        {
            // S_BOOKMARKSKIPPED is not allowed in this call, so we
            // turn the skipped flag into a E_DELETEDROW
            if (hr==DB_S_BOOKMARKSKIPPED)
                hr = DB_E_DELETEDROW;
        }
        else
        {
            hr = THR(GenerateHRowsFromHRowNumber(hChapter, ulRow, 0, 1,
                                                 pcRowsObtained, pahRows[j]));
        }

        // record the status of current requested row
        // TODO: redo GenHRows to provide better status
        DBROWSTATUS drsStatus = hr ? DBROWSTATUS_E_INVALID : DBROWSTATUS_S_OK;
        if (aRowStatus)
        {
            aRowStatus[i] = drsStatus;
        }

        // Unless there was a more serious error, we want to be careful
        // to return DB_S_BOOKMARKSKIPPED, if we had one.
        if (!hr) hr = thr;
    } // for (i=0; i!=cRows; i++)

Cleanup:
    return hr;
#else

//    FireRowEvent(*pcRowsObtained, *pahRows,
//                 DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT);

    return E_NOTIMPL; // TODO: Do this
#endif
}

//+-----------------------------------------------------------------------

STDMETHODIMP
CImpIRowset::Hash(HCHAPTER    hChapter,
                  DBBKMARK    cBookmarks, const DBBKMARK acbBookmarks[],
                  const BYTE *apBookmarks[],
                  DBHASHVALUE aHashedValues[],
                  DBROWSTATUS aBookmarkStatus[] )
{
    return E_NOTIMPL; // TODO: This routine changes drastically in June spec...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\newrow.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      newrow.cxx
//  Author:    Ted Smith
//
//  Contents:  Implementation of RowsetNewRowAfter
//
//------------------------------------------------------------------------

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetNewRowAfter specific interface
//
////////////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------
//
//  Member:    SetNewDataAfter (public member)
//
//  Synopsis:  Create and initialize a new row in the STD.
//
//  Arguments: hChapter            chapter handle [IN]
//             cbBookmarkPrevious  number of bytes in the bookmark [IN]
//             pBookmarkPrevious   pointer to bookmark [IN]
//             hAccessor           Accessor to use [IN]
//             pData               Pointer to buffer of data to set [IN]
//             phRow               Row Handle [OUT]
//
//  Returns:   S_OK                    if data changed successfully
//             E_FAIL                  if Catch all (NULL pData, etc.)
//             E_OUTOFMEMORY           if output error array couldn't be allocated
//             DB_E_BADACCESSORHANDLE  if invalid accessor
//             DB_E_BADCHAPTER         if chapter passed in
//             DB_E_BADBOOKMARK        if bookmark was invalid.
//             DB_E_NOTREENTRANT       if illegal reentrancy
//

STDMETHODIMP
CImpIRowset::SetNewDataAfter(HCHAPTER    hChapter,
                             DBBKMARK    cbBookmarkPrevious,
                             const BYTE *pBookmarkPrevious,
                             HACCESSOR   hAccessor,
                             BYTE       *pData,
                             HROW       *phRow )
{
    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::SetNewDataAfter(%p {%u %p %p %p})",
              this, cbBookmarkPrevious, pBookmarkPrevious, hAccessor, pData ));

    HRESULT hr;
    HRESULT hrBookmarkSkipped = S_OK;
    DBCOUNTITEM   ulIndex;
    DBROWCOUNT    cRowsInserted;
    HROW    hRow = NULL;
    HROW    *phRowSafe = (phRow ? phRow : &hRow);
    COSPData *pOSPData = GetpOSPData(hChapter);

    if (FAnyPhaseInProgress(DBREASON_ROW_DELETE)
            || FAnyPhaseInProgress(DBREASON_ROW_INSERT))
    {
        hr = DB_E_NOTREENTRANT;
        goto Cleanup;
    }

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    if (cbBookmarkPrevious == 0)
    {
        ulIndex = 1;
    }
    else if (pOSPData->_cSTDRows==0 && cbBookmarkPrevious==1 &&
             (*pBookmarkPrevious==DBBMK_FIRST || *pBookmarkPrevious==DBBMK_LAST))
    {
        ulIndex = 1;
    }
    else
    {
        hr = THR(Bookmark2HRowNumber(hChapter, cbBookmarkPrevious, pBookmarkPrevious,
                                     ulIndex));
        if (hr)
        {
            if (hr != DB_S_BOOKMARKSKIPPED) goto Cleanup;
            hrBookmarkSkipped = hr;
        }

        if (ulIndex > pOSPData->_cSTDRows)
        {
            hr = DB_S_BOOKMARKSKIPPED;
            ulIndex = pOSPData->_cSTDRows;
        }
        ulIndex += 1;                   // +1 to insert AFTER current row
    }
    Assert(ulIndex > 0 && ulIndex <= pOSPData->_cSTDRows + 1);

    hr = THR(GetpOSP(hChapter)->insertRows((LONG)ulIndex, 1, &cRowsInserted));
    if (hr)
    {
        if (hr != E_OUTOFMEMORY)
        {
            hr = E_FAIL;
        }
        goto Cleanup;
    }

    hr = THR(Index2HROW(hChapter, ulIndex, hRow));
    if (hr)
    {
        goto Error;
    }

    // TODO: set default values into the columns of the new row (by writing
    // no code, we're accepting whatever the STD happens to leave in memory
    // when it allocates the new row)

    // TODO: generate a notification that a new row is being added

    Assert(hRow != NULL);        
    // TODO ole-db will presumably change pData from (const BYTE*) to (void*)
    // someday, and this cast can go away
    hr = THR(SetData(hRow, hAccessor, (void*)pData));
    if (FAILED(hr))
    {
        goto Error;
    }
        
Cleanup:
    if ((phRow == NULL || hr) && hRow != NULL)
    {
        ReleaseRows(1, &hRow, NULL, NULL, NULL);
        hRow = NULL;
    }
    *phRowSafe = hRow;

    if (hr == S_OK)
        hr = hrBookmarkSkipped;
    return hr;
    
Error:
    GetpOSP(hChapter)->deleteRows((LONG) ulIndex, 1, &cRowsInserted);
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\colinfo.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      colinfo.cxx
//  Author:    Ido Ben-Shachar (t-idoben@microsoft.com)
//
//  Contents:  Implementation of GetColumnInfo
//
//  History:
//  08/02/95   Ido       GetColumnInfo returns appropriate flags.
//


#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

#define HIER_PREFIX     _T("^")
#define HIER_PREFIX_LEN (1)
#define HIER_SUFFIX     _T("^")
#define HIER_SUFFIX_LEN (1)

MtDefine(CImpIRowset_astdcolinfo, CImpIRowset, "CImpIRowset::_astdcolinfo");

//+---------------------------------------------------------------------------
//
//  Member:     CacheMetaData (public member)
//
//  Synopsis:   read meta data from OSP into a cache
//
//  Returns:    S_OK                if everything is fine
//              E_FAIL              initialization failed
//
HRESULT
CImpIRowset::CacheMetaData()
{
    HRESULT hr = S_OK;
    DBROWCOUNT cColsTemp;
    CSTDColumnInfo *pInfoIndex;
    ULONG i;
    OLEDBSimpleProvider *pOSP = GetpMetaOSP();

    Assert(!_astdcolinfo);
    // Go ahead and replace any previous cache, but this shouldn't happen
    delete [] _astdcolinfo;

    hr = pOSP->getColumnCount(&cColsTemp);
    _cCols = (ULONG)cColsTemp;

    if (hr || _cCols == 0)          // We can't make a valid 0 column rowset
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    cColsTemp = 1 + _cCols;         // bookmark column + OSP columns

    // Allocate cache:
    _astdcolinfo = new(Mt(CImpIRowset_astdcolinfo)) CSTDColumnInfo[cColsTemp];
    if (!_astdcolinfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // fill in cache for bookmark column
    pInfoIndex = _astdcolinfo;
    pInfoIndex->dwFlags = DBCOLUMNFLAGS_ISBOOKMARK |
                         DBCOLUMNFLAGS_ISFIXEDLENGTH;
    pInfoIndex->dwType = DBTYPE_I4;                     // bookmark is an integer
    pInfoIndex->cbMaxLength = sizeof(ULONG);            // bookmark is 4 bytes
    pInfoIndex->bstrName = NULL;                        // no name
    pInfoIndex->pChapRowset = NULL;                     // no referenced rowset

    // fill in cache for OSP columns
    for (i = 1, ++pInfoIndex;  i < (ULONG)cColsTemp;  ++i, ++pInfoIndex )
    {
        OSPRW  wRW;
        VARIANT tempVar;

        pInfoIndex->dwFlags = DBCOLUMNFLAGS_ISFIXEDLENGTH;
        hr = pOSP->getRWStatus(OSP_IndexAll, i, &wRW);
        if (!hr && wRW != OSPRW_READONLY)
        {
            pInfoIndex->dwFlags |= DBCOLUMNFLAGS_WRITE;
        }
        
        pInfoIndex->dwType = DBTYPE_VARIANT;            // columns hold variants
        pInfoIndex->cbMaxLength = sizeof(VARIANT);
        pInfoIndex->pChapRowset = NULL;
        pInfoIndex->bstrName = NULL;
        
        FastVariantInit(&tempVar);
        hr = pOSP->getVariant(0, i, OSPFORMAT_FORMATTED, &tempVar);
        if (!hr && tempVar.vt == VT_BSTR)
        {
            ULONG cColNameLen = SysStringLen(tempVar.bstrVal);

            // Detect hierarchy columns.
            if (FormsStringNCmp(HIER_PREFIX, HIER_PREFIX_LEN,
                                tempVar.bstrVal, HIER_PREFIX_LEN) == 0 &&
                FormsStringNCmp(HIER_SUFFIX, HIER_SUFFIX_LEN,
                                tempVar.bstrVal + cColNameLen - HIER_SUFFIX_LEN,
                                HIER_SUFFIX_LEN) == 0)
            {
                pInfoIndex->dwFlags |= DBCOLUMNFLAGS_ISCHAPTER;
                pInfoIndex->dwType = DBTYPE_HCHAPTER;
                pInfoIndex->cbMaxLength = sizeof(IUnknown *);
                // We won't save the prefix
                FormsAllocStringLen(tempVar.bstrVal + HIER_PREFIX_LEN,
                        cColNameLen - (HIER_PREFIX_LEN+HIER_SUFFIX_LEN),
                        &pInfoIndex->bstrName);
            }
            else
            {
                pInfoIndex->bstrName = tempVar.bstrVal;
                tempVar.bstrVal = NULL;     // BSTR now owned by pInfoIndex
            }

            VariantClear(&tempVar);
        }
    }

    // initialize my properties
    // TODO this should be table-driven
    {
        DBPROP prop;

        // we don't wast static data with a copy of DB_NULLID
        // prop.colid = DB_NULLID;
        memset(&prop.colid, 0, sizeof(prop.colid));

        prop.dwOptions = DBPROPOPTIONS_REQUIRED;
        prop.dwStatus  = DBPROPSTATUS_OK;

        // LITERALIDENTITY = False
        prop.dwPropertyID = DBPROP_LITERALIDENTITY;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_FALSE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));

        // STRONGIDENTITY = False
        prop.dwPropertyID = DBPROP_STRONGIDENTITY;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_FALSE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));

        //
        // the next 11 properties are the ones ADO queries (msador15 v1929)
        
        // OTHERUPDATEDELETE = True
        prop.dwPropertyID = DBPROP_OTHERUPDATEDELETE;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // OTHERINSERT = True
        prop.dwPropertyID = DBPROP_OTHERINSERT;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // CANHOLDROWS = True
        prop.dwPropertyID = DBPROP_CANHOLDROWS;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // CANSCROLLBACKWARDS = True
        prop.dwPropertyID = DBPROP_CANSCROLLBACKWARDS;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // UPDATABILITY = change | delete | insert
        prop.dwPropertyID = DBPROP_UPDATABILITY;
        V_VT(&prop.vValue) = VT_I4;
        V_I4(&prop.vValue) = DBPROPVAL_UP_CHANGE | DBPROPVAL_UP_DELETE |
                                DBPROPVAL_UP_INSERT;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // IRowsetLocate = True
        prop.dwPropertyID = DBPROP_IRowsetLocate;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // IRowsetScroll = True
        prop.dwPropertyID = DBPROP_IRowsetScroll;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // IRowsetUpdate = False
        prop.dwPropertyID = DBPROP_IRowsetUpdate;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_FALSE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // IRowsetResynch = False
        prop.dwPropertyID = DBPROP_IRowsetResynch;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_FALSE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // IConnectionPointContainer = True
        prop.dwPropertyID = DBPROP_IConnectionPointContainer;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // BOOKMARKSKIPPED = True
        prop.dwPropertyID = DBPROP_BOOKMARKSKIPPED;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));

        // IRowsetAsynch = ASK THE OSP PROVIDER!
        // Note: we assume OSP providers can actually answer the question this early.
        {
            BOOL fAsync = FALSE;
            prop.dwPropertyID = DBPROP_IDBAsynchStatus;
            V_VT(&prop.vValue) = VT_BOOL;
            V_BOOL(&prop.vValue) = (VARIANT_BOOL)TRUE; // we do support this interface
            IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));

            IGNORE_HR(GetpMetaOSP()->isAsync(&fAsync));
            prop.dwPropertyID = DBPROP_ROWSET_ASYNCH;
            V_VT(&prop.vValue) = VT_I4;
            V_I4(&prop.vValue) = fAsync ? (DBPROPVAL_ASYNCH_INITIALIZE |
                                           DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION |
                                           DBPROPVAL_ASYNCH_RANDOMPOPULATION)
                                        : 0 ;
            IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        }
    }

Cleanup:
    if (hr && hr != E_OUTOFMEMORY)
    {
        hr = E_FAIL;
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// IColumnsInfo specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------
//
//  Member:    GetColumnInfo (public member)
//
//  Synopsis:  Returns information on the rows in a table.  This can be
//             used to discover the number of columns in a table, the
//             types of information stored in each column, and the name/label
//             of each column.  In the case of the STD, columns will only
//             be holding variants, and the names of the columns are stored
//             in row #0 (used for labels).
//             The column information is returned in an array of structures,
//             each corresponding to a column in the table.
//             Note that the memory allocated for paInfo and ppStringsBuffer
//             must be deallocated by the caller of this function.
//             Column 0 does not return information about itself since it
//             is just a holder for labels.  However, element 0
//             of paInfo stores information about the "bookmark column."
//             This column does not actually exist in the rowset, but is
//             used so that accessors to bookmarks can be created.
//
//  Arguments: pcColumns        number of columns in table       (OUT)
//             paInfo           array of column-info structures  (OUT)
//             ppStringsBuffer  storage for strings              (OUT)
//
//  Returns:   Success if column-info can be constructed and returned.
//             Returns E_INVALIDARG if argument pointers are null.
//             Returns E_OUTOFMEMORY if can't allocate memory for structures.
//

STDMETHODIMP
CImpIRowset::GetColumnInfo(DBORDINAL *pcColumns,
                           DBCOLUMNINFO **paInfo,
                           OLECHAR **ppStringsBuffer )
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetColumnInfo(%p {%p, %p, %p})",
             this, pcColumns, paInfo, ppStringsBuffer) );

    HRESULT hr = S_OK;
    ULONG cTempInfo;                      // num of cols in STD+1 (for bookmark)
    DBCOLUMNINFO *aTempInfo;              // temp data block for output
    OLECHAR *pTempStringsBuffer;          // temp string-buffer block for output
    ULONG cStringBufferRemaining = 0;     // chars in string-buffer block
    DBCOLUMNINFO *pTempColumn;            // used to index data in for-loop
    ULONG i;
    CSTDColumnInfo *pColInfo;
    OLECHAR *pstrTemp;                  // used to step through str buffer

    // Check that output variables aren't null:
    if (!pcColumns || !paInfo || !ppStringsBuffer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    cTempInfo = _cCols + 1;

    // In case of error, null outputs:
    *pcColumns = 0;
    *paInfo = NULL;
    *ppStringsBuffer = NULL;

    // we must have valid meta data from the OSP
    if (!_astdcolinfo)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Allocate memory for structures holding column information:
    aTempInfo =
        (DBCOLUMNINFO *)CoTaskMemAlloc(sizeof(DBCOLUMNINFO) * cTempInfo);
    if (!aTempInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Zero structure:
    memset(aTempInfo, '\0', sizeof(DBCOLUMNINFO) * cTempInfo);

// Now we will fill in the structures with actual column information.
// Since the strings in the table are supposed to be stored in one big
//   block, this pass through the structures will not yet allocate that block,
//   but instead calculate its size.  We will need to do a second pass on the
//   columns to actually copy the strings into the buffer.

    // We need to store information about the bookmarks column:
    pColInfo = _astdcolinfo;
    aTempInfo->columnid.eKind = DBKIND_GUID_PROPID;
    aTempInfo->columnid.uGuid.guid = DBCOL_SPECIALCOL;
    aTempInfo->columnid.uName.ulPropid = DBPROPVAL_BMK_KEY; // "self" bookmark
    Assert(!aTempInfo->pwszName);                       // no name
    Assert(!aTempInfo->iOrdinal);                       // column number 0 in mapper
    aTempInfo->wType = pColInfo->dwType;                // bookmark is 4 bytes
    Assert(!aTempInfo->pTypeInfo);
    aTempInfo->ulColumnSize = pColInfo->cbMaxLength;    // bookmark is 4 bytes
    aTempInfo->bPrecision = (BYTE)~0;                   // no precision
    aTempInfo->bScale = (BYTE)~0;                       // no scale
    aTempInfo->dwFlags = pColInfo->dwFlags;

    // construct the information about the OSP columns
    for (i = 1, pTempColumn = aTempInfo + 1, ++pColInfo;
         i < cTempInfo;
         ++i, ++pTempColumn, ++pColInfo )
    {
        pTempColumn->columnid.eKind = DBKIND_NAME;      // id is col name
        Assert(!pTempColumn->columnid.uName.pwszName);  // fill this in later
        Assert(!pTempColumn->pwszName);                 // fill this in later
        pTempColumn->iOrdinal = i;
        pTempColumn->wType = pColInfo->dwType;          // columns hold variants
        Assert(!pTempColumn->pTypeInfo);
        pTempColumn->ulColumnSize = pColInfo->cbMaxLength;
        pTempColumn->bPrecision = (BYTE)~0;         // no precision
        pTempColumn->bScale = (BYTE)~0;             // no scale
        pTempColumn->dwFlags = pColInfo->dwFlags;

        // Calculate length of string buffer..
        cStringBufferRemaining += FormsStringLen(pColInfo->bstrName) + 1;
    }

    // Allocate the string buffer:
    pTempStringsBuffer =
                (OLECHAR *)CoTaskMemAlloc(sizeof(OLECHAR) * cStringBufferRemaining);
    if (!pTempStringsBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto Error1;
    }

    // Fill the string buffer:
    pstrTemp = pTempStringsBuffer;
    
    for (i = 1, pTempColumn = aTempInfo + 1, pColInfo = _astdcolinfo + 1;
         i < cTempInfo;
         ++i, ++pTempColumn, ++pColInfo )
    {
        ULONG cTempLengthCopied = FormsStringLen(pColInfo->bstrName);
        
        // Set a pointer to this string:
        pTempColumn->pwszName = pstrTemp;
        // Also set id of column to this string:
        pTempColumn->columnid.uName.pwszName = pstrTemp;

        if (cTempLengthCopied > 0)
        {
            _tcsncpy(pstrTemp, pColInfo->bstrName, cTempLengthCopied);
            pstrTemp += cTempLengthCopied;
        }
        pstrTemp[0] = '\0';
        ++ pstrTemp;
        
        cStringBufferRemaining -= cTempLengthCopied + 1;
    }

    Assert("Buffer should be fully used" &&
        (cStringBufferRemaining == 0) );

    // Set output variables:
    *pcColumns = cTempInfo;
    *paInfo = aTempInfo;
    *ppStringsBuffer = pTempStringsBuffer;

Cleanup:
    return hr;

Error1:
    // NOTE: delete pTempStringsBuffer here if this is called after it exists
    // deallocate array of structures:
    CoTaskMemFree(aTempInfo);
    goto Cleanup;
}


//+-----------------------------------------------------------------------
//
//  Member:    MapColumnIDs
//
//  Synopsis:  Given an array of column IDs, returns an array of column
//             ordinals.  Note that the output array of column ordinals
//             is allocated by the caller, and only filled in by this
//             function.  Given the column ID of the bookmark column,
//             column ordinal 0 is returned.  The value DB_INVALIDCOLUMN
//             is returned as an index if the column ID was invalid.
//
//  Arguments: cColumnIDs       number of IDs in array
//             aColumnIDs       array of column IDs
//             aColumns         array of column ordinals         (OUT)
//
//  Returns:   Success if output array can be filled.
//             E_INVALIDARG if cColumnIDs>0 and no input or output array.
//             DB_S_ERRORSOCCURRED if some but not all column IDs were invalid
//             DB_E_ERRORSOCCURRED if all column IDs were invalid
//

STDMETHODIMP
CImpIRowset::MapColumnIDs(DBORDINAL cColumnIDs,
                          const DBID aColumnIDs [],
                          DBORDINAL aColumns [] )
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::MapColumnIDs(%p {%u, %p, %p})",
             this, cColumnIDs, aColumnIDs, aColumns) );

    HRESULT hr = S_OK;
    DBORDINAL cErrors = 0;             // number of invalid column IDs
    DBORDINAL i;
    const DBID *pTempColID;        // used to index source col ids
    DBORDINAL *pTempColOrd;            // used to index dest col ordinals

    // Check arguments:
    if ((cColumnIDs && !aColumnIDs) ||
        !aColumns)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // must have valid metadata from OSP
    if (!_astdcolinfo)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // Now translate column IDs:
    for (i = 0, pTempColID = aColumnIDs, pTempColOrd = aColumns;
         i < cColumnIDs;
         i++, pTempColID++, pTempColOrd++ )
    {
        const GUID *pguid = &pTempColID->uGuid.guid;// useful for bookmark check

        *pTempColOrd = DB_INVALIDCOLUMN;    // assume failure
        
        switch(pTempColID->eKind)
        {
        case DBKIND_PGUID_PROPID:
            pguid = pTempColID->uGuid.pguid;
            // FALL THRU
        case DBKIND_GUID_PROPID:
            if (IsEqualGUID(*pguid, DBCOL_SPECIALCOL)
                    && pTempColID->uName.ulPropid == DBPROPVAL_BMK_KEY)
            {
                *pTempColOrd = 0;         // bookmark column is 0;
            }
            break;
        case DBKIND_NAME:
            if (pTempColID->uName.pwszName != NULL)
            {
                ULONG uIndex;                      // index into column labels
                ULONG cNameLength = _tcslen(pTempColID->uName.pwszName);

                // Check columns to see if they match string:
                for (uIndex = 1; uIndex <= _cCols; uIndex++)
                {
                    BSTR bstrName = _astdcolinfo[uIndex].bstrName;
                    ULONG cColumnNameLen = FormsStringLen(bstrName);
                    
                    if (FormsIsEmptyString(bstrName))
                    {
                        continue;           // this column does not have a name
                    }
                    
                    // Compare strings:
                    // make sure they're the same lengths for match
                    if ((cNameLength == cColumnNameLen) &&
                        (!_tcsnicmp(pTempColID->uName.pwszName,
                                    cNameLength,
                                    bstrName,
                                    cNameLength )))
                    {
                        *pTempColOrd = uIndex; // found it
                        break;
                    }
                }
            }
            break;
        }

        // See if we didn't find a string match:
        if (*pTempColOrd == DB_INVALIDCOLUMN)
        {
            ++ cErrors;
        }
    }

    hr =    cErrors == 0 ?          S_OK :
            cErrors < cColumnIDs ?  DB_S_ERRORSOCCURRED :
                                    DB_E_ERRORSOCCURRED;

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\rowhndl.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      rowhndl.cxx
//  Author:    Charles Frankston
//
//  Contents:  Implementation of new scheme to manage row handles & bookmarks
//  Date:      started May 28, 1996
////
//------------------------------------------------------------------------

// keep our code to 80 columns:
//       1         2         3         4         5         6         7         
// 4567890123456789012345678901234567890123456789012345678901234567890123456789

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

MtDefine(CRowArray, DataBind, "CRowArray")

//+------------------------------------------------------------------------
//
//  Class:      CRowMap
//
//  Purpose:    Class used to track translations from hRows to STD row
//              indexes, and visa versa.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member: CRowMap::HandleFromRow
//
//  Synopsis:   Returns the handle corresponding to a row.  These handles
//              are meant to be used at hRows or Bookmarks.  Handles persist
//              for the life of the CRowMap class they came from.  They
//              always continue to point to the same row (even in the face
//              of row inserts and deletes) unless that row is deleted, in
//              which case they will point to the first non-deleted row
//              following the original row.
//
//  Arguments:  row   row # to get a handle to.
//
//-------------------------------------------------------------------------
ChRow
CImpIRowset::HRowFromIndex(HCHAPTER hChapter, DBCOUNTITEM row)
{
    ChRow href;                 // Handle reference
    CRowArray<ChRow> *pMapIndex2hRow = &GetpOSPData(hChapter)->_mapIndex2hRow;

   // Get the hRow for this row if there already is one.
    href = pMapIndex2hRow->GetElem ((int) row);

    if (!href.FHrefValid())                    // Didn't already have one.
    {
        // Get the next free handle, set it to point to this row.
        if (S_OK != _maphRow2Index.SetElem(_NextH2R,
                                           CIndex((int)row, (COSPData *)(LONG_PTR)hChapter)))
        {
            // Must have been a mem alloc failure.  Don't assign to href.
            goto Error;
        }
        // Record the hRow we just claimed,
        href = href.SetRef(_NextH2R++);;

        // and set the entry for this row to point back to href entry
        pMapIndex2hRow->SetElem((int) row, href);
    }

Error:
    return (href);
}
    
//+------------------------------------------------------------------------
//
//  Member: CRowMap::RowFromHRow
//
//  Synopsis:   Returns the Row # that a particular handle addresses.
//              If the row has been deleted, the handle will still be valid
//              but would now point to the first non-deleted row following.
//
//  Arguments:  handle
//
//-------------------------------------------------------------------------
/* Inline'd in .hxx file! */

//+------------------------------------------------------------------------
//
//  Member: CRowMap::FhRowDeleted
//
//  Synopsis:   Returns TRUE if the row referred to by handle has been deleted.
//
//  Arguments:  handle
//
//-------------------------------------------------------------------------
/* Inline'd in .hxx file! */

// For iterating through ChRow's.
ChRow
CImpIRowset::FirsthRef(HCHAPTER hChapter)
{
    ChRow hRef;                         // contructed at 0

    return NexthRef(hChapter, hRef);
}

ChRow
CImpIRowset::NexthRef(HCHAPTER hChapter, ChRow hRef)
{
    // Advance to the next CIndex that matches the chapter
    // we're working on.
    for (hRef=hRef.NextHRef();  ValidhRef(hRef);  hRef=hRef.NextHRef())
    {
        if (_maphRow2Index.GetElem(hRef.DeRef()).GetpChap() ==
           (COSPData *)(LONG_PTR)hChapter)
       {
           break;
       }
    }
    return hRef;
}

BOOL
CImpIRowset::ValidhRef(ChRow hRef)
{
    return ((LONG)hRef.DeRef() < _NextH2R);
}

//+------------------------------------------------------------------------
//
//  Member: CRowMap::InsertRows
//
//  Synopsis:   Inserts new rows.  The row table (mpIndex2hRow) is shifted
//              up to make room, and all the handles in the handle table
//              (_maphRow2Index) are adjusted to account for the shift.
//
//  Arguments:  row     index of row to start insertion at (i.e. 0 would
//                      insert before the first element).
//              c       count of # of rows to insert
//              pChap   Pointer to chapter that we're dealing with now
//              mpIndex2hRow The handle table for this chapter
//
//-------------------------------------------------------------------------
HRESULT
CImpIRowset::InsertRows(ULONG row, int c, COSPData *pOSPData)
{
    HRESULT hr;
    ChRow hRef;                         // Constructor will create a 0 hRef
    CIndex v;
    HCHAPTER hChapter = HChapterFromOSPData(pOSPData);
    
    Assert(c >= 0);

    // Create space for new rows in Row2hRow table.
    // New entries are initialized to invalid hRef, showing that there
    // aren't handles checked out yet for the new rows.
    hr = pOSPData->_mapIndex2hRow.InsertMultiple(row, c, hRef);
    if (hr)
        goto Error;         // out of mem for insert
    
    // March through hRow array fixing up values
    for (hRef = FirsthRef(hChapter); ValidhRef(hRef);
         hRef = NexthRef(hChapter, hRef))
    {
        v = _maphRow2Index.GetElemNoCheck(hRef.DeRef());

        if (v.Row() >= (int)row)
        {
            _maphRow2Index.SetElemNoCheck(hRef.DeRef(),
                                         v.SetRow(v.Row()+c, v.FDeleted()));
        }
    }
    
Error:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member: CRowMap::DeleteRows
//
//  Synopsis:   Deletes rows.  The row table (mpIndex2hRow) is shifted
//              down, and all the handles in the handle table
//              (_mapIndex2hRow) are adjusted to account for the shift.
//
//  Arguments:  row     index of row to start deletion at (i.e. 0 would
//                      start deletion at the first element).
//              c       count of # of rows to delete
//              pChap   Pointer to chapter that we're dealing with now
//              mpIndex2hRow The handle table for this chapter
//
//-------------------------------------------------------------------------
void
CImpIRowset::DeleteRows(ULONG row, int c, COSPData *pOSPData)
{
    ChRow hRef;
    CIndex v;
    HCHAPTER hChapter = HChapterFromOSPData(pOSPData);

    Assert( c >= 0);
    // adjust Row2hRow mapping table
    pOSPData->_mapIndex2hRow.DeleteMultiple(row, c);

    // March through hRow array fixing up values
    for (hRef = FirsthRef(hChapter); ValidhRef(hRef);
         hRef = NexthRef(hChapter, hRef))
    {
        v = _maphRow2Index.GetElemNoCheck(hRef.DeRef());
        if (v.Row() >= (int)row)        // In the range affected by deletion?
        {
            if (v.Row() < (int)(row+c))  // In the range of now deleted rows?
            {
                // If this row has been deleted, set it to point to
                // first undeleted element, & mark it negative to show
                // that its been deleted.
                _maphRow2Index.SetElemNoCheck(hRef.DeRef(), v.SetRowDel(row));
            }
            else
            {
                // Adjust all values after deleted range.  Be sure to retain
                // any existing deleted flag.
                _maphRow2Index.SetElemNoCheck(hRef.DeRef(),
                                             v.SetRow(v.Row()-c, v.FDeleted()));
            }
        }

    }
}

#ifdef NEVER
//+------------------------------------------------------------------------
//
//  Member: CRowMap::InvalidateMap
//
//  Synopsis:   Invalidates the entire HRow to CRow mapping table.  Used
//              when the rowset has disappeared (or been sorted) out from
//              under us.  This will ensure that any and all outstanding
//              hRows, Bookmarks, etc. are invalid, can't be stored through
//              can't be used to fetch new data, etc.
//
//-------------------------------------------------------------------------
void
CImpIRowset::InvalidateMap()
{
    ChRow hRef;
    CIndex v;

    // March through hRow array deleting all values.
    // March through hRow array fixing up values
    for (hRef = FirsthRef(hChapter); ValidhRef(hRef);
         hRef = NexthRef(hRef, hChapter))
    {
        v = _maphRow2Index.GetElemNoCheck(hRef.DeRef());
        _maphRow2Index.SetElemNoCheck(hRef.DeRef(), v.SetRowDel(1));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\scroll.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      scroll.cxx
//  Author:    Ido Ben-Shachar (t-idoben@microsoft.com)
//
//  Contents:  Implementation of RowsetExactScroll
//             Implementation of RowsetScroll
//
//------------------------------------------------------------------------

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetScroll specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------
//
//  Member:    GetApproximatePosition (public member)
//
//  Synopsis:  Given a bookmark, returns the corresponding row number.
//
//  Arguments: hChapter         chapter handle
//             cbBookmark       number of bytes in the bookmark
//             pBookmark        pointer to bookmark
//             pulPosition      row number                       (OUT)
//             pcRows           total number of rows             (OUT)
//
//  Returns:   Success          if inputs are valid.
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark is invalid.
//             DB_E_NOTREENTRANT if illegal reentrancy (nested delete)
//

STDMETHODIMP
CImpIRowset::GetApproximatePosition (HCHAPTER hChapter,
                                     DBBKMARK cbBookmark,   const BYTE *pBookmark,
                                     DBCOUNTITEM *pulPosition, DBCOUNTITEM *pcRows )
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::GetApproximatePosition(%p {%u %p %p %p})",
          this, cbBookmark, pBookmark, pulPosition, pcRows) );

    HRESULT hr = S_OK;
    DBCOUNTITEM ulPosition;
    COSPData *pOSPData = GetpOSPData(hChapter);

    if (cbBookmark && pBookmark==NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    if (pcRows)
        *pcRows = pOSPData->_cSTDRows; // get rows in table

    if (cbBookmark == 0)
        goto Cleanup;                   // no position desired, just size

    hr = THR(Bookmark2HRowNumber(hChapter, cbBookmark, pBookmark, ulPosition));
    if (hr)
    {
        if (hr != DB_S_BOOKMARKSKIPPED) goto Cleanup;
        hr = S_OK;      // this call does not return DB_S_BOOKMARKSKIPPED
    }
    
    if (ulPosition > pOSPData->_cSTDRows && cbBookmark != 1) // Predefined bmks OK
    {
        hr = DB_E_BADBOOKMARK;
    }

    if (pOSPData->_cSTDRows == 0) // if rowset is empty, always return 0 position
        ulPosition = 0;
	
    if (pulPosition)
    	*pulPosition = ulPosition;

Cleanup:
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    GetRowsAtRatio (public member)
//
//  Synopsis:  Returns a set of contiguous rows within the rowset, starting
//             at a certain ratio into the rowset.  The user can allocate
//             memory for the returned row handles by setting pahRows
//             to a block of memory.  If it is NULL, this function will
//             allocate that memory.
//
//  Arguments: hChapter         chapter handle
//             ulNumberator     numerator of ratio
//             ulDenominator    denominator of ratio
//             cRows            rows to fetch and direction to fetch in
//             pcRowsObtained   rows obtained
//             pahRows          handles of rows obtained
//
//  Returns:   S_OK             if all rows could be fetched.
//             DB_S_ENDOFROWSET if we straddled the end of the rowset
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark was invalid.
//

STDMETHODIMP
CImpIRowset::GetRowsAtRatio (HWATCHREGION,
                             HCHAPTER hChapter,
                             DBCOUNTITEM ulNumerator,
                             DBCOUNTITEM ulDenominator,
                             DBROWCOUNT cRows,
                             DBCOUNTITEM *pcRowsObtained,
                             HROW **pahRows )
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetRowsAtRatio(%p {%u %u %d %p %p})",
             this, ulNumerator, ulDenominator, cRows,
             pcRowsObtained, pahRows) );

    HRESULT hr;
    LONG    iRowFirst;                   // row to start fetching at
    COSPData *pOSPData = GetpOSPData(hChapter);

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }

    // Find row to start fetching at.  Note that this function returns -1
    //   on overflow or division by 0, so the error checking, in checking
    //   bounds, catches this.
    // Note the +1 because ulNumerator is zero-based, and we're 1-based.
    iRowFirst = MulDiv(pOSPData->_cSTDRows,
                       ulNumerator, ulDenominator) + 1;

    if (pOSPData->_cSTDRows < (ULONG)iRowFirst)
    {
        hr = DB_E_BADRATIO;
        goto Cleanup;
    }

    // GenerateHRowsFromHRowNumber fails NULL args
    hr = THR(GenerateHRowsFromHRowNumber(hChapter, iRowFirst, 0, cRows,
                                         pcRowsObtained, pahRows ));
    Assert(FAILED(hr) || (pcRowsObtained != NULL && pahRows != NULL));
    if (hr)
    {
        // We can't return DB_S_BOOKMARKSKIPPED; figure out if that was
        //  masking a DB_S_ENDOFROWSET.
        if (hr == DB_S_BOOKMARKSKIPPED)
        {
            hr = (*pcRowsObtained == (ULONG) abs(cRows)
                    ? S_OK : DB_S_ENDOFROWSET);
        }
        else if (FAILED(hr))
        {
            // We can't return DB_E_BADBOOMARK, either
            if (hr == DB_E_BADBOOKMARK)
            {
                hr = DB_E_BADRATIO;
            }
            goto Cleanup;
        }
    }                                
            

    FireRowEvent(*pcRowsObtained, *pahRows,
                 DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT);

Cleanup:
    return hr;
}


////////////////////////////////////////////////////////////////////////////////
//
// IRowsetExactScroll specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------
//
//  Member:    GetExactPosition (public member)
//
//  Synopsis:  Given a bookmark, returns the corresponding row number.
//
//  Arguments: hChapter         hChapter
//             cbBookmark       number of bytes in the bookmark
//             pBookmark        pointer to bookmark
//             pulPosition      row number                       (OUT)
//             pcRows           total number of rows             (OUT)
//
//  Returns:   Success          if inputs are valid.
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark is invalid.
//

STDMETHODIMP
CImpIRowset::GetExactPosition (HCHAPTER hChapter,
                               DBBKMARK cbBookmark,
                               const BYTE *pBookmark,
                               DBCOUNTITEM *pulPosition,
                               DBCOUNTITEM *pcRows )
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::GetExactPosition(%p {%u %p %p %p})",
          this, cbBookmark, pBookmark, pulPosition, pcRows) );

    return GetApproximatePosition(hChapter, cbBookmark, pBookmark,
                                  pulPosition, pcRows );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\seek.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      seek.cxx
//  Author:    Ted Smith  (tedsmith@microsoft.com)
//
//  Contents:  Implementation of RowsetFind
//
//------------------------------------------------------------------------

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetFind specific interface
//
////////////////////////////////////////////////////////////////////////////////




//+-----------------------------------------------------------------------
//
//  Member:    FindNextRows (public member)
//
//  Synopsis:  Given a bookmark and comparison spec, returns cRows HROWs
//             matching.
//
//  Arguments: hChapter         chapter handle
//             hAccessor        accessor for value to be matched
//             pValue           pointer to the value to be matched
//             CompareOp        comparison operation to be used
//             cbBookmark       length of bookmark in bytes
//             pBookmark        pointer to bookmark vector
//             fSkipCurrent     skip current row if TRUE
//             cRows            number of consecutive rows requested to fetch
//             pcRowsObtained   number of consecutive rows actually fetched (OUT)
//             paRows           array of HROWs returned (OUT)
//
//  Returns:   S_OK             if all rows could be fetched.
//             DB_EROWLIMITEDEXCEEDED if cRows is > # rows in rowset
//             DB_E_BADINFO     hAccessor specified binding for more than one
//                              column, or was otherwise gubbish
//             DB_S_ENDOFROWSET if we straddled the end of the rowset
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark was invalid.
//

STDMETHODIMP
CImpIRowset::FindNextRow(HCHAPTER hChapter, HACCESSOR hAccessor, void * pValue,
                          DBCOMPAREOP CompareOp, DBBKMARK cbBookmark,
                          const BYTE *pBookmark, DBROWOFFSET  lRowsOffset,
                          DBROWCOUNT  cRows, DBCOUNTITEM *pcRowsObtained, HROW  **pahRows)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::GetRowsByValues(%p {%u %p %i %i})",
          this, cbBookmark, pBookmark, cRows) );

    HRESULT hr;
    DBCOUNTITEM ulHRow, ulIndex;  // holds HRowNumber, index
    DBROWCOUNT  lIndex2;
    LONG    iter=1;             // -1 for backwards, 1 for forwards
    OSPFIND stdFind=(OSPFIND)0; // stdFind flags for ISimpleTabularData Find function
    OSPCOMP stdComp;
    VARIANT var;
    BOOL    fRowsAllocated=FALSE; // TRUE iff we allocated memory for pahRows
    DBBINDING       *pBinding;
    ULONG           cBindings;
    AccessorFormat  *pAccessor;
    COSPData        *pOSPData = GetpOSPData(hChapter);

    Assert(hAccessor);
    pAccessor = (AccessorFormat *)hAccessor;

    cBindings = pAccessor->cBindings;
    pBinding  = pAccessor->aBindings;

    // Binding must be for one column, and must have a value part..
    // (anything else we should add here??)
    if (cBindings != 1)
    {
        hr = DB_E_BADBINDINFO;
        goto Cleanup;
    }

    if (pcRowsObtained == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    *pcRowsObtained = 0;

    // NULL bookmark argument means use internal cursor
    if (!pBookmark)
    {
        pBookmark = (BYTE *)&pOSPData->_iFindRowsCursor;
        cbBookmark = sizeof(ULONG);
        if (pOSPData->_iFindRowsCursor==DBBMK_INITIAL)
        {
            pOSPData->_iFindRowsCursor = cRows > 0 ? DBBMK_FIRST : DBBMK_LAST;
        }
    }

    hr = THR(Bookmark2HRowNumber(hChapter, cbBookmark, pBookmark, ulHRow));
    if (hr)
    {
        if (hr != DB_S_BOOKMARKSKIPPED) goto Cleanup;
        hr = S_OK;      // this call does not return DB_S_BOOKMARKSKIPPED
    }

    // Convert OLE-DB compareOps to STD compType.
    switch (CompareOp)
    {
        case DBCOMPAREOPS_LT:
            stdComp = OSPCOMP_LT; 
            break;
        case DBCOMPAREOPS_LE:
            stdComp = OSPCOMP_LE;
            break;
        case DBCOMPAREOPS_EQ:
            stdComp = OSPCOMP_EQ;
            break;
        case DBCOMPAREOPS_GE:
            stdComp = OSPCOMP_GE;
            break;
        case DBCOMPAREOPS_GT:
            stdComp = OSPCOMP_GT;
            break;

//        case DBCOMPAREOPS_PARTIALEQ:    // special case
//            hr = E_FAIL;                // not yet implemented
//            goto Cleanup;
//            stdComp = OSPCOMP_EQ;       // TODO - partial not done yet.
//            break;

        case DBCOMPAREOPS_NE:
            stdComp = OSPCOMP_NE;
            break;
        default:
            hr = E_INVALIDARG;
            goto Cleanup;
    }

    ulHRow += lRowsOffset;

    // range check rowIndex, esp after above compuation.
    if ((LONG) ulHRow < 1 || ulHRow > pOSPData->_cSTDRows)
    {
        hr = DB_S_ENDOFROWSET;
        goto Cleanup;
    }

    if (cRows < 0)
    {
        stdFind = OSPFIND_UP;
        cRows = -cRows;     // now its an iteration count, not a direction
        iter = -1;
    }

    // If we were asked to, allocate a block of memory large enough to hold all
    // the rows requested (even though our match might not turn up this many).
    if (!*pahRows)
    {
        *pahRows = (HROW *)CoTaskMemAlloc(sizeof(HROW) * cRows);
        if (!*pahRows)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        fRowsAllocated = TRUE;
    }

    ulIndex = ulHRow;

    // NOTE:: We depend on OLEDB types and Variant types to be the same here.
    // This is true at least through DBYTE_UI8 == VT_UI8
    if (pBinding->wType > DBTYPE_UI8)
    {
        hr = DB_E_UNSUPPORTEDCONVERSION;
        goto Cleanup;
    }

    // special case NULL binding
    if (pBinding->dwPart&DBPART_STATUS &&
        DBSTATUS_S_ISNULL==*(DBSTATUS *)((BYTE *)pValue+pBinding->obStatus))
    {
        var.vt = VT_NULL;
    }
    else if (pBinding->dwPart&DBPART_VALUE)
    {
        CVarToVARIANTARG((void *)((BYTE *)pValue+pBinding->obValue),
                         pBinding->wType, (VARIANTARG *)&var);
    }
    else
    {
        // We were passed neither a NULL binding nor a value.
        hr = DB_E_BADBINDINFO;
        goto Cleanup;
    }

 
    // See if we can find a matching row.
    hr = GetpOSP(hChapter)->find(ulIndex,  pBinding->iOrdinal, var, stdFind, stdComp,
                                 &lIndex2);
    // -1 is returned for not found
    if (lIndex2==-1)
    {
        hr = DB_S_ENDOFROWSET;          // by spec
        goto Cleanup;
    }

    if (FAILED(hr))
    {
        // Do some conversion of OLE error codes to OLE-DB error codes if we
        // know how, otherwise clamp to E_UNEXPECTED
        if (DISP_E_TYPEMISMATCH==hr)
            hr = DB_E_UNSUPPORTEDCONVERSION;
        else
            hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // Get the next cRows rows.. cRows might even be zero
    while (cRows--)
    {
        // Convert our hRowIndex to a real hRow and put it in the result array
        Index2HROW(hChapter, (ULONG)lIndex2, *pahRows[*pcRowsObtained]);

        (*pcRowsObtained)++;
        lIndex2 += iter;

        // About to step off the beginning?
        if (iter<0 && lIndex2==0)
        {
            hr = DB_S_ENDOFROWSET;
            break;
        }

    }

    // Spec says we set internal cursor to bookmark of last row found,
    // not the last row returned!
    if (cRows)
    {
        pOSPData->_iFindRowsCursor = *pahRows[0];
    }

Cleanup:
    if (fRowsAllocated && !*pcRowsObtained)
    {
        CoTaskMemFree((void *)pahRows);
        *pahRows = NULL;
    }

    // We don't need to set a whole clamp list here, since standard OLE-DB error
    // codes are handled by RRETURN now.
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\rowset.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  File:       rowset.cxx
//  Author:     Terry L. Lucas (TerryLu)
//
//  Contents:   CImpIRowset object implementation
//
//  History:
//  07/18/95    TerryLu     Creation of Nile provider implementation.
//  07/28/95    TerryLu     Removed aggregation possiblity for now (no pUnk...).
//  08/02/95    Ido         GetRowsetInfo returns appropriate flags.
//  08/07/95    TerryLu     Added IConnectionPointContainer & IConnectionPoint.
//  08/14/95    TerryLu     Removed IConnectionPointContainer and used CBase.
//

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include <connect.hxx>
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include "coredisp.h"
#endif

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

DeclareTag(tagNileRowsetProvider, "CImpIRowset", "STD Nile provider");
MtDefine(CImpIRowset, DataBind, "CImpIRowset")
MtDefine(CTopRowset, DataBind, "CTopRowset")
MtDefine(CChapRowset, DataBind, "CChapRowset")
MtDefine(COSPData, DataBind, "COSPData")

const CONNECTION_POINT_INFO CImpIRowset::s_acpi[] =
{
    CPI_ENTRY(IID_IRowsetNotify, DISPID_A_ROWSETNOTIFYSINK)
    CPI_ENTRY(IID_IDBAsynchNotify, DISPID_A_ROWSETASYNCHNOTIFYSINK)
    CPI_ENTRY_NULL
};


const CImpIRowset::CLASSDESC CImpIRowset::s_classdesc =
{
        NULL,                               // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        0,                                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
};



//+---------------------------------------------------------------------------
//  Member:     Constructor (public member)
//
//  Synopsis:   Instanciate an IRowset
//
//  Arguments:  None
//
//  Returns:    None

CImpIRowset::CImpIRowset ()
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::constructor -> %p", this ));

#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
#endif

    CBase::Init();

    _NextH2R = 1;                       // for rowmap (vestigial)
    _pUnkOuter = getpIUnknown();
}



//+---------------------------------------------------------------------------
//  Member:     Destructor (public member)
//
//  Synopsis:   Cleanup the IRowset
//
//  Arguments:  None
//
//  Returns:    None

CImpIRowset::~CImpIRowset ()
{
    TraceTag((tagNileRowsetProvider, "CImpIRowset::destructor() -> %p", this));
}



////////////////////////////////////////////////////////////////////////////////
//
//  CBase specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//  Member:     PrivateQueryInterface (public member)
//
//  Synopsis:   Private QI come to here for CBase derived objects.
//
//  Arguments:  riid            IID of requested interface
//              ppv             Interface object to return
//
//  Returns:    S_OK            Interface supported
//              E_NOINTERFACE   Interface not supported.
//

STDMETHODIMP
CImpIRowset::PrivateQueryInterface (REFIID riid, LPVOID * ppv)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::QueryInterface(%p {%p, %p})", this, riid, ppv ));

    Assert(ppv);

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = getpIUnknown();
    }
#define TEST(IFace) else if (IsEqualIID(riid, IID_##IFace)) *ppv = (IFace *)this

    TEST(IRowset);
    TEST(IAccessor);
    TEST(IColumnsInfo);
    TEST(IRowsetLocate);
    TEST(IChapteredRowset);
    TEST(IRowsetChange);
    TEST(IRowsetScroll);
    TEST(IRowsetExactScroll);
    TEST(IRowsetNewRowAfter);
    TEST(IRowsetIdentity);
    TEST(IRowsetChapterMember);
    TEST(IRowsetFind);
    TEST(IRowsetInfo);
    TEST(IConvertType);
    TEST(IDBAsynchStatus);
    TEST(IRowsetFind);
    
#undef TEST

    else if (IsEqualIID(riid, IID_IConnectionPointContainer))
    {
        *((IConnectionPointContainer **)ppv) =
                                            new CConnectionPointContainer(this, NULL);
        if (!*ppv)
        {
            RRETURN(E_OUTOFMEMORY);
        }
    }
    else
    {
        *ppv = NULL;
    }

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//  Member:     Passivate (public member)
//
//  Synopsis:   Called when main CImpIRowset reference count (_ulRefs) drops
//              to zero. Do not call this method directly.  Use Release instead.
//
//  Arguments:  None
//
//  Returns:    Nothing
//

void
CImpIRowset::Passivate ()
{
    FireRowsetEvent(DBREASON_ROWSET_RELEASE, DBEVENTPHASE_DIDEVENT);

    if (_astdcolinfo)
    {
        // If there are subsidary chapters rowsets, clear them.
        // (Column 0, the bookmark column can never have one).
        for (ULONG uCol = 1; uCol <= _cCols; uCol++)
        {
            if (_astdcolinfo[uCol].pChapRowset)
                _astdcolinfo[uCol].pChapRowset->Release();

            FormsFreeString(_astdcolinfo[uCol].bstrName);
        }

        delete [] _astdcolinfo;
    }

    // release all live accessors
    while (!_dblAccessors.IsEmpty())
    {
        ULONG ulRefcount;
        HACCESSOR hAccessor = (HACCESSOR) _dblAccessors.First();
        ReleaseAccessor(hAccessor, &ulRefcount);
    }
    
    CBase::Passivate();
}

void
CTopRowset::Passivate()
{
    ClearInterface(&_pOSPData);

    super::Passivate();
}

CTopRowset::~CTopRowset()
{
    Assert(!_pOSPData && "Rowset released before Passivate!");
}


//+---------------------------------------------------------------------------
//  Member:     GetClassDesc (public member)
//
//  Synopsis:   Return the class descriptor, we only use the descriptor to
//              describe the number of connection points our container can
//              handle and the connection points.
//
//  Arguments:  None
//
//  Returns:    CLASSDESC
//

const CBase::CLASSDESC *
CImpIRowset::GetClassDesc () const
{
    return &s_classdesc;
}


////////////////////////////////////////////////////////////////////////////////
//
//  IRowset specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


#if DBG == 1

ULONG
MaxLengthOfBinding(const DBBINDING &currBinding)
{
    ULONG ulReturn;
    
    switch (currBinding.wType)
    {
        // these are the variable-length types listed in OLE-DB manual Appendix A.
    case DBTYPE_STR:
    case DBTYPE_BYTES:
    case DBTYPE_WSTR:
    case DBTYPE_VARNUMERIC:
        ulReturn = currBinding.cbMaxLen;
        break;

        // and these are the fixed-length types
    case DBTYPE_I2:             ulReturn = sizeof(SHORT);           break;
    case DBTYPE_I4:             ulReturn = sizeof(LONG);            break;
    case DBTYPE_R4:             ulReturn = sizeof(float);           break;
    case DBTYPE_R8:             ulReturn = sizeof(double);          break;
    case DBTYPE_CY:             ulReturn = sizeof(LARGE_INTEGER);   break;
    case DBTYPE_DATE:           ulReturn = sizeof(DATE);            break;
    case DBTYPE_BSTR:           ulReturn = sizeof(BSTR);            break;
    case DBTYPE_IDISPATCH:      ulReturn = sizeof(IDispatch*);      break;
    case DBTYPE_ERROR:          ulReturn = sizeof(SCODE);           break;
    case DBTYPE_BOOL:           ulReturn = sizeof(VARIANT_BOOL);    break;
    case DBTYPE_VARIANT:        ulReturn = sizeof(VARIANT);         break;
    case DBTYPE_IUNKNOWN:       ulReturn = sizeof(IUnknown*);       break;
    case DBTYPE_DECIMAL:        ulReturn = sizeof(DECIMAL);         break;
    case DBTYPE_UI1:            ulReturn = sizeof(BYTE);            break;
    case DBTYPE_I1:             ulReturn = sizeof(BYTE);            break;
    case DBTYPE_UI2:            ulReturn = sizeof(USHORT);          break;
    case DBTYPE_UI4:            ulReturn = sizeof(ULONG);           break;
    case DBTYPE_I8:             ulReturn = sizeof(LARGE_INTEGER);   break;
    case DBTYPE_UI8:            ulReturn = sizeof(ULARGE_INTEGER);  break;
    case DBTYPE_GUID:           ulReturn = sizeof(GUID);            break;
    case DBTYPE_VECTOR:         ulReturn = sizeof(DBVECTOR);        break;
    case DBTYPE_NUMERIC:        ulReturn = sizeof(DB_NUMERIC);      break;
    case DBTYPE_DBDATE:         ulReturn = sizeof(DBDATE);          break;
    case DBTYPE_DBTIME:         ulReturn = sizeof(DBTIME);          break;
    case DBTYPE_DBTIMESTAMP:    ulReturn = sizeof(DBTIMESTAMP);     break;
    case DBTYPE_HCHAPTER:       ulReturn = sizeof(HCHAPTER);        break;
    case DBTYPE_FILETIME:       ulReturn = sizeof(FILETIME);        break;
    case DBTYPE_PROPVARIANT:    ulReturn = sizeof(PROPVARIANT);     break;

        // finally, in case we missed something...
    default:
        AssertSz(0, "Unexpected type");
        ulReturn = currBinding.cbMaxLen;
        break;
    }

    return ulReturn;
}


//+---------------------------------------------------------------------------
//  Member:     DbgCheckOverlap (private member only in debug build)
//
//  Synopsis:   Verifies that a DBBINDING does not have any value, length or
//              status data overlap. Overlap problem will assert.
//
//  Arguments:  currBinding     Binding to validate
//
//  Returns:    None
//

void
CImpIRowset::DbgCheckOverlap (const DBBINDING &currBinding)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::DbgCheckOverlap({%p})", &currBinding ));

    DBPART    currPart = currBinding.dwPart;
    short     sCount = 0;
    ULONG     left[3], right[3];

    if (currPart & DBPART_VALUE)
    {
        left[sCount] = currBinding.obValue;
        right[sCount] = left[sCount] + MaxLengthOfBinding(currBinding) - 1;
        sCount++;
    }

    if (currPart & DBPART_LENGTH)
    {
        left[sCount] = currBinding.obLength;
        right[sCount] = left[sCount] + sizeof(ULONG) - 1;
        sCount++;
    }

    if (currPart & DBPART_STATUS)
    {
        left[sCount] = currBinding.obStatus;
        right[sCount] = left[sCount] + sizeof(ULONG) - 1;
        sCount++;
    }

    // More than one comming in, check overlapping.
    if (((sCount > 1) &&
         ((left[0] <= right[1]) && (right[0] >= left[1])) ) || /*0 & 1 intersect*/
        ((sCount > 2)                                     &&
         (((left[1] <= right[2]) && (right[1] >= left[2]))  || /*1 & 2 intersect*/
          ((left[0] <= right[2]) && (right[0] >= left[2])) ))) /*0 & 2 intersect*/
    {
        Assert(!"Accessor values overlap");
    }
}
#endif  // DBG == 1



//+---------------------------------------------------------------------------
//  Member:     CreateAccessor (public member)
//
//  Synopsis:   Creates a set of bindings that can be used to send data
//              to or retrieve data from the data cache.
//
//  Arguments:  eAccFlags           How bindings are used
//              cBindings           Number of Bindings
//              aBindings           Array of DBBINDINGS
//              cbRowSize           ignored -- only used for IReadData
//              phAccessor          Accessor Handle
//              aStatus             Array of status words, one per binding
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_OUTOFMEMORY           Couldn't allocate memory
//              E_INVALIDARG            Invalid arg
//              E_UNEXPECTED            Zombie State
//              DB_E_BADACCESSORFLAGS   Bad eAccFlags
//              DB_E_BYREFACCESSORNOTSUPPORTED  Can't support PASSBYREF
//              DB_E_ERRORSOCCURRED     One or more bindings failed, see aStatus
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//              DB_E_NULLACCESSORNOTSUPPORTED   No bindings.
//

STDMETHODIMP
CImpIRowset::CreateAccessor (DBACCESSORFLAGS eAccFlags,
                             DBCOUNTITEM cBindings,
                             const DBBINDING aBindings[],
                             DBLENGTH /* cbRowSize */,
                             HACCESSOR * phAccessor,
                             DBBINDSTATUS aStatus[])
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::CreateAccessor(%p {%p, %u, %p, %p, %p})",
             this,
             eAccFlags, cBindings, aBindings, phAccessor, aStatus ));

    HRESULT             hr = S_OK;
    AccessorFormat      *pAccessor;
    ULONG               ibind;
    ULONG               icol;
    ULONG               cValidBindings = 0;  // number of validated bindings

    // Check Parameters
    if (phAccessor == NULL || (cBindings>0 && aBindings==NULL))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *phAccessor = NULL;

    // Do a quick check to make sure we recognize the binding type.
    // TODO: should we silently ignore DBACCESSOR_OPTIMIZE?
    if (eAccFlags != DBACCESSOR_ROWDATA)
    {
            hr = DB_E_BADBINDINFO;
            goto Cleanup;
    }

    // Sanity check on the bindings the user gave us.
    // Specifically hunt down some common client coding bugs.
    for (ibind = 0; ibind < cBindings; ibind++)
    {
        const DBBINDING &   currBinding = aBindings[ibind];
        DBPART              currPart = currBinding.dwPart;
        DBBINDSTATUS        dbsStatus = DBBINDSTATUS_OK;

        icol = currBinding.iOrdinal;
        if (icol > (_cCols + 1))        // +1 for bookmark info
        {
            Assert(!"Bad column number");
            dbsStatus = DBBINDSTATUS_BADORDINAL;
        }

        // At least one of these valid parts has to be set. In SetData I assume it is.
        if (!(currPart & (DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS)))
        {
            Assert(!"dwPart missing VALUE, LENGTH or STATUS being specified");
            dbsStatus = DBBINDSTATUS_BADBINDINFO;
        }

        // other binding problems forbidden by OLE-DB
        const DBTYPE currType = currBinding.wType;
        const DBTYPE currTypePtr = currType &(DBTYPE_BYREF | DBTYPE_ARRAY | DBTYPE_VECTOR);
        const DBTYPE currTypeBase = currType & 0xffff;
        if (
            // part other than value, length, or status
            (currPart & ~(DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS)) ||
            // type is empty or null
            (currType==DBTYPE_EMPTY || currType==DBTYPE_NULL) ||
            // byref or'd with empty, null, or reserved
            (currType&DBTYPE_BYREF && (currTypeBase==DBTYPE_EMPTY ||
                                       currTypeBase==DBTYPE_NULL || currType&DBTYPE_RESERVED)) ||
            // more than one of byref, array, and vector
            (!(currTypePtr==0 || currTypePtr==DBTYPE_BYREF ||
               currTypePtr==DBTYPE_ARRAY || currTypePtr==DBTYPE_VECTOR)) ||
            // provider owned memory for non-pointer type
            (!currTypePtr && currBinding.dwMemOwner==DBMEMOWNER_PROVIDEROWNED)
           )
        {
            dbsStatus = DBBINDSTATUS_BADBINDINFO;
        }

        // we only support client owned memory
        if (currBinding.dwMemOwner != DBMEMOWNER_CLIENTOWNED)
            dbsStatus = DBBINDSTATUS_BADBINDINFO;
        
        CSTDColumnInfo &  stdColInfo = _astdcolinfo[ColToDBColIndex(icol)];

        // Check for legal type conversion
        if (stdColInfo.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK)
        {
            // For bookmarks, we support an explicit list of target types.
            if ((currBinding.wType != (DBTYPE_UI1 | DBTYPE_VECTOR)) &&
                (currBinding.wType != DBTYPE_BYTES) &&
                (currBinding.wType != DBTYPE_I4) &&
                (currBinding.wType != DBTYPE_UI4)) // sign confusion in DLcursor
            {
                dbsStatus = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
            }
            // furthermore, consumer must give us enough room for the bookmark
            if (currBinding.wType == DBTYPE_BYTES &&
                currBinding.cbMaxLen < sizeof(HROW))
            {
                dbsStatus = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
            }
        }
        else if (stdColInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER)
        {
            if (currBinding.wType != DBTYPE_HCHAPTER)
            {
                dbsStatus = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
            }
        }
        else
        {   // for non-bookmarks, use my IConvertType::CanConvert
            if (CanConvert(stdColInfo.dwType, currBinding.wType,
                           DBCONVERTFLAGS_COLUMN) != S_OK)
            {
                dbsStatus = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
            }
        }

        // Check for correct sizing of types.
        // Sometimes macros are used which do sizeof(), but specify wrong type.
        // (i.e. bind a char[20] as a DWORD.)

// TODO: Need to implement NOW ***TLL***
//        if (FAILED(CheckSizeofDBType(aBindings[ibind].dwType,
//                                     aBindings[ibind].cbMaxLen )))
//        {
//            hr = E_FAIL;
//            goto Cleanup;
//        }

        if (aStatus)
            aStatus[ibind] = dbsStatus;
        if (dbsStatus == DBBINDSTATUS_OK)
        {
            ++ cValidBindings;
        }

#if DBG == 1
        DbgCheckOverlap(currBinding);
#endif  // DBG == 1
    }

    if (cValidBindings < cBindings)
    {
        goto Cleanup;
    }
    
    // Make a copy of the client's binding array, and the type of binding.
    // We could potentially give out direct ptrs to the structure.
    // Note: Accessors with no bindings (cBindings = 0) are legal, that is the
    //       AccessorFormat for a null accessor has just the dwAccFlags and
    //       cBindings fields the aBindings[] is not allocated.

    pAccessor = new(cBindings) AccessorFormat(1, eAccFlags, cBindings, aBindings);
    if (pAccessor == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // add the accessor to the active list
    _dblAccessors.Append(pAccessor);
    
    *phAccessor = (HACCESSOR)pAccessor;

    hr = S_OK;

Cleanup:
    if (hr == S_OK)     // no global errors, check whether bindings worked
        hr = cValidBindings<cBindings   ? DB_E_ERRORSOCCURRED
                                        : S_OK;
    return hr;
}



//+---------------------------------------------------------------------------
//  Member:     GetBindings (public member)
//
//  Synopsis:   Returns the bindings in an accessor
//
//  Arguments:  hAccessor       Accessor Handle
//              peAccFlags      Accessor Type flag
//              pcBindings      Number of Bindings returned
//              paBindings      Bindings
//
//  Returns:    S_OK                    if everything is fine,
//              E_INVALIDARG            peAccFlags/pcBinding/paBinding was NULL
//              E_OUTOFMEMORY           Out of Memory
//              E_UNEXPECTED            Zombie State
//              DB_E_BADACCESSORHANDLE  Invalid Accessor given
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//

STDMETHODIMP
CImpIRowset::GetBindings (HACCESSOR hAccessor,
                          DBACCESSORFLAGS * peAccFlags,
                          DBCOUNTITEM * pcBindings,
                          DBBINDING ** paBindings )
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetBindings(%p {%p, %p, %p, %p})",
             this, hAccessor, peAccFlags, pcBindings, paBindings ));

    HRESULT     hr = S_OK;
    ULONG       cBindingSize;

    Assert(hAccessor);

    // Retrieve our accessor structure from the client's hAccessor,
    // make a copy of the bindings for the user, then done.
    AccessorFormat    *pAccessor = (AccessorFormat *)hAccessor;

    // Check Other Parameters
    if (!(peAccFlags && pcBindings && paBindings))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Set values that should be returned if an error occurrs
    *peAccFlags = DBACCESSOR_INVALID;
    *pcBindings = 0;
    *paBindings = NULL;

    // Allocate and return Array of bindings
    cBindingSize = pAccessor->cBindings * sizeof(DBBINDING);
    *paBindings = (DBBINDING *)CoTaskMemAlloc(cBindingSize);
    if (*paBindings)
    {
        *peAccFlags  = pAccessor->dwAccFlags;
        *pcBindings = pAccessor->cBindings;
        memcpy(*paBindings, pAccessor->aBindings, cBindingSize);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    return hr;
}


HRESULT
CImpIRowset::EnsureReferencedRowset(HCHAPTER hChapter, ULONG uStdRow, ULONG icol,
                                    OLEDBSimpleProvider **ppOSP)
{
    HRESULT hr = S_OK;
    VARIANT varOSP;             // Variant to hold returned OSP
    OLEDBSimpleProvider *pOSP = NULL;
    OLEDBSimpleProvider *pOSPparent;
    CSTDColumnInfo& stdColInfo = _astdcolinfo[ColToDBColIndex(icol)];
    VariantInit(&varOSP);

    // if the call was made only to create the child rowset, and it already
    // exists, there's nothing to do.
    if (stdColInfo.pChapRowset != NULL && ppOSP == NULL)
        goto Cleanup;

    if (stdColInfo.dwType != DBTYPE_HCHAPTER)
    {
        hr = DB_E_NOTAREFERENCECOLUMN;
        goto Cleanup;
    }

    // get the OSP and (row,col) from which to fetch a child OSP.
    if (uStdRow > 0)
    {
        // if we have an OSP and (row,col) already, just use them.
        // This is the normal case, when GetData is trying to retrieve
        // a chapter handle from a field.
        pOSPparent = GetpOSP(hChapter);
    }
    else
    {
        // if we don't have an OSP and row, arbitrarily use the first row
        // of the metaOSP.  This is the case when a client calls
        // GetReferencedRowset on a column before actually fetching any
        // values from that column.  This strategy will fail if the metaOSP
        // doesn't have any rows, but that seems pretty unlikely.
        uStdRow = 1;
        pOSPparent = GetpMetaOSP();
    }

    // fetch the child OSP, on which we'll create the child rowset
    hr = pOSPparent->getVariant(uStdRow, icol, OSPFORMAT_RAW, &varOSP);

    if (hr || varOSP.vt != VT_UNKNOWN)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure it's an OSP
    hr = varOSP.punkVal->QueryInterface(IID_OLEDBSimpleProvider, (void **)&pOSP);
    if (hr)
        goto Cleanup;

    // return the OSP, if desired
    if (ppOSP)
    {
        pOSP->AddRef();
        *ppOSP = pOSP;
    }

    // make a child rowset, if needed
    if (stdColInfo.pChapRowset == NULL)
    {
        hr = CChapRowset::CreateRowset(pOSP,
                                       (IUnknown **)&stdColInfo.pChapRowset);
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    ClearInterface(&pOSP);
    VariantClear(&varOSP);
    
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     GetChapterData
//
//  Synopsis:   The Chapter returning part of GetData, pulled out for readability
//
//  Arguments:  see below
//
//  Returns:    S_OK                    if everything is fine,
//              DB_S_ERRORSOCCURRED     for compound accessor, partial success
//              DB_E_ERRORSOCCURRED     for compound accessor, all columns failed
//              E_FAIL                  Catch all (pData is NULL)
//              E_OUTOFMEMORY           Out of Memory
//              E_UNEXPECTED            Zombie State
//              DB_E_BADACCESSORHANDLE  Invalid Accessor given
//

HRESULT
CImpIRowset::GetChapterData(XferInfo &xfrData, CSTDColumnInfo &stdColInfo,
                            DBBINDING &currBinding, HCHAPTER hChapter,
                            HROW hrow, ULONG uStdRow, ULONG icol)
{
    HRESULT hr;
    OLEDBSimpleProvider *pOSP = NULL;
    HCHAPTER hChildChapter = NULL;

    *xfrData.pdbStatus = DBSTATUS_E_CANTCREATE; // assume failure
    Assert(currBinding.wType == DBTYPE_HCHAPTER);

    hr = EnsureReferencedRowset(hChapter, uStdRow, icol, &pOSP);
    if (hr)
        goto Cleanup;

    Assert(stdColInfo.pChapRowset);
    hr = stdColInfo.pChapRowset->EnsureHChapter(hrow, pOSP, &hChildChapter);
    if (hr)
        goto Cleanup;

    *(HCHAPTER *)xfrData.pData = hChildChapter;
    *xfrData.pdbStatus = DBSTATUS_S_OK;

Cleanup:

    ClearInterface(&pOSP);

    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     GetData (public member)
//
//  Synopsis:   Retrieves data from the rowset's cache
//
//  Arguments:  hRow        Row Handle
//              hAccessor   Accessor to use
//              pData       Pointer to buffer where data should go.
//
//  Returns:    S_OK                    if everything is fine,
//              DB_S_ERRORSOCCURRED     for compound accessor, partial success
//              DB_E_ERRORSOCCURRED     for compound accessor, all columns failed
//              E_FAIL                  Catch all (pData is NULL)
//              E_OUTOFMEMORY           Out of Memory
//              E_UNEXPECTED            Zombie State
//              DB_E_BADACCESSORHANDLE  Invalid Accessor given
//

STDMETHODIMP
CImpIRowset::GetData (HROW hRow, HACCESSOR hAccessor, void *pData)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetData(%p {%p, %p, %p})",
             this, hRow, hAccessor, pData ));

    HRESULT         hr = S_OK;
    HRESULT         hrIndex;
    HRESULT         hrLastFailure = S_OK;
    AccessorFormat  *pAccessor;
    DBBINDING       *pBinding;
    ULONG           cBindings;
    ULONG           ibind;
    ULONG           ulErrorCount;
    HCHAPTER        hChapter;
    DBCOUNTITEM     uStdRow;

    Assert(hAccessor);
    pAccessor = (AccessorFormat *)hAccessor;

    cBindings = pAccessor->cBindings;
    pBinding  = pAccessor->aBindings;

    // Ensure a place to put data, unless the accessor is the null accessor then
    // a NULL pData is okay.
    if (pData == NULL && cBindings != 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hrIndex = HROW2Index(hRow, uStdRow);
    if (hrIndex)
    {
        // Most errors mean immediate failure.
        // If row has been deleted, or is being deleted, only allow
        //  bookmark fetches.
        // Check in advance rather than in loop below, so that we don't
        //  have a problem on what success/error code to return after
        //  a DBVECTOR may have been allocated.  Avoid leaks!
        
        if (hrIndex != DB_E_DELETEDROW && hrIndex != DB_E_NOTREENTRANT)
        {
            hr = hrIndex;
            goto Cleanup;
        }
        for (ibind = 0; ibind < cBindings; ibind++)
        {
            if (pBinding[ibind].iOrdinal != 0)   // not BOOKMARK column
            {
                hr = DB_E_DELETEDROW;
                goto Cleanup;
            }
        }
    }

    hChapter = ChapterFromHRow((ChRow) hRow);

    // These restrictions should have been tested by CreateAccessor
    Assert(pAccessor->dwAccFlags == DBACCESSOR_ROWDATA);

    ulErrorCount = 0;
    for (ibind = 0; ibind < cBindings; ibind++)
    {
        XferInfo        xfrData;
        DBBINDING &     currBinding = pBinding[ibind];
        DBPART          dwPart = currBinding.dwPart;
        ULONG           icol = currBinding.iOrdinal;
        CSTDColumnInfo &stdColInfo = _astdcolinfo[ColToDBColIndex(icol)];
        DBLENGTH        dblenDummyLength;
        DBSTATUS        dbDummyStatus;

        xfrData.dwDBType = stdColInfo.dwType;
        xfrData.dblenDataMaxLength = currBinding.cbMaxLen;
        xfrData.dwAccType = currBinding.wType;
        xfrData.pData = dwPart & DBPART_VALUE
                        ? ((BYTE *) pData + currBinding.obValue)
                        : NULL;
        xfrData.pdblenXferLength = dwPart & DBPART_LENGTH
                        ? (DBLENGTH *)((BYTE *) pData + currBinding.obLength)
                        : &dblenDummyLength;
        xfrData.pdbStatus = dwPart & DBPART_STATUS
                        ? (DBSTATUS *)((BYTE *) pData + currBinding.obStatus)
                        : &dbDummyStatus;

        // What are we retrieving a bookmark or regular column data?
        if (stdColInfo.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK)
        {
            // dlcursor seems confused about UI4 vs. I4 -cfranks 11Jun96
            if (currBinding.wType == DBTYPE_I4 ||
                currBinding.wType == DBTYPE_UI4 ||
                currBinding.wType == DBTYPE_BYTES)
            {
                Assert(currBinding.wType != DBTYPE_BYTES ||
                    currBinding.cbMaxLen >= sizeof(ULONG));
                *xfrData.pdblenXferLength = sizeof(ULONG);
                if (xfrData.pData)
                {
                    *(ULONG *)(xfrData.pData) = (ULONG)hRow;
                }
            }
            else
            {
                Assert(currBinding.wType == (DBTYPE_VECTOR|DBTYPE_UI1));
                *xfrData.pdblenXferLength = sizeof(DBVECTOR);
                if (xfrData.pData)
                {
                    // Get the bookmark.
                    ((DBVECTOR *)(xfrData.pData))->size = sizeof(HROW);
                    HROW *pu = (HROW *)CoTaskMemAlloc(sizeof(HROW));
                    if (!pu)
                    {
                        *xfrData.pdbStatus = DBSTATUS_E_CANTCREATE;
                        hr = E_OUTOFMEMORY;
                        goto LoopCleanup;
                    }

                    *pu = hRow;
                    ((DBVECTOR *)(xfrData.pData))->ptr = pu;
                }
            }

            *xfrData.pdbStatus = DBSTATUS_S_OK;

            hr = S_OK;
        }
        else if (stdColInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER)
        {
            hr = GetChapterData(xfrData, stdColInfo, currBinding, hChapter,
                           hRow, uStdRow, icol);
        }
        else
        {
            // handles this case above
            Assert(!hrIndex);
            hr = DataCoerce(DataFromProvider, hChapter, uStdRow, icol, xfrData);
        }

LoopCleanup:
        if (hr)
        {
            hrLastFailure = hr;
            ulErrorCount++;
        }
    }

    // We report any lossy conversions with a special status.
    if (ulErrorCount)
    {
        Assert(hrLastFailure != S_OK);
        hr = (ulErrorCount == cBindings) ? DB_E_ERRORSOCCURRED
                                         : DB_S_ERRORSOCCURRED;
    }
    else
    {
        Assert(hr == S_OK);
    }
Cleanup:



    RRETURN4(hr, DB_E_ERRORSOCCURRED, DB_S_ERRORSOCCURRED,
                DB_E_UNSUPPORTEDCONVERSION, DB_E_BADACCESSORHANDLE);
}

//+---------------------------------------------------------------------------
//  Member:     GetNextRows (public member)
//
//  Synopsis:   Fetches rows squentially, remembering the previous position
//
//  Arguments:  hChapter            Chapter handle
//              lRowsOffset         Rows to skip before reading
//              cRows               Number of rows to fetch
//              pcRowsObtained      Number of rows obtained
//              pahRows             Array of Hrows obtained
//
//  Returns:    S_OK                    if everything is fine,
//              E_INVALIDARG            invalid argument
//              E_OUTOFMEMORY           Out of Memory
//              E_UNEXPECTED            Zombie State
//              DB_E_BADACCESSORHANDLE  Invalid Accessor given
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//

STDMETHODIMP
CImpIRowset::GetNextRows (HCHAPTER hChapter,
                          DBROWOFFSET lRowsOffset,
                          DBROWCOUNT cRows,
                          DBCOUNTITEM * pcRowsObtained,
                          HROW ** pahRows)
{
    HRESULT hr;
    DBCOUNTITEM ulRow;
    BOOL fRowsAllocated = FALSE;
    COSPData * pOSPData = GetpOSPData(hChapter);

    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetNextRows(%p {%l, %l, %p, %p})",
             this, lRowsOffset, cRows, pcRowsObtained, pahRows ));

    *pcRowsObtained = 0;                // in case of error

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Error;
    }
    
    // Allocate memory block if we need to:
    // TODO:: We're not freeing this on failure right now!!!
    if (!*pahRows)
    {
        *pahRows = (HROW *)CoTaskMemAlloc(sizeof(HROW) * cRows);
        if (!*pahRows)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        fRowsAllocated = TRUE;
    }

    // First time?
    if (DBBMK_INITIAL==pOSPData->_iGetNextCursor)
    {
        if (cRows > 0)
        {
            pOSPData->_iGetNextCursor =
                (ULONG) (HRowFromIndex(hChapter, 1)).ToNileHRow();
        }
        else
        {
            // Negative cRow means start at end and go backwards
            pOSPData->_iGetNextCursor =
                (ULONG) (HRowFromIndex(hChapter, pOSPData->_cSTDRows)).ToNileHRow();
        }
    }

    hr = Bookmark2HRowNumber(hChapter, sizeof(pOSPData->_iGetNextCursor),
                             (BYTE *)&pOSPData->_iGetNextCursor, ulRow);
    if (hr)
    {
        if (hr != DB_S_BOOKMARKSKIPPED) goto Error;
        // Surprsingly, this call is not supposed to return DB_S_BOOKMARKSKIPPED
        hr = S_OK;
    }

    // GenerateHRowsFromHRowNumber also takes care of firing events
    hr = THR(GenerateHRowsFromHRowNumber(hChapter, ulRow, lRowsOffset, cRows,
                                         pcRowsObtained, pahRows));

    // Advance cursor
    if (!hr)                            // Don't advance on error?
    {
        ulRow += lRowsOffset +
                 (cRows > 0 ? *pcRowsObtained : -(LONG)*pcRowsObtained);
        pOSPData->_iGetNextCursor = (ULONG) (HRowFromIndex(hChapter, ulRow)).ToNileHRow();
    }

Error:
    return hr;
}



//+---------------------------------------------------------------------------
//  Member:     RestartPosition (public member)
//
//  Synopsis:   Repositions the "next fetch position" to the start of the
//              rowset/chapter.
//
//  Arguments:  hChapter            Chapter handle
//
//  Returns:    S_OK                    if everything is fine,
//              DB_S_COLUMNSCHANGED     see OLE DB docs
//              E_FAIL                  provider-specific error
//              E_UNEXPECTED            Zombie State
//              DB_E_BADCHAPTER         invalid chapter
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//              DB_E_ROWSNOTRELEASED    provider insists all HROWS released
//

STDMETHODIMP
CImpIRowset::RestartPosition (HCHAPTER hChapter)
{
    HRESULT hr = S_OK;
    COSPData *pOSPData = GetpOSPData(hChapter);

    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::RestartPosition(%p {%p})",
             this, hChapter ));

    if (pOSPData)
    {
        pOSPData->_iGetNextCursor = DBBMK_INITIAL;    // reset cursor
    }
    else
    {
        hr = DB_E_BADCHAPTER;
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     GetReferencedRowset (public member)
//
//  Synopsis:   Returns an interface pointer to the rowset to which the bookmark
//              applies.
//
//  Arguments:  iOrdinal            Bookmark or Chapter Column
//              riid                ID of desired interface
//              ppReferencedRowset  where to put interface pointer 
//
//  Returns:    S_OK                        if everything is fine,
//              E_FAIL                      Provider specific Error
//              E_INVALIDARG                Invalid parameters were specified
//              E_UNEXPECTED                Zombie State
//              DB_E_NOTAREFERENCECOLUMN    iColumn contains no Bookmarks or
//                                          Chapters
//              DB_E_NOTREENTRANT           Can not enter function at this time
//

STDMETHODIMP
CImpIRowset::GetReferencedRowset (DBORDINAL iOrdinal, REFIID riid, IUnknown **ppReferencedRowset)
{
    HRESULT hr;
    CImpIRowset *pRowset;

    *ppReferencedRowset = NULL;

    hr = EnsureReferencedRowset(DB_NULL_HCHAPTER, 0, iOrdinal, NULL);
    if (hr)
        goto Cleanup;
    
    pRowset = _astdcolinfo[iOrdinal].pChapRowset;
    Assert(pRowset);
    if (pRowset)
        hr = pRowset->QueryInterface(riid, (void **)ppReferencedRowset);

Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     GetProperties (public member)
//
//  Synopsis:   Returns current settings of properites supported by
//              the rowset.
//
//  NOTE:       this is a temporary minimum implementation, which only handles
//              the properties that DLCURSOR cares about.
//
//  Arguments:  cPropIDSets          number of explicitly requested propID
//                                   sets; 0 means all supported by callee.
//              aPropIDSets          if cPropIDSets != 0 array of propID sets for
//                                   which properties are being requested
//              pcPropSets           where to return # of DBPROPSETs
//              paPropSets           where to return ptr to DBPROPSETs
//              
//
//  Returns:    S_OK                 The method succeeded
//              E_FAIL               Provider-specific error
//              E_INVALIDARG         Bad arguments (several possibilities)
//              E_OUTOFMEMORY        Provider can't allocate sufficient memory
//              E_UNEXPECTED         Zombie state
//              DB_S_ERRORSOCCURRED  Some but not all properties failed
//              DB_E_ERRORSOCCURRED  All properties failed
//

STDMETHODIMP
CImpIRowset::GetProperties (const ULONG cPropIDSets, const DBPROPIDSET aPropIDSets[],
                            ULONG *pcPropSets, DBPROPSET **paPropSets)
{
    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::GetProperties(%p {%u, %p, %p, %p})", this,
              cPropIDSets, aPropIDSets, pcPropSets, paPropSets ));

    HRESULT hr;
    ULONG cPropSets = cPropIDSets;
    ULONG iPropSet;
    DBPROPSET* aPropSets = 0;
    BOOL bFailures=FALSE, bSuccesses=FALSE; // did none, some or all properties succeed

    if (cPropIDSets == 0)       // means "return all properties"
    {
        cPropSets = _dbpProperties.GetNPropSets();
    }
    
    // check for bad arguments
    if (pcPropSets==0 || paPropSets==0 || (cPropIDSets>0 && aPropIDSets==0))
    {
        hr = E_INVALIDARG; 
        goto Cleanup;
    }

    for (iPropSet=0; iPropSet<cPropIDSets; ++iPropSet)
    {
        if (aPropIDSets[iPropSet].cPropertyIDs > 0  &&
            aPropIDSets[iPropSet].rgPropertyIDs == 0)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    // get memory for results
    aPropSets = (DBPROPSET *)
                        CoTaskMemAlloc(sizeof(DBPROPSET) * cPropSets);
    if (aPropSets == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    for (iPropSet=0; iPropSet<cPropSets; ++iPropSet)
    {
        aPropSets[iPropSet].rgProperties = 0;   // makes error cleanup simpler
    }
    
    // fill in each property set
    for (iPropSet=0; iPropSet<cPropSets; ++iPropSet)
    {
        DBPROPSET* pPropSet = & aPropSets[iPropSet];

        if (cPropIDSets == 0)               // copying all properties
        {
            hr = _dbpProperties.CopyPropertySet(iPropSet, pPropSet);
            if (hr)
                goto Error;
            bSuccesses = TRUE;
        }
        else if (aPropIDSets[iPropSet].cPropertyIDs == 0)   // all props for this GUID
        {
            hr = _dbpProperties.CopyPropertySet(aPropIDSets[iPropSet].guidPropertySet,
                                                pPropSet);
            if (hr == E_FAIL)           // no properties for this GUID
            {
                pPropSet->cProperties = 0;
                pPropSet->rgProperties = 0;
                pPropSet->guidPropertySet = aPropIDSets[iPropSet].guidPropertySet;
                hr = S_OK;
                bFailures = TRUE;
            }
            else if (hr)
                goto Error;
            bSuccesses = TRUE;
        }
        else                                // explicit list of properties
        {
            const DBPROPIDSET* pPropIDSet = & aPropIDSets[iPropSet];
            ULONG iProp;
            
            pPropSet->cProperties = pPropIDSet->cPropertyIDs;
            pPropSet->guidPropertySet = pPropIDSet->guidPropertySet;
            
            // get memory for property array
            pPropSet->rgProperties = (DBPROP *)
                            CoTaskMemAlloc(sizeof(DBPROP) * pPropIDSet->cPropertyIDs);
            if (pPropSet->rgProperties == 0)
            {
                hr = E_OUTOFMEMORY;
                pPropSet->cProperties = 0;
                goto Error;
            }

            // fill in property array
            for (iProp=0; iProp<pPropIDSet->cPropertyIDs; ++iProp)
            {
                const DBPROP* pProp = _dbpProperties.GetProperty(pPropIDSet->guidPropertySet,
                                                pPropIDSet->rgPropertyIDs[iProp]);
                if (pProp)
                {
                    pPropSet->rgProperties[iProp] = *pProp;
                    bSuccesses = TRUE;
                } else
                {
                    pPropSet->rgProperties[iProp].dwPropertyID = pPropIDSet->rgPropertyIDs[iProp];
                    pPropSet->rgProperties[iProp].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
                    bFailures = TRUE;
                }
            }
        }
    }

    *pcPropSets = cPropSets;
    *paPropSets = aPropSets;
    hr = bFailures  ? bSuccesses    ? DB_S_ERRORSOCCURRED
                                    : DB_E_ERRORSOCCURRED
                    : S_OK;

Cleanup:
    RRETURN2 (hr, DB_S_ERRORSOCCURRED, DB_E_ERRORSOCCURRED);

Error:
    // release memory
    if (aPropSets)
    {
        for (iPropSet=0; iPropSet<cPropSets; ++iPropSet)
        {
            CoTaskMemFree(aPropSets[iPropSet].rgProperties);
        }
    }
    CoTaskMemFree(aPropSets);

    // tell caller we didn't allocate memory
    *pcPropSets = 0;
    *paPropSets = 0;
    
    goto Cleanup;
}    


//+---------------------------------------------------------------------------
//  Member:     GetSpecification (public member)
//
//  Synopsis:   Returns the interface pointer of object that created the rowset
//
//  Arguments:  riid                IID of the interface being queried for
//              ppSpecification     Interface that instantiated this object
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_INVALIDARG            Invalid parameters were specified
//              E_NOINTERFACE           The provider did not support the riid
//              E_UNEXPECTED            Zombie State
//              DB_E_NOTREENTRANT       Can not enter function at this time
//

STDMETHODIMP
CImpIRowset::GetSpecification (REFIID riid, IUnknown **ppSpecification)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetSpecification(%p {%p, %p})",
             this, riid, ppSpecification ));

    HRESULT hr = E_NOINTERFACE;

    if (ppSpecification == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppSpecification = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     AddRefAccessor (public member)
//
//  Synopsis:   AddRefs an Accessor
//
//  Arguments:  hAccessor   Accessor to addref
//              pcRefCount  pointer to where to return new refcount
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_UNEXPECTED            Zombie State
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//

STDMETHODIMP
CImpIRowset::AddRefAccessor (HACCESSOR hAccessor, ULONG *pcRefCount)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::AddRefAccessor(%p {%p %p})", this, hAccessor, pcRefCount ));

    Assert(hAccessor);

    AccessorFormat *pAccessor = (AccessorFormat*) hAccessor;

    ++ pAccessor->cRefCount;
    if (pcRefCount)
        *pcRefCount = pAccessor->cRefCount;
        
    return S_OK;
}



//+---------------------------------------------------------------------------
//  Member:     ReleaseAccessor (public member)
//
//  Synopsis:   Releases an Accessor
//
//  Arguments:  hAccessor   Accessor to release
//              pcRefCount  pointer to where to return new refcount
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_UNEXPECTED            Zombie State
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//

STDMETHODIMP
CImpIRowset::ReleaseAccessor (HACCESSOR hAccessor, ULONG *pcRefCount)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::ReleaseAccessor(%p {%p %p})", this, hAccessor, pcRefCount ));

    Assert(hAccessor);

    AccessorFormat *pAccessor = (AccessorFormat*) hAccessor;
    Assert(pAccessor->cRefCount > 0);

    -- pAccessor->cRefCount;
    if (pcRefCount)
        *pcRefCount = pAccessor->cRefCount;
        
    if (pAccessor->cRefCount == 0)
    {
        // remove the accessor from the active list
        _dblAccessors.Remove(pAccessor);
        
        // Free the actual structure.
        delete pAccessor;
    }
    return S_OK;
}


//+---------------------------------------------------------------------------
//  Member:     AddRefRows (public member)
//
//  Synopsis:   Bump ref counts on rows.
//
//  Arguments:  cRow            Number of rows to AddRef
//              ahRow           Array of handles of rows to be released
//              pcRowCounted    Count of rows actually AddRefed, may be NULL
//              aRefCount       Array of refcnts for the rows
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_INVALIDARG            Invalid parameters were specified
//              DB_S_ERRORSOCCURRED     Some but not all rows were invalid
//              DB_E_ERRORSOCCURRED     All rows were invalid
//

STDMETHODIMP
CImpIRowset::AddRefRows (DBCOUNTITEM cRows,
                         const HROW ahRow[],
                         DBREFCOUNT aRefCount[],
                         DBROWSTATUS aRowStatus[])
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::AddRefRows(%p {%u %p %p %p})",
             this, cRows, ahRow, aRefCount, aRowStatus ));
             
    HRESULT hr = S_OK;
    ULONG cErrors = 0;          // number of rows that failed
    ULONG iRow;

    if (ahRow == NULL && cRows != 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (iRow=0; iRow < cRows; ++iRow)
    {
        LogErrors(aRowStatus, iRow, 1, DBROWSTATUS_S_OK);
        
        if (ahRow[iRow] == NULL)
        {
            Assert(!"Null HROW to CImpIRowset::AddRefRows.");
            LogErrors(aRowStatus, iRow, 1, DBROWSTATUS_E_INVALID);
            ++ cErrors;
        }
        else
        {
            if (aRefCount)
            {
                // Since we don't actually refcount our hRow objects, we return
                // a fake refcount here.
                aRefCount[iRow] = 1;
            }
        }
    }

    hr =    cErrors == 0 ?      S_OK :
            cErrors < cRows ?   DB_S_ERRORSOCCURRED :
                                DB_E_ERRORSOCCURRED;

Cleanup:
    RRETURN2(hr, DB_S_ERRORSOCCURRED, DB_E_ERRORSOCCURRED);
}

//+---------------------------------------------------------------------------
//  Member:     ReleaseRows (public member)
//
//  Synopsis:   Releases row handles, generating appropriate notifications.
//
//  Arguments:  cRow            Number of rows to release
//              ahRow           Array of handles of rows to be released
//              aRefCount       Array of refcnts for the rows
//              aRowStatus      Array of status codes
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_INVALIDARG            Invalid parameters were specified
//              E_UNEXPECTED            Zombie State
//              DB_E_NOTREENTRANT       Can not enter function at this time
//

STDMETHODIMP
CImpIRowset::ReleaseRows (DBCOUNTITEM cRows,
                          const HROW ahRow[],
                          DBROWOPTIONS aRowOptions[],
                          DBREFCOUNT aRefCount[],
                          DBROWSTATUS aRowStatus[])
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::ReleaseRows(%p {%u %p %p %p %p})",
             this, cRows, ahRow, aRowOptions, aRefCount, aRowStatus ));

    HRESULT hr = S_OK;

    if (cRows == 0)
    {
        goto Cleanup;
    }

    // in some sense, all rows are alive, even if their ref-counts
    //  have hit 0.....
    hr = ReleaseRowsQuiet(cRows, ahRow, aRefCount, aRowStatus);


Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//  Member:     ReleaseRowsQuiet (private member)
//
//  Synopsis:   Releases row handles, without generating any notifications.
//
//  Arguments:  cRow            Number of rows to release
//              ahRow           Array of handles of rows to be released
//              aRefCounts      Where to return ref-count of each succesfully
//                              released row.  May be NULL.
//              aRowStatus      Status of each row.  May be NULL.
//
//  Returns:    S_OK                everything worked
//              DB_S_ERRORSOCCURRED some but not all rows failed
//              DB_E_ERRORSOCCURRED all rows failed
//

HRESULT
CImpIRowset::ReleaseRowsQuiet(DBCOUNTITEM cRows, const HROW ahRow[],
                                DBREFCOUNT aRefCounts[], DBROWSTATUS aRowStatus[])
{
    ULONG iRow;
    ULONG cErrors = 0;      // number of rows that caused problems
    HRESULT hr;

    // In the new world, handles don't need to be released.
    // We run this loop only to decrement the refcounts so our
    // caller believes the handles were released.   -cfranks
    for (iRow = 0; iRow<cRows; ++iRow)
    {
        LogErrors(aRowStatus, iRow, 1, DBROWSTATUS_S_OK);
        if (!ahRow[iRow])
        {
            ++ cErrors;
            LogErrors(aRowStatus, iRow, 1, DBROWSTATUS_E_INVALID);
            continue;            
        }

        if (aRefCounts)
        {
            aRefCounts[iRow] = 1;          // Fake refcount
        }
    }

    hr =    cErrors==0 ?    S_OK :
            cErrors<cRows ? DB_S_ERRORSOCCURRED :
                            DB_E_ERRORSOCCURRED;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Member:     IsSameRow (public member)
//
//  Synopsis:   compares two HROWs to see if they are logicaly the same row
//
//  Arguments:  hThisRow        First HROW to compare
//              hThatRow        Second HROW to compare
//
//  Returns:    S_OK                    HROWs are the same
//              S_FALSE                 HROWs are for different rows
//

STDMETHODIMP
CImpIRowset::IsSameRow(HROW hThisRow, HROW hThatRow)
{
    HRESULT hr = S_OK;
    if (!hThisRow || !hThatRow)
    {
        hr = DB_E_BADROWHANDLE;
        goto Cleanup;
    }
    
    if ( FhRowDeleted((ChRow)hThisRow) || FhRowDeleted((ChRow)hThatRow) )
    {
        hr = DB_E_DELETEDROW;
        goto Cleanup;
    }


    if ((IndexFromHRow((ChRow) hThisRow) != IndexFromHRow((ChRow) hThatRow)) ||
        (ChapterFromHRow((ChRow) hThisRow) != ChapterFromHRow((ChRow) hThatRow)))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//  Member:     FireFieldEvent (public member)
//
//  Synopsis:   Fires the IRowsetNotify::OnFieldChange event on change to the
//              value of a field.
//
//  Arguments:  hRow                    row of field that changed
//              iColumn                 column in the row that changed
//              eReason                 action that caused change event to fire
//              ePhase                  phase of this notification
//
//  Returns:    S_OK                    if everything is fine
//              S_UNWANTEDEVENT         not interested in event anymore
//              S_UNWANTEDPHASE         not interested in this event phase
//              S_FALSE                 event/phase is vetoed
//

HRESULT
CImpIRowset::FireFieldEvent(HROW hRow, DBORDINAL cColumns, DBORDINAL aColumns[],
                            DBREASON eReason, DBEVENTPHASE ePhase)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    IRowsetNotify * pRSN = NULL;
    NOTIFY_STATE    ns;
    
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::FireFieldEvent(%p {%l, %l, %p, %l, %l})",
             this, hRow, cColumns, aColumns, eReason, ePhase ));

    aaidx = AA_IDX_UNKNOWN;
    
    ns = EnterNotify(eReason, ePhase);

    for (;;)
    {
        aaidx = FindNextAAIndex(
            DISPID_A_ROWSETNOTIFYSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        ClearInterface(&pRSN);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pRSN)))
        {
            hr = THR(pRSN->OnFieldChange(
                    (IRowset *) this, 
                    hRow, 
                    cColumns, 
                    aColumns,
                    eReason, 
                    ePhase, 
                    TRUE));
            if (hr && (hr==DB_S_UNWANTEDPHASE || hr==DB_S_UNWANTEDREASON))
            {
                hr = S_OK;
            }
        }
    }

    LeaveNotify(eReason, ePhase, ns);

    ReleaseInterface(pRSN);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//  Member:     FireRowEvent (public member)
//
//  Synopsis:   Fires the IRowsetNotify::OnRowChange event on first change to
//              a row or any whole-row change.
//
//  Arguments:  cRows                   count of HROWs in rghRows
//              rghRows                 array of HROWs which are changing
//              eReason                 action that caused change event to fire
//              ePhase                  phase of this notification
//
//  Returns:    S_OK                    if everything is fine
//              S_UNWANTEDEVENT         not interested in event anymore
//              S_UNWANTEDPHASE         not interested in this event phase
//              S_FALSE                 event/phase is vetoed
//

HRESULT
CImpIRowset::FireRowEvent(DBCOUNTITEM cRows, const HROW rghRows[],
                          DBREASON eReason, DBEVENTPHASE ePhase)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    IRowsetNotify * pRSN = NULL;
    NOTIFY_STATE    ns;
    
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::FireRowEvent(%p {%l, %p, %l, %l})",
             this, cRows, rghRows, eReason, ePhase ));

    aaidx = AA_IDX_UNKNOWN;
    
    ns = EnterNotify(eReason, ePhase);

    for(;;)
    {
        aaidx = FindNextAAIndex(DISPID_A_ROWSETNOTIFYSINK,
                                CAttrValue::AA_Internal, aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        ClearInterface(&pRSN);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pRSN)))
        {
            hr = THR(pRSN->OnRowChange(
                    (IRowset *) this, 
                    cRows, 
                    rghRows,
                    eReason, 
                    ePhase, 
                    FALSE));
            if (hr && (hr==DB_S_UNWANTEDPHASE || hr==DB_S_UNWANTEDREASON))
            {
                hr = S_OK;
            }
        }
    }

    LeaveNotify(eReason, ePhase, ns);
    ReleaseInterface(pRSN);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//  Member:     FireRowsetEvent (public member)
//
//  Synopsis:   Fires the IRowsetNotify::OnRowsetChange event on any change to
//              a rowset.
//
//  Arguments:  eReason                 action that caused change event to fire
//
//  Returns:    S_OK                    if everything is fine
//              S_UNWANTEDEVENT         not interested in event anymore
//

HRESULT
CImpIRowset::FireRowsetEvent(DBREASON eReason, DBEVENTPHASE ePhase)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    IRowsetNotify * pRSN = NULL;
    NOTIFY_STATE    ns;
    
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::FireRowEvent(%p {%l, %l})",
             this, eReason, ePhase));

    aaidx = AA_IDX_UNKNOWN;
    
    ns = EnterNotify(eReason, DBEVENTPHASE_DIDEVENT);
    
    for (;;)
    {
        aaidx = FindNextAAIndex(
            DISPID_A_ROWSETNOTIFYSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        ClearInterface(&pRSN);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pRSN)))
        {
            hr = THR(pRSN->OnRowsetChange(
                    (IRowset *) this, 
                    eReason, 
                    ePhase, 
                    FALSE));
            if (hr && (hr==DB_S_UNWANTEDPHASE || hr==DB_S_UNWANTEDREASON))
            {
                hr = S_OK;
            }
        }
    }

    LeaveNotify(eReason, DBEVENTPHASE_DIDEVENT, ns);

    ReleaseInterface(pRSN);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     FireAsynchOnProgress
//
//  Synopsis:   Fires the IDBAsynchNotify::OnPgoress event 
//
//  Arguments:  ulProgress              the current row count
//              ulProgressMax           the estimated final row count
//              ulStatusCode            DBASYNCHPHASE_POPULATION, or
//                                      DBASYNCHPHASE_COMPLETE
//
//  Returns:    S_OK                    if everything is fine
//              S_UNWANTEDEVENT         not interested in event anymore
//              S_UNWANTEDOPERATION
//

HRESULT
CImpIRowset::FireAsynchOnProgress(DBCOUNTITEM ulProgress, DBCOUNTITEM ulProgressMax,
                                  DBASYNCHPHASE ulStatusCode)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    IDBAsynchNotify * pDBAN = NULL;
    
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::FireAsynchOnProgress(%p {%l, %l, %l})",
              this, ulProgress, ulProgressMax, ulStatusCode));

    aaidx = AA_IDX_UNKNOWN;

    for (;;)
    {
        aaidx = FindNextAAIndex(
            DISPID_A_ROWSETASYNCHNOTIFYSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        ClearInterface(&pDBAN);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pDBAN)))
        {
            hr = THR(pDBAN->OnProgress(
                    NULL,               // chapter
                    DBASYNCHOP_OPEN,
                    ulProgress,                 
                    ulProgressMax,
                    ulStatusCode,
                    NULL));             // status text
        }
            if (hr && (hr==DB_S_UNWANTEDPHASE || hr==DB_S_UNWANTEDOPERATION))
            {
                hr = S_OK;
            }
    }

    ReleaseInterface(pDBAN);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Member:     FireAsynchOnStop
//
//  Synopsis:   Fires the IDBAsynchNotify::OnStop event 
//
//  Arguments:  hrStatus                one of:
//                                       S_OK, DB_E_CANCELED (sp?),
//                                       E_OUTOFMEMORY, E_FAIL
//
//  Returns:    S_OK                    if everything is fine
//              S_UNWANTEDEVENT         not interested in event anymore
//              S_UNWANTEDOPERATION
//

HRESULT
CImpIRowset::FireAsynchOnStop(HRESULT hrStatus)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    IDBAsynchNotify * pDBAN = NULL;
    
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::FireAsynchOnStop(%p {%l})",
             this, hrStatus));

    aaidx = AA_IDX_UNKNOWN;

    for (;;)
    {
        aaidx = FindNextAAIndex(
            DISPID_A_ROWSETASYNCHNOTIFYSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        ClearInterface(&pDBAN);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pDBAN)))
        {
            hr = THR(pDBAN->OnStop(
                    NULL,               // chapter
                    DBASYNCHOP_OPEN,
                    hrStatus,
                    NULL));             // status text
            if (hr && (hr==DB_S_UNWANTEDPHASE || hr==DB_S_UNWANTEDOPERATION))
            {
                hr = S_OK;
            }
        }
    }

    ReleaseInterface(pDBAN);
    RRETURN(hr);
}

HRESULT
CImpIRowset::Init(OLEDBSimpleProvider *pSTD)
{
    return CacheMetaData();
}

//+---------------------------------------------------------------------------
//
//  Member:     Init (public member)
//
//  Synopsis:   Initializes IRowset with an ISTD
//
//  Arguments:  pSTD                Data provider
//
//  Returns:    S_OK                if everything is fine
//              E_FAIL              initialization failed
//

HRESULT
CTopRowset::Init (OLEDBSimpleProvider *pSTD)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::Init(%p {%p})",
             this, pSTD ));

    HRESULT         hr = S_OK;

    Assert("Must have an OLEDBSimpleProvider" && pSTD);

    _pOSPData = new COSPData;
    if (!_pOSPData)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    hr = _pOSPData->Init(pSTD, this);
    if (hr)
        goto Error;

    // Init our idea of the # of rows from our only OSP member
    _cRows = _pOSPData->_cSTDRows;
    TraceTag((tagOSPRowDelta, "Init. Rowset %p has %ld rows, chapter %p has %ld rows",
                this, _cRows, _pOSPData, _pOSPData->_cSTDRows));

    hr = super::Init(pSTD);

Error:
    // Any errors here fail creation of the rowset.
    // Since we may already have hooked up event sinks to our COSPData,
    // we can't just delete it here.  Even releasing it is nasty, since
    // that will happen again in Rowset Passivate.  Let Passivate clean us up.
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CreateRowset (static)
//
//  Synopsis:   Creates creates an IRowset from an OLEDBSimpleProvider returning
//              as IUnknown
//
//  Arguments:  pRowset         - empty rowset object, new'd by one of our descendent
//                                clases, but not even checked for success.
//              pSTD            - OLEDBSimpleProvider provider wrapped by Nile
//              ppUnk           - IUnknown of Nile provider (IRowset, ...) this
//                                *ppUnk is AddRef on return.
//
//  Returns:    S_OK            - Wrapping succeeded.
//
//  Mac note:   When _MACUNICODE is defined,
//              OLEDBSimpleProvider* == OLEDBSimpleProviderMac* != LPSIMPLETABULARDATA

HRESULT
CImpIRowset::CreateRowset (CImpIRowset *pRowset, LPOLEDBSimpleProvider pSTD, IUnknown **ppUnk)
{
    HRESULT             hr;

    Assert(ppUnk);
    Assert(pSTD);

    *ppUnk = NULL;

    if (!pRowset)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pRowset->Init(pSTD);
    if (!hr)
    {
        *ppUnk = pRowset->getpIUnknown();
    }
    else
    {
        pRowset->Release();
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CTopRowset::CreateRowset(LPOLEDBSimpleProvider pSTD, IUnknown **ppUnk)
{
    CTopRowset      *pRowset;

    pRowset = new CTopRowset;
    return super::CreateRowset((CImpIRowset *)pRowset, pSTD, ppUnk);
}

HRESULT
CChapRowset::CreateRowset(LPOLEDBSimpleProvider pSTD, IUnknown **ppUnk)
{
    HRESULT hr;
    CChapRowset      *pRowset = NULL;

    pRowset = new CChapRowset;

    if (pRowset)
    {
        pSTD->AddRef();
        pRowset->_pMetaOSP = pSTD;

        hr = super::CreateRowset((CImpIRowset *)pRowset, pSTD, ppUnk);
        
        if (hr)
        {
            ClearInterface(&pRowset->_pMetaOSP);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//
// Add an entry to _aryOSPData.
//
HRESULT
CChapRowset::EnsureHChapter(HROW hRow,
                            OLEDBSimpleProvider *pOSP, HCHAPTER *phChildChapter)
{
    COSPData *pOSPData;
    HRESULT hr;
    DBROWCOUNT cRows;
    ULONG uRow = ChRow(hRow).DeRef();

    hr = _aryOSPData.EnsureSize(uRow+1);    // we don't use index 0
    if (hr)
        goto Error;

    // Do we already have OSP Data for this OSP?
    if (!(COSPData*)_aryOSPData[uRow])   // No.
    {
        pOSPData = new COSPData;
        if (!pOSPData)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        // Initialize the OSP data.
        // TODO:: Should we do anything here to check this OSP's conformity
        // to the metaOSP's meta data?
        hr = pOSPData->Init(pOSP, this);
        if (hr)
        {
            delete pOSPData;
            goto Error;
        }

        _aryOSPData[uRow] = (PCOSPData)pOSPData;
        IGNORE_HR(pOSP->getRowCount(&cRows));
        _cRows += (ULONG)cRows;
        TraceTag((tagOSPRowDelta, "Added chapter %p with %ld rows.  Rowset %p has %ld rows",
                    pOSPData, cRows, this, _cRows));
    }

    // In case we're returning an existing OSPData, we want to double-check
    // that it's the same OSP (in debug at least).

    Assert(_aryOSPData[uRow]->_pSTD == pOSP);

    *phChildChapter = _aryOSPData[uRow];
    
    
Error:
    return hr;
}

STDMETHODIMP
CImpIRowset::AddRefChapter(HCHAPTER hChapter,
              ULONG *pcRefCount)
{
    ULONG ulRefs;

#ifdef REALLY_REFCOUNT_CHAPTERS
    if (hChapter)
    {
        // TODO there's no way to verify hChapter belongs to this rowset
        COSPData *pOSPData = GetpOSPData(hChapter);
        ulRefs = pOSPData->AddRef();
    }
    else
#endif
    {
        ulRefs = 1;
    }
    
    if (pcRefCount)
        *pcRefCount = ulRefs;
    
    return S_OK;
}

STDMETHODIMP
CImpIRowset::ReleaseChapter(HCHAPTER hChapter,
              ULONG *pcRefCount)
{
    ULONG ulRefs;
    
#ifdef REALLY_REFCOUNT_CHAPTERS
    if (hChapter)
    {
        // TODO there's no way to verify hChapter belongs to this rowset
        COSPData *pOSPData = GetpOSPData(hChapter);
        ulRefs = pOSPData->Release();
    }
    else
#endif
    {
        ulRefs = 1;
    }
    
    if (pcRefCount)
        *pcRefCount = ulRefs;
    
    return S_OK;
}


STDMETHODIMP
CImpIRowset::IsRowInChapter(HCHAPTER hChapter, HROW hrow)
{
    HRESULT hr;

    hr = (hChapter == ChapterFromHRow((ChRow) hrow)) ? S_OK : S_FALSE;

    return hr;
}


void
CChapRowset::Passivate()
{
    // Recursively kill any child OSPDatas we may have.
    // (This will also release the child OSPs).
    for (ULONG uRow=1; uRow < (ULONG)_aryOSPData.Count(); uRow++)
    {
        if (_aryOSPData[uRow]._pCOSPData)
        {
            _aryOSPData[uRow]->Release();
            _aryOSPData[uRow] = NULL; // off chance we're passivate twice
        }
    }
        
    ClearInterface(&_pMetaOSP);

    super::Passivate();
}

HRESULT
COSPData::Init(OLEDBSimpleProvider *pSTD, CImpIRowset * pRowset)
{
    HRESULT hr;
    int isAsync = 0;
    DBROWCOUNT cRowsTemp;
    
    Assert(pRowset && pSTD);

    _pRowset = pRowset;                 // We don't refcount our rowset.

    _pSTD = pSTD;                       // We DO refcount our OSP.
    _pSTD->AddRef();

    // Initialize rowset cache:

    hr = _pSTD->getRowCount(&cRowsTemp);
    _cSTDRows = (LONG)cRowsTemp;
    if (hr)
    {
        goto Error;
    }
    TraceTag((tagOSPRowDelta, "Init.  Chapter %p has %ld rows",
                this, _cSTDRows));

    hr = _pSTD->getColumnCount(&cRowsTemp);
    _cSTDCols = (LONG)cRowsTemp;
    if (hr)
    {
        goto Error;
    }

    // Set the PopulationComplete bit.  It's always true for synchronous OSPs.
    // For async OSPs, we may be too late for the transferComplete notification,
    // so we check if the estimated count agrees with the row count.  Some OSPs
    // will fire transferComplete when we hook up the listener, if they're already
    // complete;  this is fine.  Finally, if getEstimatedRows fails, we assume
    // the OSP is complete;  this makes things no worse than they already are.
    _fPopulationComplete = TRUE;
    IGNORE_HR(_pSTD->isAsync(&isAsync));
    if (isAsync)
    {
        DBROWCOUNT lEstimatedRows;
        if (S_OK == _pSTD->getEstimatedRows(&lEstimatedRows))
        {
            // if the OSPs estimate agrees with its row count, we're too late
            // for the transferComplete notification
            _fPopulationComplete = (_cSTDRows == (ULONG)lEstimatedRows);
        }
    }

    // Set std events:
    // NOTE: Do this before calling GetColumnInfo, since it relies on the std
    //   events to be called.
    hr = _pSTD->addOLEDBSimpleProviderListener((OLEDBSimpleProviderListener *)&_STDEvents);
    if (hr)
    {
        _pSTD->Release();
        goto Error;
    }

    _iGetNextCursor = DBBMK_INITIAL;    // special value
    _iFindRowsCursor = DBBMK_INITIAL;
Error:
    return hr;
}

STDMETHODIMP_(ULONG)
COSPData::Release()
{
    ULONG ulRefs;
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Passivate();
        _ulRefs = 0;
    }
    ulRefs = _ulRefs;
    SubRelease();
    return ulRefs;
}

//
// Pure IUnknown
//

STDMETHODIMP
COSPData::QueryInterface (REFIID riid, LPVOID *ppv)
{
    Assert(ppv);

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
    }

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes the standard includes

#include "common.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <dtbase.cpp>
#include <dxsurfb.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\dll\dxtrans.cpp ===
// DXTrans.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DXTransps.mk in the project directory.

#include "common.h"
#include "resource.h"
#include "TranFact.h"
#include "TaskMgr.h"
#include "Scale.h"
#include "Label.h"
#include "Geo2D.h"
#include "DXSurf.h"
#include "SurfMod.h"
#include "surfmod.h"
#include "DXRaster.h"
#include "Gradient.h"
#include "dxtfilter.h"
#include "dxtfilterbehavior.h"
#include "dxtfiltercollection.h"
#include "dxtfilterfactory.h"
#ifdef _DEBUG
#include <crtdbg.h>
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_DXTransformFactory,  CDXTransformFactory )
    OBJECT_ENTRY(CLSID_DXTaskManager,       CDXTaskManager      )
    OBJECT_ENTRY(CLSID_DXTScale,            CDXTScale           )
    OBJECT_ENTRY(CLSID_DXTLabel,            CDXTLabel           )
    OBJECT_ENTRY(CLSID_DX2D,                CDX2D               )
    OBJECT_ENTRY(CLSID_DXSurface,           CDXSurface          )
    OBJECT_ENTRY(CLSID_DXSurfaceModifier,   CDXSurfaceModifier  )
    OBJECT_ENTRY(CLSID_DXRasterizer,        CDXRasterizer       )
    OBJECT_ENTRY(CLSID_DXGradient,          CDXGradient         )
    OBJECT_ENTRY(CLSID_DXTFilter,           CDXTFilter          )
    OBJECT_ENTRY(CLSID_DXTFilterBehavior,   CDXTFilterBehavior  )
    OBJECT_ENTRY(CLSID_DXTFilterCollection, CDXTFilterCollection)
    OBJECT_ENTRY(CLSID_DXTFilterFactory,    CDXTFilterFactory   )
END_OBJECT_MAP()


//+-----------------------------------------------------------------------------
//
//  This section was added when moving code over to the Trident tree.  The
//  following global variables and functions are required to link properly.
//
//------------------------------------------------------------------------------

// lint !e509 
// g_hProcessHeap is set by the CRT in dllcrt0.c

EXTERN_C HANDLE     g_hProcessHeap      = NULL;
LCID                g_lcidUserDefault   = 0;
DWORD               g_dwFALSE           = 0;


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
#ifdef _DEBUG
        // Turn on memory leak checking
//        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
//        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
//        _CrtSetDbgFlag( tmpFlag );

//      ::GdiSetBatchLimit( 1 );
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

//
//  Table of categories and resourece IDs to register
//
typedef struct tagDXCATINFO
{
    const GUID * pCatId;
    int ResourceId;
} DXCATINFO;

const DXCATINFO g_aDXCats[] = 
{
    { &CATID_DXImageTransform, IDS_DXIMAGETRANSFORM },
    { &CATID_DX3DTransform, IDS_DX3DTRANSFORM },
    { &CATID_DXAuthoringTransform, IDS_DXAUTHORINGTRANSFORM },
    { NULL, 0 }
};

//
//  Code to register transition categories
//
HRESULT RegisterTransitionCategories(bool bRegister)
{
    HRESULT         hr          = S_OK;
    char            szLCID[20];
    const HINSTANCE hinst       = _Module.GetResourceInstance();

    if (LoadStringA(hinst, IDS_LCID, szLCID, sizeof(szLCID)) == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        CComPtr<ICatRegister>   pCatRegister;
        LCID                    lcid            = atol(szLCID);
        const DXCATINFO *       pNextCat        = g_aDXCats;

        hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, 
                              CLSCTX_INPROC, IID_ICatRegister, 
                              (void **)&pCatRegister);

        while (SUCCEEDED(hr) && pNextCat->pCatId) 
        {
            if (bRegister)
            {
                CATEGORYINFO catinfo;

                catinfo.catid   = *(pNextCat->pCatId);
                catinfo.lcid    = lcid;

                LoadString(hinst, pNextCat->ResourceId,
                           catinfo.szDescription, 
                           (sizeof(catinfo.szDescription) / sizeof(catinfo.szDescription[0])));

                hr = pCatRegister->RegisterCategories(1, &catinfo);
            }
            else
            {
                hr = pCatRegister->UnRegisterCategories(1, (CATID *)pNextCat->pCatId);
            }
            pNextCat++;
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr = RegisterTransitionCategories(true);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = _Module.RegisterServer(TRUE);

    if (FAILED(hr))
    {
        goto done;
    }

done:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    RegisterTransitionCategories(false);

    _Module.UnregisterServer();

    // Manually un-register type library, we don't really care if this
    // call fails.

    ::UnRegisterTypeLib(LIBID_DXTRANSLib, 
                        DXTRANS_TLB_MAJOR_VER, DXTRANS_TLB_MINOR_VER, 
                        LOCALE_NEUTRAL, SYS_WIN32);

    return S_OK;
}


//
//
//
STDAPI DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if (i >= (sizeof(ObjectMap)/sizeof(ObjectMap[0])) - 1)
    {
        return S_FALSE;
    }

    *pclsid = *(ObjectMap[i].pclsid);
    return _Module.GetClassObject(*pclsid, IID_IUnknown, (LPVOID*)ppUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\core.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

!ENDIF

DXTROOT = $(SUBPROJROOT:\core=)
ROOT    = $(SUBPROJROOT:\src\dxt\core=)

# Trident's common.inc says to treat level 4 warnings as errors.  We wish.

WARNING_LEVEL       = W3

!include $(ROOT)\common.inc


USE_ATL=1
ATL_VER=21


INCLUDES = \
    $(INCLUDES);                \
    $(DXTROOT)\idl\$(O);        \
    $(SUBPROJROOT)\inc;         \
    $(SUBPROJROOT)\src;         \
    $(SUBPROJROOT)\mscanner;    \
    $(ROOT)\src\core\include;   \
    $(SHELL_INC_PATH);

C_DEFINES=$(C_DEFINES) -D_DXTRANSIMPL -D_WINDOWS -D_WINDLL

CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
    atlbase.h       \
    atlcom.h        \
    atlctl.h        \
    atlctl.cpp      \
    atlimpl.cpp     \
    macapi.h        \
    macnam1.h       \
    macname2.h      \
    macocidl.h      \
    macpub.h        \
    new             \
    rpcerr.h        \
    rpcmac.h        \
    statreg.cpp     \
    statreg.h       \
    thunk.h         \
    winwlm.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\inc\dassert.h ===
//************************************************************
//
// FileName:	        DAssert.h
//
// Created:	        1998
//
// Author:	        Paul Nash
// 
// Abstract:	        Defines DEBUG Assertion macro
//
// Change History:
// 11/09/98 PaulNash    Port from Trident3D -- don't bother with debug strings
//
// Copyright 1998, Microsoft
//************************************************************

#ifdef _DEBUG

#ifdef _X86_
// On X86 platforms, break with an int3 if the condition is not met.
#define DASSERT(x)      {if (!(x)) _asm {int 3} }

#else // !_X86_
// If we're not on X86, use the cross-platform version of an int 3.
#define DASSERT(x)      {if (!(x)) DebugBreak(); }

#endif !_X86_

#else !_DEBUG

#define DASSERT(x)

#endif _!DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dlay\nile2std\stdevent.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  File:       stdevent.cxx
//  Author:     Ido Ben-Shachar (t-idoben)
//
//  Contents:   Event handlers for STD
//

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

MtDefine(COSPDataCSTDEventsCellChangedHelper_rgColumns, DataBind, "COSPData::CSTDEvents::CellChangesHelper rgColumns")
MtDefine(COSPDataCSTDEventsDeleteRowsHelper_aDeletedHROWs, DataBind, "COSPData::CSTDEvents::DeleteRowsHelper aDeleteHROWs")
MtDefine(COSPDataCSTDEventsInsertRowsHelper_aInsertedHROWs, DataBind, "COSPData::CSTDEvents::InsertRowsHelper aInsertedHROWs")

DeclareTag(tagOSPRowDelta, "Databinding", "trace changes to OSP row count");
DeclareTag(tagOSPEvents, "Databinding", "trace OSP notifications");

////////////////////////////////////////////////////////////////////////////////
//
// ISimpleTabularDataEvents specific interfaces
//
////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
COSPData::CSTDEvents::QueryInterface (REFIID riid, LPVOID *ppv)
{
    Assert(ppv);
    
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_OLEDBSimpleProviderListener))
    {
        *ppv = (OLEDBSimpleProviderListener *) this;
    }
    else
    {
        *ppv = NULL;
    }
    
    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}



//+---------------------------------------------------------------------------
//  Member:     aboutToChangeCell
//
//  Synopsis:   for AboutTo phase of cellChanged
//
//  Arguments:  iRow                    row of changed cell
//              iColumn                 column of changed cell
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::aboutToChangeCell(DBROWCOUNT iRow, DB_LORDINAL iColumn)
{
    TraceTag((tagOSPEvents, "OSP %x aboutToChangeCell(%ld,%ld)", MyOSP(), iRow, iColumn));
    return CellChangedHelper(iRow, iColumn, TRUE);
}

//+---------------------------------------------------------------------------
//  Member:     CellChanged
//
//  Synopsis:   A cell somewhere in the rowset has been altered.  Therefore,
//              this function cleans up the rowset to reflect this change.
//              Notifications are also fired.  If multiple rows have changed
//              (iRow == -1) then FireRowsetEvent is called.  If multiple
//              columns have changed (iColumn == -1) then FireRowEvent is
//              called.  Otherwise, only one field has changed, and
//              FireFieldEvent is called.
//
//  Arguments:  iRow                    row of changed cell
//              iColumn                 column of changed cell
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::cellChanged(DBROWCOUNT iRow, DB_LORDINAL iColumn)
{
    TraceTag((tagOSPEvents, "OSP %x cellChanged(%ld,%ld)", MyOSP(), iRow, iColumn));
    return CellChangedHelper(iRow, iColumn, FALSE);
}

//+---------------------------------------------------------------------------
//  Member:     CellChangedHelper
//
//  Synopsis:   Does the actual work for CellChanged. fBefore tells us which
//              notification phase we're in.
//
//  Arguments:  iRow                    row of changed cell
//              iColumn                 column of changed cell
//              fBefore                 which phase are we in
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::CellChangedHelper(DBROWCOUNT iRow, DB_LORDINAL iColumn, BOOL fBefore)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::CellChanged(%p {%u %u})",
          this, iRow, iColumn) );
    HRESULT hr = S_OK;

    COSPData *pOSPData;
    pOSPData = MyOSP();
    CImpIRowset *pRowset = pOSPData->_pRowset;
    HCHAPTER hChapter;
    DBORDINAL cColCount, iSingleCol;
    DBORDINAL *rgColumns = NULL;
    HROW hrowTemp = NULL;

    if (!pRowset)                       // just in case
        goto Cleanup;

    hChapter = pRowset->HChapterFromOSPData(pOSPData);

    // -1,-1 is a special notification meaning the STD was scrambled out
    // from under us.  Everything we know is invalid.  This should probably
    // be handled better, but for now..
    
    if (iRow == -1) // multiple rows changed
    {
        // ISSUE: Is this a valid and appropriate reason for OnRowEvent?
        // also, we fire on two phases instead of 4..
        HRESULT hr1;
        hr1 = pRowset->FireRowEvent(0, &hrowTemp,
                               DBREASON_COLUMN_SET, 
                               fBefore ? DBEVENTPHASE_ABOUTTODO :
                               DBEVENTPHASE_DIDEVENT);
        if (fBefore && hr1)
        {
            pRowset->FireRowEvent(0, &hrowTemp,
                               DBREASON_COLUMN_SET, 
                               DBEVENTPHASE_FAILEDTODO);
            hr = hr1;
        }
    }
    else        // only one Row changed, but maybe multiple columns
    {

        hr = THR(pRowset->Index2HROW(hChapter, iRow, hrowTemp));
        if (hr)
        {
            goto Cleanup;
        }

        if (0<iColumn && iColumn<=(LONG)pOSPData->_cSTDCols)
        {
            // a single column is changing
            cColCount = 1;
            iSingleCol = iColumn;
            rgColumns = &iSingleCol;
        }
        
        else if (iColumn == -1)
        {
            // all columns in this row changed
            cColCount = pOSPData->_cSTDCols;
            
            rgColumns = new(Mt(COSPDataCSTDEventsCellChangedHelper_rgColumns)) DBORDINAL[cColCount];
            if (rgColumns == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            
            for (ULONG i=0; i<cColCount; ++i)
            {
                rgColumns[i] = i+1;
            }
        }

        else
        {
            // OSP gave us a bad column number
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        //   Currently, we force all 4 event phases to occur, even if the
        //   receiver of the notifications fails on one of the phases.  This is
        //   related to the problem of the changes to the field being visible
        //   before any of the phases actually occur.
        //   There is no notion of the "first time" that a field changed,
        //   thus DBREASON_ROW_FIRSTCHANGE can't be fired.
        if (fBefore)
        {
            hr = pRowset->FireFieldEvent(hrowTemp, cColCount, rgColumns,
                                       DBREASON_COLUMN_SET, DBEVENTPHASE_OKTODO);
            if (!hr)
                hr = pRowset->FireFieldEvent(hrowTemp, cColCount, rgColumns,
                                       DBREASON_COLUMN_SET, DBEVENTPHASE_ABOUTTODO);
            if (hr)
                pRowset->FireFieldEvent(hrowTemp, cColCount, rgColumns,
                                       DBREASON_COLUMN_SET, DBEVENTPHASE_FAILEDTODO);
        }
        else
        {
            pRowset->FireFieldEvent(hrowTemp, cColCount, rgColumns,
                                       DBREASON_COLUMN_SET, DBEVENTPHASE_SYNCHAFTER);
            pRowset->FireFieldEvent(hrowTemp, cColCount, rgColumns,
                                       DBREASON_COLUMN_SET, DBEVENTPHASE_DIDEVENT);
        }
    }

Cleanup:
    if (iColumn == -1)
    {
        delete [] rgColumns;
    }
    return hr;
}



//+---------------------------------------------------------------------------
//  Member:     aboutToDeleteRows
//
//  Synopsis:   About To phase of DeletedRows notification
//              
//  Arguments:  iRow                    first row deleted
//              cRows                   number of rows deleted
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::aboutToDeleteRows(DBROWCOUNT iRow, DBROWCOUNT cRows)
{
    TraceTag((tagOSPEvents, "OSP %x aboutToDeleteRows(%ld,%ld)", MyOSP(), iRow, cRows));
    return DeleteRowsHelper(iRow, cRows, TRUE);
}

//+---------------------------------------------------------------------------
//  Member:     DeletedRows
//
//  Synopsis:   Rows in the STD have been deleted.  Therefore,
//              this function cleans up the rowset to reflect this change.
//
//  Arguments:  iRow                    first row deleted
//              cRows                   number of rows deleted
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::deletedRows(DBROWCOUNT iRow, DBROWCOUNT cRows)
{
    TraceTag((tagOSPEvents, "OSP %x deletedRows(%ld,%ld)", MyOSP(), iRow, cRows));
    return DeleteRowsHelper(iRow, cRows, FALSE);
}

//+---------------------------------------------------------------------------
//  Member:     DeletedRowsHelper
//
//  Synopsis:   Rows in the STD have been deleted.  Therefore,
//              this function cleans up the rowset to reflect this change.
//
//  Arguments:  iRow                    first row deleted
//              cRows                   number of rows deleted
//              fBefore                 which phase we're in
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::DeleteRowsHelper(DBROWCOUNT iRow, DBROWCOUNT cRows, BOOL fBefore)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::DeletedRows(%p {%u %u})",
          this, iRow, cRows) );

    HRESULT hr = S_OK;
    HROW *aDeletedHROWs = NULL;
    DBCOUNTITEM cDeletedHROWs = 0;
    COSPData *pOSPData;
    pOSPData = MyOSP();
    CImpIRowset *pRowset = pOSPData->_pRowset;
    HCHAPTER hChapter;

    if (!pRowset)                       // just in case
        goto Cleanup;

    // ignore notifications about 0 rows
    if (cRows <= 0)
        goto Cleanup;

    hChapter = pRowset->HChapterFromOSPData(pOSPData);
    
    aDeletedHROWs = new(Mt(COSPDataCSTDEventsDeleteRowsHelper_aDeletedHROWs)) HROW[cRows];
    if (!aDeletedHROWs)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pRowset->GenerateHRowsFromHRowNumber(hChapter,
                                                  iRow, 0, cRows, &cDeletedHROWs,
                                                  &aDeletedHROWs));
    Assert(hr || ((LONG)cDeletedHROWs == cRows && "Got wrong number of rows"));

    if (hr || cDeletedHROWs == 0)
        goto Cleanup;
    
    if (fBefore)
    {
        hr = pRowset->FireRowEvent(cDeletedHROWs, aDeletedHROWs,
                              DBREASON_ROW_DELETE, DBEVENTPHASE_OKTODO);
        if (!hr)
            hr = pRowset->FireRowEvent(cDeletedHROWs, aDeletedHROWs,
                              DBREASON_ROW_DELETE, DBEVENTPHASE_ABOUTTODO);
        if (hr)
            pRowset->FireRowEvent(cDeletedHROWs, aDeletedHROWs,
                              DBREASON_ROW_DELETE, DBEVENTPHASE_FAILEDTODO);
    }
    else
    {
        // Fix up the rowmap that is used to implement bookmark stability
        pRowset->DeleteRows(iRow, (int) cDeletedHROWs, pOSPData);
        pRowset->_cRows -= (LONG)cDeletedHROWs;     // reduce rows in global rowset
        pOSPData->_cSTDRows -= (LONG)cDeletedHROWs; // reduce rows in this OSP
        
        TraceTag((tagOSPRowDelta, "Deleted %ld rows.  Rowset %p has %ld rows, chapter %p has %ld rows",
                    cDeletedHROWs, pRowset, pRowset->_cRows, pOSPData, pOSPData->_cSTDRows));

        pRowset->FireRowEvent(cDeletedHROWs, aDeletedHROWs,
                              DBREASON_ROW_DELETE, DBEVENTPHASE_SYNCHAFTER);
        pRowset->FireRowEvent(cDeletedHROWs, aDeletedHROWs,
                              DBREASON_ROW_DELETE, DBEVENTPHASE_DIDEVENT);
    }

Cleanup:
    delete [] aDeletedHROWs;
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     InsertedRowsHelper
//
//  Synopsis:   Rows in the STD have been inserted.  Therefore,
//              this function cleans up the rowset to reflect this change.
//
//  Arguments:  iRow                    first row inserted
//              cRows                   number of rows inserted
//              eReason                 so we can handle both insertedRows
//                                      and rowsAvailable events
//              fBefore                 which phases to signal
//
//  Returns:    Returns success.
//
STDMETHODIMP
COSPData::CSTDEvents::InsertRowsHelper(DBROWCOUNT iRow, DBROWCOUNT cRows,
                           INSERT_REASONS reason, BOOL fBefore)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::InsertedRows(%p {%u %u})",
          this, iRow, cRows) );

    HRESULT hr = S_OK;
    DBCOUNTITEM cInsertedHROWs = 0;
    HROW *aInsertedHROWs = NULL;
    COSPData *pOSPData;
    pOSPData = MyOSP();
    CImpIRowset *pRowset = pOSPData->_pRowset;
    HCHAPTER hChapter;

    // True iff insertion at end of rowset
    BOOL fAtEnd = (iRow >= (LONG)pOSPData->_cSTDRows);

    if (!pRowset)                       // just in case
        goto Cleanup;

    // ignore notifications about 0 rows
    if (cRows <= 0)
        goto Cleanup;

    hChapter = pRowset->HChapterFromOSPData(pOSPData);
    
    // If this is After phase, it's time to actually do the work!
    if (!fBefore)
    {
        // RowsAvailable events may fire well beyond our current idea
        // of the row array extent.
        if (iRow > (LONG) pOSPData->_cSTDRows+1)
        {
            // Fill in rowmap array to catch up
            LONG cRowsGap = iRow - 1 - pOSPData->_cSTDRows;
            pRowset->InsertRows(pOSPData->_cSTDRows, cRowsGap, pOSPData);
            pRowset->_cRows += cRowsGap;
            pOSPData->_cSTDRows += cRowsGap;
            TraceTag((tagOSPRowDelta, "Inserted gap of %ld rows.  Rowset %p has %ld rows, chapter %p has %ld rows",
                        cRowsGap, pRowset, pRowset->_cRows, pOSPData, pOSPData->_cSTDRows));
        }
        pRowset->_cRows += (ULONG)cRows;       // increase rows in global rowset
        pOSPData->_cSTDRows += (ULONG)cRows;   // increase rows in this OSP
        pRowset->InsertRows(iRow, (int) cRows, pOSPData);
        TraceTag((tagOSPRowDelta, "Inserted %ld rows.  Rowset %p has %ld rows, chapter %p has %ld rows",
                    cRows, pRowset, pRowset->_cRows, pOSPData, pOSPData->_cSTDRows));
    }

    aInsertedHROWs = new(Mt(COSPDataCSTDEventsInsertRowsHelper_aInsertedHROWs)) HROW[cRows];
    if (!aInsertedHROWs)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = THR(pRowset->GenerateHRowsFromHRowNumber(hChapter,
                                                  iRow, 0, cRows,
                                                  &cInsertedHROWs,
                                                  &aInsertedHROWs));
    if (cInsertedHROWs == 0)
        goto Cleanup;

    // Distinguish between ROWS_ADDED at end, and Asynch Rows added in
    // in the middle.
    if (ROWS_ADDED == reason)
        reason = (fAtEnd ? ROWS_ADDED : ROWS_ASYNCHINSERTED);

    // There are four different paths through this code:

    //  1. reason == ROWS_ADDED  (fBefore irrelevant)
    //     We got a rowsAvailable notification from the OSP for rows at the
    //     end of the Rowset . --> send a POPULATION notification on the
    //     IDBAsynchNotify interface.  This notification has no phases.
    //
    //  2. reason == ROWS_ASYNCHINSERTED (fBefore irrelevant)
    //     We got a rowsAvailable notification from the OSP for rows in
    //     the middle of the rowset.  --> send a ROW_ASYNCHINSERT event
    //     on the IRowsetNotify interface, for just the DIDEVENT phase.
    //     Also send a POPULATION notification on IDBAsyncNotify, to allow
    //     listeners to keep their progress bars up to date.

    //  3. reason == ROWS_INSERTED, fBefore == TRUE
    //     We got an aboutToInsertRows notification from the OSP.  
    //     --> send ROW_INSERT events for OKTODO & ABOUTODO phases.

    // 4.  reason == ROWS_INSERTED, fBefore == FALSE
    //     We got an InsertedRows notification from the OSP.
    //     --> send ROW_INSERT events for SYNCHAFTER and DIDEVENT phases.

    if (ROWS_ADDED == reason || ROWS_ASYNCHINSERTED == reason)
    {
        DBROWCOUNT ulProgressMax;

        IGNORE_HR(pOSPData->_pSTD->getEstimatedRows(&ulProgressMax));

        pRowset->FireAsynchOnProgress(pOSPData->_cSTDRows,
                                      ulProgressMax,
                                      DBASYNCHPHASE_POPULATION);
    }
    
    if (ROWS_INSERTED==reason || ROWS_ASYNCHINSERTED==reason)
    {
        if (ROWS_INSERTED==reason)
        {
            if (fBefore)
            {
                hr = pRowset->FireRowEvent(cRows, aInsertedHROWs,
                                      DBREASON_ROW_INSERT, DBEVENTPHASE_OKTODO);
                if (!hr)
                    hr = pRowset->FireRowEvent(cRows, aInsertedHROWs,
                                      DBREASON_ROW_INSERT, DBEVENTPHASE_ABOUTTODO);
                if (hr)
                    pRowset->FireRowEvent(cRows, aInsertedHROWs,
                                      DBREASON_ROW_INSERT, DBEVENTPHASE_FAILEDTODO);
            }
            else
            {
                pRowset->FireRowEvent(cRows, aInsertedHROWs,
                                      DBREASON_ROW_INSERT, DBEVENTPHASE_SYNCHAFTER);
            }
        }

        // By spec, ROW_ASYNCINSERT fires only DIDEVENT
        if (!fBefore)
            pRowset->FireRowEvent(cRows, aInsertedHROWs,
                                  reason==ROWS_INSERTED ? DBREASON_ROW_INSERT :
                                  (DBREASONENUM)DBREASON_ROW_ASYNCHINSERT,
                                  DBEVENTPHASE_DIDEVENT);
    }

Cleanup:
    delete [] aInsertedHROWs;
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     aboutToInsertRows
//
//  Synopsis:   About To phase of InsertedRows
//              
//
//  Arguments:  iRow                    first row inserted
//              cRows                   number of rows inserted
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::aboutToInsertRows(DBROWCOUNT iRow, DBROWCOUNT cRows)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::InsertedRows(%p {%u %u})",
          this, iRow, cRows) );
    TraceTag((tagOSPEvents, "OSP %x aboutToInsertRows(%ld,%ld)", MyOSP(), iRow, cRows));

    return InsertRowsHelper(iRow, cRows, ROWS_INSERTED, TRUE);
}

//+---------------------------------------------------------------------------
//  Member:     insertedRows
//
//  Synopsis:   Rows in the STD have been inserted.  Therefore,
//              this function cleans up the rowset to reflect this change.
//
//  Arguments:  iRow                    first row inserted
//              cRows                   number of rows inserted
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::insertedRows(DBROWCOUNT iRow, DBROWCOUNT cRows)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::InsertedRows(%p {%u %u})",
          this, iRow, cRows) );
    TraceTag((tagOSPEvents, "OSP %x insertedRows(%ld,%ld)", MyOSP(), iRow, cRows));

    return InsertRowsHelper(iRow, cRows, ROWS_INSERTED, FALSE);
}

//+---------------------------------------------------------------------------
//  Member:     AsyncRowsArrived
//
//  Synopsis:   Rows in the STD have been inserted.  Therefore,
//              this function cleans up the rowset to reflect this change.
//
//  Arguments:  iRow                    first row inserted
//              cRows                   number of rows inserted
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::rowsAvailable(DBROWCOUNT iRow, DBROWCOUNT cRows)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::AsyncRowsArrived(%p {%u %u})",
          this, iRow, cRows) );
    TraceTag((tagOSPEvents, "OSP %x rowsAvailable(%ld,%ld)", MyOSP(), iRow, cRows));

    return InsertRowsHelper(iRow, cRows, ROWS_ADDED, FALSE);
}


STDMETHODIMP
COSPData::CSTDEvents::transferComplete(OSPXFER stdxfer)
{
    HRESULT hrStatus;

    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::PopulationComplete(%p)", this) );
    TraceTag((tagOSPEvents, "OSP %x transferComplete(%s)", MyOSP(),
                stdxfer==OSPXFER_COMPLETE ? "complete" :
                stdxfer==OSPXFER_ABORT ? "abort" :
                stdxfer==OSPXFER_ERROR ? "error" :
                                        "**unknown**"
                ));

    COSPData *pOSPData;
    pOSPData = MyOSP();
    CImpIRowset *pRowset = pOSPData->_pRowset;
    HCHAPTER hChapter;

    if (!pRowset)                       // just in case
        goto Cleanup;

    hChapter = pRowset->HChapterFromOSPData(pOSPData);
    pOSPData->_fPopulationComplete = TRUE;

    // Good time to update our impression of the final STD size..
    DBROWCOUNT cRowsTemp;
    IGNORE_HR(pOSPData->_pSTD->getRowCount(&cRowsTemp));
    pOSPData->_cSTDRows = (ULONG)cRowsTemp;

    // Fire rowset event
    IGNORE_HR(pRowset->FireAsynchOnProgress(pOSPData->_cSTDRows,
                                            pOSPData->_cSTDRows,
                                            DBASYNCHPHASE_COMPLETE));

    switch (stdxfer)
    {
        case OSPXFER_ABORT:
            hrStatus = DB_E_CANCELED;
            break;
        case OSPXFER_ERROR:
            hrStatus = E_FAIL;
            break;
        case OSPXFER_COMPLETE:
        default:                        // there shouldn't be a default, but
            hrStatus = S_OK;            // having all cases makes compiler happy.
            break;
    }

    IGNORE_HR(pRowset->FireAsynchOnStop(hrStatus));

Cleanup:
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DXTrans.rc
//
#define IDS_PROJNAME                    100
#define IDR_DXTRANSFORMFACTORY          101
#define IDS_LCID                        102
#define IDR_DXOBJECTCACHE               103
#define IDS_DXIMAGETRANSFORM            104
#define IDR_DXTASKMANAGER               105
#define IDS_DX3DTRANSFORM               106
#define IDR_DXTSCALE                    107
#define IDS_DXAUTHORINGTRANSFORM        108
#define IDR_DXTLABEL                    110
#define IDR_DX2D                        111
#define IDR_DXRASTERIZER                112
#define IDR_SURFTRAN                    113
#define IDR_DXSURFACE                   114
#define IDR_DXSURFACEMODIFIER           115
#define IDR_DXGRADIENT                  116
#define IDR_DXWARP                      117
#define IDR_DXTFILTERBEHAVIOR           118
#define IDR_DXTFILTERFACTORY            119 
#define IDR_DXTFILTER                   120
#define IDR_DXTFILTERCOLLECTION         121
#define IDB_BITMAP1                     200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           122
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\inc\common.h ===
// common.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_COMMON_H__DB8FA385_F7A6_11D0_883A_3C8B00C10000__INCLUDED_)
#define AFX_COMMON_H__DB8FA385_F7A6_11D0_883A_3C8B00C10000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_APARTMENT_THREADED

// Added 1999/09/22 by a-matcal to support UNICODE on win95.
#include <w95wraps.h>


#define ATLTRACE    1 ? (void)0 : AtlTrace
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

// Added 1999/09/22 by a-matcal to support UNICODE on win95.
#include <shlwapi.h>
#include <shlwapip.h>


#include <d3drm.h>

#pragma intrinsic(memset, memcpy)

// Include the private version of DXTrans.h with extra interfaces and structures
#include <dxtransp.h>

// INCMSG defined for f3debug.h
#define INCMSG(X)

#include "f3debug.h"

#include <dxtmpl.h>
#include <ddrawex.h>
#include <dxtdbg.h>
#include <dxbounds.h>
#include <dxatlpb.h>
#include <mshtml.h>
#include <htmlfilter.h>
#include <ocmm.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMMON_H__DB8FA385_F7A6_11D0_883A_3C8B00C10000__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\mscanner\mcoverage.h ===
//************************************************************
//
// FileName:	    mcoverage.cpp
//
// Created:	    1997
//
// Author:	    Sree Kotay
// 
// Abstract:	    Sub-pixel coverage buffer header file
//
// Change History:
// ??/??/97 sree kotay  Wrote sub-pixel AA scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************

#ifndef _Coverage_H // for entire file
#define _Coverage_H

#include "msupport.h"

// =================================================================================================================
// CoverageBuffer
// =================================================================================================================
class CoverageBuffer
{
protected:
    BYTE *m_pbScanBuffer;           // eight-bit scanning buffer
    ULONG m_cbScanWidth;	    // width in pixels
    ULONG m_cSubPixelWidth;	    // width in subpixels
    ULONG m_dwSubPixelShift;        // Shift value for the sub-sampling
    ULONG m_cpixelOverSampling;     // Degree of horizontal sub-pixel accuracy

    // Optimization values; keeps track of the least/greatest
    // DWORDs that were touched during the BlastScanLine process
    ULONG m_idwPixelMin;
    ULONG m_idwPixelMax;

    // Internal static arrays for keeping track of various bitmask
    // and counts
    static ULONG lefttable8[32];
    static ULONG righttable8[32];

    // This table is so large that we optimize to reduce
    // memory bandwidth instead of code-size
    static ULONG splittable8[1024];

    // Flag indicating if these are initialized
    static bool g_fCoverageTablesGenerated;

    // Static function to initialize these arrays
    static void GenerateCoverageTables();
    
public:
    // =================================================================================================================
    // Constructor/Destructor
    // =================================================================================================================
    CoverageBuffer();
    ~CoverageBuffer();
    
    bool AllocSubPixelBuffer(ULONG width, ULONG cpixelOverSampling);
    
    // =================================================================================================================
    // Members
    // =================================================================================================================
    ULONG Width()			
    {
        return m_cbScanWidth;
    } // Width

    ULONG MinPix()			
    {
        // Our cached value is a DWORD index; but
        // we need to return a byte pointer offset
        // Note that this is exactly the offset of 
        // the first touched byte i.e. inclusive
        return (m_idwPixelMin * sizeof(DWORD));
    } // MinPix

    ULONG MaxPix()			
    {
        // Our cached value is a DWORD index; but
        // we need to return a byte pointer offset. 
        // (Also, we need to clamp to our max byte since
        // we rely on letting the DWORD stuff overshoot.)

        // Note that this is 1 byte past the end i.e. exclusive
        ULONG ibPixelMax = (m_idwPixelMax + 1) * sizeof(DWORD);
        if (ibPixelMax > m_cbScanWidth)
            ibPixelMax = m_cbScanWidth;
        return ibPixelMax;
    } // MaxPix

    BYTE *Buffer()		
    {
        return m_pbScanBuffer;
    } // Buffer

    // =================================================================================================================
    // Functions
    // =================================================================================================================
    void ExtentsClearAndReset(void);
    void BlastScanLine(ULONG x1, ULONG x2);
}; // CoverageBuffer

// Inlines (for performance)
// BlastScanLine is only called from one place; and it on the
// critical path. 
// NOTE: x1 is inclusive and x2 is exclusive
inline void CoverageBuffer::BlastScanLine(ULONG x1, ULONG x2)
{
    // Sanity check state and parameters
    DASSERT(m_pbScanBuffer);
    DASSERT(m_cSubPixelWidth > 0);

    // Caller is responsible for these checks; beccause
    // the caller can do them more efficiently
    DASSERT(x1 < x2);
    DASSERT(x2 <= m_cSubPixelWidth);
    DASSERT(x1 >= 0);

    // blast scanline
    ULONG *pdwScanline = (ULONG*)m_pbScanBuffer;

    // X1, X2 are in sub-pixel space; so we need
    // shift by m_dwSubPixelShift to get into Byte-space
    // and then we need to shift by 2 to get into Dword-space
    ULONG left = x1 >> (m_dwSubPixelShift + 2);		
    ULONG right = x2 >> (m_dwSubPixelShift + 2);	
    ULONG width = right - left;

    // Update our min and max coverage limits (this is kept in
    // dword offsets.) This is done to reduce the time
    // spent generating the RLE for RenderScan and to reduce
    // the cost of ExtentsClearAndReset
    if (left < m_idwPixelMin)		
        m_idwPixelMin = left;
    if (right > m_idwPixelMax)		
        m_idwPixelMax = right;

    // <kd> I'm not sure that I fully understand this logic here..
    //
    // This is the magic that let's us always use SolidColor8 = 0x08080808
    // even when the horiz. sub-sampling degree doesn't equal 8.
    //
    //  subsample  -> shift  => Result
    //  8               0       x1, and x2 are masked down their last 5 bits
    //  4               1       x1, and x2 are masked down to their low 4 bits (but it is
    //                          shifted to the left once to double their weights)
    //  2               2       x1 and x2 are masked down to their low 3 bits (but it is
    //                          shifted to the left twice to quadruple their weights)
    //  16              -1   => x1 and x2 are masked down to their low 6 bits (but it is
    //                          shifted once more to the right losing that last bit of detail)
    // 

    LONG shift = 3 - m_dwSubPixelShift;
    if (shift >= 0)	
    {
        x1 = (x1 << shift) & 31;
        x2 = (x2 << shift) & 31;
    }
    else
    {
        shift = -shift;
        x1 = (x1 >> shift) & 31;
        x2 = (x2 >> shift) & 31;
    }

    // For wide runs, we have a left/optional solid/right components
    // that are entirely lookup table based. (Lookup tables
    // are generated in GenerateCoverageTables.)
    if (width > 0) //more than a longword
    {
        ULONG solidColor8 = 0x08080808;

        // Assert that we haven't gone too far in our buffer
        DASSERT(left*4 < ((m_cbScanWidth+3)&(~3)));

        pdwScanline [left++] += lefttable8[x1];
        while (left < right)	
        {
            // Assert that we haven't gone too far in our buffer
            DASSERT(left*4 < ((m_cbScanWidth+3)&(~3)));

            // This is the solid portion of the run
            pdwScanline[left++] += solidColor8;
        }
        
        // Since "right" is supposed to be exclusive;
        // we don't want to write to our buffer unless
        // necessary.
        DASSERT(righttable8[0] == 0);
        DASSERT(righttable8[1] > 0);
        if (x2 != 0)
        {
            // Assert that we haven't gone too far in our buffer
            DASSERT(right*4 < ((m_cbScanWidth+3)&(~3)));
            pdwScanline [right] += righttable8[x2];
        }
    }
    else
    {
        // For runs that don't cross a dword; it gets
        // computed via this 'split table'.

        // Assert that we haven't gone too far in our buffer
        DASSERT(left*4 < ((m_cbScanWidth+3)&(~3)));

        pdwScanline [left] += splittable8[(x1<<5) + x2];
    }
} // BlastScanLine

#endif // for entire file

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\mscanner\mcoverage.cpp ===
//************************************************************
//
// FileName:	    mcoverage.cpp
//
// Created:	    1997
//
// Author:	    Sree Kotay
// 
// Abstract:	    Sub-pixel coverage buffer implementation file
//
// Change History:
// ??/??/97 sree kotay  Wrote sub-pixel AA scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
// 08/07/99 a-matcal    Replaced calls to calloc with malloc and ZeroMemory to
//                      use the IE crt.
//
// Copyright 1998, Microsoft
//************************************************************

#include "precomp.h"
#include "MSupport.h"
#include "MCoverage.h"

// =================================================================================================================
// CoverageTables
// =================================================================================================================

// NOTE: These static variables have logically the same values; so even if multiple
// threads try to generate the data. We only set the "fGenerated" flag at the
// end to prevent any thread from using the data before it is ready.
ULONG CoverageBuffer::lefttable8[32];
ULONG CoverageBuffer::righttable8[32];
ULONG CoverageBuffer::splittable8[1024];

bool CoverageBuffer::g_fCoverageTablesGenerated = false;

void CoverageBuffer::GenerateCoverageTables()
{
    // Only regenerate them if we need to
    if (g_fCoverageTablesGenerated)
        return;

    // These three tables are only used to generate 
    // the 'real' left/right/split tables
    ULONG lefttable[32];
    ULONG righttable[32];
    ULONG countbits[256];

    // =================================================================================================================
    // 1 bit tables:
    //      These are indexed from 0 to 31. And indicate which bits would
    //      be turned on for certain kinds of segments.
    //
    //      Remember that DWORDs are in reverse order, i.e. Index 0 is to the right.
    //
    //      For better visual quality, I'm going to assume that the left edge
    //      is inclusive and the right edge is exclusive. The old meta code,
    //      wasn't consistent.
    //
    //      The left table indicates that if an segment starts at i and goes to
    //      bit 31; then which bits would be on? Hence 
    //      lefttable[0] = 0xffffffff and lefttable[31] = 0x80000000.
    //
    //      The right table indicates that if an segment ended at i but started at the
    //      bit zero; then which bits would be on? Hence
    //      righttable[0] = 0x00000000 and righttable[31] = 0x7fffffff;
    //
    //
    // =================================================================================================================
    ULONG left = 0xffffffff;
    ULONG right	= 0x00000000;
    for (ULONG i = 0; i < 32; i++)
    { 
        righttable[i] = right;
        right <<= 1;
        right |= 0x00000001;

        // These shifts are unsigned
        lefttable[i] = left;
        left <<= 1;
    }

    // Check boundary cases
    DASSERT(lefttable[0] == 0xFFFFFFFF);
    DASSERT(lefttable[31] == 0x80000000);
    DASSERT(righttable[0] == 0x00000000);
    DASSERT(righttable[31] == 0x7FFFFFFF);

    // Now, we want to have a lookup table to count how
    // bits are on for any particular 8-bit value
    // Hence countbits[0] = 0, countbits[255] = 8, countbits[0x0F] = 4.
    // (There are faster ways; but this is only done once per the lifetime
    // the DLL.)
    for (ULONG j = 0; j < 256; j++)
    {
        ULONG val = j;
        ULONG count = 0;
        while (val)
        {
            count += val & 1; 
            val >>=1;
        }
        DASSERT(count <= 8);
        countbits[j] = count;
    }

    // Sanity check some cases
    DASSERT(countbits[0] == 0);
    DASSERT(countbits[255] == 8);
    DASSERT(countbits[0xF0] == 4);
    DASSERT(countbits[0x0F] == 4);
    
    // =================================================================================================================
    // 8 bit tables -
    //      For 8-bit coverage buffers (which is the way this file is implemented), we
    //  need to imagine that a run of 32 sub pixels is split into 4 cells of 8 sub-pixels.
    //  Each cell is a byte in size; the whole run is in a DWORD. For each byte, we want
    //  to place a count in that byte indicating how many of the sub-pixels were hit.
    //
    //  Remember that DWORDs are in reverse order, i.e. Index 0 is to the right. Also,
    //  the left edge is inclusive and right edge is exclusive.
    //
    //  lefttable8 indicates, if an edge started at i, and continued to 
    //  bit 31, then how many sub-pixels for each cell are hit?
    //  Hence, lefttable8[0] should be 0x08080808 and lefttable8[31] = 0x01000000.
    //  Lefttable[16] = 0x08080000
    //  
    //  righttable8 indicates if an edge ended at i, and started at 
    //  bit zero, then how many sub-pixels for each cell are hit?
    //  Hence righttable8[0] should be 0x00000000 and righttable8[31] = 0x07080808
    //  Righttable8[16] = 0x00000808
    //
    //  The way that this is computed is that we look at the one-bit left and right
    //  tables and for each byte, we run it through count bits. Then we pack into
    //  the DWORD for each lefttable8 and righttable8 entry.
    //
    // =================================================================================================================
    for (LONG k = 0; k < 32; k++)
    {
        // Take the top byte, shift it to the base position, count the bits,
        // then move it back to the top-most byte.
        lefttable8[k] = countbits[(lefttable[k] & 0xff000000) >> 24] << 24;
        lefttable8[k] |= countbits[(lefttable[k] & 0x00ff0000) >> 16] << 16;
        lefttable8[k] |= countbits[(lefttable[k] & 0x0000ff00) >> 8] << 8;
        lefttable8[k] |= countbits[(lefttable[k] & 0x000000ff) >> 0] << 0;

        // Take the top byte, shift it to the base position, count the bits,
        // then move it back to the top-most byte.
        righttable8[k] = countbits[(righttable[k]&0xff000000)>>24]<<24;
        righttable8[k] |= countbits[(righttable[k]&0x00ff0000)>>16]<<16;
        righttable8[k] |= countbits[(righttable[k]&0x0000ff00)>>8 ]<<8;
        righttable8[k] |= countbits[(righttable[k]&0x000000ff)>>0 ]<<0;
    }

    // Sanity check values
    DASSERT(lefttable8[0] == 0x08080808);
    DASSERT(lefttable8[0x10] == 0x08080000);
    DASSERT(lefttable8[0x1f] == 0x01000000);
    DASSERT(righttable8[0] == 0x00000000);
    DASSERT(righttable8[0x10] == 0x00000808);
    DASSERT(righttable8[0x1f] == 0x07080808);

    // Now this is complicated case; what if an segment starts and
    // ends inside the same 32 sub-pixel run? Then we have
    // a special table that is indexed by a start and stop pair
    // of offsets. (i is the starting and j is the ending index; the entry is (i<<5 + j));
    // 
    // So if we AND lefttable[i] and righttable[j], then we get the bit mask
    // that indicates which bits are on for that segment. And we only care about (i <= j).
    //
    // Remember that the zero bit is the right-most bit in a DWORD; and that we treat
    // the starting offset as inclusive and the ending offset as exclusive
    //
    // Examples:
    // Splittable8[0, 31] = 0x07080808
    // Splittable8[1, 31] = 0x07080807
    // Splittable8[16,16] = 0x00000000
    // Splittable8[16,17] = 0x00010000
    //
    // So if we bit-wise AND the one-bit lefttable and righttable together, 
    // we get the mask of which bits would be on; so then we use countbits to
    // convert into the 8-bit cell format.
    for (i = 0; i < 32; i++)
    {
        for (j = i; j < 32; j++)
        {
            DASSERT(i <= j);

            ULONG bits = (lefttable [i]) & (righttable[j]);
            ULONG value;
            value = countbits[(bits & 0xff000000) >> 24] << 24;
            value |= countbits[(bits & 0x00ff0000) >> 16] << 16;
            value |= countbits[(bits & 0x0000ff00) >> 8] << 8;
            value |= countbits[(bits & 0x000000ff) >> 0] << 0;

            splittable8[(i << 5) + j] = value;
        }
    }
    
    // Check our assumptions
    DASSERT(splittable8[(0 << 5) + 31] == 0x07080808);
    DASSERT(splittable8[(1 << 5) + 31] == 0x07080807);
    DASSERT(splittable8[(16 << 5) + 16] == 0x00000000);
    DASSERT(splittable8[(16 << 5) + 17] == 0x00010000);

    // Set this flag only at the end to prevent threads
    // for getting all messed up.
    g_fCoverageTablesGenerated = true;

} // GenerateCoverageTables

// =================================================================================================================
// Constructor
// =================================================================================================================
CoverageBuffer::CoverageBuffer(void) :
    m_pbScanBuffer(NULL),
    m_cbScanWidth(0)
{
    GenerateCoverageTables();
} // CoverageBuffer

// =================================================================================================================
// Destructor
// =================================================================================================================
CoverageBuffer::~CoverageBuffer()
{
    if (m_pbScanBuffer)	
    {
        ::free(m_pbScanBuffer);
        m_pbScanBuffer = NULL;
    }
} // ~CoverageBuffer

// =================================================================================================================
// AllocSubPixelBuffer
// =================================================================================================================
bool CoverageBuffer::AllocSubPixelBuffer(ULONG cbWidth, ULONG cpixelOverSampling)
{
    if (!IsPowerOf2(cpixelOverSampling))	
    {
        DASSERT(false);	
        return false;
    }

    // Check if no changes to the width or sub-sampling resolution
    if (cbWidth == m_cbScanWidth && m_pbScanBuffer && (cpixelOverSampling == m_cpixelOverSampling))
    {
        // Zero our buffer
        ZeroMemory(m_pbScanBuffer, cbWidth);

        // Initialize to outside values
        // so that we will always update them to
        // the correct min/max as we render
        m_idwPixelMin = m_cbScanWidth;
        m_idwPixelMax = 0;

        return true;
    }

    // Capture some useful state
    m_cbScanWidth = cbWidth;
    m_cSubPixelWidth = cbWidth * cpixelOverSampling;
    m_cpixelOverSampling = cpixelOverSampling;
    m_dwSubPixelShift = Log2(cpixelOverSampling);

    // We expect scanRowBytes to be a multiple of 4
    ULONG scanRowBytes = (m_cbScanWidth+3)&(~3); // long aligned
    DASSERT((scanRowBytes & 3) == 0);

    if (m_pbScanBuffer)
    {
        ::free(m_pbScanBuffer);
        m_pbScanBuffer = NULL;
    }
    
    if (!m_pbScanBuffer)
    {
        // Allocate and Zero some memory

        m_pbScanBuffer = (BYTE *)::malloc(scanRowBytes);

        if (!m_pbScanBuffer)	
        {
            DASSERT (0);	
            return false;
        }

        ZeroMemory(m_pbScanBuffer, scanRowBytes);
    }
    
    // Initialize to outside values
    // so that we will always update them to
    // the correct min/max as we render
    m_idwPixelMin = m_cbScanWidth;
    m_idwPixelMax = 0;

    ExtentsClearAndReset();
    
    return true;
} // AllocSubPixelBuffer

//
//  Optimize for speed here
//
#ifndef _DEBUG
#pragma optimize("ax", on)
#endif

// =================================================================================================================
// ExtentsClearAndReset
//      The main purpose of this function is to Zero out our coverage buffer array. It 
//      gets called every Destination scan-line.
// =================================================================================================================
void CoverageBuffer::ExtentsClearAndReset(void)
{
    // Minimum Byte index that was touched in the coverage array
    ULONG start = MinPix();
    DASSERT(start >= 0);

    // Approximate maximum Byte index that was touched in the array
    ULONG end = MaxPix();
    DASSERT(end <= m_cbScanWidth);

    LONG range = end - start;

    if ((range <= 0) || ((ULONG)range > m_cbScanWidth))	
        return;
    
    // This is optimization to reduce how much memory
    // we clear out.
    ZeroMemory(m_pbScanBuffer + start, range);

#ifdef DEBUG
    {
        // To check that the optimization is correct;
        // we check that all the bytes in the scan buffer are now zero'ed
        for (ULONG i = 0; i < m_cbScanWidth; i++)
        {
            if (m_pbScanBuffer[i] != 0)
            {
                DASSERT(m_pbScanBuffer[i] == 0);
            }
        }
    }
#endif // DEBUG

    m_idwPixelMin = m_cbScanWidth;	
    m_idwPixelMax = 0;
} // ExtentsClearAndReset


//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\mscanner\mlinescan.h ===
//************************************************************
//
// FileName:	    mlinescan.cpp
//
// Created:	    1996
//
// Author:	    Sree Kotay
// 
// Abstract:	    line scanner header
//
// Change History:
// ??/??/97 sree kotay  Wrote AA line scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************
#ifndef _LineScanner_H
#define _LineScanner_H

#include "dxtrans.h"

// =================================================================================================================
// Scanner
// =================================================================================================================
class CLineScanner
{
public:
    // =================================================================================================================
    // Data
    // =================================================================================================================
    RECT m_clipRect;

    IDXRasterizer *m_pRasterizer;
    DXRASTERPOINTINFO m_PointInfo;
    
    // =================================================================================================================
    // Contructor
    // =================================================================================================================
    CLineScanner();
    
    // =================================================================================================================
    // Properties
    // =================================================================================================================
    bool AntiAlias()				
    {
        return m_fAntiAlias;
    } // AntiAlias

    ULONG LinePattern()			
    {
        return m_dwLinePattern;
    } // LinePattern
    
    void SetAntiAlias(bool fAA)	
    {
        m_fAntiAlias = fAA;
    } // SetAntiAlias

    void SetLinePattern(ULONG dwLinePattern)	
    {
        m_dwLinePattern = dwLinePattern;
    } // SetLinePattern

    void SetAlpha(ULONG alpha);
    
    // =================================================================================================================
    // Drawing Functions
    // =================================================================================================================
    void RealLineTo(float x1, float y1, float x2, float y2);
    
protected:
    // =================================================================================================================
    // Clipping
    // =================================================================================================================
    bool ClipRealLine(float &x1, float &y1, float &x2, float &y2);
    
    // =================================================================================================================
    // Vertical/Horizontal based Low-level routines
    // =================================================================================================================
    void LowLevelVerticalLine(LONG slope, LONG sx, LONG sy, LONG ey);
    void LowLevelHorizontalLine(LONG slope, LONG sx, LONG sy, LONG ex);

    // =================================================================================================================
    // Properties
    // =================================================================================================================

    // Flag indicating whether the line should be AA or not
    bool m_fAntiAlias;
    
    // Pattern (allows for dots and dashes etc)
    ULONG m_dwLinePattern;

    // Full Alpha value for the line
    ULONG m_dwAlpha;

    // Lookup table for computing partial alpha values
    BYTE m_rgAlphaTable[257];

    // LineWidth
    LONG m_cpixLineWidth;       // used by internal lowlevel routines

    // TODO: what are these things? Hungarian?
    LONG m_startFix;	    // used by internal lowlevel routines
    LONG m_oldLength;       // used for positioning line pattern
    bool m_fXInc;
    

}; // CLineScanner

#endif //_LineScanner_H
//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\mscanner\mlinescan.cpp ===
//************************************************************
//
// FileName:	    mlinescan.cpp
//
// Created:	    1996
//
// Author:	    Sree Kotay
// 
// Abstract:	    Line drawing AA engine
//
// Change History:
// ??/??/97 sree kotay  Wrote AA line scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************


#include "precomp.h"
#include <stdlib.h>
#include <math.h>
#include "msupport.h"
#include "MLineScan.h"

//
//  Optimize for speed here
//
#ifndef _DEBUG
#pragma optimize("ax", on)
#endif

//
//  Optimize for speed, not size for this file.
//  

// Type-safe swap functions
template <class T> 
inline void SWAP(T& left, T& right)
{
    T tTemp = left;
    left = right;
    right = tTemp;
} // Swap<class T>

// Helper function to determine if a point is clipped
#ifdef DEBUG
bool IsPointClipped(const DXRASTERPOINTINFO &pointInfo, const RECT &rectClip)
{
    if (pointInfo.Pixel.p.x < rectClip.left)
        return true;
    if (pointInfo.Pixel.p.x >= rectClip.right)
        return true;
    if (pointInfo.Pixel.p.y < rectClip.top)
        return true;
    if (pointInfo.Pixel.p.y >= rectClip.bottom)
        return true;
    return false;
} // IsPointClipped
#endif // DEBUG

// -----------------------------------------------------------------------------------------------------------------
// CLineScanner
// -----------------------------------------------------------------------------------------------------------------
CLineScanner::CLineScanner(void) :
    m_fAntiAlias(true),
    m_dwLinePattern(0),
    m_pRasterizer(NULL),
    m_oldLength(0),
    m_fXInc(false)
{
    SetAlpha(256);
} // CLineScanner

// -----------------------------------------------------------------------------------------------------------------
// SetAlpha
// -----------------------------------------------------------------------------------------------------------------
void CLineScanner::SetAlpha (ULONG alpha)
{
    // Adjust the alpha passed in to a reasonable
    // range
    alpha = min (alpha, 255);

    // Update our lookup table for alpha values
    for (ULONG i = 1; i <= 256; i++)	
        m_rgAlphaTable[i] = (BYTE)((i*alpha)>>8);

    DASSERT(m_rgAlphaTable[256] == alpha);
    
    m_rgAlphaTable[0] = 0;
    m_dwAlpha = alpha;
} // SetAlpha

// -----------------------------------------------------------------------------------------------------------------
// ClipRealLine
// -----------------------------------------------------------------------------------------------------------------
bool CLineScanner::ClipRealLine(float &x1, float &y1, float &x2, float &y2)
{
    float clipMinX = (float)m_clipRect.left;
    float clipMinY = (float)m_clipRect.top;	

    // We want to clip based on "inclusive numbers". The normal
    // GDI clip rect is exclusive for right and bottom. So we
    // subtract a little to make it inclusive.
    float clipMaxX = (float)m_clipRect.right - 0.001f;
    float clipMaxY = (float)m_clipRect.bottom - 0.001f;

    // If we are anti-aliased; then there may be some spillover
    // from core pixels that are actually outside out true bbox.
    // The solution here is to artificially increase the size of our clipRect
    // and then explicitly perform clip-checks before we call SetPixel
    //
    // If we are not Anti-aliased, we do the same thing; because rounding
    // can cause pixels from outside the clipRect to be rounded inside.
    clipMinX--;
    clipMinY--;
    clipMaxX++;
    clipMaxY++;

#define RIGHT   (char) 0x01
#define LEFT    (char) 0x02
#define ABOVE   (char) 0x04
#define BELOW   (char) 0x08
    
#define REGION(reg, xc, yc)	\
    {	                        \
    reg = 0;                    \
    if (xc > clipMaxX)		\
        reg |= RIGHT;           \
    else if (xc < clipMinX)	\
        reg |= LEFT;            \
    if (yc > clipMaxY)		\
        reg |= BELOW;           \
    else if (yc < clipMinY)	\
        reg |= ABOVE;           \
    }
    
    // Compute position flags for each end point
    DWORD reg1, reg2;
    REGION (reg1, x1, y1);
    REGION (reg2, x2, y2);

    // If no flags, then both points are inside
    // the clipRect i.e. no clipping
    if (reg1 == 0 && reg2 == 0)		
        return true;

    // While there are any flags, we need to do some clipping
    // If we hit here, we must have some clipping to do
    // (this single or trick reduces the number of conditions checked)
    DASSERT(reg1 | reg2);

    // Iterate 
    LONG passes = 0; // This is bogus but I don't know why it was added <kd>
    do
    {
        passes++;	
        if (passes > 8)
        {
            // TODO: need to figure out when this happens and
            // to fix it right. <kd>

            return (false);	// hack because of this routine
        }

        // If both points are to the left, right, etc
        // then clip the entire line
        if (reg1 & reg2)	
            return (false);	// Line outside rect.

        // Normalize so that reg1 is outside 
        if (reg1 == 0) 
        {
            // Swap reg1 and reg2; don't use
            // the swap macro since that goes through 
            // a float conversion; ick.
            DWORD regT = reg1;
            reg1 = reg2;
            reg2 = regT;

            SWAP (x1, x2); 
            SWAP (y1, y2);
        }

        // Reg1 (i.e. x1, y1 is outside of the cliprect).
        DASSERT(reg1 != 0);

        // There are 4 cases, maybe we should use a switch..
        // Regardless, this tries to remove one bit from
        // reg1 by clipping the line to one of the 4 clip
        // edges.
        if (reg1 & LEFT) 
        {
            if (x2 != x1)		
                y1 +=  ((y2 - y1) * (clipMinX - x1)) / (x2 - x1);
            x1 = clipMinX;
        }
        else if (reg1 & RIGHT) 
        {
            if (x2 != x1)		
                y1 += ((y2 - y1) * (clipMaxX - x1)) / (x2 - x1);
            x1 = clipMaxX;
        }
        else if (reg1 & BELOW) 
        {
            if (y2 != y1)
                x1 +=  ((x2 - x1) * (clipMaxY - y1)) / (y2 - y1);
            y1 = clipMaxY;
        }
        else if (reg1 & ABOVE) 
        {
            if (y2 != y1)		
                x1 +=  ((x2 - x1) * (clipMinY - y1)) / (y2 - y1);
            y1 = clipMinY;
        }
                
        // Recompute region for reg1 (i.e. reg2 hasn't changed)
        // Is this really necessary? Can't we just mask off the appropriate
        // bit?
        REGION(reg1, x1, y1);
                    
    } while (reg1 | reg2);

    DASSERT(reg1 == 0);
    DASSERT(reg2 == 0);
    return true;
    
} // ClipRealLine

// -----------------------------------------------------------------------------------------------------------------
// LowLevelVerticalLine - We now treat the line as being inclusive/inclusive
// i.e. we render completely from SY to EY including the endpoints.
// -----------------------------------------------------------------------------------------------------------------
void CLineScanner::LowLevelVerticalLine (LONG slope, LONG sx, LONG sy, LONG ey)
{
#define _floorerr(a)    (((a)-FIX_FLOOR(a))>>8)
#define _ceilerr(a)     ((FIX_CEIL(a)-(a))>>8)
    
    ULONG pattern = LinePattern();
    
    if (!AntiAlias())
    {
        LONG start = roundfix2int(sy);
        LONG end = roundfix2int(ey);   

        // For Aliased lines, sy and ey are not perfectly clipped to the clipRect 
        // because precision errors can cause us to miss pixels when
        // we are asked to render with a clip rect
        while (start < m_clipRect.top)
        {
            // We should be pretty close here..
            DASSERT((m_clipRect.top - start) < 2);

            // Just increment out values without rendering
            sx = sx + slope;
            start++;
            pattern = RotateBitsLeft(pattern);
        }
        while (end >= m_clipRect.bottom)
        {
            // We should be pretty close here..
            DASSERT((m_clipRect.bottom - end) < 2);

            end--;
        }

        m_PointInfo.Weight = 255;     // It's all solid
        while (start <= end)
        {
            if (pattern & 0x80000000)
            {
                m_PointInfo.Pixel.p.x   = roundfix2int(sx);

                // We need to explicitly check against the clip-rect 
                // because we intentionally allow end-points to be slightly
                // extend past it. This compensates for the non-linear
                // rounding whereby a mathematical pixel that lies outside
                // the clip-rect can get "rounded" inside the clip-rect.
                if (m_PointInfo.Pixel.p.x >= m_clipRect.left &&
                        m_PointInfo.Pixel.p.x <  m_clipRect.right)
                {
                    m_PointInfo.Pixel.p.y   = start;
                    DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                    m_pRasterizer->SetPixel(&m_PointInfo);
                }
            }
            sx = sx + slope;
            start++;
            pattern = RotateBitsLeft(pattern);
        }
        SetLinePattern(pattern);
        return;
    }

    ///////////////////////////////////////////////
    // We are now in the Anti-Aliased case...
    //

    LONG start         = uff (FIX_FLOOR(sy));
    LONG end           = uff (FIX_CEIL(ey));

    LONG xval          = m_startFix;

    // Keep track of whether our line endpoints are real endpoints
    // or whether they have been clipped by the clipRect
    LONG first = start;
    LONG last = end;

    // For Anti-Aliased lines, our lines are not perfectly clipped to
    // the m_clipRect. This is to allow 'bleed' from pixels that are just outside
    // of the m_clipRect to be rendered.
    //
    // As a result, we need to clip explicitly to m_clipRect here.
    while (start < m_clipRect.top)
    {
        // We should be pretty close here..
        DASSERT((m_clipRect.top - start) < 2);

        // Just increment out values without rendering
        xval = xval + slope;
        sx = sx + slope;
        start++;
    }
    while (end >= m_clipRect.bottom)
    {
        // We should be pretty close here..
        DASSERT((m_clipRect.bottom - end) < 2);

        end--;
    }

    
    while (start <= end)
    {
        if (pattern & 0x80000000)
        {
            LONG fx1           = xval - m_cpixLineWidth;
            LONG fx2           = xval + m_cpixLineWidth;
            LONG fx3           = fx1 - (slope>>2);
            LONG fx4           = fx2 - (slope>>2);
            fx1                 = fx1 - (slope>>1) - (slope>>2);
            fx2                 = fx2 - (slope>>1) - (slope>>2);
            
            
            LONG xs, xe, xc;
            LONG errs, erre, errc;
            if (fx3 > fx1)      
            {
                errs            = _ceilerr      (fx1)>>1;
                erre            = _floorerr (fx4)>>1;
                xs              = uff (fx1);
                xe              = uff (fx4);
                if (xe == xs+1)
                {
                    errs        += _ceilerr             (fx3)>>1;
                    erre        += _floorerr    (fx2)>>1;
                    errc         = 0;
                }
                else
                {
                    errc        = min ((fx2 - fx3)>>8, 256);
                    xc          = (xe+xs)>>1;
                }
            }
            else
            {
                errs            = _ceilerr      (fx3)>>1;
                erre            = _floorerr (fx2)>>1;
                xs                      = uff (fx3);
                xe                      = uff (fx2);
                if (xe == xs+1)
                {
                    errs        += _ceilerr             (fx1)>>1;
                    erre        += _floorerr    (fx4)>>1;
                    errc         = 0;
                }
                else
                {
                    errc        = min ((fx4 - fx1)>>8, 256);
                    xc          = (xe+xs)>>1;
                }
            }
            
            // The purpose of this logic is to support
            // cases where a line may start on the middle of
            // a pixel; and it scales the alpha by what percentage
            // DOWN we are starting.. i.e. if we are starting half-way 
            // into sy, then scale by 1/2. 
            //
            // TODO: It doesn't take into account if what fraction of
            // sx we are starting at. This causes edge pixels to be darker.
            // It also doesn't modify the alpha based on what the cross-section
            // should look like at the endpoints. This causes 'overshoot' at
            // line joins.

            // modulate err by Y if it's an endpoint
            if (start == first)
            {
                LONG erry      = _ceilerr(sy);
                errs            = (errs*erry)>>8;
                erre            = (erre*erry)>>8;
                errc            = (errc*erry)>>8;
            }
            if (start == last)
            {
                LONG erry      = _floorerr (ey);
                errs            = (errs*erry)>>8;
                erre            = (erre*erry)>>8;
                errc            = (errc*erry)>>8;
            }
            
            // draw the pixel(s)
            m_PointInfo.Pixel.p.y = start;
            if (xs < m_clipRect.right && xs >= m_clipRect.left)
            {
                m_PointInfo.Pixel.p.x = xs;
                m_PointInfo.Weight = m_rgAlphaTable[errs];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }    
            if (xc < m_clipRect.right && xc >= m_clipRect.left && errc)
            {
                m_PointInfo.Pixel.p.x = xc;
                m_PointInfo.Weight = m_rgAlphaTable[errc];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }    
            if (xe < m_clipRect.right && xe >= m_clipRect.left)
            {
                m_PointInfo.Pixel.p.x = xe;
                m_PointInfo.Weight = m_rgAlphaTable[erre];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }    
        }
        
        xval    = xval  + slope;
        sx      = sx    + slope;
        start++;
        pattern = RotateBitsLeft(pattern);
    }
    SetLinePattern(pattern);
} // LowLevelVerticalLine

// -----------------------------------------------------------------------------------------------------------------
// LowLevelHorizontalLine - We now treat the line as being inclusive/inclusive
// i.e. we render completely from SX to EX including the endpoints.
// -----------------------------------------------------------------------------------------------------------------
void CLineScanner::LowLevelHorizontalLine (LONG slope, LONG sx, LONG sy, LONG ex)
{
    ULONG pattern = LinePattern();

    if (!AntiAlias())
    {
        LONG start = roundfix2int(sx);
        LONG end = roundfix2int(ex);   

        m_PointInfo.Weight = 255;

        // For Aliased lines, sx and ex are not perfectly clipped to the clipRect 
        // because precision errors can cause us to miss pixels when
        // we are asked to render with a clip rect
        while (start < m_clipRect.left)
        {
            // We should be pretty close here..
            DASSERT((m_clipRect.left - start) < 2);

            // Just increment out values without rendering
            sy = sy + slope;
            start++;
            pattern = RotateBitsLeft(pattern);
        }
        while (end >= m_clipRect.right)
        {
            // We should be pretty close here..
            DASSERT((m_clipRect.right - end) < 2);

            end--;
        }

        while (start <= end)
        {
            if (pattern & 0x80000000)
            {
                m_PointInfo.Pixel.p.y = roundfix2int(sy);

                // We need to explicitly check against the clip-rect 
                // because we intentionally allow end-points to be slightly
                // extend past it. This compensates for the non-linear
                // rounding whereby a mathematical pixel that lies outside
                // the clip-rect can get "rounded" inside the clip-rect.
                if (m_PointInfo.Pixel.p.y >= m_clipRect.top &&
                        m_PointInfo.Pixel.p.y <  m_clipRect.bottom)
                {
                    m_PointInfo.Pixel.p.x = start;
                    DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                    m_pRasterizer->SetPixel(&m_PointInfo);
                }
            }
            sy = sy + slope;
            start++;
            pattern = RotateBitsLeft(pattern);
        }
        SetLinePattern(pattern);
        return;
    }

    ///////////////////////////////////////////////
    // We are now in the Anti-Aliased case...
    //

    LONG start = uff (FIX_FLOOR(sx));
    LONG end = uff (FIX_CEIL(ex));   

    LONG yval = m_startFix;

    // Keep track of whether our line endpoints are real endpoints
    // or whether they have been clipped by the clipRect
    LONG first = start;
    LONG last = end;

    // For Anti-Aliased lines, our lines are not perfectly clipped to
    // the m_clipRect. This is to allow 'bleed' from pixels that are just outside
    // of the m_clipRect to be rendered.
    //
    // As a result, we need to clip explicitly to m_clipRect here.
    while (start < m_clipRect.left)
    {
        // We should be pretty close here..
        DASSERT(m_clipRect.left - start < 2);

        // Just increment out values without rendering
        yval = yval + slope;
        sy = sy + slope;
        start++;
        pattern = RotateBitsLeft(pattern);
    }
    while (end >= m_clipRect.right)
    {
        // We should be pretty close here..
        DASSERT((m_clipRect.right - end) < 2);
        end--;
    }

    while (start <= end)
    {
        if (pattern & 0x80000000)
        {
            LONG fy1 = yval - m_cpixLineWidth;
            LONG fy2 = yval + m_cpixLineWidth;
            LONG fy3 = fy1 - (slope>>2);
            LONG fy4 = fy2 - (slope>>2);

            fy1 = fy1 - (slope>>1) - (slope>>2);
            fy2 = fy2 - (slope>>1) - (slope>>2);
            
            LONG ys, ye, yc;
            LONG errs, erre, errc;
            if (fy3 > fy1)      
            {
                errs = _ceilerr(fy1)>>1;
                erre = _floorerr(fy4)>>1;
                ys = uff (fy1);
                ye = uff (fy4);
                if (ye == ys+1)
                {
                    errs += _ceilerr(fy3)>>1;
                    erre += _floorerr(fy2)>>1;
                    errc = 0;
                }
                else
                {
                    errc = min ((fy2 - fy3)>>8, 256);
                    yc = (ye+ys)>>1;
                }
            }
            else
            {
                errs = _ceilerr(fy3)>>1;
                erre = _floorerr(fy2)>>1;
                ys = uff (fy3);
                ye = uff (fy2);
                if (ye == ys+1)
                {
                    errs += _ceilerr(fy1)>>1;
                    erre += _floorerr(fy4)>>1;
                    errc = 0;
                }
                else
                {
                    errc = min ((fy4 - fy1)>>8, 256);
                    yc = (ye+ys)>>1;
                }
            }
            
            
            // The purpose of this logic is to support
            // cases where a line may start on the middle of
            // a pixel; and it scales the alpha by what percentage
            // ACROSS we are starting.. i.e. if we are starting half-way 
            // into sx, then scale by 1/2. 
            //
            // TODO: It doesn't take into account if what fraction of
            // sy we are starting at. This causes edge pixels to be darker.
            // It also doesn't modify the alpha based on what the cross-section
            // should look like at the endpoints. This causes 'overshoot' at
            // line joins.
            
            // modulate err by X if it's an endpoint
            if (start == first)
            {
                LONG errx = _ceilerr(sx);
                errs = (errs*errx)>>8;
                erre = (erre*errx)>>8;
                errc = (errc*errx)>>8;
            }
            if (start == last)
            {
                LONG errx = _floorerr (ex);
                errs = (errs*errx)>>8;
                erre = (erre*errx)>>8;
                errc = (errc*errx)>>8;
            }

            m_PointInfo.Pixel.p.x = start;
            if (ys < m_clipRect.bottom && ys >= m_clipRect.top)
            {
                m_PointInfo.Pixel.p.y = ys;
                m_PointInfo.Weight = m_rgAlphaTable[errs];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }
            if (yc < m_clipRect.bottom && yc >= m_clipRect.top && errc)
            {
                m_PointInfo.Pixel.p.y = yc;
                m_PointInfo.Weight = m_rgAlphaTable[errc];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }
            if (ye < m_clipRect.bottom && ye >= m_clipRect.top)
            {
                m_PointInfo.Pixel.p.y = ye;
                m_PointInfo.Weight = m_rgAlphaTable[erre];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }
        }
        yval = yval + slope;
        sy = sy + slope;
        start++;
        pattern = RotateBitsLeft(pattern);
    }
    SetLinePattern(pattern);
} // LowLevelHorizontalLine

// -----------------------------------------------------------------------------------------------------------------
// RealLineTo
// -----------------------------------------------------------------------------------------------------------------
void CLineScanner::RealLineTo(float x1, float y1, float x2, float y2)
{
    // Compute whether we are more horizontal than vertical
    // before doing the clipping which introduces some errors
    // into the numbers.
    bool fHorizontal;
    float flDeltaX = fabs(x1 - x2);
    float flDeltaY = fabs(y1 - y2);
    if (flDeltaX > flDeltaY)
        fHorizontal = true;
    else
        fHorizontal = false;

    // Clip the line to our clip rect; a false return
    // means the line was totally clipped out.
    if (!ClipRealLine(x1, y1, x2, y2))
        return;
    
    float slope, xDist, yDist;
    
    xDist = x1 - x2;
    yDist = y1 - y2;

    // Are we moving faster in the X than in the Y
    if (fHorizontal)
    {
        // increment in x
        if (!xDist)	
            return;

        slope = yDist / xDist;
        if (x1>x2)
        {
            SWAP (x1, x2); 
            SWAP (y1, y2); 
            SetLinePattern(RotateBitsRight(LinePattern(), m_oldLength + 1 + (int)x2 - (int)x1));
        }
        else if (!m_fXInc)
        {
            SetLinePattern(RotateBitsRight(LinePattern(), m_oldLength));
            m_fXInc = true;
        }
        
        m_oldLength = (int)x2 - (int)x1 + 1;
        
        if (AntiAlias())
        {
            // compute scanline width and subpixel increment
            float mag = (float)sqrtinv(xDist*xDist + yDist*yDist) * .5f;
            float x = -yDist*mag;
            float y = xDist*mag;
            
            float m = (yDist == 0) ? 0 : xDist/yDist;
            float b = x - m*y;
            m_cpixLineWidth = max (abs (LONG (fl (-b*slope))), sfixhalf);
            
            float x0 = (float)(PB_Real2IntSafe(x1) + 1);
            float pre = x0 - x1;
            m_startFix = fl (y1 + slope*pre);
        }
        else
        {
            // For aliased lines; we need to adjust our starting
            // point (x1, y1) so that x1 is rounded to nearest
            // integer. This is to ensure that a line will draw the
            // same no matter what clip-rect is applied to it.
            float flXStart = (float)(int)(x1 + 0.5f);
            if (x1 < 0.0f && x1 != flXStart)
                flXStart -= 1.0f;
            
            float flError = x1 - flXStart;

            // Update x1 to be the rounded value
            x1 = flXStart;

            // We now need to modify the y1 component to account for this change
            y1 -= flError * slope;
        }
        
        // draw horizontal scanline
        LowLevelHorizontalLine(fl(slope), fl(x1), fl(y1), fl(x2));		
    }
    else    // (!fHorizontal), e.g. Vertical
    {
        // increment in y
        if (!yDist)	
            return;
        
        slope = xDist / yDist;
        if (y1 > y2)
        {
            SWAP(x1, x2);
            SWAP(y1, y2);
            SetLinePattern(RotateBitsRight(LinePattern(), m_oldLength + 1 + (int)y2 - (int)y1));
        }
        else if (m_fXInc)
        {
            SetLinePattern(RotateBitsRight(LinePattern(), m_oldLength));
            m_fXInc = false;
        }
        
        m_oldLength = (int)y2 - int(y1) + 1;
        
        if (AntiAlias())
        {
            // compute scanline width and subpixel increment
            float mag = (float) (sqrtinv(xDist*xDist + yDist*yDist) * .5);
            float x = -yDist*mag;
            float y = xDist*mag;
            
            float m = (xDist == 0) ? xDist : yDist/xDist;
            float b = y - m*x;
            m_cpixLineWidth = max (abs (LONG (fl (-b*slope))), sfixhalf);
            
            
            float y0 = (float)(PB_Real2IntSafe(y1) + 1);
            float pre = y0 - y1;
            m_startFix = fl (x1 + slope*pre);
        }
        else
        {
            // For aliased lines; we need to adjust our starting
            // point (x1, y1) so that x1 is rounded to nearest
            // integer. This is to ensure that a line will draw the
            // same no matter what clip-rect is applied to it.
            float flYStart = (float)(int)(y1 + 0.5f);
            if (y1 < 0.0f && y1 != flYStart)
                flYStart -= 1.0f;
            
            float flError = y1 - flYStart;

            // Update y1 to be the rounded value
            y1 = flYStart;

            // We now need to modify the x1 component to account for this change
            x1 -= flError * slope;
        }
       
        // draw vertical scanline
        LowLevelVerticalLine(fl(slope), fl(x1), fl(y1), fl(y2));
    }
} // RealLineTo

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\mscanner\mscanner2d.cpp ===
//************************************************************
//
// FileName:	    mscanner2d.cpp
//
// Created:	    1997
//
// Author:	    Sree Kotay
// 
// Abstract:	    Scan-based AA polygon renderer
//
// Change History:
// ??/??/97 sree kotay  Wrote AA poly scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************

#include "precomp.h"
#include "msupport.h"
#include "MScanner2d.h"
#include "MLineScan.h"

// =================================================================================================================
// Constructor
// =================================================================================================================
CFillScanner::CFillScanner () :
    m_proc(NULL),
    m_scanlineProcData(NULL),
    m_vertspace(0),
    m_heightspace(0),
    m_cursortcount(0),
    m_fWinding(true),
    m_subpixelscale(4)
{
    SetAlpha			(255);
} // CFillScanner

// =================================================================================================================
// Destructor
// =================================================================================================================
CFillScanner::~CFillScanner ()
{
    m_vertspace			= 0;
} // ~CFillScanner


//
//  Optimize for speed here
//
#ifndef _DEBUG
#pragma optimize("ax", on)
#endif


// =================================================================================================================
// SetVertexSpace
// =================================================================================================================
bool CFillScanner::SetVertexSpace (LONG maxverts, LONG height)
{
    m_vertspace	= 0;
    maxverts	= max (maxverts, 3);
    
    if (!m_sortedge.SetElemCount(height))	
        return false;
    if (!m_sortcount.SetElemCount(height))	
        return false;
    if (!m_nextedge.SetElemCount(maxverts))	
        return false;
    
    if (!m_xarray.SetElemCount(maxverts))	
        return false;
    if (!m_xiarray.SetElemCount(maxverts))	
        return false;

    if (!m_ysarray.SetElemCount(maxverts))	
        return false;
    if (!m_yearray.SetElemCount(maxverts))	
        return false;
    if (!m_veflags.SetElemCount(maxverts))	
        return false;

    // Allocate enough space for our sections array
    if (!m_sectsarray.SetElemCount(maxverts))
        return false;

    m_cursortcount	= 0;

    // Initialize array pointers; these 'shortcuts'
    // allow direct dereferencing from the array.
    //
    // TODO: Would be nice to have some debug wrapper for this
    // to check array bounds
    m_nexte		= m_nextedge.Pointer(0);
    m_sorte		= m_sortedge.Pointer(0);
    m_sortc		= m_sortcount.Pointer(0);
    
    m_x			= m_xarray.Pointer(0);
    m_xi                = m_xiarray.Pointer(0);

    m_ys		= m_ysarray.Pointer(0);
    m_ye	        = m_yearray.Pointer(0);
    m_ef		= m_veflags.Pointer(0);
    
    m_vertspace	        = maxverts;
    m_heightspace	= height;
    
    
    return true;
} // SetVertexSpace

// =================================================================================================================
// SetAlpha
// =================================================================================================================
void CFillScanner::SetAlpha (ULONG a)
{
    // Clamp to a reasonable range
    DASSERT(a >= 0);
    if (a > 255)
        m_alpha = 255;
    else
        m_alpha = (BYTE)a;
   
    m_alphatable[0] = 0;
    for (LONG i=1; i < 256; i++)		
    {
        m_alphatable[i]	= (BYTE)((m_alpha*(i+1))>>8);
    }
    m_alphatable[256] = m_alpha;
} // SetAlpha

// =================================================================================================================
// BeginPoly
// =================================================================================================================
bool CFillScanner::BeginPoly (LONG maxverts)
{
    // compute shift
    m_subpixelshift		= Log2(m_subpixelscale);
    
    if (m_subpixelshift)
    {
        if (!m_coverage.AllocSubPixelBuffer (m_cpixTargetWidth, m_subpixelscale))
        {
            m_subpixelscale	= 1;
            m_subpixelshift	= 0;
        }
        else
        {
            // Cache these values to reduce the cost
            // of DrawScanLine
            m_clipLeftSubPixel = m_rectClip.left<<m_subpixelshift;
            m_clipRightSubPixel = m_rectClip.right<<m_subpixelshift;
        }
    }
    
    // Check to see if we need to reallocate our buffers
    LONG newheight	= m_cpixTargetHeight<< m_subpixelshift;
    if ((m_vertspace < maxverts) || (m_heightspace < newheight))
    {
        if (!SetVertexSpace (maxverts, newheight))	
            return false;
    }
    
    // Set some flags indicating whether all the vertices seen
    // so far are to the left/right/top/bottom. If all of them
    // are off to one side, then we can safely
    // ignore the poly.
    m_leftflag = true;
    m_rightflag = true;
    m_topflag = true;
    m_bottomflag= true;
    
    m_ystart		= _maxint32;
    m_yLastStart        = _minint32;
    m_yend		= _minint32;
    m_edgecount	        = 0;
    
    m_xstart		= _maxint32;
    m_xend		= _minint32;
    
    // Count of polygons that we have processed 
    // (if it exceeds some big number; we reset it)
    if (m_cursortcount > (1<<30))	
        m_cursortcount = 0;
    
    // By keeping track of which is the current polygon that
    // we are processing; we can eliminate the cost of
    // clearing the m_sorte array every polygon. Instead,
    // we just set m_sortc to indicate the current polygon count;
    // and that tells us if the corresponding entry in m_sorte is valid.
    if (!m_cursortcount)
    {
        // reset y sort buckets
        // (This happens the very first time; and it happens
        // if we hit a big number of polygons.)
        for (LONG i = 0; i < newheight; i++)
            m_sortc[i]	= -1;	
    }
    
    m_cursortcount++;
    
    return true;
} // BeginPoly

// =================================================================================================================
// AddEdge
//      This function adds edges to our edge array. It excludes lines that lie entirely
// above or below our top and bottom clip planes. It also excludes horinzontal edges.
//
//      For optimization purposes, it keeps track whether all of the edges seen are all to
// to one side of the clipRect. It also creates and maintains a linked list of each edge
// that starts at a particular y location. (The linked lists are maintained in m_sorte, m_nexte.)
// =================================================================================================================
bool CFillScanner::AddEdge (float x1, float y1, float x2, float y2)
{
    // Exclude nearly horizontal lines quickly
    if (IsRealEqual(y1, y2))
        return false;

    if (m_leftflag)	
        m_leftflag	= x1 < m_rectClip.left;
    if (m_rightflag)	
        m_rightflag	= x1 > m_rectClip.right;
    if (m_topflag)	
        m_topflag	= y1 < m_rectClip.top;
    if (m_bottomflag)	
        m_bottomflag	= y1 > m_rectClip.bottom;
    
    if (m_subpixelshift)
    {
        x1		*=  m_subpixelscale;
        y1		*=  m_subpixelscale;
        x2		*=  m_subpixelscale;
        y2		*=  m_subpixelscale;
    }

    // This hack prevents the numbers from getting too large
    PB_OutOfBounds(&x1);
    PB_OutOfBounds(&x2);

    // Round our Y values first
    LONG yi1 = PB_Real2IntSafe (y1 + .5f);	
    LONG yi2 = PB_Real2IntSafe (y2 + .5f);

    // Do a quick check for horizontal lines
    if (yi1 == yi2)
        return false;
    
    // compute dx, dy
    float ix = (x2 - x1);
    float dx;
    float iy = (y2 - y1);
    if (iy != 0)	
    {
        dx = ix/iy; 
    }		
    else 
    {   
        dx = 0;	
    }
    
    // edgesetup
    LONG miny = m_rectClip.top << m_subpixelshift;
    LONG maxy = m_rectClip.bottom << m_subpixelshift;

    // We flip edges so the Start is always the lesser of the y values
    LONG start, end;
    bool fFlipped;
    float xp, yp;
    if (y1 < y2)	
    {
        start = max (yi1, miny);	
        end = min (yi2, maxy);	
        xp = x1;  
        yp = y1;		
        fFlipped = false;
    }
    else
    {
        start = max (yi2, miny);	
        end = min (yi1, maxy);	
        xp = x2;  
        yp = y2;		
        fFlipped = true;
    }
    
    // Ignore lines that are clipped out
    // by the miny, maxy parameters.
    if (start >= end)
        return false;

    // Determine the data that we need to store in our edge array
    LONG count	= m_edgecount;
    float prestep = (float)start + .5f - yp;
    m_xi[count]	= PB_Real2Fix (dx);
    m_x[count] = PB_Real2FixSafe (xp + dx*prestep);
    
    m_ys[count] = start;	

    // Keep track of the top-most edge start
    if (start < m_ystart)		
    {
        m_ystart = start;	
    }

    // Keep track of the bottom-most edge start
    if (start > m_yLastStart)
    {
        m_yLastStart = start;
    }

    // Keep track of the bottom-most end
    m_ye[count] = end;		
    if (end > m_yend)			
    { 
        m_yend = end;		
    }

    // Remember if we have flipped this edge
    m_ef[count] = fFlipped ? -1 : 1;
    
    // <kd> What we now want to do is create a linked list of
    // edges that share the same startY. The head of the list of
    // the list for a particular startY is in m_sorte[startY].

    // m_sortc is a special (hacky) flag that checks if we have
    // initialized an entry for m_sorte. If it is initialized, then
    // we set the 'next' pointer for the current edge to point to the previous 
    // head pointer i..e m_sorte[start]. Else, we set it to -1, meaning null.
    if (m_sortc[start] == m_cursortcount)
    {
        // Sanity check data (-1 means null which is ok)
        DASSERT(m_sorte[start] >= -1);
        DASSERT(m_sorte[start] < count);

        // Set our next pointer to the previous head
        m_nexte[count] = m_sorte[start];
    }
    else
    {
        // Set our next to null
        m_nexte[count] = -1;
    }

    // Update the head pointer for this Y
    m_sorte[start] = count;

    // Mark the entry has having been initialized during this
    // polygon
    m_sortc[start] = m_cursortcount;
    
    m_edgecount++;
    
    return true;
} // AddEdge

// =================================================================================================================
// EndPoly
// =================================================================================================================
bool CFillScanner::EndPoly (void)
{
    // If all the points are all to the left/right/etc
    if (m_leftflag || m_rightflag || m_topflag || m_bottomflag)
        return false;

    // If our transparency is zero; then nothing to draw
    if (m_alpha == 0)
        return false;
    
    //scan edges
    if (m_edgecount > 1)	
        ScanEdges();
    m_edgecount	= 0;
    
    return true;
} // EndPoly

// =================================================================================================================
// SortSects
// =================================================================================================================
inline void SortSects(ULONG *sects, LONG *data, ULONG iEnd)
{
    DASSERT(iEnd < 0x10000000);
    if (iEnd < 2)
    {
        if (data[sects[0]] > data[sects[1]])
        {
            ULONG temp	= sects[0];
            sects[0]	= sects[1];
            sects[1]	= temp;
        }
        return;
    }
    
#ifdef USE_SELECTION_SORT
    for (LONG i = 0; i < iEnd; i++)
    {
        for (LONG j = i + 1; j <= iEnd; j++)
        {
            if (data[sects[i]] > data[sects[j]])
            {
                ULONG temp	= sects[i];
                sects[i]	= sects[j];
                sects[j]	= temp;
            }
        }    
    }
#else // !USE_SELECTION_SORT
    // From the nature of this usage; the array is almost
    // always sorted. And it is almost always small. So
    // we use a bubble-sort with an early out.
    //
    // CONSIDER: if there are lots of sects, then maybe we should qsort..
    //
    for (ULONG i = 0; i < iEnd; i++)
    {
        bool fSwapped = false;
        for (ULONG j = 0; j < iEnd; j++)
        {
            if (data[sects[j]] > data[sects[j+1]])
            {
                ULONG temp	= sects[j];
                sects[j]	= sects[j+1];
                sects[j+1]	= temp;
                fSwapped = true;
            }
        }    
        if (fSwapped == false)
        {
            // We ran through the entire list
            // and found that all elements were
            // already sorted.
            return;
        }
    }

#endif // !USE_SELECTION_SORT

} // SortSects

// =================================================================================================================
// DrawScanLine
// =================================================================================================================
void CFillScanner::DrawScanLine(LONG e1, LONG e2, LONG scanline)
{
    if (m_subpixelshift)
    {
        // =================================================================================================================
        // Sub pixel scanning
        // =================================================================================================================
        DASSERT((scanline >= 0) && ((ULONG)scanline < m_cpixTargetHeight<<m_subpixelshift));

        // Check that our cached values are what we thought are
        DASSERT(m_clipLeftSubPixel == m_rectClip.left<<m_subpixelshift);
        DASSERT(m_clipRightSubPixel == m_rectClip.right<<m_subpixelshift);

        // Convert our fixed point X coordinates into integers 
        LONG x1 = roundfix2int(m_x[e1]);
        LONG x2 = roundfix2int(m_x[e2]);

        // Clamp our range to left/right subpixels
        // Remember that x1 is inclusive; and x2 is exclusive
        if (x1 < m_clipLeftSubPixel)
            x1 = m_clipLeftSubPixel;
        if (x2 > m_clipRightSubPixel)
            x2 = m_clipRightSubPixel;

        // Did it get clipped away?
        if (x1 < x2)
        {
            // Check that casting to ULONG is safe now
            DASSERT(x1 >= 0);
            DASSERT(x2 >= 0);

            // Update the coverage buffers to account for this segment
            m_coverage.BlastScanLine((ULONG)x1, (ULONG)x2);
        }
    }
    else
    {
        // =================================================================================================================
        // Normal (aliased) drawing
        // =================================================================================================================
        DASSERT((scanline >= 0) && ((ULONG)scanline < m_cpixTargetHeight));

        // Convert our fixed point X coordinates into integers 
        LONG x1 = roundfix2int(m_x[e1]);
        LONG x2 = roundfix2int(m_x[e2]);

        // Clamp our range to left/right subpixels
        if (x1 < m_rectClip.left)
            x1 = m_rectClip.left;
        if (x2 > m_rectClip.right)
            x2 = m_rectClip.right;

        DASSERT(m_proc);
        m_proc(scanline, 
                x1, 
                x2, 
                m_coverage.Buffer(), 
                0 /* subpixelshift */, 
                1 /* cScan */, 
                m_scanlineProcData);
    }
    
    m_x[e1] += m_xi[e1];
    m_x[e2] += m_xi[e2];
    
} // DrawScanLine

// =================================================================================================================
// ScanEdges
// =================================================================================================================
void CFillScanner::ScanEdges(void)
{
    // Check that we don't go over our array of intersection edges
    DASSERT(m_sectsarray.GetElemSpace() >= (ULONG)m_edgecount);

    // Get a local pointer to the array 
    ULONG *sects = m_sectsarray.Pointer(0);

    // To optimize some checking in the core loop; we pre-compute
    // a quick way to check when we are done with a coverage buffer
    // We want a number X such that (cur+1 & X) == 0 indicates that
    // we gone far enough to render what we have sitting in the
    // coverage buffer.
    DWORD dwCoverageCompletionMask;
    if (m_subpixelshift)
    {
        DASSERT(m_subpixelscale > 1);
        DASSERT(m_subpixelshift == Log2(m_subpixelscale));

        // Whenever cur+1 reaches a multiple of m_subpixelscale
        // (which is guaranteed to be 2, 4, 8, 16). Then we
        // need to flush our coverage buffer.
        //
        // For example, when subpixelscale is 4, then 
        // if the cur+1 is 0 mod 4; then we need to flush.
        // The quick way to check that is ((cur+1) & 3) == 0
        dwCoverageCompletionMask = m_subpixelscale - 1;
    }
    else
    {
        // If no subpixel; then there is no coverage buffer;
        // since cur is always >=0; cur+1 is always > 0,
        // so 0xFFFFFFFF & cur+1 equals cur+1 and cur+1 is always non-zero
        dwCoverageCompletionMask = 0xFFFFFFFF;
    }
    
    // This is the index of the first edge in our active list
    LONG activeE = -1;

    // Keep track of the vertical distance until the next edge start/stops
    // (this lets us recognize stretches where the set of edges that
    // start/stop haven't changed).
    LONG nextystart = m_yend;

    // Keep track of the last active edge in our
    // active edge 'list'
    LONG iLastActiveEdge = -1;    

    // the current scan-line
    LONG cur = m_ystart;

    // For all scanlines
    do
    {
        // =================================================================================================================
        // find all edges that intersect this scanline
        //
        // The brute-force strategy is the following:
        //
        // for (LONG i = 0; i < m_edgecount; i++)
        // {
        //      if ((cur >= ys[i]) && (cur < ye[i]))	
        //          sects[cursects++] = i;
        // }            
        //
        // I.e. just iterate over all edges and see if any intersect
        // with this scanline. If so add them to our sects array.
        //

        // The actual algorithm takes advantage of information
        // that we built up during the AddEdge phase. For each scan-line
        // we have a "linked-list" of edges that start there. 
        //
        // So whenever we hit a new scan line, we just append those new
        // edges with our current Active list. Then we just run through the
        // Active list to determine which edges in Active list are still active.
        // 
        //
        // As a minor optimization, we keep track of the minimum scan-line where
        // something changes i.e. (edge should be added to our list or removed).

        ULONG cursects = 0;
        LONG nexty = m_yend;

        // Add edges to our active edge list if there are new ones to add
        // (This check sees if this scan-line was the start line for any edge 
        // during this this polygon; it's an optimization to prevent resetting this
        // array every polygon..)
        //
        if (m_sortc[cur] == m_cursortcount)
        {
            // There are edges that start at this scan-line
            DASSERT(m_sorte[cur] != -1);

            // Check that the first edge looks reasonable
            DASSERT(m_sorte[cur] < m_edgecount);

            // So we need to add the new edges to our active list
            // by pointing the last element of the active list to
            // the first new edge
            
            // If we have no active edges; then just take the
            // the new list
            if (activeE == -1)
            {
                activeE = m_sorte[cur];
            }
            else
            {
                // If we have an active list; then we must have a last edge
                // in that list
                DASSERT(iLastActiveEdge >= 0);
            
                // It better be a 'last edge' i.e. have no next ptr.
                DASSERT(m_nexte[iLastActiveEdge] == -1);

                // For sanity checking; let's make sure that what we
                // think is our last active edge is actually the last
                // active edge
#ifdef DEBUG
                {
                    // Start at the beginning of the active list
                    LONG iLastTest = activeE;

                    DASSERT(iLastTest >= 0);

                    // Iterate through list until we hit at the end
                    while (m_nexte[iLastTest] >= 0)
                        iLastTest = m_nexte[iLastTest];

                    // Check that we have what we are supposed to have
                    DASSERT(iLastTest == iLastActiveEdge);
                }
#endif // DEBUG

                // Point our last active edge to our list of new edges that all start at
                // this scan-line
                m_nexte[iLastActiveEdge] = m_sorte[cur];
            }

            // Compute the minimum scan-line ahead of 
            // us where an edge starts.
            
            // We kept track of the last start during AddEdges;
            // so we use that information to reduce this run. The following
            // assert checks that something does start at LastStart
            DASSERT(m_sortc[m_yLastStart] == m_cursortcount);

            if (cur >= m_yLastStart)
            {
                nextystart = m_yend;
            }
            else
            {
                for (LONG i = cur + 1; i <= m_yLastStart; i++)	
                {
                    if (m_sortc[i] == m_cursortcount)
                    {
                        nextystart	= i;
                        break;
                    }
                }

                // We must have found it
                DASSERT(nextystart == i);
            }
            DASSERT(nextystart <= m_yend);
        }

        // Initialize nexty to indicate the Next
        // y value where an edge begins
        nexty = nextystart;
           
        // search active edges
        LONG prev = -1;
        for (LONG i = activeE; i >= 0; i = m_nexte[i])
        {
            // Assert that we don't have loops of one
            DASSERT(m_nexte[i] != i);
            // Assert that we don't have loops of two
            DASSERT(m_nexte[m_nexte[i]] != i);

            if (cur < m_ye[i])
            {
                // If this edge ends below this scan-line
                // then it intersects the scan-line; so add it
                // to the array of intersections.
                sects[cursects++] = i;
                DASSERT(cursects <= (ULONG)m_edgecount);

                // Update our nexty value to be the minimum
                // y value where an edge ends or begins
                if (nexty > m_ye[i])		
                    nexty = m_ye[i];

                // Remember previous element in our list to 
                // handle deletions
                prev = i;
            }
            else 
            {
                // Else this edge should no longer be active; so we
                // need to delete it from the active list.

                // If we have a previous, then point 
                // it to our next else our next is the new
                // active list.
                if (prev >= 0)
                    m_nexte[prev]	= m_nexte[i];
                else						
                    activeE		= m_nexte[i];

                // In this case, the 'previous' element
                // doesn't change because the current element
                // is deleted.
            }

            // Assert that we don't have loops of one
            DASSERT(m_nexte[i] != i);
            // Assert that we don't have loops of two
            DASSERT(m_nexte[m_nexte[i]] != i);
        }

        // The 'prev' element indicates the last edge of the active list (if
        // there is one).
#ifdef DEBUG
        DASSERT(i == -1);
        if (prev == -1)
        {
            // If we have no last element; then we must not 
            // have a list at all.
            DASSERT(activeE == -1);   
        }
        else
        {
            // Else check that it really is the end of some list.
            DASSERT(m_nexte[prev] == -1);
        }
#endif // DEBUG

        // Cache it away.
        iLastActiveEdge = prev;
        
        // =================================================================================================================
        // find pairs of intersections of edges with scan-lines
        DASSERT(cursects <= (ULONG)m_edgecount);
        if (cursects > 1)
        {
            // A "region" is a set of scan-lines where 
            // no edges start and end except at the top/bottom.
            int yBeginRegion = cur;

            do 
            {
                // Sort the intersections
                SortSects (sects, m_x, cursects - 1);					

                // Winding rules involve looking at the orientation
                // of the polygons which is captured by m_ef
                if (m_fWinding)
                {
                    ULONG i=0, e1, x1;
                    LONG winding = 0;
                    do
                    {
                        LONG e2 = sects[i++];
                        if (!winding)			
                        {
                            e1 = e2;	
                            winding = m_ef[e2];	
                            x1 = m_x[e2];
                        }
                        else
                        {
                            winding += m_ef[e2];
                            
                            if (!winding)
                            {
#define DO_RASTER 1
#if DO_RASTER
                                DrawScanLine (e1, e2, cur);
#endif
                            }
                            else 
                            {
                                m_x[e2] += m_xi[e2]; //increment edge we "skip"
                            }
                        }
                    }
                    while (i < cursects);
                }
                else
                {
                    // The default case is alternating i.e. if A, B, C, D, E, F are all
                    // intersections along a scan-line then draw a segment from A to B, 
                    // from C to D, and from E to F.

                    ULONG i=0;
                    do
                    {
                        // Take the current intersection
                        ULONG e1 = sects[i];

                        // And the next
                        i++;
                        ULONG e2 = sects[i];

                        // And then jump to the next intersection
                        i++;

#if DO_RASTER
                        DrawScanLine (e1, e2, cur);
#endif
                    }
                    while (i < cursects - 1); //-1 because we do two at a time
                }
                
                // =================================================================================================================
                // increment scanline
                cur++;

                // Check if we have finished a coverage buffer; see
                // the top of this function for an explanation of this 
                // magic value
                if ((cur & dwCoverageCompletionMask) == 0)
                {
                    DASSERT(m_proc);

                    // Count of number of identical scan-lines
                    ULONG cScan;

                    // Here we want to optimize for rectangular sections;
                    // So we say: if there are only k intersections; and
                    // they are vertical; and we have more than a full vertical
                    // sub-pixel left to draw vertically; and we've already
                    // filled an entire buffer during this region: Then
                    // we optimize it.
                    DASSERT(cursects >= 2);
                    if (m_xi[sects[0]] == 0 && 
                            m_xi[sects[1]] == 0 && 
                            (nexty - cur) >= m_subpixelscale && 
                            (cur - yBeginRegion) >= m_subpixelscale)
                    {
                        // Check the rest of the intersections to
                        // see if they are vertical:
                        for (ULONG i = 2; i < cursects; i++)
                        {
                            if (m_xi[sects[i]] != 0)
                                break;
                        }

                        // Check to see if we exited the above loop early i.e.
                        // one of the edges wasn't zero.
                        if (i == cursects)
                        {

                            DASSERT(m_subpixelscale > 1);
                            DASSERT(m_subpixelshift > 0);
                            // Count the number of complete scan-lines
                            // between cur and nexty. (We add one because
                            // we already have completed one scanline.)
                            //
                            // cScan = 1 + FLOOR((nexty - cur) / m_subscalescale);
                            // is the right equation; the following is
                            // an optimization.
                            cScan = 1 + ((nexty - cur) >> m_subpixelshift);

                            // Sanity check the logic
                            DASSERT(cScan == 1 + (ULONG)((nexty - cur) / m_subpixelscale));
                        }
                        else
                        {
                            // Not all of the edges were vertical; so
                            // we can't do multiple copies of the same
                            // scan
                            DASSERT(i < cursects);
                            DASSERT(m_xi[sects[i]] != 0);
                            cScan = 1;
                        }
                    }
                    else
                    {
                        cScan = 1;
                    }
        
                    m_proc ((cur-1)>>m_subpixelshift,	
                        m_coverage.MinPix(), 
                        m_coverage.MaxPix(), 
                        m_coverage.Buffer(), 
                        m_subpixelshift, 
                        cScan,
                        m_scanlineProcData);
                    m_coverage.ExtentsClearAndReset();

                    // Increment cur if we did a multi-line
                    DASSERT(cScan >= 1);
                    if (cScan > 1)
                    {   
                        // Cur should be incremented by the number
                        // of extra scan-lines times the vertical subsampling
                        // i.e. cur += (cScan - 1) * m_subpixelscale;                    }
                        DASSERT((cScan - 1) * m_subpixelscale == ((cScan - 1) << m_subpixelshift));
                        cur += (cScan - 1) << m_subpixelshift;
                    }
                }
            }
            while (cur < nexty);
        }
        else 
        {
            // =================================================================================================================
            // increment scanline anyway
            cur++;

            // Check if we have finished a coverage buffer; see
            // the top of this function for an explanation of this 
            // magic value
            if ((cur & dwCoverageCompletionMask) == 0)
            {
                DASSERT(m_proc);
                m_proc ((cur-1)>>m_subpixelshift,	
                    m_coverage.MinPix(), 
                    m_coverage.MaxPix(), 
                    m_coverage.Buffer(), 
                    m_subpixelshift, 
                    1 /* cScan */,
                    m_scanlineProcData);
                m_coverage.ExtentsClearAndReset();

                // We have flushed our buffer; and there are
                // only 0 or 1 edges active (which is why
                // there is nothing to draw)
                DASSERT(cursects <= 1);

                // So let's just skip our scan-line forward
                // until an edge is being added or deleted
                DASSERT(cur <= nexty + 1);
                if (cur < nexty)
                    cur = nexty;
            }
        }
    }
    while (cur < m_yend);

    // We must have processed at least one row
    DASSERT(cur > 0);

    // flush the Leftover in m_coverage buffer (unless we are already
    // at a line that causes a flush automatically in the main do...while loop.
    // (see the top of this function for an explanation of this magic value)
    if ((cur & dwCoverageCompletionMask) != 0)
    {
        DASSERT(m_proc);
        m_proc ((cur-1)>>m_subpixelshift,	
            m_coverage.MinPix(), 
            m_coverage.MaxPix(), 
            m_coverage.Buffer(), 
            m_subpixelshift, 
            1 /* cScan */,
            m_scanlineProcData);
        m_coverage.ExtentsClearAndReset();
    }
    
    return;
} // ScanEdges


//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\mscanner\mscanner2d.h ===
//************************************************************
//
// FileName:	    mlinescan.cpp
//
// Created:	    1996
//
// Author:	    Sree Kotay
// 
// Abstract:	    scan-based algorithm for drawing AA polygons
//
// Change History:
// ??/??/97 sree kotay  Wrote AA polygon scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************
#ifndef _FillScanner_H
#define _FillScanner_H

#include "MCoverage.h"

typedef void (*ScanlineProc) (LONG y, LONG start, LONG end, BYTE *weights, ULONG shift, ULONG cScan, void *procdata);

// =================================================================================================================
// Scanner
// =================================================================================================================
class CFillScanner
{
   
public:
    LONG m_subpixelscale;

    // These three allow for a linked-list of each edge that starts
    // at a particular scan line. 
    LONG *m_nexte;

    // This entry indicates the head of the current list (or -1 for null)
    // (Note you have to check m_sortc before looking at this.)
    LONG *m_sorte;

    // This entry indicates whether the head pointer is valid (if it equals cursortcount 
    // then it is valid)
    LONG *m_sortc;
    
    // These two are actually stored in fixed-point
    LONG *m_x;
    LONG *m_xi;

    // Start and End Y locations for each edge
    LONG *m_ys;
    LONG *m_ye;

    // Did we have to flip the edge to fit into our model? (Only needed for winding fill.)
    LONG *m_ef;

    // Alpha value to render with
    BYTE m_alpha;

    // Is winding enabled
    bool m_fWinding;
   
    RECT m_rectClip;
    ULONG m_cpixTargetWidth;
    ULONG m_cpixTargetHeight;
    CoverageBuffer m_coverage;
    
    void *m_scanlineProcData;
    ScanlineProc m_proc;
    
    // =================================================================================================================
    // Constructor/Destructor
    // =================================================================================================================
    CFillScanner();
    ~CFillScanner();
    
    // =================================================================================================================
    // Properties
    // =================================================================================================================
    bool SetVertexSpace(LONG maxverts, LONG height);
    void SetAlpha(ULONG alpha);
    
    // =================================================================================================================
    // Polygon Drawing
    // =================================================================================================================
    bool BeginPoly(LONG maxverts=20); // return false means failure (no memory)
    bool EndPoly(void); // return false means no drawing (clipped out)
    bool AddEdge(float x1, float y1, float x2, float y2); // return false means edge too small to add


protected:

    // =================================================================================================================
    // ScanEdges
    // =================================================================================================================
    void ScanEdges(void);
    void DrawScanLine(LONG e1, LONG e2, LONG scanline);
    void DrawScanLineVertical(LONG e1, LONG e2, LONG scanline);
    bool TestScanLine(LONG e1, LONG e2, LONG scanline);


    // Member data
    TArray<LONG> m_nextedge;
    TArray<LONG> m_sortedge;
    TArray<LONG> m_sortcount;
    
    TArray<LONG> m_xarray;
    TArray<LONG> m_xiarray;

    TArray<LONG> m_yarray;
    TArray<LONG> m_yiarray;

    TArray<LONG> m_ysarray;
    TArray<LONG> m_yearray;
    TArray<LONG> m_veflags;
    
    TArray<ULONG> m_sectsarray;
    
    LONG m_cursortcount;
    
    LONG m_leftflag, m_rightflag;
    LONG m_ystart, m_yend;

    LONG m_yLastStart;

    LONG m_edgecount;
    LONG m_vertspace;
    LONG m_heightspace;
    
    LONG m_topflag, m_bottomflag;
    LONG m_xstart, m_xend;
    
    LONG m_subpixelshift;
    
    BYTE m_alphatable[257];

    // Cached values to reduce computation
    // in critical paths
    // The left clip edge in subpixel space (= m_rectClip.left<<m_subPixelShift)
    LONG m_clipLeftSubPixel; 
    // The right clip edge in sub-pixel space (= m_rectClip.right<<m_subPixelShift)
    LONG m_clipRightSubPixel;
};

#endif // for entire file
//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\mscanner\mstroke.cpp ===
//************************************************************
//
// FileName:	    mcoverage.cpp
//
// Created:	    1997
//
// Author:	    Sree Kotay
// 
// Abstract:	    Stroke implementation file
//
// Change History:
// ??/??/97 sree kotay  Wrote sub-pixel AA scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************

#include "precomp.h"
#include "MSupport.h"
#include "MStroke.h"
#include "MScanner2d.h"
#include "MLineScan.h"

// Array points to use for circle caps; initialized only once
static float s_rgflCircle[(CStroke::CIRCLE_SAMPLES+1)*2];
static bool s_fCircleSampleInit = false;

// =================================================================================================================
// Constructor
// =================================================================================================================
CStroke::CStroke() :
    m_plinescanner(NULL),
    m_pscanner(NULL),
    m_fValidStarts(false),
    m_proc(NULL),
    m_pprocdata(NULL),
    m_flStrokeRadius(1.0f),
    m_flMaxStrokeRadius(1.0f),
    m_joinType(eRoundJoin),
    m_capType(eRoundCap),
    m_flMiterLimit(DEFAULT_MITER_LIMIT)
{
    // Sanity check that we have the right number of entries in
    // our array
    DASSERT(sizeof(s_rgflCircle)/sizeof(s_rgflCircle[0]) == (CIRCLE_SAMPLES+1)*2);
    
    if (!s_fCircleSampleInit)
    {
        float flStep = 1.0f / (float)(CIRCLE_SAMPLES);
        for (ULONG i = 0; i <= CIRCLE_SAMPLES; i++)
        {
            float ang = (float)(3.141592*2*flStep*float(i));
            s_rgflCircle[(i*2)]	= (float)::cos(ang);
            s_rgflCircle[(i*2) + 1]	= (float)::sin(ang);
        }
        s_fCircleSampleInit = true;
    }
} // CStroke

// =================================================================================================================
// BeginStroke
// =================================================================================================================
void CStroke::BeginStroke (void)
{
    m_fValidStarts = false;
} // BeginStroke

// =================================================================================================================
// EndStroke
// =================================================================================================================
void CStroke::EndStroke (void)
{
    m_fValidStarts = false;
} // EndStroke

// =================================================================================================================
// AddEdge
// =================================================================================================================
void CStroke::AddEdge(float x1, float y1, float x2, float y2)
{
    if (m_proc)
    {
        m_proc (&x1, &y1, m_pprocdata);
        m_proc (&x2, &y2, m_pprocdata);
    }
    
    if (m_plinescanner)
        m_plinescanner->RealLineTo(x1,y1,x2,y2);
    else
        m_pscanner->AddEdge(x1,y1,x2,y2);

    return;
} // AddEdge

// =================================================================================================================
// DrawCircle
// =================================================================================================================
void CStroke::DrawCircle (float x, float y)
{
    LONG step = (LONG)(float (float(CIRCLE_SAMPLES)/m_flMaxStrokeRadius + .5)*.5);

    // Clamp step to [1, 16]
    if (step <= 1)
        step = 1;
    else if (step > 16)
        step = 16;
        
    float xo1, yo1;
    for (LONG i = 0; i <= CIRCLE_SAMPLES; i += step)
    {
        LONG i1	= i * 2;
        float xc1 = s_rgflCircle[i1  ]*m_flStrokeRadius	+ x;
        float yc1 = s_rgflCircle[i1+1]*m_flStrokeRadius	+ y;
        
        if (i)		
        {
            AddEdge (xo1, yo1, xc1, yc1);
        }
        
        xo1			= xc1;
        yo1			= yc1;
    }
    float xc1	= s_rgflCircle[0]*m_flStrokeRadius	+ x;
    float yc1	= s_rgflCircle[1]*m_flStrokeRadius	+ y;
    AddEdge (xo1, yo1, xc1, yc1);
} // DrawCircle

// =================================================================================================================
// StartCap
// =================================================================================================================
void CStroke::StartCap (float x1, float y1, float x2, float y2)
{
    DASSERT (m_pscanner);
    if ((x1==x2) && (y1==y2))	
        return;
    
    float ax = x2 - x1;
    float ay = y2 - y1;
    
    float mag	= (float)((1.0 / sqrt(ax*ax + ay*ay)) * m_flStrokeRadius);
    ax *= mag;
    ay *= mag;
    
    // start cap
    switch (m_capType)
    {
    case eSquareCap:
        AddEdge (x1 - ay, y1 + ax, x1 - ay - ax, y1 + ax - ay);
        AddEdge (x1 - ay - ax, y1 + ax - ay, x1 + ay - ax, y1 - ax - ay);
        AddEdge (x1 + ay - ax, y1 - ax - ay, x1 + ay, y1 - ax);
        break;
    case eRoundCap:
        //flat cap
        AddEdge (x1 - ay, y1 + ax, x1 + ay, y1 - ax);
        
        //round cap
        DrawCircle (x1, y1);
        break;
    case eFlatCap:
    default:
        AddEdge (x1 - ay, y1 + ax, x1 + ay, y1 - ax);
        break;
    }
    
    m_fValidStarts	= true;
    m_flSx1			= x1 - ay;
    m_flSy1			= y1 + ax;
    m_flSx2			= x1 + ay;
    m_flSy2			= y1 - ax;
} // StartCap

// =================================================================================================================
// EndCap
// =================================================================================================================
void CStroke::EndCap (float x1, float y1, float x2, float y2)
{
    DASSERT (m_pscanner);
    if ((x1==x2) && (y1==y2))	
        return;
    
    float ax		 = x2 - x1;
    float ay		 = y2 - y1;
    
    float mag	= (float)((1.0 / sqrt(ax*ax + ay*ay)) * m_flStrokeRadius);
    ax			*= mag;
    ay			*= mag;
    
    // end cap
    switch (m_capType)
    {
    case eSquareCap:
        AddEdge (x2 + ay, y2 - ax,              x2 + ay + ax, y2 - ax + ay);
        AddEdge (x2 + ay + ax, y2 - ax + ay,    x2 - ay + ax, y2 + ax + ay);
        AddEdge (x2 - ay + ax, y2 + ax + ay,    x2 - ay, y2 + ax);
        break;
    case eRoundCap:
        // flat cap
        AddEdge (x2 + ay, y2 - ax, x2 - ay, y2 + ax);
        
        // round cap
        DrawCircle (x2, y2);
        break;
    case eFlatCap:
    default:
        AddEdge (x2 + ay, y2 - ax, x2 - ay, y2 + ax);
        break;
    }
    
    m_fValidStarts = false;
} // EndCap

// =================================================================================================================
// Segment
// =================================================================================================================
void CStroke::Segment(float x1, float y1, float x2, float y2)
{
    DASSERT(m_pscanner);
    if ((x1==x2) && (y1==y2))	
        return;
    
    float ax		 = x2 - x1;
    float ay		 = y2 - y1;
    
    float mag	= (float)((1.0 / sqrt(ax*ax + ay*ay)) * m_flStrokeRadius);
    ax			*= mag;
    ay			*= mag;
    
    // connect to previous segment if unconnected
    if (m_fValidStarts)
    {
        float sx1		= x1 - ay;
        float sy1		= y1 + ax;
        float sx2		= x1 + ay;
        float sy2		= y1 - ax;
        
        if ((sx1 != m_flSx1) || (sy1 != m_flSy1))
            AddEdge(sx1, sy1, m_flSx1, m_flSy1);
        
        if ((sx2 != m_flSx2) || (sy2 != m_flSy2))
            AddEdge(m_flSx2, m_flSy2, sx2, sy2);
    }
    
    
    // segment stroke
    AddEdge(x1 + ay, y1 - ax, x2 + ay, y2 - ax);
    AddEdge(x2 - ay, y2 + ax, x1 - ay, y1 + ax);
    
    
    m_fValidStarts	= true;
    m_flSx1			= x2 - ay;
    m_flSy1			= y2 + ax;
    m_flSx2			= x2 + ay;
    m_flSy2			= y2 - ax;
} // Segment

// =================================================================================================================
// LinesSect - Return the intersection of two lines. If the two lines don't intersect
//              return false.
// =================================================================================================================
bool LinesSect(float x1, float y1, float x2, float y2, 
               float x3, float y3, float x4, float y4,
               float &px, float &py)
{
    float ix1 = x2 - x1;
    float ix2 = x4 - x3;
    
    if (IsRealZero(ix1) && IsRealZero(ix2))		
        return false; //both vertical lines
    
    float m1	= (IsRealZero(ix1)) ? 0 : (y2-y1)/ix1;
    float m2	= (IsRealZero(ix2)) ? 0 : (y4-y3)/ix2;
    
    if (IsRealZero(ix1))
    {
        float b2	= y3 - m2*x3;
        px		= x1;
        py		= b2 + m2*px;
    }
    else if (IsRealZero(ix2))
    {
        float b1	= y1 - m1*x1;
        px		= x3;
        py		= b1 + m1*px;
    }
    else
    {
        if (IsRealEqual(m1, m2))			
            return false; //same slope
        
        float b1	= y1 - m1*x1;
        float b2	= y3 - m2*x3;
        
        px		= (b2-b1)/(m1-m2);

        // Use the smaller (in magnitude) slope to reduce
        // floating point errors; this prevents
        // wackiness when lines are nearly vertical. 
        // Bug #34817
        if (fabs(m1) < fabs(m2))        
            py = b1 + m1*px;
        else
            py = b2 + m2*px;
    }
    
    return true;
} // LinesSect

// =================================================================================================================
// PB_BetweenAB
// =================================================================================================================
bool PB_BetweenAB (float t, float a, float b)
{
    if (a < b)
    {
        if (t < a)	
            return false;
        if (t > b)	
            return false;
    }
    else
    {
        if (t < b)	
            return false;
        if (t > a)	
            return false;
    }
    return true;
} // PB_BetweenAB

// =================================================================================================================
// Join
// =================================================================================================================
void CStroke::Join(float x1, float y1, float x2, float y2, float x3, float y3)
{
    DASSERT(m_pscanner);
    if ((x1==x2) && (y1==y2))	
        return;
    if ((x3==x2) && (y3==y2))	
        return;
    
    // segment 1
    float ax		 = x2 - x1;
    float ay		 = y2 - y1;
    
    float mag	= (float)((1.0 / sqrt(ax*ax + ay*ay)));
    ax			*= mag;
    ay			*= mag;
    
    // segment 2
    float bx		 = x3 - x2;
    float by		 = y3 - y2;
    
    float mag2	= (float)(1.0 / sqrt(bx * bx + by * by));
    bx			*= mag2;
    by			*= mag2;
    
    float p1x, p1y, p2x, p2y;
    bool result	= true;
    float dot		= ax*bx + ay*by; 
    
    // scale by stroke
    ax	*= m_flStrokeRadius;
    ay	*= m_flStrokeRadius;
    bx	*= m_flStrokeRadius;
    by	*= m_flStrokeRadius;
   
    // miter join
    if ((dot > m_flMiterLimit) && (m_joinType == eMiterJoin) && (m_flMaxStrokeRadius > .75))
    {
        if (!LinesSect (x1 + ay, y1 - ax, x2 + ay, y2 - ax,
                x2 + by, y2 - bx, x3 + by, y3 - bx, p1x, p1y))	
        {
            result = false;
        }
        else if (!LinesSect (x1 - ay, y1 + ax, x2 - ay, y2 + ax,
                x2 - by, y2 + bx, x3 - by, y3 + bx, p2x, p2y))	
        {
            result = false;
        }
    }
    else
    {
        result = false;
    }
    
    
    if ((m_flMaxStrokeRadius > 1) && (m_joinType == eRoundJoin))
    {
        DrawCircle (x2, y2);
        // but we still need to bevel
    }
    
    // join stroke
    if (result)
    {
        // only miter if the intersection is not between the points
        if ((PB_BetweenAB (p1x, x1 + ay, x2 + ay)) && 
                (PB_BetweenAB (p1y, y1 - ax, y2 - ax)))
        {
            AddEdge (x2 + ay, y2 - ax, x2 + by, y2 - bx);
        }
        else
        {
            AddEdge (x2 + ay, y2 - ax,		p1x, p1y);
            AddEdge (p1x, p1y, x2 + by, y2 - bx);
        }
        
        // only miter if the intersection is not between the points
        if ((PB_BetweenAB (p2x, x1 - ay, x2 - ay)) && 
                (PB_BetweenAB (p2y, y1 + ax, y2 + ax)))
        {
            AddEdge (x2 - by, y2 + bx, x2 - ay, y2 + ax);
        }
        else
        {
            AddEdge (x2 - by, y2 + bx,	p2x, p2y);
            AddEdge (p2x, p2y, x2 - ay, y2 + ax);
        }
    }
    else
    {
        // bevel join
        AddEdge (x2 + ay, y2 - ax, x2 + by, y2 - bx);
        AddEdge (x2 - by, y2 + bx, x2 - ay, y2 + ax);
    }
    
    m_fValidStarts = false;
} // Join

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\mscanner\mstroke.h ===
//************************************************************
//
// FileName:	    mstroke.cpp
//
// Created:	    1997
//
// Author:	    Sree Kotay
// 
// Abstract:	    Core Gradient filter
//
// Change History:
// ??/??/97 sree kotay  Wrote AA stroke engine for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************

#ifndef _CStroke_H
#define _CStroke_H

// forward declaration
class CLineScanner;
class CFillScanner;

// Allow the host to apply a post-transform on the points
typedef void (*PointProc) (float *x, float *y, void *procdata);

// =================================================================================================================
// CStroke
// =================================================================================================================
class CStroke
{
public:
    // Number of segments that a rounded cap will generate
    enum
    {
        CIRCLE_SAMPLES = 64
    };

protected:
    bool m_fValidStarts;
    float m_flSx1, m_flSy1;
    float m_flSx2, m_flSy2;
    

    void DrawCircle(float x, float y);
    void AddEdge(float x1, float y1, float x2, float y2);
    
public:
    enum
    {
        eMiterJoin,
        eBevelJoin,
        eRoundJoin,
        eFlatCap,
        eSquareCap,
        eRoundCap
    };
    
    // =================================================================================================================
    // Properties
    // =================================================================================================================
    float m_flStrokeRadius;
    float m_flMaxStrokeRadius;
    float m_flMiterLimit;		//as cosAng

    // Default miter-limit as "cosAng"?
#define DEFAULT_MITER_LIMIT (-0.3f)

    ULONG m_joinType;
    ULONG m_capType;
    
    
    CFillScanner *m_pscanner;
    CLineScanner *m_plinescanner;
    
    void *m_pprocdata;
    PointProc m_proc;
    
    // =================================================================================================================
    // Constructor/Destructor
    // =================================================================================================================
    CStroke();
    ~CStroke() 
    {
        // sanity check our data structures
        DASSERT(m_joinType == eMiterJoin || m_joinType == eBevelJoin || m_joinType == eRoundJoin);
        DASSERT(m_capType == eFlatCap || m_capType == eSquareCap || m_capType == eRoundCap);
    };
    
    // =================================================================================================================
    // Wrappers
    // =================================================================================================================
    void BeginStroke(void);
    void EndStroke(void);
    
    // =================================================================================================================
    // Functions
    // =================================================================================================================
    void StartCap(float x1, float y1, float x2, float y2);
    void EndCap(float x1, float y1, float x2, float y2);
    void Segment(float x1, float y1, float x2, float y2);
    void Join(float x1, float y1, float x2, float y2, float x3, float y3);
};

#endif // for entire file
//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\mscanner\precomp.h ===
// This needs to be in this directory for PCH to work, but we actually keep
// all the directives down in ..\inc\common.h

#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\mscanner\msupport.h ===
//************************************************************
//
// FileName:	    msupport.h
//
// Created:	    1996
//
// Author:	    Sree Kotay
// 
// Abstract:	    Utility helper file
//
// Change History:
// ??/??/97 sree kotay  Wrote AA line scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************

#ifndef __MSUPPORT_H__ // for entire file
#define __MSUPPORT_H__

#include "dassert.h"
#include "_tarray.h"
#include "math.h"



const LONG  	_maxint32 = 2147483647; 				//2^31 - 1
const SHORT  	_minint16 = -32768; 					//-2^15
const SHORT  	_maxint16 = 32767; 					//2^15 - 1
const LONG  	_minint32 = -_maxint32-1; 				//-2^31
const ULONG  	_maxuint32 = 4294967295; 				//2^32 - 1


/************************** comparison macros **************************/
#define IsRealZero(a)                   (fabs(a) < 1e-5)
#define IsRealEqual(a, b)               (IsRealZero((a) - (b)))

// Quick Routine for determining if a number is a pow-of-two
inline bool IsPowerOf2(LONG a)
{
    // This nifty function (a & a-1) has the property
    // that it turns off the lowest bit that is on
    // i.e. 0xABC1000 goes to 0xABC0000.
    if ((a & (a-1)) == 0)
    {
        if (a)
            return true;
    }
    return false;
}

// Helper function that returns the log base 2 of a number
inline LONG Log2(LONG value)
{
    if (value == 0)
    {
        DASSERT(FALSE);
        return 0;
    }
        
    LONG cShift = 0;
    while (value >>= 1)	
        cShift++;
    return cShift;
} // Log2

// Bitwise Rotation implemention.. (We
// implement this ourselves because _lrotl gave link
// errors in retail). (I don't use ASM because VC5 disables
// optimizations for functions that have ASM in them.)
inline DWORD RotateBitsLeft(DWORD dw, ULONG cShift = 1)
{   
    // Multiples of 32 are no-ops
    cShift = cShift % 32;

    // We shift the main term to the left, and then we OR
    // it with the high-bits which we shift right
    return ((dw << cShift) | (dw >> (32 - cShift)));
} // RotateBitsLeft

inline DWORD RotateBitsRight(DWORD dw, ULONG cShift = 1)
{   
    // Multiples of 32 are no-ops
    cShift = cShift % 32;

    // We shift the main term to the right, and then we OR
    // it with the low-bits which we shift left
    return ((dw >> cShift) | (dw << (32 - cShift)));
} // RotateBitsRight

// AbsoluteValue functions
// (Need this to prevent link errors.)
inline LONG abs(LONG lVal)
{
    if (lVal < 0)
        return -lVal;
    else
        return lVal;
} // abs

inline float fabs(float flVal)
{
    if (flVal < 0.0f)
        return -flVal;
    else
        return flVal;
} // fabs

// Returns one over the square root
inline float sqrtinv(float flValue)
{
    return (float)(1.0f / sqrt(flValue));
} // sqrtinv


#pragma warning(disable: 4756) // overflow in constant arithmetric
// This function provides an automatic way for
// the fixed point Real calculations to be clipped to a 
// number that fits in their range. The original meta code
// used +/- 24000 as the appropriate range.
//
// TODO: This is inherently buggy.
const LONG _maxvali		=  24000;
const float _maxval		=  _maxvali;
const float _minval		= -_maxvali;
inline ULONG PB_Real2IntSafe(float flVal)
{
    // Check that the magnitude is reasonable
    if (fabs(flVal) < _maxval)
        return (ULONG)flVal;

    // Clamp to range (minval, maxval)
    if (flVal > 0)
        return (ULONG)_maxval;
    
    return (ULONG)_minval;
} // PB_Real2IntSafe

// -----------------------------------------------------------------------------------------------------------------
// Internal stuff for fixed-to-float conversions
// -----------------------------------------------------------------------------------------------------------------
#define fix_shift	16

const LONG		sfixed1			= (1)<<fix_shift;
const LONG		sfixhalf		= sfixed1>>1;
const float	        Real2fix		= (1)<<fix_shift;
const float	        fix2Real		= 1/((1)<<fix_shift);
const LONG		sfixedUnder1	= sfixed1 - 1;
const LONG		sfixedOver1		= ~sfixedUnder1;


inline ULONG PB_Real2Fix(float flVal)
{
    return (ULONG)(flVal * Real2fix);
}

// Convert a float to fixed point and forces it to
// stay within a reasonable range. 
//
// TODO: this is inherently buggy.
inline ULONG PB_Real2FixSafe(float flVal)
{
    // Check that the magnitude is reasonable
    if (fabs(flVal) < _maxval)
        return (ULONG)(flVal * Real2fix);

    // Clamp to range (minval, maxval)
    // Modified by the fixed point scaling factor
    if (flVal > 0)
        return (ULONG)(_maxval * Real2fix);
    
    return (ULONG)(_minval * Real2fix);
} // PB_Real2FixSafe

// Force a float to be within a reasonable range
// for the fixed point math
inline void PB_OutOfBounds(float *pflVal)
{
    // Check that the magnitude is reasonable
    if (fabs(*pflVal) < _maxval)
        return;

    // Clamp to range (minval, maxval)
    // Modified by 
    if (*pflVal > 0)
        *pflVal = (float)_maxval;
    else 
        *pflVal = (float)_minval;
    return;
}; // PB_OutOfBounds

#define ff(a)			((a)<<fix_shift)
#define uff(a)			((a)>>fix_shift)
#define uffr(a)			((a+sfixhalf)>>fix_shift)
#define	fl(a)			(PB_Real2Fix (a))
#define ufl(a)			(((dfloat)(a))*fix2float)
#define FIX_FLOOR(a)	        ((a)&sfixedOver1)
#define FIX_CEIL(a)		FIX_FLOOR((a)+sfixed1)
#define _fixhalf                (1<<(fix_shift -1)) // .5
#define	roundfix2int(a)		LONG(((a)+_fixhalf)>>fix_shift)


#endif //for entire file
//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\msft.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

!ENDIF

ROOT=$(SUBPROJROOT:\src\dxt\msft=)

# IE's common.inc says to treat level 4 warnings as errors.  We wish.

WARNING_LEVEL=W3


!include $(ROOT)\common.inc


USE_ATL=1
ATL_VER=21  


INCLUDES =                    \
    $(INCLUDES);              \
    $(SUBPROJROOT)\inc;       \
    $(SUBPROJROOT)\src;       \
    $(ROOT)\src\core\include; \
    $(SHELL_INC_PATH)

C_DEFINES=$(C_DEFINES) -D_WINDLL -D_WINDOWS

CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
    atlbase.h       \
    atlcom.h        \
    atlctl.h        \
    fp.h            \
    folders.h       \
    macapi.h        \
    macheaders.c    \
    macname1.h      \
    macname2.h      \
    macocidl.h      \
    macpub.h        \
    pictutils.h     \
    qdoffscreen.h   \
    rpcerr.h        \
    rpcmac.h        \
    stdafx.h        \
    timer.h         \
    thunk.h         \
    winwlm.h        \
    x86_prefix.h    \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\rsrc\makefile.inc ===
#
# makefile.inc
#
#     Makefile dependency rules for special files not
# automagically processed by BUILD.EXE.
#

dxtrans.rc :                    \
    $(SDK_LIB_PATH)\dxtrans.tlb \
    dxraster.rgs                \
    dxsurf.rgs                  \
    dxtfilter.rgs               \
    dxtfilterbehavior.rgs       \
    dxtfiltercollection.rgs     \
    dxtfilterfactory.rgs        \
    geo2d.rgs                   \
    gradient.rgs                \
    label.rgs                   \
    scale.rgs                   \
    surfmod.rgs                 \
    taskmgr.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\core\mscanner\_tarray.h ===
//************************************************************
//
// FileName:	    _tarray.cpp
//
// Created:	    1996
//
// Author:	    Sree Kotay
// 
// Abstract:	    template-based array class
//
// Change History:
// ??/??/97 sree kotay  Wrote sub-pixel AA scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
// 08/07/99 a-matcal    Replaced calls to callod with malloc and ZeroMemory to
//                      use IE crt.
//
// Copyright 1998, Microsoft
//************************************************************

#ifndef _TArray_H // for entire file
#define _TArray_H

// =================================================================================================================
// TArray
// =================================================================================================================
template <class T> class TArray 
{
protected:
    // =================================================================================================================
    // Data
    // =================================================================================================================
    BYTE* m_pbBaseAddress;
    ULONG m_cElem;
    ULONG m_cElemSpace;
    ULONG m_cbElemSize;
    ULONG m_cElemGrowSize;
    bool m_fZeroMem;
    
    // =================================================================================================================
    // Array Data
    // =================================================================================================================
    T* m_ptPtr;														

    enum		
    {
        eDefaultGrowSize	= 32
    };
    
   
    // =================================================================================================================
    // Update Array Pointer
    // =================================================================================================================	
    void UpdateDataPointer()	 	
    {
        m_ptPtr=(T*)BaseAddress();
    } // UpdateDataPointer

    void ZeroInternals()
    {
        m_pbBaseAddress	= 0;
        m_cElem	= 0;
        m_cElemSpace = 0;
        m_fZeroMem = false;
        m_cbElemSize = 0;
        m_cElemGrowSize = 0;
        m_ptPtr	= 0;
        DASSERT(IsValid());
    } // UpdateDataPointer
    
public:
    // =================================================================================================================
    // Construction/Destruction
    // =================================================================================================================
    TArray(ULONG initialGrowSize = eDefaultGrowSize,  bool fZeroMem = true);			

    ~TArray();
    
    // =================================================================================================================
    // Allocation/Deallocation functions
    // =================================================================================================================
    bool ArrayAlloc(ULONG initialCount, ULONG initialSpace, ULONG initialGrowSize, bool fZeroMem);
    void ArrayFree();
    
    // =================================================================================================================
    // Validity
    // =================================================================================================================	
    inline bool IsValid() const
    {
        // CONSIDER: are there more checks that we can do in debug?
#ifdef DEBUG 
        if (m_pbBaseAddress)
        {
            DASSERT(m_cElem <= m_cElemSpace);
            // CONSIDER: add a check to see if 
            // unused memory is zero-ed for the fZeroMem case
        }
        else
        {
            DASSERT(m_cElem == 0);
            DASSERT(m_cElemSpace == 0);
        }
        DASSERT(m_cElem < 0x10000000);
        DASSERT(m_cElemSpace < 0x10000000);
#endif // DEBUG
        return true;
    } // IsValid
    
    // =================================================================================================================
    // Member Functions
    // =================================================================================================================	
    inline BYTE *BaseAddress()
    {
        DASSERT(IsValid());
        return m_pbBaseAddress;
    } // BaseAddress

    inline ULONG GetElemSize()
    {
        DASSERT(IsValid());
        return m_cbElemSize;
    } // GetElemSize
    
    inline bool	GetZeroMem()
    {
        DASSERT(IsValid());
        return m_fZeroMem;
    } // GetZeroMem    
    
    inline ULONG GetElemSpace()						
    {
        DASSERT(IsValid());
        return m_cElemSpace;
    } // GetElemSpace

    bool SetElemSpace(ULONG n);
    
    inline ULONG GetElemCount()
    {
        DASSERT(IsValid());
        return m_cElem;
    } // GetElemCount

    inline bool	SetElemCount(ULONG n);
    inline bool	AddElemCount(ULONG n);
    
    // =================================================================================================================
    // Access Methods
    // =================================================================================================================
    inline T* Pointer(ULONG i)				
    {
        DASSERT(IsValid());
        DASSERT(i < GetElemCount());
        return m_ptPtr + i;
    } // Pointer					
    
    inline T& operator[](ULONG i)
    {
        DASSERT(IsValid());				
        DASSERT(i < GetElemCount());			
        return m_ptPtr[i];
    } // Pointer					
    
    // =================================================================================================================
    // Array Functions
    // =================================================================================================================	
    inline bool SetElem(ULONG index, const T*  data);
    inline bool GetElem(ULONG index, T*  data);
    
    inline bool AddElem(const T*  data);										
    
    inline bool InsertElem(ULONG index, const T& data);
    
    inline bool CompactArray()
    {
        DASSERT(IsValid());
        return SetElemSpace(GetElemCount());
        DASSERT(IsValid());
    } // CompactArray

    inline bool ResetArray()						
    {
        DASSERT(IsValid());
        return SetElemCount(0);
        DASSERT(IsValid());
    } // CompactArray
    
}; // TArray

// =================================================================================================================
// =================================================================================================================
//
// 		Implementation of TArray -
// 		Done in the header because many compilers 
//		require template implementations this way
//
// =================================================================================================================
// =================================================================================================================

// =================================================================================================================
// Construction
// =================================================================================================================

// Note that this function has default parameters specified in the class decl.
template<class T> TArray<T>::TArray(ULONG initialGrowSize /* = eDefaultGrowSize */, 
        bool fZeroMem /* = true */)
{
    ZeroInternals ();
    
    // This doesn't really alloc anything because we pass zero as initial size
    if  (!ArrayAlloc (0 /* count */ , 0 /* space */, initialGrowSize, fZeroMem))	
    {
        DASSERT(0); 
        return;
    }
    DASSERT(IsValid());
} // TArray

// =================================================================================================================
// Destruction
// =================================================================================================================
template<class T> TArray<T>::~TArray ()
{
    DASSERT(IsValid());
    ArrayFree();
    DASSERT(IsValid());
} // ~TArray

// =================================================================================================================
// ArrayAlloc
// =================================================================================================================
template<class T> bool TArray<T>::ArrayAlloc (ULONG initialCount, ULONG initialSpace,
        ULONG initialGrowSize, bool fZeroMem)
{
    DASSERT(IsValid());
    ZeroInternals ();
    
    if (initialCount > initialSpace)		
    {
        DASSERT(0); 
        return false;
    }
    
    m_cbElemSize = sizeof (T);
    m_cElemGrowSize = initialGrowSize;
    m_fZeroMem = fZeroMem;
    
    if (!SetElemSpace (initialSpace))		
    {
        DASSERT(0); 
        return false;
    }
    if (!SetElemCount(initialCount))		
    {
        DASSERT(0); 
        return false;
    }
    
    DASSERT(IsValid());
    return true;
} // ArrayAlloc

// =================================================================================================================
// ArrayFree
// =================================================================================================================
template<class T> void TArray<T>::ArrayFree (void)
{
    DASSERT(IsValid());
    SetElemSpace(0);
    DASSERT(IsValid());
} // ArrayFree

// =================================================================================================================
// SetElemSpace
// =================================================================================================================
template<class T> bool TArray<T>::SetElemSpace(ULONG n)
{
    DASSERT(IsValid());
    DASSERT(GetElemSize()>0);	
    
    if (n == GetElemSpace())	
        return true;
    
    // set count
    m_cElem = min(n, m_cElem); //in case the new space is less than the count

    ULONG cbNewSize = 0;

    if (n)
    {
        cbNewSize = GetElemSize() * n;
    }

    BYTE *pbNewAddr;
    
    // try to resize base address
    if (cbNewSize)
    {
        if (!BaseAddress()) 
        {
            if (m_fZeroMem)
            {
                pbNewAddr = (BYTE *)::malloc(cbNewSize);

                if (pbNewAddr != NULL)
                {
                    ZeroMemory(pbNewAddr, cbNewSize);
                }
            }
            else
            {
                pbNewAddr = (BYTE *)::malloc(cbNewSize);
            }
        }
        else				
        {
            pbNewAddr = (BYTE *)::realloc(BaseAddress(), cbNewSize);

            // We may need to zero-out the new portion of
            // the allocation
            if (pbNewAddr && m_fZeroMem)
            {
                // Compute how many bytes we used to have
                ULONG cbOld = GetElemSpace()*GetElemSize();

                // Zero out starting at the first new byte, and continuing
                // for the rest of the allocation
                ZeroMemory(pbNewAddr + cbOld, cbNewSize - cbOld);
            }
        }
        
        if (pbNewAddr == NULL)		
        {
            DASSERT(0); 
            return false;
        }
    }
    else
    {
        if (BaseAddress())
            ::free(BaseAddress());
        pbNewAddr = NULL;
    }
    
    //set new pointer values and sizes
    m_pbBaseAddress = pbNewAddr;
    m_cElemSpace = n;
    
    UpdateDataPointer();
    DASSERT(IsValid());
    return true;
} // SetElemSpace

// =================================================================================================================
// SetElemCount
// =================================================================================================================
template<class T> bool TArray<T>::SetElemCount(ULONG n)
{
    DASSERT(IsValid());
    DASSERT(n >= 0);
    
    if (n > GetElemSpace())	
    {
        LONG space = n;
        if (m_cElemGrowSize)
            space = LONG((n + m_cElemGrowSize - 1)/m_cElemGrowSize) * m_cElemGrowSize;

        if (!SetElemSpace(space))	
        {
            DASSERT(0); 
            return false;
        }
    }
    
    m_cElem = n;
    
    DASSERT(IsValid());
    return true;
} // SetElemCount

// =================================================================================================================
// AddElemCount
// =================================================================================================================
template<class T> bool TArray<T>::AddElemCount(ULONG n)
{
    DASSERT(IsValid());
    return SelElemCount(n + GetElemCount());
} // AddElemCount

// =================================================================================================================
// SetElem
// =================================================================================================================
template<class T> bool TArray<T>::SetElem(ULONG index, const T*  data)
{
    DASSERT(IsValid());
    DASSERT(data);
    DASSERT(BaseAddress());
    
    DASSERT(index < GetElemCount());
    
    (*this)[index]	= *data;
    
    DASSERT(IsValid());
    return true;
} // SetElem

// =================================================================================================================
// GetElem
// =================================================================================================================
template<class T> bool TArray<T>::GetElem(ULONG index, T*  data)
{
    DASSERT(IsValid());
    DASSERT(data);
    DASSERT(BaseAddress());
    DASSERT(index < GetElemCount());
    
    *data	= (*this)[index];

    DASSERT(IsValid());
    return true;
} // GetElem

// =================================================================================================================
// AddElem
// =================================================================================================================
template<class T> inline bool TArray<T>::AddElem(const T*  data)							
{
    DASSERT(IsValid());
    DASSERT(data);
    
    if (!SetElemCount(GetElemCount() + 1))
    {
        DASSERT(0); 
        return false;
    }				
    
    m_ptPtr[GetElemCount() - 1]	= *data;										
    DASSERT(IsValid());
    return true;									
} // AddElem

// =================================================================================================================
// InsertElem
// =================================================================================================================
template<class T> bool TArray<T>::InsertElem(ULONG index, const T& data)
{
    DASSERT(IsValid());
    
    ULONG cElemCurrent = GetElemCount();
    
    /*
    we allow an Insert to the end (ie if GetElemCount == 4 (indexes 0-3) and then
    we call InsertElem(4, data) this will work even though the index 4 doesnt yet exist
    
      BECAUSE - if we have 0 elements then there is no baseAddress - but we want to be 
      able to insert to an empty list!!
    */
    
    if (index > cElemCurrent)
    {
        // if we allow them to grow the array automatically by inserting past the end of the array??
        if (AddElemCount(index - cElemCurrent + 1))	
            return SetElem(index, data);
        return false;
    }
    else if (AddElemCount(1))
    {
        ULONC cElemToMove = cElemCurrent - index;
        
        ULONG copySize		= GetElemSize() * cElemToMove;
        
        // since regions overlaps we must move memory 
        if (copySize)
        {
            ULONG srcOffset	= GetElemSize() * index;
            ULONG dstOffset	= GetElemSize() * (index + 1);
            
            DASSERT(BaseAddress());
            
            ::memmove(BaseAddress() + dstOffset, BaseAddress() + srcOffset, copySize);
        }
        
        SetElem(index, data);
        
        return true;
    }
    
    DASSERT(0);
    
    return false;
} // InsertElem

#endif // for entire file
//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\dll\debughelpers.c ===
//------------------------------------------------------------------------------
//
//  File:       debughelpers.c
//
//  Overview:   Helper functions to use during debugging.
//
//  History:
//  2000/01/26  mcalkins    Created.
//
//------------------------------------------------------------------------------

#if DBG == 1
#ifndef __DEBUGHELPERS_H_
#define __DEBUGHELPERS_H_

#include "debughelpers.h"


//+-----------------------------------------------------------------------------
//
//  Function:   EnsureDebugHelpers
//
//------------------------------------------------------------------------------
void EnsureDebugHelpers()
{
    showme(NULL);
}
//  Function:   EnsureDebugHelpers


//+-----------------------------------------------------------------------------
//
//  Function:   showme2
//
//------------------------------------------------------------------------------
void showme2(IDirectDrawSurface * surf, RECT * prc)
{
    HRESULT hr      = S_OK;
    HDC     srcDC;
    HDC     destDC  = GetDC(NULL);
    RECT    dr;
    RECT    sr;
    RECT    rcFrame;

    HBRUSH          hbrRed = NULL;
    HBRUSH          hbrGreen = NULL;
    LOGBRUSH        logbrush;
    DDSURFACEDESC   ddsd;

    ZeroMemory(&ddsd, sizeof(ddsd));

    hr = surf->GetDC(&srcDC);

    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;

    hr = surf->GetSurfaceDesc(&ddsd);

    SetRect(&sr, 0, 0, ddsd.dwWidth, ddsd.dwHeight);
    SetRect(&dr, 1, 1, ddsd.dwWidth + 1, ddsd.dwHeight + 1);
    SetRect(&rcFrame, 0, 0, ddsd.dwWidth + 2, ddsd.dwHeight + 2);
    
    StretchBlt(destDC,
               dr.left,
               dr.top,
               dr.right - dr.left,
               dr.bottom - dr.top,
               srcDC,
               sr.left,
               sr.top,
               sr.right - sr.left,
               sr.bottom - sr.top,
               SRCCOPY);

    logbrush.lbStyle    = BS_SOLID;
    logbrush.lbColor    = 0x000000FF;   // Red

    hbrRed = CreateBrushIndirect(&logbrush);
    if (hbrRed)
    {
        logbrush.lbColor    = 0x0000FF00;   // Green

        FrameRect(destDC, &rcFrame, hbrRed);
        
        if (prc != NULL)
        {
            hbrGreen = CreateBrushIndirect(&logbrush);
            if (hbrGreen)
            {
                RECT    rcBounds = *prc;
                rcBounds.right += 2;
                rcBounds.bottom += 2;

                FrameRect(destDC, &rcBounds, hbrGreen);
                DeleteObject(hbrGreen);
            }
        }
        DeleteObject(hbrRed);
    }

    hr = surf->ReleaseDC(srcDC);
    
    ReleaseDC(NULL, destDC);    
}
//  Function:   showme2


//+-----------------------------------------------------------------------------
//
//  Function:   showme
//
//------------------------------------------------------------------------------
void * showme(IUnknown * pUnk)
{
    HRESULT hr = S_OK;
    RECT    rc;

    CComPtr<IDirectDrawSurface> spDDSurf;
    CComPtr<IDXSurface>         spDXSurf;

    if (NULL == pUnk)
    {
        goto done;
    }

    hr = pUnk->QueryInterface(IID_IDirectDrawSurface, (void **)&spDDSurf);

    if (FAILED(hr))
    {
        hr = pUnk->QueryInterface(IID_IDXSurface, (void **)&spDXSurf);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDXSurf->GetDirectDrawSurface(IID_IDirectDrawSurface,
                                            (void **)&spDDSurf);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    /*
    if (pbnds)
    {
        pbnds->GetXYRect(rc);
    }
    */

    showme2(spDDSurf, NULL);

done:

    return pUnk;
}
//  Function:   showme

#endif // __DEBUGHELPERS_H_
#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\dll\objmap1.cpp ===
//***************************************************************************
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:            ObjMap1.cpp
//
// Created:             12/10/98
//
// Author:              PaulNash
//
// Description:         Object Map helper file (part 1). This file
//                      contains a portion of the DXTMSFT.DLL ATL object
//                      map.  It contains the entries for 15 objects.
//
// History
//
// 12/10/98 PaulNash    Created this file.
//
//***************************************************************************

#include "stdafx.h"
#include "resource.h"
#include <DXTMsft.h>

#include "ColorAdj.h"
#include "Composit.h"
#include "dxtwipe.h"
#include "convolve.h"
#include "CrBlur.h"

#include "Fade.h"
#include "Image.h"
#include "Pixelate.h"
#include "GradDsp.h"
#include "Iris.h"

#include "Barn.h"
#include "Blinds.h"
#include "RWipe.h"

// Start the first section of our OBJECT_MAP
//
_ATL_OBJMAP_ENTRY ObjectMap1[] = {
    OBJECT_ENTRY(CLSID_DXLUTBuilder,        CDXLUTBuilder       )
    OBJECT_ENTRY(CLSID_DXTComposite,        CDXTComposite       )
    OBJECT_ENTRY(CLSID_DXTWipe,             CDXTWipe            )
    OBJECT_ENTRY(CLSID_DXTGradientWipe,     CDXTGradientWipe    )
    OBJECT_ENTRY(CLSID_DXTConvolution,      CDXConvolution      )

    OBJECT_ENTRY(CLSID_CrBlur,              CCrBlur             )
    OBJECT_ENTRY(CLSID_CrEmboss,            CCrEmboss           )
    OBJECT_ENTRY(CLSID_CrEngrave,           CCrEngrave          )
    OBJECT_ENTRY(CLSID_DXFade,              CFade               )
    OBJECT_ENTRY(CLSID_BasicImageEffects,   CImage              )
    
    OBJECT_ENTRY(CLSID_Pixelate,            CPixelate           )
    OBJECT_ENTRY(CLSID_DXTGradientD,        CDXTGradientD       )
    OBJECT_ENTRY(CLSID_CrIris,              CDXTIris            )
    OBJECT_ENTRY(CLSID_DXTIris,             CDXTIrisOpt         )
    OBJECT_ENTRY(CLSID_CrRadialWipe,        CDXTRadialWipe      )

    OBJECT_ENTRY(CLSID_DXTRadialWipe,       CDXTRadialWipeOpt   )
    OBJECT_ENTRY(CLSID_CrBarn,              CDXTBarn            )
    OBJECT_ENTRY(CLSID_DXTBarn,             CDXTBarnOpt         )
    OBJECT_ENTRY(CLSID_CrBlinds,            CDXTBlinds          )
    OBJECT_ENTRY(CLSID_DXTBlinds,           CDXTBlindsOpt       )
};

int g_cObjs1 = sizeof(ObjectMap1) / sizeof(ObjectMap1[0]);

////////////////////////////////////////////////////
// End Of File
////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\dll\dxtmsft.cpp ===
// DXTMsft.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//          To build a separate proxy/stub DLL, 
//          run nmake -f DXTMsftps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <DXTMsft.h>

#ifdef _DEBUG
#include <crtdbg.h>
#endif


/////////////////////////////////////////////////////////////////////////////
// Global Variables...

CDXMMXInfo  g_MMXDetector;       // Determines the presence of MMX instructions.

CComModule  _Module;


//+-----------------------------------------------------------------------------
//
//  This section was added when moving code over to the Trident tree.  The
//  following global variables and functions are required to link properly.
//
//------------------------------------------------------------------------------

// lint !e509
// g_hProcessHeap is set by the CRT in dllcrt0.c

EXTERN_C HANDLE     g_hProcessHeap      = NULL;
LCID                g_lcidUserDefault   = 0;
DWORD               g_dwFALSE           = 0;


///////////////////////////////////////////////////////////////////
//
//  LOOKING FOR BEGIN_OBJECT_MAP()????
//
//   Here's the deal: Because ATL is based on templates, the classes
// that implement our objects have a lot of templatized code that must
// all be expanded by the compiler. This takes a lot of memory and time
// for the compiler to do, and it can get to the point where build
// machines run out of swap space. So the solution is to create an
// OBJECT_MAP structure dynamically. It's not hard, it's just an array
// of structures.
//
// So what we do is split the workload of expanding all these templates
// across multiple files by defining a "fragment" of the OBJECT_MAP
// in each file. Then we reference these global tables and in the final
// code, when we get called for DLL_PROCESS_ATTACH, we allocate an array
// big enough to hold all the fragments, and then we copy the OBJECT_MAP
// entries into it.  Then we just pass that pointer to ATL and everyone
// is happy.
//
// The core type for the OBJECT_MAP is _ATL_OBJMAP_ENTRY and the map
// is just an array of them. I use the END_OBJECT_MAP macro on the last
// one because that macro *does* add special entries. See files objmap*.cpp
// for the object map fragments.
//
///////////////////////////////////////////////////////////////////

// Reference the ATL object map data objects which are external to this
// file. They're external to prevent template code expansion from
// happening all in one file and swamping the compiler -- the intermediate
// file size of template expansion and the memory requirements of the
// compiler are quite huge.
extern _ATL_OBJMAP_ENTRY ObjectMap1[];
extern _ATL_OBJMAP_ENTRY ObjectMap2[];

// These variables tell us how many entries there are in each of the
// corresponding ObjectMap arrays defined above.
extern int g_cObjs1, g_cObjs2;

// This global pointer will hold the full object
// map for this instance of the DLL.
static _ATL_OBJMAP_ENTRY *g_pObjectMap = NULL;

///////////////////////////////////////
// InitGlobalObjectMap
//
BOOL InitGlobalObjectMap(void)
{
    // We should be getting here only because a new DLL data segment
    // exists for each process.
    _ASSERT(NULL == g_pObjectMap);

    // Assume the global object map was already successfully created.
    if (NULL != g_pObjectMap)
        return TRUE;

    // Allocate one big object map to give to ATL
    g_pObjectMap = new _ATL_OBJMAP_ENTRY[g_cObjs1 + g_cObjs2];
    if (NULL == g_pObjectMap)
        return FALSE;

    // Now copy the object map fragments into one complete
    // structure, and then we'll give this structure to ATL.
    CopyMemory(g_pObjectMap,
                ObjectMap1, sizeof(ObjectMap1[0]) * g_cObjs1);
    CopyMemory(g_pObjectMap + g_cObjs1,
                ObjectMap2, sizeof(ObjectMap2[0]) * g_cObjs2);

    return TRUE;
} // InitGlobalObjectMap

///////////////////////////////////////
// DeleteGlobalObjectMap
//
void DeleteGlobalObjectMap(void)
{
    if (NULL != g_pObjectMap)
    {
        delete[] g_pObjectMap;
        g_pObjectMap = NULL;
    }
} // DeleteGlobalObjectMap

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        if (!InitGlobalObjectMap())
            return FALSE;

        // If the above call returned success, then the object map BETTER be there...
        _ASSERT(NULL != g_pObjectMap);

        _Module.Init(g_pObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

#if DBG == 1
        // Turn on memory leak checking.

        int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag(tmpFlag);

        // Make sure debug helpers are linked in.

        EnsureDebugHelpers();
#endif

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        DeleteGlobalObjectMap();
    }
    return TRUE;    // ok
} // DllMain

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
} // DllGetClassObject


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
} // DllRegisterServer


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();

#if(_ATL_VER < 0x0300)
    ::UnRegisterTypeLib(LIBID_DXTMSFTLib, 
                        DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER, 
                        LOCALE_NEUTRAL, SYS_WIN32);
#endif

    return S_OK;
} // DllUnregisterServer


//
//
//
STDAPI DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if (i >= (g_cObjs1 + g_cObjs2) - 1)
    
    {
        return S_FALSE;
    }

    *pclsid = *(g_pObjectMap[i].pclsid);
    return _Module.GetClassObject(*pclsid, IID_IUnknown, (LPVOID*)ppUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\dll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

// Since there are multiple directories that need to have stdafx.h, we put all
// the stuff in stdafx_common.h to have the actual code in only one place.

#include "stdafx_common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dxtguid.c>
#include <atlctl.cpp>
#include <atlwin.cpp>
#include <dtbase.cpp>

#include "debughelpers.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\inc\debughelpers.h ===
//------------------------------------------------------------------------------
//
//  File:       debughelpers.h
//
//  Overview:   Helper functions to use during debugging.
//
//  History:
//  2000/01/26  mcalkins    Created.
//
//------------------------------------------------------------------------------

#if DBG == 1

void    EnsureDebugHelpers();
void    showme2(IDirectDrawSurface * surf, RECT * prc);
void *  showme(IUnknown * pUnk);

#ifdef _X86_
#define DASSERT(x)      {if (!(x)) _asm {int 3} }
#else  // !_X86_
#define DASSERT(x)      {if (!(x)) DebugBreak(); }
#endif // !_X86_

#else  // DBG != 1

#define DASSERT(x)

#endif // DBG != 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\dll\objmap2.cpp ===
//***************************************************************************
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:            ObjMap2.cpp
//
// Created:             12/10/98
//
// Author:              PaulNash
//
// Description:         Object Map helper file (part 2). This file
//                      contains a portion of the DXTMSFT.DLL ATL object
//                      map.  It contains the entries for 15 objects.
//
// History
//
// 12/10/98 PaulNash    Created this file.
// 08/09/99 a-matcal    Removed MetaCreations transforms for move to Trident
//                      tree.  Moved CSS effects from objmap4.cpp to here.
//
//***************************************************************************

#include "stdafx.h"
#include "resource.h"
#include <dxtmsft.h>

#include "slide.h"
#include "inset.h"
#include "spiral.h"
#include "stretch.h"
#include "wheel.h"

#include "zigzag.h"
#include "chroma.h"
#include "dropshadow.h"
#include "glow.h"
#include "shadow.h"

#include "alpha.h"
#include "wave.h"
#include "light.h"
#include "checkerboard.h"
#include "revealtrans.h"

// TODO: This is the point to start a new objmapX.cpp file, but I'm just not in
//       the mood.

#include "maskfilter.h"
#include "redirect.h"
#include "alphaimageloader.h"
#include "randomdissolve.h"
#include "randombars.h"

#include "strips.h"
#include "motionblur.h"
#include "matrix.h"
#include "colormanagement.h"


_ATL_OBJMAP_ENTRY ObjectMap2[] = {
    OBJECT_ENTRY(CLSID_CrSlide,             CDXTSlide               )
    OBJECT_ENTRY(CLSID_DXTSlide,            CDXTSlideOpt            )
    OBJECT_ENTRY(CLSID_CrInset,             CDXTInset               )
    OBJECT_ENTRY(CLSID_DXTInset,            CDXTInsetOpt            )
    OBJECT_ENTRY(CLSID_CrSpiral,            CDXTSpiral              )

    OBJECT_ENTRY(CLSID_DXTSpiral,           CDXTSpiralOpt           )
    OBJECT_ENTRY(CLSID_CrStretch,           CDXTStretch             )
    OBJECT_ENTRY(CLSID_DXTStretch,          CDXTStretchOpt          )
    OBJECT_ENTRY(CLSID_CrWheel,             CWheel                  )
    OBJECT_ENTRY(CLSID_CrZigzag,            CDXTZigZag              )

    OBJECT_ENTRY(CLSID_DXTZigzag,           CDXTZigZagOpt           )
    OBJECT_ENTRY(CLSID_DXTChroma,           CChroma                 )
    OBJECT_ENTRY(CLSID_DXTDropShadow,       CDropShadow             )
    OBJECT_ENTRY(CLSID_DXTGlow,             CGlow                   )
    OBJECT_ENTRY(CLSID_DXTShadow,           CShadow                 )

    OBJECT_ENTRY(CLSID_DXTAlpha,            CAlpha                  )
    OBJECT_ENTRY(CLSID_DXTWave,             CWave                   )
    OBJECT_ENTRY(CLSID_DXTRevealTrans,      CDXTRevealTrans         )
    OBJECT_ENTRY(CLSID_DXTCheckerBoard,     CDXTCheckerBoard        )
    OBJECT_ENTRY(CLSID_DXTLight,            CLight                  )

    OBJECT_ENTRY(CLSID_DXTMaskFilter,       CDXTMaskFilter          )
    OBJECT_ENTRY(CLSID_DXTRedirect,         CDXTRedirect            )
    OBJECT_ENTRY(CLSID_DXTAlphaImageLoader, CDXTAlphaImageLoader    )
    OBJECT_ENTRY(CLSID_DXTRandomDissolve,   CDXTRandomDissolve      )
    OBJECT_ENTRY(CLSID_DXTRandomBars,       CDXTRandomBars          )

    OBJECT_ENTRY(CLSID_DXTStrips,           CDXTStrips              )
    OBJECT_ENTRY(CLSID_DXTMotionBlur,       CDXTMotionBlur          )
    OBJECT_ENTRY(CLSID_DXTMatrix,           CDXTMatrix              )
    OBJECT_ENTRY(CLSID_DXTICMFilter,        CDXTICMFilter           )

END_OBJECT_MAP()

int g_cObjs2 = sizeof(ObjectMap2) / sizeof(ObjectMap2[0]);

////////////////////////////////////////////////////
// End Of File
////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\inc\stdafx_common.h ===
// stdafx.h : include file for standard system include files,
//            or project specific include files that are used frequently,
//            but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_APARTMENT_THREADED

// Added 1999/09/22 by a-matcal to support UNICODE on win95.
#include <w95wraps.h>


#define ATLTRACE 1 ? (void)0 : AtlTrace
#include <atlbase.h>
#pragma intrinsic(memset, memcpy)

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

// Added 1999/09/22 by a-matcal to support UNICODE on win95.
#include <shlwapi.h>
#include <shlwapip.h>

// Use Trident debug stuff.
#define INCMSG(X)

#include <f3debug.h>

#include <ddraw.h>
#include <dxtransp.h>
#include <dtbase.h>
#include <dxtmsft.h>
#include <mshtml.h>

#include "debughelpers.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

// When we moved the code over to trident, all the _ASSERTs stopped working, so
// we'll use Assert instead.

#undef _ASSERT
#define _ASSERT(x) Assert(x);

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately
// before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\rsrc\makefile.inc ===
#
# makefile.inc
#
#     Makefile dependency rules for special files not
# automagically processed by BUILD.EXE.
#

dxtmsft.rc : \
    $(SDK_LIB_PATH)\dxtmsft.tlb \
    alpha.rgs               \
    alphaimageloader.rgs    \
    barn.rgs                \
    barnopt.rgs             \
    blinds.rgs              \
    blindsopt.rgs           \
    checkerboard.rgs        \
    chroma.rgs              \
    coloradj.rgs            \
    colormanagement.rgs     \
    composit.rgs            \
    convolve.rgs            \
    crblur.rgs              \
    cremboss.rgs            \
    crengrav.rgs            \
    dropshadow.rgs          \
    dxtwipe.rgs             \
    fade.rgs                \
    glow.rgs                \
    graddsp.rgs             \
    gradientwipe.rgs        \
    image.rgs               \
    iris.rgs                \
    irisopt.rgs             \
    inset.rgs               \
    insetopt.rgs            \
    light.rgs               \
    matrix.rgs              \
    maskfilter.rgs          \
    motionblur.rgs          \
    pixelate.rgs            \
    randombars.rgs          \
    randomdissolve.rgs      \
    revealtrans.rgs         \
    rwipe.rgs               \
    rwipeopt.rgs            \
    shadow.rgs              \
    slide.rgs               \
    slideopt.rgs            \
    spiral.rgs              \
    spiralopt.rgs           \
    stretch.rgs             \
    stretchopt.rgs          \
    strips.rgs              \
    wave.rgs                \
    wheel.rgs               \
    zigzag.rgs              \
    zigzagopt.rgs           \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DXTMsft.rc
//
#define IDS_PROJNAME                    100
#define IDS_TITLERipProp                101
#define IDS_HELPFILERipProp             102
#define IDS_DOCSTRINGRipProp            103
#define IDS_TITLEDisProp                104
#define IDS_HELPFILEDisProp             105
#define IDR_EXPLODE                     106
#define IDD_RIPPROP                     106
#define IDS_IDS_DOCSTRINGDisProp        106
#define IDR_RUFFLE                      107
#define IDR_HEIGHTFIELD                 108
#define IDR_FADE                        109
#define IDS_TITLEFadePP                 110
#define IDS_HELPFILEFadePP              111
#define IDS_DOCSTRINGFadePP             112
#define IDR_FADEPP                      113
#define IDD_FADEPP                      114
#define IDS_TITLEExplodeProp1           115
#define IDS_HELPFILEExplodeProp1        116
#define IDS_DOCSTRINGExplodeProp1       117
#define IDR_EXPLODEPROP1                118
#define IDD_EXPLODEPROP1                119
#define IDS_TITLERuffleProp             120
#define IDS_HELPFILERuffleProp          121
#define IDS_DOCSTRINGRuffleProp         122
#define IDR_RUFFLEPROP                  123
#define IDD_RUFFLEPROP                  124
#define IDR_IMAGE                       125
#define IDS_TITLEImagePP                126
#define IDS_HELPFILEImagePP             127
#define IDS_DOCSTRINGImagePP            128
#define IDR_IMAGEPP                     129
#define IDD_IMAGEPP                     130
#define IDR_DXTWIPEPP                   131
#define IDC_ORIGIN                      201
#define IDC_WAVELEN                     202
#define IDC_FADE_OVERLAP                202
#define IDC_DISSOLVE_SPEEDPT0           202
#define IDR_RIPPLE                      203
#define IDC_AMPLITUDE                   203
#define IDC_FADE_CENTER                 203
#define IDC_DISSOLVE_SPEEDPT2           203
#define IDC_NUMWAVES                    204
#define IDR_RIPPROP                     204
#define IDC_0                           204
#define IDC_DISSOLVE_SPEEDPT4           204
#define IDR_DISSOLVE                    205
#define IDC_MINSTEPS                    205
#define IDC_90                          205
#define IDC_DISSOLVE_SPEEDPT6           205
#define IDR_FLIP                        206
#define IDC_MAXSTEPS                    206
#define IDC_180                         206
#define IDC_DISSOLVE_SPEEDPT8           206
#define IDD_DISPROP                     207
#define IDC_270                         207
#define IDC_DISSOLVE_SPEEDPT1           207
#define IDR_DXBUFFERCACHE               208
#define IDC_CHECK_GREY                  208
#define IDC_DISSOLVE_SPEEDPT3           208
#define IDR_DXLUTBUILDER                209
#define IDC_CHECK_MIRROR                209
#define IDC_DISSOLVE_SPEEDPT5           209
#define IDR_DXTCOMPOSITE                210
#define IDC_OPACITY                     210
#define IDC_DISSOLVE_SPEEDPT7           210
#define IDR_DXTRESAMPLER                211
#define IDC_INVERT                      211
#define IDC_DISSOLVE_SPEEDPT9           211
#define IDR_DXTDLABEL                   212
#define IDC_XRAY                        212
#define IDR_DXTWIPE                     213
#define IDC_BLUR_ADD                    213
#define IDC_MAXBOX                      213
#define IDR_EXPLODEP                    214
#define IDC_BLUR_STRENGTH               214
#define IDC_BLUR_DIRECTION              216
#define IDC_BLUR                        217
#define IDC_MASK                        218
#define IDC_MASK_COLOR                  219
#define IDD_ExplodePROP                 220
#define IDC_GLOW                        220
#define IDS_TITLEExplodeProp            221
#define IDC_GLOW_STRENGTH               221
#define IDS_HELPFILEExplodeProp         222
#define IDC_GLOW_COLOR                  222
#define IDS_DOCSTRINGExplodeProp        223
#define IDC_SHADOW                      223
#define IDR_EXPLODEPROP                 224
#define IDC_SHADOW_COLOR                224
#define IDS_TITLEDXTWipePP              224
#define IDC_Explode_Tumble              225
#define IDC_SHADOW_DIRECTION            225
#define IDS_HELPFILEDXTWipePP           225
#define IDC_Explode_MaxRotations        226
#define IDC_GRADIENT_SIZE               226
#define IDS_DOCSTRINGDXTWipePP          226
#define IDC_Explode_FinalVelocity       227
#define IDC_LEFT                        227
#define IDC_HORIZONTAL                  227
#define IDC_Explode_PositionJump        228
#define IDC_RIGHT                       228
#define IDC_VERTICAL                    228
#define IDC_Explode_DecayTime           229
#define IDC_Ruffle_MaxRotations         232
#define IDR_DXTCONVOLUTION              233
#define IDR_CRBLUR                      234
#define IDB_BITMAP1                     235
#define IDR_PIXELATE                    236
#define IRD_PIXELPP                     237
#define IDD_PIXELPP                     238
#define IDS_TITLEPixelPP                240
#define IDS_HELPFILEPixelPP             241
#define IDS_TITLECrBlurPP               241
#define IDS_DOCSTRINGPixelPP            242
#define IDS_TITLEGradientPP             242
#define IDR_PIXELPP                     243
#define IDS_TITLELabelPP                243
#define IDD_DXTWIPEPP                   244
#define IDS_TITLEResamplPP              244
#define IDS_TITLECompositePP            245
#define IDD_RESAMPLEPP                  250
#define IDD_LABELPP                     251
#define IDD_CRBLURPP                    252
#define IDD_GRADIENTPP                  253
#define IDD_COMPOSITEPP                 254
#define IDD_CONVOLVEPP                  255
#define IDD_LUTBUILDPP                  256
#define IDR_DXTIRIS                     257
#define IDR_DXTBARN                     258
#define IDR_DXTBLINDS                   259
#define IDR_DXTRADIALWIPE               260
#define IDR_DXTSLIDE                    261
#define IDR_DROPSHADOW                  262
#define IDR_CHROMA                      263
#define IDR_DXTSTRETCH                  264
#define IDR_DXTINSET                    265
#define IDR_DXTSPIRAL                   266
#define IDR_DXTZIGZAG                   267
#define IDR_WHEEL                       268
#define IDR_SHATTER                     269
#define IDR_BLACKHOLE                   270
#define IDR_ROLL                        271
#define IDR_SPIN                        272
#define IDR_GLOW                        273
#define IDR_SHADOW                      274
#define IDR_ALPHA                       275
#define IDR_WAVE                        276
#define IDR_LIGHT                       277

#define IDC_FT_NEAREST                  300
#define IDC_FT_BILINEAR                 301
#define IDC_ROTATION                    302
#define IDC_SCALEX                      303
#define IDC_SCALEY                      304
#define IDC_TEXT_STRING                 305
#define IDC_LABEL_FG_A                  306
#define IDC_LABEL_FG_R                  307
#define IDC_LABEL_FG_G                  308
#define IDC_LABEL_FG_B                  309
#define IDC_LABEL_BG_A                  310
#define IDC_LABEL_BG_R                  311
#define IDC_LABEL_BG_G                  312
#define IDC_LABEL_BG_B                  313
#define IDC_LABEL_FONT                  314
#define IDC_CRBLUR_PIXELRADIUS          315
#define IDC_LABEL_TEXTURE               315
#define IDC_CRBLUR_SHADOW               316
#define IDC_EDIT2                       317
#define IDC_CRBLUR_OPACITY              317
#define IDC_CONV_SPREAD1                317
#define IDC_LABEL_YORG                  317
#define IDC_GRAD_WIDTH                  317
#define IDC_GRAD_HORIZ                  318
#define IDC_CRBLUR_MAXEFFPIXELRADIUS    318
#define IDC_GRAD_VERT                   319
#define IDC_GRAD_FG_A                   320
#define IDC_GRAD_START_A                320
#define IDC_GRAD_FG_R                   321
#define IDC_GRAD_START_R                321
#define IDC_GRAD_FG_G                   322
#define IDC_GRAD_START_G                322
#define IDC_GRAD_FG_B                   323
#define IDC_GRAD_START_B                323
#define IDC_GRAD_BG_A                   324
#define IDC_GRAD_END_A                  324
#define IDC_GRAD_BG_R                   325
#define IDC_GRAD_END_R                  325
#define IDC_GRAD_BG_G                   326
#define IDC_GRAD_END_G                  326
#define IDC_GRAD_BG_B                   327
#define IDC_GRAD_END_B                  327
#define IDC_COMP_CLEAR                  328
#define IDC_COMP_MIN                    329
#define IDC_COMP_MAX                    330
#define IDC_COMP_A                      331
#define IDC_COMP_A_OVER_B               332
#define IDC_COMP_A_IN_B                 333
#define IDC_COMP_A_OUT_B                334
#define IDC_COMP_A_ATOP_B               335
#define IDC_COMP_A_SUB_B                336
#define IDC_COMP_A_ADD_B                337
#define IDC_COMP_A_XOR_B                338
#define IDC_COMP_B                      339
#define IDC_COMP_B_OVER_A               340
#define IDC_COMP_B_IN_A                 341
#define IDC_COMP_B_OUT_A                342
#define IDC_COMP_B_ATOP_A               343
#define IDC_COMP_B_SUB_A                344
#define IDC_COMP_B_ADD_A                345
#define IDC_COMP_B_XOR_A                346
#define IDC_CONV_BLUR3X3                347
#define IDC_CONV_SHARPEN                348
#define IDC_CONV_ROB_HR                 349
#define IDC_CONV_ROB_HC                 350
#define IDC_CONV_PREW_HR                351
#define IDC_CONV_PREW_HC                352
#define IDC_CONV_SOB_HR                 353
#define IDC_CONV_SOB_HC                 354
#define IDC_CONV_PC_E                   355
#define IDC_CONV_PC_NE                  356
#define IDC_CONV_PC_N                   357
#define IDC_CONV_PC_NW                  358
#define IDC_CONV_PC_W                   359
#define IDC_CONV_PC_SW                  360
#define IDC_CONV_PC_S                   361
#define IDC_CONV_PC_SE                  362
#define IDC_CONV_KC_E                   363
#define IDC_CONV_KC_NE                  364
#define IDC_CONV_KC_N                   365
#define IDC_CONV_KC_NW                  366
#define IDC_CONV_KC_W                   367
#define IDC_CONV_KC_SW                  368
#define IDC_CONV_KC_S                   369
#define IDC_CONV_KC_SE                  370
#define IDC_CONV_CUSTOM                 371
#define IDC_CONV_GAUSS                  372
#define IDC_EDIT3                       373
#define IDC_CONV_SPREAD2                373
#define IDC_GLOW_A                      374
#define IDC_GLOW_R                      375
#define IDC_GLOW_G                      376
#define IDC_GLOW_B                      377
#define IDC_SHADOW_A                    378
#define IDC_HtField_Width               378
#define IDC_SHADOW_R                    379
#define IDC_HtField_Height              379
#define IDC_SHADOW_G                    380
#define IDC_HtField_Depth               380
#define IDC_SHADOW_B                    381
#define IDC_HtField_Samples             381
#define IDC_MASK_A                      382
#define IDC_MASK_R                      383
#define IDC_LABEL_XORG                  383
#define IDC_MASK_G                      384
#define IDC_MASK_B                      385
#define IDC_GRAD_HEIGHT                 385
#define IDC_GRAD_ASPECT                 386
#define IDR_CRBLURPP                    400
#define IDR_GRADIENTPP                  401
#define IDR_LABELPP                     402
#define IDR_RESAMPLEPP                  403
#define IDR_DXTGRADDSP                  404
#define IDR_CONVOLVEPP                  406
#define IDR_COMPOSITEPP                 407
#define IDR_GRADDSP                     408
#define IDC_Flip_Depth                  409
#define IDC_Flip_Height                 410
#define IDC_Flip_Width                  411
#define IDS_TITLEFlipProp               412
#define IDS_HELPFILEFlipProp            413
#define IDS_DOCSTRINGFlipProp           414
#define IDR_FLIPPROP                    415
#define IDD_FLIPPROP                    416
#define IDS_TITLEHtFieldProp            417
#define IDS_HELPFILEHtFieldProp         418
#define IDS_DOCSTRINGHtFieldProp        419
#define IDR_HTFIELDPROP                 420
#define IDD_HTFIELDPROP                 421
#define IDS_TITLEDisslvpp               422
#define IDS_HELPFILEDisslvpp            423
#define IDS_DOCSTRINGDisslvpp           424
#define IDR_DISSLVPP                    425
#define IDD_DISSLVPP                    426

#define IDC_BRIGHTNESS                  1002
#define IDC_CONTRAST                    1003
#define IDC_GAMMA                       1004
#define IDC_POSTERIZELEVELS             1005
#define IDC_THRESHOLD                   1006
#define IDC_INVERTTHRESHOLD             1007
#define IDC_REDBAL_L                    1008
#define IDC_REDBAL_M                    1009
#define IDC_REDBAL_H                    1010
#define IDC_REDBAL                      1011
#define IDC_GREENBAL_L                  1012
#define IDC_GREENBAL_M                  1013
#define IDC_GREENBAL_H                  1014
#define IDC_GREENBAL                    1015
#define IDC_BLUEBAL_L                   1016
#define IDC_BLUEBAL_M                   1017
#define IDC_BLUEBAL_H                   1018
#define IDC_BLUEBAL                     1019
#define IDC_REDBAL_VAL                  1020
#define IDC_CONTRAST_VAL                1021
#define IDC_BRIGHTNESS_VAL              1022
#define IDC_OPACITY_VAL                 1023
#define IDC_BLUEBAL_VAL                 1024
#define IDC_GREENBAL_VAL                1025
#define IDC_LUTOPORDER                  1026
#define IDC_BTN_OPUP                    1027
#define IDC_BTN_OPDOWN                  1028
#define IDC_RESET_BTN                   1031
#define IDR_CREMBOSS                    1032
#define IDR_CRENGRAVE                   1033

#define IDR_METARTG                     1034

#define IDR_TEXT3D                      1035

#define IDR_METABURNFILM                1036
#define IDR_METACENTERPEEL              1037
#define IDR_METACOLORFADE               1038
#define IDR_METAFLOWMOTION              1039
#define IDR_METAGRIDDLER                1040
#define IDR_METAGRIDDLER2               1041
#define IDR_METAJAWS                    1042
#define IDR_METALIGHTWIPE               1043
#define IDR_METALIQUID                  1044
#define IDR_METAPAGETURN                1045
#define IDR_METAPEELPIECE               1046
#define IDR_METAPEELSMALL               1047
#define IDR_METAPEELSPLIT               1048
#define IDR_METARADIALSCALEWIPE         1049
#define IDR_METARIPPLE                  1050
#define IDR_METAROLL                    1051
#define IDR_METATHRESHOLD               1052
#define IDR_METATWISTER                 1053
#define IDR_METAVACUUM                  1054
#define IDR_METAWATER                   1055
#define IDR_METAWHITEOUT                1056
#define IDR_METAWORMHOLE                1057

#define IDR_SHAPES                      1058
#define IDR_DXTCHECKERBOARD             1059
#define IDR_DXTREVEALTRANS              1060
#define IDR_DXTMASKFILTER               1061
#define IDR_DXTREDIRECT                 1062
#define IDR_DXTALPHAIMAGELOADER         1063
#define IDR_DXTRANDOMDISSOLVE           1064
#define IDR_DXTRANDOMBARS               1065
#define IDR_DXTSTRIPS                   1066
#define IDR_DXTIRISOPT                  1067
#define IDR_DXTBARNOPT                  1068
#define IDR_DXTBLINDSOPT                1069
#define IDR_DXTRADIALWIPEOPT            1070
#define IDR_DXTSLIDEOPT                 1071
#define IDR_DXTINSETOPT                 1072
#define IDR_DXTSPIRALOPT                1073
#define IDR_DXTZIGZAGOPT                1074
#define IDR_DXTSTRETCHOPT               1075
#define IDR_DXTGRADIENTWIPE             1076
#define IDR_DXTMOTIONBLUR               1077
#define IDR_DXTMATRIX                   1078
#define IDR_DXTICMFILTER                1079


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        264
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         387
#define _APS_NEXT_SYMED_VALUE           427
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\alphaimageloader.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  FileName:   alphaimageloader.h
//
//  Overview:   The alpha image loader is to be used as a filter on web pages
//  `           that would like to display images that contain per pixel alpha.
//             
//  Change History:
//  1999/09/23  a-matcal    Created.
//  1999/11/23  a-matcal    Added SizingMethod property.
//
//------------------------------------------------------------------------------

#ifndef __ALPHAIMAGELOADER_H_
#define __ALPHAIMAGELOADER_H_

#include "resource.h"   




class ATL_NO_VTABLE CDXTAlphaImageLoader : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTAlphaImageLoader, &CLSID_DXTAlphaImageLoader>,
    public IDispatchImpl<IDXTAlphaImageLoader, &IID_IDXTAlphaImageLoader, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTAlphaImageLoader>,
    public IObjectSafetyImpl2<CDXTAlphaImageLoader>,
    public IPersistStorageImpl<CDXTAlphaImageLoader>,
    public IPersistPropertyBagImpl<CDXTAlphaImageLoader>,
    public IDXTScaleOutput,
    public IHTMLDXTransform
{
private:

    typedef enum {
        IMAGE = 0,
        CROP,
        SCALE,
        SIZINGMETHOD_MAX
    } SIZINGMETHOD;

    BSTR                    m_bstrSrc;
    BSTR                    m_bstrHostUrl;
    SIZINGMETHOD            m_eSizingMethod;
    static const WCHAR *    s_astrSizingMethod[SIZINGMETHOD_MAX];
    SIZE                    m_sizeManual;
    SIZE                    m_sizeSurface;

    CComPtr<IDXSurface>     m_spDXSurfSrc;
    CComPtr<IDXTransform>   m_spDXTransformScale;
    CComPtr<IDXTScale>      m_spDXTScale;
    CComPtr<IUnknown>       m_cpUnkMarshaler;
    
public:

    CDXTAlphaImageLoader();
    virtual ~CDXTAlphaImageLoader();

    DECLARE_POLY_AGGREGATABLE(CDXTAlphaImageLoader)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTALPHAIMAGELOADER)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTAlphaImageLoader)
        COM_INTERFACE_ENTRY(IDXTAlphaImageLoader)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTScaleOutput)
        COM_INTERFACE_ENTRY(IHTMLDXTransform)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTAlphaImageLoader>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTAlphaImageLoader)
        PROP_ENTRY("src",           DISPID_DXTALPHAIMAGELOADER_SRC, 
                   CLSID_DXTAlphaImageLoaderPP)
        PROP_ENTRY("sizingmethod",  DISPID_DXTALPHAIMAGELOADER_SIZINGMETHOD, 
                   CLSID_DXTAlphaImageLoaderPP)
        PROP_PAGE(CLSID_DXTAlphaImageLoaderPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT DetermineBnds(CDXDBnds & bnds);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);

    // IObjectWithSite methods (CDXBaseNTo1 overrides.)

    STDMETHOD(GetSite)(REFIID riid, void ** ppvSite);
    STDMETHOD(SetSite)(IUnknown * pUnkSite);

    // IDXTScaleOutput methods.

    STDMETHOD(SetOutputSize)(const SIZE sizeOut, BOOL fMaintainAspectRatio);

    // IHTMLDXTransform methods.

    STDMETHOD(SetHostUrl)(BSTR bstrHostUrl);

    // IDXTAlphaImageLoader properties.

    STDMETHOD(get_Src)(BSTR * pbstrSrc);
    STDMETHOD(put_Src)(BSTR bstrSrc);
    STDMETHOD(get_SizingMethod)(BSTR * pbstrSizingMethod);
    STDMETHOD(put_SizingMethod)(BSTR bstrSizingMethod);
};

#endif //__ALPHAIMAGELOADER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\alphaimageloader.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  FileName:   alphaimageloader.cpp
//
//  Overview:   The alpha image loader is to be used as a filter on web pages
//  `           that would like to display images that contain per pixel alpha.
//             
//  Change History:
//  1999/09/23  a-matcal    Created.
//  1999/11/23  a-matcal    AddedSizingMethod property.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "alphaimageloader.h"




//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader static variables initialization
//
//------------------------------------------------------------------------------

const WCHAR * CDXTAlphaImageLoader::s_astrSizingMethod[] = {
    L"image",
    L"crop",
    L"scale"
    // TODO:  Add "tile"
};


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::CDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
CDXTAlphaImageLoader::CDXTAlphaImageLoader() :
    m_bstrSrc(NULL),
    m_bstrHostUrl(NULL),
    m_eSizingMethod(IMAGE)
{
    m_sizeManual.cx     = 320;
    m_sizeManual.cy     = 240;

    // Base class members.

    m_ulNumInRequired   = 0;
    m_ulMaxInputs       = 0;

    // Because this DXTransform uses another DXTransform at times, it should
    // only use one thread for itself to avoid potential deadlocks and thread
    // conflicts.

    m_ulMaxImageBands   = 1;
}
//  CDXTAlphaImageLoader::CDXTAlphaImageLoader


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::~CDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
CDXTAlphaImageLoader::~CDXTAlphaImageLoader()
{
    SysFreeString(m_bstrSrc);
    SysFreeString(m_bstrHostUrl);
}
//  CDXTAlphaImageLoader::~CDXTAlphaImageLoader


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAlphaImageLoader::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTAlphaImageLoader::FinalConstruct, CComObjectRootEx



//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::DetermineBnds, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTAlphaImageLoader::DetermineBnds(CDXDBnds & bnds)
{
    HRESULT hr = S_OK;

    // If the sizing method is set to size to the image bounds, always return 
    // the image bounds.  Otherwise, we won't change the bounds.
    //
    // One exception.  If the bounds passed into us are empty, it's a "secret"
    // signal that we should pass back the bounds we'd prefer to draw to if we
    // were asked to draw right now.  

    if (IMAGE == m_eSizingMethod)
    {
        if (m_spDXSurfSrc)
        {
            hr = m_spDXSurfSrc->GetBounds(&bnds);
        }
    }
    else if (bnds.BoundsAreEmpty())
    {
        bnds.SetXYSize(m_sizeManual);
    }

    return hr;
}
//  CDXTAlphaImageLoader::DetermineBnds, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAlphaImageLoader::OnInitInstData(CDXTWorkInfoNTo1 & WI, 
                                     ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    // Setup the scale transform if we can and need to.

    if (   IsTransformDirty() 
        && m_spDXSurfSrc
        && m_spDXTransformScale
        && (SCALE == m_eSizingMethod))
    {
        IDXSurface * pDXSurfIn  = m_spDXSurfSrc;
        IDXSurface * pDXSurfOut = OutputSurface();

        hr = m_spDXTransformScale->Setup((IUnknown **)&pDXSurfIn,  1, 
                                         (IUnknown **)&pDXSurfOut, 1, 0);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spDXTScale->ScaleFitToSize(NULL, m_sizeManual, FALSE);

        if (FAILED(hr))
        {
            goto done;
        }
    }

done:

    return hr;
}
//  CDXTAlphaImageLoader::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAlphaImageLoader::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT     hr      = S_OK;
    DWORD       dwFlags = 0;
    CDXDBnds    bndsSrc = WI.DoBnds;
    CDXDBnds    bndsDst = WI.OutputBnds;

    // If they haven't given us a good source surface yet, just don't draw 
    // anything.

    if (!m_spDXSurfSrc)
    {
        goto done;
    }

    if (m_spDXTransformScale && (SCALE == m_eSizingMethod))
    {
        CDXDVec vecPlacement;

        WI.OutputBnds.GetMinVector(vecPlacement);

        hr = m_spDXTransformScale->Execute(NULL, &WI.DoBnds, &vecPlacement);

        goto done;
    }

    if (CROP == m_eSizingMethod)
    {
        CDXDBnds    bnds;

        hr = m_spDXSurfSrc->GetBounds(&bnds);

        if (FAILED(hr))
        {
            goto done;
        }

        // If the do bounds don't intersect the source image bounds, we don't
        // need to draw anything.

        if (!bnds.TestIntersect(WI.DoBnds))
        {
            goto done;
        }

        // We can only copy bounds to the right and bottom extents of the source
        // image.

        if (bndsSrc.Right() > bnds.Right())
        {
            long nOverrun = bndsSrc.Right() - bnds.Right();

            bndsSrc.u.D[DXB_X].Max -= nOverrun;
            bndsDst.u.D[DXB_X].Max -= nOverrun;
        }

        if (bndsSrc.Bottom() > bnds.Bottom())
        {
            long nOverrun = bndsSrc.Bottom() - bnds.Bottom();

            bndsSrc.u.D[DXB_Y].Max -= nOverrun;
            bndsDst.u.D[DXB_Y].Max -= nOverrun;
        }
    }

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    hr = DXBitBlt(OutputSurface(), bndsDst,
                  m_spDXSurfSrc, bndsSrc,
                  dwFlags, INFINITE);

done:

    return hr;
} 
//  CDXTAlphaImageLoader::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAlphaImageLoader::OnSurfacePick(const CDXDBnds & OutPoint, 
                                    ULONG & ulInputIndex, CDXDVec & InVec)
{
    HRESULT hr = S_OK;

    OutPoint.GetMinVector(InVec);

    if (   (OutPoint[DXB_X].Min < 0)
        || (OutPoint[DXB_X].Min >= m_sizeManual.cx)
        || (OutPoint[DXB_Y].Min < 0)
        || (OutPoint[DXB_Y].Min >= m_sizeManual.cy)
        || !m_spDXSurfSrc)
    {
        hr = S_FALSE;

        goto done;
    }

    if (m_spDXTransformScale && (SCALE == m_eSizingMethod))
    {
        CDXDVec                 vecOutPoint(InVec);
        CComPtr<IDXSurfacePick> spDXSurfacePick;

        hr = m_spDXTransformScale->QueryInterface(__uuidof(IDXSurfacePick),
                                                  (void **)&spDXSurfacePick);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDXSurfacePick->PointPick(&vecOutPoint, &ulInputIndex, &InVec);

        if (FAILED(hr))
        {
            goto done;
        }

        // Since the alpha image loader is a zero input transform, it doesn't
        // makes sense to return S_OK, so we'll translate DXT_S_HITOUTPUT which
        // does.

        if (S_OK == hr)
        {
            hr = DXT_S_HITOUTPUT;
        }
    }
    else
    {
        DXSAMPLE                sample;
        CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

        // If we're in crop mode and the element is larger than the source image
        // we may be able to hit outside the source image.

        if (   (OutPoint[DXB_X].Min >= m_sizeSurface.cx)
            || (OutPoint[DXB_Y].Min >= m_sizeSurface.cy))
        {
            hr = S_FALSE;

            goto done;
        }

        hr = m_spDXSurfSrc->LockSurface(&OutPoint, m_ulLockTimeOut, 
                                        DXLOCKF_READ, __uuidof(IDXARGBReadPtr),
                                        (void **)&spDXARGBReadPtr, NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        spDXARGBReadPtr->MoveToRow(0);

        spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

        if (sample.Alpha)
        {
            hr = DXT_S_HITOUTPUT;
        }
        else
        {
            hr = S_FALSE;
        }
    }

done:

    return hr;
}
//  CDXTAlphaImageLoader::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::GetSite, IObjectWithSite, CDXBaseNTo1
//
//  Notes:  GetSite and SetSite in the base class call Lock() and Unlock().
//          Because we can't do that in this function, there is a chance that
//          threading issues could arise.  
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::GetSite(REFIID riid, void ** ppvSite)
{
    return CDXBaseNTo1::GetSite(riid, ppvSite);
}
//  CDXTAlphaImageLoader::GetSite, IObjectWithSite, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::SetSite, IObjectWithSite, CDXBaseNTo1
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::SetSite(IUnknown * pUnkSite)
{
    if (m_cpUnkSite != pUnkSite)
    {
        HRESULT hr = S_OK;

        CComPtr<IDXTransformFactory>    spDXTransformFactory;
        CComPtr<IDXTransform>           spDXTransform;
        CComPtr<IDXTScale>              spDXTScale;

        m_spDXTransformScale.Release();
        m_spDXTScale.Release();

        // SetSite returns an hr, but won't fail.  See CDXBaseNTo1 comments for
        // details.

        CDXBaseNTo1::SetSite(pUnkSite);

        if (pUnkSite)
        {
            // In practice, SetSite is called before any of the IDXTransform 
            // methods are called, and only once.  So we shouldn't ever have a 
            // case where we need to re-setup the scale transform because 
            // SetSite is called at some random time.

            hr = GetSite(__uuidof(IDXTransformFactory), (void **)&spDXTransformFactory);

            if (FAILED(hr))
            {
                goto done;
            }

            hr = spDXTransformFactory->CreateTransform(NULL, 0, NULL, 0, NULL,
                                                       NULL, CLSID_DXTScale,
                                                       __uuidof(IDXTransform),
                                                       (void **)&spDXTransform);

            if (FAILED(hr))
            {
                goto done;
            }

            hr = spDXTransform->QueryInterface(__uuidof(IDXTScale),
                                               (void **)&spDXTScale);

            if (FAILED(hr))
            {
                goto done;
            }

            m_spDXTransformScale    = spDXTransform;
            m_spDXTScale            = spDXTScale;
        }
    }

done:

    return S_OK;
}
//  CDXTAlphaImageLoader::SetSite, IObjectWithSite, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::SetOutputSize, IDXTScaleOutput
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::SetOutputSize(const SIZE sizeOut, 
                                    BOOL /* fMaintainAspectRatio */)
{
    DXAUTO_OBJ_LOCK;

    if ((sizeOut.cx <= 0) || (sizeOut.cy <= 0))
    {
        return E_INVALIDARG;
    }

    m_sizeManual = sizeOut;

    SetDirty();

    return S_OK;
}
//  CDXTAlphaImageLoader::SetOutputSize, IDXTScaleOutput


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::SetHostUrl, IHTMLDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::SetHostUrl(BSTR bstrHostUrl)
{
    HRESULT hr = S_OK;

    SysFreeString(m_bstrHostUrl);

    m_bstrHostUrl = NULL;

    if (bstrHostUrl)
    {
        m_bstrHostUrl = SysAllocString(bstrHostUrl);

        if (NULL == m_bstrHostUrl)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }
    }

done:

    return hr;
}
//  CDXTAlphaImageLoader::SetHostUrl, IHTMLDXTransform


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::get_Src, IDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::get_Src(BSTR * pbstrSrc)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrSrc)
    {
        return E_POINTER;
    }

    if (*pbstrSrc != NULL)
    {
        return E_INVALIDARG;
    }

    if (NULL == m_bstrSrc)
    {
        *pbstrSrc = SysAllocString(L"");
    }
    else
    {
        *pbstrSrc = SysAllocString(m_bstrSrc);
    }

    if (NULL == *pbstrSrc)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTAlphaImageLoader::get_Src, IDXTAlphaImageLoader


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::put_Src, IDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::put_Src(BSTR bstrSrc)
{
    DXAUTO_OBJ_LOCK;

    HRESULT     hr              = S_OK;
    BSTR        bstrTemp        = NULL;
    WCHAR       strURL[2048]    = L"";
    WCHAR *     pchSrc          = (WCHAR *)bstrSrc;
    DWORD       cchURL          = 2048;
    BOOL        fAllow          = FALSE;
    CDXDBnds    bnds;
    SIZE        sizeSurface;

    CComPtr<IServiceProvider>   spServiceProvider;
    CComPtr<IDXSurface>         spDXSurfTemp;
    CComPtr<IDXSurfaceFactory>  spDXSurfaceFactory;
    CComPtr<ISecureUrlHost>     spSecureUrlHost;

    if (NULL == bstrSrc)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = GetSite(__uuidof(IServiceProvider), (void **)&spServiceProvider);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProvider->QueryService(SID_SDXSurfaceFactory, 
                                         __uuidof(IDXSurfaceFactory), 
                                         (void **)&spDXSurfaceFactory);

    if (FAILED(hr))
    {
        goto done;
    }

    if (m_bstrHostUrl)
    {
        HRESULT hrNonBlocking = ::UrlCombine(m_bstrHostUrl, bstrSrc, strURL, 
                                             &cchURL, URL_UNESCAPE );

        if (SUCCEEDED(hrNonBlocking))
        {
            pchSrc = strURL;
        }
    }

    hr = spServiceProvider->QueryService(__uuidof(IElementBehaviorSite),
                                         __uuidof(ISecureUrlHost),
                                         (void **)&spSecureUrlHost);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSecureUrlHost->ValidateSecureUrl(&fAllow, pchSrc, 0);

    if (FAILED(hr))
    {
        goto done;
    }
    else if (!fAllow)
    {
        hr = E_FAIL;
        goto done;
    }
      
    hr = spDXSurfaceFactory->LoadImage(pchSrc, NULL, NULL, &DDPF_PMARGB32,
                                       __uuidof(IDXSurface), 
                                       (void **)&spDXSurfTemp);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDXSurfTemp->GetBounds(&bnds);

    if (FAILED(hr))
    {
        goto done;
    }

    bnds.GetXYSize(sizeSurface);

    bstrTemp = SysAllocString(bstrSrc);

    if (NULL == bstrTemp)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    SysFreeString(m_bstrSrc);
    m_spDXSurfSrc.Release();

    m_bstrSrc           = bstrTemp;
    m_spDXSurfSrc       = spDXSurfTemp;
    m_sizeSurface.cx    = sizeSurface.cx;
    m_sizeSurface.cy    = sizeSurface.cy;

    SetDirty();

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  CDXTAlphaImageLoader::put_Src, IDXTAlphaImageLoader


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::get_SizingMethod, IDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::get_SizingMethod(BSTR * pbstrSizingMethod)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrSizingMethod)
    {
        return E_POINTER;
    }

    if (*pbstrSizingMethod != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrSizingMethod = SysAllocString(s_astrSizingMethod[m_eSizingMethod]);

    if (NULL == *pbstrSizingMethod)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTAlphaImageLoader::get_SizingMethod, IDXTAlphaImageLoader


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::put_SizingMethod, IDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::put_SizingMethod(BSTR bstrSizingMethod)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrSizingMethod)
    {
        return E_POINTER;
    }

    for ( ; i < (int)SIZINGMETHOD_MAX ; i++)
    {
        if (!_wcsicmp(bstrSizingMethod, s_astrSizingMethod[i]))
        {
            break;
        }
    }

    if ((int)SIZINGMETHOD_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eSizingMethod != i)
    {
        m_eSizingMethod = (SIZINGMETHOD)i;
         
        SetDirty();
    }

    return S_OK;
}
//  CDXTAlphaImageLoader::put_SizingMethod, IDXTAlphaImageLoader
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\barn.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:                barn.cpp
//
// Created:                 06/24/98
//
// Author:                  PhilLu
//
// Discription:             This file implements the Barn Door transform.
//
// 06/24/98 phillu      initial creation
// 07/09/98 phillu      implement OnSetSurfacePickOrder().
// 07/22/98 phillu      implement clipping
// 04/26/99 a-matcal    Optimize.
// 09/25/99 a-matcal    Implement ICrBarn2 interface.
// 10/22/99 a-matcal    Changed CBarn class to CDXTBarnBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "barn.h"




//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase static variables initialization.
//
//------------------------------------------------------------------------------
const WCHAR * CDXTBarnBase::s_astrMotion[] = {
    L"in",
    L"out"
};


const WCHAR * CDXTBarnBase::s_astrOrientation[] = {
    L"horizontal",
    L"vertical"
};


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::CDXTBarnBase
//
//------------------------------------------------------------------------------
CDXTBarnBase::CDXTBarnBase() :
    m_eMotion(MOTION_OUT),
    m_eOrientation(ORIENTATION_VERTICAL),
    m_fOptimize(true),
    m_fOptimizationPossible(false),
    m_cbndsDirty(0)
{
    m_sizeInput.cx    = 0;
    m_sizeInput.cy    = 0;

    for (int i = 0; i < MAX_BARN_BOUNDS; i++)
    {
        m_aulSurfaceIndex[i] = 0;
    }

    // Base class members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTBarnBase::CDXTBarnBase


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBarnBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTBarnBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBarnBase::OnSetup(DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    hr = m_bndsPrevDoor.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    m_bndsPrevDoor.GetXYSize(m_sizeInput);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTBarnBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTBarnBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                             ULONG aInIndex[], BYTE aWeight[])
{
    long pickX      = OutPoint.Left();
    long pickY      = OutPoint.Top();
    long doorWidth  = 0;
    long offset     = 0;
    bool fInDoor    = false;

    if (ORIENTATION_VERTICAL == m_eOrientation)
    {
        doorWidth   = (long)(m_Progress * m_sizeInput.cx + 0.5);

        if (MOTION_IN == m_eMotion)
        {
            offset      = doorWidth / 2;
            doorWidth   = m_sizeInput.cx - doorWidth;
        }
        else
        {
            offset      = (m_sizeInput.cx - doorWidth) / 2;
        }

        fInDoor = ((pickX >= offset) && (pickX < m_sizeInput.cx - offset));
    }
    else // Horizontal doors.
    {
        doorWidth = (long)(m_Progress * m_sizeInput.cy + 0.5F);

        if (MOTION_IN == m_eMotion)
        {
            offset      = doorWidth / 2;
            doorWidth   = m_sizeInput.cy - doorWidth;
        }
        else
        {
            offset      = (m_sizeInput.cy - doorWidth) / 2;
        }

        fInDoor = ((pickY >= offset) && (pickY < m_sizeInput.cy - offset));
    }

    if (MOTION_OUT == m_eMotion)
    {
        aInIndex[0] = fInDoor ? 1 : 0;
    }
    else
    {
        aInIndex[0] = fInDoor ? 0 : 1;
    }

    ulInToTest = 1;
    aWeight[0] = 255;
}
//  CDXTBarnBase::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::_CalcFullBounds
//
//  Overview:   This method will calculate one or three sets of bounds 
//              representing the rectangles on the output containing input A 
//              and input B.  
//
//              One set of bounds is generated in the case where the progress
//              is close enough to either 1.0 or 0.0 that the "barn door" is 
//              either completely closed (draw over entire output with input A) 
//              or completely opened (draw over entire output with input B.) 
// 
//              The barn door is considered to be completely "closed" when 
//              progress is equal to 0.0 and moves toward being completely
//              "open" when progress is 1.0.
//
//              Doors completely closed:        Doors completely opened:
//
//              AAAAAAAAAAA                     BBBBBBBBBBB         
//              AAAAAAAAAAA                     BBBBBBBBBBB
//              AAAAAAAAAAA                     BBBBBBBBBBB
//              AAAAAAAAAAA                     BBBBBBBBBBB
//
//
//              Three sets of bounds are generated when the "barn door" is
//              is paritally opened.  One set of bounds is adjacent to the left
//              side of the output surface and is drawn with input A.  Another
//              is on the right side of the output surface and draw with input
//              A.  These are the "doors" of the barn.  The third set of bounds
//              represents the center of the output and is set to be filled
//              using input B.
//
//              Doors partially opened:
//
//              AAAABBBAAAA                             
//              AAAABBBAAAA                     
//              AAAABBBAAAA                     
//              AAAABBBAAAA                     
//
//
//              Note:  All coordinates are calculated in input space coordinates
//              assuming the entire output will need to be drawn.  Bounds will
//              be clipped and transformed to output space if needed by the 
//              WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTBarnBase::_CalcFullBounds()
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    if (m_bndsCurDoor.BoundsAreEmpty())
    {
        // If the currect door area is empty, paint over the entire output
        // surface with the barn surface.

        m_cbndsDirty            = 1;
        m_abndsDirty[0]         = bndsInput;

        m_aulSurfaceIndex[0]    = (MOTION_OUT == m_eMotion) ? 0 : 1;
    }
    else if (m_bndsCurDoor == bndsInput)
    {
        // If the current door bounds are equal to the input bounds, paint
        // over the entire output surface with the door surface.

        m_cbndsDirty            = 1;
        m_abndsDirty[0]         = bndsInput;

        m_aulSurfaceIndex[0]    = (MOTION_OUT == m_eMotion) ? 1 : 0;
    }
    else
    {
        // In this case the door is partially opened so we pass three sets of
        // bounds.  The left and right barn areas, and the middle door area.

        RECT        rcTemp;

        m_cbndsDirty = 3;

        // Left/top barn area.

        bndsInput.GetXYRect(rcTemp);

        if (ORIENTATION_VERTICAL == m_eOrientation)
        {
            rcTemp.right    = m_bndsCurDoor.Left();
        }
        else // Horizontal doors.
        {
            rcTemp.bottom   = m_bndsCurDoor.Top();
        }

        m_abndsDirty[0].SetXYRect(rcTemp);

        // Middle door area.

        m_abndsDirty[1] = m_bndsCurDoor;

        // Right/bottom barn area.

        bndsInput.GetXYRect(rcTemp);

        if (ORIENTATION_VERTICAL == m_eOrientation)
        {
            rcTemp.left = m_bndsCurDoor.Right();
        }
        else // Horizontal doors.
        {
            rcTemp.top  = m_bndsCurDoor.Bottom(); 
        }

        m_abndsDirty[2].SetXYRect(rcTemp);

        // Assign surface indexes to barn and door bounds.

        if (MOTION_OUT == m_eMotion)
        {
            m_aulSurfaceIndex[0] = 0;
            m_aulSurfaceIndex[1] = 1;
            m_aulSurfaceIndex[2] = 0;
        }
        else
        {
            m_aulSurfaceIndex[0] = 1;
            m_aulSurfaceIndex[1] = 0;
            m_aulSurfaceIndex[2] = 1;
        }
    }

done:

    return hr;
}
//  CDXTBarnBase::_CalcFullBounds


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::_CalcOptBounds
//
//  Overview:   This method will calculate one or two sets of bounds to update
//              the contents of the output surface assuming the surface has not 
//              been dirtied and that the output of this transform is not being
//              blended over the current contents of the output surface.  These
//              conditions are guaranteed by the OnInitInstData method that
//              calls this method.
//
//              The OnInitInstData method will also guarantee that there has
//              been some visible change in progress before calling this method.
//
//              One set of bounds is generated if the barn door has just shut 
//              completely or has just gone from completely closed to partially
//              or completely opened.  If this is the case, the set of bounds
//              generated represent the middle section of the output that can
//              be seen through the "barn doors."  If the doors are closing
//              these bounds will be filled with Input A, otherwise they will
//              be filled with Input B.
//              
//              On the diagrams below, the hyphens represent areas that are
//              already filled with Input A pixels.
//
//              Doors closing:      Doors opening:
//
//              ----AAA----         ----BBB----         
//              ----AAA----         ----BBB----
//              ----AAA----         ----BBB----
//              ----AAA----         ----BBB----
//
//
//              Two sets of bounds are generated if the barn doors have opened
//              some or closed some and were not before and are not now
//              completely closed.  The bounds represent the different between
//              the previous door position and the current door position.
//
//              On the diagrams below, the hyphens in the middle represent areas
//              that are already filled with Input B pixels.  The hypens on the
//              right and left edges represent pixels that are already filled
//              with Input A pixels.
//
//              Doors closing some:         Doors opening some:
//
//              --AA---AA--                 --BB---BB--         
//              --AA---AA--                 --BB---BB--
//              --AA---AA--                 --BB---BB--
//              --AA---AA--                 --BB---BB--
//
//
//              Note:  All coordinates are calculated in input space coordinates
//              assuming the entire output will need to be drawn.  Bounds will
//              be clipped and transformed to output space if needed by the 
//              WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTBarnBase::_CalcOptBounds()
{
    HRESULT hr = S_OK;

    if (m_bndsCurDoor == m_bndsPrevDoor)
    {
        // If the door bounds are the same as the previous door bounds, no
        // update is required.

        m_cbndsDirty = 0;
    }
    else if (m_bndsPrevDoor.BoundsAreEmpty())
    {
        // If the previous door bounds are empty (have no area) then we just
        // need to pass one set of bounds to the WorkProc to draw the whole
        // newly opened door with the door surface.

        m_cbndsDirty            = 1;
        m_abndsDirty[0]         = m_bndsCurDoor;
        m_aulSurfaceIndex[0]    = (MOTION_OUT == m_eMotion) ? 1 : 0;
    }
    else if (m_bndsCurDoor.BoundsAreEmpty())
    {
        // If the current door bounds are empty (have no area) then we just
        // need to pass one set of bounds to the WorkProc to draw over the
        // recently closed door area with the barn surface.

        m_cbndsDirty            = 1;
        m_abndsDirty[0]         = m_bndsPrevDoor;
        m_aulSurfaceIndex[0]    = (MOTION_OUT == m_eMotion) ? 0 : 1;
    }
    else
    {
        // At this point we know the doors have either opened a little wider 
        // or closed a little and we need to pass two sets of bounds to
        // paint over the dirty area with the appropriate input.

        CDXDBnds    bndsInput;
        RECT        rcLeft;
        RECT        rcRight;

        hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty = 2;

        // Left/top update bounds.

        bndsInput.GetXYRect(rcLeft);

        if (ORIENTATION_VERTICAL == m_eOrientation)
        {
            rcLeft.left     = min(m_bndsCurDoor.Left(), m_bndsPrevDoor.Left());
            rcLeft.right    = max(m_bndsCurDoor.Left(), m_bndsPrevDoor.Left());
        }
        else // Horizontal doors.
        {
            rcLeft.top      = min(m_bndsCurDoor.Top(), m_bndsPrevDoor.Top());
            rcLeft.bottom   = max(m_bndsCurDoor.Top(), m_bndsPrevDoor.Top());
        }

        m_abndsDirty[0].SetXYRect(rcLeft);

        // Right/bottom update bounds.

        bndsInput.GetXYRect(rcRight);

        if (ORIENTATION_VERTICAL == m_eOrientation)
        {
            rcRight.left    = min(m_bndsCurDoor.Right(), m_bndsPrevDoor.Right());
            rcRight.right   = max(m_bndsCurDoor.Right(), m_bndsPrevDoor.Right());
        }
        else // Horizontal doors.
        {
            rcRight.top     = min(m_bndsCurDoor.Bottom(), m_bndsPrevDoor.Bottom());
            rcRight.bottom  = max(m_bndsCurDoor.Bottom(), m_bndsPrevDoor.Bottom());
        }

        m_abndsDirty[1].SetXYRect(rcRight);

        if ((m_bndsCurDoor.Left() < m_bndsPrevDoor.Left())
            || (m_bndsCurDoor.Top() < m_bndsPrevDoor.Top()))
        {
            // Door is getting wider, paint more door.

            m_aulSurfaceIndex[0] = (MOTION_OUT == m_eMotion) ? 1 : 0;
            m_aulSurfaceIndex[1] = (MOTION_OUT == m_eMotion) ? 1 : 0;
        }
        else
        {
            // Door is getting smaller, paint over door.

            m_aulSurfaceIndex[0] = (MOTION_OUT == m_eMotion) ? 0 : 1;
            m_aulSurfaceIndex[1] = (MOTION_OUT == m_eMotion) ? 0 : 1;
        }
    }

done:

    return hr;
}
//  CDXTBarnBase::_CalcOptBounds


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTBarnBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr          = S_OK;
    LONG    lDoorWidth  = 0;
    RECT    rcDoor;

    // Calculate the barn door bounds for this execute.

    if (ORIENTATION_VERTICAL == m_eOrientation)
    {
        lDoorWidth  = (long)(GetEffectProgress() * m_sizeInput.cx + 0.5F);

        if (MOTION_IN == m_eMotion)
        {
            lDoorWidth = m_sizeInput.cx - lDoorWidth;
        }

        rcDoor.top      = 0;
        rcDoor.bottom   = m_sizeInput.cy;
        rcDoor.left     = (m_sizeInput.cx - lDoorWidth) / 2;
        rcDoor.right    = rcDoor.left + lDoorWidth;
    }
    else // Horizontal doors.
    {
        lDoorWidth  = (long)(GetEffectProgress() * m_sizeInput.cy + 0.5F);

        if (MOTION_IN == m_eMotion)
        {
            lDoorWidth = m_sizeInput.cy - lDoorWidth;
        }

        rcDoor.left     = 0;
        rcDoor.right    = m_sizeInput.cx;
        rcDoor.top      = (m_sizeInput.cy - lDoorWidth) / 2;
        rcDoor.bottom   = rcDoor.top + lDoorWidth;
    }

    m_bndsCurDoor.SetXYRect(rcDoor);

    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        hr = _CalcFullBounds();

        if (FAILED(hr))
        {
            goto done;
        }
    }
    else // Create optimized dirty bounds.
    {
        hr = _CalcOptBounds();

        if (FAILED(hr))
        {
            goto done;
        }
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBarnBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    DWORD   dwFlags         = 0;
    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    for (ULONG i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            hr = DXBitBlt(OutputSurface(), bndsDest,
                          InputSurface(m_aulSurfaceIndex[i]), bndsSrc,
                          dwFlags, INFINITE);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTBarnBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTBarnBase::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_bndsPrevDoor = m_bndsCurDoor;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTBarnBase::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::get_Motion, ICrBarn2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBarnBase::get_Motion(BSTR * pbstrMotion)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrMotion)
    {
        return E_POINTER;
    }

    if (*pbstrMotion != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrMotion = SysAllocString(s_astrMotion[m_eMotion]);

    if (NULL == *pbstrMotion)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTBarnBase::get_Motion, ICrBarn2


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::put_Motion, ICrBarn2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBarnBase::put_Motion(BSTR bstrMotion)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrMotion)
    {
        return E_POINTER;
    }

    for ( ; i < (int)MOTION_MAX ; i++)
    {
        if (!_wcsicmp(bstrMotion, s_astrMotion[i]))
        {
            break;
        }
    }

    if ((int)MOTION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eMotion != i)
    {
        m_eMotion = (MOTION)i;

        SetDirty();
    }

    return S_OK;
}
//  CDXTBarnBase::put_Motion, ICrBarn2


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::get_Orientation, ICrBarn2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBarnBase::get_Orientation(BSTR * pbstrOrientation)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrOrientation)
    {
        return E_POINTER;
    }

    if (*pbstrOrientation != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrOrientation = SysAllocString(s_astrOrientation[m_eOrientation]);

    if (NULL == *pbstrOrientation)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTBarnBase::get_Orientation, ICrBarn2


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::put_Orientation, ICrBarn2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBarnBase::put_Orientation(BSTR bstrOrientation)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrOrientation)
    {
        return E_POINTER;
    }

    for ( ; i < (int)ORIENTATION_MAX ; i++)
    {
        if (!_wcsicmp(bstrOrientation, s_astrOrientation[i]))
        {
            break;
        }
    }

    if ((int)ORIENTATION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((ORIENTATION)i != m_eOrientation)
    {
        m_eOrientation = (ORIENTATION)i;

        SetDirty();
    }

    return S_OK;
}
//  CDXTBarnBase::put_Orientation, ICrBarn2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\alpha.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    alpha.cpp
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	Implementation of Alpha transform CAlpha
//
// Change History:
//
// 05/20/99 PhilLu      Move from dtcss to dxtmsft. Re-implemented algorithms
//                      for creating linear/rectangular/elliptic surfaces.
// 10/18/99 a-matcal    StartY and FinishY were reversed.  It looked like the 
//                      old filter was purposely reversing them, but it wasn't.
//                      Changed properties to change value as the old alpha
//                      property functions did.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include <math.h>
#include "Alpha.h"

#if DBG == 1
static s_ulMaxImageBands = 0;
#endif




//+-----------------------------------------------------------------------------
//
//  CAlpha::CAlpha
//
//------------------------------------------------------------------------------
CAlpha::CAlpha() :
    m_lPercentOpacity(100),
    m_lPercentFinishOpacity(0),
    m_lStartX(0),
    m_lStartY(50),
    m_lFinishX(100),
    m_lFinishY(50),
    m_eStyle(ALPHA_STYLE_CONSTANT)

{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;

#if DBG == 1
    if (s_ulMaxImageBands)
    {
        m_ulMaxImageBands = s_ulMaxImageBands;
    }
#endif
}
//  CAlpha::CAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CAlpha::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CAlpha::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_Opacity, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_Opacity(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lPercentOpacity;
    return S_OK;
}
//  CAlpha::get_Opacity, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_Opacity, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_Opacity(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }

    if (newVal != m_lPercentOpacity)
    {
        Lock();
        m_lPercentOpacity = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_Opacity, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_FinishOpacity, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_FinishOpacity(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lPercentFinishOpacity;
    return S_OK;
}
//  CAlpha::get_FinishOpacity, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_FinishOpacity, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_FinishOpacity(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }

    if (newVal != m_lPercentFinishOpacity)
    {
        Lock();
        m_lPercentFinishOpacity = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_FinishOpacity, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_Style, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_Style(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_eStyle;
    return S_OK;
}
//  CAlpha::get_Style, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_Style, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_Style(long newVal)
{
    if ((newVal < 0) || (newVal > 3))
    {
        return E_INVALIDARG;
    }

    if (newVal != m_eStyle)
    {
        Lock();
        m_eStyle = (AlphaStyleType) newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_Style, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_StartX, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_StartX(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lStartX;
    return S_OK;
}
//  CAlpha::get_StartX, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_StartX, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_StartX(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }

    if (newVal != m_lStartX)
    {
        Lock();
        m_lStartX = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_StartX, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_StartY, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_StartY(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lStartY;
    return S_OK;
}
//  CAlpha::get_StartY, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_StartY, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_StartY(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }


    if( newVal != m_lStartY )
    {
        Lock();
        m_lStartY = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_StartY, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_FinishX, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_FinishX(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lFinishX;
    return S_OK;
}
//  CAlpha::get_FinishX, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_FinishX, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_FinishX(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }


    if(newVal != m_lFinishX)
    {
        Lock();
        m_lFinishX = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_FinishX, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_FinishY, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_FinishY(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lFinishY;
    return S_OK;
}
//  CAlpha::get_FinishY, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_FinishY, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_FinishY(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }

    if (newVal != m_lFinishY)
    {
        Lock();
        m_lFinishY = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_FinishY, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::OnGetsurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CAlpha::OnGetSurfacePickOrder(const CDXDBnds & /* OutPoint */, ULONG & ulInToTest, 
                              ULONG aInIndex[], BYTE aWeight[])
{
    ulInToTest = 1;
    aInIndex[0] = 0;
    aWeight[0] = 255;
}
//  CAlpha::OnGetsurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CAlpha::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CAlpha::OnSetup(DWORD /* dwFlags */)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (SUCCEEDED(hr))
    {
        bndsIn.GetXYSize(m_sizeInput);
    }

    return hr;

}
//  CAlpha::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  INT_MULT
//
//  This is a helper function that computes (BYTE) (a*b + 128)/255f)
//
//------------------------------------------------------------------------------
inline int 
INT_MULT( BYTE a, int b )
{  
	int temp = (a*b) + 128;
	return ((temp>>8) + temp)>>8;
}
//  INT_MULT


//+-----------------------------------------------------------------------------
//
//  CAlpha::CompLinearGradientRow
//
//  Given a starting position (nXPos,nYPos), this functions computes a 
//  horizontal row of pixel values of a linear surface. The gradient surface is
//  defined by two points (Start and Finish) and the opacity values at these 
//  two points. The gradient direction is the direction of connecting these two 
//  points (i.e. the surface has constant value along a line perpendicular to 
//  the gradient direction). Between the two points, the opacity value is a 
//  linear interpolation of the two given values. Outside of the range of the 
//  two points, the value at the nearer end-point will hold.
//
//------------------------------------------------------------------------------
void 
CAlpha::CompLinearGradientRow(int nXPos, int nYPos, int nWidth, 
                              BYTE * pGradRow)
{
    int nOpac1  = (m_lPercentOpacity       * 255)   / 100;
    int nOpac2  = (m_lPercentFinishOpacity * 255)   / 100;
    int nx1     = (m_sizeInput.cx * m_lStartX)      / 100;
    int ny1     = (m_sizeInput.cy * m_lStartY)      / 100;   
    int nx2     = (m_sizeInput.cx * m_lFinishX)     / 100;
    int ny2     = (m_sizeInput.cy * m_lFinishY)     / 100;  

    // Notice above that the ny coordinates have been inverted so that
    // m_lStartX = 0 represents the bottom of the image, not the top.

    int ndx     = nx2 - nx1;
    int ndy     = ny2 - ny1;
    int nDist2  = (ndx * ndx) + (ndy * ndy);

    int i = 0;

    if (nDist2 == 0)
    {
        // Start and Finish points coinside with each other. 
        // create a constant surface

        for (i = 0; i < nWidth; i++)
        {
            pGradRow[i] = (BYTE)nOpac1;
        }
    }
    else
    {
        // create a linear surface. Since opacity value increments linearly 
        // along the row, we pre-compute the start value (flOpacity) and 
        // increment (flOpacInc) to save multiplications
        //
        // The relative distance at (x,y), projected to (x1,y1) -- (x2,y2) is
        //
        // r = [(x-x1)(x2-x1)+(y-y1)*(y2-y1)]/[(x2-x1)^2 + (y2-y1)^2]
        //
        // Thus the opacity value at (x,y) will be
        // op = op1, for r < 0;
        // op = op1 + r*(op2-op1), for 0 <= r <= 1
        // op = op2, for r > 1.
        //
        // flOpacity is the opacity at the beginning of the row. flOpacInc is
        // the increment of flOpacity when x increments by 1.
        //
        // nProj is the numerator part of r, and it is used to test the range
        // of r. nProj is also incremented along the row.

        // REVIEW:  In the float calculations below, cast nProj and ndx to 
        // floats also, to clarify that you're not using an integer division
        // trick of some sort (even though it's not division).

        int nProj = (nXPos - nx1) * ndx + (nYPos - ny1) * ndy;
        float flOpacity = (float)nOpac1 + 
                          (float)(nOpac2 - nOpac1) * nProj / (float)nDist2;
        float flOpacInc = (float)(nOpac2 - nOpac1) * ndx / (float)nDist2;

        for (i=0; i<nWidth; i++)
        {
            if (nProj < 0) // corresponds to r < 0
            {
                pGradRow[i] = (BYTE)nOpac1; // hold the end-point value
            }
            else if (nProj > nDist2)  // corresponds to r > 1
            {
                pGradRow[i] = (BYTE)nOpac2; // hold the end-point value
            }
            else  // 0 <= r <= 1; the current flOpacity is interpolated
            {
                pGradRow[i] = (BYTE)(flOpacity + 0.5);
            }

            // increment values for the next pixel in the row
            nProj += ndx;  // when nXPox inc by 1; nProj inc by ndx.
            flOpacity += flOpacInc;
        }
    }
}
//  CAlpha::CompLinearGradientRow


//+-----------------------------------------------------------------------------
//
//  CAlpha::CompRadialSquareRow
//
//  Create a horizontal row of pixel values on a square (rectangular) surface.
//
//------------------------------------------------------------------------------
void 
CAlpha::CompRadialSquareRow(int nXPos, int nYPos, int nWidth, 
                            BYTE *pGradRow)
{
    int nOpac1 = (m_lPercentOpacity       * 255) / 100;
    int nOpac2 = (m_lPercentFinishOpacity * 255) / 100;
    int i = 0;

    // This option is to be consistent with the original CSS filter. The radiao
    // or square surface always centers at the center of image and expands fully
    // to the edge of image.

    int     nCenterX    = m_sizeInput.cx / 2;
    int     nCenterY    = m_sizeInput.cy / 2;
    float   fdx         = 0.5F;
    float   fdy         = 0.5F;
    float   fDist       = (float)max(fabs(fdx), fabs(fdy));

    float fXInc = 1.0f / (m_sizeInput.cx * fDist);
    float fX = ((int)nXPos - nCenterX) * fXInc;
    float fY = ((int)nYPos - nCenterY) / (m_sizeInput.cy * fDist);
    float fRatio;

    for (i = 0 ; i < nWidth ; i++)
    {
        // Square shape: Z = max(|X|, |Y|), X, Y are normalized coord
        fRatio = (float)max(fabs(fX), fabs(fY));

        if (fRatio >= 1.0f)
        {
            pGradRow[i] = (BYTE)nOpac2;
        }
        else
        {
            pGradRow[i] = (BYTE)(nOpac1 + (nOpac2 - nOpac1) * fRatio + 0.5f);
        }

        fX += fXInc;
    }
}
//  CAlpha::CompRadialSquareRow


//+-----------------------------------------------------------------------------
//
//  CAlpha::CompRadialRow
//
//  Create a horizontal row of pixel values on a radial (elliptic) surface.
//
//------------------------------------------------------------------------------
void 
CAlpha::CompRadialRow(int nXPos, int nYPos, int nWidth, BYTE *pGradRow)
{
    int nOpac1      = (m_lPercentOpacity       * 255) / 100;
    int nOpac2      = (m_lPercentFinishOpacity * 255) / 100;
    int i           = 0;

    float   flXInc          = 2.0F / (float)m_sizeInput.cx;
    float   flXPos          = ((float)nXPos * flXInc) - 1.0F;
    float   flYPos          = ((float)nYPos * (2.0F / (float)m_sizeInput.cy)) 
                              - 1.0F;
    float   flYPosSquared   = flYPos * flYPos;

    float   flOpacVector    = (float)(nOpac2 - nOpac1);
    float   flRatio         = 0.0F;

    while (nWidth)
    {
        flRatio = (float)sqrt((flXPos * flXPos) + flYPosSquared);

        if (flRatio < 1.0F)
        {
            pGradRow[i] = (BYTE)(nOpac1 + (int)(flRatio * flOpacVector));
        }
        else
        {
            pGradRow[i] = (BYTE)(nOpac2);
        }

        i++;
        nWidth--;

        // Possible float drift, but this thing has bad enough perf with the 
        // sqrt for every pixel that we'll take our chances.

        flXPos += flXInc;
    }
}
//  CAlpha::CompRadialRow


//+-----------------------------------------------------------------------------
//
//  CAlpha::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CAlpha::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * /* pbContinueProcessing */)
{
    HRESULT hr  = S_OK;
    int     y   = 0;
    int     i   = 0;

    BYTE    bOpacity    = (BYTE)((m_lPercentOpacity * 255) / 100);

    DXPMSAMPLE * pOverScratch   = NULL;
    DXPMSAMPLE * pPMBuff        = NULL;
    DXSAMPLE *   pBuffer        = NULL;
    BYTE *       pGradRow       = NULL;

    CComPtr<IDXARGBReadWritePtr>    pDest;
    CComPtr<IDXARGBReadPtr>         pSrc;

    DXDITHERDESC        dxdd;

    const int nDoWidth = WI.DoBnds.Width();
    const int nDoHeight = WI.DoBnds.Height();

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, IID_IDXARGBReadWritePtr,
                                      (void**)&pDest, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = InputSurface()->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOverScratch = DXPMSAMPLE_Alloca(nDoWidth);
    }

    pBuffer = DXSAMPLE_Alloca(nDoWidth);
    pGradRow = (BYTE *)_alloca(nDoWidth);
    
    //
    //  Set up the dither structure
    //
    if (DoDither())
    {
        dxdd.x = WI.OutputBnds.Left();
        dxdd.y = WI.OutputBnds.Top();
        dxdd.pSamples = pBuffer;
        dxdd.cSamples = nDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    for (y = 0; y < nDoHeight; y++)
    {
        pSrc->MoveToRow(y);
        pSrc->Unpack(pBuffer, nDoWidth, FALSE);

        if (m_eStyle == ALPHA_STYLE_CONSTANT)
        {
            for (i = 0; i < nDoWidth; i++)
            {
                if (pBuffer[i].Alpha > bOpacity)
                {
                    pBuffer[i].Alpha = bOpacity;
                }
            }
        }
        else
        {
            if (m_eStyle == ALPHA_STYLE_LINEAR)
            {
                CompLinearGradientRow(WI.DoBnds.Left(), WI.DoBnds.Top()+y,
                                      nDoWidth, pGradRow);
            }
            else if (ALPHA_STYLE_RADIAL == m_eStyle)
            {
                CompRadialRow(WI.DoBnds.Left(), WI.DoBnds.Top() + y, nDoWidth,
                              pGradRow);
            }
            else // ALPHA_STYLE_SQUARE
            {
                CompRadialSquareRow(WI.DoBnds.Left(), WI.DoBnds.Top()+y, 
                                    nDoWidth, pGradRow);
            }

            for (i = 0; i < nDoWidth; i++)
            {
                pBuffer[i].Alpha = (BYTE)INT_MULT(pGradRow[i], pBuffer[i].Alpha);
            }
        }

        // Get the output row
        pDest->MoveToRow(y);
        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            pPMBuff = DXPreMultArray(pBuffer, nDoWidth);
            pDest->OverArrayAndMove(pOverScratch, pPMBuff, nDoWidth);
        }
        else
        {
            pDest->PackAndMove(pBuffer, nDoWidth);
        }
    } // End for

    return hr;
}
//  CAlpha::WorkProc, CDXBaseNTo1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\alpha.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    alpha.h
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	This is the header file for the Alpha transformation
//
// Change History:
//
// 05/20/99 phillu   Move from dtcss to dxtmsft. Re-implemented algorithms for
//                   creating linear/rectangular/elliptic surfaces.
//
//------------------------------------------------------------------------------

#ifndef __ALPHA_H_
#define __ALPHA_H_

#include "resource.h"       // main symbols

// enum for supported Alpha styles
typedef enum {
    ALPHA_STYLE_CONSTANT = 0,
    ALPHA_STYLE_LINEAR,
    ALPHA_STYLE_RADIAL,
    ALPHA_STYLE_SQUARE
} AlphaStyleType;




class ATL_NO_VTABLE CAlpha : 
    public CDXBaseNTo1,
    public CComCoClass<CAlpha, &CLSID_DXTAlpha>,
    public CComPropertySupport<CAlpha>,
    public IDispatchImpl<IDXTAlpha, &IID_IDXTAlpha, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CAlpha>,
    public IPersistStorageImpl<CAlpha>,
    public ISpecifyPropertyPagesImpl<CAlpha>,
    public IPersistPropertyBagImpl<CAlpha>
{
private:

    SIZE    m_sizeInput;
    long    m_lPercentOpacity;
    long    m_lPercentFinishOpacity;
    long    m_lStartX;
    long    m_lStartY;
    long    m_lFinishX;
    long    m_lFinishY;
    AlphaStyleType m_eStyle;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // Methods for gradient alpha

    void CompLinearGradientRow(int nXPos, int nYPos, int nWidth, 
                               BYTE *pGradRow);
    void CompRadialRow(int nXPos, int nYPos, int nWidth, BYTE * pGradRow);
    void CompRadialSquareRow(int nXPos, int nYPos, int nWidth, 
                             BYTE *pGradRow);

public:

    CAlpha();

    DECLARE_POLY_AGGREGATABLE(CAlpha)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_ALPHA)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CAlpha)
        COM_INTERFACE_ENTRY(IDXTAlpha)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CAlpha>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CAlpha)
        PROP_ENTRY("Opacity"      , 1, CLSID_DXTAlphaPP)
        PROP_ENTRY("FinishOpacity", 2, CLSID_DXTAlphaPP)
        PROP_ENTRY("Style"        , 3, CLSID_DXTAlphaPP)
        PROP_ENTRY("StartX"       , 4, CLSID_DXTAlphaPP)
        PROP_ENTRY("StartY"       , 5, CLSID_DXTAlphaPP)
        PROP_ENTRY("FinishX"      , 6, CLSID_DXTAlphaPP)
        PROP_ENTRY("FinishY"      , 7, CLSID_DXTAlphaPP)
        PROP_PAGE(CLSID_DXTAlphaPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    void    OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest,
                                  ULONG aInIndex[], BYTE aWeight[]);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing);
    HRESULT OnSetup(DWORD dwFlags);

    // IDXTAlpha methods.

    STDMETHOD(get_Opacity)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_Opacity)(/*[in]*/ long newVal);
    STDMETHOD(get_FinishOpacity)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_FinishOpacity)(/*[in]*/ long newVal);
    STDMETHOD(get_Style)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_Style)(/*[in]*/ long newVal);
    STDMETHOD(get_StartX)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_StartX)(/*[in]*/ long newVal);
    STDMETHOD(get_StartY)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_StartY)(/*[in]*/ long newVal);
    STDMETHOD(get_FinishX)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_FinishX)(/*[in]*/ long newVal);
    STDMETHOD(get_FinishY)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_FinishY)(/*[in]*/ long newVal);
};

#endif //__ALPHA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\barn.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:                barn.h
//
// Created:                 06/24/98
//
// Author:                  PhilLu
//
// Discription:             This file declares CrBarn (Barn Door Transform)
//
// Change History:
// 06/24/98 PhilLu      Developed 1.0 version for Chromeffects
// 11/04/98 PaulNash    Moved from DT 1.0 codebase to IE5/NT5 DXTMSFT.DLL
// 04/26/99 a-matcal    optimize.
// 09/25/99 a-matcal    Inherit from ICrBarn2 interface.
// 10/22/99 a-matcal    Changed CBarn class to CDXTBarnBase and created two new
//                      classes CDXTBarn and CDXTBarnOpt to represent
//                      non-optimized and optimized versions repectively.
//
//------------------------------------------------------------------------------

#ifndef __CRBARN_H_
#define __CRBARN_H_

#include "resource.h"   

#define MAX_BARN_BOUNDS 3




class ATL_NO_VTABLE CDXTBarnBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrBarn2, &IID_ICrBarn2, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTBarnBase>,
    public IObjectSafetyImpl2<CDXTBarnBase>
{
private:

    typedef enum {
        MOTION_IN = 0,
        MOTION_OUT,
        MOTION_MAX
    } MOTION;

    MOTION                  m_eMotion;
    static const WCHAR *    s_astrMotion[MOTION_MAX];

    typedef enum {
        ORIENTATION_HORIZONTAL = 0,
        ORIENTATION_VERTICAL,
        ORIENTATION_MAX
    } ORIENTATION;

    ORIENTATION             m_eOrientation;
    static const WCHAR *    s_astrOrientation[ORIENTATION_MAX];

    SIZE                m_sizeInput;
    CDXDBnds            m_bndsCurDoor;
    CDXDBnds            m_bndsPrevDoor;
    CDXDBnds            m_abndsDirty[MAX_BARN_BOUNDS];
    ULONG               m_aulSurfaceIndex[MAX_BARN_BOUNDS];
    ULONG               m_cbndsDirty;

    CComPtr<IUnknown>   m_cpUnkMarshaler;

    // Helpers.

    HRESULT _CalcFullBounds();
    HRESULT _CalcOptBounds();

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

public:

    CDXTBarnBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTBarnBase)
        COM_INTERFACE_ENTRY(ICrBarn2)
        COM_INTERFACE_ENTRY(ICrBarn)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTBarnBase>)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTBarnBase)
        PROP_ENTRY("motion",        DISPID_CRBARN_MOTION,       CLSID_CrBarnPP)
        PROP_ENTRY("orientation",   DISPID_CRBARN_ORIENTATION,  CLSID_CrBarnPP)
        PROP_PAGE(CLSID_CrBarnPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // ICrBarn2 properties.

    STDMETHOD(get_Motion)(BSTR * pbstrMotion);
    STDMETHOD(put_Motion)(BSTR bstrMotion);
    STDMETHOD(get_Orientation)(BSTR * pbstrOrientation);
    STDMETHOD(put_Orientation)(BSTR bstrOrientation);

    // IDXEffect properties.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTBarn :
    public CDXTBarnBase,
    public CComCoClass<CDXTBarn, &CLSID_CrBarn>,
    public IPersistStorageImpl<CDXTBarn>,
    public IPersistPropertyBagImpl<CDXTBarn>
{
public:

    CDXTBarn()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTBARN)
    DECLARE_POLY_AGGREGATABLE(CDXTBarn)

    BEGIN_COM_MAP(CDXTBarn)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTBarnBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTBarnOpt :
    public CDXTBarnBase,
    public CComCoClass<CDXTBarnOpt, &CLSID_DXTBarn>,
    public IPersistStorageImpl<CDXTBarnOpt>,
    public IPersistPropertyBagImpl<CDXTBarnOpt>
{
public:

    CDXTBarnOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTBARNOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTBarnOpt)

    BEGIN_COM_MAP(CDXTBarnOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTBarnBase)
    END_COM_MAP()
};


#endif //__CRBARN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\blinds.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:            blinds.cpp
//
// Created:             06/24/98
//
// Author:              phillu
//
// Discription:         This is the implementation of the CrBlinds transform.
//
// History
//
// 06/24/98 phillu      initial creation
// 07/02/98 phillu      return E_INVALIDARG rather than an error string
// 07/09/98 phillu      implement OnSetSurfacePickOrder().
// 07/23/98 phillu      implement clipping
// 05/18/99 a-matcal    Optimization.
// 09/25/99 a-matcal    Implemented ICrBlinds2.
// 10/22/99 a-matcal    Changed CBlinds class to CDXTBlindsBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "blinds.h"

static const OLECHAR * g_astrDirection[] = {
    L"up",
    L"down",
    L"left",
    L"right"
};




//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::CDXTBlindsBase
//
//------------------------------------------------------------------------------
CDXTBlindsBase::CDXTBlindsBase() :
    m_cBands(10),
    m_lCurBandCover(0),
    m_lPrevBandCover(0),
    m_cbndsDirty(0),
    m_eDirection(DOWN),
    m_fOptimize(false),
    m_fOptimizationPossible(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTBlindsBase::CDXTBlindsBase


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBlindsBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTBlindsBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::_CalcFullBoundsHorizontalBands
//
//------------------------------------------------------------------------------
HRESULT
CDXTBlindsBase::_CalcFullBoundsHorizontalBands(long lBandHeight)
{
    HRESULT     hr              = S_OK;
    long        lBandUnCovered = lBandHeight - m_lCurBandCover;
    RECT        rc;
    CDirtyBnds  dbnds;

    rc.left     = 0;
    rc.top      = 0;
    rc.right    = m_sizeInput.cx;
    rc.bottom   = 0;

    // Note: Some of the bounds may include areas outside the input surface
    //       area.  This is OK because the bounds will be clipped to the 
    //       appropriate size in the WorkProc.

    while (rc.bottom < m_sizeInput.cy)
    {
        // Top portion of band.

        if (DOWN == m_eDirection)
        {
            rc.bottom       = rc.top + m_lCurBandCover;
            dbnds.ulInput   = 1;
        }
        else
        {
            rc.bottom       = rc.top + lBandUnCovered;
            dbnds.ulInput   = 0;
        }

        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        // Bottom portion of band.

        rc.top = rc.bottom;

        if (DOWN == m_eDirection)
        {
            rc.bottom       = rc.top + lBandUnCovered;
            dbnds.ulInput   = 0;
        }
        else
        {
            rc.bottom       = rc.top + m_lCurBandCover;
            dbnds.ulInput   = 1;
        }

        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        rc.top      = rc.bottom;
    }

done:

    return hr;
}
//  CDXTBlindsBase::_CalcFullBoundsHorizontalBands


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::_CalcFullBoundsVerticalBands
//
//------------------------------------------------------------------------------
HRESULT
CDXTBlindsBase::_CalcFullBoundsVerticalBands(long lBandWidth)
{
    HRESULT     hr              = S_OK;
    long        lBandUnCovered  = lBandWidth - m_lCurBandCover;
    RECT        rc;
    CDirtyBnds  dbnds;

    rc.left     = 0;
    rc.top      = 0;
    rc.right    = 0;
    rc.bottom   = m_sizeInput.cy;

    // Note: Some of the bounds may include areas outside the input surface
    //       area.  This is OK because the bounds will be clipped to the 
    //       appropriate size in the WorkProc.

    while (rc.right < m_sizeInput.cx)
    {
        // Left portion of band.

        if (RIGHT == m_eDirection)
        {
            rc.right        = rc.left + m_lCurBandCover;
            dbnds.ulInput   = 1;
        }
        else
        {
            rc.right        = rc.left + lBandUnCovered;
            dbnds.ulInput   = 0;
        }

        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        // Right portion of band.

        rc.left = rc.right;

        if (RIGHT == m_eDirection)
        {
            rc.right        = rc.left + lBandUnCovered;
            dbnds.ulInput   = 0;
        }
        else
        {
            rc.right        = rc.left + m_lCurBandCover;
            dbnds.ulInput   = 1;
        }

        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        rc.left = rc.right;
    }

done:

    return hr;
}
//  CDXTBlindsBase::_CalcFullBoundsVerticalBands


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::_CalcOptBoundsHorizontalBands
//
//------------------------------------------------------------------------------
HRESULT
CDXTBlindsBase::_CalcOptBoundsHorizontalBands(long lBandHeight)
{
    HRESULT     hr      = S_OK;
    RECT        rc;
    CDirtyBnds  dbnds;

    rc.left     = 0;
    rc.right    = m_sizeInput.cx;

    rc.top      = min(m_lPrevBandCover, m_lCurBandCover);
    rc.bottom   = max(m_lPrevBandCover, m_lCurBandCover) + 1;

    // If we're going up, vertically mirror bounds in band.

    if (UP == m_eDirection)
    {
        long lTopTemp = rc.top;

        rc.top      = (lBandHeight - rc.bottom) + 1;
        rc.bottom   = (lBandHeight - lTopTemp)  + 1;
    }

    if (m_lCurBandCover > m_lPrevBandCover)
    {
        dbnds.ulInput = 1;
    }
    else
    {
        dbnds.ulInput = 0;
    }

    // Note: Some of the bounds may include areas outside the input surface
    //       area.  This is OK because the bounds will be clipped to the 
    //       appropriate size in the WorkProc.

    while (rc.top < m_sizeInput.cy)
    {
        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        rc.top      += lBandHeight;
        rc.bottom   += lBandHeight;
    }

done:

    return hr;
}
//  CDXTBlindsBase::_CalcOptBoundsHorizontalBands


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::_CalcOptBoundsVerticalBands
//
//------------------------------------------------------------------------------
HRESULT
CDXTBlindsBase::_CalcOptBoundsVerticalBands(long lBandWidth)
{
    HRESULT     hr      = S_OK;
    RECT        rc;
    CDirtyBnds  dbnds;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    rc.left     = min(m_lPrevBandCover, m_lCurBandCover);
    rc.right    = max(m_lPrevBandCover, m_lCurBandCover) + 1;

    // If we're going left, horizontally mirror bounds in band.

    if (LEFT == m_eDirection)
    {
        long lLeftTemp = rc.left;

        rc.left     = (lBandWidth - rc.right)  + 1;
        rc.right    = (lBandWidth - lLeftTemp) + 1;
    }

    if (m_lCurBandCover > m_lPrevBandCover)
    {
        dbnds.ulInput = 1;
    }
    else
    {
        dbnds.ulInput = 0;
    }

    // Note: Some of the bounds may include areas outside the input surface
    //       area.  This is OK because the bounds will be clipped to the 
    //       appropriate size in the WorkProc.

    while (rc.left < m_sizeInput.cx)
    {
        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        rc.left     += lBandWidth;
        rc.right    += lBandWidth;
    }

done:

    return hr;
}
//  CDXTBlindsBase::_CalcOptBoundsVerticalBands


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBlindsBase::OnSetup(DWORD dwFlags)
{
    HRESULT     hr      = S_OK;
    CDXDBnds    bndsIn;
    
    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsIn.GetXYSize(m_sizeInput);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
// CDXTBlindsBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTBlindsBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                               ULONG aInIndex[], BYTE aWeight[])
{
    long lBandHeight = (m_sizeInput.cy + m_cBands - 1) / m_cBands;
    long lBandCover = (long)(lBandHeight * m_Progress + 0.5);
       
    if ((OutPoint.Top() % lBandHeight) < lBandCover)
    {
        aInIndex[0] = 1;
    }
    else
    {
        aInIndex[0] = 0;
    }

    ulInToTest = 1;
    aWeight[0] = 255;
}
//  CDXTBlindsBase::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBlindsBase::OnInitInstData(CDXTWorkInfoNTo1 & WorkInfo, ULONG & ulNumBandsToDo)
{
    HRESULT hr          = S_OK;
    long    lBandSize   = 0;

    if ((UP == m_eDirection) || (DOWN == m_eDirection)) // Horizontal bands.
    {
        lBandSize = (m_sizeInput.cy + m_cBands - 1) / m_cBands;
    }
    else // Vertical bands.
    {
        lBandSize = (m_sizeInput.cx + m_cBands - 1) / m_cBands;
    }

    // Reset count of dirty bounds.

    m_cbndsDirty = 0;

    // Calculate lines of each band that are covered by input B for this
    // execute.

    m_lCurBandCover = (long)((float)lBandSize * m_Progress + 0.5F);

    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize 
        || !m_fOptimizationPossible)
    {
        if ((0 == m_lCurBandCover) || (lBandSize == m_lCurBandCover))
        {
            // If all of the band is taken up with one input, just fill the
            // whole output with that input.

            RECT        rc;
            CDirtyBnds  dbnds;

            rc.top      = 0;
            rc.left     = 0;
            rc.bottom   = m_sizeInput.cy;
            rc.right    = m_sizeInput.cx;

            dbnds.bnds.SetXYRect(rc);

            if (0 == m_lCurBandCover)
            {
                dbnds.ulInput = 0;  // Fill with input A.
            }
            else
            {
                dbnds.ulInput = 1;  // Fill with input B.
            }

            hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

            if (FAILED(hr))
            {
                goto done;
            }

            m_cbndsDirty++;
        }
        else
        {
            if ((UP == m_eDirection) || (DOWN == m_eDirection))
            {
                hr = _CalcFullBoundsHorizontalBands(lBandSize);
            }
            else
            {
                hr = _CalcFullBoundsVerticalBands(lBandSize);
            }
        }
    }
    else
    {
        // We're not blending with output, so we can call the functions 
        // that will generate bounds that only cover the dirty areas
        // of the output surface.

        // If the stretch width hasn't changed, nothing needs to be updated.

        if (m_lCurBandCover == m_lPrevBandCover)
        {
            goto done;
        }

        if ((UP == m_eDirection) || (DOWN == m_eDirection))
        {
            hr = _CalcOptBoundsHorizontalBands(lBandSize);
        }
        else
        {
            hr = _CalcOptBoundsVerticalBands(lBandSize);
        }
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WorkInfo.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WorkInfo.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTBlindsBase::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBlindsBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    DWORD   dwFlags         = 0;
    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    for (ULONG i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;
        CDirtyBnds  dbnds;

        hr = m_dabndsDirty.GetItem(dbnds, i);

        if (FAILED(hr))
        {
            goto done;
        }

        if (bndsSrc.IntersectBounds(WI.DoBnds, dbnds.bnds))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            hr = DXBitBlt(OutputSurface(), bndsDest,
                          InputSurface(dbnds.ulInput), bndsSrc,
                          dwFlags, INFINITE);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTBlindsBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTBlindsBase::OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo)
{
    m_lPrevBandCover = m_lCurBandCover;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTBlindsBase::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::get_bands, ICrBlinds
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTBlindsBase::get_bands(short * pVal)
{
   HRESULT hr = S_OK;

    if (!pVal)
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_cBands;
    }

    return hr;
}
//  CDXTBlindsBase::get_bands, ICrBlinds


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::put_bands, ICrBlinds
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTBlindsBase::put_bands(short newVal)
{
    if (newVal > 0 && newVal < 101)
    {
        if (m_cBands != newVal)
        {
            Lock();
            m_cBands = newVal;
            SetDirty();
            Unlock();
        }
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}
//  CDXTBlindsBase::put_bands, ICrBlinds

//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::get_Direction, ICrBlinds2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBlindsBase::get_Direction(BSTR * pbstrDirection)
{
    HRESULT hr = S_OK;

    if (NULL == pbstrDirection)
    {
        hr = E_POINTER;

        goto done;
    }

    if (*pbstrDirection != NULL)
    {
        hr = E_INVALIDARG;
        
        goto done;
    }

    _ASSERT(m_eDirection < DIRECTION_MAX);

    *pbstrDirection = SysAllocString(g_astrDirection[m_eDirection]);

    if (NULL == *pbstrDirection)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    if (FAILED(hr) && *pbstrDirection)
    {
        SysFreeString(*pbstrDirection);
    }

    return hr;
}
//  CDXTBlindsBase::get_Direction, ICrBlinds2


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::put_Direction, ICrBlinds2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBlindsBase::put_Direction(BSTR bstrDirection)
{
    HRESULT hr              = S_OK;
    int     nNewDirection   = 0;

    if (NULL == bstrDirection)
    {
        hr = E_POINTER;

        goto done;
    }

    while (nNewDirection < (int)DIRECTION_MAX)
    {
        if (!_wcsicmp(bstrDirection, g_astrDirection[nNewDirection]))
        {
            break;
        }

        nNewDirection++;
    }

    if ((int)DIRECTION_MAX == nNewDirection)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (nNewDirection != (int)m_eDirection)
    {
        Lock();

        m_eDirection = (DIRECTION)nNewDirection;

        SetDirty();

        Unlock();
    }

done:

    return hr;
}
//  CDXTBlindsBase::put_Direction, ICrBlinds2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\blinds.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:            blinds.h
//
// Created:             06/24/98
//
// Author:              phillu
//
// Discription:         This is the header file for the CrBlinds transformation
//
// Change History:
// 06/24/98 PhilLu      Developed 1.0 version for Chromeffects
// 11/04/98 PaulNash    Moved from DT 1.0 codebase to IE5/NT5 DXTMSFT.DLL
// 05/19/99 a-matcal    Optimization.
// 09/25/99 a-matcal    Inherit from ICRBlinds2.
// 10/22/99 a-matcal    Changed CBlinds class to CDXTBlindsBase and created two
//                      new classes CDXTBlinds and CDXTBlindsOpt to represent
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRBLINDS_H_
#define __CRBLINDS_H_

#include "resource.h"

// gridbase.h included for dynamic array template class, and the CDirtyBnds
// class for holding a single set of dirty bounds and its corresponding input
// index.

#include "gridbase.h"  




//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase class
//
//------------------------------------------------------------------------------
class ATL_NO_VTABLE CDXTBlindsBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrBlinds2, &IID_ICrBlinds2, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTBlindsBase>,
    public IObjectSafetyImpl2<CDXTBlindsBase>,
    public ISpecifyPropertyPagesImpl<CDXTBlindsBase>
{
private:

    typedef enum {
        UP = 0,
        DOWN,
        LEFT,
        RIGHT,
        DIRECTION_MAX
    } DIRECTION;

    short       m_cBands;
    long        m_lCurBandCover;
    long        m_lPrevBandCover;
    SIZE        m_sizeInput;
    ULONG       m_cbndsDirty;
    DIRECTION   m_eDirection;

    CDynArray<CDirtyBnds>   m_dabndsDirty;

    CComPtr<IUnknown>       m_cpUnkMarshaler;

    HRESULT _CalcFullBoundsHorizontalBands(long lBandHeight);
    HRESULT _CalcOptBoundsHorizontalBands(long lBandHeight);

    HRESULT _CalcFullBoundsVerticalBands(long lBandWidth);
    HRESULT _CalcOptBoundsVerticalBands(long lBandWidth);

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

public:

    CDXTBlindsBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTBlindsBase)
        COM_INTERFACE_ENTRY(ICrBlinds2)
        COM_INTERFACE_ENTRY(ICrBlinds)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTBlindsBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTBlindsBase)
        PROP_ENTRY("bands",     DISPID_CRBLINDS_BANDS,      CLSID_CrBlindPP)
        PROP_ENTRY("direction", DISPID_CRBLINDS_DIRECTION,  CLSID_CrBlindPP)
        PROP_PAGE(CLSID_CrBlindPP)
    END_PROPERTY_MAP()

    HRESULT FinalConstruct();

    // CDXTBaseNTo1 overrides.

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, 
                                  ULONG & ulInToTest, ULONG aInIndex[], 
                                  BYTE aWeight[]);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WorkInfo, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo);

    // ICrBlinds properties.

    STDMETHOD(get_bands)(/*[out, retval]*/ short *pVal);
    STDMETHOD(put_bands)(/*[in]*/ short newVal);

    // ICrBlinds2 properties.

    STDMETHOD(get_Direction)(BSTR * pbstrDirection);
    STDMETHOD(put_Direction)(BSTR bstrDirection);

    // IDXEffect properties.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTBlinds :
    public CDXTBlindsBase,
    public CComCoClass<CDXTBlinds, &CLSID_CrBlinds>,
    public IPersistStorageImpl<CDXTBlinds>,
    public IPersistPropertyBagImpl<CDXTBlinds>
{
public:

    CDXTBlinds()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTBLINDS)
    DECLARE_POLY_AGGREGATABLE(CDXTBlinds)

    BEGIN_COM_MAP(CDXTBlinds)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTBlindsBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTBlindsOpt :
    public CDXTBlindsBase,
    public CComCoClass<CDXTBlindsOpt, &CLSID_DXTBlinds>,
    public IPersistStorageImpl<CDXTBlindsOpt>,
    public IPersistPropertyBagImpl<CDXTBlindsOpt>
{
public:

    CDXTBlindsOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTBLINDSOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTBlindsOpt)

    BEGIN_COM_MAP(CDXTBlindsOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTBlindsBase)
    END_COM_MAP()
};

#endif //__CRBLINDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\checkerboard.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
//  FileName:   checkerboard.cpp
//
//  Overview:   CheckerBoard transform.
//
//  Change History:
//  1999/09/16  a-matcal    Created.
//  1999/09/25  a-matcal    Fixed bug where all squares weren't getting updated
//                          in horizontal cases.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "checkerboard.h"

#define VERTICAL_MOVEMENT ((UP == m_eDirection) || (DOWN == m_eDirection))
#define REVERSE_MOVEMENT  ((UP == m_eDirection) || (LEFT == m_eDirection))

static const OLECHAR * g_astrDirection[] = {
    L"up",
    L"down",
    L"left",
    L"right"
};

#if DBG == 1
static s_ulMaxImageBands = 0;
#endif




//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::CDXTCheckerBoard
//
//------------------------------------------------------------------------------
CDXTCheckerBoard::CDXTCheckerBoard() :
    m_eDirection(RIGHT),
    m_nSquaresX(12),
    m_nSquaresY(10)
{
    m_sizeInput.cx      = 0;
    m_sizeInput.cy      = 0;

    // Base class members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;

#if DBG == 1
    if (s_ulMaxImageBands)
    {
        m_ulMaxImageBands = s_ulMaxImageBands;
    }
#endif
}
//  CDXTCheckerBoard::CDXTCheckerBoard


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTCheckerBoard::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTCheckerBoard::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTCheckerBoard::OnSetup(DWORD dwFlags)
{
    HRESULT     hr  = S_OK;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsInput.GetXYSize(m_sizeInput);

done:

    return hr;
} 
//  CDXTCheckerBoard::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTCheckerBoard::OnGetSurfacePickOrder(const CDXDBnds & OutPoint,
                                        ULONG & ulInToTest, ULONG aInIndex[], 
                                        BYTE aWeight[])
{
    BRICKINFO   brickinfo;

    _CalcBrickInfo(brickinfo);

    // Assume Input A will be picked.

    aInIndex[0] = 0;

    // Calculate correct picked input.

    if (VERTICAL_MOVEMENT)
    {
        // Vertical movement.  Translate the y coordinate to brick coordinates.

        long y = OutPoint.Bottom();
        
        // If this is in one of the columns of offset bricks, compensate for
        // brick offset.

        if ((OutPoint.Right() / brickinfo.size.cx) % 2)
        {
            // Subtract the brick offset and add one brick height to guarantee
            // a positive value.

            y = y - brickinfo.nBrickOffset + brickinfo.size.cy;
        }

        // Normalize to brick coordinates.

        y = y % brickinfo.size.cy;

        if ((y >= brickinfo.rcInputB.top) && (y < brickinfo.rcInputB.bottom))
        {
            aInIndex[0] = 1; // Change to Input B.
        }
    }
    else
    {
        // Horizontal movement.  Translate the x coordinate to brick 
        // coordinates.

        long x = OutPoint.Right();

        // If the output point is in one of the rows of offset bricks,
        // compensate for brick offset.

        if ((OutPoint.Bottom() / brickinfo.size.cy) % 2)
        {
            // Subtract the brick offset and add one brick width to guarantee
            // a positive value.

            x = x - brickinfo.nBrickOffset + brickinfo.size.cx;
        }

        // Normalize to birck coordinates.

        x = x % brickinfo.size.cx;

        if ((x >= brickinfo.rcInputB.left) && (x < brickinfo.rcInputB.right))
        {
            aInIndex[0] = 1; // Change to Input B.
        }
    }

    // Set additional output parameters.  There will always be only one input to
    // test and it will therefore be weighted as 255.

    ulInToTest  = 1;
    aWeight[0]  = 255;
}
//  CDXTCheckerBoard::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTCheckerBoard::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    if (VERTICAL_MOVEMENT)
    {
        hr = _WorkProcForVerticalBricks(WI, pbContinue, dwFlags);
    }
    else
    {
        hr = _WorkProcForHorizontalBricks(WI, pbContinue, dwFlags);
    }

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTCheckerBoard::WorkProc, CDXBaseNTo1


STDMETHODIMP
CDXTCheckerBoard::_WorkProcForVerticalBricks(const CDXTWorkInfoNTo1 & WI, 
                                             BOOL * pbContinue,
                                             DWORD & dwFlags)
{
    HRESULT hr = S_OK;

    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();
    long    cBricksX        = 0;
    long    cBricksY        = 0;
    long    x               = 0;
    long    y               = 0;

    CDXDBnds    bndsBrickA;
    CDXDBnds    bndsBrickB;

    BRICKINFO   brickinfo;

    _CalcBrickInfo(brickinfo);

    // How many whole bricks fit, then add one to columns and two to rows (one 
    // for each side of centered offset columns.)

    cBricksX = (m_sizeInput.cx / brickinfo.size.cx) + 1;
    cBricksY = (m_sizeInput.cy / brickinfo.size.cy) + 2;

    bndsBrickA.SetXYRect(brickinfo.rcInputA);
    bndsBrickB.SetXYRect(brickinfo.rcInputB);

    // Blit Input A portion of bricks.

    if (!bndsBrickA.BoundsAreEmpty())
    {
        for (x = 0; x < cBricksX; x++)
        {
            CDXDBnds bndsSrcA;

            // Calculate source bounds.

            bndsSrcA = bndsBrickA;
            bndsSrcA.Offset(x * brickinfo.size.cx, 0, 0, 0);

            // Use brick offset if this is an odd column.

            if (x & 1)
            {
                bndsSrcA.Offset(0, brickinfo.nBrickOffset - brickinfo.size.cy,
                                0, 0);
            }

            for (y = 0; y < cBricksY; y++)
            {
                CDXDBnds bndsIntersect;
                CDXDBnds bndsDest;

                // Intersect bounds with DoBnds bounds so they're valid.

                bndsIntersect.IntersectBounds(bndsSrcA, WI.DoBnds);

                // Move bounds down one brick for next iteration.

                bndsSrcA.Offset(0, brickinfo.size.cy, 0, 0);

                if (bndsIntersect.BoundsAreEmpty())
                {
                    continue;
                }

                bndsDest = bndsIntersect;
                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(0), bndsIntersect,
                              dwFlags, INFINITE);

                if (FAILED(hr))
                {
                    goto done;
                }
            }

        }
    }

    // Blit Input B portion of bricks.

    if (!bndsBrickB.BoundsAreEmpty())
    {
        for (x = 0; x < cBricksX; x++)
        {
            CDXDBnds bndsSrcB;

            // Calculate source bounds.

            bndsSrcB = bndsBrickB;
            bndsSrcB.Offset(x * brickinfo.size.cx, 0, 0, 0);

            // Use brick offset if this is an odd column.

            if (x & 1)
            {
                bndsSrcB.Offset(0, brickinfo.nBrickOffset - brickinfo.size.cy,
                                0, 0);
            }

            for (y = 0; y < cBricksY; y++)
            {
                CDXDBnds bndsIntersect;
                CDXDBnds bndsDest;

                // Intersect bounds with DoBnds bounds so they're valid.

                bndsIntersect.IntersectBounds(bndsSrcB, WI.DoBnds);

                // Move bounds down one brick for next iteration.

                bndsSrcB.Offset(0, brickinfo.size.cy, 0, 0);

                if (bndsIntersect.BoundsAreEmpty())
                {
                    continue;
                }

                bndsDest = bndsIntersect;
                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(1), bndsIntersect,
                              dwFlags, INFINITE);

                if (FAILED(hr))
                {
                    goto done;
                }
            }

        }
    }

done:

    return hr;
}


STDMETHODIMP
CDXTCheckerBoard::_WorkProcForHorizontalBricks(const CDXTWorkInfoNTo1 & WI, 
                                               BOOL * pbContinue,
                                               DWORD & dwFlags)
{
    HRESULT hr = S_OK;

    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();
    long    cBricksX        = 0;
    long    cBricksY        = 0;
    long    x               = 0;
    long    y               = 0;

    CDXDBnds    bndsBrickA;
    CDXDBnds    bndsBrickB;

    BRICKINFO   brickinfo;

    _CalcBrickInfo(brickinfo);

    // How many whole bricks fit, then add one for rows and two for columns (one
    // for each side of centered offset rows.)

    cBricksX = (m_sizeInput.cx / brickinfo.size.cx) + 2;
    cBricksY = (m_sizeInput.cy / brickinfo.size.cy) + 1;

    bndsBrickA.SetXYRect(brickinfo.rcInputA);
    bndsBrickB.SetXYRect(brickinfo.rcInputB);

    // Blit Input A portion of bricks.

    if (!bndsBrickA.BoundsAreEmpty())
    {
        for (y = 0; y < cBricksY; y++)
        {
            CDXDBnds bndsSrcA;

            // Calculate source bounds.

            bndsSrcA = bndsBrickA;
            bndsSrcA.Offset(0, y * brickinfo.size.cy, 0, 0);

            // Use brick offset if this is an odd row.

            if (y & 1)
            {
                bndsSrcA.Offset(brickinfo.nBrickOffset - brickinfo.size.cx, 0,
                                0, 0);
            }

            for (x = 0; x < cBricksX; x++)
            {
                CDXDBnds bndsIntersect;
                CDXDBnds bndsDest;

                // Intersect bounds with DoBnds bounds so they're valid.

                bndsIntersect.IntersectBounds(bndsSrcA, WI.DoBnds);

                // Move bounds down one brick for next iteration.

                bndsSrcA.Offset(brickinfo.size.cx, 0, 0, 0);

                if (bndsIntersect.BoundsAreEmpty())
                {
                    continue;
                }

                bndsDest = bndsIntersect;
                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(0), bndsIntersect,
                              dwFlags, INFINITE);

                if (FAILED(hr))
                {
                    goto done;
                }
            }

        }
    }

    // Blit Input B portion of bricks.

    if (!bndsBrickB.BoundsAreEmpty())
    {
        for (y = 0; y < cBricksY; y++)
        {
            CDXDBnds bndsSrcB;

            // Calculate source bounds.

            bndsSrcB = bndsBrickB;
            bndsSrcB.Offset(0, y * brickinfo.size.cy, 0, 0);

            // Use brick offset if this is an odd row.

            if (y & 1)
            {
                bndsSrcB.Offset(brickinfo.nBrickOffset - brickinfo.size.cx, 0,
                                0, 0);
            }

            for (x = 0; x < cBricksX; x++)
            {
                CDXDBnds bndsIntersect;
                CDXDBnds bndsDest;

                // Intersect bounds with DoBnds bounds so they're valid.

                bndsIntersect.IntersectBounds(bndsSrcB, WI.DoBnds);

                // Move bounds down one brick for next iteration.

                bndsSrcB.Offset(brickinfo.size.cx, 0, 0, 0);

                if (bndsIntersect.BoundsAreEmpty())
                {
                    continue;
                }

                bndsDest = bndsIntersect;
                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(1), bndsIntersect,
                              dwFlags, INFINITE);

                if (FAILED(hr))
                {
                    goto done;
                }
            }

        }
    }

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::get_Direction, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::get_Direction(BSTR * pbstrDirection)
{
    HRESULT hr = S_OK;

    // Parameter validation.

    if (NULL == pbstrDirection)
    {
        hr = E_POINTER;

        goto done;
    }

    if (*pbstrDirection != NULL)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    // Allocate BSTR representing checkerboard direction.

    _ASSERT(m_eDirection < DIRECTION_MAX);

    *pbstrDirection = SysAllocString(g_astrDirection[m_eDirection]);

    if (NULL == *pbstrDirection)
    {
        hr = E_OUTOFMEMORY;
    }

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::put_Direction, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::put_Direction(BSTR bstrDirection)
{
    HRESULT hr              = S_OK;
    int     nNewDirection   = 0;

    if (NULL == bstrDirection)
    {
        hr = E_POINTER;

        goto done;
    }

    while (nNewDirection < (int)DIRECTION_MAX)
    {
        if (!_wcsicmp(bstrDirection, g_astrDirection[nNewDirection]))
        {
            break;
        }

        nNewDirection++;
    }

    if ((int)DIRECTION_MAX == nNewDirection)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (nNewDirection != (int)m_eDirection)
    {
        Lock();

        m_eDirection = (DIRECTION)nNewDirection;

        SetDirty();

        Unlock();
    }

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::get_SquaresX, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::get_SquaresX(int * pnSquaresX)
{
    HRESULT hr = S_OK;

    if (NULL == pnSquaresX)
    {
        hr = E_POINTER;

        goto done;
    }

    *pnSquaresX = m_nSquaresX;

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::put_SquaresX, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::put_SquaresX(int nSquaresX)
{
    HRESULT hr = S_OK;

    if (nSquaresX < 2)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (nSquaresX != m_nSquaresX)
    {
        m_nSquaresX = nSquaresX;

        SetDirty();
    }

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::get_SquaresY, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::get_SquaresY(int * pnSquaresY)
{
    HRESULT hr = S_OK;

    if (NULL == pnSquaresY)
    {
        hr = E_POINTER;

        goto done;
    }

    *pnSquaresY = m_nSquaresY;

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::put_SquaresY, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::put_SquaresY(int nSquaresY)
{
    HRESULT hr = S_OK;

    if (nSquaresY < 2)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (nSquaresY != m_nSquaresY)
    {
        m_nSquaresY = nSquaresY;

        SetDirty();
    }

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::_CalcBrickInfo
//
//------------------------------------------------------------------------------
void
CDXTCheckerBoard::_CalcBrickInfo(BRICKINFO & brickinfo)
{
    // Each square of the checkerboard will be measured in whole pixel units.
    // If the image is 500 pixels wide, and the user specified that there should
    // be 1000 squares horizontally, each square will set to 1 pixel wide and
    // there will be effectively only 500 squares in the x direction instead of
    // 1000.

    // Calculate square size.

    brickinfo.size.cx = m_sizeInput.cx / m_nSquaresX;

    if ((brickinfo.size.cx * m_nSquaresX) < m_sizeInput.cx)
    {
        brickinfo.size.cx++;
    }

    brickinfo.size.cy = m_sizeInput.cy / m_nSquaresY;

    if ((brickinfo.size.cy * m_nSquaresY) < m_sizeInput.cy)
    {
        brickinfo.size.cy++;
    }

    // Calculate brick size, brick offset, and portion of brick showing input B.

    if (VERTICAL_MOVEMENT)
    {
        long nBrickProgress     = 0;

        brickinfo.nBrickOffset  = brickinfo.size.cy;
        brickinfo.size.cy       = brickinfo.size.cy * 2;

        nBrickProgress = (long)(((float)brickinfo.size.cy + 0.5F) * m_Progress);

        // Calculate portion of brick showing input B.

        brickinfo.rcInputA.left   = 0;
        brickinfo.rcInputA.right  = brickinfo.size.cx;
        brickinfo.rcInputB.left   = 0;
        brickinfo.rcInputB.right  = brickinfo.size.cx;

        if (REVERSE_MOVEMENT)
        {
            brickinfo.rcInputB.top      = brickinfo.size.cy - nBrickProgress;
            brickinfo.rcInputB.bottom   = brickinfo.size.cy;

            brickinfo.rcInputA.top      = 0;
            brickinfo.rcInputA.bottom   = brickinfo.rcInputB.top;
        }
        else
        {
            brickinfo.rcInputB.top      = 0;
            brickinfo.rcInputB.bottom   = nBrickProgress;

            brickinfo.rcInputA.top      = brickinfo.rcInputB.bottom;
            brickinfo.rcInputA.bottom   = brickinfo.size.cy;
        }
    }
    else // Horizontal movement.
    {
        long nBrickProgress     = 0;

        brickinfo.nBrickOffset  = brickinfo.size.cx;
        brickinfo.size.cx       = brickinfo.size.cx * 2;

        nBrickProgress = (long)(((float)brickinfo.size.cx + 0.5F) * m_Progress);

        // Calculate portion of brick showing input B.

        brickinfo.rcInputA.top      = 0;
        brickinfo.rcInputA.bottom   = brickinfo.size.cy;
        brickinfo.rcInputB.top      = 0;
        brickinfo.rcInputB.bottom   = brickinfo.size.cy;

        if (REVERSE_MOVEMENT)
        {
            brickinfo.rcInputB.left     = brickinfo.size.cx - nBrickProgress;
            brickinfo.rcInputB.right    = brickinfo.size.cx;

            brickinfo.rcInputA.left     = 0;
            brickinfo.rcInputA.right    = brickinfo.rcInputB.left;
        }
        else
        {
            brickinfo.rcInputB.left     = 0;
            brickinfo.rcInputB.right    = nBrickProgress;

            brickinfo.rcInputA.left     = brickinfo.rcInputB.right;
            brickinfo.rcInputA.right    = brickinfo.size.cx;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\checkerboard.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:   checkerboard.h
//
//  Overview:   CheckerBoard transform.
//
//  Change History:
//  1999/09/16  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef __CHECKERBOARD_H_
#define __CHECKERBOARD_H_

#include "resource.h"   

typedef struct _BRICKINFO {
    SIZE    size;           // The size of each brick in pixels.
    RECT    rcInputA;       // The portion of each brick showing input A.
    RECT    rcInputB;       // The portion of each brick showing input B.
    long    nBrickOffset;   // The number of pixels to offset the bricks in the
                            // odd rows or columns.
} BRICKINFO;




class ATL_NO_VTABLE CDXTCheckerBoard : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTCheckerBoard, &CLSID_DXTCheckerBoard>,
    public IDispatchImpl<IDXTCheckerBoard, &IID_IDXTCheckerBoard, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTCheckerBoard>,
    public IObjectSafetyImpl2<CDXTCheckerBoard>,
    public IPersistStorageImpl<CDXTCheckerBoard>,
    public IPersistPropertyBagImpl<CDXTCheckerBoard>
{
private:

    typedef enum {
        UP = 0,
        DOWN,
        LEFT,
        RIGHT,
        DIRECTION_MAX
    } DIRECTION;

    DIRECTION                   m_eDirection;

    int                         m_nSquaresX;
    int                         m_nSquaresY;

    SIZE                        m_sizeInput;

    CComPtr<IUnknown>           m_cpUnkMarshaler;

    // Helpers.

    void _CalcBrickInfo(BRICKINFO & brickinfo);

    STDMETHOD(_WorkProcForVerticalBricks)(const CDXTWorkInfoNTo1 & WI, 
                                          BOOL * pbContinue,
                                          DWORD & dwFlags);
    STDMETHOD(_WorkProcForHorizontalBricks)(const CDXTWorkInfoNTo1 & WI, 
                                            BOOL * pbContinue,
                                            DWORD & dwFlags);

public:

    CDXTCheckerBoard();

    DECLARE_POLY_AGGREGATABLE(CDXTCheckerBoard)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTCHECKERBOARD)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTCheckerBoard)
        COM_INTERFACE_ENTRY(IDXTCheckerBoard)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTCheckerBoard>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTCheckerBoard)
        PROP_ENTRY("Direction", 1,  CLSID_DXTCheckerBoardPP)
        PROP_ENTRY("SquaresX",  2,  CLSID_DXTCheckerBoardPP)
        PROP_ENTRY("SquaresY",  3,  CLSID_DXTCheckerBoardPP)

        PROP_PAGE(CLSID_DXTCheckerBoardPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXTCheckerBoard properties.

    STDMETHOD(get_Direction)(BSTR * pbstrDirection);
    STDMETHOD(put_Direction)(BSTR bstrDirection);
    STDMETHOD(get_SquaresX)(int * pnSquaresX);
    STDMETHOD(put_SquaresX)(int nSquaresX);
    STDMETHOD(get_SquaresY)(int * pnSquaresY);
    STDMETHOD(put_SquaresY)(int nSquaresY);

    // IDXEffect methods.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__CHECKERBOARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\chroma.cpp ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:        chroma.cpp
//
// Created:         1998/10/01
//
// Author:          MikeAr
//
// Discription:     This file implements the Chroma transform.
//
// 1998/10/01   MikeAr      Created.
// 1998/11/09   mcalkins    Moved to dxtmsft.dll.
// 1998/12/11   PaulNash    Remove OLE_COLOR, use VARIANT as VT_UI4 or 
//                          VT_BSTR.
// 2000/06/19   mcalkins    Store color as BSTR, return BSTR from get_color.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "dxtmsft.h"
#include "dxclrhlp.h"
#include "filterhelpers.h"
#include "chroma.h"




//+-----------------------------------------------------------------------------
//
//  Method: CChroma::CChroma
//
//------------------------------------------------------------------------------
CChroma::CChroma() :
    m_clrChromaColor(0xFF0000FF)
{
    VariantInit(&m_varChromaColor);

    m_sizeInput.cx      = 0;
    m_sizeInput.cy      = 0;

    // CDXBaseNTo1 base class members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
}
//  Method: CChroma::CChroma


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::~CChroma
//
//------------------------------------------------------------------------------
CChroma::~CChroma()
{
    ::VariantClear(&m_varChromaColor);
}
//  Method: CChroma::~CChroma


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT
CChroma::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_spUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    _ASSERT(VT_EMPTY == m_varChromaColor.vt);

    m_varChromaColor.bstrVal = ::SysAllocString(L"blue");

    if (NULL == m_varChromaColor.bstrVal)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    m_varChromaColor.vt = VT_BSTR;

done:

    return hr;
}
//  Method: CChroma::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::put_Color, IDXTChroma
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CChroma::put_Color(VARIANT newVal)
{
    HRESULT     hr          = S_OK;
    DWORD       dwColor     = 0x00000000;
    BSTR        bstrTemp    = NULL;

    hr = FilterHelper_GetColorFromVARIANT(newVal, &dwColor, &bstrTemp);

    if (FAILED(hr))
    {
        goto done;
    }

    // The filter helper always allocates a BSTR because in many of the
    // DXTransforms property methods it's exactly what we want, but not here.

    SysFreeString(bstrTemp);

    if (!(dwColor & 0xFF000000))
    {
        dwColor |= 0xFF000000;
    }

    if (m_clrChromaColor != dwColor)
    {
        m_clrChromaColor = dwColor;
        SetDirty();
    }

    hr = ::VariantClear(&m_varChromaColor);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = ::VariantCopy(&m_varChromaColor, &newVal);

    if (FAILED(hr))
    {
        goto done;
    }

done:

    return S_OK;
}
//  Method: CChroma::put_Color, IDXTChroma


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::get_Color, IDXTChroma
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CChroma::get_Color(VARIANT * pVal)
{
    HRESULT hr = S_OK;

    if (NULL == pVal)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = ::VariantClear(pVal);

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = ::VariantCopy(pVal, &m_varChromaColor);

    if (FAILED(hr))
    {
        goto done;
    }
    
done:

    return hr;
}
//  Method: CChroma::get_Color, IDXTChroma


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CChroma::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                       CDXDVec & InVec)
{
    HRESULT                 hr                  = S_OK;
    DXSAMPLE                sample              = 0x00000000;
    CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

    if (ulInputIndex != 0)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (!InputSurface(0))
    {
        hr = E_UNEXPECTED;

        goto done;
    }

    if (   (OutPoint[DXB_X].Min < 0)
        || (OutPoint[DXB_X].Max > m_sizeInput.cx)
        || (OutPoint[DXB_Y].Min < 0)
        || (OutPoint[DXB_Y].Max > m_sizeInput.cy))
    {
        hr = S_FALSE;

        goto done;
    }

    hr = InputSurface(0)->LockSurface(&OutPoint, m_ulLockTimeOut, DXLOCKF_READ,
                                      __uuidof(IDXARGBReadPtr), 
                                      (void **)&spDXARGBReadPtr, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    spDXARGBReadPtr->MoveToRow(0);

    spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

    if (   !sample.Alpha 
        || (sample == (DXSAMPLE)m_clrChromaColor))
    {
        hr = S_FALSE;
    }

done:

    return hr;
}
//  Method: CChroma::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CChroma::OnSetup(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bnds;

    hr = InputSurface(0)->GetBounds(&bnds);

    if (SUCCEEDED(hr))
    {
        bnds.GetXYSize(m_sizeInput);
    }

    return hr;
}
//  Method: CChroma::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CChroma::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing)
{
    HRESULT hr = S_OK;

    const ULONG DoWidth     = WI.DoBnds.Width();
    const ULONG DoHeight    = WI.DoBnds.Height();
    BOOL        bDoOver     = m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT;

    CComPtr<IDXARGBReadWritePtr> pDest;
    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, (void**)&pDest, NULL);

    if (FAILED(hr)) 
        return hr;

    CComPtr<IDXARGBReadPtr> pSrc;
    hr = InputSurface()->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);
    
    if (FAILED(hr)) 
        return hr;

    DXPMSAMPLE*         pBuffer     = NULL;
    BOOL                bDirectCopy = FALSE;
    DXNATIVETYPEINFO    NTI;

    if (OutputSampleFormat() == DXPF_PMARGB32 && (!DoOver()))
    {
        bDirectCopy = TRUE;
    }

    if (bDirectCopy)
    {
        pDest->GetNativeType(&NTI);

        if (NTI.pFirstByte)
        {
            pBuffer = (DXPMSAMPLE *)NTI.pFirstByte;
        }
        else
        {
            bDirectCopy = FALSE;
        }
    }

    if (pBuffer == NULL)
    {
        pBuffer = DXPMSAMPLE_Alloca(DoWidth);
    }

    DXPMSAMPLE* pOverScratch = (DoOver() && OutputSampleFormat() != DXPF_PMARGB32) ?
                                DXPMSAMPLE_Alloca(DoWidth) : NULL;

    //
    //  Set up the dither structure
    //

    DXDITHERDESC dxdd;

    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = pBuffer;
        dxdd.cSamples       = DoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    DXPACKEDRECTDESC prd;

    prd.bPremult    = TRUE;
    prd.lRowPadding = 0;
    prd.rect.top    = 0; 
    prd.rect.bottom = 1;
    prd.rect.left   = 0; 
    prd.rect.right  = DoWidth;

    for (ULONG y = 0; y < DoHeight; y++)
    {
        prd.pSamples = pBuffer;
        pSrc->UnpackRect(&prd);
        prd.rect.top    += 1;
        prd.rect.bottom += 1;

        DWORD v;
        DWORD dwChroma = m_clrChromaColor & 0x00ffffff;

        for (ULONG x = 0; x < DoWidth; x++)
        {
            v = DXUnPreMultSample(pBuffer[x]);
            v &= 0x00ffffff;

            if (v == dwChroma)
            {
                pBuffer[x] = 0;
            }
        }

        if (bDirectCopy)
        {
            pBuffer = (DXPMSAMPLE*)(((BYTE*)pBuffer) + NTI.lPitch);
        }
        else
        {
            if (DoDither())
            {
                DXDitherArray(&dxdd);
                dxdd.y++;
            }

            pDest->MoveToRow(y);

            if (bDoOver)
            {
                //
                //  NOTE:  If any other effect can change alpha, do test here.
                //  The BltFlags which will be 0 if the
                //  source is opqaue.
                //

                if (m_dwBltFlags & DXBOF_DO_OVER)
                {
                    pDest->OverArrayAndMove(pOverScratch, pBuffer, DoWidth);
                }
                else
                {
                    pDest->PackPremultAndMove(pBuffer, DoWidth);
                }
            }
            else
            {
                pDest->PackPremultAndMove(pBuffer, DoWidth);
            }
        }
    }

    return hr;
}
//  Method: CChroma::WorkProc, CDXBaseNTo1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\chroma.h ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:        chroma.h
//
// Created:         1998/10/01
//
// Author:          MikeAr
//
// Discription:     Definition of the Chroma transform.
//
// 1998/10/01   MikeAr      Created.
// 1998/11/09   mcalkins    Moved to dxtmsft.dll.
// 2000/06/19   mcalkins    Keep a bstr version of the chroma color.
//
//------------------------------------------------------------------------------

#ifndef __CHROMA_H_
#define __CHROMA_H_

#include "resource.h" 




class ATL_NO_VTABLE CChroma : 
    public CDXBaseNTo1,
    public CComCoClass<CChroma, &CLSID_DXTChroma>,
    public IDispatchImpl<IDXTChroma, &IID_IDXTChroma, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CChroma>,
    public IPersistStorageImpl<CChroma>,
    public IObjectSafetyImpl2<CChroma>,
    public ISpecifyPropertyPagesImpl<CChroma>,
    public IPersistPropertyBagImpl<CChroma>
{
private:

    CComPtr<IUnknown>   m_spUnkMarshaler;

    DWORD               m_clrChromaColor;
    VARIANT             m_varChromaColor;
    SIZE                m_sizeInput;

public:

    CChroma();
    virtual ~CChroma();

    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_CHROMA)
    DECLARE_POLY_AGGREGATABLE(CChroma)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CChroma)
        COM_INTERFACE_ENTRY(IDXTChroma)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CChroma>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CChroma)
        PROP_ENTRY("Color", 1, CLSID_DXTChromaPP)
        PROP_PAGE(CLSID_DXTChromaPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);

    // IDXTChroma properties.

    STDMETHOD(get_Color)(VARIANT * pVal);
    STDMETHOD(put_Color)(VARIANT newVal);
};

#endif //__CHROMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\coloradj.cpp ===
/*******************************************************************************
* ColorAdj.cpp *
*--------------*
*   Description:
*    This module is the main implementation file for the CDXLUTBuilder class.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*  @doc EXTERNAL
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "ColorAdj.h"
#include <math.h>
#include <dxhelper.h>

//--- Local

/*****************************************************************************
* CDXLUTBuilder::CDXLUTBuilder *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
CDXLUTBuilder::CDXLUTBuilder()
{
    int i;
    m_dwGenerationId     = 1;
    m_dwBuiltGenId       = 0;
    m_Gamma              = 1.0;
    m_Opacity            = 1.0;
    m_InversionThreshold = 1.0;
    m_Threshold          = 0;
    m_LevelsPerChannel   = 255;
    m_dwNumBuildSteps    = 0;
    m_pBrightnessCurve   = NULL;
    m_pContrastCurve     = NULL;
    m_BrightnessCurveCnt = 0;
    m_ContrastCurveCnt   = 0;

    for( i = 0; i < 3; ++i )
    {
        m_TintCurves[i]    = NULL;
        m_TintCurveCnts[i] = 0;
    }

    for( i = 0; i < 256; ++i )
    {
        m_RedTable[i]   = (BYTE)i;
        m_GreenTable[i] = (BYTE)i;
        m_BlueTable[i]  = (BYTE)i;
        m_AlphaTable[i] = (BYTE)i;
    }
} /* CDXLUTBuilder::CDXLUTBuilder */

/*****************************************************************************
* CDXLUTBuilder::~CDXLUTBuilder *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
CDXLUTBuilder::~CDXLUTBuilder()
{
    int i;
    delete[] m_pBrightnessCurve;
    delete[] m_pContrastCurve;

    for( i = 0; i < 3; ++i )
    {
        delete[] m_TintCurves[i];
    }

} /* CDXLUTBuilder::~CDXLUTBuilder */

/*****************************************************************************
* CDXLUTBuilder::_RecalcTables *
*------------------------------*
*   Description:
*       This method is used to recalculate the lookup table based on the
*   current property settings. Intermediate results are calculated in floating
*   point to maintain precision.
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
void CDXLUTBuilder::_RecalcTables( void )
{
    ULONG i, j;
    float fVal, Red, Green, Blue, Alpha;
    float GammaValue = 1.0F / m_Gamma;
    static float Mid = .5;

    //--- Increment the table generation ID
    ++m_dwGenerationId;

    m_SampIdent = (DXBASESAMPLE)0x01010101; // Set to all TRUE initialally

    //--- Recalc the tables
    for( i = 0; i < 256; ++i )
    {
        //--- Initialize with normalized values
        Red = Green = Blue = Alpha = ((float)i) / 255.0F;

        //--- Perform ops in order
        for( j = 0; j < m_dwNumBuildSteps; ++j )
        {
            switch( m_OpOrder[j] )
            {
              case OPID_DXLUTBUILDER_Gamma:
                Red   = (float)pow( Red  , GammaValue );
                Green = (float)pow( Green, GammaValue );
                Blue  = (float)pow( Blue , GammaValue );
                break;

              case OPID_DXLUTBUILDER_Opacity:
                Alpha *= m_Opacity;
                break;

              case OPID_DXLUTBUILDER_Brightness:
                fVal = _GetWeightedValue( i, m_pBrightnessCurve, m_BrightnessCurveCnt );
                Red   *= fVal;
                Green *= fVal;
                Blue  *= fVal;
                break;

              case OPID_DXLUTBUILDER_Contrast:
                fVal = _GetWeightedValue( i, m_pContrastCurve, m_ContrastCurveCnt );
                Red   = ((Red   - Mid) * fVal) + Mid;
                Green = ((Green - Mid) * fVal) + Mid;
                Blue  = ((Blue  - Mid) * fVal) + Mid;
                break;

              case OPID_DXLUTBUILDER_ColorBalance:
                Red   *= _GetWeightedValue( i, m_TintCurves[DXLUTCOLOR_RED]  , m_TintCurveCnts[DXLUTCOLOR_RED] );
                Green *= _GetWeightedValue( i, m_TintCurves[DXLUTCOLOR_GREEN], m_TintCurveCnts[DXLUTCOLOR_GREEN] );
                Blue  *= _GetWeightedValue( i, m_TintCurves[DXLUTCOLOR_BLUE] , m_TintCurveCnts[DXLUTCOLOR_BLUE] );
                break;

              case OPID_DXLUTBUILDER_Posterize:
              {
                Red   = _BucketVal( m_LevelsPerChannel, Red   );
                Green = _BucketVal( m_LevelsPerChannel, Green );
                Blue  = _BucketVal( m_LevelsPerChannel, Blue  );
                break;
              }

              case OPID_DXLUTBUILDER_Invert:
                if( m_InversionThreshold < 1.0 )
                {
                    if( Red   > m_InversionThreshold ) Red   = 1.0F - Red;
                    if( Green > m_InversionThreshold ) Green = 1.0F - Green;
                    if( Blue  > m_InversionThreshold ) Blue  = 1.0F - Blue;
                }
                break;

              case OPID_DXLUTBUILDER_Threshold:
                Red   = ( Red   < m_Threshold )?(0.0F):(1.0F);
                Green = ( Green < m_Threshold )?(0.0F):(1.0F);
                Blue  = ( Blue  < m_Threshold )?(0.0F):(1.0F);
                break;
            }
        }

        //--- Assign
        if( Red != 0. || Green != 0. || Blue != 0. )
        {
            Red = Red;
        }

        //--- Clamp
        if( Red > 1.0 )
        {
            Red   = 1.0;
        }
        else if( Red < 0.0 )
        {
            Red   = 0.0;
        }

        if( Green > 1.0 )
        {
            Green = 1.0;
        }
        else if( Green < 0.0 )
        {
            Green = 0.0;
        }

        if( Blue > 1.0 )
        {
            Blue  = 1.0;
        }
        else if( Blue  < 0.0 )
        {
            Blue  = 0.0;
        }

        if( Alpha > 1.0 )
        {
            Alpha = 1.0;
        }
        else if( Alpha < 0.0 )
        {
            Alpha = 0.0;
        }

        m_RedTable[i]   = (BYTE)(Red   * 255.0F);
        m_GreenTable[i] = (BYTE)(Green * 255.0F);
        m_BlueTable[i]  = (BYTE)(Blue  * 255.0F);
        m_AlphaTable[i] = (BYTE)(Alpha * 255.0F);

        //
        //--- Assign boolean for channel identity mapping
        //
        m_SampIdent.Alpha &= (m_AlphaTable[i] == i);
        m_SampIdent.Red &= (m_RedTable[i] == i);
        m_SampIdent.Green &= (m_GreenTable[i] == i);
        m_SampIdent.Blue &= (m_BlueTable[i] == i);
    }

    m_dwBuiltGenId = m_dwGenerationId;

} /* CDXLUTBuilder::_RecalcTables */

/*****************************************************************************
* CDXLUTBuilder::_GetWeightedValue *
*----------------------------------*
*   Description:
*       This method is used to return a weighted value derived from the
*   specified weight array. We just bucket the indices for now.
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/22/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
float CDXLUTBuilder::
    _GetWeightedValue( ULONG dwIndex, float Weights[], ULONG dwNumWeights )
{
    float fVal;

    if( dwNumWeights == 0 )
    {
        fVal = 1.0F;
    }
    else if( dwNumWeights == 1 )
    {
        fVal = Weights[0];
    }
    else
    {
        ULONG dwRangeSize = 255 / (dwNumWeights-1);
        ULONG dwRange = dwIndex / dwRangeSize;
        if( dwRange >= dwNumWeights ) dwRange = dwNumWeights - 1;
        fVal = Weights[dwRange];
    }

    //--- Scale positive weights 100% over = 3.55
    // Hmmm.. Is this what we want? 
    if( fVal > 1.0F )
    {
        fVal = ((fVal - 1.0F) * 2.55F) + 1.0F;
    }

    return fVal;
} /* CDXLUTBuilder::_GetWeightedValue */

/*****************************************************************************
* CDXLUTBuilder::GetTables *
*--------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetTables( BYTE RedLUT[256], BYTE GreenLUT[256],
                                       BYTE BlueLUT[256], BYTE AlphaLUT[256] )
{
    HRESULT hr = S_OK;

    if( ::DXIsBadWritePtr( RedLUT, sizeof(RedLUT) ) || 
        ::DXIsBadWritePtr( GreenLUT, sizeof(GreenLUT) ) ||
        ::DXIsBadWritePtr( BlueLUT, sizeof(BlueLUT) ) ||
        ::DXIsBadWritePtr( AlphaLUT, sizeof(AlphaLUT) ) )
    {
        return E_INVALIDARG;
    }

    if( m_dwBuiltGenId != m_dwGenerationId )
    {
        _RecalcTables();
    }

    if( RedLUT   ) memcpy( RedLUT  , m_RedTable  , sizeof( m_RedTable   ) );
    if( GreenLUT ) memcpy( GreenLUT, m_GreenTable, sizeof( m_GreenTable ) );
    if( BlueLUT  ) memcpy( BlueLUT , m_BlueTable , sizeof( m_BlueTable  ) );
    if( AlphaLUT ) memcpy( AlphaLUT, m_AlphaTable, sizeof( m_AlphaTable ) );

    return hr;
} /* CDXLUTBuilder::GetTables */

/*****************************************************************************
* CDXLUTBuilder::IsChannelIdentity *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::IsChannelIdentity( DXBASESAMPLE* pSampleBools )
{
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr( pSampleBools, sizeof( DXBASESAMPLE ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if( m_dwBuiltGenId != m_dwGenerationId )
        {
            _RecalcTables();
        }
        *pSampleBools = m_SampIdent;
    }
    return hr;
} /* CDXLUTBuilder::IsChannelIdentity */

/*****************************************************************************
* CDXLUTBuilder::GetIndexValues *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetIndexValues( ULONG Index, DXBASESAMPLE* pSample )
{
    HRESULT hr = S_OK;
    if( Index > 255 ) 
    {
        hr = E_INVALIDARG;
    } 
    else
    {
        if( DXIsBadWritePtr( pSample, sizeof( DXBASESAMPLE ) ) )
        {
            hr = E_POINTER;
        }
        else
        {
            if( m_dwBuiltGenId != m_dwGenerationId )
            {
                _RecalcTables();
            }
            pSample->Alpha = m_AlphaTable[Index];
            pSample->Red   = m_RedTable[Index];
            pSample->Green = m_GreenTable[Index];
            pSample->Blue  = m_BlueTable[Index];
        }
    }

    return hr;
} /* CDXLUTBuilder::GetIndexValues */

/*****************************************************************************
* CDXLUTBuilder::ApplyTables *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::ApplyTables( DXSAMPLE *pSamples, ULONG cSamples )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pSamples, cSamples * sizeof( ULONG ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_dwBuiltGenId != m_dwGenerationId )
        {
            _RecalcTables();
        }
        DXApplyColorChannelLookupArray( (DXBASESAMPLE *)pSamples, cSamples,
                                         m_AlphaTable, m_RedTable,
                                         m_GreenTable, m_BlueTable );
    }

    return hr;
} /* CDXLUTBuilder::ApplyTables */

/*****************************************************************************
* CDXLUTBuilder::GetNumBuildSteps *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetNumBuildSteps( ULONG *pNumSteps )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pNumSteps, sizeof( ULONG ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pNumSteps = m_dwNumBuildSteps;
    }
    return hr;
} /* CDXLUTBuilder::GetNumBuildSteps */

/*****************************************************************************
* CDXLUTBuilder::GetBuildOrder *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetBuildOrder( OPIDDXLUTBUILDER OpOrder[], ULONG ulSize )
{
    HRESULT hr = S_OK;

    // Note: check for !ulSize required for ulSize of 0 (bug#27580)
    if( !ulSize || DXIsBadWritePtr( OpOrder, sizeof( OPIDDXLUTBUILDER ) * ulSize ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        memcpy( OpOrder, m_OpOrder,
                min( ulSize, m_dwNumBuildSteps ) * sizeof( OPIDDXLUTBUILDER ) );
    }
    return hr;
} /* CDXLUTBuilder::GetBuildOrder */

/*****************************************************************************
* CDXLUTBuilder::SetBuildOrder *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetBuildOrder(const OPIDDXLUTBUILDER OpOrder[], ULONG ulNumSteps )
{
    HRESULT hr = S_OK;

    if( !ulNumSteps || ::DXIsBadReadPtr( OpOrder, sizeof( OpOrder[0] ) * ulNumSteps ) ) 
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_dwGenerationId++;
        m_dwNumBuildSteps = ulNumSteps;
        memcpy( m_OpOrder, OpOrder, ulNumSteps * sizeof( OpOrder[0] ) );
    }

    return hr;
} /* CDXLUTBuilder::SetBuildOrder */

/*****************************************************************************
* CDXLUTBuilder::GetOpacity *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetOpacity( float * pVal )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVal, sizeof( float ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_Opacity;
    }

    return hr;
} /* CDXLUTBuilder::GetOpacity */

/*****************************************************************************
* CDXLUTBuilder::SetOpacity *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetOpacity(float newVal)
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( ( newVal < 0.0 ) || ( newVal > 1.0 ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_Opacity = newVal;
    }

    return hr;
} /* CDXLUTBuilder::SetOpacity */

/*****************************************************************************
* CDXLUTBuilder::GetBrightness *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetBrightness( ULONG *pulCount, float Weights[] )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pulCount, sizeof( ULONG ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if( Weights == NULL )
        {
            *pulCount = m_BrightnessCurveCnt;
        }
        else if( !DXIsBadWritePtr( Weights, m_BrightnessCurveCnt * sizeof( float ) ) )
        {
            memcpy( Weights, m_pBrightnessCurve, m_BrightnessCurveCnt * sizeof( float ) );
            *pulCount = m_BrightnessCurveCnt;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::GetBrightness */

/*****************************************************************************
* CDXLUTBuilder::SetBrightness *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetBrightness( ULONG ulCount, const float Weights[] )
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( !ulCount || ulCount > 256 || DXIsBadReadPtr( Weights, sizeof( float ) * ulCount ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_BrightnessCurveCnt < ulCount )
        {
            delete[] m_pBrightnessCurve;
            m_BrightnessCurveCnt = ulCount;
            m_pBrightnessCurve = new float[ulCount];
            if( !m_pBrightnessCurve )
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if( SUCCEEDED( hr ) )
        {
            memcpy( m_pBrightnessCurve, Weights,
                    m_BrightnessCurveCnt * sizeof( float ) );
        }
    }

    return hr;
} /* CDXLUTBuilder::SetBrightness */

/*****************************************************************************
* CDXLUTBuilder::GetContrast *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetContrast( ULONG *pulCount, float Weights[] )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pulCount, sizeof( ULONG ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if( Weights == NULL )
        {
            *pulCount = m_ContrastCurveCnt;
        }
        else if( !DXIsBadWritePtr( Weights, m_ContrastCurveCnt * sizeof( float ) ) )
        {
            memcpy( Weights, m_pContrastCurve, m_ContrastCurveCnt * sizeof( float ) );
            *pulCount = m_ContrastCurveCnt;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::GetContrast */

/*****************************************************************************
* CDXLUTBuilder::SetContrast *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetContrast(ULONG ulCount, const float Weights[])
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( !ulCount || ulCount > 256 || DXIsBadReadPtr( Weights, sizeof( float ) * ulCount ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_ContrastCurveCnt < ulCount )
        {
            delete[] m_pContrastCurve;
            m_ContrastCurveCnt = ulCount;
            m_pContrastCurve = new float[ulCount];
            if( !m_pContrastCurve )
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if( SUCCEEDED( hr ) )
        {
            memcpy( m_pContrastCurve, Weights,
                    m_ContrastCurveCnt * sizeof( float ) );
        }
    }

    return hr;
} /* CDXLUTBuilder::SetContrast */

/*****************************************************************************
* CDXLUTBuilder::GetGamma *
*-------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetGamma( float * pVal )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVal, sizeof( float ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_Gamma;
    }

    return hr;
} /* CDXLUTBuilder::GetGamma */

/*****************************************************************************
* CDXLUTBuilder::SetGamma *
*-------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetGamma(float newVal)
{
    HRESULT hr = S_OK;

    if( newVal <= 0.0 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_Gamma = newVal;
        m_dwGenerationId++;
    }

    return hr;
} /* CDXLUTBuilder::SetGamma */

/*****************************************************************************
* CDXLUTBuilder::GetColorBalance *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetColorBalance( DXLUTCOLOR Color, ULONG *pulCount, float Weights[] )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pulCount, sizeof( ULONG ) ) )
    {
        hr = E_INVALIDARG;
    }
    else if( Weights == NULL )
    {
        *pulCount = m_TintCurveCnts[Color];
    }
    else if( m_TintCurveCnts[Color] > *pulCount )
    {
        *pulCount = m_TintCurveCnts[Color];
        hr = S_FALSE;
    }
    else if( !DXIsBadWritePtr( Weights, m_TintCurveCnts[Color] * sizeof( float ) ) )
    {
        memcpy( Weights, m_TintCurves[Color], m_TintCurveCnts[Color] * sizeof( float ) );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* CDXLUTBuilder::GetColorBalance */

/*****************************************************************************
* CDXLUTBuilder::SetColorBalance *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetColorBalance( DXLUTCOLOR Color, ULONG ulCount, const float Weights[] )
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( ulCount == 0 || ulCount > 256 || DXIsBadReadPtr( Weights, sizeof( Weights[0] ) * ulCount ) )
    {
        hr = E_INVALIDARG;
    }
    else if( m_TintCurveCnts[Color] < ulCount )
    {
        delete[] m_TintCurves[Color];
        m_TintCurveCnts[Color] = ulCount;
        m_TintCurves[Color] = new float[ulCount];

        if( !m_TintCurves[Color] )
        {
            m_TintCurveCnts[Color] = 0;
            hr = E_OUTOFMEMORY;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        memcpy( m_TintCurves[Color], Weights, ulCount * sizeof( float ) );
    }

    return hr;
} /* CDXLUTBuilder::SetColorBalance */

/*****************************************************************************
* CDXLUTBuilder::GetLevelsPerChannel *
*------------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetLevelsPerChannel( ULONG *pVal )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVal, sizeof( ULONG ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_LevelsPerChannel;
    }

    return hr;
} /* CDXLUTBuilder::GetLevelsPerChannel */

/*****************************************************************************
* CDXLUTBuilder::SetLevelsPerChannel *
*------------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetLevelsPerChannel( ULONG newVal )
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( ( newVal < 2 ) || ( newVal > 255 ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_LevelsPerChannel = (BYTE)newVal;
    }

    return hr;
} /* CDXLUTBuilder::SetLevelsPerChannel */

/*****************************************************************************
* CDXLUTBuilder::GetInvert *
*--------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetInvert( float *pVal )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVal, sizeof( float ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_InversionThreshold;
    }

    return hr;
} /* CDXLUTBuilder::GetInvert */

/*****************************************************************************
* CDXLUTBuilder::SetInvert *
*--------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetInvert( float newVal )
{
    HRESULT hr = S_OK;

    if( newVal > 1.0 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_dwGenerationId++;
        m_InversionThreshold = newVal;
    }
    return hr;
} /* CDXLUTBuilder::SetInvert */

/*****************************************************************************
* CDXLUTBuilder::GetThreshold *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetThreshold( float *pVal )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVal, sizeof( float ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_Threshold;
    }

    return hr;
} /* CDXLUTBuilder::GetThreshold */

/*****************************************************************************
* CDXLUTBuilder::SetThreshold *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetThreshold( float newVal )
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( newVal < 0.0F )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_Threshold = newVal;
    }

    return hr;
} /* CDXLUTBuilder::SetThreshold */

//
//=== Dispatch translation functions ==========================================
//
/*****************************************************************************
* CDXLUTBuilder::get_BuildOrder *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::get_BuildOrder( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_dwNumBuildSteps == 1 )
        {
            pVar->vt = VT_I4;
            hr = GetBuildOrder( (OPIDDXLUTBUILDER*)&pVar->lVal, 1 );
        }
        else
        {
            pVar->vt = VT_ARRAY | VT_I4;
            SAFEARRAYBOUND rgsabound;
            rgsabound.lLbound   = 1;
            rgsabound.cElements = m_dwNumBuildSteps;
            pVar->parray = SafeArrayCreate( VT_I4, 1, &rgsabound );

            if( pVar->parray == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                void *pData;
                hr = SafeArrayAccessData( pVar->parray, &pData );

                if( SUCCEEDED( hr ) )
                {
                    hr = GetBuildOrder( (OPIDDXLUTBUILDER*)pData, m_dwNumBuildSteps );
                    hr = SafeArrayUnaccessData( pVar->parray );
                }
            }
        }
    }

    return hr;
} /* CDXLUTBuilder::get_BuildOrder */

/*****************************************************************************
* CDXLUTBuilder::put_BuildOrder *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::put_BuildOrder( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadReadPtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( pVar->vt == ( VT_ARRAY | VT_I4 ) )
        {
            SAFEARRAY *pSA = pVar->parray;
            void *pData;

            if( ( pSA->cDims != 1 ) ||
                ( pSA->cbElements != sizeof(OPIDDXLUTBUILDER) ) ||
                ( pSA->rgsabound->lLbound != 1 ) ||
                ( pSA->rgsabound->cElements > OPID_DXLUTBUILDER_NUM_OPS ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if( SUCCEEDED( hr = SafeArrayAccessData(pSA, &pData) ) )
                {
                    hr = SetBuildOrder( (OPIDDXLUTBUILDER*)pData, pSA->rgsabound->cElements );
                    SafeArrayUnaccessData( pSA );
                }
            }
        }
        else if( pVar->vt == VT_I4 )
        {
            hr = SetBuildOrder( (OPIDDXLUTBUILDER*)&pVar->lVal, 1 );
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::put_BuildOrder */

/*****************************************************************************
* CDXLUTBuilder::get_Brightness *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::get_Brightness( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_BrightnessCurveCnt == 1 )
        {
            pVar->vt = VT_R4;
            hr = GetBrightness( &m_BrightnessCurveCnt, &pVar->fltVal );
        }
        else
        {
            pVar->vt = VT_ARRAY | VT_R4;
            SAFEARRAYBOUND rgsabound;
            rgsabound.lLbound   = 1;
            rgsabound.cElements = m_BrightnessCurveCnt;
            pVar->parray = SafeArrayCreate( VT_R4, 1, &rgsabound );
            if( pVar->parray == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                void *pData;
                hr = SafeArrayAccessData( pVar->parray, &pData );

                if( SUCCEEDED( hr ) )
                {
                    hr = GetBrightness( &m_BrightnessCurveCnt, (float*)pData );
                    hr = SafeArrayUnaccessData( pVar->parray );
                }
            }
        }
    }

    return hr;
} /* CDXLUTBuilder::get_Brightness */

/*****************************************************************************
* CDXLUTBuilder::put_Brightness *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::put_Brightness( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadReadPtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( pVar->vt == ( VT_ARRAY | VT_R4 ) )
        {
            SAFEARRAY *pSA = pVar->parray;
            void *pData;

            if( ( pSA->cDims != 1 ) || ( pSA->cbElements != sizeof(float) ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if( SUCCEEDED( hr = SafeArrayAccessData(pSA, &pData) ) )
                {
                    ULONG ulCount = ( pSA->rgsabound->lLbound )?
                                    ( pSA->rgsabound->cElements ):
                                    ( pSA->rgsabound->cElements-1 );
                    hr = SetBrightness( ulCount, (float*)pData );
                    SafeArrayUnaccessData( pSA );
                }
            }
        }
        else if( pVar->vt == VT_R4 )
        {
            hr = SetBrightness( 1, &pVar->fltVal );
        }
        else if( pVar->vt == VT_R8 )
        {
            float fltVal = (float)pVar->dblVal;
            hr = SetBrightness( 1, &fltVal );
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::put_Brightness */

/*****************************************************************************
* CDXLUTBuilder::get_Contrast *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::get_Contrast( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_ContrastCurveCnt == 1 )
        {
            pVar->vt = VT_R4;
            hr = GetContrast( &m_ContrastCurveCnt, &pVar->fltVal );
        }
        else
        {
            pVar->vt = VT_ARRAY | VT_R4;
            SAFEARRAYBOUND rgsabound;
            rgsabound.lLbound   = 1;
            rgsabound.cElements = m_ContrastCurveCnt;
            pVar->parray = SafeArrayCreate( VT_R4, 1, &rgsabound );

            if( pVar->parray == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                void *pData;
                hr = SafeArrayAccessData( pVar->parray, &pData );

                if( SUCCEEDED( hr ) )
                {
                    hr = GetContrast( &m_ContrastCurveCnt, (float*)pData );
                    hr = SafeArrayUnaccessData( pVar->parray );
                }
            }
        }
    }

    return hr;
} /* CDXLUTBuilder::get_Contrast */

/*****************************************************************************
* CDXLUTBuilder::put_Contrast *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::put_Contrast( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadReadPtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( pVar->vt == ( VT_ARRAY | VT_R4 ) )
        {
            SAFEARRAY *pSA = pVar->parray;
            void *pData;

            if( ( pSA->cDims != 1 ) ||
                ( pSA->cbElements != sizeof(float) ) ||
                ( pSA->rgsabound->lLbound != 1 ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if( SUCCEEDED( hr = SafeArrayAccessData(pSA, &pData) ) )
                {
                    hr = SetContrast( pSA->rgsabound->cElements, (float*)pData );
                    SafeArrayUnaccessData( pSA );
                }
            }
        }
        else if( pVar->vt == VT_R4 )
        {
            hr = SetContrast( 1, &pVar->fltVal );
        }
        else if( pVar->vt == VT_R8 )
        {
            float fltVal = (float)pVar->dblVal;
            hr = SetContrast( 1, &fltVal );
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::put_Contrast */

/*****************************************************************************
* CDXLUTBuilder::get_ColorBalance *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::get_ColorBalance( DXLUTCOLOR Color, VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_TintCurveCnts[Color] == 1 )
        {
            pVar->vt = VT_R4;
            hr = GetColorBalance( Color, &m_TintCurveCnts[Color], &pVar->fltVal );
        }
        else
        {
            pVar->vt = VT_ARRAY | VT_R4;
            SAFEARRAYBOUND rgsabound;
            rgsabound.lLbound   = 1;
            rgsabound.cElements = m_TintCurveCnts[Color];
            pVar->parray = SafeArrayCreate( VT_R4, 1, &rgsabound );

            if( pVar->parray == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                void *pData;
                hr = SafeArrayAccessData( pVar->parray, &pData );

                if( SUCCEEDED( hr ) )
                {
                    hr = GetColorBalance( Color, &m_TintCurveCnts[Color], (float*)pData );
                    hr = SafeArrayUnaccessData( pVar->parray );
                }
            }
        }
    }

    return hr;
} /* CDXLUTBuilder::get_ColorBalance */

/*****************************************************************************
* CDXLUTBuilder::put_ColorBalance *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::put_ColorBalance( DXLUTCOLOR Color, VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadReadPtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( pVar->vt == ( VT_ARRAY | VT_R4 ) )
        {
            SAFEARRAY *pSA = pVar->parray;
            void *pData;

            if( ( pSA->cDims != 1 ) ||
                ( pSA->cbElements != sizeof(float) ) ||
                ( pSA->rgsabound->lLbound != 1 ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if( SUCCEEDED( hr = SafeArrayAccessData(pSA, &pData) ) )
                {
                    hr = SetColorBalance( Color, pSA->rgsabound->cElements, (float*)pData );
                    SafeArrayUnaccessData( pSA );
                }
            }
        }
        else if( pVar->vt == VT_R4 )
        {
            hr = SetColorBalance( Color, 1, &pVar->fltVal );
        }
        else if( pVar->vt == VT_R8 )
        {
            float fltVal = (float)pVar->dblVal;
            hr = SetColorBalance( Color, 1, &fltVal );
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::put_ColorBalance */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\coloradj.h ===
/*******************************************************************************
* ColorAdj.h *
*------------*
*   Description:
*       This is the header file for the CDXLUTBuilder implementation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef ColorAdj_h
#define ColorAdj_h

#include "resource.h"

//--- Additional includes
#ifndef __DXTrans_h__
#include <DXTrans.h>
#endif
#include <DXHelper.h>

//=== Constants ================================================================

//=== Class declarations =======================================================

/*** CDXLUTBuilder
*
*/
class ATL_NO_VTABLE CDXLUTBuilder : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CDXLUTBuilder, &CLSID_DXLUTBuilder>,
    public IDispatchImpl<IDXDLUTBuilder, &IID_IDXDLUTBuilder, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IDXLookupTable,
    public CComPropertySupport<CDXLUTBuilder>,
    public IObjectSafetyImpl2<CDXLUTBuilder>,
    public IPersistStorageImpl<CDXLUTBuilder>,
    public ISpecifyPropertyPagesImpl<CDXLUTBuilder>,
    public IPersistPropertyBagImpl<CDXLUTBuilder>,
    public IDXLUTBuilder
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_POLY_AGGREGATABLE(CDXLUTBuilder)
    DECLARE_REGISTRY_RESOURCEID(IDR_DXLUTBUILDER)

    BEGIN_COM_MAP(CDXLUTBuilder)
        COM_INTERFACE_ENTRY(IDXLUTBuilder)
        COM_INTERFACE_ENTRY(IDXDLUTBuilder)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXLookupTable)
        COM_INTERFACE_ENTRY(IDXBaseObject)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXLUTBuilder>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXLUTBuilder)
        PROP_ENTRY("BuildOrder"        ,  2, CLSID_LUTBuilderPP)
        PROP_ENTRY("Gamma"             ,  3, CLSID_LUTBuilderPP)
        PROP_ENTRY("Opacity"           ,  4, CLSID_LUTBuilderPP)
        PROP_ENTRY("Brightness"        ,  5, CLSID_LUTBuilderPP)
        PROP_ENTRY("Contrast"          ,  6, CLSID_LUTBuilderPP)
        PROP_ENTRY("ColorBalance"      ,  7, CLSID_LUTBuilderPP)
        PROP_ENTRY("Levels Per Channel",  8, CLSID_LUTBuilderPP)
        PROP_ENTRY("Invert"            ,  9, CLSID_LUTBuilderPP)
        PROP_ENTRY("Threshold"         , 10, CLSID_LUTBuilderPP)
        PROP_PAGE(CLSID_LUTBuilderPP)
    END_PROPERTY_MAP()

  /*=== Member Data ===*/
  protected:
    float  m_Gamma;
    float  m_Opacity;
    float* m_pBrightnessCurve;
    DWORD  m_BrightnessCurveCnt;
    float* m_pContrastCurve;
    DWORD  m_ContrastCurveCnt;
    float* m_TintCurves[3];
    DWORD  m_TintCurveCnts[3];
    float  m_Threshold;
    float  m_InversionThreshold;
    BYTE   m_LevelsPerChannel;
    BYTE   m_RedTable[256];
    BYTE   m_GreenTable[256];
    BYTE   m_BlueTable[256];
    BYTE   m_AlphaTable[256];
    DWORD  m_dwNumBuildSteps;
    DWORD  m_dwBuiltGenId;
    DWORD  m_dwGenerationId;
    DXBASESAMPLE m_SampIdent;
    OPIDDXLUTBUILDER m_OpOrder[OPID_DXLUTBUILDER_NUM_OPS];

  /*=== Methods =======*/
  public:
    /*--- Constructors/Setup ---*/
    CDXLUTBuilder();
    ~CDXLUTBuilder();

    /*--- Non-interface methods ---*/
    void _RecalcTables( void );
    float _GetWeightedValue( DWORD dwIndex, float Weights[], DWORD dwNumWeights );
    float _BucketVal( DWORD NumLevels, float fVal );

  public:
    STDMETHOD( GetGenerationId )( DWORD* pID );
    STDMETHOD( IncrementGenerationId ) (BOOL bRefresh);
    STDMETHOD( GetObjectSize) (ULONG *pcbSize);

    //=== IDXLookupTable interface ===========================
    STDMETHOD( GetTables )( BYTE RedLUT[256], BYTE GreenLUT[256],
                            BYTE BlueLUT[256], BYTE AlphaLUT[256] );
    STDMETHODIMP IsChannelIdentity(DXBASESAMPLE * pSampleBools);
    STDMETHODIMP GetIndexValues(ULONG Index, DXBASESAMPLE *pSampleBools);
    STDMETHODIMP ApplyTables(DXSAMPLE *pSamples, ULONG cSamples);

    //=== IDXLUTBuilder interface ===========================
    STDMETHOD(GetNumBuildSteps)( ULONG *pNumSteps );
    STDMETHOD(GetBuildOrder)( OPIDDXLUTBUILDER OpOrder[], ULONG ulSize );
    STDMETHOD(SetBuildOrder)( const OPIDDXLUTBUILDER OpOrder[], ULONG ulNumSteps );
    STDMETHOD(SetGamma)( float newVal);
    STDMETHOD(GetGamma)( float *pVal);
    STDMETHOD(GetOpacity)( float *pVal);
    STDMETHOD(SetOpacity)( float newVal);
    STDMETHOD(GetBrightness)( ULONG *pulCount, float Weights[] );
    STDMETHOD(SetBrightness)( ULONG ulCount, const float Weights[] );
    STDMETHOD(GetContrast)( ULONG *pulCount, float Weights[] );
    STDMETHOD(SetContrast)( ULONG ulCount, const float Weights[]);
    STDMETHOD(GetColorBalance)( DXLUTCOLOR Color, ULONG *pulCount, float Weights[] );
    STDMETHOD(SetColorBalance)( DXLUTCOLOR Color, ULONG ulCount, const float Weights[] );
    STDMETHOD(GetLevelsPerChannel)( ULONG *pVal);
    STDMETHOD(SetLevelsPerChannel)( ULONG newVal);
    STDMETHOD(GetInvert)( float *pThreshold );
    STDMETHOD(SetInvert)( float Threshold );
    STDMETHOD(GetThreshold)( float *pVal);
    STDMETHOD(SetThreshold)( float newVal);

    //=== IDXDLUTBuilder interface ===========================
    STDMETHOD(get_NumBuildSteps)( long *pNumSteps );
    STDMETHOD(get_BuildOrder)( VARIANT *pOpOrder );
    STDMETHOD(put_BuildOrder)( VARIANT *pOpOrder );
    STDMETHOD(put_Gamma)( float newVal);
    STDMETHOD(get_Gamma)( float *pVal);
    STDMETHOD(get_Opacity)( float *pVal);
    STDMETHOD(put_Opacity)( float newVal);
    STDMETHOD(get_Brightness)( VARIANT *pWeights );
    STDMETHOD(put_Brightness)( VARIANT *pWeights );
    STDMETHOD(get_Contrast)( VARIANT *pWeights );
    STDMETHOD(put_Contrast)( VARIANT *pWeights );
    STDMETHOD(get_ColorBalance)( DXLUTCOLOR Color, VARIANT *pWeights );
    STDMETHOD(put_ColorBalance)( DXLUTCOLOR Color, VARIANT *pWeights );
    STDMETHOD(get_LevelsPerChannel)( long *pVal);
    STDMETHOD(put_LevelsPerChannel)( long newVal);
    STDMETHOD(get_Invert)( float *pThreshold );
    STDMETHOD(put_Invert)( float Threshold );
    STDMETHOD(get_Threshold)( float *pVal);
    STDMETHOD(put_Threshold)( float newVal);
};

//=== Inline Function Definitions ==================================

inline STDMETHODIMP CDXLUTBuilder::GetGenerationId( DWORD* pID )
{
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(pID, sizeof(*pID)) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pID = m_dwGenerationId;
    }
    return hr;
}

inline STDMETHODIMP CDXLUTBuilder::IncrementGenerationId(BOOL /*bRefresh */)
{
    InterlockedIncrement((long *)&m_dwGenerationId);
    return S_OK;
}

inline STDMETHODIMP CDXLUTBuilder::GetObjectSize(ULONG *pcbSize)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pcbSize, sizeof(*pcbSize)))
    {
        hr = E_POINTER;
    }
    else
    {
        *pcbSize = sizeof(*this);
    }
    return hr;
}

inline float CDXLUTBuilder::_BucketVal( DWORD NumLevels, float fVal )
{
    fVal *= 255.0F;
    float BucketSize = 256.0F / (NumLevels-1);
    float HalfBucket = BucketSize / 2.0F;
    float fTemp = (fVal + HalfBucket) / BucketSize;
    long  lTemp = (long)(((long)fTemp) * BucketSize);
    fVal = ((float)lTemp) / 255.0F;
    return fVal;
} /* CDXLUTBuilder::_BucketVal */

inline STDMETHODIMP CDXLUTBuilder::get_LevelsPerChannel( long *pVal) { return GetLevelsPerChannel( (DWORD*)pVal ); }
inline STDMETHODIMP CDXLUTBuilder::put_LevelsPerChannel( long newVal){ return SetLevelsPerChannel( (DWORD)newVal ); }
inline STDMETHODIMP CDXLUTBuilder::get_Invert( float *pThreshold ) { return GetInvert( pThreshold ); }
inline STDMETHODIMP CDXLUTBuilder::put_Invert( float Threshold ) { return SetInvert( Threshold ); }
inline STDMETHODIMP CDXLUTBuilder::get_Threshold( float *pVal) { return GetThreshold( pVal );}
inline STDMETHODIMP CDXLUTBuilder::put_Threshold( float newVal) { return SetThreshold( newVal ); }
inline STDMETHODIMP CDXLUTBuilder::put_Gamma( float newVal) { return SetGamma( newVal ); }
inline STDMETHODIMP CDXLUTBuilder::get_Gamma( float *pVal) { return GetGamma( pVal ); }
inline STDMETHODIMP CDXLUTBuilder::get_Opacity( float *pVal) { return GetOpacity( pVal ); }
inline STDMETHODIMP CDXLUTBuilder::put_Opacity( float newVal) { return SetOpacity( newVal ); }
inline STDMETHODIMP CDXLUTBuilder::get_NumBuildSteps( long *pNumSteps ) { return GetNumBuildSteps( (DWORD*)pNumSteps ); }

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\colormanagement.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    colormanagement.h
//
// Description: Color management filter transform.
//
// Change History:
//
// 2000/02/06   mcalkins    Created.  Ported code from an old filter.
//
//------------------------------------------------------------------------------

#ifndef __COLORMANAGEMENT_H_
#define __COLORMANAGEMENT_H_

#include "resource.h"

class ATL_NO_VTABLE CDXTICMFilter : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTICMFilter, &CLSID_DXTICMFilter>,
    public CComPropertySupport<CDXTICMFilter>,
    public IDispatchImpl<IDXTICMFilter, &IID_IDXTICMFilter, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CDXTICMFilter>,
    public IPersistStorageImpl<CDXTICMFilter>,
    public ISpecifyPropertyPagesImpl<CDXTICMFilter>,
    public IPersistPropertyBagImpl<CDXTICMFilter>
{
private:

    CComPtr<IUnknown>       m_spUnkMarshaler;

    LOGCOLORSPACE           m_LogColorSpace;
    BSTR                    m_bstrColorSpace;

    static const TCHAR *    s_strSRGBColorSpace;

    // m_fWin95         True if we're on Windows 95 specifically.  In ths case
    //                  we need to have some special treatment of the color 
    //                  space directories.

    unsigned                m_fWin95 : 1;

public:

    CDXTICMFilter();

    DECLARE_POLY_AGGREGATABLE(CDXTICMFilter)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_DXTICMFILTER)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTICMFilter)
        COM_INTERFACE_ENTRY(IDXTICMFilter)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTICMFilter>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTICMFilter)
        PROP_ENTRY("colorspace",    DISPID_DXTICMFILTER_COLORSPACE, CLSID_DXTICMFilterPP)
        PROP_ENTRY("intent",        DISPID_DXTICMFILTER_INTENT,     CLSID_DXTICMFilterPP)
        PROP_PAGE(CLSID_DXTICMFilterPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pfContinueProcessing);
    //HRESULT OnSetup(DWORD dwFlags);

    // IDXTICMFilter methods.

    STDMETHOD(get_ColorSpace)(BSTR * pbstrColorSpace);
    STDMETHOD(put_ColorSpace)(BSTR bstrColorSpace);
    STDMETHOD(get_Intent)(short * pnIntent);
    STDMETHOD(put_Intent)(short nIntent);
};

#endif // __COLORMANAGEMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\convolve.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998-2000
//
//  FileName:   convolve.h
//
//  Overview:   The CDXConvolution transform.  This transform performs a 
//              convolution using the currently defined filter.
//             
//  Change History:
//  1997/07/27  edc         Created.
//  2000/02/08  mcalkins    Fixed partial redraw cases.
//
//------------------------------------------------------------------------------
#ifndef __CONVOLVE_H_
#define __CONVOLVE_H_

#include "resource.h"




class ATL_NO_VTABLE CDXConvolution : 
    public CDXBaseNTo1,
    public CComCoClass<CDXConvolution, &CLSID_DXTConvolution>,
    public IDXTConvolution
{
private:

    CComPtr<IUnknown> m_spUnkMarshaler;

    //--- Filter vars
    DXCONVFILTERTYPE    m_FilterType;
    SIZE                m_FilterSize;
    SIZE                m_OutputSpread;
    RECT                m_FilterMargins;
    float*              m_pCustomFilter;
    float*              m_pFilter;
    ULONG*              m_pFilterLUTIndexes;
    long*               m_pPMCoeffLUT;
    float               m_Bias;

    //--- Cacheing vars
    CComPtr<IDXSurface> m_cpMarginedSurf;
    DXNATIVETYPEINFO    m_MarginedSurfInfo;
    SIZE                m_MarginedSurfSize;
    CDXDBnds            m_InputSurfBnds;
    BOOL                m_bConvertToGray;
    BOOL                m_bMarginedIsPremult;

    //--- processing vars
    BOOL                m_bDoSampleClamp;
    CDXDBnds            m_LastDoBnds;
    long                m_DoBndsBaseRow;
    BOOL                m_bDoSrcCopyOnly;
    BOOL                m_bExcludeAlpha;
    BOOL                m_bIsBoxFilter;

public:

    DECLARE_POLY_AGGREGATABLE(CDXConvolution)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_DXTCONVOLUTION)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXConvolution)
        COM_INTERFACE_ENTRY(IDXTConvolution)
    	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BYTE m_bInUnpackPremult;
    BYTE m_bOutUnpackPremult;
    BYTE m_bNeedInUnpackBuff;
    BYTE m_bNeedOutUnpackBuff;

    //--- Constructors
    HRESULT FinalConstruct();
    void    FinalRelease();

    //--- Base class overrides
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1& WI, BOOL* pbContinue);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1& WI, ULONG& ulNB);

    //--- Helper functions
    HRESULT _DoBoxFilter(const CDXTWorkInfoNTo1& WI, BOOL* pbContinue);
    HRESULT _BuildFilterLUTs(void);
    HRESULT _ConvertToGray(CDXDBnds& Bnds);
    void    _DetermineUnpackCase(void);
    HRESULT _SetToPremultiplied(BOOL bWantPremult);

    // IDXTransform methods.

    STDMETHOD(MapBoundsIn2Out)(const DXBNDS * pInBounds, ULONG ulNumInBnds,
                               ULONG ulOutIndex, DXBNDS * pOutBounds);
    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTConvolution methods.

    STDMETHOD(SetFilterType)(DXCONVFILTERTYPE eType);
    STDMETHOD(GetFilterType)(DXCONVFILTERTYPE * peType);
    STDMETHOD(SetCustomFilter)(float * pFilter, SIZE Size);
    STDMETHOD(SetConvertToGray)(BOOL bConvertToGray);
    STDMETHOD(GetConvertToGray)(BOOL * pbConvertToGray);
    STDMETHOD(SetBias)(float Bias);
    STDMETHOD(GetBias)(float * pBias);
    STDMETHOD(SetExcludeAlpha)(BOOL bExcludeAlpha);
    STDMETHOD(GetExcludeAlpha)(BOOL * pbExcludeAlpha);
};


//=== Inline Function Definitions ==================================
inline STDMETHODIMP CDXConvolution::SetBias(float Bias)
{
    HRESULT hr = S_OK;
    if ((Bias < -1.) || (Bias > 1.))
    {
        hr = E_INVALIDARG;
    }
    else if (m_Bias != Bias)
    {
        m_Bias = Bias;
        SetDirty();
    }
    return hr;
}

inline STDMETHODIMP CDXConvolution::GetBias(float* pBias)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pBias, sizeof(*pBias)))
    {
        hr = E_POINTER;
    }
    else
    {
        *pBias = m_Bias;
    }
    return hr;
} /* CDXConvolution::GetBias */

inline STDMETHODIMP CDXConvolution::SetConvertToGray(BOOL bConvertToGray)
{
    if (m_bConvertToGray != bConvertToGray)
    {
        m_bConvertToGray = bConvertToGray;
        SetDirty();
    }
    return S_OK;
} /* CDXConvolution::SetConvertToGray */

inline STDMETHODIMP CDXConvolution::GetConvertToGray(BOOL* pbConvertToGray)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pbConvertToGray, sizeof(*pbConvertToGray)))
    {
        hr = E_POINTER;
    }
    else
    {
        *pbConvertToGray = m_bConvertToGray;
    }
    return hr;
} /* CDXConvolution::GetConvertToGray */

inline STDMETHODIMP CDXConvolution::SetExcludeAlpha(BOOL bExcludeAlpha)
{
    if (m_bExcludeAlpha != bExcludeAlpha)
    {
        m_bExcludeAlpha = bExcludeAlpha;
        if (!m_bDoSrcCopyOnly)
        {
            _BuildFilterLUTs();
        }
        SetDirty();
    }
    return S_OK;
} /* CDXConvolution::SetExcludeAlpha */

inline STDMETHODIMP CDXConvolution::GetExcludeAlpha(BOOL* pbExcludeAlpha)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pbExcludeAlpha, sizeof(*pbExcludeAlpha)))
    {
        hr = E_POINTER;
    }
    else
    {
        *pbExcludeAlpha = m_bExcludeAlpha;
    }
    return hr;
} /* CDXConvolution::GetExcludeAlpha */

inline BYTE ShiftAndClampChannelVal(long Value)
{
    Value >>= 16;

    if (Value > 255)
    {
        return 255;
    }
    else if (Value < 0)
    {
        return 0;
    }
    else
    {
        return (BYTE)Value;
    }
}


#endif // __CONVOLVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\composit.cpp ===
/*******************************************************************************
* Composit.cpp *
*--------------*
*   Description:
*    This module contains the CDXTComposite transform
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/28/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
//--- Additional includes
#include "stdafx.h"
#include "Composit.h"

#define COMP_CASE( fctn, runtype ) case ((DXCOMPFUNC_##fctn << 3) + DXRUNTYPE_##runtype)

/*****************************************************************************
* CDXTComposite::FinalConstruct *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 08/08/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXTComposite::FinalConstruct()
{
    //--- Uncomment this when debugging to allow only
    //    one thread to execute the work proc at a time
//    m_ulMaxImageBands = 1;

    //--- Init base class variables to control setup
    m_ulMaxInputs     = 2;
    m_ulNumInRequired = 2;
    m_dwOptionFlags   = DXBOF_SAME_SIZE_INPUTS;
    put_Function( DXCOMPFUNC_A_OVER_B );
    return CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_cpUnkMarshaler);
} /* CDXTComposite::FinalConstruct */

/*****************************************************************************
* CDXTComposite::OnSurfacePick *
*------------------------------*
*   Description:
*       This method performs a pick test. The compositing logic must be
*   performed to determine each inputs contribution.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 05/11/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXTComposite::
    OnSurfacePick( const CDXDBnds& OutPoint, ULONG& ulInputIndex, CDXDVec& InVec )
{
    HRESULT hr = S_OK;
    ULONG IndexA, IndexB;
    DXPMSAMPLE SampleA, SampleB;

    //--- Determine which indexes to use for A and B
    DXCOMPFUNC eFunc = (DXCOMPFUNC)(m_eFunction & DXCOMPFUNC_FUNCMASK);
    if( m_eFunction & DXCOMPFUNC_SWAP_AB )
    {
        IndexA = 1;
        IndexB = 0;
    }
    else
    {
        IndexA = 0;
        IndexB = 1;
    }

    //--- Get input A sample
    {
        CComPtr<IDXARGBReadPtr> cpInA;
        hr = InputSurface( IndexA )->LockSurface( &OutPoint, m_ulLockTimeOut, DXLOCKF_READ,
                                                  IID_IDXARGBReadPtr, (void**)&cpInA, NULL );
        if( FAILED( hr ) )
        {
            //--- No hit if the bounds are invalid
            return ( hr == DXTERR_INVALID_BOUNDS )?( S_FALSE ):( hr );
        }
        cpInA->UnpackPremult( &SampleA, 1, false );
    }

    //--- Get input B sample
    {
        CComPtr<IDXARGBReadPtr> cpInB;
        hr = InputSurface( IndexB )->LockSurface( &OutPoint, m_ulLockTimeOut, DXLOCKF_READ,
                                                  IID_IDXARGBReadPtr, (void**)&cpInB, NULL );
        if( FAILED( hr ) )
        {
            //--- No hit if the bounds are invalid
            return ( hr == DXTERR_INVALID_BOUNDS )?( S_FALSE ):( hr );
        }
        cpInB->UnpackPremult( &SampleB, 1, false );
    }

    //--- Check for trivial cases
    if( m_eFunction == DXCOMPFUNC_CLEAR )
    {
        //--- No hit
        return S_FALSE;
    }
    else if( eFunc == DXCOMPFUNC_A )
    {
        if( SampleA.Alpha )
        {
            ulInputIndex = IndexA;
        }
        else
        {
            hr = S_FALSE;
        }
        return hr;
    }

    //=== Check based on function ==========================
    DWORD SwitchDisp = eFunc << 3;
    switch( DXRUNTYPE_UNKNOWN + SwitchDisp )
    {
      //====================================================
      COMP_CASE(A_OVER_B, UNKNOWN):
      {
        if( SampleA.Alpha )
        {
            ulInputIndex = IndexA;
        }
        else if( SampleB.Alpha )
        {
            ulInputIndex = IndexB;
        }
        else
        {
            hr = S_FALSE;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_IN_B, UNKNOWN):
      {
        if( SampleA.Alpha && SampleB.Alpha )
        {
            ulInputIndex = IndexA;
        }
        else
        {
            //--- We only get hits on A when B exists
            hr = S_FALSE;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_OUT_B, UNKNOWN):
      {
        if( SampleA.Alpha && !SampleB.Alpha )
        {
            ulInputIndex = IndexA;
        }
        else
        {
            //--- We only get hits on A when B does not exist
            hr = S_FALSE;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_ATOP_B, UNKNOWN):
      {
        if( SampleB.Alpha )
        {
            ulInputIndex = ( SampleA.Alpha )?( IndexA ):( IndexB );
        }
        else
        {
            //--- We only get hits on A when B exists and A has alpha
            hr = S_FALSE;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_XOR_B, UNKNOWN):
      {
        if( SampleA.Alpha )
        {
            if( SampleB.Alpha )
            {
                hr = S_FALSE;
            }
            else
            {
                ulInputIndex = IndexA;
            }
        }
        else if( SampleB.Alpha )
        {
            ulInputIndex = IndexB;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_ADD_B, UNKNOWN):
      {
        if( SampleA.Alpha )
        {
            ulInputIndex = ( SampleB.Alpha )?( IndexB ):( IndexA );
        }
        else
        {
            hr = S_FALSE;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_SUBTRACT_B, UNKNOWN):
      {
        if( SampleA.Alpha )
        {
            ulInputIndex = IndexA;
        }
        else
        {
            hr = S_FALSE;
        }
        break;
      }
    }   // End of huge switch

    return hr;
} /* CDXTComposite::OnSurfacePick */

//
//=== Composite Work Procedures ==================================================
//
/*****************************************************************************
* Composite *
*-----------*
*   Description:
*       The Composite function is used to copy the source to the destination
*   performing the current compositing function.
*
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/31/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXTComposite::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{ 
    HRESULT hr = S_OK;
    ULONG IndexA, IndexB;
    const ULONG Width = WI.DoBnds.Width();
    const ULONG Height = WI.DoBnds.Height();

    //--- Determine which indexes to use for A and B
    DXCOMPFUNC eFunc = (DXCOMPFUNC)(m_eFunction & DXCOMPFUNC_FUNCMASK);
    if( m_eFunction & DXCOMPFUNC_SWAP_AB )
    {
        IndexA = 1;
        IndexB = 0;
    }
    else
    {
        IndexA = 0;
        IndexB = 1;
    }

    //--- Check for trivial cases
    if( m_eFunction == DXCOMPFUNC_CLEAR )
    {
        //--- NoOp
        return hr;
    }
    else if( eFunc == DXCOMPFUNC_A )
    {
        CDXDVec Placement(false);
        WI.OutputBnds.GetMinVector(Placement);
        return m_cpSurfFact->BitBlt( OutputSurface(), &Placement,
                                     InputSurface( IndexA ), &WI.DoBnds, m_dwBltFlags );
    }

    //--- Get input A sample access pointer.
    CComPtr<IDXARGBReadPtr> cpInA;
    hr = InputSurface( IndexA )->LockSurface( &WI.DoBnds, m_ulLockTimeOut,
                                              DXLOCKF_READ | DXLOCKF_WANTRUNINFO,
                                              IID_IDXARGBReadPtr, (void**)&cpInA, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Get input B sample access pointer.
    CComPtr<IDXARGBReadPtr> cpInB;
    hr = InputSurface( IndexB )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                              IID_IDXARGBReadPtr, (void**)&cpInB, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Put a write lock only on the region we are rendering so multiple
    //    threads don't conflict.
    CComPtr<IDXARGBReadWritePtr> cpOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                        IID_IDXARGBReadWritePtr, (void**)&cpOut, NULL );
    if( FAILED( hr ) ) return hr;

    //=== Process each row ===========================================
    DXSAMPLEFORMATENUM InTypeA = cpInA->GetNativeType(NULL);
    //--- Allocate working output buffers if necessary
    DXSAMPLEFORMATENUM InTypeB = cpInB->GetNativeType(NULL);
    DXPMSAMPLE *pInBuffA = ( InTypeA == DXPF_PMARGB32 )?( NULL ):
                           ( DXPMSAMPLE_Alloca( Width ) );
    DXPMSAMPLE *pInBuffB = DXPMSAMPLE_Alloca( Width );

    //--- Optimize if both sources are fully opaque
    DXPMSAMPLE *pOutBuff = (DoOver() && cpOut->GetNativeType(NULL) != DXPF_PMARGB32) ? 
                             DXPMSAMPLE_Alloca( Width ) : NULL;

    //--- We'll be adding the run type into the low bits
    DWORD SwitchDisp = eFunc << 3;

    for( ULONG Y = 0; *pbContinue && (Y < Height); ++Y )
    {
        //--- Move to A input row and get runs
        const DXRUNINFO *pRunInfo;
        ULONG cRuns = cpInA->MoveAndGetRunInfo(Y, &pRunInfo);

        //--- Unpack all of B
        cpInB->MoveToRow( Y );
        DXPMSAMPLE *pDest = cpInB->UnpackPremult( pInBuffB, Width, false );

        //--- Apply each run of A to B
        do
        {
            ULONG ulRunLen = pRunInfo->Count;

            switch( pRunInfo->Type + SwitchDisp )
            {
              //====================================================
              //--- Composite the translucent
              COMP_CASE(A_OVER_B, TRANS):
              {
                DXOverArrayMMX( pDest,
                                cpInA->UnpackPremult( pInBuffA, ulRunLen, true ),
                                ulRunLen );
                pDest += ulRunLen;
              }
              break;

              COMP_CASE(A_OVER_B, UNKNOWN):
              {
                //--- Do not use MMX in this case because it is faster
                //    to check for early exits
                DXOverArray( pDest,
                             cpInA->UnpackPremult( pInBuffA, ulRunLen, true ),
                             ulRunLen );
                pDest += ulRunLen;
              }
              break;

              //====================================================
              COMP_CASE(MIN, OPAQUE ):
              COMP_CASE(MIN, TRANS  ):
              COMP_CASE(MIN, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    *pDest = ( DXConvertToGray(*pSrc) < DXConvertToGray(*pDest) )?
                                ( *pSrc ):( *pDest );
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(MAX, OPAQUE ):
              COMP_CASE(MAX, TRANS  ):
              COMP_CASE(MAX, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    *pDest = ( DXConvertToGray(*pSrc) > DXConvertToGray(*pDest) )?
                                ( *pSrc ):( *pDest );
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_IN_B, OPAQUE):
              COMP_CASE(A_IN_B, TRANS):
              COMP_CASE(A_IN_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    //--- Do composite if we have non-clear destination
                    BYTE DstAlpha = pDest->Alpha;
                    if( DstAlpha )
                    {
                        DXPMSAMPLE Src = *pSrc;
                        ULONG t1, t2;
        
                        t1 = (Src & 0x00ff00ff) * DstAlpha + 0x00800080;
                        t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                        t2 = ((Src >> 8) & 0x00ff00ff) * DstAlpha + 0x00800080;
                        t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;
        
                        *pDest = (t1 | t2);
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_OUT_B, OPAQUE):
              COMP_CASE(A_OUT_B, TRANS):
              COMP_CASE(A_OUT_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    if( pDest->Alpha )
                    {
                        if( ( pDest->Alpha != 255 ) && ( pSrc->Alpha ) )
                        {
                            //--- Do the weighted assignment
                            *pDest = DXScaleSample( *pSrc, 255 - pDest->Alpha );
                        }
                        else 
                        {
                           //--- If the destination is opaque we destroy it
                           *pDest = 0;
                        }
                    }
                    else
                    {
                        //--- If the destination is clear we assign the source
                        *pDest = *pSrc;
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_ATOP_B, OPAQUE):
              COMP_CASE(A_ATOP_B, TRANS):
              COMP_CASE(A_ATOP_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    DXPMSAMPLE Dst = *pDest;
                    if( Dst.Alpha > 0 ) //--- If the destination is clear we skip
                    {
                        DXPMSAMPLE Src = *pSrc;
                        BYTE beta = 255 - Src.Alpha;
                        ULONG t1, t2, t3, t4;
        
                        //--- Compute B weighted by inverse alpha A
                        t1 = (Dst & 0x00ff00ff) * beta + 0x00800080;
                        t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                        t2 = ((Dst >> 8) & 0x00ff00ff) * beta + 0x00800080;
                        t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;
        
                        //--- Compute A weighted by alpha B
                        t3 = (Src & 0x00ff00ff) * Dst.Alpha + 0x00800080;
                        t3 = ((t3 + ((t3 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                        t4 = ((Src >> 8) & 0x00ff00ff) * Dst.Alpha + 0x00800080;
                        t4 = (t4 + ((t4 >> 8) & 0x00ff00ff)) & 0xff00ff00;
                
                        //--- Assign the sums
                        *pDest = ((t1 | t2) + (t3 | t4));
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_XOR_B, OPAQUE):
              COMP_CASE(A_XOR_B, TRANS):
              COMP_CASE(A_XOR_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    DXPMSAMPLE Dst = *pDest;
                    if(Dst.Alpha == 0 )
                    {
                        //--- If the destination is clear we assign A
                        *pDest = *pSrc;
                    }
                    else
                    {
                        DXPMSAMPLE Src = *pSrc;
                        //--- If both exist we do composite
                        BYTE SrcBeta = 255 - Src.Alpha;
                        BYTE DstBeta = 255 - Dst.Alpha;
                        ULONG t1, t2, t3, t4;
        
                        //--- Compute B weighted by inverse alpha A
                        t1 = (Dst & 0x00ff00ff) * SrcBeta + 0x00800080;
                        t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                        t2 = ((Dst >> 8) & 0x00ff00ff) * SrcBeta + 0x00800080;
                        t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;
        
                        //--- Compute A weighted by inverse alpha B
                        t3 = (Src & 0x00ff00ff) * DstBeta + 0x00800080;
                        t3 = ((t3 + ((t3 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                        t4 = ((Src >> 8) & 0x00ff00ff) * DstBeta + 0x00800080;
                        t4 = (t4 + ((t4 >> 8) & 0x00ff00ff)) & 0xff00ff00;
                
                        //--- Assign the sums
                        *pDest = ((t1 | t2) + (t3 | t4));
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_ADD_B, OPAQUE):
              COMP_CASE(A_ADD_B, TRANS):
              COMP_CASE(A_ADD_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    if( pSrc->Alpha )
                    {
                        if( pDest->Alpha )
                        {
                            //--- Add the alpha weighted colors from A
                            unsigned Val;
                            DXSAMPLE A = DXUnPreMultSample( *pSrc  );
                            Val     = (unsigned)A.Red + pDest->Red;
                            A.Red   = ( Val > 255 )?(255):(Val);
                            Val     = (unsigned)A.Green + pDest->Green;
                            A.Green = ( Val > 255 )?(255):(Val);
                            Val     = (unsigned)A.Blue + pDest->Blue;
                            A.Blue  = ( Val > 255 )?(255):(Val);
                            *pDest  = DXPreMultSample( A );
                        }
                        else
                        {
                            *pDest = *pSrc;
                        }
                    }
                    else
                    {
                        *pDest = 0;
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_SUBTRACT_B, OPAQUE):
              COMP_CASE(A_SUBTRACT_B, TRANS):
              COMP_CASE(A_SUBTRACT_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    if( pSrc->Alpha )
                    {
                        if( pDest->Alpha )
                        {
                            //--- Subtract the alpha weighted colors from A
                            DXSAMPLE A = DXUnPreMultSample( *pSrc  );
                            A.Red   = ( A.Red   <= pDest->Red   )?(0):( A.Red   - pDest->Red   );
                            A.Green = ( A.Green <= pDest->Green )?(0):( A.Green - pDest->Green );
                            A.Blue  = ( A.Blue  <= pDest->Blue  )?(0):( A.Blue  - pDest->Blue  );
                            *pDest = DXPreMultSample( A );
                        }
                        else
                        {
                            *pDest = *pSrc;
                        }
                    }
                    else
                    {
                        *pDest = 0;
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_OVER_B, OPAQUE):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                for( ULONG i = 0; i < ulRunLen; ++i ) pDest[i] = pSrc[i];
                pDest += ulRunLen;
                break;
              }

              //--- Skip this many clear
              COMP_CASE(MAX     , CLEAR):
              COMP_CASE(A_OVER_B, CLEAR):
              COMP_CASE(A_ATOP_B, CLEAR):
              COMP_CASE(A_XOR_B , CLEAR):
                cpInA->Move(ulRunLen);
                pDest += ulRunLen;
                break;

              //--- Destroy this many
              COMP_CASE(MIN         , CLEAR):
              COMP_CASE(A_ADD_B     , CLEAR):
              COMP_CASE(A_SUBTRACT_B, CLEAR):
              COMP_CASE(A_IN_B      , CLEAR):
              COMP_CASE(A_OUT_B     , CLEAR):
              {
                for( ULONG i = 0; i < ulRunLen; ++i ) pDest[i] = 0;
                pDest += ulRunLen;
                cpInA->Move(ulRunLen);
              }
              break;
            }   // End of huge switch

            //--- Next run
            pRunInfo++;
            cRuns--;
        } while (cRuns);

        //--- Write out the composite row
        //--- Move to output row
        cpOut->MoveToRow( Y );

        if( DoOver() )
        {
            cpOut->OverArrayAndMove(pOutBuff, pInBuffB, Width);
        }
        else
        {
            cpOut->PackPremultAndMove( pInBuffB, Width );
        }
    } /* end for loop */

    return hr;
} /* Composite */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\crblur.cpp ===
/*******************************************************************************
* CrBlur.cpp *
*------------*
*   Description:
*      This module contains the CCrBlur transform implemenation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/10/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "CrBlur.h"

//--- Local data

/*****************************************************************************
* CCrBlur::FinalConstruct *
*-------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrBlur::FinalConstruct()
{
    DXTDBG_FUNC( "CCrBlur::FinalConstruct" );
    HRESULT hr = S_OK;

    //--- Member data
    m_bSetupSucceeded   = false;
    m_bMakeShadow       = false;
    m_ShadowOpacity     = .75;
    m_PixelRadius       = 2.0;
    m_PixelRadius       = 2.0;
    m_pConvolutionTrans = NULL;
    m_pConvolution      = NULL;

    //--- Create inner convolution
    IUnknown* punkCtrl = GetControllingUnknown();
    hr = ::CoCreateInstance( CLSID_DXTConvolution, punkCtrl, CLSCTX_INPROC,
                             IID_IUnknown, (void **)&m_cpunkConvolution );

    if( SUCCEEDED( hr ) )
    {
        hr = m_cpunkConvolution->
                QueryInterface( IID_IDXTransform, (void **)&m_pConvolutionTrans );
        if( SUCCEEDED( hr ) )
        {
            //--- Getting an interface from the inner causes the outer to be addref'ed
            //    aggregation rules state that we need to release the outer.
            punkCtrl->Release();

            hr = m_cpunkConvolution->QueryInterface( IID_IDXTConvolution, (void **)&m_pConvolution );
            if( SUCCEEDED( hr ) )
            {
                punkCtrl->Release();
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = put_PixelRadius( m_PixelRadius );
    }

    //--- Create the surface modifier and lookup
    if( SUCCEEDED( hr ) )
    {
        hr = ::CoCreateInstance( CLSID_DXSurfaceModifier, NULL, CLSCTX_INPROC,
                                 IID_IDXSurfaceModifier, (void **)&m_cpInSurfMod );

        if( SUCCEEDED( hr ) )
        {
            m_cpInSurfMod->QueryInterface( IID_IDXSurface, (void**)&m_cpInSurfModSurf );

            hr = ::CoCreateInstance( CLSID_DXLUTBuilder, NULL, CLSCTX_INPROC,
                                     IID_IDXLUTBuilder, (void **)&m_cpLUTBldr );
        }

        if( SUCCEEDED( hr ) )
        {
            //--- Set the threshold for shadows
            static OPIDDXLUTBUILDER OpOrder[] = { OPID_DXLUTBUILDER_Threshold,
                                                  OPID_DXLUTBUILDER_Opacity,
                                                };
            m_cpLUTBldr->SetThreshold( 1.1f );
            m_cpLUTBldr->SetOpacity( m_ShadowOpacity );
            m_cpLUTBldr->SetBuildOrder( OpOrder, 2 );

            //--- Associate objects
            CComPtr<IDXLookupTable> cpLUT;
            m_cpLUTBldr->QueryInterface( IID_IDXLookupTable, (void**)&cpLUT );
            if( SUCCEEDED( hr ) )
            {
                hr = m_cpInSurfMod->SetLookup( cpLUT );
            }
        }
    }

    return hr;
} /* CCrBlur::FinalConstruct */

/*****************************************************************************
* CCrBlur::FinalRelease *
*-----------------------*
*   Description:
*       The inner interfaces are released using COM aggregation rules. Releasing
*   the inner causes the outer to be released, so we addref the outer prior to
*   protect it.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrBlur::FinalRelease()
{
    DXTDBG_FUNC( "CCrBlur::FinalRelease" );
    HRESULT hr = S_OK;

    //--- Safely free the inner interfaces held
    IUnknown* punkCtrl = GetControllingUnknown();
    if( m_pConvolutionTrans )
    {
        punkCtrl->AddRef();
        m_pConvolutionTrans->Release();
    }

    if( m_pConvolution )
    {
        punkCtrl->AddRef();
        m_pConvolution->Release();
    }

    return hr;
} /* CCrBlur::FinalRelease */

/*****************************************************************************
* CCrBlur::Setup *
*----------------*
*   Description:
*       This method is used to create the surface modifier, lookup table builder,
*   and convolution transform.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CCrBlur::Setup( IUnknown * const * punkInputs, ULONG ulNumIn,
                             IUnknown * const * punkOutputs, ULONG ulNumOut,
                             DWORD dwFlags )
{
    DXTDBG_FUNC( "CCrBlur::Setup" );
    HRESULT hr = S_OK;

    //--- Check for unsetup case
    if( ( ulNumIn == 0 ) && ( ulNumOut == 0 ) )
    {
        m_cpInputSurface.Release();
        m_cpOutputSurface.Release();
        if( m_pConvolutionTrans )
        {
            hr = m_pConvolutionTrans->Setup( NULL, 0, NULL, 0, 0 );
        }
        return hr;
    }

    //--- Validate the input ( the convolution setup will validate the rest )
    if( ( ulNumIn != 1 ) || ( ulNumOut != 1 ) ||
         DXIsBadReadPtr( punkInputs, sizeof( *punkInputs ) ) ||
         DXIsBadInterfacePtr( punkInputs[0] ) ||
         DXIsBadReadPtr( punkOutputs, sizeof( *punkOutputs ) ) ||
         DXIsBadInterfacePtr( punkOutputs[0] ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Save for later
        m_dwSetupFlags = dwFlags;
        m_cpOutputSurface = punkOutputs[0];

        //--- Get a DXSurface for the input
        m_cpInputSurface.Release();
        hr = punkInputs[0]->QueryInterface( IID_IDXSurface, (void**)&m_cpInputSurface );

        if( FAILED( hr ) )
        {
            IDirectDrawSurface* pDDSurf;
            hr = punkInputs[0]->QueryInterface( IID_IDirectDrawSurface, (void**)&pDDSurf );
            if( FAILED( hr ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                CComPtr<IObjectWithSite>    spObjectWithSite;
                CComPtr<IServiceProvider>   spServiceProvider;
                CComPtr<IDXSurfaceFactory>  spDXSurfaceFactory;

                hr = m_pConvolution->QueryInterface(__uuidof(IObjectWithSite),
                                                    (void **)&spObjectWithSite);

                if (SUCCEEDED(hr))
                {
                    hr = spObjectWithSite->GetSite(__uuidof(IServiceProvider), 
                                                   (void **)&spServiceProvider);
                }

                if (SUCCEEDED(hr))
                {
                    hr = spServiceProvider->QueryService(SID_SDXSurfaceFactory,
                                                         __uuidof(IDXSurfaceFactory),
                                                         (void **)&spDXSurfaceFactory);
                }

                if (SUCCEEDED(hr))
                {
                    //--- Create a DXSurface from the DDraw surface
                    hr = spDXSurfaceFactory->CreateFromDDSurface(
                                                    pDDSurf, NULL, 0, NULL, 
                                                    IID_IDXSurface,
                                                    (void **)&m_cpInputSurface);
                }
                else
                {
                    hr = DXTERR_UNINITIALIZED;
                }
            }
        }

        //--- Setup the convolution
        if( SUCCEEDED( hr ) )
        {
            //--- Attach the new input to the surface modifier
            hr = m_cpInSurfMod->SetForeground( m_cpInputSurface, false, NULL );
            if( SUCCEEDED( hr ) )
            {
                hr = _DoShadowSetup();
            }
        }
    }

    return hr;
} /* CCrBlur::Setup */

/*****************************************************************************
* CCrBlur::_SetPixelRadius *
*--------------------------*
*   Description:
*       This method 
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrBlur::put_PixelRadius( float PixelRadius )
{
    DXTDBG_FUNC( "CCrBlur::put_PixelRadius" );
    HRESULT hr = S_OK;

    if( ( PixelRadius < 0 ) || ( PixelRadius > 100. ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // We allow the user to enter a pixelradius of 0 since intuitively,
        // they think zero means "off", but really 0.5 means off.  So since
        // we need a kernel of at least 1 pixel, we bump up to 0.5 radius here.
        if (PixelRadius < 0.5)
            PixelRadius = 0.5;

        m_PixelRadius = PixelRadius;
        SIZE Size;
        Size.cy = Size.cx = (long)(2 * m_PixelRadius);
        int nPRSQ = Size.cy * Size.cx;
        float fPRSQ = 1.f/(float)nPRSQ;
        float* pFilt = (float*)alloca( nPRSQ * sizeof( float ) );
        for( int i = 0; i < nPRSQ; ++i ) pFilt[i] = fPRSQ;
        return m_pConvolution->SetCustomFilter( pFilt, Size );
    }
    return hr;
} /* CCrBlur::put_PixelRadius */

/*****************************************************************************
* CCrBlur::get_PixelRadius *
*--------------------------*
*   Description:
*       This method sets the value of the pixel radius when IDXEffect percent
*   complete is equal to one.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 06/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CCrBlur::get_PixelRadius( float *pPixelRadius )
{
    DXTDBG_FUNC( "CCrBlur::get_PixelRadius" );
    if( DXIsBadWritePtr( pPixelRadius, sizeof( *pPixelRadius ) ) )
    {
        return E_POINTER;
    }
    else
    {
        *pPixelRadius = m_PixelRadius;
        return S_OK;
    }
} /* CCrBlur::get_PixelRadius */

/*****************************************************************************
* CCrBlur::get_MakeShadow *
*-------------------------*
*   Description:
*       This method 
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CCrBlur::get_MakeShadow( VARIANT_BOOL *pVal )
{
    DXTDBG_FUNC( "CCrBlur::get_MakeShadow" );
    if( DXIsBadWritePtr( pVal, sizeof( *pVal ) ) )
    {
        return E_POINTER;
    }
    else
    {
        *pVal = m_bMakeShadow;
        return S_OK;
    }
} /* CCrBlur::get_MakeShadow */

/*****************************************************************************
* CCrBlur::get_MakeShadow *
*-------------------------*
*   Description:
*       This method 
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CCrBlur::put_MakeShadow( VARIANT_BOOL newVal )
{
    DXTDBG_FUNC( "CCrBlur::put_MakeShadow" );
    HRESULT hr = S_OK;

    if( m_bMakeShadow != newVal )
    {
        m_bMakeShadow = newVal;
        if( m_bSetupSucceeded )
        {
            hr = _DoShadowSetup();
        }
    }
    return hr;
} /* CCrBlur::put_MakeShadow */

//
//=== CCrEmboss implementation ==============================================
//
/*****************************************************************************
* CCrEmboss::FinalConstruct *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 06/11/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrEmboss::FinalConstruct()
{
    DXTDBG_FUNC( "CCrEmboss::FinalConstruct" );
    HRESULT hr = S_OK;
    m_pConvolution = NULL;

    //--- Create inner convolution
    IUnknown* punkCtrl = GetControllingUnknown();
    hr = ::CoCreateInstance( CLSID_DXTConvolution, punkCtrl, CLSCTX_INPROC,
                             IID_IUnknown, (void **)&m_cpunkConvolution );

    if( SUCCEEDED( hr ) )
    {
        hr = m_cpunkConvolution->QueryInterface( IID_IDXTConvolution, (void **)&m_pConvolution );
        if( SUCCEEDED( hr ) )
        {
            punkCtrl->Release();
            hr = m_pConvolution->SetFilterType( DXCFILTER_EMBOSS );
            if( SUCCEEDED( hr ) )
            {
                hr = m_pConvolution->SetConvertToGray( true );
            }
        }
    }

    return hr;
} /* CCrEmboss::FinalConstruct */

/*****************************************************************************
* CCrEmboss::FinalRelease *
*-------------------------*
*   Description:
*       The inner interfaces are released using COM aggregation rules. Releasing
*   the inner causes the outer to be released, so we addref the outer prior to
*   protect it.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 06/11/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrEmboss::FinalRelease()
{
    DXTDBG_FUNC( "CCrEmboss::FinalRelease" );
    HRESULT hr = S_OK;

    //--- Safely free the inner interfaces held
    IUnknown* punkCtrl = GetControllingUnknown();
    if( m_pConvolution )
    {
        punkCtrl->AddRef();
        m_pConvolution->Release();
        m_pConvolution = NULL;
    }

    return hr;
} /* CCrEmboss::FinalRelease */

//
//=== CCrEngrave implementation ==============================================
//
/*****************************************************************************
* CCrEngrave::FinalConstruct *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 06/11/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrEngrave::FinalConstruct()
{
    DXTDBG_FUNC( "CCrEngrave::FinalConstruct" );
    HRESULT hr = S_OK;
    m_pConvolution = NULL;

    //--- Create inner convolution
    IUnknown* punkCtrl = GetControllingUnknown();
    hr = ::CoCreateInstance( CLSID_DXTConvolution, punkCtrl, CLSCTX_INPROC,
                             IID_IUnknown, (void **)&m_cpunkConvolution );

    if( SUCCEEDED( hr ) )
    {
        hr = m_cpunkConvolution->QueryInterface( IID_IDXTConvolution, (void **)&m_pConvolution );
        if( SUCCEEDED( hr ) )
        {
            punkCtrl->Release();
            hr = m_pConvolution->SetFilterType( DXCFILTER_ENGRAVE );
            if( SUCCEEDED( hr ) )
            {
                hr = m_pConvolution->SetConvertToGray( true );
            }
        }
    }

    return hr;
} /* CCrEngrave::FinalConstruct */

/*****************************************************************************
* CCrEngrave::FinalRelease *
*--------------------------*
*   Description:
*       The inner interfaces are released using COM aggregation rules. Releasing
*   the inner causes the outer to be released, so we addref the outer prior to
*   protect it.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 06/11/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrEngrave::FinalRelease()
{
    DXTDBG_FUNC( "CCrEngrave::FinalRelease" );
    HRESULT hr = S_OK;

    //--- Safely free the inner interfaces held
    IUnknown* punkCtrl = GetControllingUnknown();
    if( m_pConvolution )
    {
        punkCtrl->AddRef();
        m_pConvolution->Release();
        m_pConvolution = NULL;
    }

    return hr;
} /* CCrEngrave::FinalRelease */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\crblur.h ===
/*******************************************************************************
* CrBlur.h *
*----------*
*   Description:
*       This is the header file for the Chrome wrapper implementations.
*-------------------------------------------------------------------------------
*  Created By: Ed Connell                            Date: 07/27/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef CrBlur_h
#define CrBlur_h

//--- Additional includes
#ifndef DTBase_h
#include <DTBase.h>
#endif

#include "resource.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================
class CCrBlur;
class CCrEmboss;
class CCrEngrave;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CCrBlur
*   This transform performs a blur using the DXConvolution transform.
*/
class ATL_NO_VTABLE CCrBlur : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCrBlur, &CLSID_CrBlur>,
    public CComPropertySupport<CCrBlur>,
    public IDispatchImpl<ICrBlur, &IID_ICrBlur, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IDXTransform,
    public IPersistStorageImpl<CCrBlur>,
    public ISpecifyPropertyPagesImpl<CCrBlur>,
    public IPersistPropertyBagImpl<CCrBlur>,
    public IObjectSafetyImpl2<CCrBlur>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_CRBLUR)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CCrBlur)
        COM_INTERFACE_ENTRY(ICrBlur)
        COM_INTERFACE_ENTRY(IDXTransform)
        COM_INTERFACE_ENTRY(IDXBaseObject)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CCrBlur>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND( m_cpunkConvolution.p )
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CCrBlur)
        PROP_ENTRY("MakeShadow"    , DISPID_CRB_MakeShadow    , CLSID_CrBlurPP)
        PROP_ENTRY("ShadowOpacity" , DISPID_CRB_ShadowOpacity , CLSID_CrBlurPP)
        PROP_ENTRY("PixelRadius"   , DISPID_CRB_PixelRadius   , CLSID_CrBlurPP)
        PROP_PAGE(CLSID_CrBlurPP)
    END_PROPERTY_MAP()
    
  /*=== Member Data ===*/
  protected:
    CComPtr<IDXSurface>         m_cpInputSurface;
    CComPtr<IUnknown>           m_cpOutputSurface;
    CComPtr<IDXLUTBuilder>      m_cpLUTBldr;
    CComPtr<IDXSurfaceModifier> m_cpInSurfMod;
    CComPtr<IDXSurface>         m_cpInSurfModSurf;
    CComPtr<IUnknown>           m_cpunkConvolution;
    IDXTConvolution*            m_pConvolution;
    IDXTransform*               m_pConvolutionTrans;
    VARIANT_BOOL                m_bMakeShadow;
    float                       m_ShadowOpacity;
    float                       m_PixelRadius;
    DWORD                       m_dwSetupFlags;
    BOOL                        m_bSetupSucceeded;

  /*=== Methods =======*/
  public:
    /*--- Constructors ---*/
    HRESULT FinalConstruct();
    HRESULT FinalRelease();
    HRESULT _DoShadowSetup();

  public:
    //=== IDXBaseObject =========================================
    STDMETHOD( GetGenerationId ) (ULONG * pGenId);
    STDMETHOD( IncrementGenerationId) (BOOL bRefresh);
    STDMETHOD( GetObjectSize ) (ULONG * pcbSize); 

    //=== IDXTransform (These are all delegated to the convolution except Setup) ====
    STDMETHOD( Setup )( IUnknown * const * punkInputs, ULONG ulNumIn, IUnknown * const * punkOutputs, ULONG ulNumOut, DWORD dwFlags );
    STDMETHOD( Execute )( const GUID* pRequestID, const DXBNDS *pOutBounds, const DXVEC *pPlacement );
    STDMETHOD( MapBoundsIn2Out )( const DXBNDS *pInBounds, ULONG ulNumInBnds, ULONG ulOutIndex, DXBNDS *pOutBounds );
    STDMETHOD( MapBoundsOut2In )( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds );
    STDMETHOD( SetMiscFlags ) ( DWORD dwOptionFlags );
    STDMETHOD( GetMiscFlags ) ( DWORD * pdwMiscFlags );
    STDMETHOD( GetInOutInfo )( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags, GUID * pIDs, ULONG * pcIDs, IUnknown **ppUnkCurObj);
    STDMETHOD( SetQuality )( float fQuality );
    STDMETHOD( GetQuality )( float *pfQuality );

    //=== ICrBlur ======================================================
    STDMETHOD( get_MakeShadow )( VARIANT_BOOL *pVal );
    STDMETHOD( put_MakeShadow )( VARIANT_BOOL newVal );
    STDMETHOD( get_ShadowOpacity )( float *pVal );
    STDMETHOD( put_ShadowOpacity )( float newVal );
    STDMETHOD( get_PixelRadius )( float *pPixelRadius );
    STDMETHOD( put_PixelRadius )( float PixelRadius );
};

/*** CCrEmboss
*   This transform performs an embossing using the DXConvolution transform.
*/
class ATL_NO_VTABLE CCrEmboss : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCrEmboss, &CLSID_CrEmboss>,
    public CComPropertySupport<CCrEmboss>,
    public IDispatchImpl<ICrEmboss, &IID_ICrEmboss, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IPersistStorageImpl<CCrEmboss>,
    public ISpecifyPropertyPagesImpl<CCrEmboss>,
    public IPersistPropertyBagImpl<CCrEmboss>,
    public IObjectSafetyImpl2<CCrEmboss>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_CREMBOSS)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CCrEmboss)
        COM_INTERFACE_ENTRY(ICrEmboss)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CCrEmboss>)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_cpunkConvolution.p)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CCrEmboss)
        PROP_ENTRY("Bias", DISPID_CRB_MakeShadow, CLSID_NULL)
//        PROP_PAGE(CLSID_NULL)
    END_PROPERTY_MAP()

  /*=== Member Data ===*/
  protected:
    CComPtr<IUnknown>   m_cpunkConvolution;
    IDXTConvolution*    m_pConvolution;

  /*=== Methods =======*/
  public:
    /*--- Constructors ---*/
    HRESULT FinalConstruct();
    HRESULT FinalRelease();

    //=== ICrEmboss =================================================
    STDMETHOD( get_Bias )( float *pVal  ) { return m_pConvolution->GetBias( pVal ); }
    STDMETHOD( put_Bias )( float newVal ) { return m_pConvolution->SetBias( newVal ); }
};

/*** CCrEngrave
*   This transform performs an engraving using the DXConvolution transform.
*/
class ATL_NO_VTABLE CCrEngrave : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCrEngrave, &CLSID_CrEngrave>,
    public CComPropertySupport<CCrEngrave>,
    public IDispatchImpl<ICrEngrave, &IID_ICrEngrave, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IPersistStorageImpl<CCrEngrave>,
    public ISpecifyPropertyPagesImpl<CCrEngrave>,
    public IPersistPropertyBagImpl<CCrEngrave>,
    public IObjectSafetyImpl2<CCrEngrave>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_CRENGRAVE)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CCrEngrave)
        COM_INTERFACE_ENTRY(ICrEngrave)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CCrEngrave>)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_cpunkConvolution.p)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CCrEngrave)
        PROP_ENTRY("Bias", DISPID_CRB_MakeShadow, CLSID_NULL)
//        PROP_PAGE(CLSID_NULL)
    END_PROPERTY_MAP()

  /*=== Member Data ===*/
  protected:
    CComPtr<IUnknown>   m_cpunkConvolution;
    IDXTConvolution*    m_pConvolution;

  /*=== Methods =======*/
  public:
    /*--- Constructors ---*/
    HRESULT FinalConstruct();
    HRESULT FinalRelease();

    //=== ICrEngrave =================================================
    STDMETHOD( get_Bias )( float *pVal  ) { return m_pConvolution->GetBias( pVal ); }
    STDMETHOD( put_Bias )( float newVal ) { return m_pConvolution->SetBias( newVal ); }
};

//=== Inline Function Definitions ==================================
inline STDMETHODIMP CCrBlur::GetGenerationId( ULONG * pGenId )
{
    return m_pConvolutionTrans->GetGenerationId( pGenId );
}

inline STDMETHODIMP CCrBlur::IncrementGenerationId( BOOL bRefresh )
{
    return m_pConvolutionTrans->IncrementGenerationId( bRefresh );
}

inline STDMETHODIMP CCrBlur::GetObjectSize( ULONG * pcbSize )
{
    return m_pConvolutionTrans->GetObjectSize( pcbSize );
}

inline STDMETHODIMP CCrBlur::Execute( const GUID* pRequestID, const DXBNDS *pOutBounds, const DXVEC *pPlacement )
{
    return m_pConvolutionTrans->Execute( pRequestID, pOutBounds, pPlacement );
}

inline STDMETHODIMP CCrBlur::MapBoundsIn2Out( const DXBNDS *pInBounds, ULONG ulNumInBnds, ULONG ulOutIndex, DXBNDS *pOutBounds )
{
    return m_pConvolutionTrans->MapBoundsIn2Out( pInBounds, ulNumInBnds, ulOutIndex, pOutBounds );
}

inline STDMETHODIMP CCrBlur::MapBoundsOut2In( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds )
{
    return m_pConvolutionTrans->MapBoundsOut2In( ulOutIndex, pOutBounds, ulInIndex, pInBounds );
}

inline STDMETHODIMP CCrBlur::SetMiscFlags( DWORD dwOptionFlags )
{
    return m_pConvolutionTrans->SetMiscFlags( dwOptionFlags );
}

inline STDMETHODIMP CCrBlur::GetMiscFlags( DWORD * pdwMiscFlags )
{
    return m_pConvolutionTrans->GetMiscFlags( pdwMiscFlags );
}

inline STDMETHODIMP CCrBlur::GetInOutInfo( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags, GUID * pIDs, ULONG * pcIDs, IUnknown **ppUnkCurObj)
{
    return m_pConvolutionTrans->GetInOutInfo( bOutput, ulIndex, pdwFlags, pIDs, pcIDs, ppUnkCurObj );
}

inline STDMETHODIMP CCrBlur::SetQuality( float fQuality )
{
    return m_pConvolutionTrans->SetQuality( fQuality );
}

inline STDMETHODIMP CCrBlur::GetQuality( float *pfQuality )
{
    return m_pConvolutionTrans->GetQuality( pfQuality );
}

inline STDMETHODIMP CCrBlur::get_ShadowOpacity( float *pVal )
{
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr( pVal, sizeof( *pVal ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_ShadowOpacity;
    }
    return hr;
}

inline STDMETHODIMP CCrBlur::put_ShadowOpacity( float newVal )
{
    HRESULT hr = S_OK;
    if( ( newVal < 0. ) || ( newVal > 1.0 ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_ShadowOpacity = newVal;
        hr = m_cpLUTBldr->SetOpacity( m_ShadowOpacity );
    }
    return hr;
}

inline HRESULT CCrBlur::_DoShadowSetup()
{
    HRESULT hr = S_OK;
    if( m_bMakeShadow )
    {
        //--- Indirect through the surface modifier to make a shadow
        hr = m_pConvolutionTrans->Setup( (IUnknown**)&m_cpInSurfModSurf.p, 1,
                                         (IUnknown**)&m_cpOutputSurface.p, 1,
                                          m_dwSetupFlags );
    }
    else
    {
        hr = m_pConvolutionTrans->Setup( (IUnknown**)&m_cpInputSurface.p, 1,
                                         (IUnknown**)&m_cpOutputSurface.p, 1,
                                          m_dwSetupFlags );
    }
    m_bSetupSucceeded = ( SUCCEEDED( hr ) )?(true):(false);

    return hr;
}

//=== Macro Definitions ============================================

//=== Global Data Declarations =====================================

//=== Function Prototypes ==========================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\colormanagement.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    colormanagement.cpp
//
// Description: Color management filter transform.
//
// Change History:
//
// 2000/02/06   mcalkins    Created.  Ported code from an old filter.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "colormanagement.h"




//+-----------------------------------------------------------------------------
//
//  CDXTICMFilter static variables initialization.
//
//------------------------------------------------------------------------------

const TCHAR * 
CDXTICMFilter::s_strSRGBColorSpace = _T("sRGB Color Space Profile.icm");


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::CDXTICMFilter
//
//------------------------------------------------------------------------------
CDXTICMFilter::CDXTICMFilter() :
    m_bstrColorSpace(NULL)
{
    USES_CONVERSION;

    OSVERSIONINFO osvi;

    // Initialize LOGCOLORSPACE structure.

    m_LogColorSpace.lcsSignature = 'PSOC';
    m_LogColorSpace.lcsVersion   = 0x0400;
    m_LogColorSpace.lcsSize      = sizeof(LOGCOLORSPACE);
    m_LogColorSpace.lcsCSType    = LCS_CALIBRATED_RGB;
    m_LogColorSpace.lcsIntent    = LCS_GM_IMAGES;

    ::StringCchCopyW(m_LogColorSpace.lcsFilename, MAX_PATH, s_strSRGBColorSpace);

    // Are we on Win95 specifically?

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    if ((osvi.dwMajorVersion == 4) && (osvi.dwMinorVersion == 0) 
        && (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS))
    {
        m_fWin95 = true;
    }
    else
    {
        m_fWin95 = false;
    }

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;

    // Let's not deal with multithreading this transform.  Too many shared
    // structures.

    m_ulMaxImageBands   = 1;
}
//  Method:  CDXTICMFilter::CDXTICMFilter


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTICMFilter::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_spUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_bstrColorSpace = SysAllocString(L"sRGB");

    if (NULL == m_bstrColorSpace)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  Method:  CDXTICMFilter::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTICMFilter::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pfContinueProcessing)
{
    HRESULT                         hr              = S_OK;
    HDC                             hdcOut          = NULL;
    HDC                             hdcIn           = NULL;
    HDC                             hdcCompat       = NULL;
    HBITMAP                         hBitmap         = NULL;
    HBITMAP                         hOldBitmap      = NULL;
    HCOLORSPACE                     hColorSpace     = NULL;
    HCOLORSPACE                     hOldColorSpace  = NULL;
    int                             y               = 0;
    int                             nICMMode        = ICM_OFF;
    int                             nLines          = 0;
    const int                       nDoWidth        = WI.DoBnds.Width();
    const int                       nDoHeight       = WI.DoBnds.Height();

    BYTE *                          pBitmapBits     = NULL;
    BITMAPINFOHEADER *              pbmi            = NULL;
    DXPMSAMPLE *                    pOverScratch    = NULL;
    DXPMSAMPLE *                    pPMBuff         = NULL;
    DXSAMPLE *                      pBuffer         = NULL;

    CComPtr<IDXDCLock>              spDXDCLockOut;
    CComPtr<IDXDCLock>              spDXDCLockIn;

    DXDITHERDESC                    dxdd;
    RECT                            rcCompatDCClip;

    // Lock output surface.

    hr = OutputSurface()->LockSurfaceDC(&WI.OutputBnds, m_ulLockTimeOut, 
                                        DXLOCKF_READWRITE, &spDXDCLockOut);

    if (FAILED(hr))
    {
        goto done;
    }

    hdcOut = spDXDCLockOut->GetDC();

    // Lock input surface.

    hr = InputSurface()->LockSurfaceDC(&WI.DoBnds, m_ulLockTimeOut,
                                       DXLOCKF_READ, &spDXDCLockIn);

    if (FAILED(hr))
    {
        goto done;
    }
    
    hdcIn = spDXDCLockIn->GetDC();

    // Create a compatible DC to hdcOut.

    if (!(hdcCompat = ::CreateCompatibleDC(hdcOut)))
    {
        hr = E_FAIL;

        goto done;
    }

    // Create a compatible bitmap.

    if (!(hBitmap = ::CreateCompatibleBitmap(hdcOut, nDoWidth, nDoHeight)))
    {
        hr = E_FAIL;

        goto done;
    }

    // Select the compatible bitmap into our compatible DC.

    if (!(hOldBitmap = (HBITMAP)::SelectObject(hdcCompat, hBitmap)))
    {
        hr = E_FAIL;

        goto done;
    }

    // Create an appropriate clipping rectangle for the new DC.

    rcCompatDCClip.left     = 0;
    rcCompatDCClip.top      = 0;
    rcCompatDCClip.right    = nDoWidth;
    rcCompatDCClip.bottom   = nDoHeight;

    // Blit from the input surface onto our output compatible DC.

    if (!::BitBlt(hdcCompat, 0, 0, nDoWidth, nDoHeight, hdcIn, WI.DoBnds.Left(),
                  WI.DoBnds.Top(), SRCCOPY))
    {
        hr = E_FAIL;

        goto done;
    }

#if DBG == 1
    ::DrawText(hdcCompat, L"ICM Filter", 10, &rcCompatDCClip, 
               DT_CENTER | DT_SINGLELINE | DT_VCENTER);
#endif // DBG == 1

    // Allocate some bitmap bits.  

    // TODO: (mcalkins) We alocate 1MB of bits here, copied from old
    //        ICMFilter, maybe we could only allocate as much as we need.

    pBitmapBits = new BYTE[1024*1024];

    if (NULL == pBitmapBits)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    ZeroMemory(pBitmapBits, 1024*1024);

    // Allocate a bitmap info header.

    pbmi = (BITMAPINFOHEADER *) new BYTE[sizeof(BITMAPINFOHEADER) + (256 * sizeof(RGBQUAD))];

    if (NULL == pbmi)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    ZeroMemory(pbmi, sizeof(BITMAPINFOHEADER) + (256 * sizeof(RGBQUAD)));

    pbmi->biSize = sizeof(BITMAPINFOHEADER);

    // Fill in the BITMAPINFO structure.

    nLines = ::GetDIBits(hdcCompat, hBitmap, 0, nDoHeight, NULL,
                         (BITMAPINFO *)pbmi, DIB_RGB_COLORS);

    if (0 == nLines)
    {
#if DBG == 1
        DWORD dwError = ::GetLastError();
#endif
        
        hr = E_FAIL;

        goto done;
    }

    // Actually get the bits.

    nLines = ::GetDIBits(hdcCompat, hBitmap, 0, nDoHeight, pBitmapBits,
                         (BITMAPINFO *)pbmi, DIB_RGB_COLORS);

    if (0 == nLines)
    {
#if DBG == 1
        DWORD dwError = ::GetLastError();
#endif

        hr = E_FAIL;

        goto done;
    }

    // Make sure ICMMode is on for the output.

    nICMMode = ::SetICMMode(hdcOut, ICM_QUERY);

    if (nICMMode != ICM_ON)
    {
        if (!::SetICMMode(hdcOut, ICM_ON))
        {
            hr = E_FAIL;

            goto done;
        }
    }

    hColorSpace = ::CreateColorSpace(&m_LogColorSpace);

    if (NULL == hColorSpace)
    {
        hr = E_FAIL;

        goto done;
    }

    hOldColorSpace = (HCOLORSPACE)::SetColorSpace(hdcOut, hColorSpace);

    nLines = ::SetDIBitsToDevice(hdcOut, WI.OutputBnds.Left(),
                                 WI.OutputBnds.Top(), nDoWidth, nDoHeight, 0, 0,
                                 0, nDoHeight, pBitmapBits, (BITMAPINFO *)pbmi, 
                                 DIB_RGB_COLORS);

    if (0 == nLines)
    {
#if DBG == 1
        DWORD dwError = ::GetLastError();
#endif
        hr = E_FAIL;

        goto done;
    }
    
    // Reset ICMMode on output surface to what it was before.

    if (nICMMode != ICM_ON)
    {
        // It's possible but unlikely that this will fail.  We really don't care
        // anymore, so no need to pay attention.

        ::SetICMMode(hdcOut, nICMMode);
    }

done:

    if (pBitmapBits)
    {
        delete [] pBitmapBits;
    }

    if (pbmi)
    {
        delete [] pbmi;
    }

    if (hOldBitmap)
    {
        ::SelectObject(hdcCompat, hOldBitmap);
    }

    if (hBitmap)
    {
        ::DeleteObject(hBitmap);
    }

    if (hdcCompat)
    {
        ::DeleteDC(hdcCompat);
    }

    if (hOldColorSpace)
    {
        ::SetColorSpace(hdcOut, hOldColorSpace);
    }

    if (hColorSpace)
    {
        ::DeleteColorSpace(hColorSpace);
    }

    return hr;
}
//  Method:  CDXTICMFilter::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::get_ColorSpace, IDXTICMFilter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTICMFilter::get_ColorSpace(BSTR * pbstrColorSpace)
{
    HRESULT hr = S_OK;

    if (NULL == pbstrColorSpace)
    {
        hr = E_POINTER;

        goto done;
    }

    if (*pbstrColorSpace != NULL)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    *pbstrColorSpace = SysAllocString(m_bstrColorSpace);

    if (NULL == *pbstrColorSpace)
    {
        hr = E_OUTOFMEMORY;
    }

done:

    return hr;
}
//  Method:  CDXTICMFilter::get_ColorSpace, IDXTICMFilter


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::put_ColorSpace, IDXTICMFilter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTICMFilter::put_ColorSpace(BSTR bstrColorSpace)
{
    HRESULT hr                  = S_OK;
    UINT    ui                  = 0;
    BSTR    bstrTemp            = NULL;
    TCHAR   strPath[MAX_PATH]   = _T("");
    BOOL    fAllow              = FALSE;

    CComPtr<IServiceProvider>   spServiceProvider;
    CComPtr<ISecureUrlHost>     spSecureUrlHost;
    
    if (NULL == bstrColorSpace)
    {
        hr = E_POINTER;

        goto done;
    }

    bstrTemp = SysAllocString(bstrColorSpace);

    if (NULL == bstrTemp)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    if (m_fWin95)
    {
        ui = ::GetSystemDirectory(strPath, MAX_PATH);

        if (0 == ui)
        {
            hr = E_FAIL;

            goto done;
        }

        hr = ::StringCchCatW(strPath, MAX_PATH, L"\\color\\");

        if (FAILED(hr))
        {
            goto done;
        }
    }

    // Complete path.

    if (!::_wcsicmp(L"srgb", bstrColorSpace))
    {
        hr = ::StringCchCatW(strPath, MAX_PATH, s_strSRGBColorSpace);

        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = ::StringCchCatW(strPath, MAX_PATH, bstrColorSpace);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = GetSite(__uuidof(IServiceProvider), (void **)&spServiceProvider);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProvider->QueryService(__uuidof(IElementBehaviorSite),
                                         __uuidof(ISecureUrlHost),
                                         (void **)&spSecureUrlHost);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSecureUrlHost->ValidateSecureUrl(&fAllow, strPath, 0);

    if (FAILED(hr))
    {
        goto done;
    }
    else if (!fAllow)
    {
        hr = E_FAIL;
        goto done;
    }
      
    // Copy path to LOGCOLORSPACE structure.

    hr = ::StringCchCopyW(m_LogColorSpace.lcsFilename, MAX_PATH, strPath);

    if (FAILED(hr))
    {
        goto done;
    }

    // Free current color space string.

    if (m_bstrColorSpace)
    {
        SysFreeString(m_bstrColorSpace);
    }

    // Save new color space string.

    m_bstrColorSpace = bstrTemp;

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  Method:  CDXTICMFilter::put_ColorSpace, IDXTICMFilter


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::get_Intent, IDXTICMFilter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTICMFilter::get_Intent(short * pnIntent)
{
    if (NULL == pnIntent)
    {
        return E_POINTER;
    }

    // It's kind of a crazy mapping, but here it is:
    // Filter Intent    GDI Intent
    // -------------    ----------------------------
    //  0                LCS_GM_IMAGES (default)
    //  1                LCS_GM_GRAPHICS
    //  2                LCS_GM_BUSINESS
    //  4                LCS_GM_ABS_COLORIMETRIC

    switch (m_LogColorSpace.lcsIntent)
    {
    case LCS_GM_IMAGES:
        *pnIntent = 0;
        break;

    case LCS_GM_GRAPHICS:
        *pnIntent = 1;
        break;

    case LCS_GM_BUSINESS:
        *pnIntent = 2;
        break;

    case LCS_GM_ABS_COLORIMETRIC:
        *pnIntent = 4;
        break;
    
    default:
        *pnIntent = 0;
        _ASSERT(false);  // We should never get here.
        break;
    }

    return S_OK;
}
//  Method:  CDXTICMFilter::get_Intent, IDXTICMFilter


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::put_Intent, IDXTICMFilter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTICMFilter::put_Intent(short nIntent)
{
    // No parameter checking to match old filter logic.

    switch (nIntent)
    {
    case 1:
        m_LogColorSpace.lcsIntent = LCS_GM_GRAPHICS;
        break;

    case 2:
        m_LogColorSpace.lcsIntent = LCS_GM_BUSINESS;
        break;

    case 4:
        m_LogColorSpace.lcsIntent = LCS_GM_ABS_COLORIMETRIC; // 8
        break;

    default:
        m_LogColorSpace.lcsIntent = LCS_GM_IMAGES;
        break;
    }

    return S_OK;
}
//  Method:  CDXTICMFilter::put_Intent, IDXTICMFilter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\convolve.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998-2000
//
//  FileName:   convolve.cpp
//
//  Overview:   The CDXConvolution transform implementation.
//             
//  Change History:
//  1998/05/08  edc         Created.
//  2000/02/08  mcalkins    Fixed partial redraw cases.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "Convolve.h"
#include <math.h>

static SIZE g_StaticFilterSize = { 3, 3 };
static float g_SharpenFilter[] = { 0, -1, 0, -1, 5, -1, 0, -1, 0 };
static float g_EmbossFilter[] = { 1, 0, 0, 0, 0, 0, 0, 0, -1 };
static float g_EngraveFilter[] = { -1, 0, 0, 0, 0, 0, 0, 0, 1 };

static float g_Blur3x3Filter[] = 
    { 1.f/16.f, 1.f/8.f, 1.f/16.f, 1.f/8.f , 1.f/4.f, 1.f/8.f , 1.f/16.f, 1.f/8.f, 1.f/16.f };


    
    
/*****************************************************************************
* CDXConvolution::FinalConstruct *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 08/08/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT 
CDXConvolution::FinalConstruct()
{
    DXTDBG_FUNC( "CDXConvolution::FinalConstruct" );

    HRESULT hr = S_OK;

    // Some transforms should just not run multithreaded, this is one of them.
    // It locks and unlocks inputs and outputs too radically which could cause
    // lockups very easily.

    m_ulMaxImageBands = 1;

    // Init base class variables to control setup.

    m_ulMaxInputs     = 1;
    m_ulNumInRequired = 1;

    // Member data.

    m_pFilter              = NULL;
    m_pCustomFilter        = NULL;
    m_pFilterLUTIndexes    = NULL;
    m_pPMCoeffLUT          = NULL;
    m_bConvertToGray       = false;
    m_bDoSrcCopyOnly       = false;
    m_MarginedSurfSize.cx  = 0;
    m_MarginedSurfSize.cy  = 0;
    m_Bias                 = 0.;
    m_bExcludeAlpha        = true;

    // Set the default filter, this will initialize the rest of the
    // member variables.

    hr = SetFilterType(DXCFILTER_BLUR3X3);

    if (FAILED(hr))
    {
        goto done;
    }

    // Create marshaler.

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_spUnkMarshaler);

done:

    return hr;
} /* CDXConvolution::FinalConstruct */


/*****************************************************************************
* CDXConvolution::FinalRelease *
*------------------------------*
*   Description:
*       The CDXConvolution destructor
*-----------------------------------------------------------------------------
*  Created By: Ed Connell                            Date: 07/17/97
*-----------------------------------------------------------------------------
*   Parameters:
*
*****************************************************************************/
void CDXConvolution::FinalRelease( void )
{
    DXTDBG_FUNC( "CDXConvolution::FinalRelease" );
    delete[] m_pCustomFilter;
    delete[] m_pFilterLUTIndexes;
    delete[] m_pPMCoeffLUT;
} /* CDXConvolution::FinalRelease */


/*****************************************************************************
* CDXConvolution::OnSetup *
*-------------------------*
*   Description:
*       This method is used to determine the types of the inputs and select
*   the optimal execution case.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 01/06/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXConvolution::OnSetup( DWORD dwFlags )
{
    DXTDBG_FUNC( "CDXConvolution::OnSetup" );
    HRESULT hr = S_OK;

    //--- Cache input surface size
    hr = InputSurface()->GetBounds( &m_InputSurfBnds );

    _DetermineUnpackCase();

    return hr;
} /* CDXConvolution::OnSetup */


/*****************************************************************************
* CDXConvolution::_DetermineUnpackCase *
*--------------------------------------*
*   Description:
*       This method is used to determine the types of the inputs and select
*   the optimal execution case.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 06/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
void CDXConvolution::_DetermineUnpackCase()
{
    DXTDBG_FUNC( "CDXConvolution::_DetermineUnpackCase" );
    HRESULT hr = S_OK;

    if( HaveInput() )
    {
        //--- Figure out how to unpack input and output
        if( m_bDoSampleClamp )
        {
            m_bInUnpackPremult  = false;
            m_bOutUnpackPremult = ( m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT )?(true):(false);
        }
        else
        {
            if( m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT )
            {
                //--- Has gotta be premult to do the over
                m_bInUnpackPremult = true;
                m_bOutUnpackPremult = true;
            }
            else
            {
                //--- Match the output format
                m_bInUnpackPremult  = ( OutputSampleFormat() & DXPF_NONPREMULT )?( false ):( true );
                m_bOutUnpackPremult = m_bInUnpackPremult;
            }
        }

        //--- Determine whether we need buffers
        if( (  m_bOutUnpackPremult   && ( OutputSampleFormat() == DXPF_PMARGB32 )) ||
            ( (!m_bOutUnpackPremult) && ( OutputSampleFormat() == DXPF_ARGB32   )) )
        {
            m_bNeedOutUnpackBuff = false;
        }
        else
        {
            m_bNeedOutUnpackBuff = true;
        }

        //
        //  We need the input buffer if we are dithering even if it's in the native
        //  format because we will dither in place
        //
        if( ( m_bInUnpackPremult   && ( InputSampleFormat() == DXPF_PMARGB32 )) ||
            ((!m_bInUnpackPremult) && ( InputSampleFormat() == DXPF_ARGB32  )) )
        {
            m_bNeedInUnpackBuff = false;
        }
        else
        {
            m_bNeedInUnpackBuff = true;
        }
    }
} /* CDXConvolution::_DetermineUnpackCase */


/*****************************************************************************
* CDXConvolution::OnInitInstData *
*--------------------------------*
*   Description:
*       This method is called once per execution.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 08/08/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXConvolution::OnInitInstData( CDXTWorkInfoNTo1& WI, ULONG& ulNB )
{
    DXTDBG_FUNC( "CDXConvolution::OnInitInstData" );
    HRESULT hr = S_OK;

    //--- Save base row when banding
    m_DoBndsBaseRow = WI.DoBnds.Top();

    //--- Create/resize the margined surface if necessary
    CDXDBnds InBnds( false );
    hr = MapBoundsOut2In( 0, &m_InputSurfBnds, 0, &InBnds );

    if( SUCCEEDED( hr ) )
    {
        CDXDBnds Bnds( InBnds );

        //--- We need a surface with an extra row/col to
        //    handle an inner loop boundary condition.
        Bnds[DXB_X].Max += ( 4 * m_FilterSize.cx ) + 1;
        Bnds[DXB_Y].Max += ( 4 * m_FilterSize.cy ) + 1;

        if( ( m_cpMarginedSurf == NULL ) ||
            ( (long)Bnds.Width()  > m_MarginedSurfSize.cx ) ||
            ( (long)Bnds.Height() > m_MarginedSurfSize.cy ) )
        {
            DXTDBG_MSG0( _CRT_WARN, "Creating Margined Surface\n" );
            m_cpMarginedSurf.Release();

            //--- Force a surface refresh
            m_LastDoBnds.SetEmpty();

            //--- Make our working surface the same format as the
            //    unpack type for performance reasons
            m_bMarginedIsPremult = m_bInUnpackPremult;
            const GUID* pPixelFormat = ( m_bInUnpackPremult )?( &DDPF_PMARGB32 ):( &DDPF_ARGB32 );

            hr = m_cpSurfFact->CreateSurface( NULL, NULL, pPixelFormat, &Bnds, 0, NULL,
                                              IID_IDXSurface, (void**)&m_cpMarginedSurf );

            if( SUCCEEDED( hr ) )
            {
                Bnds.GetXYSize( m_MarginedSurfSize );
            }
            else
            {
                //--- Make sure it's null on error because we key off it above.
                DXTDBG_MSG0( _CRT_WARN, "Failed to create Margined Surface\n" );
                m_cpMarginedSurf.p = NULL;
            }
        }
        else
        {
            //--- We call this to convert the current sample format
            //    in case we don't have to resize the margined surface.
            hr = _SetToPremultiplied( m_bInUnpackPremult );
        }
    }

    //--- Update our working surface contents if we have one and its necessary
    if( SUCCEEDED( hr ) && ( ( InBnds != m_LastDoBnds ) || IsInputDirty() ) )
    {
        m_LastDoBnds = InBnds;

        //--- Determine what portion of the input should be copied
        //    Note: Since our working surface has a margin, to eliminate boundary
        //          conditions in the inner loop, we must fill it with something.
        //          if the requested region plus its margin is within the bounds of
        //          the input, we fill fill the margins with input data, otherwise
        //          we will fill it with 0 alpha.
        CDXDBnds DestBnds( false );
        SIZE HalfSpread, DestOffset;

        // We used to use just half the spread, but that wasn't always enough
        // so now we use the whole spread at the risk that maybe we'll have too 
        // much input.

        HalfSpread.cx = m_OutputSpread.cx;
        HalfSpread.cy = m_OutputSpread.cy;

        //=== Expand the input bounds to include margin ===
        //--- X Min
        if( InBnds[DXB_X].Min - HalfSpread.cx < 0 )
        {
            DestOffset.cx = m_OutputSpread.cx - InBnds[DXB_X].Min;
            InBnds[DXB_X].Min = 0;
        }
        else
        {
            InBnds[DXB_X].Min -= HalfSpread.cx;
            DestOffset.cx = HalfSpread.cx;
        }
        //--- X Max
        InBnds[DXB_X].Max += HalfSpread.cx;
        if( InBnds[DXB_X].Max > m_InputSurfBnds[DXB_X].Max )
        {
            InBnds[DXB_X].Max = m_InputSurfBnds[DXB_X].Max;
        }

        //--- Y Min
        if( InBnds[DXB_Y].Min - HalfSpread.cy < 0 )
        {
            DestOffset.cy = m_OutputSpread.cy - InBnds[DXB_Y].Min;
            InBnds[DXB_Y].Min = 0;
        }
        else
        {
            InBnds[DXB_Y].Min -= HalfSpread.cy;
            DestOffset.cy = HalfSpread.cy;
        }
        //--- Y Max
        InBnds[DXB_Y].Max += HalfSpread.cy;
        if( InBnds[DXB_Y].Max > m_InputSurfBnds[DXB_Y].Max )
        {
            InBnds[DXB_Y].Max = m_InputSurfBnds[DXB_Y].Max;
        }

        //--- Do the blit filling the margins with 0 alpha
        //InBnds.GetSize( DestBnds );
        //DestBnds.Offset( DestOffset.cx, DestOffset.cy, 0, 0 );

        DestBnds = InBnds;
        DestBnds.Offset(m_FilterSize.cx, m_FilterSize.cy, 0, 0);

        hr = DXFillSurface(m_cpMarginedSurf, 0);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = DXBitBlt(m_cpMarginedSurf, DestBnds, InputSurface(), InBnds, 0, 10000);

        if (FAILED(hr))
        {
            goto done;
        }

        if (m_bConvertToGray)
        {
            hr = _ConvertToGray(DestBnds);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    return hr;
} /* CDXConvolution::OnInitInstData */


/*****************************************************************************
* CDXConvolution::_ConvertToGray *
*--------------------------------*
*   Description:
*       This method is called to convert the cached image to gray scale.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 08/08/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXConvolution::_ConvertToGray( CDXDBnds& Bnds )
{
    DXTDBG_FUNC( "CDXConvolution::ConvertToGray" );
    HRESULT hr = S_OK;

    CComPtr<IDXARGBReadWritePtr> cpSurf;
    hr = m_cpMarginedSurf->LockSurface( &Bnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                        IID_IDXARGBReadWritePtr, (void**)&cpSurf, NULL );
    if( SUCCEEDED( hr ) )
    {
        cpSurf->GetNativeType( &m_MarginedSurfInfo );
        DXBASESAMPLE* pSamp = (DXBASESAMPLE*)m_MarginedSurfInfo.pFirstByte;
        ULONG Wid = Bnds.Width(), Hgt = Bnds.Height();

        for( ULONG y = 0; y < Hgt; ++y )
        {
            for( ULONG x = 0; x < Wid; ++x )
            {
                pSamp[x] = DXConvertToGray( pSamp[x] );
            }
            pSamp = (DXBASESAMPLE*)(((BYTE*)pSamp) + m_MarginedSurfInfo.lPitch);
        }
    }

    return hr;
} /* CDXConvolution::_ConvertToGray */


/*****************************************************************************
* CDXConvolution::_SetToPremultiplied *
*-------------------------------------*
*   Description:
*       This method is called to convert the cached image to either
*   premultiplied or non-premultiplied samples.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 06/16/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXConvolution::_SetToPremultiplied( BOOL bWantPremult )
{
    DXTDBG_FUNC( "CDXConvolution::_SetToPremultiplied" );
    HRESULT hr = S_OK;

    if( m_cpMarginedSurf && ( m_bMarginedIsPremult != bWantPremult ) )
    {
        m_bMarginedIsPremult = bWantPremult;

        CComPtr<IDXARGBReadWritePtr> cpSurf;
        hr = m_cpMarginedSurf->LockSurface( NULL, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                            IID_IDXARGBReadWritePtr, (void**)&cpSurf, NULL );
        if( SUCCEEDED( hr ) )
        {
            cpSurf->GetNativeType( &m_MarginedSurfInfo );
            DXBASESAMPLE* pSamp = (DXBASESAMPLE*)m_MarginedSurfInfo.pFirstByte;

            for( long y = 0; y < m_MarginedSurfSize.cy; ++y )
            {
                if( bWantPremult )
                {
                    DXPreMultArray( (DXSAMPLE*)pSamp, m_MarginedSurfSize.cx );
                }
                else
                {
                    DXUnPreMultArray( (DXPMSAMPLE*)pSamp, m_MarginedSurfSize.cx );
                }
                pSamp = (DXBASESAMPLE*)(((BYTE*)pSamp) + m_MarginedSurfInfo.lPitch);
            }
        }
    }
    return hr;
} /* CDXConvolution::_SetToPremultiplied */


//
//=== IDXTransform overrides =================================================
//


/*****************************************************************************
* CDXConvolution::MapBoundsIn2Out *
*---------------------------------*
*   Description:
*       The MapBoundsIn2Out method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 10/24/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXConvolution::MapBoundsIn2Out( const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                              ULONG ulOutIndex, DXBNDS *pOutBounds )
{
    DXTDBG_FUNC( "CDXConvolution::MapBoundsIn2Out" );
    HRESULT hr = S_OK;
    
    if( ( ulNumInBnds && DXIsBadReadPtr( pInBounds, sizeof( *pInBounds ) * ulNumInBnds ) ) ||
        ( ulNumInBnds > 1 ) || ( ulOutIndex > 0 ) )
    {
        hr = E_INVALIDARG;
    }
    else if( DXIsBadWritePtr( pOutBounds, sizeof( *pOutBounds ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- If the caller does not specify a bounds we
        //    will use the bounds of the input
        CDXDBnds Bnds;
        if( ulNumInBnds == 0 )
        {
            Bnds.SetToSurfaceBounds(InputSurface());
            pInBounds = &Bnds;
        }

        *pOutBounds = *pInBounds;

        //--- Inflate by the size of the filter if we are
        //    not just doing a copy.
        if( !m_bDoSrcCopyOnly )
        {
            pOutBounds->u.D[DXB_X].Max += m_OutputSpread.cx;
            pOutBounds->u.D[DXB_Y].Max += m_OutputSpread.cy;
        }
    }
    return hr;
} /* CDXConvolution::MapBoundsIn2Out */


/*****************************************************************************
* CDXConvolution::MapBoundsOut2In *
*---------------------------------*
*   Description:
*       The MapBoundsOut2In method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 10/24/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXConvolution::MapBoundsOut2In( ULONG ulOutIndex, const DXBNDS *pOutBounds,
                                              ULONG ulInIndex, DXBNDS *pInBounds )
{
    DXTDBG_FUNC( "CDXConvolution::MapBoundsOut2In" );
    HRESULT hr = S_OK;
    
    if( DXIsBadReadPtr( pOutBounds, sizeof( *pOutBounds ) ) || ( ulOutIndex > 0 ) )
    {
        hr = E_INVALIDARG;
    }
    else if( DXIsBadWritePtr( pInBounds, sizeof( *pInBounds ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pInBounds = *pOutBounds;

        // How this works:  To calculate each pixel, each is centered in a
        // group of pixels that is the same size as m_FilterSize.  Knowing this,
        // we can add half of the m_FilterSize (rounding up) to our output 
        // bounds and be sure we include at least all the pixels we need and
        // maybe a couple more.  Then we offset the bounds into input space and
        // insersect those bounds with the full input bounds to make sure we 
        // don't return invalid bounds.

        // Temporary surface used to compute output. 
        // "0" = m_OutputSpread pixels.
        // "I" = Input surface pixels.
        // "-" = Output bounds for which input bounds were requested.
        //
        // 00000000000000000000000000
        // 0-----00000000000000000000
        // 0-----IIIIIIIIIIIIIIIIII00
        // 0-----IIIIIIIIIIIIIIIIII00
        // 0-----IIIIIIIIIIIIIIIIII00
        // 00IIIIIIIIIIIIIIIIIIIIII00
        // 00IIIIIIIIIIIIIIIIIIIIII00
        // 00000000000000000000000000
        // 00000000000000000000000000
        //
        // "-" = Expanded bounds after expanding by half of m_FilterSize.
        //       (2 in both directions)
        // 
        // --------000000000000000000
        // --------000000000000000000
        // --------IIIIIIIIIIIIIIII00
        // --------IIIIIIIIIIIIIIII00
        // --------IIIIIIIIIIIIIIII00
        // --------IIIIIIIIIIIIIIII00
        // --------IIIIIIIIIIIIIIII00
        // 00000000000000000000000000
        // 00000000000000000000000000
        //
        // "-" = Offset by negative half of m_OutputSpread to put into input
        //       surface coordinates.
        //
        // --------
        // --------
        // --------IIIIIIIIIIIIIIII
        // --------IIIIIIIIIIIIIIII
        // --------IIIIIIIIIIIIIIII
        // --------IIIIIIIIIIIIIIII
        // --------IIIIIIIIIIIIIIII
        //
        // "-" = Clip to input surface coordinates.
        //
        //   ------IIIIIIIIIIIIIIII
        //   ------IIIIIIIIIIIIIIII
        //   ------IIIIIIIIIIIIIIII
        //   ------IIIIIIIIIIIIIIII
        //   ------IIIIIIIIIIIIIIII

        if (!m_bDoSrcCopyOnly)
        {
            CDXDBnds    bndsInput;
            CDXDBnds *  pbndsOut2In = (CDXDBnds *)pInBounds;
            SIZE        sizeFilterExtends;

            sizeFilterExtends.cx = (m_FilterSize.cx + 1) / 2; 
            sizeFilterExtends.cy = (m_FilterSize.cy + 1) / 2;

            bndsInput.SetToSurfaceBounds(InputSurface());

            pbndsOut2In->u.D[DXB_X].Min -= sizeFilterExtends.cx;
            pbndsOut2In->u.D[DXB_X].Max += sizeFilterExtends.cx;
            pbndsOut2In->u.D[DXB_Y].Min -= sizeFilterExtends.cy;
            pbndsOut2In->u.D[DXB_Y].Max += sizeFilterExtends.cy;

            pbndsOut2In->Offset(- (m_OutputSpread.cx / 2), - (m_OutputSpread.cy / 2), 0, 0);

            pbndsOut2In->IntersectBounds(bndsInput);
        }
    }

    return hr;
} /* CDXConvolution::MapBoundsOut2In */


//
//=== IDXTConvolution ========================================================
//


/*****************************************************************************
* CDXConvolution::SetFilterType *
*-------------------------------*
*   Description:
*       The SetFilterType method is used to select a predefined filter.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 05/08/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXConvolution::SetFilterType( DXCONVFILTERTYPE eType )
{
    DXTDBG_FUNC( "CDXConvolution::SetFilterType" );
    HRESULT hr = S_OK;

    //--- Check args
    if( ( eType < 0 ) || ( eType >= DXCFILTER_NUM_FILTERS ) )
    {
        hr =  E_INVALIDARG;
    }
    else
    {
        //--- Force a margined surface refresh
        m_LastDoBnds.SetEmpty();

        m_FilterType = eType;
        m_FilterSize = g_StaticFilterSize;
        m_bDoSrcCopyOnly = false;

        //--- Select predefined filter type
        switch( eType )
        {
          case DXCFILTER_SRCCOPY:
            m_bDoSrcCopyOnly = true;
            m_pFilter = NULL;
            SetConvertToGray( false );
            break;
          case DXCFILTER_BOX7X7:
          {
            float* pFilt = (float*)alloca( 49 * sizeof( float ) );
            for( int i = 0; i < 49; ++i ) pFilt[i] = (float)(1./49.);
            static SIZE Size = { 7, 7 };
            hr = SetCustomFilter( pFilt, Size );
            SetExcludeAlpha( false );
            SetBias( 0. );
            m_FilterType = DXCFILTER_BOX7X7;
            SetConvertToGray( false );
            break;
          }
          case DXCFILTER_BLUR3X3:
            m_pFilter = g_Blur3x3Filter;
            SetExcludeAlpha( false );
            SetBias( 0. );
            SetConvertToGray( false );
            break;
          case DXCFILTER_SHARPEN:
            m_pFilter = g_SharpenFilter;
            SetExcludeAlpha( true );
            SetBias( 0. );
            SetConvertToGray( false );
            break;
          case DXCFILTER_EMBOSS:
            m_pFilter = g_EmbossFilter;
            SetBias( .7f );
            SetExcludeAlpha( true );
            SetConvertToGray( true );
            break;
          case DXCFILTER_ENGRAVE:
            m_pFilter = g_EngraveFilter;
            SetBias( .7f );
            SetExcludeAlpha( true );
            SetConvertToGray( true );
            break;
        }

        if( !m_bDoSrcCopyOnly )
        {
            hr = _BuildFilterLUTs();
        }
        SetDirty();
    }

    return hr;
} /* CDXConvolution::SetFilterType */


/*****************************************************************************
* CDXConvolution::GetFilterType *
*-------------------------------*
*   Description:
*       The GetFilterType method is used to perform any required one-time setup
*   before the Execute method is called.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXConvolution::GetFilterType( DXCONVFILTERTYPE* peType )
{
    DXTDBG_FUNC( "CDXConvolution::GetFilterType" );
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( peType, sizeof( *peType ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *peType = m_FilterType;
    }

    return hr;
} /* CDXConvolution::GetFilterType */


/*****************************************************************************
* CDXConvolution::SetCustomFilter *
*---------------------------------*
*   Description:
*       The SetCustomFilter method is used to define the convolution kernel.
*   A size of one causes a source copy since a normalized 1x1 pass would have
*   the same effect.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXConvolution::SetCustomFilter( float *pFilter, SIZE Size )
{
    HRESULT hr = S_OK;
    int NumCoeff = Size.cx * Size.cy;

    if( DXIsBadReadPtr( pFilter, NumCoeff * sizeof(float) ) ||
        ( Size.cx < 1 ) || ( Size.cy < 1 ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Force a margined surface refresh to adjust for new filter size
        m_LastDoBnds.SetEmpty();

        if( ( Size.cx == 1 ) && ( Size.cy == 1 ) )
        {
            m_bDoSrcCopyOnly = true;
        }
        else
        {
            //--- Make sure the filter doesn't sum to a negative value
            m_bDoSrcCopyOnly = false;
            float FilterSum = 0.;
            for( int i = 0; i < NumCoeff; ++i ) FilterSum += pFilter[i];
            if( FilterSum <= 0. )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                //--- Set type to user defined
                m_FilterType = DXCFILTER_CUSTOM;

                //--- Save size
                m_FilterSize = Size;

                //--- Copy the filter
                delete[] m_pCustomFilter;
                m_pCustomFilter = new float[NumCoeff];
                if( !m_pCustomFilter )
                {
                    hr = E_OUTOFMEMORY;
                    m_pFilter = NULL;
                }
                else
                {
                    memcpy( m_pCustomFilter, pFilter, NumCoeff * sizeof(float) );
                    m_pFilter = m_pCustomFilter;
                }

                if( SUCCEEDED( hr ) )
                {
                    hr = _BuildFilterLUTs();
                }
            }
        }
        SetDirty();
    }
    return hr;
} /* CDXConvolution::SetCustomFilter */


/*****************************************************************************
* CDXConvolution::_BuildFilterLUTs *
*----------------------------------*
*   Description:
*       The _BuildFilterLUTs method is used to build the filter coefficient
*   lookup tables used to process the image.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 05/08/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXConvolution::_BuildFilterLUTs( void )
{
    DXTDBG_FUNC( "CDXConvolution::_BuildFilterLUTs" );
    HRESULT hr = S_OK;
    int NumCoeff = m_FilterSize.cx * m_FilterSize.cy;
    int i, j;

    //--- Determine output spread
    m_OutputSpread.cx = 2 * ( m_FilterSize.cx / 2 );
    m_OutputSpread.cy = 2 * ( m_FilterSize.cy / 2 );

    //--- Do a quick check to determine if this is a box filter
    if( m_bExcludeAlpha )
    {
        //--- If we are excluding the alpha channel then we can't
        //    do the box filter special case code because it
        //    requires non-premultiplied alpha to work correctly.
        m_bIsBoxFilter = false;
    }
    else
    {
        m_bIsBoxFilter = true;
        float FirstCoeff = m_pFilter[0];
        for( i = 0; i < NumCoeff; ++i )
        {
            if( m_pFilter[i] != FirstCoeff )
            {
                m_bIsBoxFilter = false;
                break;
            }
        }
        if( m_bIsBoxFilter ) NumCoeff = 1;
    }

    //--- Allocate array that is the same size as the filter and
    //    populate with the corresponding lookup table indexes to use.
    delete[] m_pFilterLUTIndexes;
    m_pFilterLUTIndexes = new ULONG[NumCoeff];

    if( !m_pFilterLUTIndexes )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        //--- Determine how many unique coefficients there are
        //    and build the filter lookup table index
        float* TableCoefficient = (float*)alloca( NumCoeff * sizeof( float ) );
        m_pFilterLUTIndexes[0] = 0;
        int UniqueCnt = 0;
        for( i = 0; i < NumCoeff; ++i )
        {
            for( j = 0; j < i; ++j )
            {
                if( m_pFilter[i] == m_pFilter[j] )
                {
                    //--- Duplicate found
                    m_pFilterLUTIndexes[i] = m_pFilterLUTIndexes[j];
                    break;
                }
            }

            if( j == i )
            {
                //--- New coefficient
                TableCoefficient[UniqueCnt] = m_pFilter[i];
                m_pFilterLUTIndexes[i] = UniqueCnt++;
            }
        }

        //--- Clamp if the filter sum exceeds 1 or has a negative coefficient
        float FilterSum = 0.;
        m_bDoSampleClamp = false;
        for( i = 0; i < NumCoeff; ++i )
        {
            FilterSum += m_pFilter[i];
            if( m_pFilter[i] < 0. )
            {
                m_bDoSampleClamp = true;
                break;
            }
        }
        if( ( FilterSum > 1.00001f ) || ( m_Bias != 0. ) || m_bExcludeAlpha )
        {
            m_bDoSampleClamp = true;
        }

        //--- Create lookup tables
        delete[] m_pPMCoeffLUT;
        m_pPMCoeffLUT = new long[UniqueCnt*256];

        if( !m_pPMCoeffLUT )
        {
            hr = E_OUTOFMEMORY;
        }

        //--- Init table values with 16 bit signed fixed point values
        if( SUCCEEDED( hr ) )
        {
            long* pVal = m_pPMCoeffLUT;
            for( i = 0; i < UniqueCnt; ++i )
            {
                float Coeff = TableCoefficient[i] * ( 1L << 16 );

                for( ULONG j = 0; j < 256; ++j, ++pVal )
                {
                    *pVal = (long)(j * Coeff);
                }
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        _DetermineUnpackCase();
    }

    return hr;
} /* CDXConvolution::_BuildFilterLUTs */


//
//=== Work Procedures ========================================================
//  FROM THIS POINT ON, OPTIMIZE FOR SPEED.  PUT ALL CODE THAT IS NON-SPEED
//  SENSITIVE ABOVE THIS LINE 
#if DBG != 1
#pragma optimize("agt", on)
#endif


/*****************************************************************************
* WorkProc *
*----------*
*   Description:
*       This function performs the convolution with the current filter.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                 Date: 05/08/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXConvolution::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    DXTDBG_FUNC( "CDXConvolution::WorkProc" );
    HRESULT hr = S_OK;

    //=== Special case where the filter was too small
    if( m_bDoSrcCopyOnly )
    {
        hr = DXBitBlt( OutputSurface(), WI.OutputBnds, InputSurface(), WI.DoBnds,
                       m_dwBltFlags, 10000 );
        return hr;
    }
    else if( m_bIsBoxFilter )
    {
        hr = _DoBoxFilter( WI, pbContinue );
        return hr; 
    }

    ULONG DoBndsWid = WI.DoBnds.Width();
    ULONG DoBndsHgt = WI.DoBnds.Height();

    //=== General convolution case. The filter will be at least 2x2
    //--- Get input sample access pointer. Since we are doing arbitrary
    //    mapping, we'll put a read lock on the whole input to simplify logic.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> cpIn;
    hr = m_cpMarginedSurf->LockSurface( NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                        IID_IDXARGBReadPtr, (void**)&cpIn, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> cpOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                        IID_IDXARGBReadWritePtr, (void**)&cpOut, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Get pointer to input samples
    cpIn->GetNativeType( &m_MarginedSurfInfo );

    //--- Allocate output unpacking buffer if necessary.
    //    We only need a scratch buffer if we're doing an over
    //    operation to a non-PMARGB32 surface
    BOOL bDirectCopy = FALSE;
    DXPMSAMPLE *pOutScratchBuff = NULL;
    DXNATIVETYPEINFO OutInfo;

    //--- We check the option flags directly because we are
    //    working from a different source
    if( m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT )
    {
        if( m_bNeedOutUnpackBuff )
        {
            pOutScratchBuff = DXPMSAMPLE_Alloca(DoBndsWid);
        }
    }
    else
    {
        if (!m_bNeedOutUnpackBuff && !m_bDoSampleClamp)
        {
            cpOut->GetNativeType(&OutInfo);
            bDirectCopy = (OutInfo.pFirstByte != NULL);
        }
    }

    //--- If we're doing a direct copy then compose directly into the output surface,
    //    otherwise allocate a new buffer.
    DXBASESAMPLE *pComposeBuff = (bDirectCopy)?((DXBASESAMPLE *)OutInfo.pFirstByte):
                                 (DXBASESAMPLE_Alloca( DoBndsWid ));

    //--- Set up the dither structure if needed.
    DXDITHERDESC dxdd;
    if( DoDither() ) 
    {
        //  We will never get here when doing a direct copy since we don't dither
        //  for 32-bit samples, so pCompose buff always points to a buffer.
        dxdd.pSamples = pComposeBuff;
        dxdd.cSamples = DoBndsWid;
        dxdd.x = WI.OutputBnds.Left();
        dxdd.y = WI.OutputBnds.Top();
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    //--- Create fixed point bias value
    long lBias = (long)(m_Bias * 255. * ( 1L << 16 ));

    //--- Process each output row
    //    Note: Output coordinates are relative to the lock region
    DXBASESAMPLE* pInSamp = (DXBASESAMPLE*)(m_MarginedSurfInfo.pFirstByte
                                            + ((WI.DoBnds.Top() /*-  m_DoBndsBaseRow*/)
                                               * m_MarginedSurfInfo.lPitch)
                                            + (WI.DoBnds.Left() * sizeof(DXBASESAMPLE)));
    /*
    DXBASESAMPLE* pInSamp = (DXBASESAMPLE*)(m_MarginedSurfInfo.pFirstByte +
                                            ( ( WI.DoBnds.Top() - m_DoBndsBaseRow ) *
                                                m_MarginedSurfInfo.lPitch));
    */

    ULONG i, j, k, FiltWid = m_FilterSize.cx, FiltHgt = m_FilterSize.cy;

    //--- Number of DWORD to add to the input sample pointer to get to
    //    the alpha value at the center of the kernel
    ULONG ulAlphaOffset = ((FiltHgt / 2) * ( m_MarginedSurfInfo.lPitch /
                             sizeof( DXBASESAMPLE ))) + ( FiltWid / 2 );

    for( ULONG OutY = 0; *pbContinue && ( OutY < DoBndsHgt ); ++OutY )
    {
        if( m_bDoSampleClamp )
        {
            //--- Sample each point along the row with clamping
            if( m_bExcludeAlpha )
            {
                for( i = 0; i < DoBndsWid; ++i )
                {
                    DXBASESAMPLE* pCellStart = pInSamp + i;
                    long R = 0, G = 0, B = 0, lFilterLUTIndex = 0;

                    for( j = 0; j < FiltHgt; ++j )
                    {
                        for( k = 0; k < FiltWid; ++k, ++lFilterLUTIndex )
                        {
                            if( pCellStart[k].Alpha )
                            {
                                long* Table = m_pPMCoeffLUT +
                                                (m_pFilterLUTIndexes[lFilterLUTIndex] << 8);
                                R += Table[pCellStart[k].Red];
                                G += Table[pCellStart[k].Green];
                                B += Table[pCellStart[k].Blue];
                            }
                        }
                        pCellStart = (DXBASESAMPLE*)(((BYTE*)pCellStart) + m_MarginedSurfInfo.lPitch);
                    }

                    //--- Drop fractional component, clamp, and store
                    pComposeBuff[i].Alpha = pInSamp[ulAlphaOffset + i].Alpha;
                    pComposeBuff[i].Red   = ShiftAndClampChannelVal( R + lBias );
                    pComposeBuff[i].Green = ShiftAndClampChannelVal( G + lBias );
                    pComposeBuff[i].Blue  = ShiftAndClampChannelVal( B + lBias );
                }
            }
            else
            {
                for( i = 0; i < DoBndsWid; ++i )
                {
                    DXBASESAMPLE* pCellStart = pInSamp + i;
                    long R = 0, G = 0, B = 0, A = 0, lFilterLUTIndex = 0;

                    for( j = 0; j < FiltHgt; ++j )
                    {
                        for( k = 0; k < FiltWid; ++k, ++lFilterLUTIndex )
                        {
                            int Alpha = pCellStart[k].Alpha;
                            if( Alpha )
                            {
                                long* Table = m_pPMCoeffLUT +
                                                (m_pFilterLUTIndexes[lFilterLUTIndex] << 8);
                                R += Table[pCellStart[k].Red];
                                G += Table[pCellStart[k].Green];
                                B += Table[pCellStart[k].Blue];
                                A += Table[Alpha];
                            }
                        }
                        pCellStart = (DXBASESAMPLE*)(((BYTE*)pCellStart) + m_MarginedSurfInfo.lPitch);
                    }

                    //--- Drop fractional component, clamp, and store
                    pComposeBuff[i].Alpha = ShiftAndClampChannelVal( A );
                    pComposeBuff[i].Red   = ShiftAndClampChannelVal( R + lBias );
                    pComposeBuff[i].Green = ShiftAndClampChannelVal( G + lBias );
                    pComposeBuff[i].Blue  = ShiftAndClampChannelVal( B + lBias );
                }
            }

            if( m_bOutUnpackPremult )
            {
                //--- Premult if we are doing an over or the output is premult
                DXPreMultArray( (DXSAMPLE*)pComposeBuff, DoBndsWid );
            }
        }
        else
        {
            //--- Sample each point along the row without clamping
            for( i = 0; i < DoBndsWid; ++i )
            {
                DXBASESAMPLE* pCellStart = pInSamp + i;
                long R = 0, G = 0, B = 0, A = 0, lFilterLUTIndex = 0;

                for( j = 0; j < FiltHgt; ++j )
                {
                    for( k = 0; k < FiltWid; ++k, ++lFilterLUTIndex )
                    {
                        int Alpha = pCellStart[k].Alpha;
                        if( Alpha )
                        {
                            long* Table = m_pPMCoeffLUT +
                                            (m_pFilterLUTIndexes[lFilterLUTIndex] << 8);
                            R += Table[pCellStart[k].Red];
                            G += Table[pCellStart[k].Green];
                            B += Table[pCellStart[k].Blue];
                            A += Table[Alpha];
                        }
                    }
                    pCellStart = (DXBASESAMPLE*)(((BYTE*)pCellStart) + m_MarginedSurfInfo.lPitch);
                }

                //--- Drop fractional component, recombine, and store
                pComposeBuff[i] = ((A & 0x00FF0000) << 8) | (R & 0x00FF0000) |
                                  ((G & 0x00FF0000) >> 8) | (B >> 16);
            }
        }

        //--- Point to next row of input samples
        pInSamp = (DXBASESAMPLE*)(((BYTE*)pInSamp) + m_MarginedSurfInfo.lPitch);

        //--- Output
        if( bDirectCopy )
        {
            //--- Just move pointer to the next row
            pComposeBuff = (DXBASESAMPLE *)(((BYTE *)pComposeBuff) + OutInfo.lPitch);
        }
        else
        {
            if( DoDither() )
            {
                DXDitherArray( &dxdd );
                dxdd.y++;
            }

            cpOut->MoveToRow( OutY );
            if( m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT )
            {
                cpOut->OverArrayAndMove( pOutScratchBuff, (DXPMSAMPLE *)pComposeBuff, DoBndsWid);
            } 
            else
            {
                if( m_bOutUnpackPremult )
                {
                    cpOut->PackPremultAndMove( (DXPMSAMPLE*)pComposeBuff, DoBndsWid );
                }
                else
                {
                    cpOut->PackAndMove( (DXSAMPLE*)pComposeBuff, DoBndsWid );
                }
            }
        }
    } // End main row loop

    return hr;
} /* CDXConvolution::WorkProc */


/*****************************************************************************
* CDXConvolution::_DoBoxFilter *
*------------------------------*
*   Description:
*       This function performs the convolution with a box filter of the current
*   size. This is an optimized case inteneded for animation.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                 Date: 06/11/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXConvolution::_DoBoxFilter( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    DXTDBG_FUNC( "CDXConvolution::_DoBoxFilter" );
    HRESULT hr = S_OK;
    ULONG DoBndsWid = WI.DoBnds.Width();
    ULONG DoBndsHgt = WI.DoBnds.Height();

    //=== General convolution case. The filter will be at least 2x2
    //--- Get input sample access pointer. Since we are doing arbitrary
    //    mapping, we'll put a read lock on the whole input to simplify logic.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> cpIn;
    hr = m_cpMarginedSurf->LockSurface( NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                        IID_IDXARGBReadPtr, (void**)&cpIn, NULL );

    if (FAILED(hr))
    {
        return hr;
    }

    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> cpOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                        IID_IDXARGBReadWritePtr, (void**)&cpOut, NULL );

    if (FAILED(hr))
    {
        return hr;
    }

    //--- Get pointer to input samples
    cpIn->GetNativeType( &m_MarginedSurfInfo );

    //--- Allocate output unpacking buffer if necessary.
    //    We only need a scratch buffer if we're doing an over
    //    operation to a non-PMARGB32 surface
    BOOL bDirectCopy = FALSE;
    DXPMSAMPLE *pOutScratchBuff = NULL;
    DXNATIVETYPEINFO OutInfo;

    //--- We check the option flags directly because we are
    //    working from a different source
    if( m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT )
    {
        if( m_bNeedOutUnpackBuff )
        {
            pOutScratchBuff = DXPMSAMPLE_Alloca(DoBndsWid);
        }
    }
    else
    {
        if( !m_bNeedOutUnpackBuff )
        {
            cpOut->GetNativeType(&OutInfo);
            bDirectCopy = (OutInfo.pFirstByte != NULL);
        }
    }

    //--- If we're doing a direct copy then compose directly into the output surface,
    //    otherwise allocate a new buffer.
    DXBASESAMPLE *pComposeBuff = (bDirectCopy)?((DXBASESAMPLE *)OutInfo.pFirstByte):
                                 (DXBASESAMPLE_Alloca( DoBndsWid ));

    //--- Set up the dither structure if needed.
    DXDITHERDESC dxdd;
    if( DoDither() ) 
    {
        //  We will never get here when doing a direct copy since we don't dither
        //  for 32-bit samples, so pCompose buff always points to a buffer.
        dxdd.pSamples       = pComposeBuff;
        dxdd.cSamples       = DoBndsWid;
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    //--- Process each output row
    //    Note: Output coordinates are relative to the lock region
    DXBASESAMPLE* pInSamp = (DXBASESAMPLE*)(m_MarginedSurfInfo.pFirstByte
                                            + ((WI.DoBnds.Top() /*-  m_DoBndsBaseRow*/)
                                               * m_MarginedSurfInfo.lPitch)
                                            + (WI.DoBnds.Left() * sizeof(DXBASESAMPLE)));

    ULONG   i       = 0;
    ULONG   j       = 0;
    ULONG   k       = 0;
    ULONG   FiltWid = m_FilterSize.cx;
    ULONG   FiltHgt = m_FilterSize.cy;
    long    InitR   = 0;
    long    InitG   = 0;
    long    InitB   = 0;
    long    InitA   = 0;

    // Compute the initial sum and assign.

    DXBASESAMPLE * pInitCellStart   = pInSamp;
    long RowSampPitch               = m_MarginedSurfInfo.lPitch 
                                      / sizeof(DXBASESAMPLE);

    for( j = 0; j < FiltHgt; ++j )
    {
        for( k = 0; k < FiltWid; ++k )
        {
            int Alpha = pInitCellStart[k].Alpha;
            if( Alpha )
            {
                InitR += m_pPMCoeffLUT[pInitCellStart[k].Red];
                InitG += m_pPMCoeffLUT[pInitCellStart[k].Green];
                InitB += m_pPMCoeffLUT[pInitCellStart[k].Blue];
                InitA += m_pPMCoeffLUT[Alpha];
            }
        }
        pInitCellStart += RowSampPitch;
    }

    //--- Compute the rest of the samples based on deltas
    ULONG BottomOffset = FiltHgt * RowSampPitch;

    for( ULONG OutY = 0; *pbContinue && ( OutY < DoBndsHgt ); ++OutY )
    {
        long    R = InitR;
        long    G = InitG;
        long    B = InitB;
        long    A = InitA;

        for (i = 0 ; i < DoBndsWid ; ++i)
        {
            //--- Drop fractional component, recombine, and store
            pComposeBuff[i] = ((A & 0x00FF0000) << 8) | (R & 0x00FF0000) |
                              ((G & 0x00FF0000) >> 8) | (B >> 16);

            //--- Move the kernel sum right by subtracting off
            //    the left edge and adding the right
            DXBASESAMPLE* pCellStart = pInSamp + i;
            for( j = 0; j < FiltHgt; ++j )
            {
                R -= m_pPMCoeffLUT[pCellStart->Red];
                G -= m_pPMCoeffLUT[pCellStart->Green];
                B -= m_pPMCoeffLUT[pCellStart->Blue];
                A -= m_pPMCoeffLUT[pCellStart->Alpha];
                R += m_pPMCoeffLUT[pCellStart[FiltWid].Red];
                G += m_pPMCoeffLUT[pCellStart[FiltWid].Green];
                B += m_pPMCoeffLUT[pCellStart[FiltWid].Blue];
                A += m_pPMCoeffLUT[pCellStart[FiltWid].Alpha];
                pCellStart += RowSampPitch;
            }
        }

        //--- Subtract off the current top row of the kernel from the running sum
        //    And add on the new bottom row to the running sum
        for (j = 0 ; j < FiltWid ; ++j)
        {
            InitR -= m_pPMCoeffLUT[pInSamp[j].Red];
            InitG -= m_pPMCoeffLUT[pInSamp[j].Green];
            InitB -= m_pPMCoeffLUT[pInSamp[j].Blue];
            InitA -= m_pPMCoeffLUT[pInSamp[j].Alpha];

            InitR += m_pPMCoeffLUT[pInSamp[BottomOffset+j].Red];
            InitG += m_pPMCoeffLUT[pInSamp[BottomOffset+j].Green];
            InitB += m_pPMCoeffLUT[pInSamp[BottomOffset+j].Blue];
            InitA += m_pPMCoeffLUT[pInSamp[BottomOffset+j].Alpha];
        }

        //--- Point to next row of input samples
        pInSamp += RowSampPitch;

        //=== Output the result of the last row ====================================
        if( bDirectCopy )
        {
            //--- Just move pointer to the next row
            pComposeBuff = (DXBASESAMPLE *)(((BYTE *)pComposeBuff) + OutInfo.lPitch);
        }
        else
        {
            if( DoDither() )
            {
                DXDitherArray( &dxdd );
                dxdd.y++;
            }

            cpOut->MoveToRow(OutY);

            if (m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT)
            {
                cpOut->OverArrayAndMove(pOutScratchBuff, (DXPMSAMPLE *)pComposeBuff, DoBndsWid);
            } 
            else
            {
                if (m_bOutUnpackPremult)
                {
                    cpOut->PackPremultAndMove((DXPMSAMPLE *)pComposeBuff, DoBndsWid);
                }
                else
                {
                    cpOut->PackAndMove((DXSAMPLE *)pComposeBuff, DoBndsWid);
                }
            }
        }
    } // End main row loop

    return hr;
} /* CDXConvolution::_DoBoxFilter */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\composit.h ===
/*******************************************************************************
* Composit.h *
*------------*
*   Description:
*       This is the header file for the CDXTComposite implementation.
*-------------------------------------------------------------------------------
*  Created By: Ed Connell                            Date: 07/27/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef Composit_h
#define Composit_h

//--- Additional includes
#ifndef DTBase_h
#include <DTBase.h>
#endif

#include "resource.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================
class CDXTComposite;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CDXTComposite
*	This transform performs a copy blend operation. The
*	caller specifies the blend function to be performed. The default is
*   a standard A over B operation.
*/
class ATL_NO_VTABLE CDXTComposite : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTComposite, &CLSID_DXTComposite>,
    public IDispatchImpl<IDXTComposite, &IID_IDXTComposite, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTComposite>,
    public IObjectSafetyImpl2<CDXTComposite>,
    public IPersistStorageImpl<CDXTComposite>,
    public ISpecifyPropertyPagesImpl<CDXTComposite>,
    public IPersistPropertyBagImpl<CDXTComposite>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_POLY_AGGREGATABLE(CDXTComposite)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_DXTCOMPOSITE)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTComposite)
        COM_INTERFACE_ENTRY(IDXTComposite)
        COM_INTERFACE_ENTRY(IDispatch)
    	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p )
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTComposite>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN( CDXBaseNTo1 )
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTComposite)
        PROP_ENTRY("Function", DISPID_DXCOMPOSITE_Function, CLSID_CompositePP)
        PROP_PAGE(CLSID_CompositePP)
    END_PROPERTY_MAP()

  /*=== Member Data ===*/
    CComPtr<IUnknown> m_cpUnkMarshaler;
    DXCOMPFUNC        m_eFunction;

  /*=== Methods =======*/
  public:
    //--- Constructor
    HRESULT FinalConstruct();

    //--- Base class overrides
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WorkInfo, BOOL * pbContinue );
    HRESULT OnSurfacePick( const CDXDBnds& OutPoint, ULONG& ulInputIndex, CDXDVec& InVec );

  public:
    //=== IDXTComposite ==================================================
    STDMETHOD( put_Function )( DXCOMPFUNC eFunc );
    STDMETHOD( get_Function )( DXCOMPFUNC *peFunc );
};

//=== Inline Function Definitions ==================================
inline STDMETHODIMP CDXTComposite::put_Function( DXCOMPFUNC eFunc )
{
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;
    if( eFunc < DXCOMPFUNC_CLEAR || eFunc >= DXCOMPFUNC_NUMFUNCS )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_eFunction = eFunc;
        SetDirty();
    }
    return hr;
} /* CDXTComposite::put_Function */

inline STDMETHODIMP CDXTComposite::get_Function( DXCOMPFUNC *peFunc )
{
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr( peFunc, sizeof( *peFunc ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *peFunc = m_eFunction;
    }
    return hr;
} /* CDXTComposite::get_Function */

//=== Macro Definitions ============================================


//=== Global Data Declarations =====================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\dropshadow.cpp ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:        dropshadow.cpp
//
// Created:         10/01/98
//
// Author:          MikeAr
//
// Discription:     This file implements the Drop Shadow transform.
//
// 10/01/98 MikeAr      Created.
// 11/09/98 mcalkins    Moved to dxtmsft.dll
// 12/15/99 mcalkins    Rewrote.  Now alpha values are used when determining
//                      shadow alpha.  Original input alpha taken into
//                      consideration when original input drawn over shadow.
//                      Positive properties works as described in the docs.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "dxtmsft.h"
#include "dxclrhlp.h"
#include "dropshadow.h"
#include "filterhelpers.h"




//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::CDropShadow
//
//------------------------------------------------------------------------------
CDropShadow::CDropShadow() :
    m_nOffX(5),
    m_nOffY(5),
    m_bstrColor(NULL),
    m_dwColor(0xFF404040),
    m_fPositive(true),
    m_fColorTableDirty(true)
{
    // Make sure bounds structures have some area in the Z and Time dimensions
    // so as not to fail intersections.

    m_bndsAreaInput.u.D[DXB_Z].Max      = 1;
    m_bndsAreaInput.u.D[DXB_T].Max      = 1;
    m_bndsAreaShadow.u.D[DXB_Z].Max     = 1;
    m_bndsAreaShadow.u.D[DXB_T].Max     = 1;
    m_bndsAreaInitialize.u.D[DXB_Z].Max = 1;
    m_bndsAreaInitialize.u.D[DXB_T].Max = 1;

    // Base class members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;

    // Due to the the row caching method and other complexities of this 
    // transform, multithreaded rendering would be more complex than it's worth.
    // This keeps the number of threads down to 1.

    m_ulMaxImageBands   = 1;
}
//  Method: CDropShadow::CDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::~CDropShadow
//
//------------------------------------------------------------------------------
CDropShadow::~CDropShadow()
{
    SysFreeString(m_bstrColor);
}
//  Method: CDropShadow::~CDropShadow


//+-----------------------------------------------------------------------------
//
//  CDropShadow::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDropShadow::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_spUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_bstrColor = SysAllocString(L"#FF404040");

    if (NULL == m_bstrColor)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CDropShadow::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::put_Color, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::put_Color(VARIANT newVal)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr          = S_OK;
    DWORD   dwColor     = 0x00000000;
    BSTR    bstrTemp    = NULL;

    hr = FilterHelper_GetColorFromVARIANT(newVal, &dwColor, &bstrTemp);

    if (FAILED(hr))
    {
        goto done;
    }

    if (!(dwColor & 0xFF000000))
    {
        dwColor |= 0xFF000000;
    }

    if (m_dwColor != dwColor)
    {
        _ASSERT(bstrTemp);

        SysFreeString(m_bstrColor);

        m_dwColor   = dwColor;
        m_bstrColor = bstrTemp;

        SetDirty();

        m_fColorTableDirty = true;
    }

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  CDropShadow::put_Color, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::get_Color, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::get_Color(VARIANT * pVal)
{
    HRESULT hr = S_OK;

    if (NULL == pVal)
    {
        hr = E_POINTER;

        goto done;
    }

    _ASSERT(m_bstrColor);

    VariantClear(pVal);

    pVal->vt       = VT_BSTR;
    pVal->bstrVal  = SysAllocString(m_bstrColor);

    if (NULL == pVal->bstrVal)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CDropShadow::get_Color, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::get_OffX, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::get_OffX(int * pVal)
{
    DXAUTO_OBJ_LOCK;

    if(DXIsBadWritePtr(pVal, sizeof(*pVal))) 
        return E_POINTER;

    *pVal = m_nOffX;

    return S_OK;
}
//  CDropShadow::get_OffX, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::put_OffX, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::put_OffX(int newVal)
{
    DXAUTO_OBJ_LOCK;

    if (newVal != m_nOffX)
    {
        m_nOffX = newVal;

        SetDirty();
    }

    return S_OK;
}
//  CDropShadow::put_OffX, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::get_OffY, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::get_OffY(int * pVal)
{
    DXAUTO_OBJ_LOCK;

    if(DXIsBadWritePtr(pVal, sizeof(*pVal))) 
        return E_POINTER;

    *pVal = m_nOffY;

    return S_OK;
}
//  CDropShadow::get_OffY, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::put_OffY, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::put_OffY(int newVal)
{
    DXAUTO_OBJ_LOCK;

    if (newVal != m_nOffY)
    {
        m_nOffY = newVal;

        SetDirty();
    }

    return S_OK;
}
//  CDropShadow::put_OffY, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::get_Positive, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::get_Positive(VARIANT_BOOL * pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal))) 
        return E_POINTER;

    if (m_fPositive)
    {
        *pVal = VARIANT_TRUE;
    }
    else
    {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}
//  CDropShadow::get_Positive, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::put_Positive, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::put_Positive(VARIANT_BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    if ((newVal != VARIANT_TRUE) && (newVal != VARIANT_FALSE))
    {
        return E_INVALIDARG;
    }

    // If the newVal is true and the current val is false or vice-
    // versa, then update ourselves.
    if ((newVal == VARIANT_FALSE && m_fPositive)
            || (newVal == VARIANT_TRUE && !m_fPositive))
    {
        if (newVal == VARIANT_TRUE)
        {
            m_fPositive = true;
        }
        else
        {
            m_fPositive = false;
        }

        SetDirty();

        m_fColorTableDirty = true;
    }

    return S_OK;
}
//  CDropShadow::put_Positive, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDropShadow::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                   ULONG & ulInToTest, ULONG aInIndex[], 
                                   BYTE aWeight[])
{
    ulInToTest  = 1;
    aInIndex[0] = 0;
    aWeight[0]  = 255;
}
//  CDropShadow::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::DetermineBnds, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDropShadow::DetermineBnds(CDXDBnds & bnds)
{
    bnds.u.D[DXB_X].Max += max(m_nOffX, - m_nOffX);
    bnds.u.D[DXB_Y].Max += max(m_nOffY, - m_nOffY);

    return S_OK;
}
//  Method: CDropShadow::DetermineBnds, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDropShadow::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                             ULONG ulInIndex, DXBNDS * pInBounds)
{
    CDXDBnds    bnds;

    if ((NULL == pOutBounds) || (NULL == pInBounds))
    {
        return E_POINTER;
    }

    if (ulOutIndex || ulInIndex)
    {
        return E_INVALIDARG;
    }

    if (NULL == InputSurface())
    {
        return E_UNEXPECTED;
    }

    // What we do here is expand the bounds in the opposite direction of the 
    // drop shadow by the offset amount in both directions and then intersect
    // those bounds with the original input bounds.  This will give us the
    // input bounds needed to calculate the output area.

    *pInBounds = *pOutBounds;

    if (m_nOffX > 0)
    {
        pInBounds->u.D[DXB_X].Min -= m_nOffX;  // Sub |m_nOffX| from Min
    }
    else
    {
        pInBounds->u.D[DXB_X].Min += m_nOffX;  // Sub |m_nOffX| from Min
    }

    if (m_nOffY > 0)
    {
        pInBounds->u.D[DXB_Y].Min -= m_nOffY;  // Sub |m_nOffY| from Min
    }
    else
    {
        pInBounds->u.D[DXB_Y].Min += m_nOffY;  // Sub |m_nOffY| from Min
    }

    bnds = *pInBounds;

    bnds.IntersectBounds(m_bndsInput);

    *pInBounds = bnds;

    return S_OK;
}
//  Method: CDropShadow::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDropShadow::OnSetup(DWORD dwFlags)
{
    return InputSurface()->GetBounds(&m_bndsInput);
}
//  Method: CDropShadow::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDropShadow::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    if (IsTransformDirty())
    {
        _CalcAreaBounds();
    }

    if (m_fColorTableDirty)
    {
        _CalcColorTable();
    }

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDropShadow::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing)
{
    HRESULT hr = S_OK;

    CDXDVec     vecDoOutOffset;
    CDXDBnds    bndsOut;
    CDXDBnds    bndsIn;

    vecDoOutOffset.u.D[DXB_X] = WI.OutputBnds.Left() - WI.DoBnds.Left();
    vecDoOutOffset.u.D[DXB_Y] = WI.OutputBnds.Top() - WI.DoBnds.Top();

    bndsOut = WI.DoBnds;

    bndsOut.IntersectBounds(m_bndsAreaShadow);

    if (!bndsOut.BoundsAreEmpty())
    {
        int nDoWidth        = WI.DoBnds.Width();
        int nShadowOffset   = 0;
        int nShadowWidth    = 0;
        int y               = 0;

        DXSAMPLE *      asamplesOutputBuffer    = DXSAMPLE_Alloca(nDoWidth);
        DXBASESAMPLE *  abasesamplesScratch     = DXBASESAMPLE_Alloca(nDoWidth);

        CComPtr<IDXARGBReadPtr>         spSrcPtr;
        CComPtr<IDXARGBReadWritePtr>    spDstPtr;

        // Initialize output buffer.

        ZeroMemory((void *)asamplesOutputBuffer, nDoWidth * sizeof(DXSAMPLE));

        bndsIn = bndsOut;

        bndsIn.Offset(min(0, - m_nOffX), min(0, - m_nOffY), 0, 0);

        nShadowOffset   = bndsOut.Left() - WI.DoBnds.Left();
        nShadowWidth    = bndsOut.Width();

        bndsOut.u.D[DXB_X].Min = WI.DoBnds.Left();
        bndsOut.u.D[DXB_X].Max = WI.DoBnds.Right();

        bndsOut.Offset(vecDoOutOffset);

        hr = InputSurface()->LockSurface(&bndsIn, m_ulLockTimeOut,
                                         DXLOCKF_READ, __uuidof(IDXARGBReadPtr),
                                         (void **)&spSrcPtr, NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = OutputSurface()->LockSurface(&bndsOut, m_ulLockTimeOut, 
                                          DXLOCKF_READWRITE, 
                                          __uuidof(IDXARGBReadWritePtr),
                                          (void **)&spDstPtr, NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        for (y = 0 ; y < (int)bndsOut.Height() ; y++)
        {
            spSrcPtr->MoveToRow(y);

            spSrcPtr->Unpack(&asamplesOutputBuffer[nShadowOffset], nShadowWidth, 
                             FALSE);

            for (int x = nShadowOffset ; x < nShadowWidth + nShadowOffset ; x++)
            {
                asamplesOutputBuffer[x] 
                               = m_adwColorTable[asamplesOutputBuffer[x].Alpha];
            }

            spDstPtr->MoveToRow(y);

            if (DoOver())
            {
                DXPMSAMPLE * ppmsamples = DXPreMultArray(asamplesOutputBuffer,
                                                         nDoWidth);

                spDstPtr->OverArrayAndMove(abasesamplesScratch, ppmsamples, 
                                           nDoWidth);
            }
            else
            {
                spDstPtr->PackAndMove(asamplesOutputBuffer, nDoWidth);
            }
        }
    }

    // If we're not blending with output, initialize the non-shadow area to
    // clear.

    if (!DoOver())
    {
        bndsOut = WI.DoBnds;

        bndsOut.IntersectBounds(m_bndsAreaInitialize);

        if (!bndsOut.BoundsAreEmpty())
        {
            CComPtr<IDXARGBReadWritePtr> spDstPtr;

            bndsOut.Offset(vecDoOutOffset);

            hr = OutputSurface()->LockSurface(&bndsOut, m_ulLockTimeOut, 
                                              DXLOCKF_READWRITE, 
                                              __uuidof(IDXARGBReadWritePtr),
                                              (void **)&spDstPtr, NULL);

            if (FAILED(hr))
            {
                goto done;
            }

            spDstPtr->FillRect(NULL, 0x00000000, FALSE);
        }
    }

    // Blit original over top.

    bndsOut = WI.DoBnds;

    bndsOut.IntersectBounds(m_bndsAreaInput);

    if (!bndsOut.BoundsAreEmpty())
    {
        // We always blit this over the top of the output.  If the user is not
        // trying to blend with the output, any output area will already be
        // initialize either by the drop shadow or to clear by this time.

        DWORD dwFlags = DXBOF_DO_OVER;

        if (DoDither())
        {
            dwFlags |= DXBOF_DITHER;
        }

        bndsIn = bndsOut;

        bndsIn.Offset(min(0, m_nOffX), min(0, m_nOffY), 0, 0);

        bndsOut.Offset(vecDoOutOffset);

        hr = DXBitBlt(OutputSurface(), bndsOut,
                      InputSurface(), bndsIn,
                      dwFlags, INFINITE);
    }

done:

    return hr;
}
//  Method: CDropShadow::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::GetClipOrigin, IDXTClipOrigin
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDropShadow::GetClipOrigin(DXVEC * pvecClipOrigin)
{
    HRESULT hr = S_OK;

    if (NULL == pvecClipOrigin)
    {
        hr = E_POINTER;

        goto done;
    }

    if (m_nOffX < 0)
    {
        pvecClipOrigin->u.D[DXB_X] = - m_nOffX;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_X] = 0;
    }

    if (m_nOffY < 0)
    {
        pvecClipOrigin->u.D[DXB_Y] = - m_nOffY;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_Y] = 0;
    }

done:

    return hr;
}
//  Method: CDropShadow::GetClipOrigin, IDXTClipOrigin


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::_CalcAreaBounds
//
//------------------------------------------------------------------------------
void
CDropShadow::_CalcAreaBounds()
{
    // If m_nOffx and m_nOffY are both set to zero, this transform should just
    // do a bit blit of the source to the destination.

    if ((0 == m_nOffX) && (0 == m_nOffY))
    {
        m_bndsAreaInput = m_bndsInput;

        m_bndsAreaShadow.SetEmpty();
        m_bndsAreaInitialize.SetEmpty();

        return;
    }

    // Input area bounds.

    m_bndsAreaInput = m_bndsInput;

    if (m_nOffX < 0)
    {
        m_bndsAreaInput.Offset(- m_nOffX, 0, 0, 0);
    }

    if (m_nOffY < 0)
    {
        m_bndsAreaInput.Offset(0, - m_nOffY, 0, 0);
    }

    // Shadow area bounds.

    m_bndsAreaShadow = m_bndsAreaInput;

    m_bndsAreaShadow.Offset(m_nOffX, m_nOffY, 0, 0);

    // Area to initialize to clear if we're not blending with the output.

    m_bndsAreaInitialize.u.D[DXB_X].Min = 0;
    m_bndsAreaInitialize.u.D[DXB_X].Max = m_bndsInput.Width() 
                                          + max(m_nOffX, - m_nOffX);

    if (m_nOffY > 0)
    {
        m_bndsAreaInitialize.u.D[DXB_Y].Min = m_bndsAreaInput.Top();
        m_bndsAreaInitialize.u.D[DXB_Y].Max = m_bndsAreaShadow.Top();
    }
    else
    {
        m_bndsAreaInitialize.u.D[DXB_Y].Min = m_bndsAreaShadow.Bottom();
        m_bndsAreaInitialize.u.D[DXB_Y].Max = m_bndsAreaInput.Bottom();
    }
}
//  Method: CDropShadow::_CalcAreaBounds


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::_CalcColorTable
//
//------------------------------------------------------------------------------
void
CDropShadow::_CalcColorTable()
{
    if (0xFF000000 == (m_dwColor & 0xFF000000))
    {
        for (DWORD i = 0 ; i < 256 ; i++)
        {
            if (m_fPositive)
            {
                m_adwColorTable[i] = (i << 24) | (m_dwColor & 0x00FFFFFF);
            }
            else
            {
                m_adwColorTable[i] = ((255 - i) << 24) 
                                     | (m_dwColor & 0x00FFFFFF);
            }
        }
    }
    else
    {
        float flAlpha           = 0.0F;
        float flAlphaOriginal   = (float)((m_dwColor & 0xFF000000) >> 24) + 0.99F;

        for (DWORD i = 0 ; i < 256 ; i++)
        {
            if (i)
            {
                flAlpha = flAlphaOriginal * ((float)i / 255.0F);
            }

            if (m_fPositive)
            {
                m_adwColorTable[i] = ((DWORD)flAlpha << 24) 
                                     | (m_dwColor & 0x00FFFFFF); 
            }
            else
            {
                m_adwColorTable[i] = ((DWORD)(flAlphaOriginal - flAlpha) << 24)
                                     | (m_dwColor & 0x00FFFFFF);
            }
        }
    }

    m_fColorTableDirty = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\dropshadow.h ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:        dropshadow.h
//
// Created:         10/01/98
//
// Author:          MikeAr
//
// Discription:     Definition of the Drop Shadow transform.
//
// 1998/10/01   MikeAr      Created.
// 1998/11/09   mcalkins    Moved to dxtmsft.dll
// 2000/01/31   mcalkins    Support IDXTClipOrigin interface to support good 
//                          clipping for old names.
//
//------------------------------------------------------------------------------

#ifndef __DROPSHADOW_H_
#define __DROPSHADOW_H_

#include "resource.h"       // main symbols




class ATL_NO_VTABLE CDropShadow : 
    public CDXBaseNTo1,
    public CComCoClass<CDropShadow, &CLSID_DXTDropShadow>,
    public IDispatchImpl<IDXTDropShadow, &IID_IDXTDropShadow, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDropShadow>,
    public IObjectSafetyImpl2<CDropShadow>,
    public IPersistStorageImpl<CDropShadow>,
    public ISpecifyPropertyPagesImpl<CDropShadow>,
    public IPersistPropertyBagImpl<CDropShadow>,
    public IDXTClipOrigin
{
private:

    CComPtr<IUnknown>   m_spUnkMarshaler;

    CDXDBnds            m_bndsInput;

    CDXDBnds            m_bndsAreaShadow;
    CDXDBnds            m_bndsAreaInput;
    CDXDBnds            m_bndsAreaInitialize;

    int                 m_nOffX;
    int                 m_nOffY;
    BSTR                m_bstrColor;
    DWORD               m_dwColor;
    DWORD               m_adwColorTable[256];

    unsigned            m_fPositive         : 1;
    unsigned            m_fColorTableDirty  : 1;

    // Helpers.

    void _CalcAreaBounds();
    void _CalcColorTable();

public:

    CDropShadow();
    virtual ~CDropShadow();

    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_DROPSHADOW)
    DECLARE_POLY_AGGREGATABLE(CDropShadow)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDropShadow)
        COM_INTERFACE_ENTRY(IDXTDropShadow)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTClipOrigin)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDropShadow>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDropShadow)
        PROP_ENTRY("Color"   , 1, CLSID_DXTDropShadowPP)
        PROP_ENTRY("OffX"    , 2, CLSID_DXTDropShadowPP)
        PROP_ENTRY("OffY"    , 3, CLSID_DXTDropShadowPP)
        PROP_ENTRY("Positive", 4, CLSID_DXTDropShadowPP)
        PROP_PAGE(CLSID_DXTDropShadowPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT DetermineBnds(CDXDBnds & bnds);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    void    OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTClipOrigin methods.

    STDMETHOD(GetClipOrigin)(DXVEC * pvecClipOrigin);

    // IDXTDropShadow properties.

    STDMETHOD(get_Color)(VARIANT * pVal);
    STDMETHOD(put_Color)(VARIANT newVal);
    STDMETHOD(get_OffX)(int * pval);
    STDMETHOD(put_OffX)(int newVal);
    STDMETHOD(get_OffY)(int * pval);
    STDMETHOD(put_OffY)(int newVal);
    STDMETHOD(get_Positive)(VARIANT_BOOL * pval);
    STDMETHOD(put_Positive)(VARIANT_BOOL newVal);
};


#endif //__DROPSHADOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\dxtwipe.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) 1998-1999 Microsoft Corporation
//
//  File:       dxtwipe.cpp
//
//  Overview:   This module contains the CDXTWipe transform.
//
//  01/06/98    edc         Created.
//  01/01/99    a-matcal    Added bounds reduction optimization.
//  05/13/99    paulnash    Added MMX optimization.
//  05/14/99    a-matcal    Restructured code.  Use bnds loop in WorkProc.
//  09/29/99    a-matcal    _DrawGradientRect was setting up its dithering 
//                          structure with a NULL pointer to the samples.
//  10/24/99    a-matcal    Changed CDXTWipe class to CDXTWipeBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include "dxtmsft.h"   
#include "dxtwipe.h"
#include <string.h>

#define DO_GRADIENT 0xFFFFFFFFL

void _DoGradientMMXHorz(DXPMSAMPLE *pTarget, DXPMSAMPLE *pSource,
                        ULONG *paulWeights, ULONG cWeights);

/////////////////////////////////////////////////////////////////////////////
// Global Variables...

extern CDXMMXInfo   g_MMXDetector;       // Determines the presence of MMX instructions.


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase static variables initialization
//
//------------------------------------------------------------------------------

const WCHAR * CDXTWipeBase::s_astrMotion[] = {
    L"forward",
    L"reverse"
};


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::CDXTWipeBase
//
//------------------------------------------------------------------------------
CDXTWipeBase::CDXTWipeBase() :
    m_eMotion(MOTION_FORWARD),
    m_flGradPercentSize(0.25F),
    m_lGradientSize(0),
    m_pulGradientWeights(NULL),
    m_eWipeStyle(DXWD_HORIZONTAL),
    m_lCurGradMax(0),
    m_lPrevGradMax(0),
    m_cbndsDirty(0),
    m_fOptimize(false),
    m_fOptimizationPossible(false)
{
    m_sizeInput.cx    = 0;
    m_sizeInput.cy    = 0;

    // CDXBaseNTo1 members

    // Uncomment this when debugging to allow only one thread to execute the
    // work proc at a time.

    // m_ulMaxImageBands = 1;

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 0.5F;
}
// CDXTWipeBase::CDXTWipeBase


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::~CDXTWipeBase
//
//------------------------------------------------------------------------------
CDXTWipeBase::~CDXTWipeBase()
{
    if (m_pulGradientWeights != NULL)
    {
        delete [] m_pulGradientWeights; 
    }
}
// CDXTWipeBase::~CDXTWipeBase


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTWipeBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTWipeBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_UpdateStepResAndGradWeights
//
//  Overview:   This is a helper method used to generate the transition 
//              gradient wieghts.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTWipeBase::_UpdateStepResAndGradWeights(float flNewGradPercent)
{
    HRESULT hr              = S_OK;
    long    i               = 0;
    float   flWeight        = 0.0F;
    float   flInc           = 0.0F;
    long    lNewGradSize    = 0;
    float   flNewStepRes    = 0.0F;

    ULONG * pulNewGradWeights = NULL;

    if (m_eWipeStyle == DXWD_HORIZONTAL)
    {
        lNewGradSize    = (long)(m_sizeInput.cx * flNewGradPercent);
        flNewStepRes    = (float)(m_sizeInput.cx + lNewGradSize);
    }
    else // (m_eWipeStyle == DXWD_VERTICAL)
    {
        lNewGradSize    = (long)(m_sizeInput.cy * flNewGradPercent);
        flNewStepRes    = (float)(m_sizeInput.cy + lNewGradSize);
    }

    // If gradient weights are the same size, no need to recalculate.

    if (lNewGradSize == m_lGradientSize)
    {
        goto done;
    }

    // If the gradient size isn't zero, allocate memory to hold the
    // gradient weights.

    if (lNewGradSize > 0)
    {
        pulNewGradWeights = new ULONG[lNewGradSize];

        if (NULL == pulNewGradWeights)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        flWeight    = 1.0F;
        flInc       = 1.0F / (float)lNewGradSize;

        for (i = 0; i < lNewGradSize; i++)
        {
            pulNewGradWeights[i] = (ULONG)(flWeight * 255.0F);

            flWeight -= flInc;
        }

        // Everything's OK, delete old gradient weights and transfer new pointer.

        if (m_pulGradientWeights)
        {
            delete [] m_pulGradientWeights;
        }

        m_pulGradientWeights = pulNewGradWeights;
    }

    m_lGradientSize     = lNewGradSize;
    m_StepResolution    = flNewStepRes;

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
// CDXTWipeBase::_UpdateGradWeights


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_CalcFullBoundsHorizontal
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::_CalcFullBoundsHorizontal()
{
    RECT    rc;
    long    lGradMin = m_lCurGradMax - m_lGradientSize;

    // Note:    Some of the bounds may go outside of the input bounds, but that's
    //          OK because they will be clipped appropriately in WorkProc().

    // Solid left area.

    if (lGradMin > 0)
    {
        rc.left     = 0;
        rc.top      = 0;
        rc.right    = lGradMin;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }

        m_cbndsDirty++;
    }

    // Gradient area.

    if (m_lCurGradMax > 0 && lGradMin < m_sizeInput.cx)
    {
        rc.left     = lGradMin;
        rc.top      = 0;
        rc.right    = m_lCurGradMax;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = DO_GRADIENT;
        m_cbndsDirty++;
    }

    // Sold right area.

    if (m_lCurGradMax < m_sizeInput.cx)
    {
        rc.left     = m_lCurGradMax;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }

        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTWipeBase::_CalcFullBoundsHorizontal


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_CalcFullBoundsVertical
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::_CalcFullBoundsVertical()
{
    RECT    rc;
    long    lGradMin = m_lCurGradMax - m_lGradientSize;

    // Note:    Some of the bounds may go outside of the input bounds, but that's
    //          OK because they will be clipped appropriately in WorkProc().

    // Solid top area.

    if (lGradMin > 0)
    {
        rc.left     = 0;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = lGradMin;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }

        m_cbndsDirty++;
    }

    // Gradient area.

    if (m_lCurGradMax > 0 && lGradMin < m_sizeInput.cy)
    {
        rc.left     = 0;
        rc.top      = lGradMin;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_lCurGradMax;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = DO_GRADIENT;
        m_cbndsDirty++;
    }

    // Solid bottom area.

    if (m_lCurGradMax < m_sizeInput.cy)
    {
        rc.left     = 0;
        rc.top      = m_lCurGradMax;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }

        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTWipeBase::_CalcFullBoundsVertical


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_CalcOptBoundsHorizontal
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::_CalcOptBoundsHorizontal()
{
    RECT    rc;
    long    lGradMin    = m_lCurGradMax - m_lGradientSize;
    long    lGradDiff   = m_lCurGradMax - m_lPrevGradMax;

    // Positive lGradDiff indicates forward movement.

    // Note:    Some of the bounds may go outside of the input bounds, but that's
    //          OK because they will be clipped appropriately in WorkProc().

    // Solid left area.

    if ((lGradDiff > 0) && (lGradMin > 0))
    {
        rc.left     = lGradMin - lGradDiff;
        rc.top      = 0;
        rc.right    = lGradMin;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }

        m_cbndsDirty++;
    }

    // Gradient area.

    if (m_lCurGradMax > 0 && lGradMin < m_sizeInput.cx)
    {
        rc.left     = lGradMin;
        rc.top      = 0;
        rc.right    = m_lCurGradMax;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = DO_GRADIENT;
        m_cbndsDirty++;
    }

    // Solid right area.

    if ((lGradDiff < 0) && (m_lCurGradMax < m_sizeInput.cx))
    {
        rc.left     = m_lCurGradMax;
        rc.top      = 0;
        rc.right    = m_lCurGradMax - lGradDiff;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }

        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTWipeBase::_CalcOptBoundsHorizontal


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_CalcOptBoundsVertical
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::_CalcOptBoundsVertical()
{
    RECT    rc;
    long    lGradMin    = m_lCurGradMax - m_lGradientSize;
    long    lGradDiff   = m_lCurGradMax - m_lPrevGradMax;

    // Positive lGradDiff indicates forward movement.

    // Note:    Some of the bounds may go outside of the input bounds, but that's
    //          OK because they will be clipped appropriately in WorkProc().

    // Solid top area.

    if ((lGradDiff > 0) && (lGradMin > 0))
    {
        rc.left     = 0;
        rc.top      = lGradMin - lGradDiff;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = lGradMin;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }

        m_cbndsDirty++;
    }

    // Gradient area.

    if (m_lCurGradMax > 0 && lGradMin < m_sizeInput.cx)
    {
        rc.left     = 0;
        rc.top      = lGradMin;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_lCurGradMax;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = DO_GRADIENT;
        m_cbndsDirty++;
    }

    // Solid bottom area.

    if ((lGradDiff < 0) && (m_lCurGradMax < m_sizeInput.cx))
    {
        rc.left     = 0;
        rc.top      = m_lCurGradMax;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_lCurGradMax - lGradDiff;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }

        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTWipeBase::_CalcOptBoundsVertical


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::OnSetup, CDXBaseNTo1
//
//  Description:    This method is used to get the size of the inputs and 
//                  validate that they are the same.
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::OnSetup(DWORD dwFlags)
{
    DXTDBG_FUNC( "CDXTWipeBase::OnSetup" );

    HRESULT hr = S_OK;

    CDXDBnds InBounds(InputSurface(0), hr);

    if (FAILED(hr))
    {
        goto done;
    }

    // Compute the effect step resolution and weights.

    InBounds.GetXYSize(m_sizeInput);

    hr = _UpdateStepResAndGradWeights(m_flGradPercentSize);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
// CDXTWipeBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//  Description:    This method is used to determine which input has been 
//                  picked.
//
//------------------------------------------------------------------------------
void CDXTWipeBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                         ULONG & ulInToTest, ULONG aInIndex[], 
                                         BYTE aWeight[])
{
    long    lPointCoord = 0;
    long    lGradMin    = m_lCurGradMax - m_lGradientSize;

    ulInToTest  = 1;
    aWeight[0]  = 255;

    // Which coordinate to use?  If we're in "reverse" mode it's easier just to
    // invert lPointCoord than to invert everything else.

    if (DXWD_HORIZONTAL == m_eWipeStyle)
    {
        lPointCoord = OutPoint.Left();

        if (MOTION_REVERSE == m_eMotion)
        {
            lPointCoord = m_sizeInput.cx - lPointCoord;
        }
    }
    else
    {
        lPointCoord = OutPoint.Top();

        if (MOTION_REVERSE == m_eMotion)
        {
            lPointCoord = m_sizeInput.cy - lPointCoord;
        }
    }

    if (lPointCoord < lGradMin)
    {
        aInIndex[0] = 1;  // Input B
    }
    else if (lPointCoord < m_lCurGradMax)
    {
        ulInToTest = 2;

        BYTE byteWeight = (BYTE)m_pulGradientWeights[lPointCoord - lGradMin];

        if (byteWeight > 127)
        {
            aInIndex[0] = 1;
            aWeight[0]  = byteWeight;

            aInIndex[1] = 0;
            aWeight[1]  = DXInvertAlpha(byteWeight);
        }
        else
        {
            aInIndex[0] = 0;
            aWeight[0]  = DXInvertAlpha(byteWeight);

            aInIndex[1] = 1;
            aWeight[1]  = byteWeight;
        }
    }
    else
    {
        aInIndex[0] = 0;  // Input A
    }
}
//  CDXTWipeBase::OnGetSurfacePickOrder, CDXBaseNTo1




//  ALL CODE FROM THIS POINT ON IS TIME-CRITICAL SO OPTIMIZE FOR SPEED OVER 
//  SIZE!

#if DBG != 1
#pragma optimize("agtp", on)
#endif




//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::OnInitInstData, CDXBaseNTo1
//
//  Overview:   Calculate dirty bounds for WorkProc().
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    // Reset dirty bounds count.

    m_cbndsDirty = 0;

    // Calculate current gradient position.

    if (m_eWipeStyle == DXWD_HORIZONTAL)
    {
        m_lCurGradMax = (long)((float)(m_sizeInput.cx + m_lGradientSize) 
                                * m_Progress);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_lCurGradMax = (m_sizeInput.cx - m_lCurGradMax) + m_lGradientSize;
        }
    }
    else if (m_eWipeStyle == DXWD_VERTICAL)
    {
        m_lCurGradMax = (long)((float)(m_sizeInput.cy + m_lGradientSize) 
                                * m_Progress);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_lCurGradMax = (m_sizeInput.cy - m_lCurGradMax) + m_lGradientSize;
        }
    }
    else
    {
        _ASSERT(0);
    }
    
    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        if (DXWD_HORIZONTAL == m_eWipeStyle)
        {
            hr = _CalcFullBoundsHorizontal();
        }
        else
        {
            hr = _CalcFullBoundsVertical();
        }
    }
    else
    {
        // If the gradient position hasn't change, nothing is dirty.

        if (m_lCurGradMax == m_lPrevGradMax)
        {
            goto done;
        }

        // The only area that's dirty is the area including both the previous
        // gradient area and the current gradient area.

        if (DXWD_HORIZONTAL == m_eWipeStyle)
        {
            hr = _CalcOptBoundsHorizontal();
        }
        else
        {
            hr = _CalcOptBoundsVertical();
        }
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
// CDXTWipeBase::OnInitInstData


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::WorkProc, CDXBaseNTo1
//
//  Overview:   This function is used to calculate the result based on the 
//              specifiedbounds and the current effect progress. This is a 
//              simple subset of the full functionality to provide the simplest 
//              example possible (not necessarily the most efficient). THIS 
//              JUST WIPES RIGHT TO KEEP IT SIMPLE.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTWipeBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;
    ULONG   i       = 0;

    long    lInOutOffsetX = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }


    for (i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            if (DO_GRADIENT == m_alInputIndex[i])
            {
                hr = _DrawGradientRect(bndsDest, bndsSrc, m_abndsDirty[i],
                                       pbContinue);
            }
            else
            {
                _ASSERT(m_alInputIndex[i] < (long)m_ulMaxInputs);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(m_alInputIndex[i]), bndsSrc,
                              dwFlags, INFINITE);
            }

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTWipeBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_DrawGradientRect
//
//  Arguments:  bndsDest    Bounds relative to the output surface to update.
//              bndsSrc     Bounds retative to the source images to blend.
//              bndsGrad    The full gradient bounds relative to the source
//                          images.
//              pbContinue  Pointer to a boolean variable that will be set to
//                          FALSE to indicate that the function should abort.
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::_DrawGradientRect(const CDXDBnds bndsDest, const CDXDBnds bndsSrc,
                                const CDXDBnds bndsGrad, BOOL * pbContinue)
{
    HRESULT     hr              = S_OK;
    ULONG       ulDestWidth     = 0;
    ULONG       ulDestHeight    = 0;
    ULONG       ulOutY          = 0;
    bool        fDirectCopy     = (OutputSampleFormat() == DXPF_PMARGB32 
                                   && (!DoOver()));


    DXPMSAMPLE *    pRowBuff    = NULL;
    DXPMSAMPLE *    pGradBuff   = NULL;
    DXPMSAMPLE *    pOutBuff    = NULL;

    IDXSurface *    pDXSurfaceFrom  = NULL;
    IDXSurface *    pDXSurfaceTo    = NULL;

    DXDITHERDESC        dxdd;
    DXNATIVETYPEINFO    nti;

    CComPtr<IDXARGBReadPtr>         pInA;
    CComPtr<IDXARGBReadPtr>         pInB;
    CComPtr<IDXARGBReadWritePtr>    pOut;

    _ASSERT(m_pulGradientWeights);

    // Pre-calculate width and height.

    ulDestWidth     = bndsDest.Width();
    ulDestHeight    = bndsDest.Height();

    if (MOTION_REVERSE == m_eMotion)
    {
        pDXSurfaceFrom  = InputSurface(1);
        pDXSurfaceTo    = InputSurface(0);
    }
    else
    {
        pDXSurfaceFrom  = InputSurface(0);
        pDXSurfaceTo    = InputSurface(1);
    }

    // Get input sample access pointer for the requested region.

    // TODO:    Rename pInA, and pInB to the more appropos pInFrom and pInTo.

    hr = pDXSurfaceFrom->LockSurface(&bndsSrc, m_ulLockTimeOut,
                                     DXLOCKF_READ, IID_IDXARGBReadPtr, 
                                     (void **)&pInA, NULL);
    if (FAILED(hr)) 
    {
        goto done;
    }

    hr = pDXSurfaceTo->LockSurface(&bndsSrc, m_ulLockTimeOut,
                                   DXLOCKF_READ, IID_IDXARGBReadPtr, 
                                   (void **)&pInB, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Put a write lock only on the region we are updating so multiple
    // threads don't conflict.

    hr = OutputSurface()->LockSurface(&bndsDest, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, (void **)&pOut, 
                                      NULL);

    if (FAILED(hr)) 
    {
        goto done;
    }

    // If it's possible to directly modify the samples of the output surface,
    // get needed info about the surface and the pointer to the first sample.
    // If for some reason a pointer isn't available, we  can't do direct copy.

    if (fDirectCopy)
    {
        pOut->GetNativeType(&nti);

        if (nti.pFirstByte)
        {
            pRowBuff = (DXPMSAMPLE *)nti.pFirstByte;
        }
        else
        {
            fDirectCopy = false;
        }
    }

    // Allocate row and gradient buffers.

    pGradBuff = DXPMSAMPLE_Alloca(ulDestWidth);

    if (NULL == pRowBuff)
    {
        pRowBuff = DXPMSAMPLE_Alloca(ulDestWidth);
    }

    // Allocate an output buffer if needed.

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(ulDestWidth);
    }

    //
    //  Set up the dither structure
    //

    if (DoDither())
    {
        dxdd.x              = bndsDest.Left();
        dxdd.y              = bndsDest.Top();
        dxdd.pSamples       = pRowBuff;
        dxdd.cSamples       = ulDestWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    //
    // Gradient loop.
    //

    if (m_eWipeStyle == DXWD_HORIZONTAL)
    {
        ULONG ulGradWgtStart = bndsSrc.Left() - bndsGrad.Left();
    
        for (ulOutY = 0; *pbContinue && (ulOutY < ulDestHeight); ulOutY++)
        {
            // Get B samples

            pInB->MoveToRow(ulOutY);
            pInB->UnpackPremult(pRowBuff, ulDestWidth, FALSE);

            // Get A samples

            pInA->MoveToRow(ulOutY);
            pInA->UnpackPremult(pGradBuff, ulDestWidth, FALSE);

            _DoGradientMMXHorz(pRowBuff, pGradBuff, 
                               &m_pulGradientWeights[ulGradWgtStart], 
                               ulDestWidth);

            if (fDirectCopy)
            {
                // If we've been modifying the output pixels directly, just
                // reset the buffer pointer to the beginning of the next row.

                pRowBuff = (DXPMSAMPLE *)(((BYTE *)pRowBuff) + nti.lPitch);
            }
            else
            {
                // Get the output row.

                pOut->MoveToRow(ulOutY);

                // Dither if needed.

                if (DoDither())
                {
                    DXDitherArray(&dxdd);
                    dxdd.y++;
                }

                // Copy buffer to output surface.

                if (DoOver())
                {
                    pOut->OverArrayAndMove(pOutBuff, pRowBuff, ulDestWidth);
                }
                else
                {
                    pOut->PackPremultAndMove(pRowBuff, ulDestWidth);
                }
            } // if (!fDirectCopy)
        } // End for
    }
    else // (m_eWipeStyle == DXWD_VERTICAL)
    {
        ULONG ulGradWgtStart = bndsSrc.Top() - bndsGrad.Top();
        
        for(ulOutY = 0; *pbContinue && (ulOutY < ulDestHeight); ulOutY++)
        {
            // Get B samples.

            pInB->MoveToRow(ulOutY);
            pInB->UnpackPremult(pRowBuff, ulDestWidth, FALSE);

            // Get A samples.

            pInA->MoveToRow(ulOutY);
            pInA->UnpackPremult(pGradBuff, ulDestWidth, FALSE);

            ULONG ulWgt = m_pulGradientWeights[ulGradWgtStart + ulOutY];
                
            for (ULONG i = 0; i < ulDestWidth; i++)
            {
                pRowBuff[i] = DXScaleSample(pGradBuff[i], ulWgt ^ 0xFF) + 
                              DXScaleSample(pRowBuff[i], ulWgt); 
            }

            if (fDirectCopy)
            {
                // If we've been modifying the output pixels directly, just
                // reset the buffer pointer to the beginning of the next row.

                pRowBuff = (DXPMSAMPLE *)(((BYTE *)pRowBuff) + nti.lPitch);
            }
            else
            {
                // Get the output row

                pOut->MoveToRow(ulOutY);

                if (DoDither())
                {
                    DXDitherArray(&dxdd);
                    dxdd.y++;
                }

                if (DoOver())
                {
                    pOut->OverArrayAndMove(pOutBuff, pRowBuff, ulDestWidth);
                }
                else
                {
                    pOut->PackPremultAndMove(pRowBuff, ulDestWidth);
                }
            } // if (!fDirectCopy)
        } // End for
    }

done:
    
    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTWipeBase::_DrawGradientRect


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_lPrevGradMax = m_lCurGradMax;

    // Calling IsOutputDirty clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTWipeBase::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::get_WipeStyle, IDXTWipe
//
//  Description:    This method is used to get the current wipe style.
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTWipeBase::get_WipeStyle(DXWIPEDIRECTION *pVal)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if(DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pVal = m_eWipeStyle;

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTWipeBase::get_WipeStyle, IDXTWipe


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::put_WipeStyle, IDXTWipe
//
//  Description:    This method is used to specify whether the wipe is 
//                  horizontal or vertical.
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTWipeBase::put_WipeStyle(DXWIPEDIRECTION newVal)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (newVal != DXWD_HORIZONTAL && newVal != DXWD_VERTICAL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (newVal == m_eWipeStyle)
    {
        goto done;
    }

    hr = _UpdateStepResAndGradWeights(m_flGradPercentSize);

    if (FAILED(hr))
    {
        goto done;
    }

    m_eWipeStyle = newVal;

    SetDirty();

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTWipeBase::put_WipeStyle, IDXTWipe


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::get_GradientSize, IDXTWipe
//
//  Description:    This method is used to get the size of the transition area 
//                  between image A and image B.
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTWipeBase::get_GradientSize(float *pflPercentSize)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (DXIsBadWritePtr(pflPercentSize, sizeof(*pflPercentSize)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pflPercentSize = m_flGradPercentSize;

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTWipeBase::get_GradientSize, IDXTWipe


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::put_GradientSize, IDXTWipe
//
//  Description:    This method is used to set the size of the transition area 
//                  between image A and image B.
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTWipeBase::put_GradientSize(float flPercentSize)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (flPercentSize < 0.0F || flPercentSize > 1.0F)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (flPercentSize == m_flGradPercentSize)
    {
        goto done;
    }

    hr = _UpdateStepResAndGradWeights(flPercentSize);

    if (FAILED(hr))
    {
        goto done;
    }

    m_flGradPercentSize = flPercentSize;

    SetDirty();

done:
    
    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTWipeBase::put_GradientSize, IDXTWipe


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::get_Motion, IDXTWipe2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTWipeBase::get_Motion(BSTR * pbstrMotion)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrMotion)
    {
        return E_POINTER;
    }

    if (*pbstrMotion != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrMotion = SysAllocString(s_astrMotion[m_eMotion]);

    if (NULL == *pbstrMotion)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTWipeBase::get_Motion, IDXTWipe2


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::put_Motion, IDXTWipe2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTWipeBase::put_Motion(BSTR bstrMotion)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrMotion)
    {
        return E_POINTER;
    }

    for ( ; i < (int)MOTION_MAX ; i++)
    {
        if (!_wcsicmp(bstrMotion, s_astrMotion[i]))
        {
            break;
        }
    }

    if ((int)MOTION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eMotion != i)
    {
        m_eMotion = (MOTION)i;

        SetDirty();
    }

    return S_OK;
}
//  CDXTWipeBase::put_Motion, IDXTWipe2


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_DoGradientMMXHorz
//
//------------------------------------------------------------------------------
void _DoGradientMMXHorz(DXPMSAMPLE *pTarget, DXPMSAMPLE *pSource,
                        ULONG *paulWeights, ULONG cWeights)
{
#if defined(_X86_)

    // The global MMX detector tells us there's no MMX instructions by setting
    // MinMMXOverCount() equal to 0xFFFFFFFF.
    //
    // Pixels are processed in pairs, so if there are less than 2 pixels there's
    // no need to do MMX optimization.

    if (   (g_MMXDetector.MinMMXOverCount() == 0xFFFFFFFF)
        || (cWeights < 2))
    {
        goto NonMMXPath;
    }
    else
    {
        ULONG   nCount = cWeights;

        static __int64 MASK  = 0x000000FF000000FF;
        static __int64 MASK2 = 0x00FF00FF00FF00FF;
        static __int64 ROUND = 0x0080008000800080;
        //--- TODO do we want to be quad word aligned here?

        //--- Make sure we have an even count
        bool fDoTrailing = false;
        if( nCount & 1 )
        {
            fDoTrailing = true;
            --nCount;
        }

        __int64     TempPixel;

        //--- Crank through the middle
        __asm
        {
            xor ebx, ebx	            // offset for the three pointers
            mov edx, pTarget            // edx -> Destination
            mov esi, edx                // esi -> Background source
            mov edi, pSource            // edi -> Foreground source (destination)
            mov ecx, nCount             // ecx = loop count
            mov eax, paulWeights        // eax -> Alpha values (gradient weights)

            //  prolog: prime the pump
            //
            pxor      mm0,mm0           //      mm0 = 0000 0000 0000 0000
            movq      mm7,MASK          //      mm7 = 0000 00FF 0000 00FF

            movq      mm1,[eax+ebx]     // 1.01 mm1= 0000 00a2 0000 00a1
                                        // 2.01 Unpaired
            pxor      mm1,MASK          // 1.03 mm1= 0000 1-a2 0000 1-a1
                                        // 2.03 Unpaired
            movq      mm2,mm1           // 2.04 mm2= 0000 1-a2 0000 1-a1
            punpcklwd mm1,mm1           // 1.05 mm1= 0000 0000 1-a1 1-a1
            punpckhwd mm2,mm2           // 2.05 mm2= 0000 0000 1-a2 1-a2
            punpcklwd mm1,mm1           // 1.06 mm1= 1-a1 1-a1 1-a1 1-a1
            punpcklwd mm2,mm2           // 2.06 mm2= 1-a2 1-a2 1-a2 1-a2

            movq      mm3,[edi+ebx]     // 3.04 mm3= Aa Ar Ag Ab Ba Br Bg Bb
            movq      mm4,mm3           // 4.05 mm4= Aa Ar Ag Ab Ba Br Bg Bb
            punpcklbw mm3,mm0           // 3.06 mm3=  00Ba  00Br  00Bg  00Bb

            shr ecx, 1                  // divide loop counter by 2; pixels are processed in pairs
            dec ecx                     // do one less loop to correct for prolog/postlog
            jz skip                     // if original loop count=2

    loopb:
            punpckhbw mm4,mm0           // 4.06 mm4=  00Aa  00Ar  00Ag  00Ab 
            pmullw    mm3,mm1           // 3.07 mm3=  (1-Fa)*B

            pmullw    mm4,mm2           // 4.07 mm4=  (1-Ga)*A      // <PN 05/13/99> Stopped fixing r/b switch here

            // Flip the masks back so we can scale the source pixel
            pxor      mm1,MASK2         // **PRN mm1= 00a1 00a1 00a1 00a1   XFER FROM SECOND HALF BELOW
            pxor      mm2,MASK2         // **PRN mm2= 00a2 00a2 00a2 00a2   XFER FROM SECOND HALF BELOW

            paddw     mm3,ROUND         // 3.08 mm3=  prod+128=FBr
            add       ebx,8             //      increment offset
            paddw     mm4,ROUND         // 4.08 mm4=  prod+128=Gar

            movq      mm5,mm3           // 5.09 mm5=  FBr
            movq      mm6,mm4           // 6.09 mm6=  GAr

            psrlw     mm5,8             // 5.10 mm5=  FBr>>8 
            psrlw     mm6,8             // 6.10 mm6=  GAr>>8 

            paddw     mm5,mm3           // 5.11 mm5=  FBr+(FBr>>8)
            paddw     mm6,mm4           // 6.11 mm6=  GAr+(GAr>>8)

            psrlw     mm5,8             // 5.12 mm5= (FBr+(FBr>>8)>>8)= 00Sa 00Sr 00Sg 00Sb
            psrlw     mm6,8             // 6.12 mm6= (GAr+(GAr>>8)>>8)= 00Ta 00Tr 00Tg 00Tb

            movq      mm3,[esi+ebx-8]   // **PRN mm3= Ca Cr Cg Cb Da Dr Dg Db
            packuswb  mm5,mm6           // 5.13 mm5= Ta Tr Tg Tb Sa Sr Sg Sb 

            movq      mm4,mm3           // **PRN mm4= Ca Cr Cg Cb Da Dr Dg Db

            punpcklbw mm3,mm0           // **PRN mm3=  00Da  00Dr  00Dg  00Db
            punpckhbw mm4,mm0           // **PRN mm4=  00Ca  00Cr  00Cg  00Cb 

            pmullw    mm3,mm1           // **PRN mm3=  (a1)*B
            pmullw    mm4,mm2           // **PRN mm4=  (a2)*A

            movq      mm1,[eax+ebx]     // 1.01 mm1= 0000 00a1 0000 00a2
            movq      mm2,mm5           // **PRN move result from first scale into mm2

            paddw     mm3,ROUND         // **PRN mm3=  prod+128=FBr
            paddw     mm4,ROUND         // **PRN mm4=  prod+128=Gar

            pxor      mm1,mm7           //+1.03 mm1= 0000 1-a2 0000 1-a1

            movq      mm5,mm3           // **PRN mm5=  FBr
            movq      mm6,mm4           // **PRN mm6=  GAr

            psrlw     mm5,8             // **PRN mm5=  FBr>>8 
            psrlw     mm6,8             // **PRN mm6=  GAr>>8 

            paddw     mm5,mm3           // **PRN mm5=  FBr+(FBr>>8)
            paddw     mm6,mm4           // **PRN mm6=  GAr+(GAr>>8)

            psrlw     mm5,8             // **PRN mm5= (FBr+(FBr>>8)>>8)= 00Xa 00Xr 00Xg 00Xb
            psrlw     mm6,8             // **PRN mm6= (GAr+(GAr>>8)>>8)= 00Ya 00Yr 00Yg 00Yb

            packuswb  mm5,mm6           // **PRN mm5= Ta Tr Tg Tb Sa Sr Sg Sb
            paddusb   mm5,mm2           // **PRN add two scaled pixels

    // Setup next iteration
            movq      mm2,mm1           //+2.04 mm2= 0000 1-a2 0000 1-a1
            punpcklwd mm1,mm1           //+1.05 mm1= 0000 0000 1-a1 1-a1

            movq      [edx+ebx-8],mm5   // **PRN store result

            punpckhwd mm2,mm2           //+2.05 mm2= 0000 0000 1-a2 1-a2 
            punpcklwd mm1,mm1           //+1.06 mm1=  1-a1  1-a1  1-a1  1-a1 
            punpcklwd mm2,mm2           //+2.06 mm2=  1-a2  1-a2  1-a2  1-a2 

            movq      mm3,[edi+ebx]     //+3.04 mm3= Aa Ar Ag Ab Ba Br Bg Bb
            movq      mm4,mm3           //+4.05 mm4= Aa Ar Ag Ab Ba Br Bg Bb
            punpcklbw mm3,mm0           //+3.06 mm3=  00Ba  00Br  00Bg  00Bb 
        
            dec ecx                     // decrement loop counter
            jg loopb                    // loop

            // 
            // loop postlog, drain the pump
            //
    skip:
            punpckhbw mm4,mm0           // 4.06 mm4=  00Aa  00Ar  00Ag  00Ab
            pmullw    mm3,mm1           // 3.07 mm3=  (1-Fa)*B
            pmullw    mm4,mm2           // 4.07 mm4=  (1-Ga)*A
            paddw     mm3,ROUND         // 3.08 mm3=  prod+128=FBr
            paddw     mm4,ROUND         // 4.08 mm4=  prod+128=Gar
            movq      mm5,mm3           // 5.09 mm5=  FBr
            movq      mm6,mm4           // 6.09 mm6=  GAr
            psrlw     mm5,8             // 5.10 mm5=  FBr>>8
            psrlw     mm6,8             // 6.10 mm6=  GAr>>8
            paddw     mm5,mm3           // 5.11 mm5=  FBr+(FBr>>8)
            paddw     mm6,mm4           // 6.11 mm6=  GAr+(GAr>>8)
            psrlw     mm5,8             // 5.12 mm5= (FBr+(FBr>>8)>>8)= 00Sa 00Sr 00Sg 00Sb
            psrlw     mm6,8             // 6.12 mm6= (Gar+(GAr>>8)>>8)= 00Ta 00Tr 00Tg 00Tb
            packuswb  mm5,mm6           // 5.13 mm5= Sa Sr Sg Sb Ta Tr Tg Tb
            movq      TempPixel,mm5     // **PRN store to stack for a moment...

            pxor      mm1,MASK2         // **PRN mm1= 00a1 00a1 00a1 00a1
            pxor      mm2,MASK2         // **PRN mm2= 00a2 00a2 00a2 00a2
            movq      mm3,[esi+ebx]     // **PRN mm3= Ca Cr Cg Cb Da Dr Dg Db
            movq      mm4,mm3           // **PRN mm4= Ca Cr Cg Cb Da Dr Dg Db
            punpcklbw mm3,mm0           // **PRN mm3=  00Da  00Dr  00Dg  00Db
            punpckhbw mm4,mm0           // **PRN mm4=  00Ca  00Cr  00Cg  00Cb 

            pmullw    mm3,mm1           // **PRN mm3=  (a1)*B
            pmullw    mm4,mm2           // **PRN mm4=  (a2)*A
            paddw     mm3,ROUND         // **PRN mm3=  prod+128=FBr
            paddw     mm4,ROUND         // **PRN mm4=  prod+128=Gar
            movq      mm5,mm3           // **PRN mm5=  FBr
            movq      mm6,mm4           // **PRN mm6=  GAr
            psrlw     mm5,8             // **PRN mm5=  FBr>>8 
            psrlw     mm6,8             // **PRN mm6=  GAr>>8 
            paddw     mm5,mm3           // **PRN mm5=  FBr+(FBr>>8)
            paddw     mm6,mm4           // **PRN mm6=  GAr+(GAr>>8)
            psrlw     mm5,8             // **PRN mm5= (FBr+(FBr>>8)>>8)= 00Xa 00Xr 00Xg 00Xb
            psrlw     mm6,8             // **PRN mm6= (GAr+(GAr>>8)>>8)= 00Ya 00Yr 00Yg 00Yb
            packuswb  mm5,mm6           // **PRN mm5= Ta Tr Tg Tb Sa Sr Sg Sb

            movq      mm6,TempPixel     // **PRN restore from stack
            paddusb   mm5,mm6           // **PRN add two scaled pixels
            movq      [edx+ebx],mm5     // **PRN store result

            //
            // really done now
            //
            EMMS
        }

        //--- Do the last one non-MMX if the count was odd
        if( fDoTrailing )
        {
            ULONG Wgt = paulWeights[nCount];

            pTarget[nCount] = DXScaleSample(pSource[nCount], Wgt ^ 0xFF) +
                                DXScaleSample(pTarget[nCount], Wgt);
        }
    }

    return;

NonMMXPath:

#endif // defined(_X86_)

    for( ULONG i = 0; i < cWeights; ++i )
    {
        ULONG Wgt = paulWeights[i];
        pTarget[i] = DXScaleSample( pSource[i], Wgt ^ 0xFF ) + 
                     DXScaleSample( pTarget[i], Wgt ); 
    }

    return;
} // _DoGradientMMXHorz
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\fade.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-2000
//
// FileName:    fade.cpp
//
// Description: Implementation of CFade, the fade transform.
//
// Change History:
//
// 2000/01/28   mcalkins    Fixed bad fading with 0.0 < overlap < 1.0.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "DXTMsft.h"
#include "Fade.h"

#if defined(_X86_)

static void _DoDoubleBlendMMX(const DXPMSAMPLE * pSrcA, 
                              const DXPMSAMPLE * pSrcB, DXPMSAMPLE * pDest, 
                              ULONG nSamples, ULONG ulWeightA, ULONG ulWeightB);

#endif // defined(_X86_)

extern CDXMMXInfo   g_MMXDetector;       // Determines the presence of MMX instructions.




//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
CFade::CFade() :
    m_Overlap(1.0f)
{
    m_ulNumInRequired = 1;
    m_ulMaxInputs = 2;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
}


//+-----------------------------------------------------------------------------
//
//  Method: CFade::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CFade::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  Method: CFade::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
STDMETHODIMP CFade::get_Overlap(float * pVal)
{
    if (NULL == pVal)
    {
        return E_POINTER;
    }

    *pVal = m_Overlap;
    return S_OK;
}

//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
STDMETHODIMP CFade::put_Overlap(float newVal)
{
    if (newVal < 0.0f || newVal > 1.0f)
    {
        return E_INVALIDARG;
    }
    
    if (m_Overlap != newVal)
    {
        Lock();
        m_Overlap = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}

//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
STDMETHODIMP CFade::get_Center(BOOL * pVal)
{
    if (NULL == pVal)
    {
        return E_POINTER;
    }
    
    *pVal = (m_dwOptionFlags & DXBOF_CENTER_INPUTS) ? TRUE : FALSE;
    return S_OK;
}

//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
STDMETHODIMP CFade::put_Center(BOOL newVal)
{
    DWORD dwFlags = m_dwOptionFlags & (~DXBOF_CENTER_INPUTS);
    if (newVal) dwFlags |= DXBOF_CENTER_INPUTS;
    if (dwFlags != m_dwOptionFlags)
    {
        m_dwOptionFlags = dwFlags;
        IncrementGenerationId(TRUE);
    }
    return S_OK;
}

//
//  Optimize this file for SPEED
//
#if DBG != 1
#pragma optimize("agtp", on)
#endif

//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
void CFade::_ComputeScales(void)
{
    if (HaveInput(1))
    {
        if (m_Overlap > 0.9960784f) // 254.0F / 255.0f
        {
            BYTE CurAAlpha = (BYTE)((1.0f - m_Progress) * 255.5f);
           // if (m_ScaleA[CurAAlpha] != CurAAlpha)
            {
                for (int i = 0; i < 256; ++i )
                {
                    m_ScaleA[i] = (BYTE)((CurAAlpha * i) / 255);
                    m_ScaleB[i] = (BYTE)(i - m_ScaleA[i]);
                }
            }
        }
        else
        {
            float Scale = 1.0f / (0.5f + (m_Overlap / 2));
            float APercent = 1.0f - (m_Progress * Scale);
            float BPercent = 1.0f - ((1.0f - m_Progress) * Scale);
            if (APercent > 0.0f)
            {
                BYTE A = (BYTE)(APercent * 255.5f);
                for (int i = 0; i < 256; ++i )
                {
                    m_ScaleA[i] = (BYTE)(A * i / 255);
                }
            }
            else
            {
                m_ScaleA[255] = 0;
            }
            if (BPercent > 0.0f)
            {
                BYTE B = (BYTE)(BPercent * 255.5f);
                for (int i = 0; i < 256; ++i )
                {
                    m_ScaleB[i] = (BYTE)(B * i / 255);
                }
            }
            else
            {
                m_ScaleB[255] = 0;
            }
        }
    }
    else
    {
        BYTE AlphaProgress = (BYTE)((1.0f - m_Progress) * 255.5f);
        for (int i = 0; i < 256; ++i )
        {
            m_ScaleA[i] = (BYTE)((AlphaProgress * i) / 255);
        }
    }
}


//+-----------------------------------------------------------------------------
//
//  Method: CFade::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CFade::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    _ComputeScales();

    return S_OK;
}
//  Method: CFade::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CFade::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CFade::OnGetSurfacePickOrder(const CDXDBnds & /*BndsPoint*/, 
                             ULONG & ulInToTest, ULONG aInIndex[], 
                             BYTE aWeight[])
{
    _ComputeScales();

    ulInToTest  = 1;
    aWeight[0]  = 255;
    aInIndex[0] = 0;

    if (HaveInput(1))
    {
        if (m_ScaleA[255] < 255)    // If == 255 then initial settings correct
        {
            if (m_ScaleB[255] == 255)
            {
                aInIndex[0] = 1;
            }
            else
            {
                ulInToTest = 2;
                if (m_Progress < 0.5)
                {
                    aInIndex[0] = 0;
                    aWeight[0] = m_ScaleA[255];
                    aInIndex[1] = 1;
                    aWeight[1] = m_ScaleB[255];
                }
                else
                {
                    aInIndex[0] = 1;
                    aWeight[0] = m_ScaleB[255];
                    aInIndex[1] = 0;
                    aWeight[1] = m_ScaleA[255];
                }
            }
        }
    }
}
//  Method: CFade::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
HRESULT CFade::FadeOne(const CDXTWorkInfoNTo1 & WI, IDXSurface *pInSurf,
                       const BYTE *AlphaTable)
{
    HRESULT hr = S_OK;
    if (AlphaTable[255] == 255)
    {
        return DXBitBlt(OutputSurface(), WI.OutputBnds, 
                        pInSurf,
                        WI.DoBnds, m_dwBltFlags, m_ulLockTimeOut);
    }

    CComPtr<IDXARGBReadWritePtr> cpDest;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&cpDest, NULL );
    if( FAILED( hr ) ) return hr;

    if (AlphaTable[255] == 0)
    {
        if ((m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT) == 0)
        {
            DXPMSAMPLE nothing;
            nothing = 0;
            cpDest->FillRect(NULL, nothing, FALSE);
        }
        return hr;
    }

    //
    //  In this function we don't want to use the base class DoOver() because it will
    //  be false if both of the input surfaces are opaque.  Since we are creating translucent
    //  pixels, we want to look directly at the appropriate flag.
    //
    BOOL bDoOver = (m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT);
    CComPtr<IDXARGBReadPtr> cpSrc;
    hr = pInSurf->LockSurface( &WI.DoBnds, m_ulLockTimeOut,
                               bDoOver ? (DXLOCKF_READ | DXLOCKF_WANTRUNINFO) : DXLOCKF_READ,
                               IID_IDXARGBReadPtr, (void**)&cpSrc, NULL);
    if(SUCCEEDED(hr)) 
    {
        //
        //  We don't bother about optimizing the direct copy case since this
        //  transform will most likely be used with an over.  In any case, we
        //  would always need a source buffer since we're going to smash the samples
        //
        const ULONG Width = WI.DoBnds.Width();
        DXPMSAMPLE *pSrcBuff = DXPMSAMPLE_Alloca(Width);
        DXDITHERDESC dxdd;
        if (DoDither())
        {
            dxdd.x = WI.OutputBnds.Left();
            dxdd.y = WI.OutputBnds.Top();
            dxdd.pSamples = pSrcBuff;
            dxdd.cSamples = Width;
            dxdd.DestSurfaceFmt = OutputSampleFormat();
        }
        const ULONG Height = WI.DoBnds.Height();
        if (bDoOver)
        {
            DXPMSAMPLE *pDestScratchBuff = NULL;
            if( OutputSampleFormat() != DXPF_PMARGB32 )
            {
                pDestScratchBuff = DXPMSAMPLE_Alloca(Width);
            }
            for (ULONG y = 0; y < Height; y++)
            {
                cpDest->MoveToRow(y);
                const DXRUNINFO *pRunInfo;
                ULONG ul = cpSrc->MoveAndGetRunInfo(y, &pRunInfo);
                const DXRUNINFO *pLimit = pRunInfo + ul;
                do
                {
                    dxdd.x = WI.OutputBnds.Left();
                    while (pRunInfo < pLimit && pRunInfo->Type == DXRUNTYPE_CLEAR)
                    {
                        dxdd.x += pRunInfo->Count;
                        cpSrc->Move(pRunInfo->Count);
                        cpDest->Move(pRunInfo->Count);
                        pRunInfo++;
                    }
                    if (pRunInfo < pLimit)
                    {
                        ULONG cRunLen = pRunInfo->Count;
                        pRunInfo++;
                        while (pRunInfo < pLimit && pRunInfo->Type != DXRUNTYPE_CLEAR)
                        {
                            cRunLen += pRunInfo->Count;
                            pRunInfo++;
                        }
                        cpSrc->UnpackPremult(pSrcBuff, cRunLen, TRUE);
                        if (DoDither())
                        {
                            dxdd.cSamples = cRunLen;
                            DXDitherArray(&dxdd);
                            dxdd.x += cRunLen;
                        }
                        DXApplyLookupTableArray(pSrcBuff, cRunLen, AlphaTable);
                        DXPMSAMPLE *pOverDest = cpDest->UnpackPremult(pDestScratchBuff, cRunLen, FALSE);
                        DXOverArrayMMX(pOverDest, pSrcBuff, cRunLen);
                        cpDest->PackPremultAndMove(pDestScratchBuff, cRunLen);
                    }
                } while (pRunInfo < pLimit);
                dxdd.y++;
            }
        }
        else
        {
            for (ULONG y = 0; y < Height; y++)
            {
                cpSrc->MoveToRow(y);
                cpSrc->UnpackPremult(pSrcBuff, Width, FALSE);
                DXApplyLookupTableArray(pSrcBuff, Width, AlphaTable);
                if (DoDither())
                {
                    DXDitherArray(&dxdd);
                    dxdd.y++;
                }
                cpDest->MoveToRow(y);
                cpDest->PackPremultAndMove(pSrcBuff, Width);
            }
        }
    }
    return hr;
}


//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
HRESULT 
CFade::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing)
{
    HRESULT hr = S_OK;

    CComPtr<IDXARGBReadPtr>         pSrcA;
    CComPtr<IDXARGBReadPtr>         pSrcB;
    CComPtr<IDXARGBReadWritePtr>    cpDest;

    const ULONG     DoWidth     = WI.DoBnds.Width();
    const ULONG     DoHeight    = WI.DoBnds.Height();
    ULONG           y           = 0;

    BOOL    bDoOver     = (m_ScaleA[255] + m_ScaleB[255] == 255) 
                          ? DoOver() : (m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT);
    BOOL    bDirectCopy = (OutputSampleFormat() == DXPF_PMARGB32 && (!bDoOver));

    DXPMSAMPLE *    pBuffA          = NULL;
    DXPMSAMPLE *    pBuffB          = NULL;
    DXPMSAMPLE *    pDestBuff       = NULL;
    DXPMSAMPLE *    pOverScratch    = NULL;

    DXNATIVETYPEINFO    NTI;
    DXDITHERDESC        dxdd;

    if ((!HaveInput(1)) || m_ScaleB[255] == 0)
    {
        return FadeOne(WI, InputSurface(0), m_ScaleA);
    }
    if (m_ScaleA[255] == 0)
    {
        return FadeOne(WI, InputSurface(1), m_ScaleB);
    }

    pBuffA          = (InputSampleFormat(0) == DXPF_PMARGB32)
                      ? NULL : DXPMSAMPLE_Alloca(DoWidth);
    pBuffB          = (InputSampleFormat(1) == DXPF_PMARGB32)
                      ? NULL : DXPMSAMPLE_Alloca(DoWidth);
    pOverScratch    = (bDoOver && OutputSampleFormat() != DXPF_PMARGB32) 
                      ? DXPMSAMPLE_Alloca(DoWidth) : NULL;

    hr = InputSurface(0)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void **)&pSrcA, 
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = InputSurface(1)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void* *)&pSrcB, 
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, (void **)&cpDest,
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    //
    //  The base class DoOver() will be the appropriate value iff the scales
    //  add up to 255.  Otherwise, use the MiscFlags to determine if we want 
    //  to do an over operation.
    //

    if (bDirectCopy)
    {
        cpDest->GetNativeType(&NTI);
        if (NTI.pFirstByte)
        {
            pDestBuff = (DXPMSAMPLE *)NTI.pFirstByte;
        }
        else
        {
            bDirectCopy = FALSE;
        }
    }

    if (pDestBuff == NULL)
    {
        pDestBuff = DXPMSAMPLE_Alloca(DoWidth);
    }

    //
    //  Set up the dither structure. 
    //

    if (DoDither())
    {
        dxdd.x = WI.OutputBnds.Left();
        dxdd.y = WI.OutputBnds.Top();
        dxdd.pSamples = pDestBuff;
        dxdd.cSamples = DoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    for (y = 0; y < DoHeight; y++)
    {
        pSrcA->MoveToRow(y);
        const DXPMSAMPLE *pASamples = pSrcA->UnpackPremult(pBuffA, DoWidth, FALSE);
        pSrcB->MoveToRow(y);
        const DXPMSAMPLE *pBSamples = pSrcB->UnpackPremult(pBuffB, DoWidth, FALSE);

        ULONG cTranslucent = 0;
        ULONG cTransparent = 0;
        bool  fForceOver = false;

#if defined(_X86_)

        if (g_MMXDetector.MinMMXOverCount() != 0xFFFFFFFF)
        {
            ULONG   ulWeightA = 0;
            ULONG   ulWeightB = 0;

            // The code below does some kind of funky counting of translucent vs. transparent
            // pixels to try and optimize when they should use DXOverArrayMMX instead of OverArray().
            fForceOver = true;

            if (m_Overlap > 0.9960784f) // 254.0F / 255.0f
            {
                ulWeightA = (ULONG)(BYTE)((1.0f - m_Progress) * 255.5f);
                ulWeightB = 255 - ulWeightA;
            }
            else
            {
                float Scale = 1.0f / (0.5f + (m_Overlap / 2));

                ulWeightA = (ULONG)((1.0f - (m_Progress * Scale)) * 255.5f);
                ulWeightB = (ULONG)((1.0f - ((1.0f - m_Progress) * Scale)) 
                                    * 255.5f);
            }

            _DoDoubleBlendMMX(pASamples, pBSamples, pDestBuff, DoWidth, 
                              ulWeightA, ulWeightB);
        }
        else
        {

#endif // !defined(_X86_)

            for (ULONG i = 0; i < DoWidth; i++)
            {
                const DWORD av = pASamples[i];
                const DWORD bv = pBSamples[i];
                DWORD a = m_ScaleA[av >> 24] + m_ScaleB[bv >> 24];
                if (a)
                {
                    if (a < 0xFF) cTranslucent++;
                    DWORD r = m_ScaleA[(BYTE)(av >> 16)];
                    DWORD g = m_ScaleA[(BYTE)(av >> 8)];
                    DWORD b = m_ScaleA[(BYTE)av];

                    r += m_ScaleB[(BYTE)(bv >> 16)];
                    g += m_ScaleB[(BYTE)(bv >> 8)];
                    b += m_ScaleB[(BYTE)bv];
                
                    pDestBuff[i] = ((a << 24) | (r << 16) | (g << 8) | b);
                }
                else 
                {
                    pDestBuff[i] = 0;
                    cTransparent++;
                }

            }

#if defined(_X86_)
        }
#endif // !defined(_X86_)

        if (bDirectCopy)
        {
            pDestBuff = (DXPMSAMPLE *)(((BYTE *)pDestBuff) + NTI.lPitch);
        }
        else
        {
            if (DoDither())
            {
                DXDitherArray(&dxdd);
                dxdd.y++;
            }
            cpDest->MoveToRow(y);

            // TODO: Probably we should just totally cut out DXOverArrayMMX opt.
            //      The blending routine that does the fade is a much better win and this other
            //      one is seriously questionable.

            // We need fForceOver here to force the code into the "over" case instead of the
            // "copy" (packpremult) case if we did the MMX code path above because we didn't
            // count cTranslucent and cTransparent
            if (bDoOver && (fForceOver || (cTransparent + cTranslucent)))
            {
                // In the common case, there aren't many translucent pixels.  It's only worth
                // going through the MMX over (and taking the hit for the Unpack) if there are
                // a lot.  In the case of MMX blending code above (fForceOver == true), we will
                // simply assume that it's faster to NOT go through this MMX code (i.e. the image
                // doesn't have many translucent pixels).  The reason we must guess is because the
                // MMX code above is not setup to count translucent pixels.
                if (!fForceOver && (cTranslucent > DoWidth / 4))
                {
                    DXPMSAMPLE *pOverDest = cpDest->UnpackPremult(pOverScratch, DoWidth, FALSE);
                    DXOverArrayMMX(pOverDest, pDestBuff, DoWidth);
                    cpDest->PackPremultAndMove(pOverScratch, DoWidth);
                }
                else
                {
                    cpDest->OverArrayAndMove(pOverScratch, pDestBuff, DoWidth);
                }
            }
            else
            {
                cpDest->PackPremultAndMove(pDestBuff, DoWidth);
            }
        }
    }
    
done:

    return hr;
}

// MMX Code is X86 processor-specific (duh)
#if defined(_X86_)

//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
static void 
_DoDoubleBlendMMX(const DXPMSAMPLE *pSrcA, const DXPMSAMPLE *pSrcB,
                  DXPMSAMPLE *pDest, ULONG nSamples, ULONG ulWeightA,
                  ULONG ulWeightB)
{
    _ASSERT(NULL != pSrcA && NULL != pSrcB && NULL != pDest);
    _ASSERT(0 < nSamples);
    _ASSERT(0 < ulWeightA && 255 >= ulWeightA);

    ULONG   nCount = nSamples;
    bool    fDoTrailing = false;

    static __int64 ROUND = 0x0080008000800080;

    // TODO: do we want to be quad word aligned here?

    // Make sure we have an even count.

    if (nCount & 1)
    {
        fDoTrailing = true;
        --nCount;
    }

    // If we only have one column, don't do MMX at all.

    if (0 == nCount)
    {
        goto trailing;
    }

    // Crank through the middle.

    __asm
    {
        xor ebx, ebx	            // offset for the three pointers
        mov edx, pDest              // edx -> Destination
        mov esi, pSrcB              // esi -> Background source
        mov edi, pSrcA              // edi -> Foreground source (destination)
        mov ecx, nCount             // ecx = loop count

        //  prolog: prime the pump
        //

        // mm7 will hold the alpha weight (a1) for the pSrcA samples.

        movd      mm7,ulWeightA     //      mm7 = 0000 0000 0000 00a1
        pxor      mm0,mm0           //      mm0 = 0000 0000 0000 0000

        punpcklwd mm7,mm7           //      mm7 = 0000 0000 00a1 00a1
        punpcklwd mm7,mm7           //      mm7 = 00a1 00a1 00a1 00a1

        // mm1 will hold the alpha weight (a2) for the pSrcB samples.

        movd      mm1,ulWeightB     //      mm1 = 0000 0000 0000 00a2
        punpcklwd mm1,mm1           //      mm1 = 0000 0000 00a2 00a2
        punpcklwd mm1,mm1           //      mm1 = 00a2 00a2 00a2 00a2

        movq      mm3,[edi+ebx]     // 3.04 mm3= Aa Ar Ag Ab Ba Br Bg Bb
        shr       ecx,1             // divide loop counter by 2; pixels are processed in pairs
        movq      mm4,mm3           // 4.05 mm4= Aa Ar Ag Ab Ba Br Bg Bb
        punpcklbw mm3,mm0           // 3.06 mm3=  00Ba  00Br  00Bg  00Bb

        dec       ecx               // do one less loop to correct for prolog/postlog
        jz        skip              // if original loop count=2

loopb:
        punpckhbw mm4,mm0           // 4.06 mm4=  00Aa  00Ar  00Ag  00Ab 
        pmullw    mm3,mm7           // 3.07 mm3=  (1-a1)*B

        pmullw    mm4,mm7           // 4.07 mm4=  (1-a1)*A

        movq      mm2,[esi+ebx]     // **PRN mm2= Ca Cr Cg Cb Da Dr Dg Db
        add       ebx,8             //      increment offset

        movq      mm5,ROUND
        movq      mm6,mm5

        paddw     mm5,mm3           // 5.09 mm5=  FBr
        paddw     mm6,mm4           // 6.09 mm6=  GAr

        psrlw     mm5,8             // 5.10 mm5=  FBr>>8 
        psrlw     mm6,8             // 6.10 mm6=  GAr>>8 

        paddw     mm5,mm3           // 5.11 mm5=  FBr+(FBr>>8)
        paddw     mm6,mm4           // 6.11 mm6=  GAr+(GAr>>8)

        psrlw     mm5,8             // 5.12 mm5= (FBr+(FBr>>8)>>8)= 00Sa 00Sr 00Sg 00Sb
        psrlw     mm6,8             // 6.12 mm6= (GAr+(GAr>>8)>>8)= 00Ta 00Tr 00Tg 00Tb

        packuswb  mm5,mm6           // 5.13 mm5= Ta Tr Tg Tb Sa Sr Sg Sb 

        movq      mm4,mm2           // **PRN mm4= Ca Cr Cg Cb Da Dr Dg Db

        punpcklbw mm2,mm0           // **PRN mm2=  00Da  00Dr  00Dg  00Db
        punpckhbw mm4,mm0           // **PRN mm4=  00Ca  00Cr  00Cg  00Cb 

        pmullw    mm2,mm1           // **PRN mm2=  (a1)*D
        pmullw    mm4,mm1           // **PRN mm4=  (a1)*C

        movq      mm6,ROUND
        movq      mm3,mm5           // **PRN move result from first scale into mm3

        movq      mm5,mm6

        paddw     mm5,mm2           // 5.09 mm5=  FBr
        paddw     mm6,mm4           // 6.09 mm6=  GAr

        psrlw     mm5,8             // **PRN mm5=  FBr>>8 
        psrlw     mm6,8             // **PRN mm6=  GAr>>8 

        paddw     mm5,mm2           // **PRN mm5=  FBr+(FBr>>8)
        paddw     mm6,mm4           // **PRN mm6=  GAr+(GAr>>8)

        psrlw     mm5,8             // **PRN mm5= (FBr+(FBr>>8)>>8)= 00Xa 00Xr 00Xg 00Xb
        psrlw     mm6,8             // **PRN mm6= (GAr+(GAr>>8)>>8)= 00Ya 00Yr 00Yg 00Yb

        packuswb  mm5,mm6           // **PRN mm5= Ya Yr Yg Yb Xa Xr Xg Xb
        paddusb   mm5,mm3           // **PRN add two scaled pixels

        movq      mm3,[edi+ebx]     //+3.04 mm3= Aa Ar Ag Ab Ba Br Bg Bb
        dec       ecx               // decrement loop counter

        movq      [edx+ebx-8],mm5   // **PRN store result

        movq      mm4,mm3           //+4.05 mm4= Aa Ar Ag Ab Ba Br Bg Bb
        punpcklbw mm3,mm0           //+3.06 mm3=  00Ba  00Br  00Bg  00Bb 
    
        jg        loopb             // loop

        // 
        // loop postlog, drain the pump
        //
skip:
        punpckhbw mm4,mm0           // 4.06 mm4=  00Aa  00Ar  00Ag  00Ab
        pmullw    mm3,mm7           // 3.07 mm3=  (1-Fa)*B
        pmullw    mm4,mm7           // 4.07 mm4=  (1-Ga)*A
        paddw     mm3,ROUND         // 3.08 mm3=  prod+128=FBr
        paddw     mm4,ROUND         // 4.08 mm4=  prod+128=Gar
        movq      mm5,mm3           // 5.09 mm5=  FBr
        movq      mm6,mm4           // 6.09 mm6=  GAr
        psrlw     mm5,8             // 5.10 mm5=  FBr>>8
        psrlw     mm6,8             // 6.10 mm6=  GAr>>8
        paddw     mm5,mm3           // 5.11 mm5=  FBr+(FBr>>8)
        paddw     mm6,mm4           // 6.11 mm6=  GAr+(GAr>>8)
        psrlw     mm5,8             // 5.12 mm5= (FBr+(FBr>>8)>>8)= 00Sa 00Sr 00Sg 00Sb
        psrlw     mm6,8             // 6.12 mm6= (Gar+(GAr>>8)>>8)= 00Ta 00Tr 00Tg 00Tb
        packuswb  mm5,mm6           // 5.13 mm5= Sa Sr Sg Sb Ta Tr Tg Tb
        movq      mm2,mm5           // **PRN store to stack for a moment...

        movq      mm3,[esi+ebx]     // **PRN mm3= Ca Cr Cg Cb Da Dr Dg Db
        movq      mm4,mm3           // **PRN mm4= Ca Cr Cg Cb Da Dr Dg Db
        punpcklbw mm3,mm0           // **PRN mm3=  00Da  00Dr  00Dg  00Db
        punpckhbw mm4,mm0           // **PRN mm4=  00Ca  00Cr  00Cg  00Cb 

        pmullw    mm3,mm1           // **PRN mm3=  (a1)*B
        pmullw    mm4,mm1           // **PRN mm4=  (a2)*A
        paddw     mm3,ROUND         // **PRN mm3=  prod+128=FBr
        paddw     mm4,ROUND         // **PRN mm4=  prod+128=Gar
        movq      mm5,mm3           // **PRN mm5=  FBr
        movq      mm6,mm4           // **PRN mm6=  GAr
        psrlw     mm5,8             // **PRN mm5=  FBr>>8 
        psrlw     mm6,8             // **PRN mm6=  GAr>>8 
        paddw     mm5,mm3           // **PRN mm5=  FBr+(FBr>>8)
        paddw     mm6,mm4           // **PRN mm6=  GAr+(GAr>>8)
        psrlw     mm5,8             // **PRN mm5= (FBr+(FBr>>8)>>8)= 00Xa 00Xr 00Xg 00Xb
        psrlw     mm6,8             // **PRN mm6= (GAr+(GAr>>8)>>8)= 00Ya 00Yr 00Yg 00Yb
        packuswb  mm5,mm6           // **PRN mm5= Ta Tr Tg Tb Sa Sr Sg Sb

        movq      mm6,mm2           // **PRN restore from stack
        paddusb   mm5,mm6           // **PRN add two scaled pixels
        movq      [edx+ebx],mm5     // **PRN store result

        //
        // really done now
        //
        EMMS
    }

trailing:

    // Do the last one non-MMX if the count was odd.

    if (fDoTrailing)
    {
        pDest[nCount] = DXScaleSample(pSrcA[nCount], ulWeightA) +
                        DXScaleSample(pSrcB[nCount], ulWeightB);
    }
}


#endif //defined(_X86_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\fade.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-2000
//
// FileName:    fade.h
//
// Description: Declaration of the CFade class.
//
// Change History:
//
// 1998/01/01   ????        Created.
// 1909/01/25   mcalkins    Fixed property map entries.
// 2000/01/28   mcalkins    Fixed bad fading with 0.0 < overlap < 1.0.
//
//------------------------------------------------------------------------------
#ifndef __FADE_H_
#define __FADE_H_

#include "resource.h" 




class ATL_NO_VTABLE CFade : 
    public CDXBaseNTo1,
    public CComCoClass<CFade, &CLSID_DXFade>,
    public CComPropertySupport<CFade>,
    public IDispatchImpl<IDXTFade, &IID_IDXTFade, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CFade>,
    public IPersistStorageImpl<CFade>,
    public ISpecifyPropertyPagesImpl<CFade>,
    public IPersistPropertyBagImpl<CFade>
{
private:

    CComPtr<IUnknown>   m_spUnkMarshaler;

    BYTE    m_ScaleA[256];
    BYTE    m_ScaleB[256];
    float   m_Overlap;

    void    _ComputeScales(void);
    HRESULT FadeOne(const CDXTWorkInfoNTo1 & WI, IDXSurface *pInSurf,
                    const BYTE *AlphaTable);

public:

    CFade();

    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_FADE)
    DECLARE_POLY_AGGREGATABLE(CFade)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CFade)
        COM_INTERFACE_ENTRY(IDXTFade)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CFade>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CFade)
        PROP_ENTRY("Overlap",   1,  CLSID_FadePP)
        PROP_ENTRY("Center",    2,  CLSID_FadePP)
        PROP_PAGE(CLSID_FadePP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    void    OnGetSurfacePickOrder(const CDXDBnds & BndsPoint, 
                                  ULONG & ulInToTest, ULONG aInIndex[], 
                                  BYTE aWeight[]);

    // IDXTFade methods.

    STDMETHOD(get_Center)(BOOL * pVal);
    STDMETHOD(put_Center)(BOOL newVal);
    STDMETHOD(get_Overlap)(float * pVal);
    STDMETHOD(put_Overlap)(float newVal);

    // IDXEffect methods.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__FADE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\dynarray.h ===
// dynarray.h

#ifndef __DYNARRAY_H_
#define __DYNARRAY_H_

#define DYNARRAY_INITIAL_SIZE 8




template <class T> class CDynArray
{
public:

    CDynArray();
    virtual ~CDynArray();

    STDMETHOD(SetItem)(T & item, ULONG ulPosition);
    STDMETHOD(GetItem)(T & item, ULONG ulPosition);
    STDMETHOD(ExpandTo)(ULONG ulPosition);

    void    Empty();
    ULONG   GetSize() { return m_cFilled; }

private:

    T       m_aT[DYNARRAY_INITIAL_SIZE];
    T *     m_pT;
    ULONG   m_cArraySize;
    ULONG   m_cFilled;
    bool    m_fAllocated;
};


template <class T> 
CDynArray<T>::CDynArray()
{
    m_pT            = m_aT;
    m_cArraySize    = DYNARRAY_INITIAL_SIZE;
    m_cFilled       = 0;
    m_fAllocated    = false;
}


template <class T> 
CDynArray<T>::~CDynArray()
{
    if (m_fAllocated)
    {
        delete [] m_pT;
    }
}


template <class T> 
STDMETHODIMP 
CDynArray<T>::SetItem(T & item, ULONG ulPosition)
{
    HRESULT hr = S_OK;

    _ASSERT(m_cFilled <= m_cArraySize);
    _ASSERT((m_pT == m_aT) ? (m_cArraySize == DYNARRAY_INITIAL_SIZE) : (m_fAllocated));
    _ASSERT(m_fAllocated ? ((m_pT != NULL) && (m_pT != m_aT)) : (m_pT == m_aT));

    // Fail if items are not filled sequentially.

    if (ulPosition > m_cFilled)
    {
        hr = E_FAIL;
        goto done;
    }

    // Expand array if more space is needed.

    if (ulPosition == m_cArraySize)
    {
        // Double current size.

        hr = ExpandTo(m_cArraySize + m_cArraySize);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    // Copy item to array postion.

    m_pT[ulPosition] = item;

    // Increment count of items filled if needed.

    if (ulPosition == m_cFilled)
    {
        m_cFilled++;
    }

done:

    return hr;
}


template <class T>
STDMETHODIMP
CDynArray<T>::GetItem(T & item, ULONG ulPosition)
{
    _ASSERT(m_cFilled <= m_cArraySize);
    _ASSERT((m_pT == m_aT) ? (m_cArraySize == DYNARRAY_INITIAL_SIZE) : (m_fAllocated));
    _ASSERT(m_fAllocated ? ((m_pT != NULL) && (m_pT != m_aT)) : (m_pT == m_aT));

    // Fail if item hasn't been initialized.

    if (ulPosition >= m_cFilled)
    {
        return E_FAIL;
    }

    item = m_pT[ulPosition];

    return S_OK;
}

        
template <class T>
STDMETHODIMP
CDynArray<T>::ExpandTo(ULONG ulSize)
{
    HRESULT hr = S_OK;

    ULONG   ul = 0;
    T *     pT = NULL;

    _ASSERT(m_cFilled <= m_cArraySize);
    _ASSERT((m_pT == m_aT) ? (m_cArraySize == DYNARRAY_INITIAL_SIZE) : (m_fAllocated));
    _ASSERT(m_fAllocated ? ((m_pT != NULL) && (m_pT != m_aT)) : (m_pT == m_aT));

    // Fail if array is already large enough.

    if (ulSize <= m_cArraySize)
    {
        hr = E_FAIL;
        goto done;
    }

    // Allocate new array.

    pT = new T[ulSize];

    // Check for out of memory.

    if (NULL == pT)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Copy previous array to new array.

    for (ul = 0; ul < m_cFilled; ul++)
    {
        pT[ul] = m_pT[ul];
    }

    // Delete old array if needed.

    if (m_fAllocated)
    {
        delete [] m_pT;
    }

    // Set member pointer to new array.

    m_pT = pT;

    // Set allocated flag.

    m_fAllocated = true;

    // Set new array size.

    m_cArraySize = ulSize;

done:

    return hr;
}


template <class T>
void
CDynArray<T>::Empty()
{
    _ASSERT(m_cFilled <= m_cArraySize);
    _ASSERT((m_pT == m_aT) ? (m_cArraySize == DYNARRAY_INITIAL_SIZE) : (m_fAllocated));
    _ASSERT(m_fAllocated ? ((m_pT != NULL) && (m_pT != m_aT)) : (m_pT == m_aT));

    if (m_fAllocated)
    {
        delete [] m_pT;
    }

    m_pT            = m_aT;
    m_fAllocated    = false;
    m_cArraySize    = DYNARRAY_INITIAL_SIZE;
    m_cFilled       = 0;
}

#endif // __DYNARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\dxtwipe.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) 1998-1999 Microsoft Corporation
//
//  File:       dxtwipe.h
//
//  Overview:   This is the header file for the CDXTWipe implementation.
//
//  01/06/98    edc         Created.
//  01/25/99    a-matcal    Fixed property map entries.
//  01/31/99    a-matcal    Optimization.
//  05/14/99    a-matcal    More optimization.
//  10/24/99    a-matcal    Changed CDXTWipe class to CDXTWipeBase and created
//                          two new classes CDXTWipe and CDXTGradientWipe to  
//                          represent non-optimized and optimized versions 
//                          respectively.
//
//------------------------------------------------------------------------------

#ifndef __DXTWIPE
#define __DXTWIPE

#include "resource.h"

#define MAX_WIPE_BOUNDS 3




class ATL_NO_VTABLE CDXTWipeBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<IDXTWipe2, &IID_IDXTWipe2, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTWipeBase>,
    public IObjectSafetyImpl2<CDXTWipeBase>,
    public ISpecifyPropertyPagesImpl<CDXTWipeBase> 
{
private:

    typedef enum {
        MOTION_FORWARD = 0,
        MOTION_REVERSE,
        MOTION_MAX
    } MOTION;

    MOTION                  m_eMotion;
    static const WCHAR *    s_astrMotion[MOTION_MAX];

    long            m_lGradientSize;
    float           m_flGradPercentSize;
    PULONG          m_pulGradientWeights;
    DXWIPEDIRECTION m_eWipeStyle;
    SIZE            m_sizeInput;

    long            m_lCurGradMax;
    long            m_lPrevGradMax;

    CDXDBnds        m_abndsDirty[MAX_WIPE_BOUNDS];
    long            m_alInputIndex[MAX_WIPE_BOUNDS];
    ULONG           m_cbndsDirty;

    CComPtr<IUnknown>   m_cpUnkMarshaler;

    unsigned        m_fOptimizationPossible : 1;

protected:

    unsigned        m_fOptimize             : 1;

private:

    // Functions to calculate optimized bounds when the entire output needs to
    // be redrawn.

    HRESULT _CalcFullBoundsHorizontal();
    HRESULT _CalcFullBoundsVertical();

    // Functions to calculate optimized bounds when only the dirty parts of the
    // output need to be redrawn.

    HRESULT _CalcOptBoundsHorizontal();
    HRESULT _CalcOptBoundsVertical();

    // Function to draw the gradient.

    HRESULT _DrawGradientRect(const CDXDBnds bndsDest, const CDXDBnds bndsSrc,
                              const CDXDBnds bndsGrad, BOOL * pbContinue);

    HRESULT _UpdateStepResAndGradWeights(float flNewGradPercent);

public:

    CDXTWipeBase();
    virtual ~CDXTWipeBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTWipeBase)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDXTWipe)
        COM_INTERFACE_ENTRY(IDXTWipe2)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTWipeBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTWipeBase)
        PROP_ENTRY("GradientSize",  DISPID_DXW_GradientSize,    CLSID_DXTWipePP)
        PROP_ENTRY("WipeStyle",     DISPID_DXW_WipeStyle,       CLSID_DXTWipePP)
        PROP_ENTRY("motion",        DISPID_DXW_Motion,          CLSID_DXTWipePP)
        PROP_PAGE(CLSID_DXTWipePP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);
    HRESULT OnSetup(DWORD dwFlags);
    void    OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXEffect methods

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)

    // IDXTWipe properties

    STDMETHOD(get_GradientSize)(float *pPercentSize);
    STDMETHOD(put_GradientSize)(float PercentSize);
    STDMETHOD(get_WipeStyle)(DXWIPEDIRECTION *pVal);
    STDMETHOD(put_WipeStyle)(DXWIPEDIRECTION newVal);

    // IDXTWipe2 properties

    STDMETHOD(get_Motion)(BSTR * pbstrMotion);
    STDMETHOD(put_Motion)(BSTR bstrMotion);
};


class ATL_NO_VTABLE CDXTWipe :
    public CDXTWipeBase,
    public CComCoClass<CDXTWipe, &CLSID_DXTWipe>,
    public IPersistStorageImpl<CDXTWipe>,
    public IPersistPropertyBagImpl<CDXTWipe>,
    public IOleObjectDXImpl<CDXTWipe>
{
public:

    CDXTWipe()
    {
        m_fOptimize = false;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTWIPE)
    DECLARE_POLY_AGGREGATABLE(CDXTWipe)

    BEGIN_COM_MAP(CDXTWipe)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXTWipeBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTGradientWipe :
    public CDXTWipeBase,
    public CComCoClass<CDXTGradientWipe, &CLSID_DXTGradientWipe>,
    public IPersistStorageImpl<CDXTGradientWipe>,
    public IPersistPropertyBagImpl<CDXTGradientWipe>,
    public IOleObjectDXImpl<CDXTGradientWipe>
{
public:

    CDXTGradientWipe()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTGRADIENTWIPE)
    DECLARE_POLY_AGGREGATABLE(CDXTGradientWipe)

    BEGIN_COM_MAP(CDXTGradientWipe)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXTWipeBase)
    END_COM_MAP()
};


#endif // __DXTWIPE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\filterhelpers.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       filterhelpers.cpp
//
//  Overview:       Helper functions for transforms that are trying to be 
//                  backward compatible with their filter couterparts.
//
//  Change History:
//  1999/09/21  a-matcal    Created.
//  2001/05/30  mcalkins    IE6 Bug 35204
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "filterhelpers.h"
#include "dxclrhlp.h"




HRESULT
FilterHelper_GetColorFromVARIANT(VARIANT varColorParam, DWORD * pdwColor, 
                                 BSTR * pbstrColor)
{
    HRESULT hr          = S_OK;
    BSTR    bstrTemp    = NULL;
    VARIANT varColor;

    Assert(pdwColor);
    Assert(pbstrColor);
    Assert(*pbstrColor == NULL);

    // 2001/05/30 mcalkins
    // IE6 Bug 35204
    // Someone outside of this function is hanging on to a pointer to the
    // original BSTR data in varColorParam.  We used to use VariantChangeType
    // which may release that data, then we'd allocate another BSTR to that same
    // location which would later be released again outside this function
    // causing much havoc.  Now we make a copy of the variant for our uses inside
    // this function.

    ::VariantInit(&varColor);

    hr = ::VariantCopy(&varColor, &varColorParam);

    if (FAILED(hr))
    {
        goto done;
    }

    if (varColor.vt != VT_UI4)
    {
        hr = VariantChangeType(&varColor, &varColor, 0, VT_UI4);
    }

    if (SUCCEEDED(hr)) // It's a number variant.
    {
        *pdwColor = V_UI4(&varColor);
    }
    else // Is it a BSTR variant?
    {
        if (varColor.vt != VT_BSTR)
        {
            hr = VariantChangeType(&varColor, &varColor, 0, VT_BSTR);

            // If this is neither a UI4 or a BSTR, we can't do anything with it.

            if (FAILED(hr))
            {
                goto done;
            }
        }

        hr = DXColorFromBSTR(varColor.bstrVal, pdwColor);

        if (FAILED(hr) && (6 == SysStringLen(varColor.bstrVal)))
        {
            // Nasty back compat issue.  If the color conversion failed, let's
            // try putting a # in front of it because _someone_ decided when
            // they made the original filters not to require it.  grrrr....

            bstrTemp = SysAllocString(L"#RRGGBB");

            if (NULL == bstrTemp)
            {
                hr = E_OUTOFMEMORY;

                goto done;
            }

            wcsncpy(&bstrTemp[1], varColor.bstrVal, 6);

            hr = DXColorFromBSTR(bstrTemp, pdwColor);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    // If a BSTR representation of our color hasn't been created yet, create it.

    if (NULL == bstrTemp)
    {
        if (varColor.vt != VT_BSTR)
        {
            hr = VariantChangeType(&varColor, &varColor, 0, VT_BSTR);
        }

        if (FAILED(hr))
        {
            goto done;
        }

        bstrTemp = SysAllocString(varColor.bstrVal);

        if (NULL == bstrTemp)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }
    }

    Assert(bstrTemp);

done:

    ::VariantClear(&varColor);

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    *pbstrColor = bstrTemp;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\glow.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    glow.cpp
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	Implementation of CGlow, the Glow transform
//
// Change History:
//
// 05/20/99 PhilLu      Move code from dtcss to dxtmsft. New implementation of
//                      glow algorithm.
// 09/04/99 a-matcal    Fixed some memory overrun issues.
// 09/21/99 a-matcal    Changed color parameter to VARIANT.
// 12/03/99 a-matcal    Implement IDXTClipOrigin interface.
// 12/03/99 a-matcal    Default glow color red.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "glow.h"
#include "filterhelpers.h"


//+-----------------------------------------------------------------------------
//
//  CGlow::CGlow
//
//------------------------------------------------------------------------------
CGlow::CGlow() :
    m_lStrength(5),
    m_bstrColor(NULL)
{
    m_rgbColor      = (DXSAMPLE)0xFFFF0000;

    m_sizeInput.cx  = 0;
    m_sizeInput.cy  = 0;

    // Base class members.

    m_ulMaxImageBands = 1; // disable banding
    m_ulMaxInputs     = 1;
    m_ulNumInRequired = 1;
}
//  CGlow::CGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::~CGlow
//
//------------------------------------------------------------------------------
CGlow::~CGlow()
{
    if (m_bstrColor)
    {
        SysFreeString(m_bstrColor);
    }
}
//  CGlow::~CGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CGlow::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_cpUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_bstrColor = SysAllocString(L"red");

    if (NULL == m_bstrColor)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CGlow::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CGlow::put_Color, IDXTGlow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::put_Color(VARIANT varColor)
{
    HRESULT hr          = S_OK;
    DWORD   dwColor     = 0x00000000;
    BSTR    bstrTemp    = NULL;

    hr = FilterHelper_GetColorFromVARIANT(varColor, &dwColor, &bstrTemp);

    if (FAILED(hr))
    {
        goto done;
    }

    _ASSERT(bstrTemp);

    Lock();

    SysFreeString(m_bstrColor);

    m_bstrColor = bstrTemp;
    m_rgbColor  = (DXSAMPLE)dwColor;

    SetDirty();

    Unlock();

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  CGlow::put_Color, IDXTGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::get_Color, IDXTGlow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::get_Color(VARIANT * pvarColor)
{
    HRESULT hr = S_OK;

    if (NULL == pvarColor)
    {
        hr = E_POINTER;

        goto done;
    }

    _ASSERT(m_bstrColor);

    VariantClear(pvarColor);

    pvarColor->vt       = VT_BSTR;
    pvarColor->bstrVal  = SysAllocString(m_bstrColor);

    if (NULL == pvarColor->bstrVal)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CGlow::get_Color, IDXTGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::get_Strength, IDXTGlow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::get_Strength(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lStrength;
    return S_OK;
}
//  CGlow::get_Strength, IDXTGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::put_Strength, IDXTGlow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::put_Strength(long lStrength)
{
    long Strength = min(max(lStrength, 1), 255);

    if (Strength != m_lStrength)
    {
        Lock();
        m_lStrength = Strength;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CGlow::put_Strength, IDXTGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CGlow::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (SUCCEEDED(hr))
    {
        bndsIn.GetXYSize(m_sizeInput);
    }

    return hr;

}
//  CGlow::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CGlow::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CGlow::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                             ULONG aInIndex[], BYTE aWeight[])
{
    ulInToTest = 1;
    aInIndex[0] = 0;
    aWeight[0] = 255;
}
//  CGlow::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CGlow::DetermineBnds, CDXBaseNTo1
//
//  This overrides the base function so as to map to an output surface larger
//  than the input surface.
//
//------------------------------------------------------------------------------
HRESULT 
CGlow::DetermineBnds(CDXDBnds & Bnds)
{
    SIZE size;
    Bnds.GetXYSize(size);
    size.cx += (m_lStrength*2);
    size.cy += (m_lStrength*2);
    Bnds.SetXYSize(size);
    return S_OK;
} /* CGlow::DetermineBnds */


//+-----------------------------------------------------------------------------
//
//  CGlow::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CGlow::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
{
    HRESULT hr      = S_OK;
    int     y       = 0;

    DXPMSAMPLE * pOutBuff         = NULL;
    DXPMSAMPLE * pPMBuff          = NULL;
    DXSAMPLE *   pOperationBuffer = NULL;
    DXSAMPLE *   pRowInBuffer     = NULL;

    SIZE            sizeOperationBuffer = {0, 0};
    DXDITHERDESC    dxdd;

    CComPtr<IDXARGBReadWritePtr>    pDest;
    CComPtr<IDXARGBReadPtr>         pSrc;

    const int nDoWidth = WI.DoBnds.Width();
    const int nDoHeight = WI.DoBnds.Height();

    // This is the size of the operation buffer we'll need.

    sizeOperationBuffer.cx = m_sizeInput.cx + (m_lStrength * 2);
    sizeOperationBuffer.cy = m_sizeInput.cy + (m_lStrength * 2);

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, 
                                      IID_IDXARGBReadWritePtr, 
                                      (void**)&pDest, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = InputSurface()->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    if (DoOver() && OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(nDoWidth);
    }

    //
    //  Set up the dither structure
    //
    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = NULL;                     // to be filled
        dxdd.cSamples       = nDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();     // TODO: ??
    }

    // The output surface has a frame of width m_lStrength. Thus the output
    // surface is 2*Strength larger in both dimensions. Create a buffer the
    // same size as the output surface to hold a copy of the input surface. 
    // Center the input surface in the buffer and pad a frame of value 0. 
    // Note there is an offset m_lStrength from the buffer origin to the start
    // of the input surface.

    // TODO:  Buffering the whole surface is just plain wrong, not to mention
    //        expensive.

    pOperationBuffer = new DXSAMPLE[sizeOperationBuffer.cx * sizeOperationBuffer.cy];

    if (!pOperationBuffer) 
    {
        return E_OUTOFMEMORY;
    }

    memset(pOperationBuffer, 0, 
           sizeOperationBuffer.cx * sizeOperationBuffer.cy * sizeof(DXSAMPLE));

    // Skip m_lStrength rows, as well as m_lStrength pixels on the current row.

    pRowInBuffer = pOperationBuffer + (sizeOperationBuffer.cx * m_lStrength) + m_lStrength;

    for (y = 0; y < m_sizeInput.cy; y++)
    {
        pSrc->MoveToRow(y);
        pSrc->Unpack(pRowInBuffer, m_sizeInput.cx, FALSE);

        pRowInBuffer += sizeOperationBuffer.cx;
    }

    // Create glowing effect in the buffer.

    _PropagateGlow(pOperationBuffer, sizeOperationBuffer.cx, sizeOperationBuffer.cy);

    // Copy the result to output surface.  First move to the correct location of
    // the operation buffer.

    pRowInBuffer = &pOperationBuffer[ 
                    (WI.DoBnds.Top() * sizeOperationBuffer.cx) // Row
                    + WI.DoBnds.Left()                         // + Column
                    ];                         

    for (y = 0; y < nDoHeight; y++)
    {
        // Move to the appropriate row of the output surface.

        pDest->MoveToRow(y);

        if (DoDither())
        {
            dxdd.pSamples = pRowInBuffer;
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            pPMBuff = DXPreMultArray(pRowInBuffer, nDoWidth);
            pDest->OverArrayAndMove(pOutBuff, pPMBuff, nDoWidth);
        }
        else
        {
            pDest->PackAndMove(pRowInBuffer, nDoWidth);
        }

        pRowInBuffer += sizeOperationBuffer.cx;
    }

    delete [] pOperationBuffer;

    return hr;
}
//  CGlow::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CGlow::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                       ULONG ulInIndex, DXBNDS * pInBounds)
{
    CDXDBnds    bndsInput;

    if (ulOutIndex || ulInIndex)
    {
        return E_INVALIDARG;
    }

    if (!pOutBounds || !pInBounds)
    {
        return E_POINTER;
    }

    if (NULL == InputSurface())
    {
        return E_UNEXPECTED;
    }

    *pInBounds = *pOutBounds;

    // Glow needs an input area that is the output area plus a border of 
    // m_lStrength pixels to properly render the requested output area.

    pInBounds->u.D[DXB_X].Min -= m_lStrength;
    pInBounds->u.D[DXB_X].Max += m_lStrength;
    pInBounds->u.D[DXB_Y].Min -= m_lStrength;
    pInBounds->u.D[DXB_Y].Max += m_lStrength;

    bndsInput.SetXYSize(m_sizeInput);

    ((CDXDBnds *)pInBounds)->IntersectBounds(bndsInput);

    return S_OK;
}
//  CGlow::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  CGlow::GetClipOrigin, IDXTClipOrigin
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::GetClipOrigin(DXVEC * pvecClipOrigin)
{
    if (NULL == pvecClipOrigin)
    {
        return E_POINTER;
    }

    pvecClipOrigin->u.D[DXB_X] = m_lStrength;
    pvecClipOrigin->u.D[DXB_Y] = m_lStrength;

    return S_OK;
}
//  CGlow::GetClipOrigin, IDXTClipOrigin


//+-----------------------------------------------------------------------------
//
//  CGlow::_PropagateGlow
//
//  Propagate the alpha value of opaque pixels to transparent pixels to create
//  the glowing effect. The algorithm is similar to the "Mathematical 
//  Morphology" type of algorithm and it scans the image twice.
//
//------------------------------------------------------------------------------
void 
CGlow::_PropagateGlow(DXSAMPLE *pOperationBuffer, int nWidth, int nHeight)
{
    int iCol        = 0;
    int iRow        = 0;
    int iAlphaStep  = 255 / (m_lStrength + 1);
    int iNoise      = 0;
    int iAlpha      = 0;

    DXSAMPLE * pBufRow = NULL;
    DXSAMPLE * pBufPix = NULL;

    // Scan the image twice. The first time is normal scan direction (top-down, 
    // left-right). Add glow effect to the current pixel if either the top or
    // left neighbour (which are scanned before the current pixel) has 
    // sufficiently larger alpha value than the alpha of the current pixel. 
    // Every generation of propagation decreases the alpha value by
    // iAlphaStep = 255/(m_lStrength+1). Thus it takes a maximum of m_lStrength
    // steps to propapage a solid color to transparent ones.

    pBufRow = pOperationBuffer + nWidth;
    for (iRow = 1; iRow < nHeight; iRow++, pBufRow += nWidth)
    {
        pBufPix = pBufRow + 1;
        for (iCol = 1; iCol < nWidth; iCol++, pBufPix++)
        {
            iAlpha = max((pBufPix-1)->Alpha, (pBufPix-nWidth)->Alpha)
                     - iAlphaStep;
            if (iAlpha > 0 && pBufPix->Alpha < iAlpha)
            {
                // add glowing effect: change to glow color with a random noise
                // The alpha value is gradually decreasing.
                iNoise = (int) RandOffset();
                pBufPix->Red = NClamp(m_rgbColor.Red + iNoise);
                pBufPix->Green = NClamp(m_rgbColor.Green + iNoise);
                pBufPix->Blue = NClamp(m_rgbColor.Blue + iNoise);
                pBufPix->Alpha = (BYTE)iAlpha;
            }
        }
    }

    // The second time scan the image in reverse order (bottom-up, right to 
    // left). Add glow effect to the current pixel based the bottom or right
    // neighbour. 
    
    pBufRow = pOperationBuffer + nWidth * (nHeight - 2);
    for (iRow = nHeight - 2; iRow >= 0; iRow--, pBufRow -= nWidth)
    {
        pBufPix = pBufRow + nWidth - 2;
        for (iCol = nWidth - 2; iCol >= 0; iCol--, pBufPix--)
        {
            iAlpha = max((pBufPix+1)->Alpha, (pBufPix+nWidth)->Alpha)
                     - iAlphaStep;
            if (iAlpha > 0 && pBufPix->Alpha < iAlpha)
            {
                iNoise = (int) RandOffset();
                pBufPix->Red = NClamp(m_rgbColor.Red + iNoise);
                pBufPix->Green = NClamp(m_rgbColor.Green + iNoise);
                pBufPix->Blue = NClamp(m_rgbColor.Blue + iNoise);
                pBufPix->Alpha = (BYTE)iAlpha;
            }
        }
    }

}
//  CGlow::_PropageteGlow
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\glow.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    glow.h
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	header file for glow transform implementation CGlow
//
// Change History:
//
// 05/20/99 PhilLu      Move code from dtcss to dxtmsft. New algorithm.
// 09/21/99 a-matcal    Changed color parameter to VARIANT.
// 12/03/99 a-matcal    Add support for IDXTClipOrigin interface.
//
//------------------------------------------------------------------------------

#ifndef __GLOW_H_
#define __GLOW_H_

#include "resource.h"




class ATL_NO_VTABLE CGlow : 
    public CDXBaseNTo1,
    public CComCoClass<CGlow, &CLSID_DXTGlow>,
    public CComPropertySupport<CGlow>,
    public IDispatchImpl<IDXTGlow, &IID_IDXTGlow, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IPersistStorageImpl<CGlow>,
    public ISpecifyPropertyPagesImpl<CGlow>,
    public IPersistPropertyBagImpl<CGlow>,
    public IObjectSafetyImpl2<CGlow>,
    public IDXTClipOrigin
{
private:

    BSTR        m_bstrColor;
    DXSAMPLE    m_rgbColor;
    long        m_lStrength;
    SIZE        m_sizeInput;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // Helpers

    void _PropagateGlow(DXSAMPLE *pBuffer, int nWidth, int nHeight);

    inline long RandOffset(void)
    {
        const int RAND_RANGE = 32;  // range of random variation of glow color
        return (rand() % (2*RAND_RANGE+1) - RAND_RANGE);
    }

    inline BYTE NClamp(int i)
    {
        return (i < 0 ? 0 : (i > 255 ? 255 : i));
    }

public:

    CGlow();
    virtual ~CGlow();

    DECLARE_POLY_AGGREGATABLE(CGlow)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_GLOW)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CGlow)
        COM_INTERFACE_ENTRY(IDXTGlow)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTClipOrigin)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CGlow>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CGlow)
        PROP_ENTRY("Color"   , 1, CLSID_DXTGlowPP)
        PROP_ENTRY("Strength", 2, CLSID_DXTGlowPP)
        PROP_PAGE(CLSID_DXTGlowPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    HRESULT OnSetup(DWORD dwFlags);
    void OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                               ULONG aInIndex[], BYTE aWeight[]);
    HRESULT DetermineBnds(CDXDBnds & Bnds);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTClipOrigin methods.

    STDMETHOD(GetClipOrigin)(DXVEC * pvecClipOrigin);

    // IDXTGlow methods

    STDMETHOD(get_Color)(VARIANT * pvarColor);
    STDMETHOD(put_Color)(VARIANT varColor);
    STDMETHOD(get_Strength)(long * pval);
    STDMETHOD(put_Strength)(long lStrength);
};

#endif //__GLOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\filterhelpers.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       filterhelpers.h
//
//  Overview:       Helper functions for transforms that are trying to be 
//                  backward compatible with their filter couterparts.
//
//  Change History:
//  1999/09/21  a-matcal    Created.
//  2001/05/30  mcalkins    IE6 Bug 35204
//
//------------------------------------------------------------------------------





HRESULT FilterHelper_GetColorFromVARIANT(VARIANT varColorParam, 
                                         DWORD * pdwColor, 
                                         BSTR * pbstrColor);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\graddsp.cpp ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997-2000
//
// FileName:    graddsp.cpp
//
// Description: Dispatch capable version of the gradient filter.
//
// Change History:
//
// 1997/09/05   mikear      Created.
// 2000/05/10   mcalkisn    Cleaned up construction.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include <DXTrans.h>
#include "GradDsp.h"
#include <DXClrHlp.h>




//+-----------------------------------------------------------------------------
//
//  Method: CDXTGradientD::CDXTGradientD
//
//------------------------------------------------------------------------------
CDXTGradientD::CDXTGradientD() :
    m_pGradientTrans(NULL),
    m_pGradient(NULL),
    m_StartColor(0xFF0000FF),
    m_EndColor(0xFF000000),
    m_GradType(DXGRADIENT_VERTICAL),
    m_bKeepAspect(false)
{
}
//  Method: CDXTGradientD::CDXTGradientD

    
/////////////////////////////////////////////////////////////////////////////
// CDXTGradientD
/*****************************************************************************
* CDXTGradientD::FinalConstruct *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXTGradientD::FinalConstruct()
{
    HRESULT     hr          = S_OK;
    BSTR        bstr        = NULL;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_cpUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    bstr = SysAllocString(L"#FF0000FF");

    if (NULL == bstr)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    m_cbstrStartColor.Attach(bstr);

    bstr = SysAllocString(L"#FF000000");

    if (NULL == bstr)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    m_cbstrEndColor.Attach(bstr);

    hr = ::CoCreateInstance(CLSID_DXGradient, GetControllingUnknown(), 
                            CLSCTX_INPROC, __uuidof(IUnknown), 
                            (void **)&m_cpunkGradient);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_cpunkGradient->QueryInterface(__uuidof(IDXTransform), 
                                         (void **)&m_pGradientTrans);

    if (FAILED(hr))
    {
        goto done;
    }

    // Querying an aggregated interface causes us to have a reference count on
    // ourself.  This is bad, so call release on the outer object to reduce the
    // count.

    GetControllingUnknown()->Release();

    hr = m_cpunkGradient->QueryInterface(IID_IDXGradient, 
                                         (void **)&m_pGradient);
    
    if (FAILED(hr))
    {
        goto done;
    }

    // Querying an aggregated interface causes us to have a reference count on
    // ourself.  This is bad, so call release on the outer object to reduce the
    // count.

    GetControllingUnknown()->Release();

done:

    return hr;
} /* CDXTGradientD::FinalConstruct */

/*****************************************************************************
* CDXTGradientD::FinalRelease *
*--------------------------*
*   Description:
*       The inner interfaces are released using COM aggregation rules. Releasing
*   the inner causes the outer to be released, so we addref the outer prior to
*   protect it.
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXTGradientD::FinalRelease()
{
    // Safely free the inner interfaces held.

    if (m_pGradientTrans)
    {
        GetControllingUnknown()->AddRef();

        m_pGradientTrans->Release();
    }

    if (m_pGradient)
    {
        GetControllingUnknown()->AddRef();

        m_pGradient->Release();
    }

    return S_OK;
} /* CDXTGradientD::FinalRelease */


//
//=== IDXTGradientD ==============================================================
//

/*****************************************************************************
* CDXTGradientD::put_StartColor *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_StartColor( OLE_COLOR Color )
{
    USES_CONVERSION;

    HRESULT hr = S_OK;

    if( m_StartColor != Color )
    {
        TCHAR   szStartColor[10];
        BSTR    bstrStartColor;

        // Format OLE_COLOR into a BSTR color.

        wsprintf(szStartColor, _T("#%08X"), Color);

        bstrStartColor = SysAllocString(T2OLE(szStartColor));

        if (bstrStartColor == NULL)
            return E_OUTOFMEMORY;

        // Set gradient color.

        hr = m_pGradient->SetGradient(Color, m_EndColor, 
                                      m_GradType == DXGRADIENT_HORIZONTAL);

        // If everything worked out OK, alter internal property settings.

        if( SUCCEEDED( hr ) )
        {
            m_StartColor = Color;
            m_cbstrStartColor.Empty();
            m_cbstrStartColor.Attach(bstrStartColor);
        }
        else
        {
            SysFreeString(bstrStartColor);
        }
    }

    return hr;
} /* CDXTGradientD::put_StartColor */


/*****************************************************************************
* CDXTGradientD::get_StartColor *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_StartColor( OLE_COLOR *pColor )
{
    if( DXIsBadWritePtr( pColor, sizeof(*pColor) ) ) return E_POINTER;
    *pColor = m_StartColor;
    return S_OK;
} /* CDXTGradientD::get_StartColor */


/*****************************************************************************
* CDXTGradientD::put_EndColor *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_EndColor( OLE_COLOR Color )
{
    USES_CONVERSION;

    HRESULT hr = S_OK;

    if( m_EndColor != Color )
    {
        TCHAR   szEndColor[10];
        BSTR    bstrEndColor;

        // Format OLE_COLOR into a BSTR color.

        wsprintf(szEndColor, _T("#%08X"), Color);

        bstrEndColor = SysAllocString(T2OLE(szEndColor));

        if (bstrEndColor == NULL)
            return E_OUTOFMEMORY;

        // Set gradient color.

        hr = m_pGradient->SetGradient(m_StartColor, Color, 
                                      m_GradType == DXGRADIENT_HORIZONTAL);

        // If everything worked out OK, alter internal property settings.

        if( SUCCEEDED( hr ) )
        {
            m_EndColor = Color;
            m_cbstrEndColor.Empty();
            m_cbstrEndColor.Attach(bstrEndColor);
        }
        else
        {
            SysFreeString(bstrEndColor);
        }
    }

    return hr;
} /* CDXTGradientD::put_EndColor */


/*****************************************************************************
* CDXTGradientD::get_EndColor *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_EndColor( OLE_COLOR *pColor )
{
    if( DXIsBadWritePtr( pColor, sizeof(*pColor) ) ) return E_POINTER;
    *pColor = m_EndColor;
    return S_OK;
} /* CDXTGradientD::get_EndColor */


/*****************************************************************************
* CDXTGradientD::put_GradientType *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_GradientType( DXGRADIENTTYPE Type )
{
    HRESULT hr = S_OK;
    if( Type < DXGRADIENT_VERTICAL || Type > DXGRADIENT_HORIZONTAL )
    {
        hr = E_INVALIDARG;
    }
    else if( m_GradType != Type )
    {
        hr = m_pGradient->SetGradient( m_StartColor, m_EndColor, Type );
        if( SUCCEEDED( hr ) )
        {
            m_GradType = Type;
        }
    }
    return hr;
} /* CDXTGradientD::put_GradientType */


/*****************************************************************************
* CDXTGradientD::get_GradientType *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_GradientType( DXGRADIENTTYPE *pType )
{
    if( DXIsBadWritePtr( pType, sizeof(*pType) ) ) return E_POINTER;
    *pType = m_GradType;
    return S_OK;
} /* CDXTGradientD::get_GradientType */


/*****************************************************************************
* CDXTGradientD::put_GradientWidth *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_GradientWidth( long lVal )
{
    if( lVal <= 0 ) return E_INVALIDARG;

    SIZE sz;
    m_pGradient->GetOutputSize( &sz );
    sz.cx = lVal;
    return m_pGradient->SetOutputSize( sz, m_bKeepAspect );
} /* CDXTGradientD::put_GradientWidth */


/*****************************************************************************
* CDXTGradientD::get_GradientWidth *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_GradientWidth( long *pVal )
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) ) return E_POINTER;

    SIZE sz;
    m_pGradient->GetOutputSize( &sz );
    *pVal = sz.cx;
    return S_OK;
} /* CDXTGradientD::get_GradientWidth */


/*****************************************************************************
* CDXTGradientD::put_GradientHeight *
*-----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_GradientHeight( long lVal )
{
    if( lVal <= 0 ) return E_INVALIDARG;

    SIZE sz;
    m_pGradient->GetOutputSize( &sz );
    sz.cy = lVal;
    return m_pGradient->SetOutputSize( sz, m_bKeepAspect );
} /* CDXTGradientD::put_GradientHeight */


/*****************************************************************************
* CDXTGradientD::get_GradientHeight *
*-----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_GradientHeight( long *pVal )
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) ) return E_POINTER;

    SIZE sz;
    m_pGradient->GetOutputSize( &sz );
    *pVal = sz.cy;
    return S_OK;
} /* CDXTGradientD::get_GradientHeight */


/*****************************************************************************
* CDXTGradientD::put_KeepAspectRatio *
*------------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_KeepAspectRatio( VARIANT_BOOL b )
{
    HRESULT hr = S_OK;
    if( m_bKeepAspect != b )
    {
        SIZE sz;
        m_pGradient->GetOutputSize( &sz );
        hr = m_pGradient->SetOutputSize( sz, b );

        if( SUCCEEDED( hr ) )
        {
            m_bKeepAspect = b;
        }
    }
    return hr;
} /* CDXTGradientD::put_KeepAspectRatio */


/*****************************************************************************
* CDXTGradientD::get_KeepAspectRatio *
*------------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_KeepAspectRatio( VARIANT_BOOL *pVal )
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) ) return E_POINTER;
    *pVal = m_bKeepAspect;
    return S_OK;
} /* CDXTGradientD::get_KeepAspectRatio */

/*****************************************************************************
* CDXTGradientD::put_StartColorStr *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_StartColorStr( BSTR Color )
{
    HRESULT hr      = S_OK;
    DWORD   dwColor = 0;
    
    if (DXIsBadReadPtr(Color, SysStringByteLen(Color)))
        return E_POINTER;

    hr = ::DXColorFromBSTR(Color, &dwColor);

    if( SUCCEEDED( hr ) )
    {
        // Copy the Color BSTR.

        BSTR bstrStartColor = SysAllocString(Color);

        if (bstrStartColor == NULL)
            return E_OUTOFMEMORY;

        // Set gradient color.

        hr = m_pGradient->SetGradient(dwColor, m_EndColor, 
                                      m_GradType == DXGRADIENT_HORIZONTAL);

        // If everything worked out OK, alter internal property settings.

        if( SUCCEEDED( hr ) )
        {
            m_StartColor = dwColor;
            m_cbstrStartColor.Empty();
            m_cbstrStartColor.Attach(bstrStartColor);
        }
        else
        {
            SysFreeString(bstrStartColor);
        }
    }

    return hr;
} /* CDXTGradientD::put_StartColorStr */


/*****************************************************************************
* CDXTGradientD::get_StartColorStr *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Matt Calkins                                    Date: 01/25/99
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_StartColorStr(BSTR* pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;

    *pVal = m_cbstrStartColor.Copy();

    if (NULL == *pVal)
        return E_OUTOFMEMORY;

    return S_OK;
} /* CDXTGradientD::get_StartColorStr */


/*****************************************************************************
* CDXTGradientD::put_EndColorStr *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_EndColorStr( BSTR Color )
{
    HRESULT hr      = S_OK;
    DWORD   dwColor = 0;
     
    if (DXIsBadReadPtr(Color, SysStringByteLen(Color)))
        return E_POINTER;

    hr = ::DXColorFromBSTR(Color, &dwColor);

    if( SUCCEEDED( hr ) )
    {
        // Copy the Color BSTR.

        BSTR bstrEndColor = SysAllocString(Color);

        if (bstrEndColor == NULL)
            return E_OUTOFMEMORY;

        // Set gradient color.

        hr = m_pGradient->SetGradient(m_StartColor, dwColor, 
                                      m_GradType == DXGRADIENT_HORIZONTAL);

        // If everything worked out OK, alter internal property settings.

        if( SUCCEEDED( hr ) )
        {
            m_EndColor = dwColor;
            m_cbstrEndColor.Empty();
            m_cbstrEndColor.Attach(bstrEndColor);
        }
        else
        {
            SysFreeString(bstrEndColor);
        }
    }

    return hr;
} /* CDXTGradientD::put_EndColorStr */


/*****************************************************************************
* CDXTGradientD::get_EndColorStr *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Matt Calkins                                    Date: 01/25/99
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_EndColorStr(BSTR* pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;

    *pVal = m_cbstrEndColor.Copy();

    if (NULL == *pVal)
        return E_OUTOFMEMORY;

    return S_OK;
} /* CDXTGradientD::get_EndColorStr */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\gridbase.h ===
//+-----------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       \aspen\src\dxt\packages\msft\src\gridbase.h
//
//  Contents:   A base class for grid oriented transforms.
//
//  Created By: a-matcal
//
//------------------------------------------------------------------------------

#ifndef __GRIDBASE
#define __GRIDBASE

#include "dynarray.h"

#define GRID_DRAWCELL 0x00010000L




//+-----------------------------------------------------------------------------
//
// CDirtyBnds class
//
//------------------------------------------------------------------------------
class CDirtyBnds
{
public:

    CDXDBnds    bnds;
    ULONG       ulInput;

    CDirtyBnds() : ulInput(0) {};
};


//+-----------------------------------------------------------------------------
//
// CGridBase class
//
//------------------------------------------------------------------------------
class CGridBase :
    public CDXBaseNTo1
{
private:

    DWORD * m_padwGrid;
    ULONG * m_paulBordersX;
    ULONG * m_paulBordersY;

    SIZE    m_sizeInput;

    ULONG   m_ulPrevProgress;
    ULONG   m_cbndsDirty;

    CDynArray<CDirtyBnds>   m_dabndsDirty;

    unsigned    m_fGridDirty            : 1;
    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

private:

    HRESULT _CreateNewGridAndIndex(SIZE & sizeNewGrid);
    HRESULT _GenerateBoundsFromGrid();
    void    _CalculateBorders();

    // CDXBaseNTo1

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1& WI, BOOL* pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);
                                  
protected:

    SIZE    m_sizeGrid;
    ULONG * m_paulIndex;

    virtual HRESULT OnDefineGridTraversalPath() = 0;

public:

    CGridBase();
    virtual ~CGridBase();
    HRESULT FinalConstruct();

    // IDXTGridSize

    STDMETHOD(get_gridSizeX)(/*[out, retval]*/ short *pX);
    STDMETHOD(put_gridSizeX)(/*[in]*/ short newX);
    STDMETHOD(get_gridSizeY)(/*[out, retval]*/ short *pY);
    STDMETHOD(put_gridSizeY)(/*[in]*/ short newY);
};

// Makes it easy for derived classes to implement forwarding functions to the implementations
// of these interface methods, which are actually in this class.

#define DECLARE_IDXTGRIDSIZE_METHODS() \
    STDMETHODIMP get_gridSizeX(short *pX) { return CGridBase::get_gridSizeX(pX); }      \
    STDMETHODIMP put_gridSizeX(short newX) { return CGridBase::put_gridSizeX(newX); }   \
    STDMETHODIMP get_gridSizeY(short *pY) { return CGridBase::get_gridSizeY(pY); }      \
    STDMETHODIMP put_gridSizeY(short newY) { return CGridBase::put_gridSizeY(newY); }

#endif // __GRIDBASE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\graddsp.h ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997-2000
//
// FileName:    graddsp.h
//
// Description: Dispatch capable version of the gradient filter.
//
// Change History:
//
// 1997/09/05   mikear      Created.
// 1999/01/25   mcalkins    Fixed property map entries.
// 2000/05/10   mcalkins    Added marshaler, aggregation, cleanup.
//
//------------------------------------------------------------------------------
#ifndef __GradDsp_H_
#define __GradDsp_H_

#include <DTBase.h>
#include "resource.h"




class ATL_NO_VTABLE CDXTGradientD : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CDXTGradientD, &CLSID_DXTGradientD>,
    public CComPropertySupport<CDXTGradientD>,
    public IDispatchImpl<IDXTGradientD, &IID_IDXTGradientD, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CDXTGradientD>,
    public IPersistStorageImpl<CDXTGradientD>,
    public ISpecifyPropertyPagesImpl<CDXTGradientD>,
    public IPersistPropertyBagImpl<CDXTGradientD>
{
private:

    CComBSTR            m_cbstrStartColor;
    CComBSTR            m_cbstrEndColor;
    CComPtr<IUnknown>   m_cpunkGradient;
    CComPtr<IUnknown>   m_cpUnkMarshaler;

    IDXGradient *       m_pGradient;
    IDXTransform *      m_pGradientTrans;
    DXSAMPLE            m_StartColor;
    DXSAMPLE            m_EndColor;
    DXGRADIENTTYPE      m_GradType;
    VARIANT_BOOL        m_bKeepAspect;

public:

    CDXTGradientD();

    // TODO:  I'd like this to be aggregatable, but when I specify this macro,
    //        the object enters into FinalConstruct() with a reference count of
    //        zero instead of one (as it does w/o the macro) which causes the
    //        object to destroy itself when it releases the AddRefs it does
    //        on itself via QI.  

    // DECLARE_POLY_AGGREGATABLE(CDXTGradientD)

    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_GRADDSP)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CDXTGradientD)
        COM_INTERFACE_ENTRY(IDXTGradientD)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTGradientD>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_cpunkGradient.p)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTGradientD)
        PROP_ENTRY("GradientType",      DISPID_GradientType,    CLSID_GradientPP)
        PROP_ENTRY("StartColor",        DISPID_StartColor,      CLSID_GradientPP)
        PROP_ENTRY("EndColor",          DISPID_EndColor,        CLSID_GradientPP)
        PROP_ENTRY("GradientHeight",    DISPID_GradientHeight,  CLSID_GradientPP)
        PROP_ENTRY("GradientWidth",     DISPID_GradientWidth,   CLSID_GradientPP)
        PROP_ENTRY("KeepAspectRatio",   DISPID_GradientAspect,  CLSID_GradientPP)
        PROP_ENTRY("StartColorStr",     DISPID_StartColorStr,   CLSID_GradientPP)
        PROP_ENTRY("EndColorStr",       DISPID_EndColorStr,     CLSID_GradientPP)
        PROP_PAGE( CLSID_GradientPP )
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();
    HRESULT FinalRelease();

    // IDXTGradientD properties.

    STDMETHOD(get_GradientType)(/*[out, retval]*/ DXGRADIENTTYPE *pVal);
    STDMETHOD(put_GradientType)(/*[in]*/ DXGRADIENTTYPE newVal);
    STDMETHOD(get_StartColor)(/*[out, retval]*/ OLE_COLOR *pVal);
    STDMETHOD(put_StartColor)(/*[in]*/ OLE_COLOR newVal);
    STDMETHOD(get_EndColor)(/*[out, retval]*/ OLE_COLOR *pVal);
    STDMETHOD(put_EndColor)(/*[in]*/ OLE_COLOR newVal);
    STDMETHOD(get_GradientWidth)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_GradientWidth)(/*[in]*/ long newVal);
    STDMETHOD(get_GradientHeight)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_GradientHeight)(/*[in]*/ long newVal);
    STDMETHOD(get_KeepAspectRatio)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_KeepAspectRatio)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(get_StartColorStr)(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(put_StartColorStr)(/*[in]*/ BSTR Color);
    STDMETHOD(get_EndColorStr)(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(put_EndColorStr)(/*[in]*/ BSTR Color);
};

#endif //__GradDsp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\gridbase.cpp ===
//+-----------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       \aspen\src\dxt\packages\msft\src\gridbase.cpp
//
//  Contents:   A base class for grid oriented transforms.
//
//  Created By: a-matcal
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "gridbase.h"




// 
// ----- CGridBase methods -----
//


//+-----------------------------------------------------------------------------
//
//  CGridBase::CGridBase
//
//------------------------------------------------------------------------------
CGridBase::CGridBase() :
    m_padwGrid(NULL),
    m_paulIndex(NULL),
    m_paulBordersX(NULL),
    m_paulBordersY(NULL),
    m_ulPrevProgress(0),
    m_cbndsDirty(0),
    m_fGridDirty(true),
    m_fOptimizationPossible(false),
    m_fOptimize(false)
{
    m_sizeGrid.cx     = 16;
    m_sizeGrid.cy     = 16;

    m_sizeInput.cx    = 0;
    m_sizeInput.cy    = 0;

    // CDXBaseNTo1 base class members

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0F;
}
//  CGridBase::CGridBase

    
//+-----------------------------------------------------------------------------
//
//  CGridBase::~CGridBase
//
//------------------------------------------------------------------------------
CGridBase::~CGridBase()
{
    if (m_padwGrid)
    {
        delete [] m_padwGrid;
    }

    if (m_paulIndex)
    {
        delete [] m_paulIndex;
    }

    if (m_paulBordersX)
    {
        delete [] m_paulBordersX;
    }

    if (m_paulBordersY)
    {
        delete [] m_paulBordersY;
    }
}
//  CGridBase::~CGridBase


//+-----------------------------------------------------------------------------
//
//  CGridBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CGridBase::FinalConstruct()
{
    return _CreateNewGridAndIndex(m_sizeGrid);
}
//  CGridBase::FinalConstruct


//+-----------------------------------------------------------------------------
//
//  CGridBase::_CreateNewGridAndIndex
// 
//  Overview:   This function allocates memory for a new grid, index, and border
//              position arrays if the size of the grid changes.  It is called
//              once from FinalContruct() for initialization and from the 
//              property functions put_gridSizeY() and put_gridSizeX().
//              
//  Arguments:  sizeNewGrid   The desired grid size. 
//
//  Returns:    S_OK            new objects were created propertly.
//              E_OUTOFMEMORY   new objects could not be created for lack of
//                              memory.
//
//------------------------------------------------------------------------------
HRESULT
CGridBase::_CreateNewGridAndIndex(SIZE & sizeNewGrid)
{
    HRESULT hr = S_OK;

    DWORD * padwGrid        = NULL;
    ULONG * paulIndex       = NULL;
    ULONG * paulBordersX    = NULL;
    ULONG * paulBordersY    = NULL;

    padwGrid = new DWORD[sizeNewGrid.cx * sizeNewGrid.cy];

    if (NULL == padwGrid)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    paulIndex = new ULONG[sizeNewGrid.cx * sizeNewGrid.cy];

    if (NULL == paulIndex)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    paulBordersX = new ULONG[sizeNewGrid.cx + 1];

    if (NULL == paulBordersX)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    paulBordersY = new ULONG[sizeNewGrid.cy + 1];

    if (NULL == paulBordersY)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

done:

    if (FAILED(hr))
    {
        if (padwGrid)
        {
            delete [] padwGrid;
        }

        if (paulIndex)
        {
            delete [] paulIndex;
        }

        if (paulBordersX)
        {
            delete [] paulBordersX;
        }

        if (paulBordersY)
        {
            delete [] paulBordersY;
        }

        return hr;
    }

    // Success

    if (m_padwGrid)
    {
        delete [] m_padwGrid;
    }

    if (m_paulIndex)
    {
        delete [] m_paulIndex;
    }

    if (m_paulBordersX)
    {
        delete [] m_paulBordersX;
    }

    if (m_paulBordersY)
    {
        delete [] m_paulBordersY;
    }

    m_padwGrid      = padwGrid;
    m_paulIndex     = paulIndex;
    m_paulBordersX  = paulBordersX;
    m_paulBordersY  = paulBordersY;

    return S_OK;
}
//  CGridBase::_CreateNewGridAndIndex


//+-----------------------------------------------------------------------------
//
//  CGridBase::_GenerateBoundsFromGrid
//
//------------------------------------------------------------------------------
HRESULT 
CGridBase::_GenerateBoundsFromGrid()
{
    HRESULT hr          = S_OK;
    DWORD * padwCurRow  = NULL;

    int x = 0;
    int y = 0;

    _ASSERT(m_padwGrid != NULL);

    m_cbndsDirty = 0;

    for (y = 0; y < m_sizeGrid.cy; y++)
    {
        padwCurRow = &m_padwGrid[y * m_sizeGrid.cx];

        for (x = 0; x < m_sizeGrid.cx; x++)
        {
            if (padwCurRow[x] & GRID_DRAWCELL)
            {
                DWORD       dw = 0;
                RECT        rc;

                CDXDBnds    bnds;
                CDirtyBnds  dbnds;

                // A block has been found, determine its dimensions and remove
                // it's cells' draw flags.  The steps to do this are:
                // A.  Determine the width, right edge.
                // B.  Determine the height, bottom edge.
                // C.  Calculate the actual surface bounds and add a new bounds
                //     structure to the array.

                rc.left     = x;
                rc.top      = y;
                rc.right    = x + 1;
                rc.bottom   = y + 1;

                dw = padwCurRow[x];

                padwCurRow[x] &= (~GRID_DRAWCELL);

                // A. Find the right edge of this block (width).

                while (((x + 1) < m_sizeGrid.cx) && (padwCurRow[x + 1] == dw))
                {
                    rc.right++;
                    x++;

                    padwCurRow[x] &= (~GRID_DRAWCELL);
                } // block width loop.

                // B. Find the bottom edge of this block (height).

                while (rc.bottom < m_sizeGrid.cy)
                {
                    int     x2 = 0;
                    DWORD * padwCandidateRow = &m_padwGrid[rc.bottom * m_sizeGrid.cx];

                    // This loop performs 3 tests on each candidate row to make
                    // sure we should expand the vertical height of the block.
                    // 1.  The left edge must match.
                    // 2.  The right edge must match.
                    //
                    //   If the cells needing to be painted spill over the right
                    //   or left edges, it's more optimal for them to be placed
                    //   in a different block.
                    //
                    // 3.  All the cells between the left and right edge must
                    //     require painting of the same input.


                    // 1. If the left edge of our block is not the left edge of
                    // the matrix AND the cell to the left of our block on this
                    // row is the same as the cell type we're looking for, these
                    // cells don't belong in our block.  Exit.
                   
                    if ((rc.left > 0)
                        && (padwCandidateRow[rc.left - 1] == dw))
                    {
                        break;
                    }

                    // 2. If the right edge of our block is not touching the
                    // right edge of the matrix AND the cell to our right is the
                    // same as the cell type we're looking for, these cells
                    // don't belong in our block.  Exit.

                    if ((rc.right < m_sizeGrid.cx) 
                        && (padwCandidateRow[rc.right] == dw))
                    {
                        break;
                    }

                    // 3. Traverse the cells that would be a part of our block 
                    // to see if they are all the appropriate type.

                    x2 = rc.left;
                    
                    while (x2 < rc.right && padwCandidateRow[x2] == dw)
                    {
                        x2++;
                    }

                    // If we didn't traverse all the way to the right edge of 
                    // our block, these cells don't belong in our block.  Exit.

                    if (x2 < rc.right)
                    {
                        break;
                    }

                    // These cells belong in our block so traverse the cells
                    // again to remove the draw flag from each of them.

                    for (x2 = rc.left; x2 < rc.right; x2++)
                    {
                        padwCandidateRow[x2] &= (~GRID_DRAWCELL);
                    }

                    // Increase the vertical size of our block to include the
                    // cells in this row.

                    rc.bottom++;

                } // block height loop.

                // C. Create new bounds from block size, add to array, and keep
                // going.

                rc.left     = m_paulBordersX[rc.left];
                rc.top      = m_paulBordersY[rc.top];
                rc.right    = m_paulBordersX[rc.right];
                rc.bottom   = m_paulBordersY[rc.bottom];

                dbnds.bnds.SetXYRect(rc);
                dbnds.ulInput = dw & 0x0000FFFFL;

                hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

                if (FAILED(hr))
                {
                    goto done;
                }

                m_cbndsDirty++;
            }
        } // x loop
    } // y loop

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CGridBase::_GenerateBoundsFromGrid


//+-----------------------------------------------------------------------------
//
//  CGridBase::_CalculateBorders
// 
//  Overview:  This function calculates the borders of the squares in the grid
//             in measurements of pixels in the x and y directions. The function
//             should be called in two cases:
//
//      1.  If the grid is dirty this function will be called from 
//          OnInitInstData()
//      2.  The input size has changed this function will be called from 
//          OnSetup()
//
//------------------------------------------------------------------------------
void
CGridBase::_CalculateBorders()
{
    long i = 0;
    float   flTemp1 = (float)m_sizeInput.cx / (float)m_sizeGrid.cx;
    float   flTemp2 = (float)m_sizeInput.cy / (float)m_sizeGrid.cy;

    _ASSERT(m_paulBordersX != NULL);
    _ASSERT(m_paulBordersY != NULL);

    // Calculate horizontal borders.

    m_paulBordersX[0] = 0;

    for (i = 1; i < m_sizeGrid.cx; i++)
    {
        m_paulBordersX[i] = (ULONG)((float)i * flTemp1);
    }

    m_paulBordersX[i] = m_sizeInput.cx;

    // Calculate vertical borders.

    m_paulBordersY[0] = 0;

    for (i = 1; i < m_sizeGrid.cy; i++)
    {
        m_paulBordersY[i] = (ULONG)((float)i * flTemp2);
    }

    m_paulBordersY[i] = m_sizeInput.cy;
}
// CGridBase::_CalculateBorders

   
//
// ----- CDXBaseNTo1 methods -----
//


//+-----------------------------------------------------------------------------
//
//  CGridBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CGridBase::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;
    
    CDXDBnds bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsIn.GetXYSize(m_sizeInput);

    _CalculateBorders();

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
// CGridBase::OnSetup


//+-----------------------------------------------------------------------------
//
//  CGridBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CGridBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                                 ULONG aInIndex[], BYTE aWeight[])
{
    POINT   ptLoc;
    ULONG   ulX;
    ULONG   ulY;

    ulX = OutPoint.Left();
    ulY = OutPoint.Top();

    ptLoc.x = 0;
    ptLoc.y = 0;

    // Check for out of bounds.

    if ((OutPoint.Left() < 0) || (OutPoint.Left() >= m_sizeInput.cx))
    {
        ulInToTest = 0;
        goto done;
    }

    if ((OutPoint.Top() < 0) || (OutPoint.Top() >= m_sizeInput.cy))
    {
        ulInToTest = 0;
        goto done;
    }

    ulInToTest  = 1;
    aWeight[0]  = 255;

    // Which column?

    while (ptLoc.x < m_sizeGrid.cx)
    {
        if (ulX > m_paulBordersX[ptLoc.x + 1])
        {
            ptLoc.x++;
        }
        else
        {
            break;
        }
    }

    // Which row?

    while (ptLoc.y < m_sizeGrid.cy)
    {
        if (ulY > m_paulBordersY[ptLoc.y + 1])
        {
            ptLoc.y++;
        }
        else
        {
            break;
        }
    }

    aInIndex[0] = m_padwGrid[ptLoc.y * m_sizeGrid.cx + ptLoc.x] & (~GRID_DRAWCELL);
    
done:

    return;
}
//  CGridBase::OnGetSurfacePickOrder


//+-----------------------------------------------------------------------------
//
//  CGridBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CGridBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;
    
    ULONG   ulMax       = m_sizeGrid.cx * m_sizeGrid.cy;
    ULONG   ulProgress  = (ULONG)(GetEffectProgress() * ((float)ulMax + 0.5F));
    ULONG   i           = 0;

    if (m_fGridDirty)
    {
        OnDefineGridTraversalPath();
        _CalculateBorders();
        m_fGridDirty = false;
    }

    // If the inputs, output, or transform is dirty, or if we can't optimize we
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        for (i = 0; i < ulProgress; i++)
        {
            m_padwGrid[m_paulIndex[i]] = GRID_DRAWCELL | 1;
        }

        for (i = ulProgress; i < ulMax; i++)
        {
            m_padwGrid[m_paulIndex[i]] = GRID_DRAWCELL;
        }
    }
    else // Create optimized dirty bounds.
    {
        if (ulProgress == m_ulPrevProgress)
        {
            m_cbndsDirty = 0;
            goto done;
        }

        // TODO: Clear matrix.

        if (ulProgress > m_ulPrevProgress)
        {
            // We're going forward in the spiral, fill cells with input B.

            for (i = m_ulPrevProgress; i < ulProgress; i++)
            {
                m_padwGrid[m_paulIndex[i]] = GRID_DRAWCELL | 1;
            }
        }
        else
        {
            // We're going backward in the spiral, fill cells with input A.

            for (i = ulProgress; i < m_ulPrevProgress; i++)
            {
                m_padwGrid[m_paulIndex[i]] = GRID_DRAWCELL;
            }
        }
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

    m_ulPrevProgress = ulProgress;

    hr = _GenerateBoundsFromGrid();

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
// CGridBase::OnInitInstData


//+-----------------------------------------------------------------------------
//
//  CGridBase::WorkProc, CDXBaseNTo1
//
//  Overview:   This function is used to calculate the result based on the
//              specified bounds and the current effect progress.
//
//------------------------------------------------------------------------------
HRESULT 
CGridBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    DWORD   dwFlags         = 0;
    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    for (ULONG i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;
        CDirtyBnds  dbnds;

        hr = m_dabndsDirty.GetItem(dbnds, i);

        if (FAILED(hr))
        {
            goto done;
        }

        if (bndsSrc.IntersectBounds(WI.DoBnds, dbnds.bnds))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            hr = DXBitBlt(OutputSurface(), bndsDest,
                          InputSurface(dbnds.ulInput), bndsSrc,
                          dwFlags, INFINITE);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
// CGridBase::WorkProc


//+-----------------------------------------------------------------------------
//
//  CGridBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CGridBase::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CGridBase::OnFreeInstData


//
//  ----- IDXTGridSize methods -----
//


//+-----------------------------------------------------------------------------
//
//  CGridBase::get_gridSizeX, IDXTGridSize
//
//  Overview:   Get the horizontal grid size (number of cells in a row)
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CGridBase::get_gridSizeX(short * pX)
{
    if (!pX)
    {
        return E_POINTER;
    }

    *pX = (short)m_sizeGrid.cx;

    return S_OK;
}
//  CGridBase::get_gridSizeX


//+-----------------------------------------------------------------------------
//
//  CGridBase::put_gridSizeX, IDXTGridSize
//
//  Overview:   Set the horizontal grid size (number of cells in a row)
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CGridBase::put_gridSizeX(short newX)
{
    HRESULT hr = S_OK;

    if (newX > 0 && newX < 101)
    {
        if (m_sizeGrid.cx != newX)
        {
            SIZE szNew = m_sizeGrid;

            szNew.cx = newX;

            hr = _CreateNewGridAndIndex(szNew);

            if (FAILED(hr))
            {
                goto done;
            }

            Lock();
            m_sizeGrid.cx   = newX;
            m_fGridDirty    = true;
            Unlock();

            SetDirty();
        }
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CGridBase::put_gridSizeX


//+-----------------------------------------------------------------------------
//
//  CGridBase::get_gridSizeY, IDXTGridSize
//
//  Overview:   Get the vertical grid size (number of cells in a column)
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CGridBase::get_gridSizeY(short *pY)
{
    if (!pY)
    {
        return E_POINTER;
    }

    *pY = (short)m_sizeGrid.cy;

    return S_OK;
}
//  CGridBase::get_gridSizeY


//+-----------------------------------------------------------------------------
//
//  CGridBase::put_gridSizeY, IDXTGridSize
//
//  Overview:   Set the vertical grid size (number of cells in a column)
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CGridBase::put_gridSizeY(short newY)
{
    HRESULT hr = S_OK;

    if (newY > 0 && newY < 101)
    {
        if (m_sizeGrid.cy != newY)
        {
            SIZE szNew = m_sizeGrid;

            szNew.cy = newY;

            hr = _CreateNewGridAndIndex(szNew);

            if (FAILED(hr))
            {
                goto done;
            }

            Lock();
            m_sizeGrid.cy   = newY;
            m_fGridDirty    = true;
            Unlock();

            SetDirty();
        }
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CGridBase::put_gridSizeY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\guids.c ===
#include <objbase.h>
#include <initguid.h>

#include <ddraw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\image.h ===
//------------------------------------------------------------------------------
//
//  image.h
//
//  This file provides the declaration of the CImage class which is the 
//  class behind the Basic Image transform.
//
//  Created:    1998        EdC, RalhpL
//
//  1998/11/04 mcalkins Added Comments.
//                      Moved sample modification code out of WorkProc and into
//                      private inline functions.
//
//  2000/01/05 mcalkins If mask color alpha is zero, set to 0xFF
//                      Default mask color black instead of clear.
//                      Added support for free threaded marshaler.
//
//  2000/01/25 mcalkins Implement OnSurfacePick instead of OnGetSurfacePickOrder
//                      To ensure that we pass back the transformed input point
//                      even when nothing is hit (the input pixel is clear.)
//
//------------------------------------------------------------------------------

#ifndef __IMAGE_H_
#define __IMAGE_H_

#include "resource.h"




class ATL_NO_VTABLE CImage : 
    public CDXBaseNTo1,
    public CComCoClass<CImage, &CLSID_BasicImageEffects>,
    public CComPropertySupport<CImage>,
    public IDispatchImpl<IDXBasicImage, &IID_IDXBasicImage, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CImage>,
    public IPersistStorageImpl<CImage>,
    public ISpecifyPropertyPagesImpl<CImage>,
    public IPersistPropertyBagImpl<CImage>
{
private:

    CDXScale            m_Scale;
    CDXDBnds            m_InputBounds;

    CComPtr<IUnknown>   m_spUnkMarshaler;

    long                m_Rotation;
    BOOL                m_fMirror;
    BOOL                m_fGrayScale;
    BOOL                m_fInvert;
    BOOL                m_fXRay;
    BOOL                m_fGlow;
    BOOL                m_fMask;
    int                 m_MaskColor;

    // Helper methods.

    void OpInvertColors(DXPMSAMPLE * pBuffer, ULONG ulSize);
    void OpXRay(DXPMSAMPLE * pBuffer, ULONG ulSize);
    void OpGrayScale(DXPMSAMPLE * pBuffer, ULONG ulSize);
    void OpMask(DXPMSAMPLE * pBuffer, ULONG ulSize);
    void FlipBounds(const CDXDBnds & DoBnds, CDXDBnds & Flip);

public:

    CImage();

    DECLARE_POLY_AGGREGATABLE(CImage)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_IMAGE)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CImage)
        COM_INTERFACE_ENTRY(IDXBasicImage)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CImage>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CImage)
        PROP_ENTRY("Rotation"       , 1, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("Mirror"         , 2, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("GrayScale"      , 3, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("Opacity"        , 4, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("Invert"         , 5, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("XRay"           , 6, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("Mask"           , 7, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("MaskColor"      , 8, CLSID_BasicImageEffectsPP)
        PROP_PAGE(CLSID_BasicImageEffectsPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD /*dwFlags*/);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pfContinueProcessing);
    HRESULT DetermineBnds(CDXDBnds & Bnds);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);

    // IDXTransform methods.

    STDMETHODIMP MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                                 ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXBasicImage properties.

    STDMETHOD(get_Rotation)(/*[out, retval]*/ int *pVal);
    STDMETHOD(put_Rotation)(/*[in]*/ int newVal);
    STDMETHOD(get_Mirror)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Mirror)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_GrayScale)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_GrayScale)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Opacity)(/*[out, retval]*/ float *pVal);
    STDMETHOD(put_Opacity)(/*[in]*/ float newVal);
    STDMETHOD(get_Invert)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Invert)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_XRay)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_XRay)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Mask)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Mask)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_MaskColor)(/*[out, retval]*/ int *pVal);
    STDMETHOD(put_MaskColor)(/*[in]*/ int newVal);
};

//
// Inline method implementations.
//

////////////////////////////////////////////////////////////////////////////////
//  CImage::OpInvertColors
//
//  This method modifies an array of DXPMSAMPLEs by inverting the color portion
//  of the samples.
//
////////////////////////////////////////////////////////////////////////////////
inline void CImage::OpInvertColors(DXPMSAMPLE* pBuffer, ULONG ulSize)
{
    for (ULONG x = 0 ; x < ulSize ; x++)
    {
        // Don't do any work if there's no alpha.

        if (pBuffer[x].Alpha != 0)
        {
            DXSAMPLE s = DXUnPreMultSample(pBuffer[x]);
        
            // XOR with 1's to invert the color bits.

            s = (DWORD)s ^ 0x00FFFFFF;

            pBuffer[x] = DXPreMultSample(s);
        }
    }
} // CImage::OpInvertColors


////////////////////////////////////////////////////////////////////////////////
//  CImage::OpXRay
//
//  This method modifies an array of DXPMSAMPLEs by taking the inverse of the
//  average of the red and green components and using that as a gray scale,
//  preserving the alpha.
//
////////////////////////////////////////////////////////////////////////////////
inline void CImage::OpXRay(DXPMSAMPLE* pBuffer, ULONG ulSize)
{
    for (ULONG x = 0 ; x < ulSize ; x++)
    {
        // Don't do any work if there's no alpha.

        if (pBuffer[x].Alpha != 0)
        {
            // Get original RGB values.

            DXSAMPLE    s = DXUnPreMultSample(pBuffer[x]);

            // Determine the level of gray.

            BYTE        gray = (BYTE)(255 - ((s.Red + s.Green) / 2));

            // Create gray scale.

            s = DXSAMPLE(s.Alpha, gray, gray, gray);

            // Copy back to buffer.

            pBuffer[x] = DXPreMultSample(s);
        }
    }
} // CImage::OpXRay


////////////////////////////////////////////////////////////////////////////////
//  CImage::OpGrayScale
//
//  This method modifies an array of DXPMSAMPLEs so that colored pixels are 
//  converted to gray scale.
//
////////////////////////////////////////////////////////////////////////////////
inline void CImage::OpGrayScale(DXPMSAMPLE* pBuffer, ULONG ulSize)
{
    for (ULONG x = 0 ; x < ulSize ; x++)
    {
        // Don't do any work if there's no alpha.

        if (pBuffer[x].Alpha != 0)
        {
            DXPMSAMPLE  s = pBuffer[x];

            // This calculates the Y (luminance) portion of a YIQ (black-and-white TV)
            // color space from the RGB components.  The weights are .299, .587, and .114
            // which are approximately equal to 306/1024, 601/1024 and 117/1024.  It's faster
            // to divide by 1024, that's why this is done with weird weights.  Plus, this
            // way we can do integer math instead of using floating point.  See Foley and
            // van Dam, page 589 for a discussion of this RGB<->YIQ conversion.

            DWORD   dwSaturation = (s.Red * 306 + s.Green * 601 + s.Blue * 117) >> 10;

            s = (DWORD)s & 0xFF000000;
            s = (DWORD)s | (dwSaturation << 16) | (dwSaturation << 8) | dwSaturation;
        
            pBuffer[x] = s;
        }
    }
} //CImage::OpGrayScale


////////////////////////////////////////////////////////////////////////////////
//  CImage::OpMask
//
//  This method modifies an array of DXPMSAMPLEs so that:
//
//  1. Opaque samples become clear.
//  2. Transparent samples take on the alpha and color stored in m_MaskColor.
//  3. Translucent samples have their alpha inverted and take on the color 
//     stored in m_MaskColor.
//
////////////////////////////////////////////////////////////////////////////////
inline void CImage::OpMask(DXPMSAMPLE* pBuffer, ULONG ulSize)
{
    // PreMultiply the mask color for transparent pixels.

    DXPMSAMPLE pmsMaskColor = DXPreMultSample(m_MaskColor);

    for (ULONG x = 0 ; x < ulSize ; x++)
    {
        if (pBuffer[x].Alpha != 0)
        {
            // Non-clear (aka, partially or fully opaque) pixels.

            DXPMSAMPLE s = pBuffer[x];

            if (s.Alpha == 0xFF)
            {
                // Opaque pixels should become transparent.

                pBuffer[x] = 0;
            }
            else
            {
                // Pixels that are translucent invert alpha.

                s = ~((DWORD)s) & 0xFF000000;

                // Set color to mask color.

                s = (DWORD)s | (m_MaskColor & 0x00FFFFFF);

                // We've created a new sample so we need to pre-multiply
                // it before putting it back into the buffer.

                pBuffer[x] = DXPreMultSample(s);
            }
        }
        else
        {
            // Transparent pixels should take on the mask color.

            pBuffer[x] = pmsMaskColor;
        }
    }
} // CImage::OpMask


#endif //__IMAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\inset.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:        inset.cpp
//
// Created:         06/24/98
//
// Author:          PhilLu
//
// Discription:     This file implements the Inset transform.
//
// Revisions:
//
// 06/24/98 phillu      Initial creation.
// 07/09/98 phillu      Implement OnSetSurfacePickOrder().
// 07/22/98 phillu      Implement clipping.
// 06/02/99 a-matcal    Optimization.
// 10/24/99 a-matcal    Changed CInset class to CDXTInsetBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "inset.h"




//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::CDXTInsetBase
//
//------------------------------------------------------------------------------
CDXTInsetBase::CDXTInsetBase() :
    m_cbndsDirty(0),
    m_fOptimizationPossible(false),
    m_fOptimize(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    for (int i = 0; i < MAX_INSET_BOUNDS; i++)
    {
        m_aulSurfaceIndex[i] = 0;
    }

    // CDXBaseNTo1 members

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTInsetBase::CDXTInsetBase


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTInsetBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTInsetBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::_CalcFullBounds
//
//  Overview:   This method creates one or three sets of bounds that represent
//              the entire output surface.  
//          
//              One set of bounds is generated if the current progress is close
//              enough to 0.0 or 1.0 so that the output surface should be 
//              entirely Input A or Input B.  
//
//              Three sets of bounds are generated if the current progress is
//              somewhere in the middle.  One set of bounds represents the inset
//              area that is filled with input B.  The other two sets of bounds
//              represent the areas to the right and below the inset bounds and
//              are filled with input A.
//
//              000000011111	
//              000000011111	
//              000000011111	
//              000000011111
//              222222222222
//              222222222222
//
//              0 - inset area       (dirty bound idx 0 Input B)
//              1 - non-inset area 1 (dirty bound idx 1 Input A)
//              2 - non-inset area 2 (dirty bound idx 2 Input A)
//
//
//              Note:  All coordinates are calculated in input space coordinates
//              assuming the entire output will need to be drawn.  Bounds will
//              be clipped and transformed to output space if needed by the 
//              WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTInsetBase::_CalcFullBounds()
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    if (m_bndsCurInset.BoundsAreEmpty())
    {
        // If the current inset area is empty, paint over the entier output
        // surface with input A.

        m_cbndsDirty          = 1;
        m_abndsDirty[0]         = bndsInput;
        m_aulSurfaceIndex[0]    = 0;
    }
    else if (m_bndsCurInset == bndsInput)
    {
        // If the current inset bounds are equal to the input bounds, paint
        // over the entire output surface with input B.

        m_cbndsDirty          = 1;
        m_abndsDirty[0]         = bndsInput;
        m_aulSurfaceIndex[0]    = 1;
    }
    else
    {
        // In this case the inset is in progress so we pass three sets of 
        // bounds.  The inset area representing input B, and two bounds 
        // representing the rest of the output surface area, input A.

        RECT rcTemp;

        m_cbndsDirty = 3;

        // Inset area.

        m_abndsDirty[0]         = m_bndsCurInset;

        // Portion one of non-inset area.

        m_bndsCurInset.GetXYRect(rcTemp);

        rcTemp.left     = rcTemp.right;
        rcTemp.right    = m_sizeInput.cx;

        m_abndsDirty[1].SetXYRect(rcTemp);

        // Portion two of non-inset area.

        rcTemp.left     = 0;
        rcTemp.top      = rcTemp.bottom;
        rcTemp.bottom   = m_sizeInput.cy;

        m_abndsDirty[2].SetXYRect(rcTemp);

        m_aulSurfaceIndex[0]    = 1;
        m_aulSurfaceIndex[1]    = 0;
        m_aulSurfaceIndex[2]    = 0;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTInsetBase::_CalcFullBounds


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::_CalcOptBounds
//
//  XXXXX11YYYYY	1 - transition area part 1  (difference between old
//  XXXXX11YYYYY	2 - transition area part 2    and new inset regions)
//  XXXXX11YYYYY	X - inset area not updated
//  2222222YYYYY	Y - non-inset area not updated
//  YYYYYYYYYYYY
//  YYYYYYYYYYYY
//
//              Note:  All coordinates are calculated in input space coordinates
//              assuming the entire output will need to be drawn.  Bounds will
//              be clipped and transformed to output space if needed by the 
//              WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTInsetBase::_CalcOptBounds()
{
    if (m_bndsCurInset == m_bndsPrevInset)
    {
        // If the inset bounds are the same as the previous inset bounds, no
        // update is required.

        m_cbndsDirty = 0;
    }
    else if (m_bndsPrevInset.BoundsAreEmpty())
    {
        // If the previous inset bounds are empty (have no area) then we just
        // need to pass one set of bounds to the WorkProc to draw the whole
        // new inset area using input B.

        m_cbndsDirty          = 1;
        m_abndsDirty[0]         = m_bndsCurInset;
        m_aulSurfaceIndex[0]    = 1;
    }
    else if (m_bndsCurInset.BoundsAreEmpty())
    {
        // If the current inset bounds are empty (have no area) then we just
        // need to pass one set of bounds to the WorkProc to draw over the whole
        // old inset area using input A.

        m_cbndsDirty          = 1;
        m_abndsDirty[0]         = m_bndsPrevInset;
        m_aulSurfaceIndex[0]    = 0;
    }
    else
    {
        // At this point we know the inset has become either larger or smaller
        // and we need to pass two sets of bounds to paint over the dirty area
        // with the appropriate input.

        RECT rcTemp;

        m_cbndsDirty = 2;

        // Portion 1

        rcTemp.top      = 0;
        rcTemp.left     = min(m_bndsCurInset.Right(), m_bndsPrevInset.Right());
        rcTemp.right    = max(m_bndsCurInset.Right(), m_bndsPrevInset.Right());
        rcTemp.bottom   = min(m_bndsCurInset.Bottom(), m_bndsPrevInset.Bottom());

        m_abndsDirty[0].SetXYRect(rcTemp);

        // Portion 2

        rcTemp.left     = 0;
        rcTemp.top      = rcTemp.bottom;
        rcTemp.bottom   = max(m_bndsCurInset.Bottom(), m_bndsPrevInset.Bottom());

        m_abndsDirty[1].SetXYRect(rcTemp);

        // Inputs

        if ((m_bndsCurInset.Right() > m_bndsPrevInset.Right())
            || (m_bndsCurInset.Bottom() > m_bndsPrevInset.Bottom()))
        {
            // Inset is growing so paint with input B.
            m_aulSurfaceIndex[0] = 1;
            m_aulSurfaceIndex[1] = 1;
        } 
        else
        {
            // Inset is shrinking so paint with input A.
            m_aulSurfaceIndex[0] = 0;
            m_aulSurfaceIndex[1] = 0;
        }
    }

    return S_OK;
}
//  CDXTInsetBase::_CalcOptBounds


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTInsetBase::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsInput.GetXYSize(m_sizeInput);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTInsetBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTInsetBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                     ULONG & ulInToTest, 
                                     ULONG aInIndex[], BYTE aWeight[])
{
    long pickX = OutPoint.Left();
    long pickY = OutPoint.Top();
    long insetHeight = (long)(GetEffectProgress() * m_sizeInput.cy + 0.5);
    long insetWidth = (long)(GetEffectProgress() * m_sizeInput.cx + 0.5);

    if (pickX < insetWidth && pickY < insetHeight)
        aInIndex[0] = 1;
    else
        aInIndex[0] = 0;

    ulInToTest = 1;
    aWeight[0] = 255;
}
//  CDXTInsetBase::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTInsetBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    RECT    rcInset;

    // Calculate inset bounds.

    rcInset.left    = 0;
    rcInset.top     = 0;

    if (0.0F == GetEffectProgress())
    {
        rcInset.right   = 0;
        rcInset.bottom  = 0;
    }
    else if (1.0F == GetEffectProgress())
    {
        rcInset.right   = m_sizeInput.cx;
        rcInset.bottom  = m_sizeInput.cy;
    }
    else
    {
        rcInset.right   = (LONG)((m_Progress * (float)m_sizeInput.cx) + 0.5F);
        rcInset.bottom  = (LONG)((m_Progress * (float)m_sizeInput.cy) + 0.5F);
    }

    m_bndsCurInset.SetXYRect(rcInset);

    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        hr = _CalcFullBounds();
    }
    else // Create optimized dirty bounds.
    {
        hr = _CalcOptBounds();

        if (FAILED(hr))
        {
            goto done;
        }
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTInsetBase::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::WorkProc, CDXBaseNTo1 
//
//------------------------------------------------------------------------------
HRESULT 
CDXTInsetBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    DWORD   dwFlags         = 0;
    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    for (ULONG i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            hr = DXBitBlt(OutputSurface(), bndsDest,
                          InputSurface(m_aulSurfaceIndex[i]), bndsSrc,
                          dwFlags, INFINITE);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTInsetBase::WorkProc, CDXBaseNTo1 


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTInsetBase::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_bndsPrevInset = m_bndsCurInset;

    // Calling IsOuputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTInsetBase::OnFreeInstData, CDXBaseNTo1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\inset.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:        inset.h
//
// Created:         06/24/98
//
// Author:          PhilLu
//
// Discription:     This file declares CInset (Inset Transform)
//
// Revisions:
//
// 06/02/99 a-matcal    Optimization.
// 10/24/99 a-matcal    Changed CInset class to CDXTInsetBase and created two
//                      new classes CDXTInset and CDXTInsetOpt to represent  
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRINSET_H_
#define __CRINSET_H_

#include "resource.h"

#define MAX_INSET_BOUNDS 3




class ATL_NO_VTABLE CDXTInsetBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrInset, &IID_ICrInset, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTInsetBase>,
    public IObjectSafetyImpl2<CDXTInsetBase>
{
private:

    SIZE        m_sizeInput;
    ULONG       m_cbndsDirty;

    ULONG       m_aulSurfaceIndex[MAX_INSET_BOUNDS];
    CDXDBnds    m_abndsDirty[MAX_INSET_BOUNDS];
    
    CDXDBnds    m_bndsCurInset;
    CDXDBnds    m_bndsPrevInset;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    HRESULT _CalcFullBounds();
    HRESULT _CalcOptBounds();

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

public:

    CDXTInsetBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTInsetBase)
        COM_INTERFACE_ENTRY(ICrInset)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTInsetBase>)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTInsetBase)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, 
                                  ULONG & ulInToTest, ULONG aInIndex[], 
                                  BYTE aWeight[]);

    // IDXEffect

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTInset :
    public CDXTInsetBase,
    public CComCoClass<CDXTInset, &CLSID_CrInset>,
    public IPersistStorageImpl<CDXTInset>,
    public IPersistPropertyBagImpl<CDXTInset>
{
public:

    CDXTInset()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTINSET)
    DECLARE_POLY_AGGREGATABLE(CDXTInset)

    BEGIN_COM_MAP(CDXTInset)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTInsetBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTInsetOpt :
    public CDXTInsetBase,
    public CComCoClass<CDXTInsetOpt, &CLSID_DXTInset>,
    public IPersistStorageImpl<CDXTInsetOpt>,
    public IPersistPropertyBagImpl<CDXTInsetOpt>
{
public:

    CDXTInsetOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTINSETOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTInsetOpt)

    BEGIN_COM_MAP(CDXTInsetOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTInsetBase)
    END_COM_MAP()
};


#endif // __CRINSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\image.cpp ===
//------------------------------------------------------------------------------
//
//  image.cpp
//
//  This file provides the implementation of the CImage class which is the 
//  class behind the Basic Image transform.
//
//  Created:    1998        EdC, RalhpL
//
//  1998/11/04 mcalkins Added Comments.
//                      Moved sample modification code out of WorkProc and into
//                      private inline functions.
//
//  2000/01/05 mcalkins If mask color alpha is zero, set to 0xFF
//                      Default mask color black instead of clear.
//                      Added support for free threaded marshaler.
//
//  2000/01/25 mcalkins Implement OnSurfacePick instead of OnGetSurfacePickOrder
//                      To ensure that we pass back the transformed input point
//                      even when nothing is hit (the input pixel is clear.)
//
//------------------------------------------------------------------------------
      
#include "stdafx.h"
#include "DXTMsft.h"
#include "Image.h"




//+-----------------------------------------------------------------------------
//
//  Method: CImage::CImage
//
//------------------------------------------------------------------------------
CImage::CImage() :
    m_Rotation(0),
    m_fMirror(FALSE),
    m_fGrayScale(FALSE),
    m_fInvert(FALSE),
    m_fXRay(FALSE),
    m_fGlow(FALSE),
    m_fMask(FALSE),
    m_MaskColor(0xFF000000)
{
}
//  Method: CImage::CImage


//+-----------------------------------------------------------------------------
//
//  Method: CImage::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CImage::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  Method: CImage::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CImage::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CImage::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                      CDXDVec & InVec)
{
    HRESULT     hr          = S_OK;
    CDXDBnds    bndsInPoint;

    ulInputIndex = 0;

    if (GetNumInputs() == 0 || !InputSurface())
    {
        hr = E_FAIL;

        goto done;
    }

    hr = MapBoundsOut2In(0, &OutPoint, 0, &bndsInPoint);

    if (FAILED(hr))
    {
        goto done;
    }

    // Reset to S_OK just in case MapBoundsOut2In changed it.

    hr = S_OK;

    bndsInPoint.GetMinVector(InVec);

    if (!m_Scale.GetScaleAlphaValue())
    {
        hr = S_FALSE;
    }
    else
    {
        DXSAMPLE                sample;
        CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

        hr = InputSurface()->LockSurface(NULL, INFINITE, DXLOCKF_READ,
                                         __uuidof(IDXARGBReadPtr),
                                         (void **)&spDXARGBReadPtr,
                                         NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        // Reset to S_OK just in case LockSurface changed it.

        hr = S_OK;

        spDXARGBReadPtr->MoveToXY(InVec.u.D[DXB_X], InVec.u.D[DXB_Y]);

        spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

        if (!sample.Alpha)
        {
            // Sample is clear, we're not hit.

            hr = S_FALSE;
        }
        else if (m_Scale.ScaleType() == DXRUNTYPE_TRANS)
        {
            // Scale the sample if they're using scaling and see if the scaled
            // sample is clear.

            if (!(m_Scale.ScaleSample(sample) & 0xFF000000))
            {
                hr = S_FALSE;
            }
        }
    }

done:

    return hr;
}
//  CImage::OnSurfacePick, CDXBaseNTo1


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_Rotation
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_Rotation(int newVal)
{
    DXAUTO_OBJ_LOCK;

    if (newVal < 0 || newVal > 3)
        return E_INVALIDARG;

    if (m_Rotation != newVal)
    {
        m_Rotation = newVal;
        SetDirty();
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_Rotation
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_Rotation(int *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_Rotation;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_Mirror
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_Mirror(BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    m_fMirror = newVal;
    SetDirty();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_Mirror
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_Mirror(BOOL *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_fMirror;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_XRay
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_XRay(BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    m_fXRay = newVal;
    SetDirty();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_XRay
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_XRay(BOOL *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_fXRay;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_Invert
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_Invert(BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    m_fInvert = newVal;
    SetDirty();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_Invert
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_Invert(BOOL *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_fInvert;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_GrayScale
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_GrayScale(BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    m_fGrayScale = newVal;
    SetDirty();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_GrayScale
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_GrayScale(BOOL *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_fGrayScale;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//`CImage::put_Mask
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_Mask(BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    m_fMask = newVal;
    SetDirty();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_Mask
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_Mask(BOOL *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_fMask;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_MaskColor
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_MaskColor(int newVal)
{
    DXAUTO_OBJ_LOCK;

    // If no alpha value was provided (clear) assume opaque.

    if (!(newVal & 0xFF000000))
    {
        newVal |= 0xFF000000;
    }

    if (m_MaskColor != newVal)
    {
        m_MaskColor = newVal;
        SetDirty();
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_MaskColor
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_MaskColor(int *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_MaskColor;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_Opacity
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_Opacity(float newVal)
{
    DXAUTO_OBJ_LOCK;

    SetDirty();
    return m_Scale.SetScale(newVal);
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_Opacity
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_Opacity(float *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)) ) 
        return E_POINTER;
    *pVal = m_Scale.GetScale();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::OnSetup
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CImage::OnSetup(DWORD /*dwFlags*/)
{
    return InputSurface()->GetBounds(&m_InputBounds);
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::DetermineBnds
//
//  This function modifies the Bnds parameter to correctly indicate the
//  dimensions of the output bounds.  The placement of the bounds may
//  not necessarily match the placement of the actual output bounds.
//
//  If the image will be rotated 90 or 270 degrees (m_Rotation = 1 or 3)
//  the function will switch the x and y bounds.
// 
////////////////////////////////////////////////////////////////////////////////
HRESULT CImage::DetermineBnds(CDXDBnds & Bnds)
{
    if (m_Rotation & 1)
    {
        long tMin, tMax;
        tMin = Bnds[DXB_X].Min;
        tMax = Bnds[DXB_X].Max;
        Bnds[DXB_X].Min = Bnds[DXB_Y].Min;
        Bnds[DXB_X].Max = Bnds[DXB_Y].Max;
        Bnds[DXB_Y].Min = tMin;
        Bnds[DXB_Y].Max = tMax;
    }

    return S_OK;
} // CImage::DetermineBnds


////////////////////////////////////////////////////////////////////////////////
//  FlipX (inline local function, not a class method)
//
//  If the Width parameter represents the width of the entire image, this 
//  fuction will mirror the x bounds of the Flip parameter.
// 
////////////////////////////////////////////////////////////////////////////////
void inline FlipX(CDXDBnds & Flip, ULONG Width)
{
    ULONG FlipWidth = Flip.Width();

    Flip[DXB_X].Min = Width - Flip[DXB_X].Max;
    Flip[DXB_X].Max = Flip[DXB_X].Min + FlipWidth;
}


////////////////////////////////////////////////////////////////////////////////
//  FlipY (inline local function, not a class method)
//
//  If the Height parameter represents the width of the entire image, this
//  fuction will mirror the y bounds of the Flip parameter.
// 
////////////////////////////////////////////////////////////////////////////////
void inline FlipY(CDXDBnds & Flip, ULONG Height)
{
    ULONG FlipHeight = Flip.Height();

    Flip[DXB_Y].Min = Height - Flip[DXB_Y].Max;
    Flip[DXB_Y].Max = Flip[DXB_Y].Min + FlipHeight;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::FlipBounds
//
//  This function takes DoBnds, which are in output coordinates and modifies
//  them so that they are in input coordinates based on whether the input
//  is being rotated, mirrored, or both.
//
//  Consequently, this function is the basis for MapBoundsOut2In and is used
//  by the WorkProc to calculate the input pixels it needs to work with.
//
//  The benefit to not just having this code in MapBoundsOut2In is that it
//  will improve the speed of WorkProc to be able to call this code directly
//  without the overhead of calling MapBoundsOut2In.  (???)
//  
////////////////////////////////////////////////////////////////////////////////
void CImage::FlipBounds(const CDXDBnds & DoBnds, CDXDBnds & Flip)
{
    Flip            = DoBnds;
    ULONG Width     = m_InputBounds.Width();
    ULONG Height    = m_InputBounds.Height();

    if (m_Rotation & 1)
    {
        long tMin, tMax;
        tMin = Flip[DXB_X].Min;
        tMax = Flip[DXB_X].Max;
        Flip[DXB_X].Min = Flip[DXB_Y].Min;
        Flip[DXB_X].Max = Flip[DXB_Y].Max;
        Flip[DXB_Y].Min = tMin;
        Flip[DXB_Y].Max = tMax;
    }

    switch (m_Rotation)
    {
    case 0:
        if (m_fMirror) FlipX(Flip, Width);
        break;
    case 1:
        if (!m_fMirror) FlipY(Flip, Height);
        break;
    case 2:
        FlipY(Flip, Height);
        if (!m_fMirror) FlipX(Flip, Width);
        break;
    case 3:
        FlipX(Flip, Width);
        if (m_fMirror) FlipY(Flip, Height);
        break;
    }
} // CImage::FlipBounds


////////////////////////////////////////////////////////////////////////////////
//  CImage::MapBoundsOut2In
//
//  This method translates output coordinates to input coordinates using
//  the FlipBounds method implimented directly above.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS *pOutBounds, 
                                     ULONG ulInIndex, DXBNDS *pInBounds)
{
    HRESULT hr = CDXBaseNTo1::MapBoundsOut2In(ulOutIndex, pOutBounds, 
                                              ulInIndex, pInBounds);

    if (SUCCEEDED(hr) && HaveInput())
    {
        FlipBounds(*(CDXDBnds *)pOutBounds, *(CDXDBnds *)pInBounds);
    }

    return hr;
} // CImage::MapBoundsOut2In



////////////////////////////////////////////////////////////////////////////////
//  CImage::WorkProc
//
//  This method performs the modifications on the inputs.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT 
CImage::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing)
{
    HRESULT hr = S_OK;

    // The FlipSrc bounds declared and initialized below will be used as the
    // locking bounds for the input surface.  The FlipBounds method translates
    // output bounds to input bounds.

    CDXDBnds FlipSrc(false);
    FlipBounds(WI.DoBnds, FlipSrc);

    // Save height and width of the DoBnds for later use.

    const ULONG DoWidth     = WI.DoBnds.Width();
    const ULONG DoHeight    = WI.DoBnds.Height();

    // REVIEW:  Why fDoOver instead of DoOver()?

    BOOL fDoOver = m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT;

    // Get output pointer.

    CComPtr<IDXARGBReadWritePtr> pDest;
    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, (void**)&pDest, NULL);

    if( FAILED(hr) ) 
        return hr;

    // Opacity Check:  If the user has set opacity to 0 (invisible), then
    //                 leave this function early:
    //
    //  If blending with output:
    //      Do nothing.  Return.
    //  If not blending:
    //      Fill output with black, clear pixels.  Return.

    if (m_Scale.ScaleType() == DXRUNTYPE_CLEAR)
    {
        if (!fDoOver)
        {
            DXPMSAMPLE Color;
            Color = 0;
            pDest->FillRect(NULL, Color, FALSE);
        }

        return hr;
    }    

    // Get input pointer.

    CComPtr<IDXARGBReadPtr> pSrc;
    hr = InputSurface()->LockSurface(&FlipSrc, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);

    if (FAILED(hr) ) 
        return hr;

    // Declare and initialize the pointer to the temporary sample buffer
    // this function will make modifications to.

    DXPMSAMPLE* pBuffer = NULL;

    // We can modify samples the output surface directly if the output
    // surface format is DXPF_PMARGB32 and we aren't blending the results
    // of this transform with the original output. The local variable 
    // fDirectCopy will be set to TRUE if this is the case.

    DXNATIVETYPEINFO    NTI;
    BOOL                fDirectCopy = (OutputSampleFormat() == DXPF_PMARGB32 
                                       && (!DoOver()));

    // If it's possible to directly modify the samples of the output
    // surface, get needed info about the surface and the pointer to the
    // first sample.  If for some reason a pointer isn't available, we 
    // can't do direct copy.

    if (fDirectCopy)
    {
        pDest->GetNativeType(&NTI);
        if (NTI.pFirstByte)
        {
            pBuffer = (DXPMSAMPLE*)NTI.pFirstByte;
        }
        else
        {
            fDirectCopy = FALSE;
        }
    }

    // If we're not directly modifying the samples of the output surface, 
    // allocate memory for the temporary sample buffer.

    if (pBuffer == NULL)
    {
        pBuffer = DXPMSAMPLE_Alloca(DoWidth);
    }

    // If we're blending with the original output surface and the output
    // surface sample format isn't PMARGB32, we'll need a scratch buffer
    // for some of the blit functions.

    DXPMSAMPLE *pOverScratch = NULL;
    
    if (DoOver() && OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOverScratch = DXPMSAMPLE_Alloca(DoWidth);
    }

    //  Set up the dither structure

    DXDITHERDESC dxdd;

    if (DoDither())
    {
        dxdd.x = WI.OutputBnds.Left();
        dxdd.y = WI.OutputBnds.Top();
        dxdd.pSamples = pBuffer;
        dxdd.cSamples = DoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // Structure describing which input samples to retrieve.

    DXPACKEDRECTDESC    prd;

    // Retrieve the samples with their pre-multiplied values.
    // Don't separate the rows.
    // REVIEW:  This transform could be optimized by setting the
    //          prd.bPremult value to FALSE and modifiying the
    //          Op functions to use non-premultiplied samples.

    prd.bPremult    = TRUE;
    prd.lRowPadding = 0;

    // The following code initializes the following local variables:
    //
    // RECT prd.rect
    // This rectangle is relative to the input surface and represents a single
    // row or column of pixels.  This group of pixels will become the first
    // output row.  A column will be used if the rotation requested is 90 or
    // 270 degrees.  By using this input column as an output row, the rotation
    // is implemented.
    //
    // BOOL fReverse
    // The other part of implementing rotation and flip is making sure the
    // order of the pixels is reversed if needed, which is why the fReverse
    // flag is set.
    //
    // long XInc, YInc
    // These variables represent how the rectangle should be translated to
    // retrieve the next output row of input samples.

    long    YInc, XInc;
    BOOL    fReverse;

    switch (m_Rotation)
    {
    case 0:
        fReverse = m_fMirror;
        prd.rect.top = 0; prd.rect.bottom = 1;
        prd.rect.left = 0; prd.rect.right = DoWidth;
        YInc = 1;
        XInc = 0;
        break;
    case 1:
        fReverse = m_fMirror ? FALSE : TRUE;
        prd.rect.top = 0; prd.rect.bottom = DoWidth;
        prd.rect.left = 0; prd.rect.right = 1;
        YInc = 0;
        XInc = 1;
        break;
    case 2:
        fReverse = m_fMirror ? FALSE : TRUE;
        prd.rect.top = DoHeight - 1; prd.rect.bottom = DoHeight;
        prd.rect.left = 0; prd.rect.right = DoWidth;
        XInc = 0;
        YInc = -1;
        break;
    case 3:
        fReverse = m_fMirror;
        prd.rect.top = 0; prd.rect.bottom = DoWidth;
        prd.rect.left = DoHeight - 1; prd.rect.right = DoHeight;
        XInc = -1;
        YInc = 0;
        break;
    }

    //
    // This is the row loop.  Each iteration of this loop will retrieve
    // a row of output samples, perform the requested modifications, and
    // write the samples to the output.
    //

    for (ULONG y = 0 ; y < DoHeight ; y++)
    {
        // Retrieve the output row into pBuffer.

        prd.pSamples = pBuffer;
        pSrc->UnpackRect(&prd);

        // Translate the input rect for the next iteration.

        prd.rect.left   += XInc;
        prd.rect.right  += XInc;
        prd.rect.top    += YInc;
        prd.rect.bottom += YInc;

        // fReverse is TRUE if the row of samples needs to be reversed to
        // properly mirror or rotate the image.

        if (fReverse)
        {
            DXPMSAMPLE * pA = pBuffer;
            DXPMSAMPLE * pB = pBuffer + DoWidth - 1;
            while (pB > pA)
            {
                DXPMSAMPLE Temp;
                Temp = *pA;
                *pA++ = *pB;
                *pB-- = Temp;
            }
        }

        //
        // Insert more effects here.
        //
        // TODO:    Switch to unpacking as DXSAMPLES so I can get rid of all
        //          these unpremultiplying and premultiplying calls.
        //

        // Invert Colors
        
        if (m_fInvert)
        {
            OpInvertColors(pBuffer, DoWidth);
        }

        // X-Ray

        if (m_fXRay)
        {
            OpXRay(pBuffer, DoWidth);
        }

        // Gray Scale

        if (m_fGrayScale)
        {
            OpGrayScale(pBuffer, DoWidth);
        }

        // Mask

        if (m_fMask)
        {
            OpMask(pBuffer, DoWidth);
        }

        // Opacity
        // Only modify the samples of the user has not set opacity 0 or 1.

        if (m_Scale.ScaleType() == DXRUNTYPE_TRANS)
        {
            m_Scale.ScalePremultArray(pBuffer, DoWidth);
        }

        if (fDirectCopy)
        {
            // If we've been modifying the output pixels directly, just
            // reset the buffer pointer to the beginning of the next row.

            pBuffer = (DXPMSAMPLE *)(((BYTE *)pBuffer) + NTI.lPitch);
        }
        else
        {
            // Blend or copy the modified samples to the output surface.

            if (DoDither())
            {
                DXDitherArray(&dxdd);
                dxdd.y++;
            }

            pDest->MoveToRow(y);

            if (fDoOver)
            {
                if (m_Scale.ScaleType() == DXRUNTYPE_TRANS)
                {
                    DXOverArrayMMX(pDest->UnpackPremult(pOverScratch, DoWidth, FALSE), pBuffer, DoWidth);
                    pDest->PackPremultAndMove(pOverScratch, DoWidth);
                }
                else
                {
                    //  NOTE:  If any other effect can change alpha, do test here.
                    //  The BltFlags which will be 0 if the
                    //  source is opqaue.

                    if (m_dwBltFlags & DXBOF_DO_OVER)
                    {
                        pDest->OverArrayAndMove(pOverScratch, pBuffer, DoWidth);
                    }
                    else
                    {
                        pDest->PackPremultAndMove(pBuffer, DoWidth);
                    }
                }
            }
            else
            {
                pDest->PackPremultAndMove(pBuffer, DoWidth);
            }
        }
    }

    return hr;
} // CImage::WorkProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\iris.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:		iris.cpp
//
// Created:             06/17/98
//
// Author:              PhilLu
//
// Discription:		This file implements the CrIris transformation.
//
// History:
//
// 06/23/98 phillu      Added PLUS iris style.
// 06/24/98 phillu      Removed copyright related methods.
// 06/29/98 phillu      Rename irisType to irisStyle.
// 07/02/98 phillu      Return E_INVALIDARG rather than an error string; check 
//                      for E_POINTER.
// 07/09/98 phillu      Implement OnSetSurfacePickOrder().
// 07/22/98 phillu      Implement clipping.
// 05/19/99 a-matcal    Check for out of memory in get_ functions allocating
//                      BSTRs.
// 05/20/99 a-matcal    Code scrub.
// 09/25/99 a-matcal    Implemented ICrIris2 interface.
// 10/22/99 a-matcal    Changed CIris class to CDXTIrisBase base class.
// 2000/01/16 mcalkins  Added rectangle option.
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "iris.h"

// Constants for drawing a star of unit radius.

const double STAR_VPOS1         = -1.0;
const double STAR_VPOS2	        = -0.309017;
const double STAR_VPOS3	        = 0.118034;
const double STAR_VPOS4	        = 0.381966;
const double STAR_VPOS5	        = 0.951057;

const double STAR_SLOPE1        = 0.324920;
const double STAR_INTERCEPT1    = 0.324920;
const double STAR_SLOPE2        = -1.376382;
const double STAR_INTERCEPT2    = 0.525731;

const int    MAXBOUNDS          = 10;




//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase static variables initialization
//
//------------------------------------------------------------------------------

const WCHAR * CDXTIrisBase::s_astrStyle[] = {
    L"diamond",
    L"circle",
    L"cross",
    L"plus",
    L"square",
    L"star",
    L"rectangle"
};

const WCHAR * CDXTIrisBase::s_astrMotion[] = {
    L"in",
    L"out"
};


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::CDXTIrisBase
//
//------------------------------------------------------------------------------
CDXTIrisBase::CDXTIrisBase() :
    m_eStyle(STYLE_PLUS),
    m_eMotion(MOTION_OUT),
    m_fOptimize(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTIrisBase::CDXTIrisBase


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTIrisBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTIrisBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTIrisBase::OnSetup(DWORD dwFlags)
{
    HRESULT hr;

    CDXDBnds InBounds(InputSurface(0), hr);

    if (SUCCEEDED(hr))
    {
        InBounds.GetXYSize(m_sizeInput);
    }

    return hr;
}
//  CDXTIrisBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTIrisBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                    ULONG & ulInToTest, ULONG aInIndex[], 
                                    BYTE aWeight[])
{
    long    XBounds[10];
    long    pickX           = OutPoint.Left();
    long    pickY           = OutPoint.Top();

    aInIndex[0] = 0;

    if((pickX >= 0) && (pickX < m_sizeInput.cx) && (pickY >= 0) 
        && (pickY < m_sizeInput.cy))
    {
        _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, m_Progress,
                           pickY, XBounds);
    
        for(long i=0; XBounds[i] < pickX; i++)
        {
            aInIndex[0] = 1 - aInIndex[0];
        }
    }

    ulInToTest = 1;
    aWeight[0] = 255;
}
//  CDXTIrisBase::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::get_irisStyle, ICrIris
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTIrisBase::get_irisStyle(BSTR * pbstrStyle)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrStyle)
    {
        return E_POINTER;
    }

    if (*pbstrStyle != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrStyle = SysAllocString(s_astrStyle[m_eStyle]);

    if (NULL == *pbstrStyle)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTIrisBase::get_irisStyle, ICrIris


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::put_irisStyle, ICrIris
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTIrisBase::put_irisStyle(BSTR bstrStyle)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrStyle)
    {
        return E_POINTER;
    }

    for ( ; i < (int)STYLE_MAX ; i++)
    {
        if (!_wcsicmp(bstrStyle, s_astrStyle[i]))
        {
            break;
        }
    }

    if ((int)STYLE_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eStyle != i)
    {
        m_eStyle = (STYLE)i;

        SetDirty();
    }

    return S_OK;
}
//  CDXTIrisBase::put_irisStyle, ICrIris


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::get_Motion, ICrIris2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTIrisBase::get_Motion(BSTR * pbstrMotion)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrMotion)
    {
        return E_POINTER;
    }

    if (*pbstrMotion != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrMotion = SysAllocString(s_astrMotion[m_eMotion]);

    if (NULL == *pbstrMotion)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTIrisBase::get_Motion, ICrIris2


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::put_Motion, ICrIris2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTIrisBase::put_Motion(BSTR bstrMotion)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrMotion)
    {
        return E_POINTER;
    }

    for ( ; i < (int)MOTION_MAX ; i++)
    {
        if (!_wcsicmp(bstrMotion, s_astrMotion[i]))
        {
            break;
        }
    }

    if ((int)MOTION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eMotion != i)
    {
        m_eMotion = (MOTION)i;
        
        SetDirty();
    }

    return S_OK;
}
//  CDXTIrisBase::put_Motion, ICrIris2


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::_ScanlineIntervals
//
// A helper method that calculates the transition boundaries between the
// two image regions on a scanline. Based on the type of iris, the scanline
// consists of a series of alternating A and B image sections. The upper X
// bound of each section is calculated and saved in array XBounds. The number
// of useful entries in XBounds is variable. The end of array is determined
// when one entry equals to the scanline (image) width. It is assumed that
// XBounds[0] is the upper bound of the first A section. So if the scanline
// starts with a B section, XBounds[0] will be 0.
//
// Example 1: scanline length = 16, first section is from A image
//
//    AAAABBBBBAAABBAA      XBounds should contain {4, 9, 12, 14, 16}.
//
// Example 2: scanline length = 16, first section is from B image
//
//    BBBAAAAAABBBBBBB      XBounds should contain {0, 3, 9, 16}.
//
//
// Note: It is possible that some section has length 0 (i.e. two adjacent
//       bounds equal). {3, 9, 9, 16} is equivalent to {3, 16}.
//
// Parameters:
//
// width, height: width and height of both images.
// progress: progress value from 0.0 to 1.0
// YScanline: Y cooridnate (height) of the current scanline
// XBounds: array to hold the computed X bounds on return.
//
//
// 06/17/98 phillu      Created.
//
//------------------------------------------------------------------------------
void 
CDXTIrisBase::_ScanlineIntervals(long width, long height, float progress, 
                                 long YScanline, long *XBounds)
{
    long    CenterX         = 0;
    long    CenterY         = 0;
    long    range           = 0;
    long    deltaY          = 0;
    double  scale           = 0.0;
    float   flIrisProgress  = progress;

    // flIrisProgress represents the progress of the iris.  At 0.0 the iris
    // is an invisible dot in the center of the image, at 1.0 the iris is
    // large enough to cover the entire image.  If we're in "out" motion mode,
    // iris progress goes from 0.0 to 1.0 (matching the transform progress),
    // if we're in "in" motion mode, it goes from 1.0 to 0.0.
    
    if (MOTION_IN == m_eMotion)
    {
        flIrisProgress = 1.0F - flIrisProgress;
    }

    // Center of image
    CenterX = width/2;
    CenterY = height/2;

    switch(m_eStyle)
    {
    case STYLE_DIAMOND:
        range = (long)((CenterX + CenterY) * flIrisProgress + 0.5);
        deltaY = labs(YScanline - CenterY);

        if(deltaY > range)
        {
            XBounds[0] = width; // image A only
        }
        else
        {
            XBounds[0] = max(CenterX - range + deltaY, 0);
            XBounds[1] = min(CenterX + range - deltaY, width);
            XBounds[2] = width;
        }

        break;
    
    case STYLE_SQUARE:

        range = (long)((max(CenterX, CenterY) * flIrisProgress) + 0.5F);

        deltaY = labs(YScanline - CenterY);

        if (deltaY > range)
        {
            XBounds[0] = width;
        }
        else
        {
            XBounds[0] = max(CenterX - range, 0);
            XBounds[1] = min(CenterX + range, width);
            XBounds[2] = width;
        }

        break;

    case STYLE_RECTANGLE:

        range = (long)(((float)CenterY * flIrisProgress) + 0.5F);

        deltaY = labs(YScanline - CenterY);

        if (deltaY > range)
        {
            XBounds[0] = width;
        }
        else
        {
            long lXRange = (long)(((float)CenterX * flIrisProgress) + 0.5F);

            XBounds[0] = max(CenterX - lXRange, 0);
            XBounds[1] = min(CenterX + lXRange, width);
            XBounds[2] = width;
        }

        break;

    case STYLE_CIRCLE:
        range = (long)(sqrt((double)(CenterX*CenterX+CenterY*CenterY))*flIrisProgress + 0.5);
        deltaY = labs(YScanline - CenterY);

        if(deltaY > range)
        {
            XBounds[0] = width;
        }
        else
        {
            long temp = (long)(sqrt((double)(range*range-deltaY*deltaY)) + 0.5);
            XBounds[0] = max(CenterX - temp, 0);
            XBounds[1] = min(CenterX + temp, width);
            XBounds[2] = width;
        }

        break;

    case STYLE_CROSS:
        range = (long)(max(CenterX,CenterY)*flIrisProgress + 0.5);
        deltaY = labs(YScanline - CenterY);

        if(deltaY > CenterX - range)
        {
            XBounds[0] = 0;
            XBounds[3] = width;
        }
        else
        {
            XBounds[0] = max(CenterX - range - deltaY, 0);
            XBounds[3] = min(CenterX + range + deltaY, width);
            XBounds[4] = width;
        }

        if(deltaY > range)
        {
            XBounds[1] = max(CenterX + range - deltaY, 0);
            XBounds[2] = min(CenterX - range + deltaY, width);
        }
        else
        {
            XBounds[1] = XBounds[2] = XBounds[0];
        }

        break;

    case STYLE_PLUS:
        range = (long)(max(CenterX,CenterY)*flIrisProgress + 0.5);
        deltaY = labs(YScanline - CenterY);
        
        if (deltaY >= range)
        {
            XBounds[0] = max(CenterX - range, 0);
            XBounds[1] = min(CenterX + range, width);
            XBounds[2] = width;
        }
        else
        {
            XBounds[0] = 0;
            XBounds[1] = width;
        }
        break;

    case STYLE_STAR:
        scale = max(width, height)*2*flIrisProgress;
        deltaY = YScanline - CenterY;

        if(deltaY < (long)(STAR_VPOS1*scale) || deltaY >= (long)(STAR_VPOS5*scale))
        {
            XBounds[0] = width;
        }
        else if(deltaY < (long)(STAR_VPOS2*scale))
        {
            long temp = (long)(STAR_SLOPE1*deltaY+STAR_INTERCEPT1*scale);
            temp = max(temp, 0);
            XBounds[0] = max(CenterX - temp, 0);
            XBounds[1] = min(CenterX + temp, width);
            XBounds[2] = width;
        }
        else if(deltaY < (long)(STAR_VPOS3*scale))
        {
            long temp = (long)(STAR_SLOPE2*deltaY+STAR_INTERCEPT2*scale);
            temp = max(temp, 0);
            XBounds[0] = max(CenterX - temp, 0);
            XBounds[1] = min(CenterX + temp, width);
            XBounds[2] = width;
        }
        else if(deltaY < (long)(STAR_VPOS4*scale))
        {
            long temp = (long)(STAR_SLOPE1*deltaY+STAR_INTERCEPT1*scale);
            temp = max(temp, 0);
            XBounds[0] = max(CenterX - temp, 0);
            XBounds[1] = min(CenterX + temp, width);
            XBounds[2] = width;
        }
        else
        {
            long temp = (long)(STAR_SLOPE1*deltaY+STAR_INTERCEPT1*scale);
            temp = max(temp, 0);
            XBounds[0] = max(CenterX - temp, 0);
            XBounds[3] = min(CenterX + temp, width);
            temp = (long)(STAR_SLOPE2*deltaY+STAR_INTERCEPT2*scale);
            temp = min(temp, 0);
            XBounds[1] = max(CenterX + temp, 0);
            XBounds[2] = min(CenterX - temp, width);
            XBounds[4] = width;
        }

        break;

    default:
        _ASSERT(0);
        break;
    }
}


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::_ClipBounds
//
//  Description:
//  Initially the X-bounds are specified relative to the entire image. After clipping,
//  the bounds should be transformed to be relative to the clipping region.
//
//  Parameters;
//  offset, width: offset and width of the clipping region (along X)
//  XBounds: array of X-bounds
//
//  Created by: PhilLu    07/21/98
//
//------------------------------------------------------------------------------
void 
CDXTIrisBase::_ClipBounds(long offset, long width, long *XBounds)
{
    int i;

    for(i=0; XBounds[i] < offset+width; i++)
    {
        if (XBounds[i] < offset)
            XBounds[i] = 0;
        else
            XBounds[i] -= offset;
    }

    XBounds[i] = width;
}
//  CDXTIrisBase::_ClipBounds



//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::WorkProc, CDXBaseNTo1
//
//  Overview:   This function is used to calculate the result based on the 
//              specified bounds and the current effect progress.
//
//  Created by: PhilLu    06/17/98
//
//------------------------------------------------------------------------------
HRESULT 
CDXTIrisBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    long    lDoWidth        = WI.DoBnds.Width();
    long    lDoHeight       = WI.DoBnds.Height();
    long    lOutY           = 0;

    long    alXBounds[MAXBOUNDS];   // To hold the X bounds of A/B 
                                    // image sections on a scanline.

    DXPMSAMPLE * pRowBuff = NULL;
    DXPMSAMPLE * pOutBuff = NULL;

    DXDITHERDESC dxdd;

    IDXSurface *                    pDXSurfOuter    = NULL;
    IDXSurface *                    pDXSurfInner    = NULL;

    CComPtr<IDXARGBReadPtr>         cpOuterInput;
    CComPtr<IDXARGBReadPtr>         cpInnerInput;
    CComPtr<IDXARGBReadWritePtr>    cpOut;

    if (MOTION_IN == m_eMotion)
    {
        pDXSurfOuter = InputSurface(1);
        pDXSurfInner = InputSurface(0);
    }
    else
    {
        pDXSurfOuter = InputSurface(0);
        pDXSurfInner = InputSurface(1);
    }

    // Get a read pointer to the outer surface.

    hr = pDXSurfOuter->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                   IID_IDXARGBReadPtr, 
                                   (void **)&cpOuterInput, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get a read pointer to the inner surface.

    hr = pDXSurfInner->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                   IID_IDXARGBReadPtr, 
                                   (void **)&cpInnerInput, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get a read/write pointer to the output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, 
                                      IID_IDXARGBReadWritePtr, 
                                      (void **)&cpOut, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Allocate a buffer.

    pRowBuff = DXPMSAMPLE_Alloca(lDoWidth);

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(lDoWidth);
    }

    // Set up the dither structure.

    if (DoDither())
    {
        dxdd.x                  = WI.OutputBnds.Left();
        dxdd.y                  = WI.OutputBnds.Top();
        dxdd.pSamples           = pRowBuff;
        dxdd.cSamples           = lDoWidth;
        dxdd.DestSurfaceFmt     = OutputSampleFormat();
    }

    for (lOutY = 0; *pbContinue && (lOutY < lDoHeight); lOutY++)
    {
        long    i           = 0;
        long    lScanLength = 0;    // Cumulative scan length on the current 
                                    // scanline.

        // Compute the inner/outer image section bounds.

        _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, 
                           m_Progress, lOutY + WI.DoBnds.Top(), alXBounds);

        _ClipBounds(WI.DoBnds.Left(), lDoWidth, alXBounds);

        while (lScanLength < lDoWidth)
        {
            // Copy a section of outer image to output buffer.

            if (alXBounds[i] - lScanLength > 0)
            {
                cpOuterInput->MoveToXY(lScanLength, lOutY);
                cpOuterInput->UnpackPremult(pRowBuff + lScanLength, 
                                            alXBounds[i] - lScanLength, FALSE);
            }

            lScanLength = alXBounds[i++];

            if (lScanLength >= lDoWidth)
            {
                break;
            }

            // Copy a section of inner image to output buffer.

            if (alXBounds[i] - lScanLength > 0)
            {
                cpInnerInput->MoveToXY(lScanLength, lOutY);
                cpInnerInput->UnpackPremult(pRowBuff + lScanLength, 
                                            alXBounds[i] - lScanLength, FALSE);
            }

            lScanLength = alXBounds[i++];
        }

        cpOut->MoveToRow(lOutY);

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            cpOut->OverArrayAndMove(pOutBuff, pRowBuff, lDoWidth);
        }
        else
        {
            cpOut->PackPremultAndMove(pRowBuff, lDoWidth);
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTIrisBase::WorkProc, CDXBaseNTo1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\light.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    light.cpp
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	Implementation of CLight
//
// Change History:
//
// 05/20/99 PhilLu   Move code from dtcss to dxtmsft. Clean up.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "Light.h"

const float PI = 3.14159265359f;


//+-----------------------------------------------------------------------------
//
//  CLight::CLight
//
//------------------------------------------------------------------------------
CLight::CLight() :
    m_lAmount(100),
    m_cLights(0)
{
    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;
}
//  CLight::CLight


//+-----------------------------------------------------------------------------
//
//  CLight::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CLight::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CLight::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CLight::addAmbient, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CLight::addAmbient(int r, int g, int b, int strength)
{
    if (m_cLights < MAXLIGHTS)
    {
        Lock();
        m_apLights[m_cLights++] = new ambientLight(r, g, b, strength);
        if (!m_apLights[m_cLights-1])
        {
            m_cLights--;
            return E_OUTOFMEMORY;
        }

        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::addAmbient, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::addPoint, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP  
CLight::addPoint(int x, int y, int z, int r, int g, int b, int strength) 
{
    if (m_cLights < MAXLIGHTS)
    {
        Lock();
        m_apLights[m_cLights++] = new ptLight(x, y, z, r, g, b, strength);
        if (!m_apLights[m_cLights-1])
        {
            m_cLights--;
            return E_OUTOFMEMORY;
        }

        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::addPoint, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::addCone, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP  
CLight::addCone(int x, int y, int z, int tx, int ty, int r, int g, int b, 
                 int strength, int spread)
{
    if (m_cLights < MAXLIGHTS)
    {
        Lock();
        m_apLights[m_cLights++] = new coneLight(x, y, z, tx, ty, r, g, b, strength, spread);
        if (!m_apLights[m_cLights-1])
        {
            m_cLights--;
            return E_OUTOFMEMORY;
        }

        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::addCone, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::moveLight, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP  
CLight::moveLight(int lightNum, int x, int y, int z, BOOL fAbsolute) 
{
    if (lightNum < m_cLights)
    {
        Lock();
        m_apLights[lightNum]->move(x, y, z, fAbsolute);
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::moveLight, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::ChangeStrength, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP  
CLight::ChangeStrength(int lightNum, int dStrength, BOOL fAbsolute)
{
    if (lightNum < m_cLights)
    {
        Lock();
        m_apLights[lightNum]->changeStrength(dStrength, fAbsolute);
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::ChangeStrength, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::ChangeColor, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CLight::ChangeColor(int lightNum, int R, int G, int B, BOOL fAbsolute)
{
    if (lightNum < m_cLights)
    {
        Lock();
        m_apLights[lightNum]->changeColor(R, G, B, fAbsolute);
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::ChangeColor, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::Clear, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CLight::Clear()
{
    Lock();
    for (int i = 0; i < m_cLights; i++)
    {
        delete m_apLights[i];
    }

    m_cLights = 0;
    SetDirty();
    Unlock();
    return S_OK;
}
//  CLight::Clear, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CLight::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (SUCCEEDED(hr))
    {
        bndsIn.GetXYSize(m_sizeInput);
    }

    return hr;

}
//  CLight::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CLight::Clear, IDXTLight
//
//------------------------------------------------------------------------------
void 
CLight::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                               ULONG aInIndex[], BYTE aWeight[])
{
    ulInToTest = 1;
    aInIndex[0] = 0;
    aWeight[0] = 255;
}
//  CLight::Clear, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT CLight::WorkProc(const CDXTWorkInfoNTo1 & WI, 
                         BOOL * pbContinueProcessing)
{
    HRESULT hr  = S_OK;
    int     y   = 0;

    DXSAMPLE *      pInputBuffer    = NULL;
    DXPMSAMPLE *    pPMBuff         = NULL;
    DXPMSAMPLE *    pOverScratch    = NULL;

    CComPtr<IDXARGBReadWritePtr>    pDest;
    CComPtr<IDXARGBReadPtr>         pSrc;

    DXDITHERDESC dxdd;

    const int nDoWidth  = WI.DoBnds.Width();
    const int nDoHeight = WI.DoBnds.Height();

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, 
                                      (void**)&pDest, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InputSurface()->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // If the output surface isn't in PMARGB32 or ARGB32 formats and we're 
    // blending with the output we'll need a scratch buffer blend with the
    // output surface.

    if ((OutputSampleFormat() != DXPF_PMARGB32) 
        && (OutputSampleFormat() != DXPF_ARGB32)
        && DoOver())
    {
        pOverScratch = DXPMSAMPLE_Alloca(nDoWidth);
    }

    // Allocate a working buffer.

    pInputBuffer = DXSAMPLE_Alloca(nDoWidth);

    //  Initialize the dither structure

    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = pInputBuffer;
        dxdd.cSamples       = nDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // Row loop.

    for (y = 0; y < nDoHeight; y++)
    {
        // Move to the appropriate input row.

        pSrc->MoveToRow(y);

        // Unpack the pixels to our working buffer.

        pSrc->Unpack(pInputBuffer, nDoWidth, FALSE);

        // Light this row of pixels.

        CompLightingRow(WI.DoBnds.Left(), WI.DoBnds.Top() + y, nDoWidth, 
                        pInputBuffer);

        // Dither if requested.

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        // Move to the appropriate output row.

        pDest->MoveToRow(y);

        if (DoOver())
        {
            pPMBuff = DXPreMultArray(pInputBuffer, nDoWidth);
            pDest->OverArrayAndMove(pOverScratch, pPMBuff, nDoWidth);
        }
        else
        {
            pDest->PackAndMove(pInputBuffer, nDoWidth);
        }
    } // Row loop.

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CLight::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CLight::CompLightingRow
//
//------------------------------------------------------------------------------
void
CLight::CompLightingRow(int nStartX, int nStartY, int nWidth, DXSAMPLE *pDrawingBuffer)
{
    int  j  = 0;
    int  k  = 0;

    dRGB     dRGBCurrent;
    DXSAMPLE pix;

    for (j = 0; j < nWidth; j++)
    {
        pix = pDrawingBuffer[j];
        //Is the alpha set?
        if (pix.Alpha)
        {
            //Clear the light sum;
            dRGBCurrent.clear();
            for (k = 0; k < m_cLights; k++)
            {
                //Add in the light contribution
                m_apLights[k]->getLight(nStartX+j, nStartY, dRGBCurrent);
            }
            //Now adjust the screen bits;
            pix.Red = (UCHAR)clamp((ULONG)(pix.Red * dRGBCurrent.m_R), 255);
            pix.Green = (UCHAR)clamp((ULONG)(pix.Green * dRGBCurrent.m_G), 255);
            pix.Blue = (UCHAR)clamp((ULONG)(pix.Blue * dRGBCurrent.m_B), 255);
            pDrawingBuffer[j] = pix;
        }
    }
}
//  CLight::CompLightingRow

    
//+-----------------------------------------------------------------------------
//
//  lightObj::lightObj
//
//  This is the base class for all light types
//  C++ note: need to make the member functions virtual
//------------------------------------------------------------------------------
lightObj::lightObj(int x, int y, int z, int R, int G, int B, int strength)
{
    m_x = x;
    m_y = y;
    m_z = max(1, z);
    m_R = colCvt(R);
    m_G = colCvt(G);
    m_B = colCvt(B);
    if (strength < 0)
    {
        m_strength = 0.0f;
    }
    else
    {
        m_strength = min(1.0f, (float)strength / 100.0f);
    }
}
//  lightObj::lightObj


//+-----------------------------------------------------------------------------
//
//  lightObj::move
//
//  Either relative or absolute move for the light source
//------------------------------------------------------------------------------
void 
lightObj::move(int x, int y, int z, BOOL fAbsolute)
{
    if (!fAbsolute)
    {
        m_x += x;
        m_y += y;
        m_z += z;
    }
    else
    {
        m_x = x;
        m_y = y;
        m_z = z;
    }
    m_z = max(1, m_z);
}
//  lightObj::move


//+-----------------------------------------------------------------------------
//
//  lightObj::changeStregth
//
//------------------------------------------------------------------------------
void 
lightObj::changeStrength(int dStrength, BOOL fAbsolute) 
{
    if (!fAbsolute)
    {
        m_strength += static_cast<float>(dStrength) / 100.0f;
    }
    else
    {
        m_strength = static_cast<float>(dStrength) / 100.0f;
    }
    m_strength = min(1.0f, max(0.0f, m_strength));
}
//  lightObj::changeStregth


//+-----------------------------------------------------------------------------
//
//  lightObj::changeColor
//
//------------------------------------------------------------------------------
void 
lightObj::changeColor(int R, int G, int B, BOOL fAbsolute) 
{
    if (!fAbsolute)
    {
        m_R = lightClip(m_R + relativeColCvt(R));
        m_G = lightClip(m_G + relativeColCvt(G));
        m_B = lightClip(m_B + relativeColCvt(B));
    }
    else
    {
        m_R = colCvt(R);
        m_G = colCvt(G);
        m_B = colCvt(B);
    }
}
//  lightObj::changeColor


//+-----------------------------------------------------------------------------
//
//  ambientLight::ambientLight
//
//------------------------------------------------------------------------------
ambientLight::ambientLight(int R, int G, int B, int strength) : 
    lightObj(0, 0, 0, R, G, B, strength)
{
    premultiply();
}
//  ambientLight::ambientLight


//+-----------------------------------------------------------------------------
//
//  ambientLight::changeStrength, lightObj
//
//------------------------------------------------------------------------------
void 
ambientLight::changeStrength(int dStrength, BOOL fAbsolute)
{
    lightObj::changeStrength(dStrength,fAbsolute);
    premultiply();
}
//  ambientLight::changeStrength, lightObj

	
//+-----------------------------------------------------------------------------
//
//  ambientLight::changeColor, lightObj
//
//------------------------------------------------------------------------------
void 
ambientLight::changeColor(int R, int G, int B, BOOL fAbsolute)
{
    lightObj::changeColor(R, G, B, fAbsolute);
    premultiply();
}
//  ambientLight::changeColor, lightObj


//+-----------------------------------------------------------------------------
//
//  ambientLight::getLight, lightObj
//
//------------------------------------------------------------------------------
void 
ambientLight::getLight(int x, int y, dRGB &col) 
{
    //Calculate ambient values
    col.add(m_RStr, m_GStr, m_BStr);
}
//  ambientLight::getLight, lightObj


//+-----------------------------------------------------------------------------
//
//  ambientLight::premultiply
//
//------------------------------------------------------------------------------
void 
ambientLight::premultiply(void)
{
    m_RStr = m_R * m_strength;
    m_GStr = m_G * m_strength;
    m_BStr = m_B * m_strength;
}
//  ambientLight::premultiply


//+-----------------------------------------------------------------------------
//
//  ptLight::ptLight
//
//------------------------------------------------------------------------------
ptLight::ptLight(int x, int y, int z, int R, int G, int B, int strength) :
    lightObj(x, y, z, R, G, B, strength),
    bounded()
{
    CalculateBoundingRect();
}
//  ptLight::ptLight


//+-----------------------------------------------------------------------------
//
//  ptLight::CalculateBoundingRect, bounded
//
//  The idea is to not calculate anything that falls
//  so far away it's beneath a strength threshold.
//  strength = (m_strength / r^2) * cos(alpha)
//  where r = [ ((x-m_x)^2 + (y-m_y)^2 + m_z^2)^1/2 ] / m_z;
//  and cos(alpha) is really just 1/r.
//  We solve for threshold = m_strength * (m_z/rT)^3
//  where rT = iRadius^2 + m_z^2 and we don't consider
//  pixels lying outside the rect given by iRadius and m_x, m_y.
//  Note: the getLight function uses m_strength * m_z^3 
//  and m_z^2 for each x,y; so pre-calc these here too.
//------------------------------------------------------------------------------
void 
ptLight::CalculateBoundingRect(void)
{
    float  fltDistNormal = (float) abs(m_z);
    float  fltThresh     = (float) s_iThresholdStr / 255.0f;
    int    iRadius;
    RECT   rectBounds;
    float  fltMaxClrStr;

    m_fltNormalDistSquared  = fltDistNormal * fltDistNormal;
    m_fltIntensityNumerator = m_strength * 
                              fltDistNormal * 
                              m_fltNormalDistSquared;

    fltMaxClrStr = m_R;
    if (m_G > fltMaxClrStr)
    {
        fltMaxClrStr = m_G;
    }

    if (m_B > fltMaxClrStr)
    {
        fltMaxClrStr = m_B;
    }

    fltMaxClrStr *= m_strength;

    if ((fltMaxClrStr > 0.0f) && 
        (m_fltIntensityNumerator > 0.0f))
    {
        iRadius = (int)(
            fltDistNormal * 
            (float) sqrt(pow(fltMaxClrStr,2.0f/3.0f) *
                          pow(fltThresh, -2.0f/3.0f) -
                          1.0f));

        rectBounds.left   = m_x - iRadius;
        rectBounds.right  = m_x + iRadius;
        rectBounds.top    = m_y - iRadius;
        rectBounds.bottom = m_y + iRadius;	
    }
    else
    {
        rectBounds.left  = rectBounds.top    = 0;
        rectBounds.right = rectBounds.bottom = 0;
    }

    SetRect(rectBounds);
}
//  ptLight::CalculateBoundingRect, bounded


//+-----------------------------------------------------------------------------
//
//  ptLight::changeColor, lightObj
//
//------------------------------------------------------------------------------
void 
ptLight::changeColor(int R, int G, int B, BOOL fAbsolute)
{
    lightObj::changeColor(R, G, B, fAbsolute);
    CalculateBoundingRect();
}
//  ptLight::changeColor, lightObj


//+-----------------------------------------------------------------------------
//
//  ptLight::changeColor, lightObj
//
//------------------------------------------------------------------------------
void 
ptLight::changeStrength(int dStrength, BOOL fAbsolute)
{
    lightObj::changeStrength(dStrength, fAbsolute);
    CalculateBoundingRect();
}
//  ptLight::changeColor, lightObj


//+-----------------------------------------------------------------------------
//
//  ptLight::getLight, lightObj
//
//------------------------------------------------------------------------------
#pragma optimize("agt", on)
void 
ptLight::getLight(int x, int y, dRGB &col)
{
    //Light strength
    float n;
    float dp;

    if (InBounds(x, y))
    {
        dp = (((float)(x - m_x) * (float)(x - m_x)) + 
               ((float)(y - m_y) * (float)(y - m_y)) + 
               m_fltNormalDistSquared);

        dp = 1.0f / static_cast<float>(sqrt(dp));
        n = m_fltIntensityNumerator * dp * dp * dp;

        col.add(m_R*n, m_G*n, m_B*n);
    }
}
#pragma optimize("", on)
//  ptLight::getLight, lightObj


//+-----------------------------------------------------------------------------
//
//  ptLight::move, lightObj
//
//------------------------------------------------------------------------------
void 
ptLight::move(int x, int y, int z, BOOL fAbsolute)
{
    lightObj::move(x, y, z, fAbsolute);
    CalculateBoundingRect();
}
//  ptLight::move, lightObj



//+-----------------------------------------------------------------------------
//
//  coneLight::coneLight
//  Here's the constructor. Note that it takes extra parameters
//
//------------------------------------------------------------------------------
coneLight::coneLight(int x, int y, int z, int targX, int targY, int R, int G, 
                     int B, int strength, int spread) : 
	lightObj(x, y, z, R, G, B, strength)
{
    m_targdx = targX - m_x;
    m_targdy = targY - m_y;	

    //Convert cone spread to cosine range
    m_conespread = (float) cos(abs(spread)*PI/180.0);
    if (m_conespread < 0.0f)
        m_conespread = 0.0f;	

    CalculateConstants();
}
//  coneLight::coneLight


//+-----------------------------------------------------------------------------
//
//  coneLight::CalculateConstants
//  Here's the constructor. Note that it takes extra parameters
//
//------------------------------------------------------------------------------
void coneLight::CalculateConstants(void)
{
    float fltDistTargetSquared;

    m_fltDistNormalSquared = (float)(m_z * m_z);

    fltDistTargetSquared   = ((float)m_targdx * (float)m_targdx) +
                             ((float)m_targdy * (float)m_targdy) + 
                             m_fltDistNormalSquared;

    m_fltComparisonAngle = m_conespread * 
                           m_conespread * 
                           fltDistTargetSquared;
}
//  coneLight::CalculateConstants


//+-----------------------------------------------------------------------------
//
//  coneLight::getLight, lightObj
//
//------------------------------------------------------------------------------
#pragma optimize("agt", on)
void coneLight::getLight(int x, int y, dRGB &col)
{
    float  fltDistPSquared =    0.0f;	
    float  fltDotSquared =      0.0f;
    float  fltDenom =           0.0f;
    float  fltStr =             0.0f;

    float  fltDot = ((m_targdx) * (x-m_x)) + 
                    ((m_targdy) * (y-m_y)) +
                    m_fltDistNormalSquared;

    if (fltDot < 0.0f)
        return;

    fltDotSquared = fltDot * fltDot;
    fltDistPSquared = ((float)(x-m_x) * (float)(x-m_x)) +
                        ((float)(y-m_y) * (float)(y-m_y)) +
                        m_fltDistNormalSquared;

    // We want to compare the angle between
    // vector-xy and vector-target with m_conespread.
    // Instead we compare the cosine-squared of the angle,
    // which we get by squaring the dot-product and
    // cross-multiplying by the vector magnitudes.
    // The target vector magnitude has been pre-calculated.
    // The fltDot<0 test above preserves sign and early-outs.
    // No division, no sqrt, save those for col.add pixels.
    if (fltDotSquared >= 
        (fltDistPSquared * m_fltComparisonAngle))
    {
        // strength = m_strength * cos^2(xy-to-target) * 1/r^2
        // cos(xy-to-target) = fltDot / 
        //            sqrt(fltDistPSquared*fltDistTargetSquared)
        // cos^2 is close enough and avoids a sqrt!
        // and 1/r^2 ~= m_fltDistTargetSquared/fltDistPSquared
        // All this reduces to ...

        fltDenom = fltDistPSquared * fltDistPSquared;
        fltStr   = m_strength * fltDotSquared / fltDenom;

        col.add(m_R*fltStr, m_G*fltStr, m_B*fltStr);
    }
}
#pragma optimize("", on)
//  coneLight::getLight, lightObj



//+-----------------------------------------------------------------------------
//
//  coneLight::getLight, lightObj
//  Relative move of the target not source
//
//------------------------------------------------------------------------------
void 
coneLight::move(int x, int y, int z, BOOL fAbsolute)
{
    if (!fAbsolute)
    {
        m_targdx += x;
        m_targdy += y;
    }
    else
    {
        m_targdx = x - m_x;
        m_targdy = y - m_y;
    }

    CalculateConstants();
}
//  coneLight::getLight, lightObj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\light.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    light.h
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	This is the header file for the light transformation.
//
// Change History:
//
// 1999/05/20 phillu    Move from dtcss to dxtmsft. Re-implemented algorithms
//                      for creating linear/rectangular/elliptic surfaces.
// 2000/05/10 mcalkins  Support IObjectSafety appropriately.
//
//------------------------------------------------------------------------------

#ifndef __LIGHT_H_
#define __LIGHT_H_

#include "resource.h"

class lightObj;




class ATL_NO_VTABLE CLight : 
    public CDXBaseNTo1,
    public CComCoClass<CLight, &CLSID_DXTLight>,
    public CComPropertySupport<CLight>,
    public IDispatchImpl<IDXTLight, &IID_IDXTLight, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CLight>,
    public IPersistStorageImpl<CLight>,
    public ISpecifyPropertyPagesImpl<CLight>,
    public IPersistPropertyBagImpl<CLight>
{
private:

    enum { MAXLIGHTS = 10 };

    long                m_lAmount;
    lightObj *          m_apLights[MAXLIGHTS];
    int                 m_cLights;
    SIZE                m_sizeInput;
    CComPtr<IUnknown>   m_cpUnkMarshaler;

    inline DWORD clamp(DWORD i, DWORD d)
    {
        if (i <= d)
            return (i & d);
        else
            return d;
    }

    void CompLightingRow(int nStartX, int nStartY, int nWidth, 
                         DXSAMPLE *pBuffer);

public:

    CLight();

    ~CLight()
    {
        Clear();
    }

    DECLARE_POLY_AGGREGATABLE(CLight)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_LIGHT)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CLight)
        COM_INTERFACE_ENTRY(IDXTLight)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CLight>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CLight)
        PROP_PAGE(CLSID_DXTLightPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    void    OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest,
                                  ULONG aInIndex[], BYTE aWeight[]);
    HRESULT OnSetup(DWORD dwFlags);

    // IDXTLight methods.

    STDMETHOD(addAmbient)(int r, int g, int b, int strength);
    STDMETHOD(addPoint)(int x, int y, int z, int r, int g, int b, int strength);
    STDMETHOD(addCone)(int x, int y, int z, int tx, int ty, int r, int g, int b, int strength, int spread);
    STDMETHOD(moveLight)(int lightNum, int x, int y, int z, BOOL fAbsolute);
    STDMETHOD(ChangeStrength)(int lightNum, int dStrength, BOOL fAbsolute);
    STDMETHOD(ChangeColor)(int lightNum, int R, int G, int B, BOOL fAbsolute);
    STDMETHOD(Clear)();
};

//
//  This class stores and manages a color
//
class dRGB 
{
public: // to simplify some code ...

    float m_R, m_G, m_B;

public:

    dRGB() : m_R(0.0f), m_G(0.0f), m_B(0.0f) {};

    inline void clear()
    { 
        m_R = m_G = m_B = 0.0f; 
    }

    inline void set(float R, float G, float B)
    {
        m_R = R; m_G = G; m_B = B;
    }

    inline void add(const dRGB & c)
    {
        m_R += c.m_R; m_G += c.m_G; m_B += c.m_B;
    }

    inline void add(float R, float G, float B)
    {
        m_R += R; m_G += G; m_B += B;
    }
};


// 
// This is the base class for all light types
// 
class lightObj 
{
protected:

    int m_x, m_y, m_z;    //Coordinates of the light source
    float m_R, m_G, m_B;  //Light color
    float m_strength;     //Light strength

    // helper
    inline float lightClip(float v)
    {
        if (v < 0.0f) v = 0.0f;
        if (v > 1.0f) v = 1.0f;
        return v;
    }

public:

    lightObj(int x, int y, int z, int R, int G, int B, int strength);

    virtual void getLight(int x, int y, dRGB &col){}
    virtual void move(int x, int y, int z, BOOL fAbsolute);
    virtual void changeStrength(int dStrength, BOOL fAbsolute);
    virtual void changeColor(int R, int G, int B, BOOL fAbsolute);

    //Converts a color value (0..255) to a percent
    //Clips to valid range
    inline float lightObj::colCvt(int c)
    {
        if (c < 0) c = 0;
        if (c > 255) c = 255;
        return ((float) c)/255.0f;
    }

    inline float lightObj::relativeColCvt( int c )
    {
        if( c < -255 ) c = -255;
        if( c > 255 ) c = 255;
        return static_cast<float>(c) / 255.0f;
    }
};

//
//  Implement ambient light
//  Ambient light isn't effected by position
//
class ambientLight : 
    public lightObj 
{
private:

    float  m_RStr, m_GStr, m_BStr;

    void  premultiply(void);

public:

    ambientLight(int R, int G, int B, int strength);

    // overrides lightObj functions
    void getLight(int x, int y, dRGB &col);
    void changeStrength(int dStrength, BOOL fAbsolute);
    void changeColor(int R, int G, int B, BOOL fAbsolute);
};

//
//  Helper class to implement rectangular bounds checking
//
class bounded
{
private:

    RECT  m_rectBounds;

public:
    bounded(){ClearBoundingRect();}
    bounded(const RECT & rectBounds){SetRect(rectBounds);}
    bounded(int left, int top, int right, int bottom )
    {
        RECT rectBound;
        ::SetRect( &m_rectBounds, left, top, right, bottom );
        SetRect( rectBound );
    }

    virtual ~bounded(){}

    virtual void CalculateBoundingRect() = 0;
    virtual void ClearBoundingRect()
    { 
        m_rectBounds.left   = LONG_MIN;
        m_rectBounds.top    = LONG_MIN;
        m_rectBounds.right  = LONG_MAX;
        m_rectBounds.bottom = LONG_MAX;
    }

    inline BOOL InBounds( POINT & pt )
    {
        return PtInRect( &m_rectBounds, pt ); 
    }

    inline BOOL InBounds( int x, int y )
    {
        // Intentional bitwise-AND for speed
        return( (x >= m_rectBounds.left)  &
                (x <= m_rectBounds.right) & 
                (y >= m_rectBounds.top)   &
                (y <= m_rectBounds.bottom) );
    }

    void GetRect(RECT & theRect) const { theRect = m_rectBounds; }
    void SetRect(const RECT & theRect) { m_rectBounds = theRect; }
};


//
// Implement a point light source
// A point light drops off proportionate to the cosine of the angle between 
// the light vector and the viewer vector
//
class ptLight : 
    public lightObj, 
    public bounded
{
private:

    float  m_fltIntensityNumerator;
    float  m_fltNormalDistSquared;

    enum { s_iThresholdStr = 8 };

public:
    ptLight(int x, int y, int z, int R, int G, int B, int strength);

    // overrides lightObj::
    virtual void changeColor(int R, int G, int B, BOOL fAbsolute);
    virtual void changeStrength(int dStrength, BOOL fAbsolute);
    virtual void getLight(int x, int y, dRGB &col);
    virtual void move(int x, int y, int z, BOOL fAbsolute);

    // overrides bounded::
    virtual void CalculateBoundingRect( void );
};


//
// Implement a cone light source
//
class coneLight : 
    public lightObj 
{
private:

    int   m_targdx;
    int   m_targdy;
    float m_fltDistTargetSquared;
    float m_fltDistNormalSquared;
    float m_fltComparisonAngle;	
    float m_conespread;

    virtual void CalculateConstants();

public:

    // constructor. Note that it takes extra parameters
    coneLight(int x, int y, int z, int targX, int targY, int R, int G, int B, 
              int strength, int spread);

    // overrides lightObj
    void getLight(int x, int y, dRGB &col);
    virtual void move(int x, int y, int, BOOL fAbsolute);
};


#endif //__LIGHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\maskfilter.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       maskfilter.cpp
//
//  Overview:       The MaskFilter transform simply wraps the BasicImage
//                  transform to ensure backward compatibility for the mask 
//                  filter.
//
//  Change History:
//  1999/09/19  a-matcal    Created.
//  1999/12/03  a-matcal    put_Color now ensures that the mask color is opaque.
//  1999/12/03  a-matcal    Default mask color is now black instead of clear.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "maskfilter.h"
#include "dxclrhlp.h"
#include "filterhelpers.h"




//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::CDXTMaskFilter
//
//------------------------------------------------------------------------------
CDXTMaskFilter::CDXTMaskFilter() :
    m_bstrColor(NULL)
{
}
//  CDXTMaskFilter::CDXTMaskFilter


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::~CDXTMaskFilter
//
//------------------------------------------------------------------------------
CDXTMaskFilter::~CDXTMaskFilter()
{
    if (m_bstrColor)
    {
        SysFreeString(m_bstrColor);
    }
}
//  CDXTMaskFilter::~CDXTMaskFilter


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT
CDXTMaskFilter::FinalConstruct()
{
    HRESULT hr = S_OK;

    CComPtr<IDXTransformFactory>    spDXTransformFactory;

    hr =  CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                        &m_spUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_bstrColor = SysAllocString(L"#FF000000");

    if (NULL == m_bstrColor)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CDXTMaskFilter::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::GetSite, IObjectWithSite
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMaskFilter::GetSite(REFIID riid, void ** ppvSite)
{
    if (!m_spUnkSite)
    {
        return E_FAIL;
    }
    else
    {
        return m_spUnkSite->QueryInterface(riid, ppvSite);
    }
}
//  Method: CDXTMaskFilter::GetSite, IObjectWithSite


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::SetSite, IObjectWithSite
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMaskFilter::SetSite(IUnknown * pUnkSite)
{
    if (pUnkSite == m_spUnkSite)
    {
        goto done;
    }

    m_spDXBasicImage.Release();
    m_spDXTransform.Release();

    m_spUnkSite = pUnkSite;

    if (pUnkSite)
    {
        HRESULT hr          = S_OK;
        DWORD   dwColor;

        CComPtr<IDXTransformFactory>    spDXTransformFactory;
        CComPtr<IDXBasicImage>          spDXBasicImage;
        CComPtr<IDXTransform>           spDXTransform;

        hr = pUnkSite->QueryInterface(__uuidof(IDXTransformFactory),
                                      (void **)&spDXTransformFactory);

        if (FAILED(hr))
        {
            goto done;
        }

        // Create BasicImage transform.

        hr = spDXTransformFactory->CreateTransform(NULL, 0, NULL, 0, NULL, NULL,
                                                   CLSID_BasicImageEffects, 
                                                   __uuidof(IDXBasicImage), 
                                                   (void **)&spDXBasicImage);

        if (FAILED(hr))
        {
            goto done;
        }

        // Get IDXTransform interface.

        hr = spDXBasicImage->QueryInterface(__uuidof(IDXTransform),
                                              (void **)&spDXTransform);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDXBasicImage->put_Mask(TRUE);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = DXColorFromBSTR(m_bstrColor, &dwColor);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDXBasicImage->put_MaskColor(dwColor);

        if (FAILED(hr))
        {
            goto done;
        }

        m_spDXBasicImage    = spDXBasicImage;
        m_spDXTransform     = spDXTransform;
    }

done:

    return S_OK;
}
//  Method: CDXTMaskFilter::SetSite, IObjectWithSite


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::get_Color, IDXTMask
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMaskFilter::get_Color(VARIANT * pvarColor)
{
    HRESULT hr = S_OK;

    if (NULL == pvarColor)
    {
        hr = E_POINTER;

        goto done;
    }

    // Copy our stored color and change to BSTR format.  The type of the VARIANT
    // returned by this function is considered the default type and we want it
    // to be BSTR

    VariantClear(pvarColor);

    _ASSERT(m_bstrColor);

    pvarColor->vt       = VT_BSTR;
    pvarColor->bstrVal  = SysAllocString(m_bstrColor);

    if (NULL == pvarColor->bstrVal)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CDXTMaskFilter::get_Color, IDXTMask


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::put_Color, IDXTMask
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMaskFilter::put_Color(VARIANT varColor)
{
    HRESULT hr          = S_OK;
    BSTR    bstrTemp    = NULL;
    DWORD   dwColor     = 0x00000000;

    hr = FilterHelper_GetColorFromVARIANT(varColor, &dwColor, &bstrTemp);

    if (FAILED(hr))
    {
        goto done;
    }

    // If zero is specified as the alpha value, in the case of filters this
    // means the user probably meant that the color should be opaque as this
    // is how the old filters treated it.

    if (!(dwColor & 0xFF000000))
    {
        dwColor |= 0xFF000000;
    }

    if (m_spDXBasicImage)
    {
        hr = m_spDXBasicImage->put_MaskColor((int)dwColor);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    _ASSERT(bstrTemp);

    SysFreeString(m_bstrColor);

    m_bstrColor = bstrTemp;

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  CDXTMaskFilter::put_Color, IDXTMask
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\iris.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:            iris.h
//
// Created:             06/18/98
//
// Author:              kipo
//
// Description:         This is the header file for the CrIris transformation
//
// Change History:
// 06/24/98 PhilLu      Developed 1.0 version for Chromeffects
// 11/04/98 PaulNash    Moved from DT 1.0 codebase to IE5/NT5 DXTMSFT.DLL
// 05/20/99 a-matcal    Code scrub.
// 09/25/99 a-matcal    Inherit from ICrIris2 interface.
// 10/22/99 a-matcal    Changed CIris class to CDXTIrisBase and created two new
//                      classes CDXTIris and CDXTIrisOpt to represent 
//                      non-optimized and optimized versions respectively.
// 2000/01/16 mcalkins  Added rectangle option.
//
//------------------------------------------------------------------------------

#ifndef __CRIRIS_H_
#define __CRIRIS_H_

#include "resource.h"




class ATL_NO_VTABLE CDXTIrisBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrIris2, &IID_ICrIris2, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTIrisBase>,
    public IObjectSafetyImpl2<CDXTIrisBase>,
    public ISpecifyPropertyPagesImpl<CDXTIrisBase>
{
private:

    typedef enum
    {
        STYLE_DIAMOND,
        STYLE_CIRCLE,
        STYLE_CROSS,
        STYLE_PLUS,
        STYLE_SQUARE,
        STYLE_STAR,
        STYLE_RECTANGLE,
        STYLE_MAX
    } STYLE;

    STYLE                   m_eStyle;
    static const WCHAR *    s_astrStyle[STYLE_MAX];

    typedef enum {
        MOTION_IN = 0,
        MOTION_OUT,
        MOTION_MAX
    } MOTION;

    MOTION                  m_eMotion;
    static const WCHAR *    s_astrMotion[MOTION_MAX];

    SIZE                m_sizeInput;
    CComPtr<IUnknown>   m_cpUnkMarshaler;

    // Helpers.

    void _ScanlineIntervals(long width, long height, float progress, 
                            long YScanline, long *XBounds);
    void _ClipBounds(long offset, long width, long *XBounds);

protected:

    unsigned        m_fOptimize : 1;

public:

    CDXTIrisBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTIrisBase)
        COM_INTERFACE_ENTRY(ICrIris2)
        COM_INTERFACE_ENTRY(ICrIris)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTIrisBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CIris)
        PROP_ENTRY("irisstyle", DISPID_CRIRIS_IRISSTYLE,    CLSID_CrIrisPP)
        PROP_ENTRY("motion",    DISPID_CRIRIS_MOTION,       CLSID_CrIrisPP)
        PROP_PAGE(CLSID_CrIrisPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, 
                                  ULONG & ulInToTest, ULONG aInIndex[], 
                                  BYTE aWeight[]);
    HRESULT WorkProc(const CDXTWorkInfoNTo1& WI, BOOL* pbContinue);
    HRESULT OnSetup(DWORD dwFlags );

    // ICrIris properties.

    STDMETHOD(get_irisStyle)(BSTR * pbstrStyle);
    STDMETHOD(put_irisStyle)(BSTR bstrStyle);

    // ICrIris2 properties.

    STDMETHOD(get_Motion)(BSTR * pbstrMotion);
    STDMETHOD(put_Motion)(BSTR bstrMotion);

    // IDXEffect methods.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTIris :
    public CDXTIrisBase,
    public CComCoClass<CDXTIris, &CLSID_CrIris>,
    public IPersistStorageImpl<CDXTIris>,
    public IPersistPropertyBagImpl<CDXTIris>
{
public:

    CDXTIris()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTIRIS)
    DECLARE_POLY_AGGREGATABLE(CDXTIris)

    BEGIN_COM_MAP(CDXTIris)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTIrisBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTIrisOpt :
    public CDXTIrisBase,
    public CComCoClass<CDXTIrisOpt, &CLSID_DXTIris>,
    public IPersistStorageImpl<CDXTIrisOpt>,
    public IPersistPropertyBagImpl<CDXTIrisOpt>
{
public:

    CDXTIrisOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTIRISOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTIrisOpt)

    BEGIN_COM_MAP(CDXTIrisOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTIrisBase)
    END_COM_MAP()
};

#endif //__CRIRIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\maskfilter.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       maskfilter.h
//
//  Overview:       The MaskFilter transform simply wraps the BasicImage
//                  transform to ensure backward compatibility for the mask 
//                  filter.
//
//  Change History:
//  1999/09/19  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef __MASKFILTER_H_
#define __MASKFILTER_H_

#include "resource.h"




class ATL_NO_VTABLE CDXTMaskFilter : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDXTMaskFilter, &CLSID_DXTMaskFilter>,
    public IDispatchImpl<IDXTMask, &IID_IDXTMask, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTMaskFilter>,
    public IObjectSafetyImpl2<CDXTMaskFilter>,
    public IPersistStorageImpl<CDXTMaskFilter>,
    public ISpecifyPropertyPagesImpl<CDXTMaskFilter>,
    public IPersistPropertyBagImpl<CDXTMaskFilter>,
    public IDXTransform,
    public IObjectWithSite
{
private:

    BSTR                    m_bstrColor;

    CComPtr<IDXBasicImage>  m_spDXBasicImage;
    CComPtr<IDXTransform>   m_spDXTransform;

    CComPtr<IUnknown>       m_spUnkSite;
    CComPtr<IUnknown>       m_spUnkMarshaler;

public:

    CDXTMaskFilter();
    virtual ~CDXTMaskFilter();

    DECLARE_POLY_AGGREGATABLE(CDXTMaskFilter)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTMASKFILTER)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTMaskFilter)
        COM_INTERFACE_ENTRY(IDXTMask)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTransform)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTMaskFilter>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTMaskFilter)
        PROP_ENTRY("color" , 1, CLSID_NULL)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // IObjectWithSite methods.

    STDMETHOD(GetSite)(REFIID riid, void ** ppvSite);
    STDMETHOD(SetSite)(IUnknown * pUnkSite);

    // IDXTMask methods.

    STDMETHOD(get_Color)(VARIANT * pvarColor);
    STDMETHOD(put_Color)(VARIANT varColor);

    // IDXTransform wrappers.

    STDMETHOD(Execute)(const GUID * pRequestID, const DXBNDS * pPortionBnds,
                       const DXVEC * pPlacement)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->Execute(pRequestID, pPortionBnds, pPlacement);
    }
    STDMETHOD(GetInOutInfo)(BOOL bIsOutput, ULONG ulIndex, DWORD * pdwFlags,
                            GUID * pIDs, ULONG * pcIDs, 
                            IUnknown ** ppUnkCurrentObject)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->GetInOutInfo(bIsOutput, ulIndex, pdwFlags,
                                             pIDs, pcIDs, ppUnkCurrentObject);
    }
    STDMETHOD(GetMiscFlags)(DWORD * pdwMiscFlags)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->GetMiscFlags(pdwMiscFlags);
    }
    STDMETHOD(GetQuality)(float * pfQuality)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->GetQuality(pfQuality);
    }
    STDMETHOD(MapBoundsIn2Out)(const DXBNDS * pInBounds, ULONG ulNumInBnds,
                               ULONG ulOutIndex, DXBNDS * pOutBounds)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->MapBoundsIn2Out(pInBounds, ulNumInBnds,
                                                ulOutIndex, pOutBounds);
    }
    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                               ULONG ulInIndex, DXBNDS * pInBounds)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->MapBoundsOut2In(ulOutIndex, pOutBounds, 
                                                ulInIndex, pInBounds);
    }
    STDMETHOD(SetMiscFlags)(DWORD dwMiscFlags)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->SetMiscFlags(dwMiscFlags);
    }
    STDMETHOD(SetQuality)(float fQuality)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->SetQuality(fQuality);
    }
    STDMETHOD(Setup)(IUnknown * const * punkInputs, ULONG ulNumInputs,
	             IUnknown * const * punkOutputs, ULONG ulNumOutputs,	
                     DWORD dwFlags)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->Setup(punkInputs, ulNumInputs, punkOutputs, 
                                      ulNumOutputs, dwFlags);
    }

    // IDXBaseObject wrappers.

    STDMETHOD(GetGenerationId)(ULONG * pnID)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->GetGenerationId(pnID);
    }
    STDMETHOD(GetObjectSize)(ULONG * pcbSize)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->GetObjectSize(pcbSize);
    }
    STDMETHOD(IncrementGenerationId)(BOOL fRefresh)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->IncrementGenerationId(fRefresh);
    }
};

#endif //__MASKFILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\matrix.cpp ===
//+-----------------------------------------------------------------------------
//
//  Filename:       matrix.cpp
//
//  Overview:       Applies a transformation matrix to an image.
//
//  History:
//  1998/10/30      phillu      Created.
//  1999/11/08      a-matcal    Changed from procedural surface to transform.
//                              Changed to IDXTWarp dual interface.
//                              Moved from dxtrans.dll to dxtmsft.dll.
//  2000/02/03      mcalkins    Changed from "warp" to "matrix"
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "matrix.h"




//+-----------------------------------------------------------------------------
//
//  CDXTMatrix static variables initialization.
//
//------------------------------------------------------------------------------

const WCHAR * CDXTMatrix::s_astrFilterTypes[] = {
    L"nearest",
    L"bilinear",
    L"cubic",
    L"bspline"
};

const WCHAR * CDXTMatrix::s_astrSizingMethods[] = {
    L"clip to original",
    L"auto expand"
};


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::CDXTMatrix
//
//------------------------------------------------------------------------------
CDXTMatrix::CDXTMatrix() :
    m_apsampleRows(NULL),
    m_asampleBuffer(NULL),
    m_eFilterType(BILINEAR),
    m_eSizingMethod(CLIP_TO_ORIGINAL),
    m_fInvertedMatrix(true)
{
    m_matrix.eOp            = DX2DXO_GENERAL_AND_TRANS;
    m_matrixInverted.eOp    = DX2DXO_GENERAL_AND_TRANS;

    m_sizeInput.cx          = 0;
    m_sizeInput.cy          = 0;

    // Base class members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
}
//  CDXTMatrix::CDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::~CDXTMatrix
//
//------------------------------------------------------------------------------
CDXTMatrix::~CDXTMatrix() 
{
    delete [] m_asampleBuffer;
    delete [] m_apsampleRows;
}
//  CDXTMatrix::~CDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT
CDXTMatrix::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  CDXTMatrix::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTMatrix::OnSetup(DWORD dwFlags)
{
    HRESULT hr  = S_OK;
    int     i   = 0;
    
    CDXDBnds bnds;

    hr = InputSurface()->GetBounds(&bnds);

    if (FAILED(hr))
    {
        goto done;
    }

    bnds.GetXYSize(m_sizeInput);

    _CreateInvertedMatrix();

    // Allocate a buffer to hold the input surface.

    delete [] m_asampleBuffer;
    delete [] m_apsampleRows;

    m_asampleBuffer = new DXSAMPLE[(m_sizeInput.cx + 2) * (m_sizeInput.cy + 2)];
    m_apsampleRows  = new DXSAMPLE *[m_sizeInput.cy + 2];

    if ((NULL == m_apsampleRows) || (NULL == m_asampleBuffer))
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    // m_apsampleRows is an array of pointers to the first sample of each row
    // of the input.  We need to set up these pointers now.  We add two pixels
    // the the row width because there will be a clear pixel on the right and
    // left side to help us anti-alias the border of the output.

    for (i = 0 ; i < (m_sizeInput.cy + 2) ; i++)
    {
        m_apsampleRows[i] = &m_asampleBuffer[i * (m_sizeInput.cx + 2)];
    }

    hr = _UnpackInputSurface();

    if (FAILED(hr))
    {
        goto done;
    }

    // Set the border pixels to clear.

    for (i = 0 ; i < m_sizeInput.cy ; i++)
    {
        m_apsampleRows[i + 1][0]                    = 0;
        m_apsampleRows[i + 1][m_sizeInput.cx + 1]   = 0;
    }

    for (i = 0 ; i <= (m_sizeInput.cx + 1) ; i++)
    {
        m_apsampleRows[0][i]                    = 0;
        m_apsampleRows[m_sizeInput.cy + 1][i]   = 0;
    }

done:

    return hr;
}
//  CDXTMatrix::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::DetermineBnds, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTMatrix::DetermineBnds(CDXDBnds & Bnds)
{
    if (AUTO_EXPAND == m_eSizingMethod)
    {
        RECT        rc;
        DXFPOINT    flptIn;
        DXFPOINT    flptOut;

        // Top/Left

        flptIn.x = (float)Bnds.Left();
        flptIn.y = (float)Bnds.Top();

        m_matrix.TransformPoints(&flptIn, &flptOut, 1);

        rc.top      = (long)flptOut.y;
        rc.bottom   = (long)(flptOut.y + 0.5F);
        rc.left     = (long)flptOut.x;
        rc.right    = (long)(flptOut.x + 0.5F);

        // Bottom/Left

        flptIn.y = (float)(Bnds.Bottom() - 1);

        m_matrix.TransformPoints(&flptIn, &flptOut, 1);

        rc.top      = min(rc.top,       (long)flptOut.y);
        rc.bottom   = max(rc.bottom,    (long)(flptOut.y + 0.5F));
        rc.left     = min(rc.left,      (long)flptOut.x);
        rc.right    = max(rc.right,     (long)(flptOut.x + 0.5F));

        // Bottom/Right

        flptIn.x = (float)(Bnds.Right() - 1);

        m_matrix.TransformPoints(&flptIn, &flptOut, 1);

        rc.top      = min(rc.top,       (long)flptOut.y);
        rc.bottom   = max(rc.bottom,    (long)(flptOut.y + 0.5F));
        rc.left     = min(rc.left,      (long)flptOut.x);
        rc.right    = max(rc.right,     (long)(flptOut.x + 0.5F));

        // Top/Right

        flptIn.y = (float)Bnds.Top();

        m_matrix.TransformPoints(&flptIn, &flptOut, 1);

        rc.top      = min(rc.top,       (long)flptOut.y);
        rc.bottom   = max(rc.bottom,    (long)(flptOut.y + 0.5F));
        rc.left     = min(rc.left,      (long)flptOut.x);
        rc.right    = max(rc.right,     (long)(flptOut.x + 0.5F));

        OffsetRect(&rc, -rc.left, -rc.top);

        // Since we calculated the bounds using points, we need to increment the
        // bottom and right values to have the bounds include all relevent 
        // points.

        rc.bottom++;
        rc.right++;

        Bnds.SetXYRect(rc);
    }

    return S_OK;
}
//  CDXTMatrix::DetermineBnds, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMatrix::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    if (IsInputDirty())
    {
        hr = _UnpackInputSurface();
    }
        
    return hr;
}
//  CDXTMatrix::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTMatrix::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT     hr          = S_OK;
    DXFPOINT    flptFirstDoPtInRow;

    long        nDoHeight   = WI.DoBnds.Height();
    long        nDoWidth    = WI.DoBnds.Width();
    long        y           = 0;

    CComPtr<IDXARGBReadWritePtr>    spDXARGBReadWritePtr;

    DXSAMPLE *      asampleRowBuffer        = DXSAMPLE_Alloca(nDoWidth);
    DXBASESAMPLE *  abasesampleRowScratch   = DXBASESAMPLE_Alloca(nDoWidth);

    // If the current matrix can't produce an inverted matrix, there's no
    // visible output and we don't need to render.

    if (!m_fInvertedMatrix)
    {
        goto done;
    }

    // Get pointer to output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut,
                                      DXLOCKF_READWRITE, 
                                      __uuidof(IDXARGBReadWritePtr),
                                      (void **)&spDXARGBReadWritePtr, NULL);

    if (FAILED(hr))
    {
        goto done;
    }
                                      
    // Transform the start point and step vector to the input coordinates.

    flptFirstDoPtInRow.x = (float)WI.DoBnds.Left();

    for (y = 0 ; (y < nDoHeight) && *pbContinue ; y++)
    {
        DXFPOINT flpt;

        flptFirstDoPtInRow.y = (float)(WI.DoBnds.Top() + y);

        // Store the first input point needed in flpt.

        m_matrixInverted.TransformPoints(&flptFirstDoPtInRow, &flpt, 1);

        switch (m_eFilterType)
        {
        case BILINEAR:

            hr = _DoBilinearRow(asampleRowBuffer, &flpt, nDoWidth);
            break;

        default:

            hr = _DoNearestNeighbourRow(asampleRowBuffer, &flpt, nDoWidth);
            break;
        }

        if (FAILED(hr))
        {
            goto done;
        }

        // Write row to output surface.

        spDXARGBReadWritePtr->MoveToRow(y);

        if (DoOver())
        {
            DXPMSAMPLE * ppmsampleFirst = DXPreMultArray(asampleRowBuffer, 
                                                         nDoWidth);

            spDXARGBReadWritePtr->OverArrayAndMove(abasesampleRowScratch, 
                                                   ppmsampleFirst,
                                                   nDoWidth);
        }
        else
        {
            spDXARGBReadWritePtr->PackAndMove(asampleRowBuffer, nDoWidth);
        }
    }

done:

    return hr;
}
//  CDXTMatrix::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTMatrix::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                        CDXDVec & InVec)
{
    DXFPOINT    flptIn;
    DXFPOINT    flptOut;

    ulInputIndex = 0;

    // If the current matrix can't be inverted, there's no visible output and
    // therefore no point on the input could have been hit.

    if (!m_fInvertedMatrix)
    {
        return S_FALSE;
    }

    flptOut.x = (float)OutPoint.u.D[DXB_X].Min;
    flptOut.y = (float)OutPoint.u.D[DXB_Y].Min;

    m_matrixInverted.TransformPoints(&flptOut, &flptIn, 1);

    InVec.u.D[DXB_X] = (long)flptIn.x;
    InVec.u.D[DXB_Y] = (long)flptIn.y;

    // If this is a point outside the original element bounds or the point hit
    // is very translucent, we aren't hit.

    if ((InVec.u.D[DXB_X] < 0) 
        || (InVec.u.D[DXB_X] >= m_sizeInput.cx)
        || (InVec.u.D[DXB_Y] < 0)
        || (InVec.u.D[DXB_Y] >= m_sizeInput.cy)
        || (0 == (m_apsampleRows[InVec.u.D[DXB_Y] + 1][InVec.u.D[DXB_X] + 1]
                   & 0xFF000000)))
    {
        return S_FALSE;
    }
    
    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                            ULONG ulInIndex, DXBNDS * pInBounds)
{
    if (ulOutIndex || ulInIndex)
    {
        return E_INVALIDARG;
    }

    if ((NULL == pInBounds) || (NULL == pOutBounds))
    {
        return E_POINTER;
    }

    if (m_fInvertedMatrix)
    {
        CDXDBnds    bndsInput;

        // This sets z and t components to reasonable values.

        *pInBounds = *pOutBounds;

        // TransformBounds has problems: it doesn't compute bounding boxes,
        // instead it assumes the top-left point of the input maps to top-left
        // of the output, etc.  Instead, call TransformPoints and do the rest of 
        // the work myself.

        DXFPOINT OutPoints[4], InPoints[4];
        
        OutPoints[0].x = (float)pOutBounds->u.D[DXB_X].Min;
        OutPoints[0].y = (float)pOutBounds->u.D[DXB_Y].Min;
        OutPoints[1].x = (float)pOutBounds->u.D[DXB_X].Min;
        OutPoints[1].y = (float)(pOutBounds->u.D[DXB_Y].Max - 1);
        OutPoints[2].x = (float)(pOutBounds->u.D[DXB_X].Max - 1);
        OutPoints[2].y = (float)pOutBounds->u.D[DXB_Y].Min;
        OutPoints[3].x = (float)(pOutBounds->u.D[DXB_X].Max - 1);
        OutPoints[3].y = (float)(pOutBounds->u.D[DXB_Y].Max - 1);

        m_matrixInverted.TransformPoints(OutPoints, InPoints, 4);

        pInBounds->u.D[DXB_X].Min = pInBounds->u.D[DXB_X].Max = (LONG)InPoints[0].x;
        pInBounds->u.D[DXB_X].Min = pInBounds->u.D[DXB_Y].Max = (LONG)InPoints[0].y;

        for (int i=1; i<4; ++i)
        {
            if (pInBounds->u.D[DXB_X].Min > (LONG)InPoints[i].x)
            {
                pInBounds->u.D[DXB_X].Min = (LONG)InPoints[i].x;
            }

            if (pInBounds->u.D[DXB_X].Max < (LONG)InPoints[i].x)
            {
                pInBounds->u.D[DXB_X].Max = (LONG)InPoints[i].x;
            }

            if (pInBounds->u.D[DXB_Y].Min > (LONG)InPoints[i].y)
            {
                pInBounds->u.D[DXB_Y].Min = (LONG)InPoints[i].y;
            }

            if (pInBounds->u.D[DXB_Y].Max < (LONG)InPoints[i].y)
            {
                pInBounds->u.D[DXB_Y].Max = (LONG)InPoints[i].y;
            }
        }

        // Since we were working with points, but need to return bounds, we need
        // to increment the Max members so that the bounds include all relevant
        // points.

        pInBounds->u.D[DXB_X].Max++;
        pInBounds->u.D[DXB_Y].Max++;

        // Expand the bounds by one pixel on all sides just to make extra sure 
        // we have the input bounds we need.  (IE6 Bug: 19343)

        pInBounds->u.D[DXB_X].Min--;
        pInBounds->u.D[DXB_Y].Min--;
        pInBounds->u.D[DXB_X].Max++;
        pInBounds->u.D[DXB_Y].Max++;

        // Since we're returning an area of the input surface, we need to 
        // intersect our proposed input bounds with the actual input surface
        // bounds.

        bndsInput.SetXYSize(m_sizeInput);

        ((CDXDBnds *)pInBounds)->IntersectBounds(bndsInput);
    }
    else
    {
        ((CDXDBnds)*pInBounds).SetEmpty();
    }

    return S_OK;
}
//  CDXTMatrix::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_M11, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_M11(float * pflM11)
{
    DXAUTO_OBJ_LOCK;

    if (!pflM11)
    {
        return E_POINTER;
    }

    *pflM11 = m_matrix.eM11;

    return S_OK;
}
//  CDXTMatrix::get_M11, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_M11, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_M11(const float flM11)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_M11, flM11);
}
//  CDXTMatrix::put_M11, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_M12, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_M12(float * pflM12)
{
    DXAUTO_OBJ_LOCK;

    if (!pflM12)
    {
        return E_POINTER;
    }

    *pflM12 = m_matrix.eM12;

    return S_OK;
}
//  CDXTMatrix::get_M12, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_M12, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_M12(const float flM12)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_M12, flM12);
}
//  CDXTMatrix::put_M12, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_Dx, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_Dx(float * pfldx)
{
    DXAUTO_OBJ_LOCK;

    if (!pfldx)
    {
        return E_POINTER;
    }

    *pfldx = m_matrix.eDx;

    return S_OK;
}
//  CDXTMatrix::get_Dx, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_Dx, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_Dx(const float fldx)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_DX, fldx);
}
//  CDXTMatrix::put_Dx, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_M21, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_M21(float * pflM21)
{
    DXAUTO_OBJ_LOCK;

    if (!pflM21)
    {
        return E_POINTER;
    }

    *pflM21 = m_matrix.eM21;

    return S_OK;
}
//  CDXTMatrix::get_M21, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_M21, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_M21(const float flM21)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_M21, flM21);
}
//  CDXTMatrix::put_M21, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_M22, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_M22(float * pflM22)
{
    DXAUTO_OBJ_LOCK;

    if (!pflM22)
    {
        return E_POINTER;
    }

    *pflM22 = m_matrix.eM22;

    return S_OK;
}
//  CDXTMatrix::get_M22, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_M22, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_M22(const float flM22)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_M22, flM22);
}
//  CDXTMatrix::put_M22, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_Dy, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_Dy(float * pfldy)
{
    DXAUTO_OBJ_LOCK;

    if (!pfldy)
    {
        return E_POINTER;
    }

    *pfldy = m_matrix.eDy;

    return S_OK;
}
//  CDXTMatrix::get_Dy, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_Dy, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_Dy(const float fldy)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_DY, fldy);
}
//  CDXTMatrix::put_Dy, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_SizingMethod, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_SizingMethod(BSTR * pbstrSizingMethod)
{
    DXAUTO_OBJ_LOCK;

    if (!pbstrSizingMethod)
    {
        return E_POINTER;
    }

    if (*pbstrSizingMethod != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrSizingMethod = SysAllocString(s_astrSizingMethods[m_eSizingMethod]);

    if (NULL == *pbstrSizingMethod)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTMatrix::get_SizingMethod, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_SizingMethod, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_SizingMethod(const BSTR bstrSizingMethod)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr  = S_OK;
    int     i   = 0;

    if (NULL == bstrSizingMethod)
    {
        hr = E_POINTER;

        goto done;
    }

    for ( ; i < (int)SIZINGMETHOD_MAX ; i++)
    {
        if (!_wcsicmp(s_astrSizingMethods[i], bstrSizingMethod))
        {
            m_eSizingMethod = (SIZINGMETHOD)i;

            SetDirty();

            goto done;
        }
    }

    hr = E_INVALIDARG;

done:

    return hr;
}
//  CDXTMatrix::put_SizingMethod, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_FilterType, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_FilterType(BSTR * pbstrFilterType)
{
    DXAUTO_OBJ_LOCK;

    if (!pbstrFilterType)
    {
        return E_POINTER;
    }

    if (*pbstrFilterType != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrFilterType = SysAllocString(s_astrFilterTypes[m_eFilterType]);

    if (NULL == *pbstrFilterType)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTMatrix::get_FilterType, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_FilterType, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_FilterType(const BSTR bstrFilterType)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr  = S_OK;
    int     i   = 0;

    if (NULL == bstrFilterType)
    {
        hr = E_POINTER;

        goto done;
    }

    for ( ; i < (int)FILTERTYPE_MAX ; i++)
    {
        if (!_wcsicmp(s_astrFilterTypes[i], bstrFilterType))
        {
            m_eFilterType = (FILTERTYPE)i;

            SetDirty();

            goto done;
        }
    }

    hr = E_INVALIDARG;

done:

    return hr;
}
//  CDXTMatrix::put_FilterType, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_DoNearestNeighbourRow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::_DoNearestNeighbourRow(DXSAMPLE * psampleRowBuffer, DXFPOINT * pflpt, 
                                 long cSamples)
{
    _ASSERT(psampleRowBuffer);
    _ASSERT(pflpt);

    float       fldx    = m_matrixInverted.eM11;
    float       fldy    = m_matrixInverted.eM21;
    long        i       = 0;

    // TODO:  This method will work fine when we convert to using a direct 
    //        pointer to the input pixels in certain cases.  Just remove the
    //        "+ 1"s. 

    for ( ; i < cSamples ; i++)
    {
        if ((pflpt->x >= -0.5F) 
            && (pflpt->x < (float)m_sizeInput.cx - 0.5F) 
            && (pflpt->y >= -0.5F) 
            && (pflpt->y < ((float)m_sizeInput.cy - 0.5F)))
        {
            // Round to the nearest pixel and use that.

            // Note:  the array buffer index is off by 1 in both X and Y 
            // directions.

            long x = (long)(pflpt->x + 0.5F) + 1;
            long y = (long)(pflpt->y + 0.5F) + 1;
        
            psampleRowBuffer[i] = m_apsampleRows[y][x];
        }
        else
        {
            psampleRowBuffer[i] = 0;
        }
        
        // There is a potential for drift here with very large images and 
        // certain matrices.

        pflpt->x += fldx;
        pflpt->y += fldy;
    }

    return S_OK;
}
//  CDXTMatrix::_DoNearestNeighbourRow


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_DoBilinearRow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::_DoBilinearRow(DXSAMPLE * psampleRowBuffer, DXFPOINT * pflpt, 
                         long cSamples)
{
    _ASSERT(psampleRowBuffer);
    _ASSERT(pflpt);

    float   fldx    = m_matrixInverted.eM11;
    float   fldy    = m_matrixInverted.eM21;
    float   flInt   = 0.0F;
    long    i       = 0;

    // Bilinear resampling: the one-pixel frame at the four edges of the 
    // surface automatically takes care of the anti-aliasing at the edge.

    for ( ; i < cSamples ; i++)
    {
        if ((pflpt->x >= -1.0F) 
            && (pflpt->x < (float)m_sizeInput.cx) 
            && (pflpt->y >= -1.0F) 
            && (pflpt->y < (float)m_sizeInput.cy))
        {
            // Note:  the array buffer index is off by 1 in both X and Y 
            //        directions, hence the "+ 1"s.

            BYTE    byteWeightX = (BYTE)(modf(pflpt->x + 1, &flInt) * 255.0F);
            long    x           = (long)flInt;

            BYTE    byteWeightY = (BYTE)(modf(pflpt->y + 1, &flInt) * 255.0F);
            long    y           = (long)flInt;
      
            DXSAMPLE sampleT = _DXWeightedAverage2(m_apsampleRows[y][x + 1], 
                                                   m_apsampleRows[y][x], 
                                                   byteWeightX);

            DXSAMPLE sampleB = _DXWeightedAverage2(m_apsampleRows[y + 1][x + 1],
                                                   m_apsampleRows[y + 1][x], 
                                                   byteWeightX);

            psampleRowBuffer[i] = _DXWeightedAverage2(sampleB, sampleT, 
                                                      byteWeightY);
        }
        else
        {
            psampleRowBuffer[i] = 0;
        }

        // There is a potential for drift here with very large images and 
        // certain matrices.

        pflpt->x += fldx;
        pflpt->y += fldy;
    }

    return S_OK;
}
//  CDXTMatrix::_DoBilinearRow


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_SetMatrixValue
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::_SetMatrixValue(MATRIX_VALUE eMatrixValue, const float flValue)
{
    _ASSERT(eMatrixValue < MATRIX_VALUE_MAX);

    if ((&m_matrix.eM11)[eMatrixValue] != flValue)
    {
        // Update the matrix.

        (&m_matrix.eM11)[eMatrixValue] = flValue;

        _CreateInvertedMatrix();

        SetDirty();
    }

    return S_OK;
}
//  CDXTMatrix::_SetMatrixValue


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_CreateInvertedMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::_CreateInvertedMatrix()
{
    HRESULT hr = S_OK;

    CDX2DXForm  matrixTemp = m_matrix;

    if (AUTO_EXPAND == m_eSizingMethod) 
    {
        DXFPOINT    flptOffset;
        DXFPOINT    flptIn;
        DXFPOINT    flptOut;

        // Top/Left

        flptIn.x = 0.0F;
        flptIn.y = 0.0F;

        matrixTemp.TransformPoints(&flptIn, &flptOffset, 1);

        // Bottom/Left

        flptIn.y = (float)(m_sizeInput.cy - 1);

        matrixTemp.TransformPoints(&flptIn, &flptOut, 1);

        flptOffset.x = min(flptOffset.x, flptOut.x);
        flptOffset.y = min(flptOffset.y, flptOut.y);

        // Top/Right

        flptIn.x = (float)(m_sizeInput.cx - 1);
        flptIn.y = 0.0;

        matrixTemp.TransformPoints(&flptIn, &flptOut, 1);

        flptOffset.x = min(flptOffset.x, flptOut.x);
        flptOffset.y = min(flptOffset.y, flptOut.y);

        // Bottom/Right

        flptIn.y = (float)(m_sizeInput.cy - 1);

        matrixTemp.TransformPoints(&flptIn, &flptOut, 1);

        flptOffset.x = min(flptOffset.x, flptOut.x);
        flptOffset.y = min(flptOffset.y, flptOut.y);

        matrixTemp.eDx = matrixTemp.eDx - flptOffset.x;
        matrixTemp.eDy = matrixTemp.eDy - flptOffset.y;
    }

    m_fInvertedMatrix = matrixTemp.Invert();

    m_matrixInverted = matrixTemp;

    return hr;
}
//  CDXTMatrix::_CreateInvertedMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_UnpackInputSurface
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::_UnpackInputSurface()
{
    HRESULT hr  = S_OK;
    int     i   = 0;

    CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

    _ASSERT(InputSurface());
    _ASSERT(m_apsampleRows);
    _ASSERT(m_asampleBuffer);

    hr = InputSurface()->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                     __uuidof(IDXARGBReadPtr), 
                                     (void**)&spDXARGBReadPtr, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    for (i = 0 ; i < m_sizeInput.cy ; i++)
    {
        spDXARGBReadPtr->MoveToRow(i);

        spDXARGBReadPtr->Unpack(&m_apsampleRows[i + 1][1], m_sizeInput.cx, 
                                FALSE);
    }

done:

    return hr;
}
//  CDXTMatrix::_UnpackInputSurface
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\motionblur.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       motionblur.h
//
//  Description:    The declaration of the motion blur transform class.
//
//  Change History:
//  1999/10/26  a-matcal    Created.
//  1999/11/19  a-matcal    Changed color members of CSumNode to ULONGs instead
//                          of WORDs.  With only 255 pixels of white, the sum
//                          node would overflow, giving sometimes interesting
//                          results, mostly just ugly ones though.  Also do 
//                          calculations using doubles instead of floats now.
//
//------------------------------------------------------------------------------

#ifndef __DXTMOTIONBLUR_H_
#define __DXTMOTIONBLUR_H_

#include "resource.h"   




class CSumNode
{
public:

    CSumNode *  pNext;
    int         cSamples;

    ULONG       Red;
    ULONG       Green;
    ULONG       Blue;
    ULONG       Alpha;

    CSumNode() : pNext(NULL), cSamples(0), Red(0), Green(0), Blue(0), 
                 Alpha(0) {}

    void ZeroSumNode() 
    { 
        Blue = 0; Green = 0; Red = 0; Alpha = 0; cSamples = 0; 
    }

    void AddSample(const DXSAMPLE & sample);
    void SubtractSample(const DXSAMPLE & sample);
    void CalcSample(DXSAMPLE * psampleOut, const long nStrength);
    void CalcWeightedSample(DXSAMPLE * psampleOut, 
                            const DXSAMPLE & sampleWeight, 
                            const long nStrength);
};


class CRowNode
{
public:

    CRowNode *  pNext;
    DXSAMPLE *  pSamples;

    CRowNode() : pNext(NULL), pSamples(NULL) {}

    // A CRowNode does not allocate memory for its samples and will not delete
    // them either.  The user of a CRowNode should do this.
};


class CBlurBuffer
{
private:

    CSumNode *  m_pSumNodes;
    CRowNode *  m_pRowNodes;
    DXSAMPLE *  m_psamples;

    long        m_cRowNodes;
    long        m_nOutputWidth;
    long        m_nStrength;
    short       m_nDirection;

    unsigned    m_fInitialized : 1;

    STDMETHOD_(void, _FreeAll)();
    STDMETHOD_(void, _GenerateStructure)();

public:

    CBlurBuffer() : m_pSumNodes(NULL), m_pRowNodes(NULL), m_psamples(NULL),
                    m_cRowNodes(0), m_nOutputWidth(0), m_nStrength(0), 
                    m_nDirection(0), m_fInitialized(NULL) {}

    virtual ~CBlurBuffer() { _FreeAll(); }

    STDMETHOD(Initialize)(const short nDirection, const long nStrength, 
                          const long nOutputWidth);

    STDMETHOD_(void, GetSumNodePointers)(CSumNode ** ppSumNodeFirstCol,
                                         CSumNode ** ppSumNodeFirstAdd,
                                         const CDXDBnds bndsDo);

    inline 
    STDMETHOD_(void, Clear)()
    {
        ZeroMemory(m_psamples, m_nOutputWidth * m_cRowNodes * sizeof(DXSAMPLE));

        if (m_pSumNodes)
        {
            CSumNode * pSumNodeCur = &m_pSumNodes[0];

            do
            {
                pSumNodeCur->ZeroSumNode();

                pSumNodeCur = pSumNodeCur->pNext;
            }
            while (pSumNodeCur != &m_pSumNodes[0]);
        }
    }

    inline 
    STDMETHOD_(void, GetFirstSumNode)(CSumNode ** ppSumNodeFirst)
    {
        *ppSumNodeFirst = &m_pSumNodes[0];
    }

    inline 
    STDMETHOD_(void, GetFirstRowNode)(CRowNode ** ppRowNodeFirst)
    {
        *ppRowNodeFirst = &m_pRowNodes[0];
    }
};

    
class ATL_NO_VTABLE CDXTMotionBlur : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTMotionBlur, &CLSID_DXTMotionBlur>,
    public IDispatchImpl<IDXTMotionBlur, &IID_IDXTMotionBlur, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTMotionBlur>,
    public IObjectSafetyImpl2<CDXTMotionBlur>,
    public IPersistPropertyBagImpl<CDXTMotionBlur>,
    public IPersistStorageImpl<CDXTMotionBlur>,
    public IDXTClipOrigin
{
private:

    CComPtr<IUnknown>   m_cpUnkMarshaler;

    CBlurBuffer *       m_pblurbuffer;

    SIZE                m_sizeInput;
    SIZE                m_sizeOutput;

    long                m_nStrength;
    short               m_nDirection;

    unsigned            m_fAdd      : 1;
    unsigned            m_fSetup    : 1;

    STDMETHOD(_CreateNewBuffer)(const short nDirection, const long nStrength, 
                                const long nOutputWidth);

    STDMETHOD(_DetermineBnds)(CDXDBnds & bnds, long nStrength, long nDirection);

    STDMETHOD(_WorkProcHorizontal)(const CDXTWorkInfoNTo1 & WI, 
                                   CDXDBnds &               bndsInput, 
                                   IDXARGBReadPtr *         pInput,
                                   IDXARGBReadWritePtr *    pOutput,
                                   BOOL *                   pfContinue);

    STDMETHOD(_WorkProcVertical)  (const CDXTWorkInfoNTo1 & WI, 
                                   CDXDBnds &               bndsInput, 
                                   IDXARGBReadPtr *         pInput,
                                   IDXARGBReadWritePtr *    pOutput,
                                   BOOL *                   pfContinue);
public:

    CDXTMotionBlur();
    virtual ~CDXTMotionBlur();

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTMOTIONBLUR)
    DECLARE_POLY_AGGREGATABLE(CDXTMotionBlur)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTMotionBlur)
        COM_INTERFACE_ENTRY(IDXTMotionBlur)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTClipOrigin)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTMotionBlur>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTMotionBlur)
        PROP_ENTRY("add",       DISPID_DXTMOTIONBLUR_ADD,       CLSID_DXTMotionBlurPP)
        PROP_ENTRY("direction", DISPID_DXTMOTIONBLUR_DIRECTION, CLSID_DXTMotionBlurPP)
        PROP_ENTRY("strength",  DISPID_DXTMOTIONBLUR_STRENGTH,  CLSID_DXTMotionBlurPP)
        PROP_PAGE(CLSID_DXTMotionBlurPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT DetermineBnds(CDXDBnds & Bnds);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTClipOrigin methods.

    STDMETHOD(GetClipOrigin)(DXVEC * pvecClipOrigin);

    // IDXTMotionBlur properties.

    STDMETHOD(get_Add)(VARIANT_BOOL * pfAdd);
    STDMETHOD(put_Add)(VARIANT_BOOL fAdd);
    STDMETHOD(get_Direction)(short * pnDirection);
    STDMETHOD(put_Direction)(short nDirection);
    STDMETHOD(get_Strength)(long * pnStrength);
    STDMETHOD(put_Strength)(long nStrength);
};


//+-----------------------------------------------------------------------------
//
//  CSumNode::AddSample
//
//------------------------------------------------------------------------------
inline void
CSumNode::AddSample(const DXSAMPLE & sample)
{
    if (sample.Alpha)
    {
        cSamples++;

        Red     += sample.Red;
        Blue    += sample.Blue;
        Green   += sample.Green;
        Alpha   += sample.Alpha;
    }
}
//  CSumNode::AddSample


//+-----------------------------------------------------------------------------
//
//  CSumNode::SubtractSample
//
//------------------------------------------------------------------------------
inline void
CSumNode::SubtractSample(const DXSAMPLE & sample)
{
    // TODO:  This assert is firing during the horizontal case.
    // _ASSERT(cSamples);

    if (sample.Alpha)
    {
        cSamples--;

        Red     -= sample.Red;
        Blue    -= sample.Blue;
        Green   -= sample.Green;
        Alpha   -= sample.Alpha;
    }
}
//  CSumNode::SubtractSample


//+-----------------------------------------------------------------------------
//
//  CSumNode::CalcSample
//
//------------------------------------------------------------------------------
inline void
CSumNode::CalcSample(DXSAMPLE * psampleOut, long nStrength)
{
    _ASSERT(psampleOut);

    if (cSamples)
    {
        double dblDiv = 1.0F / (double)cSamples;

        psampleOut->Red     = (BYTE)((double)Red   * dblDiv);
        psampleOut->Green   = (BYTE)((double)Green * dblDiv);
        psampleOut->Blue    = (BYTE)((double)Blue  * dblDiv);
        psampleOut->Alpha   = (BYTE)((double)Alpha / (double)nStrength);
    }
    else
    {
        *((DWORD *)psampleOut) = 0;
    }
}
//  CSumNode::CalcSample


//+-----------------------------------------------------------------------------
//
//  CSumNode::CalcWeightedSample
//
//------------------------------------------------------------------------------
inline void
CSumNode::CalcWeightedSample(DXSAMPLE * psampleOut, 
                             const DXSAMPLE & sampleWeight, 
                             const long nStrength)
{
    _ASSERT(psampleOut);

    if (cSamples)
    {
        double dblDiv = 1.0F / (double)cSamples;

        if (sampleWeight.Alpha)
        {
            psampleOut->Red     = (BYTE)((sampleWeight.Red   
                                          + (short)((double)Red   * dblDiv)) / 2);
            psampleOut->Green   = (BYTE)((sampleWeight.Green 
                                          + (short)((double)Green * dblDiv)) / 2);
            psampleOut->Blue    = (BYTE)((sampleWeight.Blue  
                                          + (short)((double)Blue  * dblDiv)) / 2);
        }
        else
        {
            psampleOut->Red     = (BYTE)((double)Red   * dblDiv);
            psampleOut->Green   = (BYTE)((double)Green * dblDiv);
            psampleOut->Blue    = (BYTE)((double)Blue  * dblDiv);
        }

        psampleOut->Alpha   = (BYTE)((sampleWeight.Alpha 
                                      + (short)((double)Alpha / (double)nStrength)) / 2);
    }
    else
    {
        *((DWORD *)psampleOut) = 0;
    }
}
//  CSumNode::CalcWeightedSample


#endif //__DXTMOTIONBLUR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\motionblur.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       motionblur.cpp
//
//  Description:    The motion blur transform class.
//
//  Change History:
//  1999/10/26  a-matcal    Created.
//  1999/11/19  a-matcal    The wrong information was being sent by put_Strength
//                          and put_Direction to _CreateNewBuffer which would
//                          cause a crash in drastic cases, and bad rendering
//                          in most cases.
//          
//                          Also made a fix to the horizontal case where it
//                          would sometimes add pixels to the sum node when
//                          nAddIndex was out of bounds.  This was causing bad
//                          rendering in certain cases.  (Oddly, I never
//                          witnessed a crash.)
//  1999/12/03  a-matcal    Changed default blur direction to 270 instead of 90.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "motionblur.h"




//+-----------------------------------------------------------------------------
//
//  CBlurBuffer::Initialize
//
//------------------------------------------------------------------------------
STDMETHODIMP
CBlurBuffer::Initialize(const short nDirection, const long nStrength, 
                        const long nOutputWidth)
{
    if (1 == nStrength)
    {
        return S_OK;
    }

    m_cRowNodes = nStrength;

    // If this is a purely horizontal blur, we only need one row node, and
    // we don't need any sum nodes.

    if ((90 == nDirection) || (270 == nDirection))
    {
        m_cRowNodes = 1;
    }
    else
    {
        m_pSumNodes = new CSumNode[nOutputWidth];

        if (!m_pSumNodes)
        {
            _FreeAll();

            return E_OUTOFMEMORY;
        }
    }

    m_pRowNodes = new CRowNode[m_cRowNodes];
    m_psamples  = new DXSAMPLE[nOutputWidth * m_cRowNodes];

    if (!m_pRowNodes || !m_psamples)
    {
        _FreeAll();

        return E_OUTOFMEMORY;
    }

    m_nOutputWidth  = nOutputWidth;
    m_nDirection    = nDirection;
    m_nStrength     = nStrength;

    _GenerateStructure();

    return S_OK;
}
//  CBlurBuffer::Initialize


//+-----------------------------------------------------------------------------
//
//  CBlurBuffer::GetSumNodePointers
//
//------------------------------------------------------------------------------
void 
CBlurBuffer::GetSumNodePointers(CSumNode ** ppSumNodeFirstCol,
                                CSumNode ** ppSumNodeFirstAdd,
                                const CDXDBnds bndsDo)
{
    *ppSumNodeFirstCol = &m_pSumNodes[0];

    if ((m_nDirection > 0) && (m_nDirection < 180)) // Right
    {
        *ppSumNodeFirstAdd = &m_pSumNodes[max(0, 
                                      (m_nStrength - 1) - bndsDo.Left())];
    }
    else if ((m_nDirection > 180) && (m_nDirection < 360)) // Left
    {
        *ppSumNodeFirstAdd = &m_pSumNodes[max(0,  
                  (m_nStrength - 1) - (m_nOutputWidth - bndsDo.Right()))];
    }
    else // Vertical
    {
        *ppSumNodeFirstAdd = &m_pSumNodes[0];
    }
}
//  CBlurBuffer::GetSumNodePointers


//+-----------------------------------------------------------------------------
//
//  CBlurBuffer::_FreeAll
//
//------------------------------------------------------------------------------
void
CBlurBuffer::_FreeAll()
{
    delete [] m_pSumNodes; 
    delete [] m_pRowNodes; 
    delete [] m_psamples;

    m_pSumNodes = NULL;
    m_pRowNodes = NULL;  
    m_psamples  = NULL;
}
//  CBlurBuffer::_FreeAll


//+-----------------------------------------------------------------------------
//
//  CBlurBuffer::_GenerateStructure
//
//------------------------------------------------------------------------------
void
CBlurBuffer::_GenerateStructure()
{
    int i = 0;

    if (m_pSumNodes)
    {
        // Create sum nodes list structure.

        m_pSumNodes[m_nOutputWidth - 1].pNext = &m_pSumNodes[0];

        for (i = 0 ; i < (m_nOutputWidth - 1) ; i++)
        {
            m_pSumNodes[i].pNext = &m_pSumNodes[i + 1];
        }
    }

    // Create row nodes list structure.

    m_pRowNodes[m_cRowNodes - 1].pNext = &m_pRowNodes[0];

    for (i = 0 ; i < (m_cRowNodes - 1) ; i++)
    {
        m_pRowNodes[i].pNext = &m_pRowNodes[i + 1];
    }

    // Associate sample memory with row nodes.

    for (i = 0 ; i < m_cRowNodes ; i++)
    {
        m_pRowNodes[i].pSamples = &m_psamples[i * m_nOutputWidth];
    }
}
//  CBlurBuffer::_GenerateStructure


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::CDXTMotionBlur
//
//------------------------------------------------------------------------------
CDXTMotionBlur::CDXTMotionBlur() :
    m_pblurbuffer(NULL),
    m_nStrength(5),
    m_nDirection(270),
    m_fAdd(true),
    m_fSetup(false)
{
    m_sizeInput.cx  = 0;
    m_sizeInput.cy  = 0;

    m_sizeOutput.cx = 0;
    m_sizeOutput.cy = 0;

    // Base class members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;

    // Due to the the row caching method and other complexities of this 
    // transform, multithreaded rendering would be more complex than it's worth.
    // This keeps the number of threads down to 1.

    m_ulMaxImageBands   = 1;
}
//  CDXTMotionBlur::CDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::~CDXTMotionBlur
//
//------------------------------------------------------------------------------
CDXTMotionBlur::~CDXTMotionBlur()
{
    delete m_pblurbuffer;
}
//  CDXTMotionBlur::~CDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                               &m_cpUnkMarshaler.p);
}
//  CDXTMotionBlur::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::DetermineBnds, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::DetermineBnds(CDXDBnds & Bnds)
{
    return _DetermineBnds(Bnds, m_nStrength, m_nDirection);
}
//  CDXTMotionBlur::DetermineBnds, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                                ULONG ulInIndex, DXBNDS * pInBounds)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsInput;

    if ((NULL == pOutBounds) || (NULL == pInBounds))
    {
        hr = E_POINTER;

        goto done;
    }

    if (ulOutIndex || ulInIndex)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    *pInBounds = *pOutBounds;

    // If the blur direction isn't purely up or down, we'll have an X offset to
    // consider.  It works out that if we just subtract (m_nStrength - 1) from
    // the minimum X bound and then intersect with the input bounds, we'll
    // have the correct X bounds.

    if ((m_nDirection != 0) && (m_nDirection != 180))
    {
        pInBounds->u.D[DXB_X].Min -= m_nStrength - 1;
    }

    // Same idea as the X bound above except we test to see that the blur
    // direciton isn't purley left or right.

    if ((m_nDirection != 90) && (m_nDirection != 270))
    {
        pInBounds->u.D[DXB_Y].Min -= m_nStrength - 1;
    }

    // Intersect with input surface bounds.

    bndsInput.SetXYSize(m_sizeInput);

    ((CDXDBnds *)pInBounds)->IntersectBounds(bndsInput);

done:

    return hr;
}
//  CDXTMotionBlur::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::OnSetup(DWORD dwFlags)
{
    HRESULT         hr      = S_OK;
    CDXDBnds        bndsIn;
    CDXDBnds        bndsOut;

    m_fSetup = false;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsOut = bndsIn;

    DetermineBnds(bndsOut);

    hr = _CreateNewBuffer(m_nDirection, m_nStrength, bndsOut.Width());

    if (FAILED(hr))
    {
        goto done;
    }

    bndsIn.GetXYSize(m_sizeInput);
    bndsOut.GetXYSize(m_sizeOutput);

    m_fSetup = true;

done:

    return hr;
} 
//  CDXTMotionBlur::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr          = S_OK;
    int     x           = 0;
    int     y           = 0;

    CSumNode *  pSumNodeFirstAdd    = NULL;
    CSumNode *  pSumNodeFirstCol    = NULL;
    CSumNode *  pSumNodeCur         = NULL;
    CRowNode *  pRowNodeFar         = NULL;
    CRowNode *  pRowNodeCur         = NULL;

    CDXDBnds    bndsInput;

    CComPtr<IDXARGBReadPtr>         spInput;
    CComPtr<IDXARGBReadWritePtr>    spOutput;

    // When strength is equal to 1, the transform doesn't actually do anything.

    if (1 == m_nStrength)
    {
        DWORD dwFlags = 0;

        if (DoOver())
        {
            dwFlags |= DXBOF_DO_OVER;
        }

        if (DoDither())
        {
            dwFlags |= DXBOF_DITHER;
        }

        hr = DXBitBlt(OutputSurface(), WI.OutputBnds,
                      InputSurface(), WI.DoBnds,
                      dwFlags, m_ulLockTimeOut);

        goto done;
    }

    // Get the input surface portion needed to calculate the requested DoBnds.

    hr = MapBoundsOut2In(0, &WI.DoBnds, 0, &bndsInput);

    if (FAILED(hr))
    {
        goto done;
    }

    // Clear out the sample rows and nodes.

    m_pblurbuffer->Clear();

    // Lock input surface.

    hr = InputSurface()->LockSurface(&bndsInput, m_ulLockTimeOut, DXLOCKF_READ,
                                     __uuidof(IDXARGBReadPtr), 
                                     (void **)&spInput, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Lock output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, 
                                      __uuidof(IDXARGBReadWritePtr),
                                      (void **)&spOutput, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Call appropriate WorkProc.

    if ((90 == m_nDirection) || (270 == m_nDirection))
    {
        hr = _WorkProcHorizontal(WI, bndsInput, spInput, spOutput, pbContinue);
    }
    else
    {
        hr = _WorkProcVertical(WI, bndsInput, spInput, spOutput, pbContinue);
    }

done:

    return hr;
} 
//  CDXTMotionBlur::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                              CDXDVec & InVec)
{
    HRESULT hr          = S_OK;
    CDXDVec vecInPoint;

    ulInputIndex = 0;

    if (GetNumInputs() == 0 || NULL == InputSurface())
    {
        hr = E_FAIL;

        goto done;
    }

    OutPoint.GetMinVector(vecInPoint);

    if ((m_nDirection > 180) && (m_nDirection < 360))
    {
        vecInPoint.u.D[DXB_X] -= (m_nStrength - 1);
    }

    if ((m_nDirection > 90) && (m_nDirection < 270))
    {
        vecInPoint.u.D[DXB_Y] -= (m_nStrength - 1);
    }

    if ((vecInPoint.u.D[DXB_X] >= m_sizeInput.cx)
        || (vecInPoint.u.D[DXB_X] < 0)
        || (vecInPoint.u.D[DXB_Y] >= m_sizeInput.cy)
        || (vecInPoint.u.D[DXB_Y] < 0))
    {
        // Out of bounds, say that we hit the output, but no input surface is 
        // related.

        hr = DXT_S_HITOUTPUT;
    }
    else
    {
        // We have a valid input point.

        CDXDBnds    bndsLock(vecInPoint);
        CDXDVec     vecCurrent;
        CDXDVec     vecMax;
        DXSAMPLE    sample;
        int         nXInc   = 1;
        int         nYInc   = 1;
        int         nAlpha  = 0;

        CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

        // This is our input point.  

        InVec = vecInPoint;

        // Expand useful bounds in the x direction.

        if ((m_nDirection > 0) && (m_nDirection < 180))
        {
            // Blur to the right, so look at pixels to the left.

            bndsLock.u.D[DXB_X].Min -= (m_nStrength - 1);
            bndsLock.u.D[DXB_X].Min = max(bndsLock.u.D[DXB_X].Min, 0); 
        }
        else if ((m_nDirection > 180) && (m_nDirection < 360))
        {
            // Blur to the left, so look at pixels to the right.

            bndsLock.u.D[DXB_X].Max += (m_nStrength - 1);
            bndsLock.u.D[DXB_X].Max = min(bndsLock.u.D[DXB_X].Max, 
                                          m_sizeInput.cx);
        }
        else
        {
            nXInc = 0;
        }

        // Expand useful bounds in the y direction.

        if ((m_nDirection > 90) && (m_nDirection < 270))
        {
            // Blur down, so look at pixels above.

            bndsLock.u.D[DXB_Y].Min -= (m_nStrength - 1);
            bndsLock.u.D[DXB_Y].Min = max(bndsLock.u.D[DXB_Y].Min, 0); 
        }
        else if ((m_nDirection < 90) || (m_nDirection > 270))
        {
            // Blur up, so look at pixels below.

            bndsLock.u.D[DXB_Y].Max += (m_nStrength - 1);
            bndsLock.u.D[DXB_Y].Max = min(bndsLock.u.D[DXB_Y].Max, 
                                          m_sizeInput.cy);
        }
        else
        {
            nYInc = 0;
        }

        bndsLock.GetMinVector(vecCurrent);
        bndsLock.GetMaxVector(vecMax);

        // Lock entire input surface so we don't have to do any offset 
        // calculations.

        hr = InputSurface()->LockSurface(NULL, INFINITE, DXLOCKF_READ,
                                         __uuidof(IDXARGBReadPtr),
                                         (void **)&spDXARGBReadPtr,
                                         NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        // Reset to S_OK, just in case LockSurface changed it.

        hr = S_OK;

        // Now walk vecCurrent up to vecMax;

        while ((vecCurrent.u.D[DXB_X] < vecMax.u.D[DXB_X])
               && (vecCurrent.u.D[DXB_Y] < vecMax.u.D[DXB_Y]))
        {
            spDXARGBReadPtr->MoveToXY(vecCurrent.u.D[DXB_X], 
                                      vecCurrent.u.D[DXB_Y]);

            spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

            if ((vecCurrent == vecInPoint) && m_fAdd)
            {
                nAlpha += sample.Alpha * m_nStrength;
            }
            else
            {
                nAlpha += sample.Alpha;
            }

            vecCurrent.u.D[DXB_X] += nXInc;
            vecCurrent.u.D[DXB_Y] += nYInc;
        }
        
        // Check the output pixel for transparency.

        if (m_fAdd)
        {
            if (0 == (nAlpha / ((m_nStrength * 2) - 1)))
            {
                hr = S_FALSE;
            }
        }
        else
        {
            if (0 == (nAlpha / m_nStrength))
            {
                hr = S_FALSE;
            }
        }
    }

done:

    return hr;
}
//  CDXTMotionBlur::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::GetClipOrigin, IDXTClipOrigin
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::GetClipOrigin(DXVEC * pvecClipOrigin)
{
    if (NULL == pvecClipOrigin)
    {
        return E_POINTER;
    }

    // X offset.

    if (m_nDirection > 180)
    {
        pvecClipOrigin->u.D[DXB_X] = m_nStrength - 1;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_X] = 0;
    }

    // Y offset.

    if ((m_nDirection < 90) || (m_nDirection > 270))
    {
        pvecClipOrigin->u.D[DXB_Y] = m_nStrength - 1;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_Y] = 0;
    }

    return S_OK;
}
//  CDXTMotionBlur::GetClipOrigin, IDXTClipOrigin


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::get_Add, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::get_Add(VARIANT_BOOL * pfAdd)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (NULL == pfAdd)
    {
        hr = E_POINTER;

        goto done;
    }

    *pfAdd = m_fAdd ? VARIANT_TRUE : VARIANT_FALSE;

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::put_Add, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::put_Add(VARIANT_BOOL fAdd)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if ((fAdd != VARIANT_TRUE) && (fAdd != VARIANT_FALSE))
    {
        hr = E_INVALIDARG;

        goto done;
    }

    // If we're already set this way, just return.

    if ((m_fAdd && (VARIANT_TRUE == fAdd))
        || (!m_fAdd && (VARIANT_FALSE == fAdd)))
    {
        goto done;
    }

    m_fAdd = !m_fAdd;

    SetDirty();

done:

    return hr;
}
//  CDXTMotionBlur::put_Add, IDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::get_Direction, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::get_Direction(short * pnDirection)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (NULL == pnDirection)
    {
        hr = E_POINTER;

        goto done;
    }

    *pnDirection = m_nDirection;

done:

    return hr;
}
//  CDXTMotionBlur::get_Direction, IDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::put_Direction, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::put_Direction(short nDirection)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    nDirection = nDirection % 360;

    if (nDirection < 0)
    {
        nDirection = 360 + nDirection;
    }

    if (m_nDirection != nDirection)
    {
        if (m_fSetup)
        {
            CDXDBnds bnds;

            hr = InputSurface()->GetBounds(&bnds);

            if (FAILED(hr))
            {
                goto done;
            }

            // What would the output size be with this new property setting?

            hr = _DetermineBnds(bnds, m_nStrength, nDirection);

            if (FAILED(hr))
            {
                goto done;
            }

            hr = _CreateNewBuffer(nDirection, m_nStrength, bnds.Width());

            if (FAILED(hr))
            {
                goto done;
            }

            // Save output size to our member variable.

            bnds.GetXYSize(m_sizeOutput);
        }

        m_nDirection = nDirection;

        SetDirty();
    }

done:

    return hr;
}
//  CDXTMotionBlur::put_Direction, IDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::get_Strength, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::get_Strength(long * pnStrength)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (NULL == pnStrength)
    {
        hr = E_POINTER;

        goto done;
    }

    *pnStrength = m_nStrength;

done:

    return hr;
}
//  CDXTMotionBlur::get_Strength, IDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::put_Strength, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::put_Strength(long nStrength)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (nStrength < 1)
    {
        nStrength = 1;
    }

    if (m_nStrength != nStrength)
    {
        if (m_fSetup)
        {
            CDXDBnds bnds;

            hr = InputSurface()->GetBounds(&bnds);

            if (FAILED(hr))
            {
                goto done;
            }

            // What would the output size be with this new property setting?

            hr = _DetermineBnds(bnds, nStrength, m_nDirection);

            if (FAILED(hr))
            {
                goto done;
            }

            hr = _CreateNewBuffer(m_nDirection, nStrength, bnds.Width());

            if (FAILED(hr))
            {
                goto done;
            }

            // Save output size to our member variable.

            bnds.GetXYSize(m_sizeOutput);
        }

        m_nStrength = nStrength;

        SetDirty();
    }

done:

    return hr;
}
//  CDXTMotionBlur::put_Strength, IDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::_CreateNewBuffer
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::_CreateNewBuffer(const short nDirection, const long nStrength, 
                                 const long nOutputWidth)
{
    HRESULT hr = S_OK;

    CBlurBuffer * pblurbufferNew = new CBlurBuffer;

    if (NULL == pblurbufferNew)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    hr = pblurbufferNew->Initialize(nDirection, nStrength, nOutputWidth);

    if (FAILED(hr))
    {
        goto done;
    }

    delete m_pblurbuffer;

    m_pblurbuffer = pblurbufferNew;

done:

    if (FAILED(hr))
    {
        delete pblurbufferNew;
    }

    return hr;
}
//  CDXTMotionBlur::_CreateNewBuffer


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::_DetermineBnds
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::_DetermineBnds(CDXDBnds & bnds, long nStrength,
                               long nDirection)
{
    // Horizontal bounds.

    if ((nDirection != 0) && (nDirection != 180))
    {
        bnds.u.D[DXB_X].Max += nStrength - 1;
    }

    // Vertical bounds.

    if ((nDirection != 90) && (nDirection != 270))
    {
        bnds.u.D[DXB_Y].Max += nStrength - 1;
    }

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::_WorkProcHorizontal
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::_WorkProcHorizontal(const CDXTWorkInfoNTo1 &    WI, 
                                    CDXDBnds &                  bndsInput, 
                                    IDXARGBReadPtr *            pInput,
                                    IDXARGBReadWritePtr *       pOutput,
                                    BOOL *                      pfContinue)
{
    HRESULT hr              = S_OK;
    int     y               = 0;
    int     i               = 0;
    int     cDoHeight       = WI.DoBnds.Height();
    int     cDoWidth        = WI.DoBnds.Width();
    int     cInWidth        = bndsInput.Width();

    int     nAddIndex       = 0;
    int     nCurIndex       = 0;
    int     nOutIndex       = 0;
    int     nUnpackIndex    = 0;
    int     nInc            = 0;

    CRowNode *  pRowNode    = NULL;
    CSumNode    sumnode;

    DXDITHERDESC dxdd;

    DXSAMPLE *      psampleBuffer           = DXSAMPLE_Alloca(cDoWidth);
    DXBASESAMPLE *  psampleBufferScratch    = DXBASESAMPLE_Alloca(cDoWidth);

    // Get a row node for our use.

    m_pblurbuffer->GetFirstRowNode(&pRowNode);

    // Set up dither structure.

    if (DoDither())
    {
        dxdd.x                  = WI.OutputBnds.Left();
        dxdd.y                  = WI.OutputBnds.Top();
        dxdd.pSamples           = psampleBuffer;
        dxdd.cSamples           = cDoWidth;
        dxdd.DestSurfaceFmt     = OutputSampleFormat();
    }

    // Row loop

    for (y = 0 ; (y < cDoHeight) && *pfContinue ; y++)
    {
        if (90 == m_nDirection) // Blur to the right.
        {
            nAddIndex       = WI.DoBnds.Right() - 1;
            nCurIndex       = nAddIndex;
            nOutIndex       = cDoWidth - 1;
            nUnpackIndex    = bndsInput.Left();

            nInc      = -1;
        }
        else // Blur to the left.
        {
            nAddIndex       = WI.DoBnds.Left();
            nCurIndex       = nAddIndex;
            nOutIndex       = 0;
            nUnpackIndex    = bndsInput.Left() + (m_nStrength - 1);

            nInc      = 1;
        }

        // Go the correct input row and unpack the needed samples to a good 
        // place in the row node's sample buffer.

        pInput->MoveToRow(y);
        pInput->Unpack(&pRowNode->pSamples[nUnpackIndex], cInWidth, FALSE);

        // We need to prime the sumnode with (m_nStrength - 1) samples to get
        // it ready to calculate output samples.

        for (i = 1 ; i < m_nStrength ; i++)
        {
            if ((nAddIndex >= 0) && (nAddIndex < m_sizeOutput.cx))
            {
                sumnode.AddSample(pRowNode->pSamples[nAddIndex]);
            }

            nAddIndex += nInc;
        }
            
        // Calculate the output samples.

        for (i = 0 ; i < cDoWidth ; i++)
        {
            // If nAddIndex is a valid index, add the far sample to our sumnode.
            // This sample will be the one (m_nStrength - 1) pixels away from 
            // the current pixel.

            if ((nAddIndex >= 0) && (nAddIndex < m_sizeOutput.cx))
            {
                sumnode.AddSample(pRowNode->pSamples[nAddIndex]);
            }

            // Calculate the output sample value.
            // TODO:  move check for m_fAdd outside of loop.

            if (m_fAdd)
            {
                sumnode.CalcWeightedSample(&psampleBuffer[nOutIndex],
                                           pRowNode->pSamples[nCurIndex],
                                           m_nStrength);
            }
            else
            {
                sumnode.CalcSample(&psampleBuffer[nOutIndex], m_nStrength);
            }

            // Subtract the current pixel from the sumnode since it won't be
            // used to calculate the next pixel.
            
            sumnode.SubtractSample(pRowNode->pSamples[nCurIndex]);

            nAddIndex += nInc;
            nCurIndex += nInc;
            nOutIndex += nInc;
        }

        // Clear values in sum node.

        sumnode.ZeroSumNode();

        // Move to the correct output row.

        pOutput->MoveToRow(y);

        // Dither

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        // Over or Pack the samples.

        if (DoOver())
        {
            DXPMSAMPLE * ppmsamples = DXPreMultArray(psampleBuffer, cDoWidth);

            pOutput->OverArrayAndMove(psampleBufferScratch, ppmsamples, 
                                      cDoWidth);
        }
        else
        {
            pOutput->PackAndMove(psampleBuffer, cDoWidth);
        }
    } // Row loop

    return hr;
}
//  CDXTMotionBlur::_WorkProcHorizontal


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::_WorkProcVertical
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::_WorkProcVertical(const CDXTWorkInfoNTo1 &  WI, 
                                  CDXDBnds &                bndsInput, 
                                  IDXARGBReadPtr *          pInput,
                                  IDXARGBReadWritePtr *     pOutput,
                                  BOOL *                    pfContinue)
{
    HRESULT hr              = S_OK;

    int     cDoHeight       = WI.DoBnds.Height();
    int     cDoWidth        = WI.DoBnds.Width();
    int     cInWidth        = bndsInput.Width();
    int     cInHeight       = bndsInput.Height();

    // Iterator variables.

    int     i               = 0;
    int     j               = 0;

    int     nsrcCurX        = 0;
    int     nsrcX           = 0;
    int     nsrcY           = 0;
    int     ndstX           = 0;
    int     ndstY           = 0;

    // cPrimerRows  The number of rows needed to be gathered from the input 
    //              before the method can start processing output rows.  This
    //              can vary depending on the location of the do bounds 
    //              within the output bounds.
    //
    //  nsrcStartX  This is the index of the first sample in the buffer row 
    //              needed to calculate each row in this method.  
    //
    //  nsrcStartY  This is the y coordinate of the first row needed from the
    //              locked input area for use in this method.
    //
    //  nsrcOffsetX This is the index of the first sample in the buffer row that
    //              should be "added" to the first output pixel calculated in
    //              each row when m_fAdd is set.
    //
    //  nsrcPackX   This is the index of the first element in our row buffer
    //              that should be filled with the first pixel unpacked.  We may
    //              offset the unpacking to leave some clear pixels for use at
    //              various times and so we won't have to do too much bounds 
    //              checking.
    //
    //  ndstStartX  This is the index of the first sample in psampleBuffer that
    //              will be calculated for each row.
    //
    //  ndstStartY  This is the y coordinate of the first row of the locked
    //              ouput area that will be calculated by this method.
    //
    //  fRotateSumNodes To simplify the the calculation of blurs with left or
    //                  right vectors, we set this flag to true and rotate the
    //                  some nodes after calculating each row.

    int     cPrimerRows     = 0;
    int     nsrcStartX      = 0;
    int     nsrcStartY      = 0;
    int     nsrcOffsetX     = 0;
    int     nsrcPackX       = 0;
    int     ndstStartX      = 0;
    int     ndstStartY      = 0;

    int     nIncX           = 0;
    int     nIncY           = 0;

    bool    fRotateSumNodes = false;

    CRowNode *      pRowNodeCur             = NULL;
    CRowNode *      pRowNodeFar             = NULL;
    CSumNode *      pSumNodeFirstAdd        = NULL;
    CSumNode *      pSumNodeFirstCol        = NULL;

    DXDITHERDESC dxdd;

    DXSAMPLE *      psampleBuffer           = DXSAMPLE_Alloca(cDoWidth);
    DXBASESAMPLE *  psampleBufferScratch    = DXBASESAMPLE_Alloca(cDoWidth);

    // Vertical setup.

    if ((m_nDirection > 90) && (m_nDirection < 270)) // Down
    {
        nsrcStartY  = cInHeight - 1;
        ndstStartY  = cDoHeight - 1;


        cPrimerRows = min(m_sizeOutput.cy - WI.DoBnds.Bottom(), 
                          (m_nStrength - 1));

        nIncY       = -1;
    }
    else // Up
    {
        nsrcStartY  = 0;
        ndstStartY  = 0;

        cPrimerRows = min(WI.DoBnds.Top(), m_nStrength - 1);

        nIncY       = 1;
    }

    // Horizontal setup.

    if (m_nDirection > 180) // Left
    {
        nsrcPackX   = m_nStrength - 1;
        nsrcStartX  = nsrcPackX + cInWidth - 1;
        ndstStartX  = cDoWidth - 1;
        nsrcOffsetX = nsrcPackX + (cInWidth - 1) 
                      - min(m_sizeOutput.cx - WI.DoBnds.Right(), m_nStrength - 1);
        nIncX       = -1;

        fRotateSumNodes = true;
    }
    else if ((m_nDirection > 0) && (m_nDirection < 180)) // Right
    {
        nsrcPackX   = 0;
        nsrcStartX  = 0;
        ndstStartX  = 0;
        nsrcOffsetX = min(WI.DoBnds.Left(), (m_nStrength - 1));
        nIncX       = 1;

        fRotateSumNodes = true;
    }
    else // Vertical
    {
        nsrcPackX   = 0;
        nsrcStartX  = 0;
        ndstStartX  = 0;
        nsrcOffsetX = 0;
        nIncX       = 1;

        fRotateSumNodes = false;
    }

    // Get a row node for our use.

    m_pblurbuffer->GetFirstRowNode(&pRowNodeFar);

    // Get sum nodes for our use.

    m_pblurbuffer->GetSumNodePointers(&pSumNodeFirstCol, 
                                      &pSumNodeFirstAdd,
                                      WI.DoBnds);
    
    // Set up dither structure.

    if (DoDither())
    {
        dxdd.x                  = WI.OutputBnds.Left();
        dxdd.y                  = nIncY == 1 ? WI.OutputBnds.Top() 
                                               : WI.OutputBnds.Bottom();
        dxdd.pSamples           = psampleBuffer;
        dxdd.cSamples           = cDoWidth;
        dxdd.DestSurfaceFmt     = OutputSampleFormat();
    }

    // We need to prime the row nodes with (m_nStrength - 1) rows of data to get
    // them ready to calculate output samples.

    nsrcX = nsrcStartX;
    nsrcY = nsrcStartY;
    ndstX = ndstStartX;
    ndstY = ndstStartY;

    for (i = 0 ; (i < cPrimerRows) && *pfContinue ; i++)
    {
        CSumNode * pSumNodeTempAdd = pSumNodeFirstAdd;

        if ((nsrcY >= 0) && (nsrcY < cInHeight))
        {
            pInput->MoveToRow(nsrcY);
            pInput->Unpack(&pRowNodeFar->pSamples[nsrcPackX], cInWidth, FALSE);

            for (nsrcX = nsrcStartX, j = 0 ; j < cInWidth ; nsrcX += nIncX, j++)
            {
                pSumNodeTempAdd->AddSample(pRowNodeFar->pSamples[nsrcX]);

                pSumNodeTempAdd = pSumNodeTempAdd->pNext;
            }
        }

        if (fRotateSumNodes)
        {
            pSumNodeFirstCol->ZeroSumNode();

            pSumNodeFirstAdd = pSumNodeFirstAdd->pNext;
            pSumNodeFirstCol = pSumNodeFirstCol->pNext;
        }

        pRowNodeFar = pRowNodeFar->pNext;
        nsrcY      += nIncY;
    }

    // Set current row node.

    pRowNodeCur = pRowNodeFar->pNext;

    // Row loop

    for (i = 0 ; (i < cDoHeight) && *pfContinue ; i++)
    {
        CSumNode * pSumNodeTempCol = pSumNodeFirstCol;
        CSumNode * pSumNodeTempAdd = pSumNodeFirstAdd;

        if ((nsrcY >= 0) && (nsrcY < cInHeight))
        {
            pInput->MoveToRow(nsrcY);
            pInput->Unpack(&pRowNodeFar->pSamples[nsrcPackX], cInWidth, FALSE);

            for (nsrcX = nsrcStartX, j = 0 ; j < cInWidth ; nsrcX += nIncX, j++)
            {
                pSumNodeTempAdd->AddSample(pRowNodeFar->pSamples[nsrcX]);

                pSumNodeTempAdd = pSumNodeTempAdd->pNext;
            }
        }

        // Calculate the output samples.

        for (nsrcCurX = nsrcOffsetX, ndstX = ndstStartX, j = 0 
             ; j < cDoWidth 
             ; nsrcCurX += nIncX, ndstX += nIncX, j++)
        {
            if (m_fAdd)
            {
                pSumNodeTempCol->CalcWeightedSample(&psampleBuffer[ndstX], 
                                                    pRowNodeCur->pSamples[nsrcCurX],
                                                    m_nStrength);
            }
            else
            {
                pSumNodeTempCol->CalcSample(&psampleBuffer[ndstX], m_nStrength);
            }

            if (nsrcCurX >= 0)
            {
                pSumNodeTempCol->SubtractSample(pRowNodeCur->pSamples[nsrcCurX]);
            }

            pSumNodeTempCol = pSumNodeTempCol->pNext;
        }

        // Move to the correct output row.

        pOutput->MoveToRow(ndstY);

        // Dither.

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y += nIncY;
        }

        // Over or Pack the samples.

        if (DoOver())
        {
            DXPMSAMPLE * ppmsamples = DXPreMultArray(psampleBuffer, cDoWidth);

            pOutput->OverArrayAndMove(psampleBufferScratch, ppmsamples, 
                                      cDoWidth);
        }
        else
        {
            pOutput->PackAndMove(psampleBuffer, cDoWidth);
        }

        if (fRotateSumNodes)
        {
            pSumNodeFirstCol->ZeroSumNode();

            pSumNodeFirstAdd = pSumNodeFirstAdd->pNext;
            pSumNodeFirstCol = pSumNodeFirstCol->pNext;
        }

        pRowNodeFar = pRowNodeFar->pNext;
        pRowNodeCur = pRowNodeFar->pNext;

        nsrcY += nIncY;
        ndstY += nIncY;
    } // Row loop

    return hr;
}
//  CDXTMotionBlur::_WorkProcVertical
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\pixelate.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//  Filename:   pixelate.cpp
//
//  Overview:   Implementation of a pixelate DXTransform.
//
//  Change History:
//  2000/04/13  mcalkins    Code cleanup, NoOp optimization fix.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "Pixelate.h"

// Functions for doing WorkProc color averaging in the 2 input case.

static DXPMSAMPLE
_DoPixelateBlock_TwoInputs(DXPMSAMPLE * pSrc1, DXPMSAMPLE *pSrc2,
                           int nBoxWidth, int nBoxHeight, ULONG uOtherWeight,
                           int cbStride1, int cbStride2);
static DXPMSAMPLE
_DoPixelateBlockMMX_TwoInputs(DXPMSAMPLE * pSrc1, DXPMSAMPLE *pSrc2,
                              int nBoxWidth, int nBoxHeight, ULONG uOtherWeight,
                              int cbStride1, int cbStride2);

// Functions for doing WorkProc color averaging in the 1 input case.

static DXPMSAMPLE
_DoPixelateBlock_OneInput(DXPMSAMPLE *pSrc, int nBoxWidth, int nBoxHeight,
                          int cbStride);
static DXPMSAMPLE
_DoPixelateBlockMMX_OneInput(DXPMSAMPLE *pSrc, int nBoxWidth, int nBoxHeight,
                             int cbStride);

// Is MMX available?

extern CDXMMXInfo g_MMXDetector;




//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::CPixelate
//
//------------------------------------------------------------------------------
CPixelate::CPixelate() :
    m_fNoOp(false),
    m_fOptimizationPossible(false),
    m_nMaxSquare(50),
    m_nPrevSquareSize(0),
    m_pfnOneInputFunc(NULL),
    m_pfnTwoInputFunc(NULL)
{
    m_sizeInput.cx      = 0;
    m_sizeInput.cy      = 0;

    // CDXTBaseNTo1 members.

    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 1;
    m_Progress          = 1.0f;

    // If we're on the X86, we'll try asking the MMX detector if there's MMX instructions and if so
    // we'll set our WorkProc() helper functions to the MMX versions. The CDXMMXInfo object will correctly
    // tell us that there's no MMX even if we're *not* on X86, but we go the extra step to hardcode the fact
    // that we know it's a waste of time to even ask.

#ifdef _X86_
    if (g_MMXDetector.MinMMXOverCount() == 0xFFFFFFFF)
    {
#endif // _X86_
        m_pfnOneInputFunc = _DoPixelateBlock_OneInput;
        m_pfnTwoInputFunc = _DoPixelateBlock_TwoInputs;
#ifdef _X86_
    }
    else
    {
        m_pfnOneInputFunc = _DoPixelateBlockMMX_OneInput;
        m_pfnTwoInputFunc = _DoPixelateBlockMMX_TwoInputs;
    }
#endif // _X86_
}
//  Method: CPixelate::CPixelate


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT CPixelate::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(),
                                         &m_spUnkMarshaler.p);
}
//  Method: CPixelate::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::OnSetup, CDXTBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT CPixelate::OnSetup(DWORD /*dwFlags*/)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bnds;

    hr = InputSurface()->GetBounds(&bnds);

    if (FAILED(hr))
    {
        goto done;
    }

    bnds.GetXYSize(m_sizeInput);

done:

    m_fOptimizationPossible = false;

    return hr;
}
//  Method: CPixelate::OnSetup, CDXTBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::OnGetSurfacePickOrder, CDXTBaseNTo1
//
//------------------------------------------------------------------------------
void
CPixelate::OnGetSurfacePickOrder(const CDXDBnds & /*BndsPoint*/,
                                 ULONG & ulInToTest, ULONG aInIndex[],
                                 BYTE aWeight[])
{
    ulInToTest  = 1;
    aWeight[0]  = 255;
    aInIndex[0] = 0;

    if (HaveInput(1))
    {
        if (m_Progress < 0.5)
        {
            if (m_Progress > 0.25f)
            {
                aWeight[0] = (BYTE)((m_Progress - 0.25f) * 255.1f * 2.0f);
                aWeight[1] = DXInvertAlpha(aWeight[0]);
                aInIndex[1] = 1;
                ulInToTest = 2;
            }
        }
        else
        {
            aInIndex[0] = 1;
            if (m_Progress < 0.75f)
            {
                aWeight[0] = (BYTE)((0.75 - m_Progress) * 255.1f * 2.0f);
                aWeight[1] = DXInvertAlpha(aWeight[0]);
                aInIndex[1] = 0;
                ulInToTest = 2;
            }
        }
        aWeight[1] = DXInvertAlpha(aWeight[0]);
    }
}
//  Method: CPixelate::OnGetSurfacePickOrder, CDXTBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::OnInitInstData, CDXTBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CPixelate::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    long nSquareSize = 1 + (long)(((float)(m_nMaxSquare) - 0.0001f)
                                  * m_Progress);

    if (   !m_fOptimizationPossible
        || (nSquareSize != m_nPrevSquareSize)
        || IsInputDirty(0)
        || (HaveInput(1) ? IsInputDirty(1) : false)
        || IsOutputDirty()
        || IsTransformDirty()
        || DoOver())
    {
        m_fNoOp             = false;
        m_nPrevSquareSize   = nSquareSize;
    }
    else
    {
        m_fNoOp = true;
    }

    if (   (WI.DoBnds.Width()  == (ULONG)m_sizeInput.cx)
        && (WI.DoBnds.Height() == (ULONG)m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

    return S_OK;
}
//  Method: CPixelate::OnInitInstData, CDXTBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::WorkProc, CDXTBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT CPixelate::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
{
    HRESULT     hr          = S_OK;
    ULONG       SourceSurf  = 0;
    float       prog        = m_Progress;
    BYTE        OtherWeight = 0;

    if (m_fNoOp)
    {
        // TODO:  Move all local variables to the top of the function so we can
        //        use the "goto done" syntax.

        return S_OK;
    }

    if (HaveInput(1))
    {
        if (prog >= 0.5f)
        {
            if (prog < 0.75f)
            {
                OtherWeight = (BYTE)((0.75f - prog) * 255.1f * 2.0f);
            }
            prog = (1.0f - prog);
            SourceSurf = 1;
        }
        else
        {
            if (prog > 0.25f)
            {
                OtherWeight = (BYTE)((prog - 0.25f) * 255.1f * 2.0f);
            }
        }
        prog *= 2.0f;
    }

    long Square = 1 + (ULONG)((((float)(m_nMaxSquare)) - 0.0001f) * prog);

    if (Square < 2)
    {
        return DXBitBlt(OutputSurface(), WI.OutputBnds,
                        InputSurface(SourceSurf), WI.DoBnds,
                        m_dwBltFlags, m_ulLockTimeOut);
    }

    //
    //  Always lock the entire source for reading
    //
    CComPtr<IDXARGBReadPtr> pSrc;

    hr = InputSurface(SourceSurf)->LockSurface(NULL, m_ulLockTimeOut,
                                               DXLOCKF_READ,
                                               IID_IDXARGBReadPtr,
                                               (void**)&pSrc, NULL);

    if (FAILED(hr))
    {
        return hr;
    }

    CComPtr<IDXARGBReadPtr> pSrcOther;

    if (OtherWeight)
    {
        hr = InputSurface((SourceSurf + 1) % 2)->LockSurface(NULL,
                                                             m_ulLockTimeOut,
                                                             DXLOCKF_READ,
                                                             IID_IDXARGBReadPtr,
                                                             (void**)&pSrcOther, NULL);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    CComPtr<IDXARGBReadWritePtr> pDest;

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut,
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr,
                                      (void**)&pDest, NULL);

    if (FAILED(hr))
    {
        return hr;
    }

    BOOL bDoOver = m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT;

    RECT rectOut;
    rectOut.left = rectOut.top = 0;
    rectOut.right = m_sizeInput.cx;
    rectOut.bottom = m_sizeInput.cy;

    RECT DoRect;
    WI.DoBnds.GetXYRect(DoRect);

    long cbRowWidth = Square * sizeof(DXPMSAMPLE);
    // Find SquareBytes mod 8
    long nPadding = 8 - (cbRowWidth & 7);

    if (nPadding == 8)
        nPadding = 0;

    // Find width rounded up to nearest multiple of 8
    long nWidth = (cbRowWidth + 7) & ~(7);

    // Allocate our pitched rows and an extra 8 pixels so we can adjust the pointer to
    // QWord alignment
    long nBytesToAlloc = (nWidth * Square) + 8;

    DXPMSAMPLE *pBuff = (DXPMSAMPLE *)alloca(nBytesToAlloc);
    DXPMSAMPLE *pOtherBuff = (DXPMSAMPLE *)alloca(nBytesToAlloc);

    // Adjust the pointers to QWord alignment by rounding up to nearest multiple of 8
    pBuff = (DXPMSAMPLE *)((INT_PTR)((BYTE *)pBuff + 7) & ~(7));
    pOtherBuff = (DXPMSAMPLE *)((INT_PTR)((BYTE *)pOtherBuff + 7) & ~(7));

    long CenterX = (m_sizeInput.cx / 2) - (Square / 2);
    long CenterY = (m_sizeInput.cy / 2) - (Square / 2);


    DXPACKEDRECTDESC prd1;
    DXPACKEDRECTDESC prd2;


    prd1.pSamples = pBuff;
    prd1.bPremult = TRUE;
    prd1.lRowPadding = nPadding / sizeof(DXPMSAMPLE);

    prd2.pSamples = pOtherBuff;
    prd2.bPremult = TRUE;
    prd2.lRowPadding = nPadding / sizeof(DXPMSAMPLE);

    long StartX = (CenterX % Square);
    long StartY = (CenterY % Square);

    if (StartX)
    {
        StartX -= Square;
    }
    if (StartY)
    {
        StartY -= Square;
    }

    for (long y = StartY; y < DoRect.bottom; y += Square)
    {
        //
        //  Do a quick clipping check -- If the output region does not contain
        //  the rows then skip.
        //
        if (y + Square > DoRect.top)
        {
            for (long x = StartX; x < m_sizeInput.cx; x += Square)
            {
                DXPMSAMPLE  Color;
                RECT        r;
                RECT        rectOutClipped;

                r.left = x; r.right = x+Square;
                r.top = y; r.bottom = y+Square;

                IntersectRect(&prd1.rect, &r, &rectOut);

                if (IntersectRect(&rectOutClipped, &prd1.rect, &DoRect))
                {
                    long    lWidth = (prd1.rect.right - prd1.rect.left);
                    long    lHeight = (prd1.rect.bottom - prd1.rect.top);

                    // Set the padding to be the remainder to move to the next QWord boundary after
                    // one row of the rectangle.  QWord boundaries are important for the MMX optimizations
                    // we've made because they allow us to move more quickly through the data.
                    long cbRectWidth = (lWidth * sizeof(DXPMSAMPLE));


                    DXNATIVETYPEINFO    nti;
                    DXNATIVETYPEINFO    nti2;
                    DXSAMPLEFORMATENUM  format;
                    DXSAMPLEFORMATENUM  format2;
                    DXPMSAMPLE *pData = NULL;
                    DXPMSAMPLE *pData2 = NULL;
                    long    cbRowStride;
                    long    cbRowStride2;


                    format = pSrc->GetNativeType(&nti);

                    if (format == DXPF_PMARGB32 && !DoOver() && NULL != nti.pFirstByte)
                    {
                        pData = (DXPMSAMPLE *)(nti.pFirstByte + (nti.lPitch * prd1.rect.top) + (prd1.rect.left * sizeof(DXPMSAMPLE)));
                        cbRowStride = nti.lPitch;
                    }
                    else
                    {
                        prd1.lRowPadding = (cbRectWidth & 7) ? ((8 - (cbRectWidth & 7)) / sizeof(DXPMSAMPLE)) : 0;
                        pSrc->UnpackRect(&prd1);
                        pData = pBuff;
                        cbRowStride = (cbRectWidth + 7) & ~(7);
                    }

                    if (OtherWeight)
                    {
                        format2 = pSrcOther->GetNativeType(&nti2);
                        CopyRect(&prd2.rect, &prd1.rect);

                        if (format2 == DXPF_PMARGB32 && !DoOver() && NULL != nti2.pFirstByte)
                        {
                            pData2 = (DXPMSAMPLE *)(nti2.pFirstByte + (nti2.lPitch * prd2.rect.top) + (prd2.rect.left * sizeof(DXPMSAMPLE)));
                            cbRowStride2 = nti2.lPitch;
                        }
                        else
                        {
                            prd2.lRowPadding = (cbRectWidth & 7) ? ((8 - (cbRectWidth & 7)) / sizeof(DXPMSAMPLE)) : 0;
                            pSrcOther->UnpackRect(&prd2);
                            pData2 = pOtherBuff;
                            cbRowStride2 = (cbRectWidth + 7) & ~(7);
                        }

                        Color = (*m_pfnTwoInputFunc)(pData, pData2, lWidth, lHeight, OtherWeight,
                                                     cbRowStride, cbRowStride2);
                    }
                    else
                    {
                        Color = (*m_pfnOneInputFunc)(pData, lWidth, lHeight, cbRowStride);
                    }

                    if (Color.Alpha || (!bDoOver))
                    {
                        rectOutClipped.left -= DoRect.left;
                        rectOutClipped.right -= DoRect.left;
                        rectOutClipped.top -= DoRect.top;
                        rectOutClipped.bottom -= DoRect.top;
                        pDest->FillRect(&rectOutClipped, Color, bDoOver);
                    }
                }
            }
        }
    }
    return hr;
}
//  Method: CPixelate::WorkProc, CDXTBaseNTo1

//+-----------------------------------------------------------------------------
//
//  CBarn::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CPixelate::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    // Calling IsOutputDirty() clears the dirty state we just caused by writing
    // to the output in WorkProc().

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CPixelate::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::put_MaxSquare, IDXPixelate
//
//------------------------------------------------------------------------------
STDMETHODIMP
CPixelate::put_MaxSquare(int newVal)
{
    DXAUTO_OBJ_LOCK;

    if (newVal < 2 || newVal > 50)
    {
        return E_INVALIDARG;
    }

    if (m_nMaxSquare != newVal)
    {
        m_nMaxSquare = newVal;
        SetDirty();
    }

    return S_OK;
}
//  Method: CPixelate::put_MaxSquare, IDXPixelate


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::get_MaxSquare, IDXPixelate
//
//------------------------------------------------------------------------------
STDMETHODIMP
CPixelate::get_MaxSquare(int * pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }

    *pVal = m_nMaxSquare;

    return S_OK;
}
//  Method: CPixelate::get_MaxSquare, IDXPixelate


//////////////////////////////////////////////////////////////////////////////////
//
// PIXELATE_MMX_VALS
//
// Simple structure to represent the values that get stored to memory from the
// two quadwords that were holding the summed pixel values. The ordering is
// crucial here. The MMX quadword registers were storing AAAAAAAA RRRRRRRR and
// GGGGGGGG BBBBBBBB but in the packing, the DWORD's get swapped. Therefore the
// ordering becomes Red, Alpha, Blue, Green.

struct PIXELATE_MMX_VALS
{
    DWORD   Red;
    DWORD   Alpha;
    DWORD   Blue;
    DWORD   Green;
};

//////////////////////////////////////////////////////////////////////////////////
//

static DXPMSAMPLE
_DoPixelateBlockMMX_TwoInputs(DXPMSAMPLE * pSrc1, DXPMSAMPLE *pSrc2,
                              int nBoxWidth, int nBoxHeight, ULONG uOtherWeight,
                              int cbStride1, int cbStride2)
{
#if defined(_X86_)        // (In other words, use MMX)

    _ASSERT(g_MMXDetector.MinMMXOverCount() != 0xFFFFFFFF);

    // Calculate pointers that are at the beginning of the last row so we can move backwards
    // through the block of memory.
    DXPMSAMPLE  *pSrcEnd1 = (DXPMSAMPLE *)((BYTE *)pSrc1 + ((nBoxHeight-1) * cbStride1));
    DXPMSAMPLE  *pSrcEnd2 = (DXPMSAMPLE *)((BYTE *)pSrc2 + ((nBoxHeight-1) * cbStride2));

    PIXELATE_MMX_VALS   rgMMXOutputs[2];

    if (nBoxWidth > 0 && nBoxHeight > 0)
    {
        __asm
        {
            // Setup our pointers into memory for building the first image's average
            mov     ebx,pSrcEnd1        // Read pointer base
            mov     edx,80000000h       // Set high bit to indicate first pass
            mov     edi,cbStride1       // Number of bytes to back up the base pointer in ebx

StartOfBlock:
            mov     eax,nBoxHeight      // Number of rows (height)
            mov     esi,nBoxWidth       // Store width here for quick access in the future

            ///////////////////////////////////////////////////////
            // Register Layout
            //
            // eax  Count of rows remaining
            // ebx  Base pointer to current row start
            // ecx  Count of 8-pixel blocks per row
            //  dx  Count of leftover pixels per row (0 <= dx <= 8)
            //      (High bit of edx tracks first vs. second source. 1 for first source, zero for second)
            // esi  Extra copy of nBoxWidth to use in refreshing counters
            // edi  Row stride -- amount to subtract from ebx to move up one row
            //
            // mm0  Zero (constant)
            // mm1  Temp storage
            // mm2  Temp storage
            // mm3  Temp storage
            // mm4  Temp storage
            // mm5  Stores high-order DWORD's of running total (AAAA AAAA  RRRR RRRR)
            // mm6  Stores low-order DWORD's of running total  (BBBB BBBB  GGGG GGGG)
            // mm7  Accumulator for running total within a row

            pxor        mm0,mm0         // 0000 0000  0000 0000
            pxor        mm5,mm5         // AAAA AAAA  RRRR RRRR
            pxor        mm6,mm6         // BBBB BBBB  GGGG GGGG

StartOfRow:
            // Setup these counters which get destroyed in the processing of the row
            mov     ecx,esi
            mov     dx,si
            and     dx, 7               // Number of extra pixels beyond nearest multiple of 8
            and     ecx, 0fffffff8h     // Number of pixels rounded down to mult of 8

            shl     ecx,2               // Multiply by four to turn into a pointer offset

            pxor        mm7,mm7         // Running total for this row

// Do the first straggler pixels
            push    ebx
            add     ebx,ecx
            shl     dx,2                // Turn nStragglers into a byte count

            // Add (nStragglers-2)*sizeof(DXPMSAMPLE) to the base pointer in ebx
            push    edx
            and     edx,7fffffffh
            sub     edx,8               // Move back 2 pixels (8 bytes)
            add     ebx,edx
            pop     edx

StragglerLoop:
            cmp     dx,4
            jle     StragglerSingle

            movq        mm1,[ebx]
            sub     dx,8
            sub     ebx,8

            movq        mm2,mm1
            punpcklbw   mm1,mm0
            punpckhbw   mm2,mm0
            paddusw     mm7,mm1
            paddusw     mm7,mm2

            jmp StragglerLoop

StragglerSingle:
            cmp     dx,0
            je      StragglerEnd

            mov     ebx,dword ptr [ebx+4]

            movd        mm1,ebx
            punpcklbw   mm1,mm0
            paddusw     mm7,mm1

StragglerEnd:
            pop ebx
            cmp     ecx,0                   // Check to see if there are any 8-pixel blocks to do
            jle     FinishedRow             // If not, jump past the "GoLikeCrazy" loop

GoLikeCrazy:
            movq        mm1,[ebx+ecx-8]     // 1.01
            sub     ecx,32                  // Setup ecx for loop invariant below

            movq        mm2,mm1             // 1.02
            punpcklbw   mm1,mm0             // 1.03
            punpckhbw   mm2,mm0             // 1.04
            movq        mm3,[ebx+ecx+16]    // 2.01
            paddusw     mm7,mm1             // 1.05
            paddusw     mm7,mm2             // 1.06

            movq        mm4,mm3             // 2.02
            punpcklbw   mm3,mm0             // 2.03
            punpckhbw   mm4,mm0             // 2.04
            movq        mm1,[ebx+ecx+8]     // 3.01
            paddusw     mm7,mm3             // 2.05
            paddusw     mm7,mm4             // 2.06

            movq        mm2,mm1             // 3.02
            punpcklbw   mm1,mm0             // 3.03
            punpckhbw   mm2,mm0             // 3.04
            movq        mm3,[ebx+ecx]       // 4.01
            paddusw     mm7,mm1             // 3.05
            paddusw     mm7,mm2             // 3.06

            movq        mm4,mm3             // 4.02
            punpcklbw   mm3,mm0             // 4.03
            punpckhbw   mm4,mm0             // 4.04
            paddusw     mm7,mm3             // 4.05
            paddusw     mm7,mm4             // 4.06

            jnz GoLikeCrazy     // Zero flag state comes from "sub ecx,32" above

FinishedRow:
            // Pack two low-order WORD's into DWORD temp storage in mm5
            // Pack two high-order WORD's into DWORD temp storage in mm6

            movq        mm3,mm7
            punpckhwd   mm3,mm0
            punpcklwd   mm7,mm0

            // Accumulate those DWORD's to the running total in mm3 and mm4

            paddd       mm5,mm3     // High
            paddd       mm6,mm7     // Low

            sub     ebx,edi
            dec     eax
            jnz     StartOfRow

//FinishedBlock:

            // The high bit of edx tells us whether this is the first pass (set) or the second
            // pass. If first, setup for second and loop. Else, finish the function.

            test    edx,80000000h
            jz      FinishedBoth    // Fall through if the flag is still set

//(Finished first block summation)
            // Store our accumulated sums of A,R,G,B to two DWORDs
            movq        [rgMMXOutputs],mm5
            movq        [rgMMXOutputs+8],mm6

            // Clear flag, set source pointer and stride, and loop to top
            and     edx,7fffffffh
            mov     ebx,pSrcEnd2
            mov     edi,cbStride2

            jmp StartOfBlock

FinishedBoth:
            // Store our accumulated sums of A,R,G,B to two DWORDs
            movq        [rgMMXOutputs+16],mm5
            movq        [rgMMXOutputs+24],mm6

            EMMS    // Das Ende

        } // End of __asm block
    }

    ULONG   cSamps = (ULONG)(nBoxHeight * nBoxWidth);

    DXPMSAMPLE  color1((BYTE)(rgMMXOutputs[0].Alpha / cSamps),
                       (BYTE)(rgMMXOutputs[0].Red / cSamps),
                       (BYTE)(rgMMXOutputs[0].Green / cSamps),
                       (BYTE)(rgMMXOutputs[0].Blue / cSamps));

    DXPMSAMPLE  color2((BYTE)(rgMMXOutputs[1].Alpha / cSamps),
                       (BYTE)(rgMMXOutputs[1].Red / cSamps),
                       (BYTE)(rgMMXOutputs[1].Green / cSamps),
                       (BYTE)(rgMMXOutputs[1].Blue / cSamps));

    return DXScaleSample(color1, (BYTE)DXInvertAlpha((BYTE)uOtherWeight)) +
           DXScaleSample(color2, (BYTE)uOtherWeight);

#else // !defined(_X86_)

    // This function should only be called on X86 platforms that might have MMX
    _ASSERT(false);
    return DXPMSAMPLE(0,0,0,0);

#endif // !defined(_X86_)

} // _DoPixelateBlockMMX_TwoInputs

////////////////////////////////////////////////////////////////////////////////////////////
//
//
static DXPMSAMPLE
_DoPixelateBlockMMX_OneInput(DXPMSAMPLE * pSrc, int nBoxWidth, int nBoxHeight, int cbStride)
{
#if defined(_X86_)        // (In other words, use MMX)

    // We should only have setup the function pointer to call this function if MMX is available
    _ASSERT(g_MMXDetector.MinMMXOverCount() != 0xFFFFFFFF);

    // Calculate pointers that are at the beginning of the last row so we can move backwards
    // through the block of memory.
    DXPMSAMPLE  *pSrcEnd = (DXPMSAMPLE *)((BYTE *)pSrc + ((nBoxHeight-1) * cbStride));

    PIXELATE_MMX_VALS   MMXOutput;

    if (nBoxWidth > 0 && nBoxHeight > 0)
    {
        __asm
        {
            // Setup our pointers into memory for building the first image's average
            mov     ebx,pSrcEnd         // Read pointer base

            mov     eax,nBoxHeight      // Number of rows (height)
            mov     esi,nBoxWidth       // Store width here for quick access in the future

            mov     edi,cbStride        // Number of bytes to back up the base pointer in ebx

            ///////////////////////////////////////////////////////
            // Register Layout
            //
            // eax  Count of rows remaining
            // ebx  Base pointer to current row start
            // ecx  Count of 8-pixel blocks per row
            // edx  Count of leftover pixels per row (0 <= edx <= 8)
            // esi  Extra copy of nBoxWidth to use in refreshing counters
            // edi  Row stride -- amount to subtract from ebx to move up one row
            //
            // mm0  Zero (constant)
            // mm1  Temp storage
            // mm2  Temp storage
            // mm3  Temp storage
            // mm4  Temp storage
            // mm5  Stores high-order DWORD's of running total (AAAA AAAA  RRRR RRRR)
            // mm6  Stores low-order DWORD's of running total  (BBBB BBBB  GGGG GGGG)
            // mm7  Accumulator for running total within a row

            pxor        mm0,mm0         // 0000 0000  0000 0000
            pxor        mm5,mm5         // AAAA AAAA  RRRR RRRR
            pxor        mm6,mm6         // BBBB BBBB  GGGG GGGG

StartOfRow:
            // Setup these counters which get destroyed in the processing of the row
            mov     ecx,esi
            mov     edx,esi
            and     edx,7               // Number of extra pixels beyond nearest multiple of 8
            and     ecx,0fffffff8h      // Number of pixels rounded down to mult of 8

            shl     ecx,2               // Multiply by four to turn into a pointer offset

            pxor        mm7,mm7         // Running total for this row

// Do the first straggler pixels
            push    ebx
            add     ebx,ecx
            shl     edx,2               // Turn nStragglers into a byte count

StragglerLoop:
            cmp     edx,4
            jle     StragglerSingle

            movq        mm1,[ebx+edx-8]
            sub     edx,8

            movq        mm2,mm1
            punpcklbw   mm1,mm0
            punpckhbw   mm2,mm0
            paddusw     mm7,mm1
            paddusw     mm7,mm2

            jmp StragglerLoop

StragglerSingle:
            cmp     edx,0
            je      StragglerEnd

            mov     ebx,dword ptr [ebx]

            movd        mm1,ebx
            punpcklbw   mm1,mm0
            paddusw     mm7,mm1

StragglerEnd:
            pop     ebx
            cmp     ecx,0                   // Check to see if there are any 8-pixel blocks to do
            jle     FinishedRow             // If not, jump past the "GoLikeCrazy" loop

GoLikeCrazy:
            movq        mm1,[ebx+ecx-8]     // 1.01
            sub     ecx,32                  // Setup ecx for loop invariant below

            movq        mm2,mm1             // 1.02
            punpcklbw   mm1,mm0             // 1.03
            punpckhbw   mm2,mm0             // 1.04
            movq        mm3,[ebx+ecx+16]    // 2.01
            paddusw     mm7,mm1             // 1.05
            paddusw     mm7,mm2             // 1.06

            movq        mm4,mm3             // 2.02
            punpcklbw   mm3,mm0             // 2.03
            punpckhbw   mm4,mm0             // 2.04
            movq        mm1,[ebx+ecx+8]     // 3.01
            paddusw     mm7,mm3             // 2.05
            paddusw     mm7,mm4             // 2.06

            movq        mm2,mm1             // 3.02
            punpcklbw   mm1,mm0             // 3.03
            punpckhbw   mm2,mm0             // 3.04
            movq        mm3,[ebx+ecx]       // 4.01
            paddusw     mm7,mm1             // 3.05
            paddusw     mm7,mm2             // 3.06

            movq        mm4,mm3             // 4.02
            punpcklbw   mm3,mm0             // 4.03
            punpckhbw   mm4,mm0             // 4.04
            paddusw     mm7,mm3             // 4.05
            paddusw     mm7,mm4             // 4.06

            jnz GoLikeCrazy     // Zero flag state comes from "sub ecx,32" above

FinishedRow:
            // Pack two low-order WORD's into DWORD temp storage in mm5
            // Pack two high-order WORD's into DWORD temp storage in mm6

            movq        mm3,mm7
            punpckhwd   mm3,mm0
            punpcklwd   mm7,mm0

            // Accumulate those DWORD's to the running total in mm3 and mm4

            paddd       mm5,mm3     // High
            paddd       mm6,mm7     // Low

            sub     ebx,edi
            dec     eax
            jnz     StartOfRow

//FinishedBlock:

            // Store our accumulated sums of A,R,G,B to two DWORDs
            movq        [MMXOutput],mm5
            movq        [MMXOutput+8],mm6

            EMMS    // Das Ende

        } // End of __asm block
    }

    ULONG   cSamps = (ULONG)(nBoxHeight * nBoxWidth);

    DXPMSAMPLE  color((BYTE)(MMXOutput.Alpha / cSamps),
                      (BYTE)(MMXOutput.Red / cSamps),
                      (BYTE)(MMXOutput.Green / cSamps),
                      (BYTE)(MMXOutput.Blue / cSamps));

    return color;

#else // !defined(_X86_)

    // This function should only be called when we're on X86 platforms.
    _ASSERT(false);
    return DXPMSAMPLE(0, 0, 0, 0);

#endif // !defined(_X86_)

} // _DoPixelateBlockMMX_OneInput

//////////////////////////////////////////////////////////////////////////////////
//
//
static DXPMSAMPLE
_DoPixelateBlock_OneInput(DXPMSAMPLE *pSrc, int nBoxWidth, int nBoxHeight, int cbStride)
{
    int cSamps = nBoxWidth * nBoxHeight;

    ULONG Alpha = 0;
    ULONG Red = 0;
    ULONG Green = 0;
    ULONG Blue = 0;

    DXPMSAMPLE *    pRead = pSrc;

    // It works out that to be padded to QWords means that if the number of samples
    // is odd, then 4 padding bytes (1 sample) are added.  If it's even, none are added.
    int     cPadding = nBoxWidth & 1;
    int     nPaddedWidth = nBoxWidth + cPadding;

    for (int i = 0; i < nBoxHeight; i++)
    {
        for (int j = 0; j < nBoxWidth; j++)
        {
            DWORD val = *pRead++;

            Alpha += (val >> 24);
            Red += (BYTE)(val >> 16);
            Green += (BYTE)(val >> 8);
            Blue += (BYTE)(val);
        }
        pRead += cPadding;
    }

    return DXPMSAMPLE((BYTE)(Alpha / cSamps),
                      (BYTE)(Red / cSamps),
                      (BYTE)(Green / cSamps),
                      (BYTE)(Blue / cSamps));
}

//////////////////////////////////////////////////////////////////////////////////
//
//
static DXPMSAMPLE
_DoPixelateBlock_TwoInputs(DXPMSAMPLE *pSrc1, DXPMSAMPLE *pSrc2, int nBoxWidth, int nBoxHeight,
                           ULONG uOtherWeight, int cbStride1, int cbStride2)
{
    int cSamps = nBoxWidth * nBoxHeight;

    ULONG Alpha = 0;
    ULONG Red = 0;
    ULONG Green = 0;
    ULONG Blue = 0;

    DXPMSAMPLE *    pRead = pSrc1;

    // It works out that to be padded to QWords means that if the number of samples
    // is odd, then 4 padding bytes (1 sample) are added.  If it's even, none are added.
    int     cPadding = nBoxWidth & 1;
    int     nPaddedWidth = nBoxWidth + cPadding;
    int     i,j;

    for (i = 0; i < nBoxHeight; i++)
    {
        for (j = 0; j < nBoxWidth; j++)
        {
            DWORD val = *pRead++;

            Alpha += (val >> 24);
            Red += (BYTE)(val >> 16);
            Green += (BYTE)(val >> 8);
            Blue += (BYTE)(val);
        }
        pRead += cPadding;
    }

    DXPMSAMPLE color1((BYTE)(Alpha / cSamps),
                      (BYTE)(Red / cSamps),
                      (BYTE)(Green / cSamps),
                      (BYTE)(Blue / cSamps));

    pRead = pSrc2;
    Alpha = Red = Green = Blue = 0;

    for (i = 0; i < nBoxHeight; i++)
    {
        for (j = 0; j < nBoxWidth; j++)
        {
            DWORD val = *pRead++;

            Alpha += (val >> 24);
            Red += (BYTE)(val >> 16);
            Green += (BYTE)(val >> 8);
            Blue += (BYTE)(val);
        }
        pRead += cPadding;
    }

    DXPMSAMPLE color2((BYTE)(Alpha / cSamps),
                      (BYTE)(Red / cSamps),
                      (BYTE)(Green / cSamps),
                      (BYTE)(Blue / cSamps));

    return DXScaleSample(color1, (BYTE)DXInvertAlpha((BYTE)uOtherWeight)) +
           DXScaleSample(color2, (BYTE)uOtherWeight);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\matrix.h ===
//+-----------------------------------------------------------------------------
//
//  Filename:       matrix.h
//
//  Overview:       Applies a transformation matrix to an image.
//
//  History:
//  10/30/1998      phillu      Created.
//  11/08/1999      a-matcal    Changed from procedural surface to transform.
//                              Changed to IDXTWarp dual interface.
//                              Moved from dxtrans.dll to dxtmsft.dll.
//  2000/02/03      mcalkins    Changed from "warp" to "matrix"
//
//------------------------------------------------------------------------------

#ifndef __MATRIX_H_
#define __MATRIX_H_

#include "resource.h" 
#include <dxtransp.h>
#include <dxtpriv.h>
#include <dxhelper.h>




class ATL_NO_VTABLE CDXTMatrix : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTMatrix, &CLSID_DXTMatrix>,
    public IDispatchImpl<IDXTMatrix, &IID_IDXTMatrix, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTMatrix>,
    public IObjectSafetyImpl2<CDXTMatrix>,
    public IPersistStorageImpl<CDXTMatrix>,
    public IPersistPropertyBagImpl<CDXTMatrix>
{
private:

    CComPtr<IUnknown>           m_spUnkMarshaler;
    CDX2DXForm                  m_matrix;
    CDX2DXForm                  m_matrixInverted;

    SIZE                        m_sizeInput;

    // m_asampleBuffer is a buffer of the entire input image.  Obviously we'll
    // try to get rid of this ASAP.

    DXSAMPLE *                  m_asampleBuffer;

    // m_apsampleRows is an a array of pointers to the rows.  Using this, the
    // samples in m_asampleBuffer can be accessed using the convenient
    // m_apsampleRows[y][x] notation.

    DXSAMPLE **                 m_apsampleRows;

    typedef enum {
        NEAREST = 0,
        BILINEAR,
        CUBIC,
        BSPLINE,
        FILTERTYPE_MAX
    } FILTERTYPE;

    FILTERTYPE                  m_eFilterType;
    static const WCHAR *        s_astrFilterTypes[FILTERTYPE_MAX];

    typedef enum {
        CLIP_TO_ORIGINAL = 0,
        AUTO_EXPAND,
        SIZINGMETHOD_MAX
    } SIZINGMETHOD;

    SIZINGMETHOD                m_eSizingMethod;
    static const WCHAR *        s_astrSizingMethods[SIZINGMETHOD_MAX];

    // m_fInvertedMatrix    True when the current matrix settings are able to be
    //                      inverted.

    unsigned                    m_fInvertedMatrix : 1;

    // If you view CDX2DXForm as an array of floats, these enum values can be
    // used to specify the indices of the values.

    typedef enum {
        MATRIX_M11 = 0,
        MATRIX_M12,
        MATRIX_M21,
        MATRIX_M22,
        MATRIX_DX,
        MATRIX_DY,
        MATRIX_VALUE_MAX
    } MATRIX_VALUE;

    // Helpers.

    float   modf(const float flIn, float * pflIntPortion);
    DWORD   _DXWeightedAverage2(DXBASESAMPLE S1, DXBASESAMPLE S2, 
                                ULONG nWgt);

    // Helpers to calculate one row of transformed pixels.

    STDMETHOD(_DoNearestNeighbourRow)(DXSAMPLE * psampleRowBuffer, 
                                      DXFPOINT * pflpt, long cSamples);
    STDMETHOD(_DoBilinearRow)(DXSAMPLE * psampleRowBuffer,
                              DXFPOINT * pflpt, long cSamples);

    // General Helpers.

    STDMETHOD(_SetMatrixValue)(MATRIX_VALUE eMatrixValue, const float flValue);
    STDMETHOD(_CreateInvertedMatrix)();
    STDMETHOD(_UnpackInputSurface)();
    

public:

    CDXTMatrix();
    virtual ~CDXTMatrix();

    DECLARE_POLY_AGGREGATABLE(CDXTMatrix)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTMATRIX)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTMatrix)
        COM_INTERFACE_ENTRY(IDXTMatrix)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTMatrix>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTMatrix)
        PROP_ENTRY("m11",           DISPID_DXTMATRIX_M11,           CLSID_DXTMatrixPP)
        PROP_ENTRY("m12",           DISPID_DXTMATRIX_M12,           CLSID_DXTMatrixPP)
        PROP_ENTRY("dx",            DISPID_DXTMATRIX_DX,            CLSID_DXTMatrixPP)
        PROP_ENTRY("m21",           DISPID_DXTMATRIX_M21,           CLSID_DXTMatrixPP)
        PROP_ENTRY("m22",           DISPID_DXTMATRIX_M22,           CLSID_DXTMatrixPP)
        PROP_ENTRY("dy",            DISPID_DXTMATRIX_DY,            CLSID_DXTMatrixPP)
        PROP_ENTRY("sizingmethod",  DISPID_DXTMATRIX_SIZINGMETHOD,  CLSID_DXTMatrixPP)
        PROP_ENTRY("filtertype",    DISPID_DXTMATRIX_FILTERTYPE,    CLSID_DXTMatrixPP)
        PROP_PAGE(CLSID_DXTMatrixPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT DetermineBnds(CDXDBnds & Bnds);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTMatrix properties.

    STDMETHOD(get_M11)(float * pflM11);
    STDMETHOD(put_M11)(const float flM11);
    STDMETHOD(get_M12)(float * pflM12);
    STDMETHOD(put_M12)(const float flM12);
    STDMETHOD(get_Dx)(float * pfldx);
    STDMETHOD(put_Dx)(const float fldx);
    STDMETHOD(get_M21)(float * pflM21);
    STDMETHOD(put_M21)(const float flM21);
    STDMETHOD(get_M22)(float * pflM22);
    STDMETHOD(put_M22)(const float flM22);
    STDMETHOD(get_Dy)(float * pfldy);
    STDMETHOD(put_Dy)(const float fldy);
    STDMETHOD(get_SizingMethod)(BSTR * pbstrSizingMethod);
    STDMETHOD(put_SizingMethod)(const BSTR bstrSizingMethod);
    STDMETHOD(get_FilterType)(BSTR * pbstrFilterType);
    STDMETHOD(put_FilterType)(const BSTR bstrFilterType);
};


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::modf
//
//  Overview:   The usual modf function takes doubles, but we only use floats
//              so lets avoid the conversions.
//
//------------------------------------------------------------------------------
inline float 
CDXTMatrix::modf(const float flIn, float * pflIntPortion)
{
    _ASSERT(pflIntPortion);

    *pflIntPortion = (float)((long)flIn);

    return flIn - (*pflIntPortion);
}
//  CDXTMatrix::modf


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_DXWeightedAverage2
//
//  Overview:   The DXWeightedAverage function included in dxhelper.h will 
//              average the color data of a pixel that has no alpha.  This is 
//              a bad thing.  This function checks the alpha first.  It's still
//              a bit messed up, though.  If you have a color 0x01FF0000 and a
//              color 0xFF00FF00 weighted 50/50, should the red really get half
//              the weight?
//
//------------------------------------------------------------------------------
inline DWORD   
CDXTMatrix::_DXWeightedAverage2(DXBASESAMPLE S1, DXBASESAMPLE S2, ULONG nWgt)
{
    if (S1.Alpha || S2.Alpha)
    {
        if (!S1.Alpha)
        {
            S1 = S2 & 0x00FFFFFF;
        }
        else if (!S2.Alpha)
        {
            S2 = S1 & 0x00FFFFFF;
        }

        return DXWeightedAverage(S1, S2, nWgt);
    }

    return 0;
}
//  CDXTMatrix::_DXWeightedAverage2


#endif //__MATRIX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\pixelate.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//  Filename:   pixelate.h
//
//  Overview:   Declaration of a pixelate DXTransform.
//
//  Change History:
//  2000/04/13  mcalkins    Code cleanup, NoOp optimization fix.
//  2000/05/10  mcalkins    Support IObjectSafety appropriately, add marshaler.
//
//------------------------------------------------------------------------------
#ifndef __PIXELATE_H_
#define __PIXELATE_H_

#include "resource.h"

typedef DXPMSAMPLE (* PONEINPUTFUNC)(DXPMSAMPLE *, int, int, int);
typedef DXPMSAMPLE (* PTWOINPUTFUNC)(DXPMSAMPLE *, DXPMSAMPLE *, int, int, ULONG, int, int);

/////////////////////////////////////////////////////////////////////////////
// CPixelate
class ATL_NO_VTABLE CPixelate :
    public CDXBaseNTo1,
    public CComCoClass<CPixelate, &CLSID_Pixelate>,
    public IDispatchImpl<IDXPixelate, &IID_IDXPixelate, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CPixelate>,
    public IObjectSafetyImpl2<CPixelate>,
    public IPersistStorageImpl<CPixelate>,
    public ISpecifyPropertyPagesImpl<CPixelate>,
    public IPersistPropertyBagImpl<CPixelate>
{
private:

    unsigned            m_fNoOp                 : 1;
    unsigned            m_fOptimizationPossible : 1;

    long                m_nMaxSquare;
    long                m_nPrevSquareSize;

    PONEINPUTFUNC       m_pfnOneInputFunc;
    PTWOINPUTFUNC       m_pfnTwoInputFunc;

    SIZE                m_sizeInput;

    CComPtr<IUnknown>   m_spUnkMarshaler;

public:

    CPixelate();

    DECLARE_POLY_AGGREGATABLE(CPixelate)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_PIXELATE)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CPixelate)
        COM_INTERFACE_ENTRY(IDXPixelate)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CPixelate>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CImage)
        PROP_ENTRY("MaxSquare", 1, CLSID_PixelatePP)
        PROP_PAGE(CLSID_PixelatePP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WorkInfo, 
                     BOOL * pbContinueProcessing);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);
    void    OnGetSurfacePickOrder(const CDXDBnds & /*BndsPoint*/, 
                                  ULONG & ulInToTest, ULONG aInIndex[],
                                  BYTE aWeight[]);

    // IDXEffect methods.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH);

    // IDXPixelate properties.

    STDMETHOD(put_MaxSquare)(int newVal);
    STDMETHOD(get_MaxSquare)(int * pVal);
};


#endif //__PIXELATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\randombars.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   randombars.cpp
//
//  Overview:   One pixel thick horizontal or vertical bars from input B are 
//              randomly placed over input A until only input B is showing.
//
//  Change History:
//  1999/09/26  a-matcal    Created.
//  1999/10/06  a-matcal    Combined WorkProcs into one general WorkProc.
//                          Implemented surface picking.
//                          Fixed bug where vertical bars leaving off right side
//                          of output.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "randombars.h"

extern DWORD g_adwRandMask[];




//+-----------------------------------------------------------------------------
//
//  CDXTRandomBars static variables initialization
//
//------------------------------------------------------------------------------

const WCHAR * CDXTRandomBars::s_astrOrientation[] = {
    L"horizontal",
    L"vertical"
};


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::CDXTRandomBars
//
//------------------------------------------------------------------------------
CDXTRandomBars::CDXTRandomBars() :
    m_eOrientation(ORIENTATION_HORIZONTAL),
    m_cbBufferSize(0),
    m_cPixelsMax(0),
    m_cPrevPixelsMax(0),
    m_pbBitBuffer(NULL),
    m_dwRandMask(0),
    m_fNoOp(false),
    m_fOptimizationPossible(false)
{
    m_sizeInput.cx      = 0;
    m_sizeInput.cy      = 0;

    // Base class members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  Method: CDXTRandomBars::CDXTRandomBars


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::~CDXTRandomBars
//
//------------------------------------------------------------------------------
CDXTRandomBars::~CDXTRandomBars()
{
    if (m_pbBitBuffer)
    {
        delete [] m_pbBitBuffer;
    }
}
//  Method: CDXTRandomBars::~CDXTRandomBars


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomBars::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  Method: CDXTRandomBars::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::OnSetup, CDXBaseNTo1
//
//  Overview:   This function will create a bit buffer where each bit represents
//              a row or column of the output, depending on whether the 
//              transform is set for vertical or horizontal action.
//
//              The bit buffer will be sized in whole bytes with one extra byte
//              at the beginning because the zero bit will never be set using
//              this random number generator.  This extra byte will be ignored.
//              
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomBars::OnSetup(DWORD dwFlags)
{
    HRESULT hr      = S_OK;
    UINT    cbPitch = 0;

    SIZE        sizeNew;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsInput.GetXYSize(sizeNew);

    // If the input size hasn't changed, we don't have to do any work here.

    if ((sizeNew.cx == m_sizeInput.cx) && (sizeNew.cy == m_sizeInput.cy))
    {
        goto done;
    }

    // Allocate new bit buffer if needed.

    hr = _CreateNewBitBuffer(sizeNew, m_eOrientation);

    if (FAILED(hr))
    {
        goto done;
    }

done:

    return hr;
} 
//  Method: CDXTRandomBars::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTRandomBars::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                      ULONG & ulInToTest,  ULONG aInIndex[],
                                      BYTE aWeight[])
{
    long    nMinBound   = (ORIENTATION_VERTICAL == m_eOrientation) ? 
                          OutPoint.Left() : OutPoint.Top();
    ULONG   nCurByte    = (nMinBound / 8) + 1;
    BYTE    bCurBit     = 0x80 >> (nMinBound % 8);

    ulInToTest  = 1;
    aWeight[0]  = 255;
    aInIndex[0] = (m_pbBitBuffer[nCurByte] & bCurBit) ? 1 : 0;
}
//  Method: CDXTRandomBars::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::OnInitInstData, CDXBaseNTo1
//
//  Overview:   This method is responsible for updating the bitmask representing
//              the output of the transform.  Lit bits represent pixels of input
//              B and 0 bits represent pixels of input A.
//
//              Keep in mind that what we consider a "row" in this function is
//              8 bits.  This has no relation to the number of pixels in a row
//              of the output surface.  
//
//------------------------------------------------------------------------------
HRESULT
CDXTRandomBars::OnInitInstData(CDXTWorkInfoNTo1 & WI, 
                               ULONG & ulNumBandsToDo)
{
    DWORD   dwElement   = 1;
    UINT    nRow        = 0;
    UINT    cPixelsCur  = 0;

    m_cCurPixelsMax = (UINT)(((float)m_cPixelsMax + 0.5F) * m_Progress);

    // Simple optimization so that we won't do the same thing twice in a row.

    if ((m_cPrevPixelsMax == m_cCurPixelsMax) && !IsInputDirty(0)
        && !IsInputDirty(1) && !IsOutputDirty() && !IsTransformDirty()
        && m_fOptimizationPossible)
    {
        m_fNoOp = true;

        goto done;
    }

    // TODO:  We can optimize better if nothing is dirty and we're not blending
    //        with the output.  Keep track of the last execute's dwElement and 
    //        cPixelsCur and take if from there.  (Don't zero memory.)

    ZeroMemory(m_pbBitBuffer, m_cPixelsMax / 8);

    while (cPixelsCur < m_cCurPixelsMax)
    {
        // The random number generator will generate number our of our range
        // so we need to make sure this number is in our range before we set
        // a value in our bit buffer.

        if (dwElement < m_cPixelsMax)
        {
            // For the purpose of this function, our rows are 8 bits wide so we
            // get the row number by dividing by 8.

            nRow = dwElement >> 3;   // row = dwElement / 8

            // Once in the row, we have to set the appropriate bit, which is the
            // remainder after dividing by 8.

            m_pbBitBuffer[nRow] |= (0x80 >> (dwElement & 7)); 
                                                 // ^^ dwElement % 8

            // We've set a pixel, increment the pixel count.

            cPixelsCur++;
        }

        // Get next random value.  See Graphics Gems I for explanation.

        if (dwElement & 1)
        {
            dwElement = (dwElement >> 1) ^ m_dwRandMask;
        }
        else
        {
            dwElement = (dwElement >> 1);
        }

        // (1 == dwElement) should only happen when m_cCurPixelsMax == m_cPixelsMax.

        // SamBent:  Not quite.  When m_cCurPixelsMax == m_cPixelsMax - 1,
        // dwElement will need to cycle through all 2^n-1 values before finding 
        // the last good one (at dwElement == 1).  The comment a few lines
        // below (about "zero is never selected") should have been a tipoff.

        if (1 == dwElement)
        {
            _ASSERT(m_cCurPixelsMax >= m_cPixelsMax - 1);

            break;
        }
    }

    // At this point, cPixelsCur should be equal to m_cCurPixelsMax except when 
    // m_cCurPixelsMax == m_cPixelsMax (m_Progress == 1.0) where cPixelsCur will
    // equal m_cCurPixelsMax - 1 because zero is never selected.

    _ASSERT((cPixelsCur == m_cCurPixelsMax) || ((cPixelsCur == m_cCurPixelsMax - 1) && (m_cCurPixelsMax == m_cPixelsMax)));

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    return S_OK;
}
//  Method: CDXTRandomBars::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::WorkProc, CDXBaseNTo1
//
//  Overview:   WorkProc takes the bit buffer updated in OnInitInstData and
//              updates the output surface using it.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomBars::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr              = S_OK;
    DWORD   dwFlags         = 0;
    ULONG   nCurInputIndex  = 0;
    ULONG   nNextInputIndex = 0;
    ULONG   nCurByte        = 0;
    BYTE    bCurBit         = 0;

    long    nDoMin          = 0;
    long    nDoMax          = 0;

    long *  pnSrcMin        = NULL;
    long *  pnSrcMax        = NULL;

    CDXDVec     vecDo2OutputOffset;
    CDXDBnds    bndsSrc(WI.DoBnds);
    CDXDBnds    bndsDest;

    // Leave if no work is needed.

    if (m_fNoOp)
    {
        goto done;
    }

    // This vector is the difference between the upper left corner of the "do"
    // bounds and where the do bounds should be placed on the output surface.

    vecDo2OutputOffset.u.D[DXB_X] = WI.OutputBnds.Left() - WI.DoBnds.Left();
    vecDo2OutputOffset.u.D[DXB_Y] = WI.OutputBnds.Top() - WI.DoBnds.Top();

    // Set up max and min variables for vertical or horizontal case.

    if (ORIENTATION_VERTICAL == m_eOrientation)
    {
        nDoMin = WI.DoBnds.Left();
        nDoMax = WI.DoBnds.Right();

        pnSrcMin = &bndsSrc.u.D[DXB_X].Min;
        pnSrcMax = &bndsSrc.u.D[DXB_X].Max;
    }
    else
    {
        nDoMin = WI.DoBnds.Top();
        nDoMax = WI.DoBnds.Bottom();

        pnSrcMin = &bndsSrc.u.D[DXB_Y].Min;
        pnSrcMax = &bndsSrc.u.D[DXB_Y].Max;
    }

    // The source bounds start of as empty at the left or top side of the "do" 
    // bounds.

    *pnSrcMax = *pnSrcMin;

    // nCurByte is the first byte that we care about.  Add one byte because
    // the first byte is discarded since the first bit will never be selected
    // by the random number generator.
    
    nCurByte    = (nDoMin / 8) + 1;

    // bCurBit is the first bit in that byte that we care about.

    bCurBit     = 0x80 >> (nDoMin % 8);

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    nCurInputIndex  = (m_pbBitBuffer[nCurByte] & bCurBit) ? 1 : 0;
    nNextInputIndex = nCurInputIndex;

    while ((*pnSrcMax < nDoMax) && *pbContinue)
    {
        *pnSrcMin = *pnSrcMax;

        // While the input needed to draw the row/column stays the same, expand 
        // the rectangle to paint.

        while((*pnSrcMax < nDoMax) && (nNextInputIndex == nCurInputIndex))
        {
            // Rectangle to paint gets one pixel wider.

            (*pnSrcMax)++;

            // Go to next bit.

            bCurBit >>= 1;

            if (!bCurBit)
            {
                // We've used up the bits in this byte, go to next byte and 
                // reset the bit.

                nCurByte++;

                bCurBit = 0x80;
            }

            nNextInputIndex = (m_pbBitBuffer[nCurByte] & bCurBit) ? 1 : 0;
        }

        // Set destination bounds.

        bndsDest = bndsSrc;
        bndsDest.Offset(vecDo2OutputOffset);

        // Paint this rectangle.

        hr = DXBitBlt(OutputSurface(), bndsDest,
                      InputSurface(nCurInputIndex), bndsSrc,
                      dwFlags, m_ulLockTimeOut);

        if (FAILED(hr))
        {
            goto done;
        }

        nCurInputIndex = nNextInputIndex;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTRandomBars::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTRandomBars::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_cPrevPixelsMax    = m_cCurPixelsMax;
    m_fNoOp             = false;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  Method: CDXTRandomBars::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::get_Orientation, IDXTRandomBars
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRandomBars::get_Orientation(BSTR * pbstrOrientation)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrOrientation)
    {
        return E_POINTER;
    }

    if (*pbstrOrientation != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrOrientation = SysAllocString(s_astrOrientation[m_eOrientation]);

    if (NULL == *pbstrOrientation)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  Method: CDXTRandomBars::get_Orientation, IDXTRandomBars


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::put_Orientation, IDXTRandomBars
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRandomBars::put_Orientation(BSTR bstrOrientation)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;
    
    if (NULL == bstrOrientation)
    {
        return E_POINTER;
    }

    for ( ; i < (int)ORIENTATION_MAX ; i++)
    {
        if (!_wcsicmp(bstrOrientation, s_astrOrientation[i]))
        {
            break;
        }
    }

    if ((int)ORIENTATION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eOrientation != i)
    {
        HRESULT hr = _CreateNewBitBuffer(m_sizeInput, (ORIENTATION)i);

        if (FAILED(hr))
        {
            return hr;
        }

        m_eOrientation = (ORIENTATION)i;

        SetDirty();
    }

    return S_OK;
}
//  Method: CDXTRandomBars::put_Orientation, IDXTRandomBars


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::_BitWidth
//
//------------------------------------------------------------------------------
UINT
CDXTRandomBars::_BitWidth(UINT n)
{
    UINT nWidth = 0;

    while (n)
    {
        n >>= 1;

        nWidth++;
    }

    return nWidth;
}
//  Method: CDXTRandomBars::_BitWidth


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::_CreateNewBitBuffer
//
//------------------------------------------------------------------------------
HRESULT
CDXTRandomBars::_CreateNewBitBuffer(SIZE & sizeNew, ORIENTATION eOrientation)
{
    HRESULT hr              = S_OK;
    UINT    cbBufferSize    = 0;

    // How many bytes would be needed to hold a bit for each row/column.

    if (ORIENTATION_VERTICAL == eOrientation)
    {
        cbBufferSize = sizeNew.cx / 8;

        if (sizeNew.cx % 8)
        {
            cbBufferSize++;  // Add one if division truncated.
        }    
    }
    else
    {
        cbBufferSize = sizeNew.cy / 8;

        if (sizeNew.cy % 8)
        {
            cbBufferSize++;  // Add one if division truncated.
        }    
    }

    // Add 1 byte so the first byte can be ignored since the zero bit will never
    // be set.

    cbBufferSize++;

    // Do we need to allocate a new buffer?

    if ((cbBufferSize == m_cbBufferSize) && m_pbBitBuffer)
    {
        // Our bit buffer is already the correct size, so just change the input
        // size and return.

        m_sizeInput.cx = sizeNew.cx;
        m_sizeInput.cy = sizeNew.cy;
    }
    else // We need to allocate a new bit buffer.
    {
        BYTE *  pbBitsTemp      = NULL;

        pbBitsTemp = new BYTE[cbBufferSize];

        if (NULL == pbBitsTemp)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        m_sizeInput.cx  = sizeNew.cx;
        m_sizeInput.cy  = sizeNew.cy;
        m_cbBufferSize  = cbBufferSize;

        // What is the maximum pixel represented by our buffer?  (This will be
        // different than the maximum pixel of the input surfaces.)

        m_cPixelsMax    = cbBufferSize * 8;

        // The maximum number we need our random number generator to create is
        // m_cPixelsMax - 1.  So we get the bit width of that number and then
        // get the appropriate random number generating mask from the global 
        // array.

        m_dwRandMask    = g_adwRandMask[_BitWidth(m_cPixelsMax -1)];

        // Even if the inputs are 1x1 pixel, the bit mask will be at
        // least 16-bits (representing 16 pixels) and it will be impossible
        // for us to get a 0 rand mask.  But we'll assert, just to be sure.

        _ASSERT(m_dwRandMask);

        // Replace the bit buffer.

        if (m_pbBitBuffer)
        {
            delete [] m_pbBitBuffer;
        }

        m_pbBitBuffer = pbBitsTemp;
    }

done:

    return hr;
}
//  Method: CDXTRandomBars::_CreateNewBitBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\randombars.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   randombars.h
//
//  Overview:   One pixel thick horizontal or vertical bars from input B are 
//              randomly placed over input A until only input B is showing.
//
//  Change History:
//  1999/09/26  a-matcal    Created.
//  1999/10/06  a-matcal    Removed _WorkProcVertical and _WorkProcHorizontal
//                          Added m_fNoOp, m_cCurPixelsmax, and m_cPrevPixelsMax 
//                          members to enable simple optimization.
//
//------------------------------------------------------------------------------

#ifndef __RANDOMBARS_H_
#define __RANDOMBARS_H_

#include "resource.h"   




class ATL_NO_VTABLE CDXTRandomBars : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTRandomBars, &CLSID_DXTRandomBars>,
    public IDispatchImpl<IDXTRandomBars, &IID_IDXTRandomBars, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTRandomBars>,
    public IObjectSafetyImpl2<CDXTRandomBars>,
    public IPersistStorageImpl<CDXTRandomBars>,
    public IPersistPropertyBagImpl<CDXTRandomBars>
{
private:

    typedef enum {
        ORIENTATION_HORIZONTAL = 0,
        ORIENTATION_VERTICAL,
        ORIENTATION_MAX
    } ORIENTATION;

    ORIENTATION             m_eOrientation;
    static const WCHAR *    s_astrOrientation[ORIENTATION_MAX];

    UINT        m_cbBufferSize;
    UINT        m_cPixelsMax;
    UINT        m_cCurPixelsMax;
    UINT        m_cPrevPixelsMax;
    BYTE *      m_pbBitBuffer;
    DWORD       m_dwRandMask;
    SIZE        m_sizeInput;

    CComPtr<IUnknown> m_spUnkMarshaler;

    unsigned    m_fNoOp                 : 1;
    unsigned    m_fOptimizationPossible : 1;

    // Helper methods.

    UINT    _BitWidth(UINT n);
    HRESULT _CreateNewBitBuffer(SIZE & sizeNew, ORIENTATION eOrientation);

public:

    CDXTRandomBars();
    virtual ~CDXTRandomBars();

    DECLARE_POLY_AGGREGATABLE(CDXTRandomBars)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTRANDOMBARS)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTRandomBars)
        COM_INTERFACE_ENTRY(IDXTRandomBars)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTRandomBars>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTRandomBars)
        PROP_ENTRY("orientation",   DISPID_DXTRANDOMBARS_ORIENTATION,   CLSID_DXTRandomBarsPP)
        PROP_PAGE(CLSID_DXTRandomBarsPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXTRandomBars properties.

    STDMETHOD(get_Orientation)(BSTR * pbstrOrientation);
    STDMETHOD(put_Orientation)(BSTR bstrOrientation);

    // IDXEffect properties.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__RANDOMBARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\randomdissolve.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   randomdissolve.cpp
//
//  Overview:   A random dissolve transform.
//
//  Change History:
//  1999/09/26  a-matcal    Created.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "randomdissolve.h"

DWORD g_adwRandMask[33] = {
    // Mask     // Bit width
    0x0,        //  0 Not available
    0x0,        //  1 Not available
    0x00000003, //  2
    0x00000006, //  3
    0x0000000C, //  4
    0x00000014, //  5
    0x00000030, //  6
    0x00000060, //  7
    0x000000B8, //  8
    0x00000110, //  9
    0x00000240, // 10
    0x00000500, // 11
    0x00000CA0, // 12
    0x00001B00, // 13
    0x00003500, // 14
    0x00006000, // 15
    0x0000B400, // 16
    0x00012000, // 17
    0x00020400, // 18
    0x00072000, // 19
    0x00090000, // 20
    0x00140000, // 21
    0x00300000, // 22
    0x00420000, // 23 BUG 9432 - This guy was 0x00400000 and his pixels would 
                //    cluster about the left and top asymptotically close.  I
                //    added the 0x20000 bit to give a little more noise to the
                //    column result.  
                //
                //    (mcalkins) while porting this I noticed the old
                //    filter was grabbing the rand mask for an index 2 larger
                //    than it needed, causing over calculation and possibly the
                //    cause of this bug.  This table comes straight out of 
                //    Graphics Gems I.
                //
    0x00D80000, // 24
    0x01200000, // 25
    0x03880000, // 26
    0x07200000, // 27
    0x09000000, // 28 
    0x14000000, // 29
    0x32800000, // 30
    0x48000000, // 31
    0xA3000000  // 32
};




//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::CDXTRandomDissolve
//
//------------------------------------------------------------------------------
CDXTRandomDissolve::CDXTRandomDissolve() :
    m_cdwPitch(0),
    m_cPixelsMax(0),
    m_pdwBitBuffer(NULL),
    m_dwRandMask(0)
{
    m_sizeInput.cx      = 0;
    m_sizeInput.cy      = 0;

    // Base class members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  Method: CDXTRandomDissolve::CDXTRandomDissolve


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::~CDXTRandomDissolve
//
//------------------------------------------------------------------------------
CDXTRandomDissolve::~CDXTRandomDissolve()
{
    if (m_pdwBitBuffer)
    {
        delete [] m_pdwBitBuffer;
    }
}
//  Method: CDXTRandomDissolve::~CDXTRandomDissolve


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomDissolve::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  Method: CDXTRandomDissolve::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::OnSetup, CDXBaseNTo1
//
//  Overview:   This function will create a buffer surface with a bit depth of
//              1 to hold a mask of the output.  The buffer will have a row size
//              that is a multiple of four bytes, and will have four extra bytes
//              in front of the first bit representing pixel {0, 0} so that we
//              can avoid dealing with the problem of zero never coming out of
//              our random number generator.  (Otherwise pixel {0, 0} would
//              always be the first or last pixel selected.)
//              
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomDissolve::OnSetup(DWORD dwFlags)
{
    HRESULT hr          = S_OK;
    UINT    cdwPitch    = 0;

    SIZE        sizeNew;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsInput.GetXYSize(sizeNew);

    // If the input size hasn't changed, we don't have to do any work here.

    if ((sizeNew.cx == m_sizeInput.cx) && (sizeNew.cy == m_sizeInput.cy))
    {
        goto done;
    }

    // How many DWORDs would be needed per row to hold this image in 1 bit per
    // pixel format.

    cdwPitch = sizeNew.cx / 32;

    if (sizeNew.cx % 32)
    {
        cdwPitch++;  // Add one if division truncated.
    }
    
    if ((cdwPitch == m_cdwPitch) 
        && (sizeNew.cy == m_sizeInput.cy) && m_pdwBitBuffer)
    {
        // Our bit buffer is already the correct size, so just change the input
        // size width and return.

        m_sizeInput.cx = sizeNew.cx;
    }
    else // We need to allocate a new bit buffer.
    {
        DWORD * pdwBitsTemp = NULL;

        // We add one DWORD to buffer size so we can ignore the first DWORD and
        // not deal with the 0th element never being selected. (A side effect of
        // the random number generator used.)

        int cdwBufferSize = (cdwPitch * sizeNew.cy) + 1;

        pdwBitsTemp = new DWORD[cdwBufferSize];

        if (NULL == pdwBitsTemp)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        m_sizeInput.cx  = sizeNew.cx;
        m_sizeInput.cy  = sizeNew.cy;
        m_cdwPitch      = cdwPitch;

        // What is the maximum pixel represented by our buffer?  (This will be
        // different than the maximum pixel of the input surfaces.)

        m_cPixelsMax    = cdwBufferSize * 32;

        // The maximum number we need our random number generator to create is
        // m_cPixelsMax - 1.  So we get the bit width of that number and then
        // get the appropriate random number generating mask from the global 
        // array.

        m_dwRandMask    = g_adwRandMask[_BitWidth(m_cPixelsMax -1)];

        // Even if the inputs are 1x1 pixel, the bit mask will be at
        // least 64-bits (representing 64 pixels) and it will be impossible
        // for us to get a 0 rand mask.  But we'll assert, just to be sure.

        _ASSERT(m_dwRandMask);

        // Replace the bit buffer.

        if (m_pdwBitBuffer)
        {
            delete [] m_pdwBitBuffer;
        }

        m_pdwBitBuffer = pdwBitsTemp;
    }

done:

    return hr;
} 
//  Method: CDXTRandomDissolve::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTRandomDissolve::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                          ULONG & ulInToTest,  ULONG aInIndex[],
                                          BYTE aWeight[])
{
    DWORD dwCurrent = m_pdwBitBuffer[  (m_cdwPitch * OutPoint[DXB_Y].Min)
                                     + (OutPoint[DXB_X].Min >> 5 /* / 32 */)
                                     + 1 /* we don't use the first DWORD */];
    int   nBit      = OutPoint[DXB_X].Min % 32;

    ulInToTest  = 1;
    aWeight[0]  = 255;
    aInIndex[0] = ((dwCurrent << nBit) & 0x80000000) ? 1 : 0;
}
//  Method: CDXTRandomDissolve::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::OnInitInstData, CDXBaseNTo1
//
//  Overview:   This method is responsible for updating the bitmask representing
//              the output of the transform.  Lit bits represent pixels of input
//              B and 0 bits represent pixels of input A.
//
//              Keep in mind that what we consider a "row" in this function is
//              32 bits.  This has no relation to the number of pixels in a row
//              of the output surface.  
//
//------------------------------------------------------------------------------
HRESULT
CDXTRandomDissolve::OnInitInstData(CDXTWorkInfoNTo1 & WI, 
                                   ULONG & ulNumBandsToDo)
{
    DWORD   dwElement   = 1;
    UINT    nRow        = 0;
    UINT    cPixelsCur  = 0;
    UINT    cPixelsMax  = (UINT)(((float)m_cPixelsMax + 0.5F) * m_Progress);

    // TODO:  We can optimize if nothing is dirty and we're not blending with
    //        the output.  Keep track of the last execute's dwElement and 
    //        cPixelsCur and take if from there.  (Don't zero memory.)

    ZeroMemory(m_pdwBitBuffer, m_cPixelsMax / 8);

    while (cPixelsCur < cPixelsMax)
    {
        // The random number generator will generate number our of our range
        // so we need to make sure this number is in our range before we set
        // a value in our bit buffer.

        if (dwElement < m_cPixelsMax)
        {
            // For the purpose of this function, our rows are 32 bits wide so we
            // get the row number by dividing by 32.

            nRow = dwElement >> 5;   // row = dwElement / 32

            // Once in the row, we have to set the appropriate bit, which is the
            // remainder after dividing by 32.

            m_pdwBitBuffer[nRow] |= (0x80000000 >> (dwElement & 31)); 
                                                    // ^^ dwElement % 32

            // We've set a pixel, increment the pixel count.

            cPixelsCur++;
        }

        // Get next random value.  See Graphics Gems I for explanation.

        if (dwElement & 1)
        {
            dwElement = (dwElement >> 1) ^ m_dwRandMask;
        }
        else
        {
            dwElement = (dwElement >> 1);
        }

        // (1 == dwElement) should only happen when cPixelsMax == m_cPixelsMax.

        // SamBent:  Not quite.  When cPixelsMax == m_cPixelsMax - 1,
        // dwElement will need to cycle through all 2^n-1 values before finding 
        // the last good one (at dwElement == 1).  The comment a few lines
        // below (about "zero is never selected") should have been a tipoff.

        if (1 == dwElement)
        {
            _ASSERT(cPixelsMax >= m_cPixelsMax - 1);

            break;
        }
    }

    // At this point, cPixelsCur should be equal to cPixelsMax except when 
    // cPixelsMax == m_cPixelsMax (m_Progress == 1.0) where cPixelsCur will
    // equal cPixelsMax - 1 because zero is never selected.

    _ASSERT((cPixelsCur == cPixelsMax) || ((cPixelsCur == cPixelsMax - 1) && (cPixelsMax == m_cPixelsMax)));

    return S_OK;
}
//  Method: CDXTRandomDissolve::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::WorkProc, CDXBaseNTo1
//
//  Overview:   WorkProc takes the bit buffer updated in OnInitInstData and
//              updates the output surface using it.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomDissolve::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    long    lDoWidth        = WI.DoBnds.Width();
    long    lDoHeight       = WI.DoBnds.Height();
    long    lOutY           = 0;

    // nCurrent will be the index of the first DWORD in our bit buffer that
    // holds the bit representing the first pixel we care about in the first
    // row we care about.  For each row nCurrent will be incremented by 
    // m_cdwPitch.

    UINT    nCurrent        = (m_cdwPitch * WI.DoBnds.Top())// Row we want.
                              + (WI.DoBnds.Left() / 32)     // Column we want.
                              + 1;                          // We ignore the
                                                            //  first DWORD.

    // dwFirstBit will represent the first bit in the DWORD that represents
    // the left side of the bounds we were requested to draw.

    DWORD   dwFirstBit      = 0x80000000 >> (WI.DoBnds.Left() % 32);

    DXPMSAMPLE * pRowBuffA  = NULL;
    DXPMSAMPLE * pRowBuffB  = NULL;
    DXPMSAMPLE * pOutBuff   = NULL;

    DXDITHERDESC dxdd;

    CComPtr<IDXARGBReadPtr>         spReadA;
    CComPtr<IDXARGBReadPtr>         spReadB;
    CComPtr<IDXARGBReadWritePtr>    spOut;

    // Get a read pointer to input A.

    hr = InputSurface(0)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, 
                                     (void **)&spReadA, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get a read pointer to input B.

    hr = InputSurface(1)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, 
                                     (void **)&spReadB, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get a read/write pointer to the output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, 
                                      IID_IDXARGBReadWritePtr, 
                                      (void **)&spOut, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Allocate a buffer.

    pRowBuffA = DXPMSAMPLE_Alloca(lDoWidth);
    pRowBuffB = DXPMSAMPLE_Alloca(lDoWidth);

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(lDoWidth);
    }

    // Set up the dither structure.

    if (DoDither())
    {
        dxdd.x                  = WI.OutputBnds.Left();
        dxdd.y                  = WI.OutputBnds.Top();
        dxdd.pSamples           = pRowBuffA;
        dxdd.cSamples           = lDoWidth;
        dxdd.DestSurfaceFmt     = OutputSampleFormat();
    }

    for (lOutY = 0; *pbContinue && (lOutY < lDoHeight); lOutY++)
    {
        // TODO:  Optimize by copying pixels from the surface that will be 
        //        likely to have less pixels needing to be copied.

        long    x           = 0;

        // pdwBits points to the first DWORD containing bits correstponding
        // to this output row.

        DWORD * pdwBits     = &m_pdwBitBuffer[nCurrent];

        // dwCurBit is initialized to the left-most bit.

        DWORD   dwCurBit    = dwFirstBit;                  

        // Read samples from both inputs.

        spReadA->MoveToRow(lOutY);
        spReadB->MoveToRow(lOutY);

        spReadA->UnpackPremult(pRowBuffA, lDoWidth, FALSE);
        spReadB->UnpackPremult(pRowBuffB, lDoWidth, FALSE);

        for ( ; x < lDoWidth ; x++)
        {
            if (*pdwBits & dwCurBit)
            {
                // Copy this pixel from input B's buffer to input A's buffer.
                // After these operations, input A's buffer will be copied onto
                // the output surface.

                pRowBuffA[x] = pRowBuffB[x];
            }

            dwCurBit >>= 1;

            if (!dwCurBit)
            {
                // We've used up the current DWORD's bits.  Move ahead one 
                // DWORD and reset current bit to the left-most bit.

                pdwBits++;
                
                dwCurBit = 0x80000000;
            }
        }

        // Move to the correct output row.

        spOut->MoveToRow(lOutY);

        // Dither if requested.

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        // Blend the bits or just copy.

        if (DoOver())
        {
            spOut->OverArrayAndMove(pOutBuff, pRowBuffA, lDoWidth);
        }
        else
        {
            spOut->PackPremultAndMove(pRowBuffA, lDoWidth);
        }

        // Increment our DWORD counter by the pitch.

        nCurrent += m_cdwPitch;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTRandomDissolve::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::_BitWidth
//
//------------------------------------------------------------------------------
UINT
CDXTRandomDissolve::_BitWidth(UINT n)
{
    UINT nWidth = 0;

    while (n)
    {
        n >>= 1;

        nWidth++;
    }

    return nWidth;
}
//  Method: CDXTRandomDissolve::_BitWidth
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\randomdissolve.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   randomdissolve.h
//
//  Overview:   A random dissolve transform.
//
//  Change History:
//  1999/09/26  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef __RANDOMDISSOLVE_H_
#define __RANDOMDISSOLVE_H_

#include "resource.h"   




class ATL_NO_VTABLE CDXTRandomDissolve : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTRandomDissolve, &CLSID_DXTRandomDissolve>,
    public IDispatchImpl<IDXEffect, &IID_IDXEffect, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTRandomDissolve>,
    public IObjectSafetyImpl2<CDXTRandomDissolve>,
    public IPersistStorageImpl<CDXTRandomDissolve>,
    public IPersistPropertyBagImpl<CDXTRandomDissolve>
{
private:

    DWORD * m_pdwBitBuffer;
    DWORD   m_dwRandMask;
    UINT    m_cdwPitch;
    UINT    m_cPixelsMax;
    SIZE    m_sizeInput;

    CComPtr<IUnknown> m_spUnkMarshaler;

    // Helper methods.

    UINT _BitWidth(UINT n);

public:

    CDXTRandomDissolve();
    virtual ~CDXTRandomDissolve();

    DECLARE_POLY_AGGREGATABLE(CDXTRandomDissolve)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTRANDOMDISSOLVE)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTRandomDissolve)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTRandomDissolve>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTRandomDissolve)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, 
                                  ULONG & ulInToTest,
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXEffect properties.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__RANDOMDISSOLVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\redirect.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:            redirect.h
//
//  Discription:         The redirect transform.
//
//  Change History:
//  1999/09/20  a-matcal    Created.
//  1999/11/07  a-matcal    Handle OnSetup.
//
//------------------------------------------------------------------------------

#ifndef __REDIRECT_H_
#define __REDIRECT_H_

#include "resource.h"
#include "danim.h"
#include "datime.h"
#include "mshtml.h"




class ATL_NO_VTABLE CDXTRedirect : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTRedirect, &CLSID_DXTRedirect>,
    public IDispatchImpl<IDXTRedirect, &IID_IDXTRedirect, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTRedirect>,
    public IObjectSafetyImpl2<CDXTRedirect>,
    public IPersistStorageImpl<CDXTRedirect>,
    public IPersistPropertyBagImpl<CDXTRedirect>,
    public ITIMEDAElementRenderSite,
    public IDXTRedirectFilterInit
{
private:

    CDXDBnds                        m_bndsInput;

    CComPtr<IDAStatics>             m_spDAStatics;
    CComPtr<IDAImage>               m_spDAImage;
    CComPtr<ITIMEDAElementRender>   m_spTIMEDAElementRender;
    CComPtr<IHTMLPaintSite>         m_spHTMLPaintSite;
    CComPtr<IDirectDrawSurface>     m_spDDSurfBuffer;
    CComPtr<IDXSurface>             m_spDXSurfBuffer;

    CComPtr<IUnknown>               m_cpUnkMarshaler;

    DWORD                           m_dwChromaColor;

    unsigned                        m_fDetached : 1;

public:

    CDXTRedirect();

    DECLARE_POLY_AGGREGATABLE(CDXTRedirect)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTREDIRECT)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTRedirect)
        COM_INTERFACE_ENTRY(IDXTRedirect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITIMEDAElementRenderSite)
        COM_INTERFACE_ENTRY(IDXTRedirectFilterInit)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTRedirect>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CIris)
    END_PROPERTY_MAP()

    HRESULT FinalConstruct();

    // CDXTBaseNTo1 overrides.

    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnSetup(DWORD dwFlags);

    // ITIMEDAElementRenderSite methods.

    STDMETHOD(Invalidate)(LPRECT prc);

    // IDXTRedirectFilterInit methods.

    STDMETHOD(SetHTMLPaintSite)(void * pvHTMLPaintSite);

    // IDXTRedirect methods.

    STDMETHOD(ElementImage)(VARIANT * pvarImage);
    STDMETHOD(SetDAViewHandler)(IDispatch * pDispViewHandler);
    STDMETHOD(HasImageBeenAllocated)(BOOL * pfAllocated);
    STDMETHOD(DoRedirection)(IUnknown * pInputSurface,
                             HDC hdcOutput,
                             RECT * pDrawRect);
};

#endif //__REDIRECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\redirect.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:            redirect.cpp
//
//  Discription:         The redirect transform.
//
//  Change History:
//  1999/09/20  a-matcal    Created.
//  1999/11/09  a-matcal    Handle OnSetup to create a buffer surface if the
//                          output surface doesn't have 32-bit color depth.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "redirect.h"




//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::CDXTRedirect
//
//------------------------------------------------------------------------------
CDXTRedirect::CDXTRedirect() :
    m_fDetached(false),
    m_dwChromaColor(0)
{
    m_ulMaxImageBands   = 1; // disable banding
    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
}
//  CDXTRedirect::CDXTRedirect


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRedirect::FinalConstruct()
{
    HRESULT hr = S_OK;

    CComPtr<IDAImage> spDAImage;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_cpUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_DAStatics, NULL, CLSCTX_INPROC_SERVER,
                          __uuidof(IDAStatics), (void **)&m_spDAStatics);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spDAStatics->get_EmptyImage(&spDAImage);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spDAStatics->ModifiableBehavior(spDAImage, (IDABehavior **)&m_spDAImage);

    if (FAILED(hr))
    {
        goto done;
    }

done:

    return hr;
}
//  CDXTRedirect::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTRedirect::OnSetup(DWORD dwFlags)
{
    HRESULT         hr      = S_OK;
    HDC             hdc     = NULL;
    HBITMAP         hbm     = NULL;
    DDSURFACEDESC   ddsd;
    DDCOLORKEY      ddck;

    CComPtr<IServiceProvider>       spServiceProvider;
    CComPtr<IDXSurfaceFactory>      spDXSurfaceFactory;
    CComPtr<IDirectDraw>            spDirectDraw;

    // Ask our site for a service provider.

    hr = GetSite(__uuidof(IServiceProvider), (void **)&spServiceProvider);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get a pointer to a surface factory.

    hr = spServiceProvider->QueryService(SID_SDXSurfaceFactory,
                                         __uuidof(IDXSurfaceFactory),
                                         (void **)&spDXSurfaceFactory);

    if (FAILED(hr))
    {
        goto done;
    }

    // Query transform factory for DirectDraw object.

    hr = spServiceProvider->QueryService(SID_SDirectDraw, IID_IDirectDraw,
                                         (void **)&spDirectDraw);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get display mode.

    ZeroMemory(&ddsd, sizeof(DDSURFACEDESC));

    ddsd.dwSize = sizeof(DDSURFACEDESC);

    hr = spDirectDraw->GetDisplayMode(&ddsd);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get input surface size.  Our buffer surface will need to be this size.

    hr = InputSurface()->GetBounds(&m_bndsInput);

    if (FAILED(hr))
    {
        goto done;
    }

    // Stuff from old filters code that will hopefully help us to create the
    // a surface in the exact surface format we need.  In a better world, it 
    // shouldn't matter, but it does.

    ddsd.dwFlags           &= ~DDSD_PITCH;
    ddsd.lPitch             = 0;
    ddsd.lpSurface          = NULL;
    ddsd.dwBackBufferCount  = 0;
    ddsd.dwReserved         = 0;
    ddsd.dwHeight           = m_bndsInput.Height();
    ddsd.dwWidth            = m_bndsInput.Width();

    // Do some corrections for 16-bit mode to make sure we choose correctly
    // between 555 and 565.  This code is taken out of offscrn.cxx in Trident
    // from the PixelFormat() function.

    if (16 == ddsd.ddpfPixelFormat.dwRGBBitCount)
    {
        struct
        {
            BITMAPINFOHEADER bih;
            DWORD            bf[3];
        } bi;

        hdc = ::GetDC(NULL);

        if (NULL == hdc)
        {
            hr = E_FAIL;

            goto done;
        }

        hbm = ::CreateCompatibleBitmap(hdc, 1, 1);

        if (NULL == hbm)
        {
            hr = E_FAIL;

            goto done;
        }

        ZeroMemory(&bi, sizeof(bi));

        bi.bih.biSize = sizeof(BITMAPINFOHEADER);

        // The first call will fill in the optimal biBitCount.

        GetDIBits(hdc, hbm, 0, 1, NULL, (BITMAPINFO*)&bi, DIB_RGB_COLORS);

        if (bi.bih.biBitCount == 16)
        {
            // The second call will get the optimal bitfields.

            GetDIBits(hdc, hbm, 0, 1, NULL, (BITMAPINFO*)&bi, DIB_RGB_COLORS);

            ddsd.ddpfPixelFormat.dwRBitMask = bi.bf[0]; // red mask
            ddsd.ddpfPixelFormat.dwGBitMask = bi.bf[1]; // green mask
            ddsd.ddpfPixelFormat.dwBBitMask = bi.bf[2]; // blue mask
        }
        else
        {
            _ASSERT(false);
        }
    }

    // Release references to the old buffer surface.

    m_spDXSurfBuffer.Release();
    m_spDDSurfBuffer.Release();

    // Create the buffer surface.  For DATime to work properly, buffer surfaces
    // must be created in the display mode pixel format, except when the display
    // mode is 256 colors in which case it should be anything _but_ the display
    // mode pixel format.  We make it 32-bit for faster blits from the filter
    // buffer surfaces.

    hr = spDXSurfaceFactory->CreateSurface(NULL, &ddsd, NULL,
                                           &m_bndsInput, 0, NULL,
                                           __uuidof(IDXSurface), 
                                           (void **)&m_spDXSurfBuffer);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spDXSurfBuffer->GetDirectDrawSurface(IID_IDirectDrawSurface, 
                                                (void **)&m_spDDSurfBuffer);

    if (FAILED(hr))
    {
        goto done;
    }

    // Decide upon a color key to use depending on the surface description.

    if (   (0x00FF0000 == ddsd.ddpfPixelFormat.dwRBitMask)
        && (0x0000FF00 == ddsd.ddpfPixelFormat.dwGBitMask)
        && (0x000000FF == ddsd.ddpfPixelFormat.dwBBitMask))
    {
        // 32-bit or 24-bit.

        m_dwChromaColor = 0x0004FFF4;
    }
    else if (   (0x0000F800 == ddsd.ddpfPixelFormat.dwRBitMask)
             && (0x000007E0 == ddsd.ddpfPixelFormat.dwGBitMask)
             && (0x0000001F == ddsd.ddpfPixelFormat.dwBBitMask))
    {
        // 16-bit 5:6:5.

        m_dwChromaColor = 0x00000FFE;
    }
    else if (   (0x00007C00 == ddsd.ddpfPixelFormat.dwRBitMask)
             && (0x000003E0 == ddsd.ddpfPixelFormat.dwGBitMask)
             && (0x0000001F == ddsd.ddpfPixelFormat.dwBBitMask))
    {
        // 16-bit 5:5:5.

        m_dwChromaColor = 0x000007FE;
    }
    else
    {
        // 256 color surface or unknown pixel format, set to something.

        m_dwChromaColor = 0x00000021;
    }

    // Set the color key to our newly decided color key.

    ddck.dwColorSpaceHighValue  = m_dwChromaColor;
    ddck.dwColorSpaceLowValue   = m_dwChromaColor;

    hr = m_spDDSurfBuffer->SetColorKey(DDCKEY_SRCBLT, &ddck);

done:

    if (hdc)
    {
        ::ReleaseDC(NULL, hdc);
    }

    if (hbm)
    {
        ::DeleteObject(hbm);
    }

    return hr;
}
//  CDXTRedirect::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRedirect::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr  = S_OK;

    CComPtr<IDAImage>           spDAImage;
    CComPtr<IDirectDrawSurface> spDDSurface;

    _ASSERT(!!m_spDAStatics);
    _ASSERT(!!m_spDAImage);

    // Put input surface into image.

    if (IsInputDirty(0))
    {
        DDBLTFX ddbltfx;
        RECT    rc;

        // Set up blit effects structure and source RECT.

        ZeroMemory(&ddbltfx, sizeof(DDBLTFX));

        ddbltfx.dwSize      = sizeof(DDBLTFX);
        ddbltfx.dwFillColor = m_dwChromaColor;
        
        m_bndsInput.GetXYRect(rc);

        // Fill buffer surface with color key.

        hr = m_spDDSurfBuffer->Blt(&rc, NULL, NULL, DDBLT_COLORFILL, &ddbltfx);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = DXBitBlt(m_spDXSurfBuffer, m_bndsInput,
                      InputSurface(), m_bndsInput,
                      DXBOF_DO_OVER, INFINITE);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spDAStatics->ImportDirectDrawSurface(m_spDDSurfBuffer, NULL,
                                                    &spDAImage);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spDAImage->SwitchTo(spDAImage);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (m_spTIMEDAElementRender)
    {
        HDC         hdc     = NULL;
        RECT        rc;
        POINT       pt;

        CComPtr<IDirectDrawSurface> spDDSurfaceOut;

        hr = OutputSurface()->GetDirectDrawSurface(IID_IDirectDrawSurface,
                                                   (void **)&spDDSurfaceOut);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDDSurfaceOut->GetDC(&hdc);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spTIMEDAElementRender->Tick();

        if (FAILED(hr))
        {
            goto done;
        }

        // This size of the rect passed to ITIMEDAElementRender::Draw should
        // always be the same size as the element.  Since this transform doesn't
        // change the size, that's the same size as the input surface.

        m_bndsInput.GetXYRect(rc);

        // The offset rect should be the element's rect offset to it's upper
        // left coordinate with regard to coordinate 0,0 of the HTML page.  This
        // only comes into use when the element is only partially drawn.
        
        OffsetRect(&rc, -WI.DoBnds.Left(), -WI.DoBnds.Top());

        // Set the viewport origin.

        if (!::SetViewportOrgEx(hdc, WI.OutputBnds.Left(), WI.OutputBnds.Top(), 
                                &pt))
        {
            hr = E_FAIL;

            goto done;
        }

        // DA will now draw the element to the page for us.

        hr = m_spTIMEDAElementRender->Draw(hdc, &rc);

        // Even if this fails we still need to reset the viewport origin.

        if (!::SetViewportOrgEx(hdc, pt.x, pt.y, NULL)) 
        {
            DASSERT(false);

            goto done;
        }

        if (FAILED(hr))
        {
            DASSERT(false);

            goto done;
        }
    }

    // This transform doesn't actually do any drawing in the way that transforms
    // usually do (writing bits to the output surface.)  If it did, it would
    // draw over the top of the DA stuff going on.

done:

    return hr;
} 
//  CDXTRedirect::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::SetHTMLPaintSite, IDXTRedirectFilterInit
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::SetHTMLPaintSite(void * pvHTMLPaintSite)
{
   if (NULL == pvHTMLPaintSite)
    {
        // This method should only be called with NULL when the a filter 
        // is being detached from an element.  And then only once.

        _ASSERT(!m_fDetached);

        m_fDetached = true;
    }

    m_spHTMLPaintSite = (IHTMLPaintSite *)pvHTMLPaintSite;

    return S_OK;
}
//  CDXTRedirect::SetHTMLPaintSite, IDXTRedirectFilterInit


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::Invalidate, ITIMEDAElementRenderSite
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::Invalidate(LPRECT prc)
{
    // DATime may call us from a timer tick after we've been detached and 
    // m_spHTMLPaintSite will be NULL.  If so, return E_UNEXPECTED.

    if (!m_fDetached)
    {
        return m_spHTMLPaintSite->InvalidateRect(prc);
    }
    else
    {
        // We're detached from the element, we can't really invalidate anyting.

        return E_UNEXPECTED;
    }
}
//  CDXTRedirect::Invalidate, ITIMEDAElementRenderSite


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::ElementImage, IDXTRedirect
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::ElementImage(VARIANT * pvarImage)
{
    HRESULT hr = S_OK;

    if (NULL == pvarImage)
    {
        hr = E_POINTER;

        goto done;
    }

    pvarImage->vt       = VT_DISPATCH;
    pvarImage->pdispVal = m_spDAImage;

    m_spDAImage.p->AddRef();

done:

    return hr;
}
//  CDXTRedirect::ElementImage, IDXTRedirect


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::SetDAViewHandler, IDXTRedirect
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::SetDAViewHandler(IDispatch * pDispViewHandler)
{
    HRESULT hr = S_OK;

    WCHAR *     pstrProperty    = L"renderObject";
    DISPID      dispid          = 0;

    DISPPARAMS  dispparams;
    VARIANT     varResult;
    VARIANT     varUnknown;

    VariantInit(&varResult);
    VariantInit(&varUnknown);

    if (m_spTIMEDAElementRender)
    {
        m_spTIMEDAElementRender->put_RenderSite(NULL);
        m_spTIMEDAElementRender.Release();
    }

    if (NULL == pDispViewHandler)
    {
        goto done;
    }

    dispparams.rgvarg               = NULL;
    dispparams.rgdispidNamedArgs    = NULL;
    dispparams.cArgs                = 0;
    dispparams.cNamedArgs           = 0;

    hr = pDispViewHandler->GetIDsOfNames(IID_NULL, &pstrProperty, 1,
                                         LOCALE_SYSTEM_DEFAULT, &dispid);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispViewHandler->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT,
                                  DISPATCH_PROPERTYGET, &dispparams, &varResult,
                                  NULL, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varUnknown, &varResult, 0, VT_UNKNOWN);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = varUnknown.punkVal->QueryInterface(IID_ITIMEDAElementRender,
                                            (void **)&m_spTIMEDAElementRender);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spTIMEDAElementRender->put_RenderSite(
                                            (ITIMEDAElementRenderSite *)this);
                                  
done:

    VariantClear(&varResult);
    VariantClear(&varUnknown);

    return hr;
}
//  CDXTRedirect::SetDAViewHandler, IDXTRedirect


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::HasImageBeenAllocated, IDXTRedirect
//
//  I don't think this function is ever used by anyone.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::HasImageBeenAllocated(BOOL * pfAllocated)
{
    HRESULT hr = S_OK;

    if (NULL == pfAllocated)
    {
        hr = E_POINTER;

        goto done;
    }

    if (m_spDAImage)
    {
        *pfAllocated = FALSE;
    }
    else
    {
        *pfAllocated = TRUE;
    }

done:

    return hr;
}
//  CDXTRedirect::HasImageBeenAllocated, IDXTRedirect


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::DoRedirection, IDXTRedirect
//
//  I think this function was only called by the old filters code and
//  isn't needed any more.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::DoRedirection(IUnknown * pInputSurface,
                            HDC hdcOutput,
                            RECT * pDrawRect)
{
    return E_NOTIMPL;
}
//  CDXTRedirect::DoRedirection, IDXTRedirect
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\revealtrans.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       revealtrans.h
//
//  Overview:       The RevealTrans transform simply wraps other transforms to 
//                  ensure backward compatibility for the revealtrans filter.
//
//  Change History:
//  1999/09/18  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef __REVEALTRANS_H_
#define __REVEALTRANS_H_

#include "resource.h"




class ATL_NO_VTABLE CDXTRevealTrans : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDXTRevealTrans, &CLSID_DXTRevealTrans>,
    public IDispatchImpl<IDXTRevealTrans, &IID_IDXTRevealTrans, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTRevealTrans>,
    public IObjectSafetyImpl2<CDXTRevealTrans>,
    public IPersistStorageImpl<CDXTRevealTrans>,
    public ISpecifyPropertyPagesImpl<CDXTRevealTrans>,
    public IPersistPropertyBagImpl<CDXTRevealTrans>,
    public IDXTransform,
    public IDXSurfacePick,
    public IObjectWithSite
{
private:

    int     m_nTransition;
    int     m_cInputs;
    int     m_cOutputs;
    float   m_flProgress;
    float   m_flDuration;

    IUnknown * m_apunkInputs[2];
    IUnknown * m_apunkOutputs[1];

    CComPtr<IDXTransformFactory>    m_spDXTransformFactory;
    CComPtr<IDXTransform>           m_spDXTransform;
    CComPtr<IDXEffect>              m_spDXEffect;
    CComPtr<IDXSurfacePick>         m_spDXSurfacePick;

    CComPtr<IUnknown> m_spUnkMarshaler;
    CComPtr<IUnknown> m_spUnkSite;

    // Helpers.

    STDMETHOD(_InitializeNewTransform)(int nTransition, 
                                       IDXTransform * pDXTransform);
                                       
    void _FreeSurfacePointers();

public:

    CDXTRevealTrans();
    virtual ~CDXTRevealTrans();

    DECLARE_POLY_AGGREGATABLE(CDXTRevealTrans)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTREVEALTRANS)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTRevealTrans)
        COM_INTERFACE_ENTRY(IDXTRevealTrans)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDXTransform)
        COM_INTERFACE_ENTRY(IDXSurfacePick)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal,     m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTRevealTrans>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTRevealTrans)
        PROP_ENTRY("transition" , 1, CLSID_NULL)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // IDXTRevealTrans methods.

    STDMETHOD(get_Transition)(/*[out, retval]*/ int * pnTransition);
    STDMETHOD(put_Transition)(/*[in]*/ int nTransition);

    // IDXEffect methods.

    STDMETHOD(get_Capabilities)(long * plCapabilities);
    STDMETHOD(get_Duration)(float * pflDuration);
    STDMETHOD(put_Duration)(float flDuration);
    STDMETHOD(get_Progress)(float * pflProgress);
    STDMETHOD(put_Progress)(float flProgress);
    STDMETHOD(get_StepResolution)(float * pflStepResolution);

    // IDXTransform methods.

    STDMETHOD(Execute)(const GUID * pRequestID, const DXBNDS * pPortionBnds,
                       const DXVEC * pPlacement);
    STDMETHOD(GetInOutInfo)(BOOL bIsOutput, ULONG ulIndex, DWORD * pdwFlags,
                            GUID * pIDs, ULONG * pcIDs, 
                            IUnknown ** ppUnkCurrentObject);
    STDMETHOD(GetMiscFlags)(DWORD * pdwMiscFlags);
    STDMETHOD(GetQuality)(float * pfQuality);
    STDMETHOD(MapBoundsIn2Out)(const DXBNDS * pInBounds, ULONG ulNumInBnds,
                               ULONG ulOutIndex, DXBNDS * pOutBounds);
    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                               ULONG ulInIndex, DXBNDS * pInBounds);
    STDMETHOD(SetMiscFlags)(DWORD dwMiscFlags);
    STDMETHOD(SetQuality)(float fQuality);
    STDMETHOD(Setup)(IUnknown * const * punkInputs, ULONG ulNumInputs,
	             IUnknown * const * punkOutputs, ULONG ulNumOutputs,	
                     DWORD dwFlags);

    // IDXSurfacePick methods.

    STDMETHOD(PointPick)(const DXVEC * pvecOutputPoint, 
                         ULONG * pnInputSurfaceIndex,
                         DXVEC * pvecInputPoint);

    // IDXBaseObject methods.

    STDMETHOD(GetGenerationId)(ULONG * pnID);
    STDMETHOD(GetObjectSize)(ULONG * pcbSize);
    STDMETHOD(IncrementGenerationId)(BOOL fRefresh);

    // IObjectWithSite methods.

    STDMETHOD(SetSite)(IUnknown * pUnkSite);
    STDMETHOD(GetSite)(REFIID riid, void ** ppvSite);
};

#endif //__REVEALTRANS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\revealtrans.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       revealtrans.cpp
//
//  Overview:       The RevealTrans transform simply wraps other transforms to 
//                  ensure backward compatibility for the revealtrans filter.
//
//  Change History:
//  1999/09/18  a-matcal    Created.
//  1999/10/06  a-matcal    Fix bug where setup was saving the input and ouput
//                          surface pointers, but not saving the number of 
//                          inputs and outputs.
//  2000/01/16  mcalkins    Change Box in/out to use "rectangle" setting instead
//                          of "square".
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "revealtrans.h"
#include "time.h"

#define SafeRelease(pointer) if (pointer) { pointer->Release(); } pointer = NULL

static const CLSID * g_apclsidTransition[] = {
    &CLSID_DXTIris,             //  0 Box in
    &CLSID_DXTIris,             //  1 Box out
    &CLSID_DXTIris,             //  2 Circle in
    &CLSID_DXTIris,             //  3 Circle out
    &CLSID_DXTGradientWipe,     //  4 Wipe up
    &CLSID_DXTGradientWipe,     //  5 Wipe down
    &CLSID_DXTGradientWipe,     //  6 Wipe right
    &CLSID_DXTGradientWipe,     //  7 Wipe left
    &CLSID_DXTBlinds,           //  8 Vertical blinds
    &CLSID_DXTBlinds,           //  9 Horizontal blinds
    &CLSID_DXTCheckerBoard,     // 10 Checkerboard across
    &CLSID_DXTCheckerBoard,     // 11 Checkerboard down
    &CLSID_DXTRandomDissolve,   // 12 Random dissolve
    &CLSID_DXTBarn,             // 13 Split vertical in
    &CLSID_DXTBarn,             // 14 Split vertical out
    &CLSID_DXTBarn,             // 15 Split horizontal in
    &CLSID_DXTBarn,             // 16 Split horizontal out
    &CLSID_DXTStrips,           // 17 Strips left down
    &CLSID_DXTStrips,           // 18 Strips left up
    &CLSID_DXTStrips,           // 19 Strips right down
    &CLSID_DXTStrips,           // 20 Strips right up
    &CLSID_DXTRandomBars,       // 21 Random bars horizontal
    &CLSID_DXTRandomBars,       // 22 Random bars vertical
    &CLSID_NULL                 // 23 Random
};

static const int g_cTransitions = sizeof(g_apclsidTransition) / 
                                  sizeof(g_apclsidTransition[0]);




//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans
//
//------------------------------------------------------------------------------
CDXTRevealTrans::CDXTRevealTrans() :
    m_nTransition(23),
    m_cInputs(0),
    m_cOutputs(0),
    m_flProgress(0.0F),
    m_flDuration(1.0F)
{
    m_apunkInputs[0]   = NULL;
    m_apunkInputs[1]   = NULL;
    m_apunkOutputs[0]  = NULL;

    srand((unsigned int)time(NULL));
}
//  Method: CDXTRevealTrans


//+-----------------------------------------------------------------------------
//
//  Method: ~CDXTRevealTrans
//
//------------------------------------------------------------------------------
CDXTRevealTrans::~CDXTRevealTrans()
{
    _FreeSurfacePointers();
}
//  Method: ~CDXTRevealTrans


//+-----------------------------------------------------------------------------
//
//  Method: _FreeSurfacePointers
//
//------------------------------------------------------------------------------
void
CDXTRevealTrans::_FreeSurfacePointers()
{
    SafeRelease(m_apunkInputs[0]);
    SafeRelease(m_apunkInputs[1]);
    SafeRelease(m_apunkOutputs[0]);
}
//  Method: _FreeSurfacePointers


//+-----------------------------------------------------------------------------
//
//  Method: FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT
CDXTRevealTrans::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  Method: FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::Execute, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::Execute(const GUID * pRequestID, const DXBNDS * pPortionBnds,
                         const DXVEC * pPlacement)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->Execute(pRequestID, pPortionBnds, pPlacement);
}
//  Method: CDXTRevealTrans::Execute, IDXTransform



//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::GetInOutInfo, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::GetInOutInfo(BOOL bIsOutput, ULONG ulIndex, DWORD * pdwFlags,
                              GUID * pIDs, ULONG * pcIDs, 
                              IUnknown ** ppUnkCurrentObject)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->GetInOutInfo(bIsOutput, ulIndex, pdwFlags, pIDs, 
                                         pcIDs, ppUnkCurrentObject);
}
//  Method: CDXTRevealTrans::GetInOutInfo, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::GetMiscFlags, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::GetMiscFlags(DWORD * pdwMiscFlags)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->GetMiscFlags(pdwMiscFlags);
}
//  Method: CDXTRevealTrans::GetMiscFlags, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::GetQuality, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::GetQuality(float * pfQuality)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->GetQuality(pfQuality);
}
//  Method: CDXTRevealTrans::GetQuality, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::MapBoundsIn2Out, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::MapBoundsIn2Out(const DXBNDS * pInBounds, ULONG ulNumInBnds,
                                 ULONG ulOutIndex, DXBNDS * pOutBounds)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->MapBoundsIn2Out(pInBounds, ulNumInBnds, ulOutIndex,
                                            pOutBounds);
}
//  Method: CDXTRevealTrans::MapBoundsIn2Out, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                                 ULONG ulInIndex, DXBNDS * pInBounds)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->MapBoundsOut2In(ulOutIndex, pOutBounds, ulInIndex,
                                            pInBounds);
}
//  Method: CDXTRevealTrans::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::SetMiscFlags, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::SetMiscFlags(DWORD dwMiscFlags)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->SetMiscFlags(dwMiscFlags);
}
//  Method: CDXTRevealTrans::SetMiscFlags, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::SetQuality, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::SetQuality(float fQuality)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->SetQuality(fQuality);
}
//  Method: CDXTRevealTrans::SetQuality, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::Setup, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::Setup(IUnknown * const * punkInputs, ULONG ulNumInputs,
	               IUnknown * const * punkOutputs, ULONG ulNumOutputs,	
                       DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (!m_spDXTransform)
    {
        hr = DXTERR_UNINITIALIZED;

        goto done;
    }

    hr = m_spDXTransform->Setup(punkInputs, ulNumInputs, punkOutputs, 
                                ulNumOutputs, dwFlags);

    if (FAILED(hr))
    {
        goto done;
    }

    _ASSERT(2 == ulNumInputs);
    _ASSERT(1 == ulNumOutputs);

    _FreeSurfacePointers();

    m_apunkInputs[0]   = punkInputs[0];
    m_apunkInputs[1]   = punkInputs[1];
    m_apunkOutputs[0]  = punkOutputs[0];

    m_apunkInputs[0]->AddRef();
    m_apunkInputs[1]->AddRef();
    m_apunkOutputs[0]->AddRef();

    m_cInputs   = ulNumInputs;
    m_cOutputs  = ulNumOutputs;
    
done:

    return hr;
}
//  Method: CDXTRevealTrans::Setup, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: get_Transition, IDXTRevealTrans
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::get_Transition(int * pnTransition)
{
    HRESULT hr = S_OK;

    if (NULL == pnTransition)
    {
        hr = E_POINTER;

        goto done;
    }

    *pnTransition = m_nTransition;

done:

    return hr;
}
//  Method: get_Transition, IDXTRevealTrans


//+-----------------------------------------------------------------------------
//
//  Method: put_Transition, IDXTRevealTrans
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::put_Transition(int nTransition)
{
    HRESULT hr      = S_OK;
    int     nIndex  = 0;
    
    CComPtr<IDXTransform>   spDXTransform;
    CComPtr<IDXEffect>      spDXEffect;
    CComPtr<IDXSurfacePick> spDXSurfacePick;

    // This is not the usual parameter checking we would do in a transform, but
    // to old filter code behaves this way so we do it for compatibility.

    if (nTransition < 0)
    {
        nTransition = 0;
    }
    else if (nTransition >= g_cTransitions)
    {
        nTransition = g_cTransitions - 1;
    }

    if (23 == nTransition)
    {
        // Choose random transition excluding 23.

        nIndex = rand() % (g_cTransitions - 1);
    }
    else
    {
        nIndex = nTransition;
    }

    // nIndex can't be 23 at this point, so sometimes m_nTransition will be set
    // to 23 outside of this function to make sure that the DXTransform is 
    // recreated when needed, for instance, when the DXTransformFactory changes.

    if ((nIndex == m_nTransition) && !!m_spDXTransform)
    {
        // We already have this transition, no need to re-create.

        goto done;
    }

    hr = m_spDXTransformFactory->CreateTransform(m_apunkInputs, m_cInputs,
                                                 m_apunkOutputs, m_cOutputs,
                                                 NULL, NULL,
                                                 *g_apclsidTransition[nIndex],
                                                 __uuidof(IDXTransform),
                                                 (void **)&spDXTransform);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = _InitializeNewTransform(nIndex, spDXTransform);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDXTransform->QueryInterface(__uuidof(IDXEffect), 
                                       (void **)&spDXEffect);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDXEffect->put_Progress(m_flProgress);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDXEffect->put_Duration(m_flDuration);

    if (FAILED(hr))
    {
        goto done;
    }

    // Although filters in general are not required to support the 
    // IDXSurfacePick interface, all of the filters represented by revealtrans
    // are.

    hr = spDXTransform->QueryInterface(__uuidof(IDXSurfacePick),
                                       (void **)&spDXSurfacePick);

    if (FAILED(hr))
    {
        goto done;
    }

    m_spDXTransform.Release();
    m_spDXTransform = spDXTransform;

    m_spDXEffect.Release();
    m_spDXEffect = spDXEffect;

    m_spDXSurfacePick.Release();
    m_spDXSurfacePick = spDXSurfacePick;

    m_nTransition = nTransition;

done:

    return hr;
}
//  Method: put_Transition, IDXTRevealTrans


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::_InitializeNewTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::_InitializeNewTransform(int nTransition, 
                                         IDXTransform * pDXTransform)
{
    HRESULT hr  = S_OK;

    DISPID      dispid          = DISPID_PROPERTYPUT;
    VARIANT     avarArg[3];   
    DISPID      adispid[3]      = {0, 0, 0};
    DISPPARAMS  aDispParams[3]  = {{&avarArg[0], &dispid, 1, 1}, 
                                   {&avarArg[1], &dispid, 1, 1},
                                   {&avarArg[2], &dispid, 1, 1}};

    CComPtr<IDispatch> spDispatch;

    _ASSERT(nTransition < g_cTransitions);

    VariantInit(&avarArg[0]);
    VariantInit(&avarArg[1]);
    VariantInit(&avarArg[2]);

    // Get dispatch interface.

    hr = pDXTransform->QueryInterface(__uuidof(IDispatch), 
                                      (void **)&spDispatch);

    if (FAILED(hr))
    {
        goto done;
    }

    // Setup.

    switch(nTransition)
    {
    case  0:    //  0 Box in
    case  1:    //  1 Box out
        
        // Iris style.

        adispid[0]          = DISPID_CRIRIS_IRISSTYLE;
        avarArg[0].vt       = VT_BSTR;
        avarArg[0].bstrVal  = SysAllocString(L"rectangle");

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        // Reverse

        adispid[1]          = DISPID_CRIRIS_MOTION;
        avarArg[1].vt       = VT_BSTR;

        avarArg[1].bstrVal  = SysAllocString((0 == nTransition) ? 
                                             L"in" : L"out");

        if (NULL == avarArg[1].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case  2:    //  2 Circle in
    case  3:    //  3 Circle out

        adispid[0]          = DISPID_CRIRIS_IRISSTYLE;
        avarArg[0].vt       = VT_BSTR;
        avarArg[0].bstrVal  = SysAllocString(L"circle");

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        // Reverse

        adispid[1]          = DISPID_CRIRIS_MOTION;
        avarArg[1].vt       = VT_BSTR;
        avarArg[1].bstrVal  = SysAllocString((2 == nTransition) ? 
                                             L"in" : L"out");

        if (NULL == avarArg[1].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case  4:    //  4 Wipe up
    case  5:    //  5 Wipe down
    case  6:    //  6 Wipe right
    case  7:    //  7 Wipe left

        // Gradient size.

        adispid[0]          = DISPID_DXW_GradientSize;
        avarArg[0].vt       = VT_R4;
        avarArg[0].fltVal   = 0.0F;

        // Wipe style.

        adispid[1]          = DISPID_DXW_WipeStyle;
        avarArg[1].vt       = VT_I4;

        if ((4 == nTransition) || (5 == nTransition))
        {
            avarArg[1].lVal     = DXWD_VERTICAL;
        }
        else
        {
            avarArg[1].lVal     = DXWD_HORIZONTAL;
        }

        // Reverse.

        adispid[2]          = DISPID_DXW_Motion;
        avarArg[2].vt       = VT_BSTR;

        if ((4 == nTransition) || (7 == nTransition))
        {
            avarArg[2].bstrVal  = SysAllocString(L"reverse");
        }
        else
        {
            avarArg[2].bstrVal  = SysAllocString(L"forward");
        }
            
        if (NULL == avarArg[2].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case  8:    //  8 Vertical blinds
    case  9:    //  9 Horizontal blinds

        // Bands.

        adispid[0]          = DISPID_CRBLINDS_BANDS;
        avarArg[0].vt       = VT_I4;
        avarArg[0].lVal     = 6;

        // Direction.

        adispid[1]          = DISPID_CRBLINDS_DIRECTION;
        avarArg[1].vt       = VT_BSTR;

        if (8 == nTransition)
        {
            avarArg[1].bstrVal = SysAllocString(L"right");
        }
        else
        {
            avarArg[1].bstrVal = SysAllocString(L"down");
        }

        if (NULL == avarArg[1].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case 10:    // 10 Checkerboard across
    case 11:    // 11 Checkerboard down

        // Direction.

        adispid[0]          = DISPID_DXTCHECKERBOARD_DIRECTION;
        avarArg[0].vt       = VT_BSTR;

        if (10 == nTransition)
        {
            avarArg[0].bstrVal = SysAllocString(L"right");
        }
        else
        {
            avarArg[0].bstrVal = SysAllocString(L"down");
        }

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case 12:    // 12 Random dissolve

        // No properties.

        break;

    case 13:    // 13 Split vertical in
    case 14:    // 14 Split vertical out
    case 15:    // 15 Split horizontal in
    case 16:    // 16 Split horizontal out

        // Doors opening?

        adispid[0]      = DISPID_CRBARN_MOTION;
        avarArg[0].vt   = VT_BSTR;

        if ((14 == nTransition) || (16 == nTransition))
        {
            avarArg[0].bstrVal = SysAllocString(L"out");
        }
        else
        {
            avarArg[0].bstrVal = SysAllocString(L"in");
        }

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        // Vertical doors?

        adispid[1]      = DISPID_CRBARN_ORIENTATION;
        avarArg[1].vt   = VT_BSTR;

        if ((13 == nTransition) || (14 == nTransition))
        {
            avarArg[1].bstrVal = SysAllocString(L"vertical");
        }
        else
        {
            avarArg[1].bstrVal = SysAllocString(L"horizontal");
        }

        if (NULL == avarArg[1].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case 17:    // 17 Strips left down
    case 18:    // 18 Strips left up
    case 19:    // 19 Strips right down
    case 20:    // 20 Strips right up

        // Movement.

        adispid[0]          = DISPID_DXTSTRIPS_MOTION;
        avarArg[0].vt       = VT_BSTR;

        if (17 == nTransition)
        {
            avarArg[0].bstrVal = SysAllocString(L"leftdown");
        }
        else if (18 == nTransition)
        {
            avarArg[0].bstrVal = SysAllocString(L"leftup");
        }
        else if (19 == nTransition)
        {
            avarArg[0].bstrVal = SysAllocString(L"rightdown");
        }
        else // 20 == nTransition
        {
            avarArg[0].bstrVal = SysAllocString(L"rightup");
        }

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case 21:    // 21 Random bars horizontal
    case 22:    // 22 Random bars vertical

        // Vertical ?

        adispid[0]      = DISPID_DXTRANDOMBARS_ORIENTATION;
        avarArg[0].vt   = VT_BSTR;

        avarArg[0].bstrVal = SysAllocString((22 == nTransition) ? 
                                            L"vertical" : L"horizontal");

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    default:
        
        _ASSERT(false);
    }

    if (avarArg[0].vt != VT_EMPTY)
    {
        hr = spDispatch->Invoke(adispid[0], IID_NULL, LOCALE_USER_DEFAULT,
                                DISPATCH_PROPERTYPUT, &aDispParams[0], NULL,
                                NULL, NULL);
    }

    if (avarArg[1].vt != VT_EMPTY)
    {
        hr = spDispatch->Invoke(adispid[1], IID_NULL, LOCALE_USER_DEFAULT,
                                DISPATCH_PROPERTYPUT, &aDispParams[1], NULL,
                                NULL, NULL);
    }

    if (avarArg[2].vt != VT_EMPTY)
    {
        hr = spDispatch->Invoke(adispid[2], IID_NULL, LOCALE_USER_DEFAULT,
                                DISPATCH_PROPERTYPUT, &aDispParams[2], NULL,
                                NULL, NULL);
    }

done:

    VariantClear(&avarArg[0]);
    VariantClear(&avarArg[1]);
    VariantClear(&avarArg[2]);

    return hr;
}



//+-----------------------------------------------------------------------------
//
//  IDXEffect wrappers
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::get_Capabilities(long * plCapabilities)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXEffect->get_Capabilities(plCapabilities);
}

STDMETHODIMP
CDXTRevealTrans::get_Duration(float * pflDuration)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXEffect->get_Duration(pflDuration);
}

STDMETHODIMP
CDXTRevealTrans::put_Duration(float flDuration)
{
    HRESULT hr = S_OK;

    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    if (!!m_spDXEffect)
    {
        hr = m_spDXEffect->put_Duration(flDuration);
    }
    else if (flDuration <= 0.0F)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        m_flDuration = flDuration;
    }

    return hr;
}

STDMETHODIMP
CDXTRevealTrans::get_Progress(float * pflProgress)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXEffect->get_Progress(pflProgress);
}

STDMETHODIMP
CDXTRevealTrans::put_Progress(float flProgress)
{
    HRESULT hr = S_OK;

    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    if (!!m_spDXEffect)
    {
        hr = m_spDXEffect->put_Progress(flProgress);
    }
    else if ((flProgress < 0.0F) || (flProgress > 1.0F))
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        m_flProgress = flProgress;
    }

    return hr;
}

STDMETHODIMP
CDXTRevealTrans::get_StepResolution(float * pflStepResolution)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXEffect->get_StepResolution(pflStepResolution);
}
//  IDXEffect wrappers


//+-----------------------------------------------------------------------------
//
//  IDXSurfacePick wrappers
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::PointPick(const DXVEC * pvecOutputPoint, 
                           ULONG * pnInputSurfaceIndex,
                           DXVEC * pvecInputPoint)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    // All the DXTransforms hosted by revealtrans are required to support 
    // surface picking.

    _ASSERT(!!m_spDXSurfacePick);

    return m_spDXSurfacePick->PointPick(pvecOutputPoint, pnInputSurfaceIndex,
                                        pvecInputPoint);
}
//  IDXSurfacePick wrappers


//+-----------------------------------------------------------------------------
//
//  IDXBaseObject wrappers
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::GetGenerationId(ULONG * pnID)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->GetGenerationId(pnID);
}

STDMETHODIMP
CDXTRevealTrans::GetObjectSize(ULONG * pcbSize)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->GetObjectSize(pcbSize);
}

STDMETHODIMP
CDXTRevealTrans::IncrementGenerationId(BOOL fRefresh)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->IncrementGenerationId(fRefresh);
}
//  IDXBaseObject wrappers


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTRevealTrans::SetSite, IObjectWithSite
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::SetSite(IUnknown * pUnkSite)
{
    m_spUnkSite = pUnkSite;

    if (pUnkSite)
    {
        HRESULT hr  = S_OK;

        CComPtr<IDXTransformFactory> spDXTransformFactory;

        hr = pUnkSite->QueryInterface(__uuidof(IDXTransformFactory),
                                      (void **)&spDXTransformFactory);

        if (SUCCEEDED(hr))
        {
            int nTransition         = m_nTransition;
            m_spDXTransformFactory  = spDXTransformFactory;

            // Setting m_nTransition to 23 makes sure put_Transition will
            // create a new DXTransform object.

            m_nTransition = 23;

            // Recreate transition with the new DXTransformFactory

            hr = put_Transition(nTransition);

            // put_Transition will set m_nTransition if it succeeds, but we need
            // to make sure it's set properly if it fails as well.

            m_nTransition = nTransition;
        }
    }

    return S_OK;
}
//  Method:  CDXTRevealTrans::SetSite, IObjectWithSite


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTRevealTrans::GetSite, IObjectWithSite
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::GetSite(REFIID riid, void ** ppvSite)
{
    if (!m_spUnkSite)
    {
        return E_FAIL;
    }
    else
    {
        return m_spUnkSite->QueryInterface(riid, ppvSite);
    }
}
//  Method:  CDXTRevealTrans::GetSite, IObjectWithSite
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\shadow.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    shodow.cpp
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	Implementation of CShadow, the Shadow transform
//
// Change History:
//
// 05/20/99 PhilLu      Move code from dtcss to dxtmsft. New implementation of
//                      shadow algorithm.
// 09/04/99 a-matcal    Fixed memory overrun issues.
// 12/03/99 a-matcal    Implement IDXTClipOrigin interface.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "Shadow.h"
#include "dxclrhlp.h"

DeclareTag(tagFilterShadow,  "Filter: Shadow",   "Shadow DXTransform info.");

                      //  0     45    90    135   180    225    270    315
SIZE g_Direction[8] = {{0,-1},{1,-1},{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1}};


//+-----------------------------------------------------------------------------
//
//  CShadow::CShadow
//
//------------------------------------------------------------------------------
CShadow::CShadow() :
    m_lStrength(8),
    m_lDirection(5),    // 225 degrees
    m_bstrColor(NULL)
{
    m_rgbColor          = DXSAMPLE(255,0,0,0);
    
    // Base class members.

    m_ulMaxImageBands   = 1; // disable banding
    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
}
//  CShadow::CShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::~CShadow
//
//------------------------------------------------------------------------------
CShadow::~CShadow()
{
    if (m_bstrColor)
    {
        SysFreeString(m_bstrColor);
    }
}
//  CShadow::~CShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CShadow::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_cpUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_bstrColor = SysAllocString(L"black");

    if (NULL == m_bstrColor)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CShadow::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CShadow::put_Color, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::put_Color(BSTR bstrColor)
{
    HRESULT hr          = S_OK;
    BSTR    bstrTemp    = NULL;
    DWORD   dwColor     = 0x00000000;

    DXSAMPLE rgbTemp;

    hr = DXColorFromBSTR(bstrColor, &dwColor);

    if (SUCCEEDED(hr))
    {
        bstrTemp = SysAllocString(bstrColor);

        if (NULL == bstrTemp)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }
    }
    else if (FAILED(hr) && (6 == SysStringLen(bstrColor)))
    {
        // Nasty back compat issue.  If the color conversion failed, let's
        // try putting a # in front of it because _someone_ decided when
        // they made the original filters not to require it.  grrrr....

        bstrTemp = SysAllocString(L"#RRGGBB");

        if (NULL == bstrTemp)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        wcsncpy(&bstrTemp[1], bstrColor, 6);

        hr = DXColorFromBSTR(bstrTemp, &dwColor);

        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        goto done;
    }

    rgbTemp = (DXSAMPLE)dwColor;

    // Lock and change color.

    Lock();

    if (m_rgbColor != rgbTemp)
    {
        m_rgbColor = (DXSAMPLE)dwColor;
        SetDirty();
    }

    // Replace color string with new color string regardless of whether the
    // actual color changed or not.

    Assert(bstrTemp);

    SysFreeString(m_bstrColor);

    m_bstrColor = bstrTemp;

    Unlock();

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  CShadow::put_Color, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::get_Color, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::get_Color(BSTR * pbstrColor)
{
    HRESULT hr = S_OK;

    if (NULL == pbstrColor)
    {
        hr = E_POINTER;

        goto done;
    }

    if (*pbstrColor != NULL)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    *pbstrColor = SysAllocString(m_bstrColor);

    if (NULL == *pbstrColor)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CShadow::get_Color, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::get_Strength, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::get_Strength(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lStrength;
    return S_OK;
}
//  CShadow::get_Strength, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::put_Strength, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::put_Strength(long lStrength)
{
    long Strength = min(max(lStrength, 1), 255);

    if (Strength != m_lStrength)
    {
        Lock();
        m_lStrength = Strength;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CShadow::put_Strength, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::get_Direction, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::get_Direction(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    // angle from direction code
    *pVal = m_lDirection*45;
    return S_OK;
}
//  CShadow::get_Direction, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::put_Direction, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::put_Direction(long newVal)
{
    int iDirection;

    Lock();
    if (newVal < 0)
    {
        // add enough multiples of 360 to make the angle positive
        newVal += ((-newVal-1)/360 + 1)*360;
    }

    // discretize the angle into a direction code 0 .. 7
    iDirection = (newVal + 22)%360 / 45;
    
    if (m_lDirection != iDirection)
    {
        m_lDirection = iDirection;
        SetDirty();
    }
    Unlock();

    return S_OK;
}
//  CShadow::get_Direction, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CShadow::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (SUCCEEDED(hr))
    {
        m_bndsInput = bndsInput;
    }

    return hr;

}
//  CShadow::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CShadow::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CShadow::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                       CDXDVec & InVec)
{
    HRESULT         hr                  = S_OK;
    DXSAMPLE        sample              = 0;
    POINT           pt                  = {0, 0};
    int             nShadowPixels       = 0;
    int             nInputPixelsToCheck = 0;
    int             i                   = 0;
    int             nAlphaStep          = 255 / (m_lStrength + 1);
    int             nAlpha              = 0;
    bool            fDiagonal           = true;

    CDXDBnds        bndsShadowInput;
    CDXDBnds        bndsActualInput;

    CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

    // This DXTransform only has one index so we know if an input is hit it will
    // be input 0.

    ulInputIndex = 0;

    // Is the shadow really diagonal?

    if (   (0 == g_Direction[m_lDirection].cx)
        || (0 == g_Direction[m_lDirection].cy))
    {
        fDiagonal = false;
    }

    // If the output point is not in the shadow area or the input area, it's in
    // one of the empty corners so just return that nothing was hit.

    if (   fDiagonal
        && _IsOutputPointInEmptyCorner(OutPoint))
    {
        hr = S_FALSE;

        goto done;
    }

    // What are the bounds of the input surface pixels we need to look at to
    // determine if the hit point is on a shadow.

    hr = MapBoundsOut2In(0, &OutPoint, 0, &bndsShadowInput);

    if (FAILED(hr))
    {
        goto done;
    }

    // Which input surface pixel if any directly relates to the output pixel to
    // be tested.

    hr = _GetActualInputBndsFromOutputBnds(OutPoint, bndsActualInput);

    if (FAILED(hr))
    {
        goto done;
    }

    // How many pixels do we need to test to caculate the alpha value of a
    // potential shadow pixel?

    if (fDiagonal)
    {
        nShadowPixels = min(bndsShadowInput.Width(), bndsShadowInput.Height());
    }
    else
    {
        nShadowPixels = max(bndsShadowInput.Width(), bndsShadowInput.Height());
    }

    // If there is an input point that directly relates to the output pixel to
    // be tested, we don't need to check that pixel, so reduce the number of
    // pixels to check by one.

    if (!bndsActualInput.BoundsAreEmpty())
    {
        nInputPixelsToCheck = nShadowPixels - 1;
    }
    else
    {
        nInputPixelsToCheck = nShadowPixels;
    }

    // Calculate nAlpha.
    // nAlpha is the alpha value of the shadow pixel if this output pixel
    // correclates to a shadow pixel.

    if (nInputPixelsToCheck)
    {
        // Initialize pt.

        if (g_Direction[m_lDirection].cx < 0)
        {
            pt.x = bndsShadowInput.Width() - 1;
        }

        if (g_Direction[m_lDirection].cy < 0)
        {
            pt.y = bndsShadowInput.Height() - 1;
        }

        // Lock surface to get access to pixels that need to be checked.

        hr = InputSurface(0)->LockSurface(&bndsShadowInput, m_ulLockTimeOut,
                                          DXLOCKF_READ, 
                                          __uuidof(IDXARGBReadPtr), 
                                          (void **)&spDXARGBReadPtr, NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        // Check input pixels

        for (i = 0; i < nInputPixelsToCheck; i++)
        {
            // Check pixel

            spDXARGBReadPtr->MoveToXY(pt.x, pt.y);

            spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

            if (   (sample.Alpha != 0)
                && (nAlpha < sample.Alpha))
            {
                nAlpha = sample.Alpha - nAlphaStep;
            }
            else
            {
                nAlpha -= nAlphaStep;
            }

            // Move point.

            pt.x += g_Direction[m_lDirection].cx;
            pt.y += g_Direction[m_lDirection].cy;
        }

        spDXARGBReadPtr.Release();
    }

    // See if an input pixel directly is being displayed by this output pixel.

    if (!bndsActualInput.BoundsAreEmpty())
    {
        // An input pixel does correlate to this output point.  Check to see if
        // its alpha value is greater than the the alpha value of the shadow
        // pixel that would like to be rendered at this point.  The one with the
        // greater alpha value will be rendered.

        hr = InputSurface(0)->LockSurface(&bndsActualInput, m_ulLockTimeOut,
                                          DXLOCKF_READ,
                                          __uuidof(IDXARGBReadPtr), 
                                          (void **)&spDXARGBReadPtr, NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

        if (   (sample.Alpha != 0)
            && (sample.Alpha > nAlpha))
        {
            // An input pixel will be drawn to this output pixel.  Set the 
            // input point to return and we're done.

            bndsActualInput.GetMinVector(InVec);

            hr = S_OK;

            goto done;
        }
    }
    else if (nInputPixelsToCheck < m_lStrength)
    {
        // If the hit pixel is in the shadow only part of the output, make sure
        // the alpha value of the shadow hass been decreased adequately.

        nAlpha -= (nAlphaStep * (m_lStrength - nInputPixelsToCheck));
    }

    // At this point it's certain that no input surface point was hit.
    
    // If nAlpha is positive it means that a shadow was hit so this method
    // should return DXT_S_HITOUTPUT.  Otherwise return S_FALSE since no point
    // was hit.

    if (nAlpha > 0)
    {
        hr = DXT_S_HITOUTPUT;
    }
    else
    {
        hr = S_FALSE;
    }

done:

    if (IsTagEnabled(tagFilterShadow))
    {
        TraceTag((tagFilterShadow, 
                  "Output was hit at point x:%lu, y:%lu", 
                  OutPoint[DXB_X].Min, OutPoint[DXB_Y].Min));

        if (S_OK == hr)
        {
            TraceTag((tagFilterShadow, 
                      "Input was hit at point x:%lu, y:%lu", 
                      InVec[DXB_X], InVec[DXB_Y]));
        }
        else if (DXT_S_HITOUTPUT == hr)
        {
            TraceTag((tagFilterShadow,
                      "No input point hit, but the shadow area of the output"
                      " was hit."));
        }
        else if (S_FALSE == hr)
        {
            TraceTag((tagFilterShadow,
                      "No input point hit."));
        }
    }

    RRETURN2(hr, DXT_S_HITOUTPUT, S_FALSE);
}
//  CShadow::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CShadow::DetermineBnds, CDXBaseNTo1
//
//  This overrides the base function so as to map to an output surface larger
//  than the input surface.
//
//------------------------------------------------------------------------------
HRESULT 
CShadow::DetermineBnds(CDXDBnds & Bnds)
{
    SIZE size;

    Bnds.GetXYSize(size);

    // enlarge the surface by m_lStrength along the shadow direction
    if (g_Direction[m_lDirection].cx != 0)
    {
        size.cx += m_lStrength;
    }

    if (g_Direction[m_lDirection].cy != 0)
    {
        size.cy += m_lStrength;
    }

    Bnds.SetXYSize(size);
    return S_OK;
} /* CShadow::DetermineBnds */


//+-----------------------------------------------------------------------------
//
//  CShadow::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CShadow::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
{
    HRESULT         hr      = S_OK;
    unsigned int    y       = 0;

    DXSAMPLE *      pOperationBuffer    = NULL;
    DXSAMPLE *      pRowInBuffer        = NULL;
    DXPMSAMPLE *    pOutBuff            = NULL;
    DXPMSAMPLE *    pPMBuff             = NULL;

    SIZE            sizeOperationBuffer = {0, 0};

    CComPtr<IDXARGBReadWritePtr>    pDest;
    CComPtr<IDXARGBReadPtr>         pSrc;

    DXDITHERDESC dxdd;

    const unsigned int nDoWidth     = WI.DoBnds.Width();
    const unsigned int nDoHeight    = WI.DoBnds.Height();

    const int nXExpansion   = g_Direction[m_lDirection].cx != 0 ? m_lStrength : 0;
    const int nYExpansion   = g_Direction[m_lDirection].cy != 0 ? m_lStrength : 0;
    const int nOffsetX      = g_Direction[m_lDirection].cx < 0  ? m_lStrength : 0;
    const int nOffsetY      = g_Direction[m_lDirection].cy < 0  ? m_lStrength : 0;

    // Calculate operation buffer size.

    sizeOperationBuffer.cx = m_bndsInput.Width()  + nXExpansion;
    sizeOperationBuffer.cy = m_bndsInput.Height() + nYExpansion;

    // Lock output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, 
                                      IID_IDXARGBReadWritePtr, 
                                      (void**)&pDest, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    // Lock entire input surface.

    hr = InputSurface()->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    if (DoOver() && OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(nDoWidth);
    }

    //
    //  Set up the dither structure
    //
    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = NULL;                     // to be filled
        dxdd.cSamples       = nDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // The output buffer is a copy of input surface with an offset

    // TODO:    It's crazy to buffer the entire surface, stop it.

    pOperationBuffer = new DXSAMPLE[sizeOperationBuffer.cx
                                    * sizeOperationBuffer.cy];

    if (!pOperationBuffer) 
    {
        return E_OUTOFMEMORY;
    }

    memset(pOperationBuffer, 0, 
           sizeOperationBuffer.cx * sizeOperationBuffer.cy * sizeof(DXSAMPLE));

    // skip OffsetY rows, as well as OffsetX pixels on the current row

    pRowInBuffer = &pOperationBuffer[
                                (sizeOperationBuffer.cx * nOffsetY) // Row
                                + nOffsetX                          // + Column
                                ];

    for (y = 0; y < m_bndsInput.Height(); y++)
    {
        pSrc->MoveToRow(y);
        pSrc->Unpack(pRowInBuffer, m_bndsInput.Width(), FALSE);

        pRowInBuffer += sizeOperationBuffer.cx;
    }

    // create shadow effect in the buffer

    _PropagateShadow(pOperationBuffer, sizeOperationBuffer.cx, 
                     sizeOperationBuffer.cy);

    // copy the result to output surface

    pRowInBuffer = &pOperationBuffer[
                        (sizeOperationBuffer.cx * WI.DoBnds.Top())  // Row
                        + WI.DoBnds.Left()                          // + Column
                        ];

    for (y = 0; y < nDoHeight; y++)
    {
        // Move to the appropriate row of the output surface.

        pDest->MoveToRow(y);

        if (DoDither())
        {
            dxdd.pSamples = pRowInBuffer;
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            pPMBuff = DXPreMultArray(pRowInBuffer, nDoWidth);
            pDest->OverArrayAndMove(pOutBuff, pPMBuff, nDoWidth);
        }
        else
        {
            pDest->PackAndMove(pRowInBuffer, nDoWidth);
        }

        pRowInBuffer += sizeOperationBuffer.cx;
    }

    delete [] pOperationBuffer;

    return hr;
}
//  CShadow::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CShadow::MapBoundsOut2In, IDXTransform
//
//  Overview:
//      To implement this function, we convert all coordinates to what they 
//      would be if the x shadow and y shadow were both cast in the positive
//      direction (to the right or down.)  Then we find the required bounds.
//      Then, after finding the smallest bounds required, we mirror them back
//      if we've converted the x or y coordinates.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CShadow::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                         ULONG ulInIndex, DXBNDS * pInBounds)
{
    bool        fDiagonal   =    g_Direction[m_lDirection].cx 
                              && g_Direction[m_lDirection].cy;

    CDXDBnds    bndsMirroredOutputRequired(*pOutBounds);
    
    if (ulOutIndex || ulInIndex)
    {
        return E_INVALIDARG;
    }

    if (!pOutBounds || !pInBounds)
    {
        return E_POINTER;
    }

    if (NULL == InputSurface())
    {
        return E_UNEXPECTED;
    }

    // Mirror coordinates as if shadow is being cast down and/or to the right.

    if (g_Direction[m_lDirection].cx < 0)
    {
        long n = bndsMirroredOutputRequired[DXB_X].Min;

        bndsMirroredOutputRequired[DXB_X].Min = (m_bndsInput.Width() + m_lStrength) 
                                                - bndsMirroredOutputRequired[DXB_X].Max;
        bndsMirroredOutputRequired[DXB_X].Max = (m_bndsInput.Width() + m_lStrength) - n;
    }

    if (g_Direction[m_lDirection].cy < 0)
    {
        long n = bndsMirroredOutputRequired[DXB_Y].Min;

        bndsMirroredOutputRequired[DXB_Y].Min = (m_bndsInput.Height() + m_lStrength) 
                                                - bndsMirroredOutputRequired[DXB_Y].Max;
        bndsMirroredOutputRequired[DXB_Y].Max = (m_bndsInput.Height() + m_lStrength) - n;
    }

    // Find minimum required input bounds needed to produce output bounds.

    *pInBounds = bndsMirroredOutputRequired;

    // Find the miniumum x input bound required if there is a shadow to the left
    // or right.

    if (g_Direction[m_lDirection].cx)
    {
        // If the shadow is diagonal, we may be able to minimize the bounds even
        // further.

        if (   fDiagonal
            && (bndsMirroredOutputRequired[DXB_Y].Max <= m_lStrength))
        {
            pInBounds->u.D[DXB_X].Min -= (bndsMirroredOutputRequired[DXB_Y].Max - 1);
        }
        else
        {
            pInBounds->u.D[DXB_X].Min -= m_lStrength;
        }
    }

    if (g_Direction[m_lDirection].cy)
    {
        // If the shadow is diagonal, we may be able to minimize the bounds even
        // further.

        if (   fDiagonal
            && (bndsMirroredOutputRequired[DXB_X].Max <= m_lStrength))
        {
            pInBounds->u.D[DXB_Y].Min -= (bndsMirroredOutputRequired[DXB_X].Max - 1);
        }
        else
        {
            pInBounds->u.D[DXB_Y].Min -= m_lStrength;
        }
    }

    // This part is tricky, if one of the minimum output bounds is outside the
    // input area and the shadow is diagonal, we can reduce the required input 
    // bounds even further.

    if (fDiagonal)
    {
        int nXDist = bndsMirroredOutputRequired[DXB_X].Min - m_bndsInput.Width();

        int nYDist = bndsMirroredOutputRequired[DXB_Y].Min - m_bndsInput.Height();

        if (   (nXDist > 0) 
            || (nYDist > 0))
        {
            if (nXDist > nYDist)
            {
                pInBounds->u.D[DXB_Y].Max -= nXDist;
            }
            else
            {
                pInBounds->u.D[DXB_X].Max -= nYDist;
            }
        }
    }

    // Clip bounds to input surface bounds.

    ((CDXDBnds *)pInBounds)->IntersectBounds(m_bndsInput);

    // Mirror required input coordinates if we mirrored the required output
    // coordinates.

    if (g_Direction[m_lDirection].cx < 0)
    {
        long n = pInBounds->u.D[DXB_X].Min;

        pInBounds->u.D[DXB_X].Min = m_bndsInput.Width() 
                                    - pInBounds->u.D[DXB_X].Max;
        pInBounds->u.D[DXB_X].Max = m_bndsInput.Width() - n;
    }

    if (g_Direction[m_lDirection].cy < 0)
    {
        long n = pInBounds->u.D[DXB_Y].Min;

        pInBounds->u.D[DXB_Y].Min = m_bndsInput.Height() 
                                    - pInBounds->u.D[DXB_Y].Max;
        pInBounds->u.D[DXB_Y].Max = m_bndsInput.Height() - n;
    }

    return S_OK;
}
//  CShadow::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  CShadow::GetClipOrigin, IDXTClipOrigin
//
//------------------------------------------------------------------------------
STDMETHODIMP
CShadow::GetClipOrigin(DXVEC * pvecClipOrigin)
{
    if (NULL == pvecClipOrigin)
    {
        return E_POINTER;
    }

    if (g_Direction[m_lDirection].cx < 0)
    {
        pvecClipOrigin->u.D[DXB_X] = m_lStrength;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_X] = 0;
    }

    if (g_Direction[m_lDirection].cy < 0)
    {
        pvecClipOrigin->u.D[DXB_Y] = m_lStrength;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_Y] = 0;
    }

    return S_OK;
}
//  CShadow::GetClipOrigin, IDXTClipOrigin


//+-----------------------------------------------------------------------------
//
//  CShadow::_GetActualInputBndsFromOutputBnds
//
//  Overview:   This takes a set of output bounds and gives the input surface
//              bounds needed to generate the actual input (non-shadow) portion
//              for that are of the output.
//
//  Returns:    
//      S_FALSE If no input bounds are needed to generate the actual input 
//              (non-shadow) portion for that area of the output.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CShadow::_GetActualInputBndsFromOutputBnds(const CDXDBnds & bndsOutput,
                                           CDXDBnds & bndsActualInput)
{
    CDXDVec     vecActualInputOffset;

    if (g_Direction[m_lDirection].cx < 0)
    {
        vecActualInputOffset[DXB_X] -= m_lStrength;
    }

    if (g_Direction[m_lDirection].cy < 0)
    {
        vecActualInputOffset[DXB_Y] -= m_lStrength;
    }

    bndsActualInput = bndsOutput;

    bndsActualInput.Offset(vecActualInputOffset);
    bndsActualInput.IntersectBounds(m_bndsInput);

    if (bndsActualInput.BoundsAreEmpty())
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}
//  CShadow::_GetActualInputBndsFromOutputBnds


//+-----------------------------------------------------------------------------
//
//  CShadow::_PropagateShadow
//
//  Overview:
//
//      Propagate the Alpha value of the opague pixels to transparent pixels
//      along the shadow direction, to create a shadow effect.
//
//  Parameters:
//
//      pOperationBuffer    An array of DXSAMPLES that is the size of the output
//                          surface of this DXTransform.  When this function is
//                          called the pixels of the input surface will have
//                          been unpacked into the appropriate place in this
//                          array.
//      nWidth              Size of the width of the array and the final output
//                          of this DXTransform.
//      nHeight             Size of the height of the array and the final output
//                          of this DXTransform.
//
//------------------------------------------------------------------------------
void 
CShadow::_PropagateShadow(DXSAMPLE *pOperationBuffer, int nWidth, int nHeight)
{
    int     iCol    = 0;
    int     iRow    = 0;
    int     iAlpha  = 0;

    DXSAMPLE * pBufRow = NULL;
    DXSAMPLE * pBufPix = NULL;

    // Scan the image either in forward direction (top-down, left-right) or 
    // backward direction (bottom-up, right to left), depending on the shadow 
    // direction. The idea is to scan a source pixel before a shadow pixel.
    // Add shadow effect to the current pixel if a neighbour along the revers 
    // shadow direction has sufficiently larger alpha value than the alpha of 
    // the current pixel. Every generation of propagation decreases the alpha 
    // value by iAlphaStep = 255/(m_lStrength+1). Thus there is a maximum of 
    // m_lStrength steps to propapage a solid color to transparent ones.

    int iAlphaStep  = 255 / (m_lStrength + 1);
    int offset      = (g_Direction[m_lDirection].cy * nWidth) 
                      + g_Direction[m_lDirection].cx;
    
    if (offset > 0)
    {
        // For directions 2, 3, 4, and 5 scan forward.

        // Initialize pBufRow to point to the second row of the operation
        // buffer.

        pBufRow = pOperationBuffer + nWidth;

        // Loop to the last row.

        for (iRow = 1; iRow < nHeight; iRow++, pBufRow += nWidth)
        {
            // Initialize pBufPix to point to the second pixel in this row.

            pBufPix = pBufRow + 1;

            // Loop to the last pixel.

            for (iCol = 1; iCol < nWidth; iCol++, pBufPix++)
            {
                iAlpha = (pBufPix-offset)->Alpha - iAlphaStep;

                if (iAlpha > 0 && pBufPix->Alpha < iAlpha)
                {
                    // [2000/12/27 mcakins]
                    // This is a less than perfect solution because the pixel
                    // pointed to by pBufPix should be blended over the top of
                    // the shadow.

                    // Add shadow effect: change to shadow color.
                    // The alpha value is gradually decreasing.

                    *pBufPix        = m_rgbColor;
                    pBufPix->Alpha  = (BYTE)iAlpha;
                }
            }
        }
    }
    else // (offset < 0)
    {
        // For directions 0, 1, 6, and 7 scan backward.

        // Initialize pBufRow to point to the second to the last row of the
        // operation buffer.

        pBufRow = pOperationBuffer + (nWidth * (nHeight - 2));

        // Loop back to the first row.

        for (iRow = nHeight - 2; iRow >= 0; iRow--, pBufRow -= nWidth)
        {
            // Initialize pBufPix to point to the second to the last pixel in 
            // this row.

            pBufPix = pBufRow + nWidth - 2;

            // Loop back to the first pixel.

            for (iCol = nWidth-2; iCol >= 0; iCol--, pBufPix--)
            {
                iAlpha = (pBufPix-offset)->Alpha - iAlphaStep;

                if (iAlpha > 0 && pBufPix->Alpha < iAlpha)
                {
                    // [2000/12/27 mcakins]
                    // This is a less than perfect solution because the pixel
                    // pointed to by pBufPix should be blended over the top of
                    // the shadow.

                    // Add shadow effect: change to shadow color.
                    // The alpha value is gradually decreasing.

                    *pBufPix        = m_rgbColor;
                    pBufPix->Alpha  = (BYTE)iAlpha;
                }
            }
        }
    }
}
//  CShadow::_PropagateShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::_IsOutputPointInEmptyCorner
//
//  Overview:
//
//      If the shadow is diagonal, there will be two empty corners on the output
//      surface.  This method checks to see if an output point is on one of 
//      those empty corners.
//
//      Points on the lines used to define the corners for this method are NOT 
//      considered to be in the corners.
//
//  Notes:
//
//      Remember that down in the sense of a bitmap's coordinate system means
//      up on the screen when viewing these equations.  Therefore I when I use
//      the word "below" it means "above" when looking at the screen.
// 
//------------------------------------------------------------------------------
BOOL
CShadow::_IsOutputPointInEmptyCorner(const CDXDBnds & OutPoint)
{
    Assert(!OutPoint.BoundsAreEmpty());
    Assert(g_Direction[m_lDirection].cx != 0);
    Assert(g_Direction[m_lDirection].cy != 0);

    const int   x           = OutPoint[DXB_X].Min;
    const int   y           = OutPoint[DXB_Y].Min;
    int         yIntercept  = 0;

    if (g_Direction[m_lDirection].cx == g_Direction[m_lDirection].cy)
    {
        // Empty corners are top-right and bottom-left.
        //
        // In this case the slope of the lines is 1 so we use the following
        // general equation for both lines:
        //
        // y = x + b

        // Top-right corner.
        //
        // The y intercept for the line that defines this corner is:
        //
        //  - (m_bndsInput.Width() - 1)

        yIntercept = - ((int)m_bndsInput.Width() - 1);

        // y = x + yIntercept
        //
        // The definition of all points below this line is:
        //
        // y < x + yIntercept
        //
        // Solve for x:
        //
        // x > y - yIntercept

        if (x > (y - yIntercept))
        {
            return TRUE;
        }

        // Bottom-left corner.
        //
        // The y intercept for the line that defines this corner is:
        //
        // m_bndsInput.Height() - 1

        yIntercept = m_bndsInput.Height() - 1;

        // y = x + yIntercept
        // 
        // The definition of all points above this line is:
        //
        // y > x + yIntercept
        //
        // Solve for x:
        //
        // x < y - yIntercept

        if (x < (y - yIntercept))
        {
            return TRUE;
        }
    }
    else
    {
        // Empty corners are top-left and bottom-right.
        //
        // In this case the slope of the lines is -1 so we use the following
        // general equation for both lines:
        //
        // y = -x + b


        // Top-left corner.
        //
        // The y intercept for the line that defines this corner is m_lStrength.
        
        yIntercept = m_lStrength;

        // y = -x + yIntercept
        // 
        // The definition of all points below this line is:
        //
        // y < -x + yIntercept
        //
        // Rearrange:
        //
        // -x > y - yIntercept
        //
        // Multiply by -1:
        //
        // x < yIntercept - y

        if (x < (yIntercept - y))
        {
            return TRUE;
        }

        // Bottom-right corner.
        //
        // The y intercept for the line that defines this corner is:
        //
        //              m_lStrength 
        //  +  m_bndsInput.Height() 
        //  +   m_bndsInput.Width()
        //  -                     2

        yIntercept = m_lStrength + m_bndsInput.Height() + m_bndsInput.Width() 
                     - 2;

        // y = -x + yIntercept
        //
        // The definition of all points above this line is:
        //
        // y > -x + yIntercept
        //
        // Rearrange:
        //
        // -x < y - yIntercept
        //
        // Multiply by -1:
        // 
        // x > yIntercept - y

        if (x > (yIntercept - y))
        {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\rwipe.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:                rwipe.cpp
//
// Created:                 06/22/98
//
// Author:                  PhilLu
//
// Discription:             This file implements the Raidal Wipe transform.
//
// History
//
// 06/22/98 phillu      initial creation
// 07/02/98 phillu      return E_INVALIDARG rather than an error string; check
//                      for E_POINTER
// 07/10/98 phillu      implement OnSetSurfacePickOrder().
// 07/23/98 phillu      implement clipping
// 05/09/99 a-matcal    Optimization.
// 05/19/99 a-matcal    Check for out of memory in get_ functions allocating
//                      BSTRs.
// 10/22/99 a-matcal    Changed CRadialWipe class to CDXTRadialWipeBase base 
//                      class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "rwipe.h"

#define DRAWRECT            0xFFFFFFFFL
#define MIN_PIXELS_PER_ROW  10

const double    gc_PI       = 3.14159265358979323846;
const int       MAXBOUNDS   = 10;



//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::CDXTRadialWipeBase
//
//------------------------------------------------------------------------------
CDXTRadialWipeBase::CDXTRadialWipeBase() :
    m_eWipeStyle(CRRWS_CLOCK),
    m_cbndsDirty(0),
    m_iCurQuadrant(1),
    m_iPrevQuadrant(1),
    m_fOptimizationPossible(false),
    m_fOptimize(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}   
//  CDXTRadialWipeBase::CDXTRadialWipeBase


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::FinalConstruct
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTRadialWipeBase::FinalConstruct


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::OnSetup(DWORD dwFlags)
{
    HRESULT hr;

    CDXDBnds InBounds(InputSurface(0), hr);
    if (SUCCEEDED(hr))
    {
        InBounds.GetXYSize(m_sizeInput);
    }
    return hr;

} 
//  CDXTRadialWipeBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTRadialWipeBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                          ULONG & ulInToTest, ULONG aInIndex[], 
                                          BYTE aWeight[])
{
    long    pickX   = OutPoint.Left();
    long    pickY   = OutPoint.Top();
    long    XEdge   = 0;
    long    YEdge   = 0;        // intersection of ray with image boundary
    long    XBounds[MAXBOUNDS]; // to hold the X bounds of A/B image sections on 
                                // a scanline
    double  dAngle  = 0.0;

    // compute the intersection of a ray with the image boundary

    switch (m_eWipeStyle)
    {
        case CRRWS_CLOCK:
            dAngle = (2.0 * m_Progress - 0.5) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 
                           m_sizeInput.cx/2, m_sizeInput.cy/2,
                           cos(dAngle), sin(dAngle), XEdge, YEdge);

            break;

        case CRRWS_WEDGE:
            dAngle = (1.0 * m_Progress - 0.5) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 
                           m_sizeInput.cx/2, m_sizeInput.cy/2,
                           cos(dAngle), sin(dAngle), XEdge, YEdge);

            break;

        case CRRWS_RADIAL: // (wipe centered at the top-left corner)
            dAngle = (0.5 * m_Progress) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 0, 0, 
                           cos(dAngle), sin(dAngle), XEdge, YEdge);

            break;

        default:
            _ASSERT(0);

            break;

    }

    aInIndex[0] = 0;

    if ((pickX >= 0) && (pickX < m_sizeInput.cx) && (pickY >= 0) 
        && (pickY < m_sizeInput.cy))
    {
        long i = 0;

        _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, XEdge, YEdge, m_Progress,
                           pickY, XBounds);
    
        for (i = 0; XBounds[i] < pickX; i++)
        {
            aInIndex[0] = 1 - aInIndex[0];
        }
    }

    ulInToTest = 1;
    aWeight[0] = 255;
}
//  CDXTRadialWipeBase::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_IntersectRect
//
// A helper method that calculates the intersection of a ray with image boundary
// rectangle.
//
// Parameters:
//
//   width, height: image width and height in pixels
//   x0, y0:        origin of ray in image coordinates
//   dbldx, dbldy:  direction vector of ray, not necessarily normalized,
//                  but must be non-zero.
//   xi, yi:        computed intersection point rounded into image coordinates.
//
// Created by: PhilLu    06/22/98
// 
//------------------------------------------------------------------------------
void 
CDXTRadialWipeBase::_IntersectRect(long width, long height, long x0, long y0, 
                                   double dbldx, double dbldy, long & xi, 
                                   long & yi)
{
    double dblD;
    double dblDmin = (double)(width+height); // larger than the distance from (x0,y0) to rect boundary

    // (dbldx, dbldy) gives the direction vector, it must not be (0,0)

    _ASSERT(dbldx != 0.0 || dbldy != 0.0);

    // check intersection with top and bottom edge

    if(dbldy != 0.0)
    {
        dblD = -y0/dbldy;
        if (dblD > 0 && dblD < dblDmin)
            dblDmin = dblD;

        dblD = (height-1 - y0)/dbldy;
        if (dblD > 0 && dblD < dblDmin)
            dblDmin = dblD;
    }

    // check intersection with left and right edges

    if(dbldx != 0.0)
    {
        dblD = -x0/dbldx;
        if (dblD > 0 && dblD < dblDmin)
            dblDmin = dblD;

        dblD = (width-1 - x0)/dbldx;
        if (dblD > 0 && dblD < dblDmin)
            dblDmin = dblD;
    }

    xi = (long)(x0 + dblDmin*dbldx + 0.5);
    yi = (long)(y0 + dblDmin*dbldy + 0.5);

    _ASSERT(xi >= 0 && xi < width && yi >= 0 && yi < height);
}
//  CDXTRadialWipeBase::_IntersectRect


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_ScanlineIntervals
//
// A helper method that calculates the transition boundaries between the
// two image regions on a scanline. Based on the type of transform, the scanline
// consists of a series of alternating A and B image sections. The upper X
// bound of each section is calculated and saved in array XBounds. The number
// of useful entries in XBounds is variable. The end of array is determined
// when one entry equals to the scanline (image) width. It is assumed that
// XBounds[0] is the upper bound of the first A section. So if the scanline
// starts with a B section, XBounds[0] will be 0.
//
// Example 1: scanline length = 16, first section is from A image
//
//    AAAABBBBBAAABBAA      XBounds should contain {4, 9, 12, 14, 16}.
//
// Example 2: scanline length = 16, first section is from B image
//
//    BBBAAAAAABBBBBBB      XBounds should contain {0, 3, 9, 16}.
//
//
// Note: It is possible that some section has length 0 (i.e. two adjacent
//       bounds equal). {3, 9, 9, 16} is equivalent to {3, 16}.
//
// Parameters:
//
// width, height: width and height of both images.
// XEdge, YEdge: coordinates of the intersection point of a ray with the image boundary
// fProg: progress value from 0.0 to 1.0
// YScanline: Y cooridnate (height) of the current scanline
// XBounds: array to hold the computed X bounds on return.
//
//
// Created by: PhilLu    06/22/98
// 
//------------------------------------------------------------------------------
void 
CDXTRadialWipeBase::_ScanlineIntervals(long width, long height, 
                                       long XEdge, long YEdge, float fProg,
                                       long YScanline, long *XBounds)
{
    long CenterX, CenterY;

    // Center of image
    CenterX = width/2;
    CenterY = height/2;

    switch(m_eWipeStyle)
    {
    case CRRWS_CLOCK:
        if (YEdge >= CenterY)
        {
            // bottom half

            if (YScanline <= CenterY)
            {
                XBounds[0] = CenterX;
                XBounds[1] = width;
            }
            else if (YScanline <= YEdge)
            {
                // note YEdge-CenterY != 0 when we reach here, won't divide by 0
                XBounds[0] = CenterX + (XEdge-CenterX)*(YScanline-CenterY)/(YEdge-CenterY);
                XBounds[1] = width;
            }
            else if (XEdge < CenterX)
            {
                XBounds[0] = 0;
                XBounds[1] = width;
            }
            else
            {
                XBounds[0] = width;
            }
        }
        else if (XEdge < CenterX)
        {
            // top left quarter
            if (YScanline < YEdge)
            {
                XBounds[0] = CenterX;
                XBounds[1] = width;
            }
            else if (YScanline <= CenterY)
            {
                XBounds[0] = 0;
                XBounds[1] = CenterX + (XEdge-CenterX)*(YScanline-CenterY)/(YEdge-CenterY);
                XBounds[2] = CenterX;
                XBounds[3] = width;
            }
            else
            {
                XBounds[0] = 0;
                XBounds[1] = width;
            }
        }
        else // top right quarter: YEdge < CenterY && XEdge >= CenterX
        {
            if (YScanline < YEdge)
            {
                XBounds[0] = CenterX;
                XBounds[1] = width;
            }
            else if (YScanline <= CenterY)
            {
                XBounds[0] = CenterX;
                XBounds[1] = CenterX + (XEdge-CenterX)*(YScanline-CenterY)/(YEdge-CenterY);
                XBounds[2] = width;
            }
            else
            {
                XBounds[0] = width;
            }
        }

        // check a special case when progress is 0 or 1. The ray direction is not sufficient
        // for determining it is the beginning or end of sequence.
        if (fProg == 0.0)
        {
            XBounds[0] = width;
        }
        else if(fProg == 1.0)
        {
            XBounds[0] = 0;
            XBounds[1] = width;
        }

        break;

    case CRRWS_WEDGE:
        if (YEdge >= CenterY)
        {
            // bottom half

            if (YScanline <= CenterY)
            {
                XBounds[0] = 0;
                XBounds[1] = width;
            }
            else if (YScanline <= YEdge)
            {
                // note YEdge-CenterY != 0 when we reach here, won't divide by 0
                long deltaX = (XEdge-CenterX)*(YScanline-CenterY)/(YEdge-CenterY);
                XBounds[0] = 0;
                XBounds[1] = CenterX - deltaX;
                XBounds[2] = CenterX + deltaX;
                XBounds[3] = width;
            }
            else
            {
                XBounds[0] = width;
            }
        }
        else // YEdge < CenterY
        {
            if (YScanline < YEdge)
            {
                XBounds[0] = 0;
                XBounds[1] = width;
            }
            else if (YScanline <= CenterY)
            {
                long deltaX = (XEdge-CenterX)*(YScanline-CenterY)/(YEdge-CenterY);
                XBounds[0] = CenterX - deltaX;
                XBounds[1] = CenterX + deltaX;
                XBounds[2] = width;
            }
            else
            {
                XBounds[0] = width;
            }
        }

        break;

    case CRRWS_RADIAL:
        if (YScanline <= YEdge && YEdge > 0)
        {
            XBounds[0] = YScanline*XEdge/YEdge;
            XBounds[1] = width;
        }
        else
        {
            XBounds[0] = width;
        }

        break;

   default:
        _ASSERT(0);

        break;
    }
}
//  CDXTRadialWipeBase::_ScanlineIntervals


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_ClipBounds
//
//  Description:
//  Initially the X-bounds are specified relative to the entire image. After clipping,
//  the bounds should be transformed to be relative to the clipping region.
//
//  Parameters;
//  offset, width: offset and width of the clipping region (along X)
//  XBounds: array of X-bounds
//
//  Created by: PhilLu    07/21/98
//
//------------------------------------------------------------------------------
void 
CDXTRadialWipeBase::_ClipBounds(long offset, long width, long *XBounds)
{
    int i;

    for(i=0; XBounds[i] < offset+width; i++)
    {
        if (XBounds[i] < offset)
            XBounds[i] = 0;
        else
            XBounds[i] -= offset;
    }

    XBounds[i] = width;
}
//  CDXTRadialWipeBase::_ClipBounds


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcFullBoundsClock
//
//------------------------------------------------------------------------------
HRESULT
CDXTRadialWipeBase::_CalcFullBoundsClock()
{
    POINT   ptCenter;
    RECT    rcRay;
    RECT    rcBar;
    RECT    rc;

    ptCenter.x = m_sizeInput.cx / 2;
    ptCenter.y = m_sizeInput.cy / 2;

    // Rect enclosing the vertical bar between quadrants 1 and 4.

    rcBar.left      = max(ptCenter.x - 2, 0);
    rcBar.top       = 0;
    rcBar.right     = min(ptCenter.x + 2, m_sizeInput.cx);
    rcBar.bottom    = max(ptCenter.y - 2, 0);

    switch (m_iCurQuadrant)
    {
    case 1:
 
        // Rect enclosing current quadrant (1).

        rcRay.left      = max(ptCenter.x - 2, 0);
        rcRay.top       = 0;
        rcRay.right     = m_sizeInput.cx;
        rcRay.bottom    = min(ptCenter.y + 2, m_sizeInput.cy);

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcRay);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect enclosing quadrants 2 and 3.

        rc.left     = 0;
        rc.top      = rcRay.bottom;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        // Rect enclosing quadrant 4.

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = rcRay.left;
        rc.bottom   = rcRay.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        break;

    case 2:

        // Use rcBar.

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcBar);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect enclosing current quadrant (2).

        rcRay.left      = rcBar.left;
        rcRay.top       = rcBar.bottom;
        rcRay.right     = m_sizeInput.cx;
        rcRay.bottom    = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcRay);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect enclosing quadrant 1.

        rc.left     = rcBar.right;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = rcBar.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;

        // Rect enclosing quadrants 3 and 4.

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = rcBar.left;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        break;

    case 3:

        // Use rcBar.

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcBar);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect enclosing current quadrant (3).

        rcRay.left      = 0;
        rcRay.top       = rcBar.bottom;
        rcRay.right     = rcBar.right;
        rcRay.bottom    = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcRay);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect encloseing quadrants 1 and 2.

        rc.left     = rcBar.right;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;

        // Rect enclosing quadrant 4.

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = rcBar.left;
        rc.bottom   = rcBar.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        break;

    case 4:

        // Rect enclosing current quadrant (4).

        rcRay.left      = 0;
        rcRay.top       = 0;
        rcRay.right     = min(ptCenter.x + 2, m_sizeInput.cx);
        rcRay.bottom    = max(ptCenter.y + 2, 0);

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcRay);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect enclosing quadrant 1.

        rc.left     = rcRay.right;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = rcRay.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;

        // Rect enclosing quadrants 2 and 3.

        rc.left     = 0;
        rc.top      = rcRay.bottom;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;

        break;

    default:

        _ASSERT(0);
    }

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcFullBoundsClock


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcFullBoundsWedge
//
//------------------------------------------------------------------------------
HRESULT
CDXTRadialWipeBase::_CalcFullBoundsWedge()
{
    POINT   ptCenter;
    RECT    rcRay;
    RECT    rc;

    ptCenter.x = m_sizeInput.cx / 2;
    ptCenter.y = m_sizeInput.cy / 2;

    // Calculate rect enclosing all both rays.

    rcRay.right     = m_ptCurEdge.x + 1;
    rcRay.left      = m_sizeInput.cx - rcRay.right;

    rcRay.top       = max(min(m_ptCurEdge.y, ptCenter.y - 1), 0);
    rcRay.bottom    = max(m_ptCurEdge.y, ptCenter.y) + 1;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rcRay);
    m_alInputIndex[m_cbndsDirty] = DRAWRECT;
    m_cbndsDirty++;

    // Do we need to fill above the top of rcRay?

    if (rcRay.top > 0)
    {
        rc.left     = 0;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = rcRay.top;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;
    }

    // Do we need to fill below the bottom of rcRay?

    if (rcRay.bottom < m_sizeInput.cy)
    {
        rc.left     = 0;
        rc.top      = rcRay.bottom;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;
    }

    // Do we need to fill to the right of rcRay?

    if (rcRay.right < m_sizeInput.cx)
    {
        rc.left     = rcRay.right;
        rc.top      = rcRay.top;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = rcRay.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = (m_Progress > 0.5F) ? 1 : 0;
        m_cbndsDirty++;
    }

    // Do we need to fill to the left of rcRay?

    if (rcRay.left > 0)
    {
        rc.left     = 0;
        rc.top      = rcRay.top;
        rc.right    = rcRay.left;
        rc.bottom   = rcRay.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = (m_Progress > 0.5F) ? 1 : 0;
        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcFullBoundsWedge


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcFullBoundsRadial
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::_CalcFullBoundsRadial()
{
    SIZE    szMax;
    RECT    rcRemaining;

    szMax.cx    = m_sizeInput.cx - 1;
    szMax.cy    = m_sizeInput.cy - 1;

    rcRemaining.left    = 0;
    rcRemaining.right   = m_sizeInput.cx;
    rcRemaining.top     = 0;
    rcRemaining.bottom  = m_sizeInput.cy;

    m_cbndsDirty = 0;

    if (!((m_ptCurEdge.x == szMax.cx) && (m_ptCurEdge.y == szMax.cy)))
    {
        RECT rc;

        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        if (m_ptCurEdge.x == szMax.cx)
        {
            // Fill rect on bottom part of output with input A.

            rc.left = 0;
            rc.top  = m_ptCurEdge.y + 1;

            m_alInputIndex[m_cbndsDirty] = 0;

            rcRemaining.bottom = m_ptCurEdge.y + 1;
        }
        else
        {
            // Fill rect on right part of output with input B.

            rc.left = m_ptCurEdge.x + 1;
            rc.top  = 0;

            m_alInputIndex[m_cbndsDirty] = 1;

            rcRemaining.right = m_ptCurEdge.x + 1;
        }

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_cbndsDirty++;
    }

    m_abndsDirty[m_cbndsDirty].SetXYRect(rcRemaining);
    m_alInputIndex[m_cbndsDirty] = DRAWRECT;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcFullBoundsRadial


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcOptBoundsClock
//
//------------------------------------------------------------------------------
HRESULT
CDXTRadialWipeBase::_CalcOptBoundsClock()
{
    POINT   ptCenter;
    RECT    rcCenter;   // Center DRAWRECT bounds.
    RECT    rcCur;      // Current ray's bounds if needed outside center bnds.
    RECT    rcPrev;     // Previous ray's bounds if needed outside center bnds.
    POINT   ptCRI;      // Current ray intercept with center bounds.
    POINT   ptPRI;      // Previous ray intercept with center bounds.

    bool    fCurUsed    = false;    // rcCur used?
    bool    fPrevUsed   = false;    // rcPrev used?

    long    lInput      = 0;

    int     iMaxQuadrant = max(m_iCurQuadrant, m_iPrevQuadrant);
    int     iMinQuadrant = min(m_iCurQuadrant, m_iPrevQuadrant);

    RECT *  prcMin = NULL;
    RECT *  prcMax = NULL;

    ptCenter.x = m_sizeInput.cx / 2;
    ptCenter.y = m_sizeInput.cy / 2;

    if (m_sizeInput.cx < 25)
    {
        rcCenter.left   = 0;
        rcCenter.right  = m_sizeInput.cx;
    }
    else
    {
        rcCenter.left   = ptCenter.x - 10;
        rcCenter.right  = ptCenter.x + 10;
    }

    if (m_sizeInput.cy < 25)
    {
        rcCenter.top    = 0;
        rcCenter.bottom = m_sizeInput.cy;
    }
    else
    {
        rcCenter.top    = ptCenter.y - 10;
        rcCenter.bottom = ptCenter.y + 10;
    }

    // Find new ray intercept.

    if (m_ptCurEdge.y >= rcCenter.top && m_ptCurEdge.y < rcCenter.bottom)
    {
        ptCRI.x = m_ptCurEdge.x;
        ptCRI.y = m_ptCurEdge.y;
    }
    else
    {
        double dly  = 0.0;
        double dlx  = 0.0;
        double dlim = 0.0;  // inverse slope of ray.

        // We'll be using rcCur.

        fCurUsed = true;

        if (1 == m_iCurQuadrant || 4 == m_iCurQuadrant)
        {
            dly             = 10.0;
            ptCRI.y         = rcCenter.top;
            rcCur.top       = max(m_ptCurEdge.y - 2, 0);
            rcCur.bottom    = rcCenter.top;
        }
        else
        {
            dly             = -10.0;
            ptCRI.y         = rcCenter.bottom;
            rcCur.top       = rcCenter.bottom;
            rcCur.bottom    = min(m_ptCurEdge.y + 2, m_sizeInput.cy);
        }

        dlim = (double)(m_ptCurEdge.x - ptCenter.x) 
               / (double)(ptCenter.y - m_ptCurEdge.y);
        
        dlx = dly * dlim;

        ptCRI.x = (long)dlx + ptCenter.x;

        // Calculate horizontal bounds of rcCur;

        rcCur.left  = max(min(m_ptCurEdge.x - 2, ptCRI.x - 2), 0);
        rcCur.right = min(max(m_ptCurEdge.x + 2, ptCRI.x + 2), m_sizeInput.cx);
    }

    // Expand center bounds horizontally to include the new ray intercept.

    if (rcCenter.right <= ptCRI.x)
    {
        rcCenter.right = ptCRI.x + 1;
    }
    else if (rcCenter.left > ptCRI.x)
    {
        rcCenter.left = ptCRI.x;
    }

    // Find old ray intercept.

    if (m_ptPrevEdge.y >= rcCenter.top && m_ptPrevEdge.y < rcCenter.bottom)
    {
        ptPRI.x = m_ptPrevEdge.x;
        ptPRI.y = m_ptPrevEdge.y;
    }
    else
    {
        double dly  = 0.0;
        double dlx  = 0.0;
        double dlim = 0.0;  // inverse slope of ray.

        // We'll be using rcPrev.

        fPrevUsed = true;

        if (1 == m_iPrevQuadrant || 4 == m_iPrevQuadrant)
        {
            dly             = 10.0;
            ptPRI.y         = rcCenter.top;
            rcPrev.top      = max(m_ptPrevEdge.y - 2, 0);
            rcPrev.bottom   = rcCenter.top;
        }
        else
        {
            dly             = -10.0;
            ptPRI.y         = rcCenter.bottom;
            rcPrev.top      = rcCenter.bottom;
            rcPrev.bottom   = min(m_ptPrevEdge.y + 2, m_sizeInput.cy);
        }

        dlim = (double)(m_ptPrevEdge.x - ptCenter.x) 
               / (double)(ptCenter.y - m_ptPrevEdge.y);
        
        dlx = dly * dlim;

        ptPRI.x = (long)dlx + ptCenter.x;

        rcPrev.left  = max(min(m_ptPrevEdge.x - 2, ptPRI.x - 2), 0);
        rcPrev.right = min(max(m_ptPrevEdge.x + 2, ptPRI.x + 2), m_sizeInput.cx);
    }

    // Expand center bounds horizontally to include the previous ray intercept.

    if (rcCenter.right <= ptPRI.x)
    {
        rcCenter.right = ptPRI.x + 1;
    }
    else if (rcCenter.left > ptPRI.x)
    {
        rcCenter.left = ptPRI.x;
    }

    if (m_iCurQuadrant == m_iPrevQuadrant)
    {
        RECT *  prc = NULL;
        RECT    rc;

        // If both RECTs are used, union bounds manually and unset used flags.

        if (fCurUsed && fPrevUsed)
        {
            rc.top      = min(rcCur.top,    rcPrev.top);
            rc.bottom   = max(rcCur.bottom, rcPrev.bottom);
            rc.left     = min(rcCur.left,   rcPrev.left);
            rc.right    = max(rcCur.right,  rcPrev.right);

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = DRAWRECT;
            m_cbndsDirty++;

            fCurUsed    = false;
            fPrevUsed   = false;

            goto done;
        }

        // If neither RECT is used, both rays are entirely in the center
        // band and all needed areas will be covered.

        if (!fCurUsed && !fPrevUsed)
        {
            goto done;
        }

        // In the case of only one RECT being used and the other being in
        // the center, it is possible for some areas to be missed.

        if (fCurUsed)
        {
            prc = &rcCur;
        }
        else
        {
            _ASSERT(fPrevUsed);
            prc = &rcPrev;
        }

        // Grow the right or left edge of the rectangle to the edge of
        // the work area to make sure we got all the pixels.

        switch (m_iCurQuadrant)
        {
        case 1:

            if (prc->right == m_sizeInput.cx)
            {
                goto done;
            }

            if (fPrevUsed)
            {
                lInput = 1;
            }

            rc.top      = prc->top;
            rc.bottom   = prc->bottom;
            rc.left     = prc->right;
            rc.right    = m_sizeInput.cx;
            
            break;

        case 2:

            if (prc->right == m_sizeInput.cx)
            {
                goto done;
            }

            if (fCurUsed)
            {
                lInput = 1;
            }

            rc.top      = prc->top;
            rc.bottom   = prc->bottom;
            rc.left     = prc->right;
            rc.right    = m_sizeInput.cx;
        
            break;

        case 3:

            if (prc->left == 0)
            {
                goto done;
            }

            if (fPrevUsed)
            {
                lInput = 1;
            }

            rc.top      = prc->top;
            rc.bottom   = prc->bottom;
            rc.left     = 0;
            rc.right    = prc->left;

            break;

        case 4:

            if (prc->left == 0)
            {
                goto done;
            }

            if (fCurUsed)
            {
                lInput = 1;
            }

            rc.top      = prc->top;
            rc.bottom   = prc->bottom;
            rc.left     = 0;
            rc.right    = prc->left;

            break;

        default:

            _ASSERT(0);
        }

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = lInput;
        m_cbndsDirty++;

        goto done;
    }

    // If current quadrant is greater than the previous quadrant, fill with
    // input B instead of A.

    if (m_iCurQuadrant > m_iPrevQuadrant)
    {
        lInput = 1;
        
        if (fCurUsed)
        {
            prcMax = &rcCur;
        }

        if (fPrevUsed)
        {
            prcMin = &rcPrev;
        }
    }
    else
    {
        // lInput = 0; (by default, commented on purpose)

        if (fCurUsed)
        {
            prcMin = &rcCur;
        }

        if (fPrevUsed)
        {
            prcMax = &rcPrev;
        }
    }

    // If we're moving from or to quadrant 1, make sure center bounds
    // go all the way to the right edge.

    if (1 == m_iCurQuadrant || 1 == m_iPrevQuadrant)
    {
        rcCenter.right = m_sizeInput.cx;
    }

    // If we're moving from or to quadrant 4, make sure center bounds
    // go all the way to the left edge.

    if (4 == m_iCurQuadrant || 4 == m_iPrevQuadrant)
    {
        rcCenter.left = 0;
    }

    // If the minium quadrant is quadrant 1, make sure the quadrant is filled
    // all the way to the right side of the output.

    if (1 == iMinQuadrant && prcMin)
    {
        RECT rc;

        if (prcMin->right < m_sizeInput.cx)
        {
            rc.top      = 0;
            rc.bottom   = rcCenter.top;
            rc.left     = prcMin->right;
            rc.right    = m_sizeInput.cx;
        
            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInput;
            m_cbndsDirty++;
        }
    }

    // If the maximum quadrant is quadrant 2, make sure the quadrant is filled
    // all the way to the right side of the output.

    if (2 == iMaxQuadrant && prcMax)
    {
        RECT rc;

        if (prcMax->right < m_sizeInput.cx)
        {
            rc.top      = rcCenter.bottom;
            rc.bottom   = m_sizeInput.cy;
            rc.left     = prcMax->right;
            rc.right    = m_sizeInput.cx;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInput;
            m_cbndsDirty++;
        }
    }

    if (3 == iMinQuadrant && prcMin)
    {
        RECT rc;

        if (prcMin->left > 0)
        {
            rc.top      = rcCenter.bottom;
            rc.bottom   = m_sizeInput.cy;
            rc.left     = 0;
            rc.right    = prcMin->left;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInput;
            m_cbndsDirty++;
        }
    }

    if (4 == iMaxQuadrant && prcMax)
    {
        RECT rc;

        if (prcMax->left > 0)
        {
            rc.top      = 0;
            rc.bottom   = rcCenter.top;
            rc.left     = 0;
            rc.right    = prcMax->left;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInput;
            m_cbndsDirty++;
        }
    }

    if (iMaxQuadrant >= 3 && iMinQuadrant < 3)
    {
        if ((1 == iMinQuadrant) || !prcMin)
        {
            RECT rcBottom;  // Represets a rectangle that runs the full width of
                            // the output and touches the bottom of the output.

            if (prcMax && (3 == iMaxQuadrant))
            {
                RECT rcRight;   // Represents a rectangle to the right of the
                                // rectangle used to enclose the ray in
                                // quadrant 3.

                rcRight.top     = prcMax->top;
                rcRight.bottom  = prcMax->bottom;
                rcRight.left    = prcMax->right;
                rcRight.right   = m_sizeInput.cx;

                m_abndsDirty[m_cbndsDirty].SetXYRect(rcRight);
                m_alInputIndex[m_cbndsDirty] = lInput;
                m_cbndsDirty++;

                rcBottom.top    = prcMax->bottom;
            }
            else // if (!prcMax || (3 != iMaxQuadrant))
            {
                rcBottom.top    = rcCenter.bottom;
            }

            rcBottom.bottom = m_sizeInput.cy;
            rcBottom.left   = 0;
            rcBottom.right  = m_sizeInput.cx;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rcBottom);
            m_alInputIndex[m_cbndsDirty] = lInput;
            m_cbndsDirty++;
        }
        else // if ((1 != iMinQuadrant) && prcMin))
        {
            RECT rcBottom;

            if (prcMax && (3 == iMaxQuadrant))
            {
                RECT rcCombo;

                // Combine both ray rectangles.

                rcCombo.top     = rcCenter.bottom;
                rcCombo.bottom  = max(prcMax->bottom, prcMin->bottom);
                rcCombo.left    = prcMax->left;
                rcCombo.right   = prcMin->right;

                m_abndsDirty[m_cbndsDirty].SetXYRect(rcCombo);
                m_alInputIndex[m_cbndsDirty] = DRAWRECT;
                m_cbndsDirty++;
                
                fCurUsed    = false;
                fPrevUsed   = false;

                if (rcCombo.bottom < m_sizeInput.cy)
                {
                    // Combo rectangle doesn't go all the way to the 
                    // bottom.

                    rcBottom.top    = rcCombo.bottom;
                    rcBottom.bottom = m_sizeInput.cy;
                    rcBottom.left   = rcCombo.left;
                    rcBottom.right  = rcCombo.right;

                    m_abndsDirty[m_cbndsDirty].SetXYRect(rcBottom);
                    m_alInputIndex[m_cbndsDirty] = lInput;
                    m_cbndsDirty++;
                }
            }
            else // if (!prcMax || (3 != iMaxQuadrant))
            {
                RECT rcLeft;

                rcLeft.left     = 0;
                rcLeft.right    = prcMin->left;
                rcLeft.top      = rcCenter.bottom;
                rcLeft.bottom   = prcMin->bottom;

                m_abndsDirty[m_cbndsDirty].SetXYRect(rcLeft);
                m_alInputIndex[m_cbndsDirty] = lInput;
                m_cbndsDirty++;

                if (rcLeft.bottom < m_sizeInput.cy)
                {
                    rcBottom.top    = rcLeft.bottom;
                    rcBottom.bottom = m_sizeInput.cy;
                    rcBottom.left   = 0;
                    rcBottom.right  = m_sizeInput.cx;

                    m_abndsDirty[m_cbndsDirty].SetXYRect(rcBottom);
                    m_alInputIndex[m_cbndsDirty] = lInput;
                    m_cbndsDirty++;
                }
            } // if (!prcMax || (3 != iMaxQuadrant))

        } // if ((1 != iMinQuadrant) && prcMin))

    } // if (3 == iMaxQuadrant)

done:

    m_abndsDirty[m_cbndsDirty].SetXYRect(rcCenter);
    m_alInputIndex[m_cbndsDirty] = DRAWRECT;
    m_cbndsDirty++;

    if (fCurUsed)
    {
        m_abndsDirty[m_cbndsDirty].SetXYRect(rcCur);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;
    }

    if (fPrevUsed)
    {
        m_abndsDirty[m_cbndsDirty].SetXYRect(rcPrev);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;
    }

    if (fCurUsed && fPrevUsed &&
        m_abndsDirty[m_cbndsDirty - 2].TestIntersect(m_abndsDirty[m_cbndsDirty -1]))
    {
        m_abndsDirty[m_cbndsDirty - 2].UnionBounds(
            m_abndsDirty[m_cbndsDirty - 2], m_abndsDirty[m_cbndsDirty - 1]);

        m_cbndsDirty--;
    }

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcOptBoundsClock


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcOptBoundsWedge
//
//------------------------------------------------------------------------------
HRESULT
CDXTRadialWipeBase::_CalcOptBoundsWedge()
{
    POINT   ptCenter;
    RECT    rcRemaining;

    ptCenter.x = m_sizeInput.cx / 2;
    ptCenter.y = m_sizeInput.cy / 2;

    rcRemaining.left    = 0;
    rcRemaining.right   = m_sizeInput.cx;
    rcRemaining.top     = 0;
    rcRemaining.bottom  = m_sizeInput.cy;

    // Can bounds be clipped on the sides?

    if ((m_ptCurEdge.x < (m_sizeInput.cx - 1)) 
        && (m_ptPrevEdge.x < (m_sizeInput.cx - 1)))
    {
        rcRemaining.right   = max(m_ptCurEdge.x, m_ptPrevEdge.x) + 1;
        rcRemaining.left    = m_sizeInput.cx - rcRemaining.right;

        // If the y edge is the same we can further clip off the top or the 
        // bottom half.  Otherwise we'll need to fill the sides with either
        // input A or input B.

        if (m_ptCurEdge.y == m_ptPrevEdge.y)
        {
            rcRemaining.top     = min(m_ptCurEdge.y, (ptCenter.y - 1));
            rcRemaining.bottom  = max(ptCenter.y, m_ptCurEdge.y) + 1;
        }
        else
        {
            RECT    rc;
            long    lInputIndex = (m_ptCurEdge.y > m_ptPrevEdge.y) ? 1 : 0;

            // Left side.

            rc.left     = 0;
            rc.top      = 0;
            rc.right    = rcRemaining.left;
            rc.bottom   = m_sizeInput.cy;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInputIndex;
            m_cbndsDirty++;

            // Right side.

            rc.left     = rcRemaining.right;
            rc.right    = m_sizeInput.cx;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInputIndex;
            m_cbndsDirty++;
        }
    }

    // Can bounds be clipped on the top and bottom?

    if ((m_ptCurEdge.x == (m_sizeInput.cx - 1)) && (m_ptPrevEdge.x == (m_sizeInput.cx - 1)))
    {
        rcRemaining.top     = min(min(m_ptCurEdge.y, m_ptPrevEdge.y), ptCenter.y) - 1;
        rcRemaining.top     = max(rcRemaining.top, 0);
        rcRemaining.bottom  = max(max(m_ptCurEdge.y, m_ptPrevEdge.y), ptCenter.y) + 1;
    }

    m_abndsDirty[m_cbndsDirty].SetXYRect(rcRemaining);
    m_alInputIndex[m_cbndsDirty] = DRAWRECT;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcOptBoundsWedge


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcOptBoundsRadial
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::_CalcOptBoundsRadial()
{
    // ppt1, ptt2   ppt2 points to the intersection POINT that is "further along
    //              in progress."  If progress has risen since the last execute
    //              then ppt2 will point to the current intersection POINT.  If
    //              progress has decreased since the last execute ppt2 will
    //              point to the previous intersection POINT.
    //              ppt1 points to the other point.  

    POINT * ppt1;       // The point closest to the point at m_Progress = 0.0.
    POINT * ppt2;       // The point closest to the point at m_Progress = 1.0.

    RECT    rcRemaining;    // Bounding rectangle of dirty areas.
    RECT    rc;             // Temporary bounds rectangle.

    float   flInvSlope1 = 0.0F;
    float   flInvSlope2 = 0.0F;
    float   flRowHeight = 0.0F;
    ULONG   i           = 0;

    // Initialize rcRemaining to the entire surface size.  This will be reduced
    // as optimizations can be made.

    rcRemaining.left    = 0;
    rcRemaining.right   = m_sizeInput.cx;
    rcRemaining.top     = 0;
    rcRemaining.bottom  = m_sizeInput.cy;

    // Reduce the size of the bounding rectangle of all dirty areas 
    // (rcRemaining) by eliminating rectangles that don't contain any areas
    // that aren't dirty.  This reduction will leave rcRemaining as a rectangle
    // that just contains both the current and the previous rays.

    if (!((m_ptCurEdge.x == (m_sizeInput.cx - 1)) && (m_ptCurEdge.y == (m_sizeInput.cy - 1))))
    {
        if (m_ptCurEdge.x == (m_sizeInput.cx - 1))
        {
            // There may be an area on the bottom of rcRemaining that isn't
            // dirty.  If so, reduce the size of rcRemaining.

            rcRemaining.bottom = max(m_ptCurEdge.y, m_ptPrevEdge.y) + 1;
        }
        else
        {
            // There may be an area on the right side of rcRemaining that isn't
            // dirty.  If so, reduce the size of rcRemaining.

            rcRemaining.right = max(m_ptCurEdge.x, m_ptPrevEdge.x) + 1;
        }
    }

    // Determine which ray intersection point is "further along in progress" and
    // set ppt1 and ppt2 accordingly.

    if ((m_ptCurEdge.x < m_ptPrevEdge.x) || (m_ptCurEdge.y > m_ptPrevEdge.y))
    {
        // Progress has increased since the last execute.

        ppt1 = &m_ptPrevEdge;
        ppt2 = &m_ptCurEdge;
    }
    else
    {
        // Progress has decreased since the last execute.

        ppt1 = &m_ptCurEdge;
        ppt2 = &m_ptPrevEdge;
    }

    // Calculate the number of dirty bounds we would desire based on the 
    // size of rcRemaining.  

    m_cbndsDirty = min(rcRemaining.bottom / MIN_PIXELS_PER_ROW, 
                         rcRemaining.right / MIN_PIXELS_PER_ROW) + 1;

    // If rcRemaining is particularly large, reduce the number of dirty bounds
    // we will create.  (While creating a certain number of smaller dirty bounds
    // structures will improve performance, too many structures will actually
    // decrease performance.)

    if (m_cbndsDirty > MAX_DIRTY_BOUNDS)
    {
        m_cbndsDirty = MAX_DIRTY_BOUNDS;
    }

    // Calculate 1 / (slope of the line from {0, 0} to ppt1)

    if (ppt1->y != 0)
    {
        flInvSlope1 = (float)ppt1->x / (float)ppt1->y;
    }

    // Calculate 1 / (slope of the line from {0, 0} to ppt2)

    if (ppt2->y != 0)
    {
        flInvSlope2 = (float)ppt2->x / (float)ppt2->y;
    }

    // Calculate the desired height of each bounds structure.  (Calculated as
    // a float so rounding won't cause problems.)

    if (m_cbndsDirty > 1)
    {
        flRowHeight = (float)(ppt2->y + 1) / (float)m_cbndsDirty;
    }

    // Calculate the bounds structures.

    for (i = 0; i < m_cbndsDirty; i++)
    {
        // Calculate the top-left corner of this set of dirty bounds.

        if (0 == i)
        {
            rc.top  = 0;
            rc.left = 0;
        }
        else
        {
            rc.top  = rc.bottom;
            rc.left = (long)(((float)rc.top * flInvSlope2) - 1.0F);
            rc.left = max(rc.left, 0);
        }

        // Calculate the bottom-right corner of this set of dirty bounds.

        if ((m_cbndsDirty - 1) == i)
        {
            rc.bottom = rcRemaining.bottom;
            rc.right  = rcRemaining.right;
        }
        else
        {
            rc.bottom = (long)((float)(i + 1) * flRowHeight);

            if (0.0F == flInvSlope1)
            {
                rc.right = rcRemaining.right;
            }
            else
            {
                rc.right  = (long)(((float)rc.bottom * flInvSlope1) + 1.0F);
                rc.right  = min(rc.right, rcRemaining.right);
            }
        }

        // Set the next set of bounds in the m_abndsDirty array to our
        // calculated bounds and specify that this set of bounds should be
        // drawn using the _DrawRect() method instead of being filled 
        // with an input.

        m_abndsDirty[i].SetXYRect(rc);
        m_alInputIndex[i] = DRAWRECT;
    }

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcOptBoundsRadial


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, 
                                   ULONG & ulNumBandsToDo)
{
    HRESULT hr      = S_OK;
    double  dlAngle = 0.0;

    // Reset number of dirty bounds to zero.

    m_cbndsDirty = 0;

    // Calculate current edge point.

    switch (m_eWipeStyle)
    {
        case CRRWS_CLOCK:

            // Calculate quadrant of current execute.

            if (1.0F == m_Progress)
            {
                m_iCurQuadrant = 4;
            }
            else
            {
                m_iCurQuadrant = (int)(m_Progress / 0.25F) + 1;
            }

            dlAngle = (2.0 * m_Progress - 0.5) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 
                           m_sizeInput.cx/2, m_sizeInput.cy/2,
                           cos(dlAngle), sin(dlAngle),
                           m_ptCurEdge.x, m_ptCurEdge.y);

            break;

        case CRRWS_WEDGE:
            dlAngle = (1.0 * m_Progress - 0.5) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 
                           m_sizeInput.cx/2, m_sizeInput.cy/2,
                           cos(dlAngle), sin(dlAngle),
                           m_ptCurEdge.x, m_ptCurEdge.y);

            break;

        case CRRWS_RADIAL:
            dlAngle = (0.5 * m_Progress) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 
                           0, 0, 
                           cos(dlAngle), sin(dlAngle), 
                           m_ptCurEdge.x, m_ptCurEdge.y);

            break;

        default:
            _ASSERT(0);
            break;
    } 

    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        switch (m_eWipeStyle)
        {
            case CRRWS_CLOCK:
                hr = _CalcFullBoundsClock();

                break;

            case CRRWS_WEDGE:
                hr = _CalcFullBoundsWedge();

                break;

            case CRRWS_RADIAL:
                hr = _CalcFullBoundsRadial();

                break;
        } 
    }
    else
    {
        if ((m_ptCurEdge.x == m_ptPrevEdge.x) && (m_ptCurEdge.y == m_ptPrevEdge.y))
        {
            if (CRRWS_CLOCK == m_eWipeStyle)
            {
                // Clock can have duplicate edge points at different progress
                // levels so we also have to check to make sure the quadrants
                // are the same.

                if (m_iCurQuadrant == m_iPrevQuadrant)
                {
                    // Nothing needs to be updated.
                    goto done;
                }
            }
            else
            {
                // Nothing needs to be updated.
                goto done;
            }
        }

        switch (m_eWipeStyle)
        {
            case CRRWS_CLOCK:
                hr = _CalcOptBoundsClock();
                break;

            case CRRWS_WEDGE:
                hr = _CalcOptBoundsWedge();
                break;

            case CRRWS_RADIAL:
                hr = _CalcOptBoundsRadial();

                break;
        } 
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }
    
done:

    if (FAILED(hr))
    {
        return hr;
    }
    
    return S_OK;
}
//  CDXTRadialWipeBase::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::WorkProc, CDXBaseNTo1
//
//  Description:
//      This function is used to calculate the transformed image based on the 
//  specified bounds and the current effect progress.
//
//  Created by: PhilLu    06/22/98
//  
//  05/09/99    a-matcal    Created new WorkProc.  Old WorkProc modified to
//                          become new _DrawRect method.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;
    ULONG   i       = 0;

    long    lInOutOffsetX = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }


    for (i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            if (m_alInputIndex[i] == DRAWRECT)
            {
                hr = _DrawRect(bndsDest, bndsSrc, pbContinue);
            }
            else
            {
                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(m_alInputIndex[i]), bndsSrc,
                              dwFlags, INFINITE);
            }

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTRadialWipeBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_DrawRect
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::_DrawRect(const CDXDBnds & bndsDest, 
                              const CDXDBnds & bndsSrc, BOOL * pfContinue)
{
    HRESULT hr = S_OK;

    SIZE            szSrc;
    DXDITHERDESC    dxdd;
    DXPMSAMPLE *    pRowBuff = NULL;
    DXPMSAMPLE *    pOutBuff = NULL;

    CComPtr<IDXARGBReadPtr>         pInA;
    CComPtr<IDXARGBReadPtr>         pInB;
    CComPtr<IDXARGBReadWritePtr>    pOut;

    long    lOutY   = 0;

    double  dAngle  = 0.0F;
    long    XEdge   = 0;        // intersection of ray with image boundary
    long    YEdge   = 0;          
    long    XBounds[MAXBOUNDS]; // to hold the X bounds of A/B image sections on 
                                // a scanline

    bndsSrc.GetXYSize(szSrc);

    // Get read access to needed area of input A.

    hr = InputSurface(0)->LockSurface(&bndsSrc, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void**)&pInA, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get read access to needed area of input B.

    hr = InputSurface(1)->LockSurface(&bndsSrc, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void**)&pInB, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get write access to needed area of output.

    hr = OutputSurface()->LockSurface(&bndsDest, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, (void**)&pOut, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    pRowBuff = DXPMSAMPLE_Alloca(szSrc.cx);

    // Allocate output buffer if needed

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(szSrc.cx);
    }

    //  Set up the dither structure

    if (DoDither())
    {
        dxdd.x              = bndsDest.Left();
        dxdd.y              = bndsDest.Top();
        dxdd.pSamples       = pRowBuff;
        dxdd.cSamples       = szSrc.cx;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // Row loop.

    for (lOutY = 0; *pfContinue && (lOutY < szSrc.cy); lOutY++)
    {
        long lScanLength = 0;  // cumulative scan length on the current scanline
        long i           = 0;

        // Compute the A/B image section bounds

        _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, 
                           m_ptCurEdge.x, m_ptCurEdge.y, 
                           m_Progress, lOutY + bndsSrc.Top(), XBounds);

        _ClipBounds(bndsSrc.Left(), szSrc.cx, XBounds);

        while (lScanLength < szSrc.cx)
        {
            // copy a section of A image to output buffer

            if(XBounds[i] - lScanLength > 0)
            {
                pInA->MoveToXY(lScanLength, lOutY);
                pInA->UnpackPremult(pRowBuff + lScanLength, 
                                    XBounds[i] - lScanLength, FALSE);
            }

            lScanLength = XBounds[i++];

            if (lScanLength >= szSrc.cx)
            {
                break;
            }

            // copy a section of B image to output buffer

            if (XBounds[i] - lScanLength > 0)
            {
                pInB->MoveToXY(lScanLength, lOutY);
                pInB->UnpackPremult(pRowBuff + lScanLength, 
                                    XBounds[i] - lScanLength, FALSE);
            }

            lScanLength = XBounds[i++];
        }


        // Get the output row

        pOut->MoveToRow(lOutY);

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            pOut->OverArrayAndMove(pOutBuff, pRowBuff, szSrc.cx);
        }
        else
        {
            pOut->PackPremultAndMove(pRowBuff, szSrc.cx);
        }
    } // Row loop.

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTRadialWipeBase::_DrawRect


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_iPrevQuadrant = m_iCurQuadrant;
    m_ptPrevEdge    = m_ptCurEdge;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTRadialWipeBase::OnFreeInstData, CDXBaseNTo1


//
// ICrRadialWipe methods
//


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::get_wipeStyle, ICrRadialWipe
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTRadialWipeBase::get_wipeStyle(BSTR * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    switch (m_eWipeStyle)
    {
    case CRRWS_CLOCK:
        *pVal = SysAllocString (L"CLOCK");
        break;

    case CRRWS_WEDGE:
        *pVal = SysAllocString (L"WEDGE");
        break;

    case CRRWS_RADIAL:
        *pVal = SysAllocString (L"RADIAL");
        break;

    default:
        _ASSERT(0);
        break;
    }

    if (NULL == *pVal)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTRadialWipeBase::get_wipeStyle, ICrRadialWipe


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::put_wipeStyle, ICrRadialWipe
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTRadialWipeBase::put_wipeStyle(BSTR newVal)
{
    CRRWIPESTYLE eNewStyle = m_eWipeStyle;

    if (!newVal)
    {
        return E_POINTER;
    }

    if(!_wcsicmp(newVal, L"CLOCK"))
    {
        eNewStyle = CRRWS_CLOCK;
    }
    else if(!_wcsicmp(newVal, L"WEDGE"))
    {
        eNewStyle = CRRWS_WEDGE;
    }
    else if(!_wcsicmp(newVal, L"RADIAL"))
    {
        eNewStyle = CRRWS_RADIAL;
    }
    else
    {
        return E_INVALIDARG;
    }

    if (eNewStyle != m_eWipeStyle)
    {
        Lock();
        m_eWipeStyle = eNewStyle;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CDXTRadialWipeBase::put_wipeStyle, ICrRadialWipe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\rwipe.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:            rwipe.h
//
// Created:             06/24/98
//
// Author:              phillu
//
// Discription:         This is the header file for the CrRadialWipe transformation
//
// Change History:
// 06/24/98 PhilLu      Developed 1.0 version for Chromeffects
// 11/04/98 PaulNash    Moved from DT 1.0 codebase to IE5/NT5 DXTMSFT.DLL
// 05/09/99 a-matcal    Optimizations.
// 10/22/99 a-matcal    Changed CRadialWipe class to CDXTRadialWipeBase and
//                      created two new classes CDXTRadialWipe and 
//                      CDXTRadialWipeOpt to represent non-optimized and 
//                      optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRRADIALWIPE_H_
#define __CRRADIALWIPE_H_

#include "resource.h"       // main symbols

#define MAX_DIRTY_BOUNDS 100

typedef enum CRRWIPESTYLE
{
    CRRWS_CLOCK,
    CRRWS_WEDGE,
    CRRWS_RADIAL
} CRRWIPESTYLE;




class ATL_NO_VTABLE CDXTRadialWipeBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrRadialWipe, &IID_ICrRadialWipe, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTRadialWipeBase>,
    public IObjectSafetyImpl2<CDXTRadialWipeBase>,
    public ISpecifyPropertyPagesImpl<CDXTRadialWipeBase>
{
private:

    SIZE            m_sizeInput;
    CRRWIPESTYLE    m_eWipeStyle;
    CDXDBnds        m_abndsDirty[MAX_DIRTY_BOUNDS];
    long            m_alInputIndex[MAX_DIRTY_BOUNDS];
    ULONG           m_cbndsDirty;
    POINT           m_ptCurEdge;
    POINT           m_ptPrevEdge;
    int             m_iCurQuadrant;
    int             m_iPrevQuadrant;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

private:

    // The _CalcBounds... functions calculate sets of optimized bounds
    // structures to improve the performance of the transform.

    HRESULT _CalcFullBoundsClock();
    HRESULT _CalcFullBoundsWedge();
    HRESULT _CalcFullBoundsRadial();

    HRESULT _CalcOptBoundsClock();
    HRESULT _CalcOptBoundsWedge();
    HRESULT _CalcOptBoundsRadial();

    HRESULT _DrawRect(const CDXDBnds & bndsDest, const CDXDBnds & bndsSrc, 
                      BOOL * pfContinue);
    void    _IntersectRect(long width, long height, long x0, long y0, 
                           double dx, double dy, long & xi, long & yi);
    void    _ScanlineIntervals(long width, long height, long xedge, long yedge, 
                               float fProgress, long YScanline, long * XBounds);
    void    _ClipBounds(long offset, long width, long * XBounds);

public:

    CDXTRadialWipeBase();
    HRESULT FinalConstruct();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTRadialWipeBase)
        COM_INTERFACE_ENTRY(ICrRadialWipe)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTRadialWipeBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTRadialWipeBase)
        PROP_ENTRY("wipeStyle", 1, CLSID_CrRadialWipePP)
        PROP_PAGE(CLSID_CrRadialWipePP)
    END_PROPERTY_MAP()

    // CDXBaseNTo1 overrides

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                               ULONG aInIndex[], BYTE aWeight[]);

    // ICrRadialWipe

    STDMETHOD(get_wipeStyle)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_wipeStyle)(/*[in]*/ BSTR newVal);

    // IDXEffect

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTRadialWipe :
    public CDXTRadialWipeBase,
    public CComCoClass<CDXTRadialWipe, &CLSID_CrRadialWipe>,
    public IPersistStorageImpl<CDXTRadialWipe>,
    public IPersistPropertyBagImpl<CDXTRadialWipe>
{
public:

    CDXTRadialWipe()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTRADIALWIPE)
    DECLARE_POLY_AGGREGATABLE(CDXTRadialWipe)

    BEGIN_COM_MAP(CDXTRadialWipe)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTRadialWipeBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTRadialWipeOpt :
    public CDXTRadialWipeBase,
    public CComCoClass<CDXTRadialWipeOpt, &CLSID_DXTRadialWipe>,
    public IPersistStorageImpl<CDXTRadialWipeOpt>,
    public IPersistPropertyBagImpl<CDXTRadialWipeOpt>
{
public:

    CDXTRadialWipeOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTRADIALWIPEOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTRadialWipeOpt)

    BEGIN_COM_MAP(CDXTRadialWipeOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTRadialWipeBase)
    END_COM_MAP()
};


#endif //__CRRADIALWIPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\shadow.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    shadow.h
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	header file for shadow transform implementation CGlow
//
// Change History:
//
// 05/20/99 PhilLu      Move code from dtcss to dxtmsft. New algorithm.
// 12/03/99 a-matcal    Added support for IDXTClipOrigin interface.
//
//------------------------------------------------------------------------------

#ifndef __SHADOW_H_
#define __SHADOW_H_

#include "resource.h"       // main symbols




class ATL_NO_VTABLE CShadow : 
    public CDXBaseNTo1,
    public CComCoClass<CShadow, &CLSID_DXTShadow>,
    public CComPropertySupport<CShadow>,
    public IDispatchImpl<IDXTShadow, &IID_IDXTShadow, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IPersistStorageImpl<CShadow>,
    public ISpecifyPropertyPagesImpl<CShadow>,
    public IPersistPropertyBagImpl<CShadow>,
    public IObjectSafetyImpl2<CShadow>,
    public IDXTClipOrigin
{
private:

    BSTR        m_bstrColor;
    DXSAMPLE    m_rgbColor;
    long        m_lStrength;
    long        m_lDirection;
    CDXDBnds    m_bndsInput;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // Helpers 

    STDMETHOD(_GetActualInputBndsFromOutputBnds)(const CDXDBnds & bndsOutput,
                                                 CDXDBnds & bndsActualInput);

    void    _PropagateShadow(DXSAMPLE * pBuffer, int nWidth, int nHeight);
    BOOL    _IsOutputPointInEmptyCorner(const CDXDBnds & OutPoint);

public:

    CShadow();
    virtual ~CShadow();

    DECLARE_POLY_AGGREGATABLE(CShadow)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_SHADOW)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CShadow)
        COM_INTERFACE_ENTRY(IDXTShadow)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTClipOrigin)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CShadow>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CShadow)
        PROP_ENTRY("Color"    , 1, CLSID_DXTShadowPP)
        PROP_ENTRY("Direction", 2, CLSID_DXTShadowPP)
        PROP_ENTRY("Strength",  3, CLSID_DXTShadowPP)
        PROP_PAGE(CLSID_DXTShadowPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);
    HRESULT DetermineBnds(CDXDBnds & Bnds);

    // IDXTClipOrigin methods.

    STDMETHOD(GetClipOrigin)(DXVEC * pvecClipOrigin);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTShadow methods

    STDMETHOD(get_Color)(/*[out, retval]*/ BSTR * pbstrColor);
    STDMETHOD(put_Color)(/*[in]*/ BSTR bstrColor);
    STDMETHOD(get_Strength)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_Strength)(/*[in]*/ long lStrength);
    STDMETHOD(get_Direction)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_Direction)(/*[in]*/ long newVal);
};

#endif //__SHADOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

// Since there are multiple directories that need to have stdafx.h, we put all
// the stuff in stdafx_common.h to have the actual code in only one place.

#include "stdafx_common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\slide.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:            slide.h
//
// Created:             06/24/98
//
// Author:              phillu
//
// Discription:         This is the header file for the CrSlide transformation
//
// Change History:
// 06/24/98 PhilLu      Developed 1.0 version for Chromeffects
// 11/04/98 PaulNash    Moved from DT 1.0 codebase to IE5/NT5 DXTMSFT.DLL
// 01/25/99 a-matcal    Fixed property map entries.
// 05/10/99 a-matcal    Optimization.
// 10/24/99 a-matcal    Changed CSlide class to CDXTSlideBase and created two
//                      new classes CDXTSlide and CDXTSlideOpt to represent  
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRSLIDE_H_
#define __CRSLIDE_H_

#include "resource.h"

#define MAX_BOUNDS 2

typedef enum CRSLIDESTYLE
{
    CRSS_HIDE,
    CRSS_PUSH,
    CRSS_SWAP,
} CRSLIDESTYLE;




class ATL_NO_VTABLE CDXTSlideBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrSlide, &IID_ICrSlide, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTSlideBase>,
    public IObjectSafetyImpl2<CDXTSlideBase>,
    public ISpecifyPropertyPagesImpl<CDXTSlideBase>
{
private:

    SIZE            m_sizeInput;
    short           m_cBands;	
    CRSLIDESTYLE    m_eSlideStyle;

    // m_lCurSlideDist  This member variable is basically m_Progress multiplied
    //                  by the input surface width.  It's calculated once in 
    //                  OnInitInstData and then used throughout the Bounds 
    //                  Calculation functions.  
    // m_lPrevSlideDist The value of m_lCurSlideDist that was calculated for the
    //                  previous execute.

    long            m_lCurSlideDist;
    long            m_lPrevSlideDist;

    long            m_alInputIndex[MAX_BOUNDS];

    // m_aptOffset      This member variable holds the input offset for each 
    //                  set of bounds generated by the Bounds Calculation
    //                  functions.  The bounds generated represent areas of
    //                  the output surface.  This offset is used to specify the 
    //                  point on the input surface that corresponds to the
    //                  top-left point of the bounds.

    POINT           m_aptOffset[MAX_BOUNDS];

    CDXDBnds        m_abndsDirty[MAX_BOUNDS];
    ULONG           m_cbndsDirty;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

private:

    // Functions to calculate optimized bounds when blending with output and
    // using only one band.

    HRESULT _CalcFullBoundsHide();
    HRESULT _CalcFullBoundsPush();
    HRESULT _CalcFullBoundsSwap();

    // Functions to calculate optimized bounds when blending is off and using
    // only one band.  (Push and Swap are not specially optimizable for this 
    // situation because every pixel on the output is changing.)

    HRESULT _CalcOptBoundsHide();

    // This function is used for surface picking and when using greater than
    // one band.

    void    _CalcBounds(long & offsetA, long & offsetB, long & widthA, 
                        long & widthB);

    // Functions to generate/update output surface.  _WorkProc_Optimized is 
    // used for the 1 band cases, and _WorkProc_Multiband is used for the 
    // cases where then number of bands is greater than 1.

    HRESULT _WorkProc_Optimized(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT _WorkProc_Multiband(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
  
public:

    CDXTSlideBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTSlideBase)
        COM_INTERFACE_ENTRY(ICrSlide)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTSlideBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTSlideBase)
        PROP_ENTRY("bands"            , 1, CLSID_CrSlidePP)
        PROP_ENTRY("slideStyle"       , 2, CLSID_CrSlidePP)
        PROP_PAGE(CLSID_CrSlidePP)
    END_PROPERTY_MAP()

    // CComObjecRootEx overrides

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WorkInfo, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo);

    // ICrSlide methods

    STDMETHOD(get_slideStyle)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_slideStyle)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_bands)(/*[out, retval]*/ short *pVal);
    STDMETHOD(put_bands)(/*[in]*/ short newVal);

    // IDXEffect methods

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTSlide :
    public CDXTSlideBase,
    public CComCoClass<CDXTSlide, &CLSID_CrSlide>,
    public IPersistStorageImpl<CDXTSlide>,
    public IPersistPropertyBagImpl<CDXTSlide>
{
public:

    CDXTSlide()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTSLIDE)
    DECLARE_POLY_AGGREGATABLE(CDXTSlide)

    BEGIN_COM_MAP(CDXTSlide)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTSlideBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTSlideOpt :
    public CDXTSlideBase,
    public CComCoClass<CDXTSlideOpt, &CLSID_DXTSlide>,
    public IPersistStorageImpl<CDXTSlideOpt>,
    public IPersistPropertyBagImpl<CDXTSlideOpt>
{
public:

    CDXTSlideOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTSLIDEOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTSlideOpt)

    BEGIN_COM_MAP(CDXTSlideOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTSlideBase)
    END_COM_MAP()
};

#endif //__CRSLIDE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\slide.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:		slide.cpp
//
// Created:		06/24/98
//
// Author:		phillu
//
// Discription:		This is the implementation of the CrSlide transformation
//
// History
//
// 06/24/98 phillu      initial creation
// 07/02/98 phillu      return E_INVALIDARG rather than an error string; check 
//                      for E_POINTER
// 07/12/98 kipo        revert to previous checkin to fix crashing error when 
//                      bound rect specified
// 07/13/98 leonro      removed CSlide::OnGetSurfacePickOrder function and added 
//                      CSlide::OnSurfacePick to override picking correctly
// 07/22/98 phillu      implement clipping
// 05/10/99 a-matcal    Optimization.
// 05/19/99 a-matcal    Check for out of memory in get_ functions allocating
//                      BSTRs.
// 10/24/99 a-matcal    Changed CSlide class to CDXTSlideBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "slide.h"





//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::CDXTSlideBase
//
//------------------------------------------------------------------------------
CDXTSlideBase::CDXTSlideBase() :
    m_cBands(1),
    m_eSlideStyle(CRSS_HIDE),
    m_cbndsDirty(0),
    m_lCurSlideDist(0),
    m_lPrevSlideDist(0),
    m_fOptimizationPossible(false),
    m_fOptimize(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // Base class members

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTSlideBase::CDXTSlideBase


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTSlideBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_CalcFullBoundsHide
//
//  Overview:   This method calculates two sets of bounds that represent the 
//              output at the current progress.
//
//              If the progress is such that the output is composed entirely
//              of pixels from only one input, the bounds representing the other
//              input will have no area and will be skipped by the WorkProc 
//              method.
//
//              lBarLocation: When this transform is in hide mode, Input A moves
//              from right to left over the top of input B.  Since the 
//              m_lCurSlideDist moves from left to right, the method calculates
//              lBarLocation to represent the right edge of Input A at the
//              current progress.  
//
//              AAABBBBBBBB
//              AAABBBBBBBB
//              AAABBBBBBBB
//              AAABBBBBBBB
//                 ^   ^
//                 |   |-- m_lCurSlideDist (--> as progress increases)
//                 |
//                 |---- lBarLocation      (<-- as progress increases)
//
//
//              Note:  All coordinates are calculated in output space coordinates
//              assuming that 1) the output surface is the same size as the input
//              surface(s), 2) the output is placed at {0, 0} and 3) the ouput is
//              not clipped. Bounds will be transformed to input space, clipped,
//              or offset to support placement by the WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::_CalcFullBoundsHide()
{
    long    lBarLocation = m_sizeInput.cx - m_lCurSlideDist; 
    RECT    rc;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    // Input A bounds and offset.

    rc.left     = 0;
    rc.right    = lBarLocation;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].x   = m_lCurSlideDist;
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 0;
    m_cbndsDirty++;

    // Input B bounds and offset.

    rc.left     = lBarLocation;
    rc.right    = m_sizeInput.cx;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].x   = 0;
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 1;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTSlideBase::_CalcFullBoundsHide


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_CalcFullBoundsPush
//
//  Overview:   This method calculates two sets of bounds that represent the 
//              output at the current progress.
//
//              If the progress is such that the output is composed entirely
//              of samples from one input, the bounds representing the other
//              input will have no area and will be skipped by the WorkProc 
//              method.
//
//              lBarLocation: When this transform is in push mode, both Inputs A
//              and B move from right to left.  Since the m_lCurSlideDist 
//              member moves from left to right, the method calculates
//              lBarLocation to represent the right edge of Input A and the left
//              edge of Input B at the current progress.
//
//
//              Note:  All coordinates are calculated in output space coordinates
//              assuming that 1) the output surface is the same size as the input
//              surface(s), 2) the output is placed at {0, 0} and 3) the ouput is
//              not clipped. Bounds will be transformed to input space, clipped,
//              or offset to support placement by the WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::_CalcFullBoundsPush()
{
    long    lBarLocation = m_sizeInput.cx - m_lCurSlideDist;
    RECT    rc;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    // Input A bounds and offset.

    rc.left     = 0;
    rc.right    = lBarLocation;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].x   = m_lCurSlideDist;
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 0;
    m_cbndsDirty++;

    // Input B bounds and offset.

    rc.left     = lBarLocation;
    rc.right    = m_sizeInput.cx;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].x   = -lBarLocation;
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 1;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTSlideBase::_CalcFullBoundsPush


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_CalcFullBoundsSwap
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::_CalcFullBoundsSwap()
{
    long    lInvSlideDist   = m_sizeInput.cx - m_lCurSlideDist;
    RECT    rc;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    // Input A bounds and offset.

    rc.left     = 0;
    rc.right    = lInvSlideDist;

    if (m_lCurSlideDist < lInvSlideDist)
    {
        m_aptOffset[m_cbndsDirty].x = m_lCurSlideDist;
    }
    else
    {
        m_aptOffset[m_cbndsDirty].x = lInvSlideDist;
    }

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 0;
    m_cbndsDirty++;

    // Input B bounds and offset.

    rc.left     = lInvSlideDist;
    rc.right    = m_sizeInput.cx;

    if (m_lCurSlideDist < lInvSlideDist)
    {
        m_aptOffset[m_cbndsDirty].x = -m_lCurSlideDist; 
    }
    else
    {
        m_aptOffset[m_cbndsDirty].x = -lInvSlideDist;
    }

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 1;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTSlideBase::_CalcFullBoundsSwap


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_CalcOptBoundsHide
//
//  Overview:   This method calculates one or two sets of bounds that represent 
//              the changes that need to be made to the previous output to bring
//              it up to the current progress.
//
//              The area represting the sliding portion of Input A will always
//              be generated along with it's new offset.  
//
//              If progress has decreased, a set of bounds will be generated
//              to update only the portion that has been newly uncovered which
//              is possible because the Input B portion is stationary during 
//              the duration of the effect.
//
//              lBarLocation: When this transform is in hide mode, Input A moves
//              from right to left over the top of input B.  Since the 
//              m_lCurSlideDist moves from left to right, the method calculates
//              lBarLocation to represent the right edge of Input A at the
//              current progress.  
//
//              Progress decreased:             Progress Increased:
//
//              AAABBBB----                     AAAAAAA----
//              AAABBBB----                     AAAAAAA----
//              AAABBBB----                     AAAAAAA----
//              AAABBBB----                     AAAAAAA----
//                 ^   ^                           ^   ^
//                 |   |-- lPrevBarLocation        |   |-- lBarLocation
//                 |                               |
//                 |---- lBarLocation              |---- lPrevBarLocation    
//
//              - = Pixels that don't need to be updated.
//
//
//              Note:  All coordinates are calculated in output space coordinates
//              assuming that 1) the output surface is the same size as the input
//              surface(s), 2) the output is placed at {0, 0} and 3) the ouput is
//              not clipped. Bounds will be transformed to input space, clipped,
//              or offset to support placement by the WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::_CalcOptBoundsHide()
{
    long    lBarLocation        = m_sizeInput.cx - m_lCurSlideDist;
    long    lPrevBarLocation    = m_sizeInput.cx - m_lPrevSlideDist;
    RECT    rc;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    // Input A bounds and offset.

    rc.left     = 0;
    rc.right    = lBarLocation;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].x   = m_lCurSlideDist;
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 0;
    m_cbndsDirty++;

    // Input B bounds and offset.

    if (lBarLocation < lPrevBarLocation)
    {
        rc.left     = lBarLocation;
        rc.right    = lPrevBarLocation;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_aptOffset[m_cbndsDirty].x   = 0;
        m_aptOffset[m_cbndsDirty].y   = 0;
        m_alInputIndex[m_cbndsDirty]  = 1;
        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTSlideBase::_CalcOptBoundsHide


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_CalcBounds
//
//  Arguments:  offset  the first visible pixel of an image in the output 
//                      buffer, from the start of image.
//
//              width   number of pixels of an image visible in the output 
//                      buffer.
//
//------------------------------------------------------------------------------
void 
CDXTSlideBase::_CalcBounds(long & offsetA, long & offsetB, long & widthA, 
                           long & widthB)
{
    long lInvSlideDist = m_sizeInput.cx - m_lCurSlideDist;

    //long slideDist = (long)(m_sizeInput.cx * m_Progress + 0.5F);

    switch(m_eSlideStyle)
    {
    case CRSS_HIDE:
        offsetA = m_lCurSlideDist;
        widthA  = lInvSlideDist;
        offsetB = lInvSlideDist;
        widthB  = m_lCurSlideDist;

        break;

    case CRSS_PUSH:
        offsetA = m_lCurSlideDist;
        widthA  = lInvSlideDist;
        offsetB = 0;
        widthB  = m_lCurSlideDist;

        break;

    case CRSS_SWAP:
        if(m_lCurSlideDist < lInvSlideDist)
        {
            offsetA = m_lCurSlideDist;
            widthA  = lInvSlideDist;
            offsetB = lInvSlideDist - m_lCurSlideDist;
        // same as: = m_sizeInput.cx - (2 * m_lCurSlideDist);
            widthB  = m_lCurSlideDist;
        }
        else
        {
            offsetA = lInvSlideDist;
            widthA  = lInvSlideDist;
            offsetB = 0;
            widthB  = m_lCurSlideDist;            
        }

        break;

    default:
        _ASSERT(0);

        break;
    }
}
//  CDXTSlideBase::_CalcBounds


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::OnSetup(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsIn.GetXYSize(m_sizeInput);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTSlideBase::OnSetup


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                             CDXDVec & InVec)
{
    HRESULT     hr          = S_OK;
    BOOL        bFoundIt    = FALSE;
    long        pickX       = OutPoint.Left();
    long        pickY       = OutPoint.Top();
    long        offsetA     = 0;
    long        offsetB     = 0;
    long        widthA      = 0;
    long        widthB      = 0;
    long        iBand       = 0;
    
    if ((OutPoint.Left() < 0) || (OutPoint.Left() >= m_sizeInput.cx))
    {
        return S_FALSE;
    }

    _CalcBounds(offsetA, offsetB, widthA, widthB);

    iBand = pickY * m_cBands / m_sizeInput.cy;

    // Create an adjusted output point to be used for
    // the rest of the calculations.
    CDXDBnds    AdjustedOutPoint(OutPoint);
    POINT       pt={OutPoint.Left(), OutPoint.Top()};

    if (iBand&1) // odd bands
    {
        offsetA = m_sizeInput.cx - offsetA - widthA;
        offsetB = m_sizeInput.cx - offsetB - widthB;

        if (pickX < widthB)
        {
            ulInputIndex = 1;
            pt.x += offsetB;
        }
        else
        {
            ulInputIndex = 0;
            pt.x -= (widthB - offsetA);
        }
    }
    else // even bands (including the case of a single band)
    {
        if (pickX < widthA)
        {
            ulInputIndex = 0;
            pt.x += offsetA;
        }
        else
        {
            ulInputIndex = 1;
            pt.x -= (widthA - offsetB);
        }
    }
    
    AdjustedOutPoint.SetXYPoint(pt);
    
    // The following code was copied from the base class and 
    // modified to use AdjustedOutPoint and the appropriate
    // variable names for this function.

    if (HaveInput(ulInputIndex))
    {
        CDXDBnds Out2InBnds(false);
        hr = MapBoundsOut2In(0, &AdjustedOutPoint, ulInputIndex, &Out2InBnds);
        if (SUCCEEDED(hr))
        {
            CDXDBnds InSurfBnds(InputSurface(ulInputIndex), hr);
            if (SUCCEEDED(hr) && InSurfBnds.IntersectBounds(Out2InBnds))
            {
                IDXARGBReadPtr * pPtr;
                hr = InputSurface(ulInputIndex)->LockSurface(&InSurfBnds, m_ulLockTimeOut, DXLOCKF_READ, 
                                                        IID_IDXARGBReadPtr, (void **)&pPtr, NULL);
                if( SUCCEEDED(hr) )
                {
                    DXPMSAMPLE val;
                    pPtr->UnpackPremult(&val, 1, FALSE);
                    pPtr->Release();
                    if ( val.Alpha )
                    {
                        InSurfBnds.GetMinVector(InVec);
                        bFoundIt = TRUE;
                    }
                }
            }   
        }
    }
    if (SUCCEEDED(hr) & (!bFoundIt))
    {
        hr = S_FALSE;
    }

    return hr;
} 
//  CDXTSlideBase::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::OnInitInstData(CDXTWorkInfoNTo1 & WorkInfo, 
                              ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    // Reset number of dirty bounds.

    m_cbndsDirty = 0;

    // Calculate m_lCurBarLoc.

    m_lCurSlideDist = (long)(m_sizeInput.cx * m_Progress + 0.5);

    // If only one band is used, we can optimize the transform using the
    // bounds functions.

    if (1 == m_cBands)
    {
        // If the inputs, output, or transform is dirty, or if we can't optimize we 
        // have to entirely redraw the output surface.  Otherwise we can create 
        // optimized dirty bounds.

        if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
            || IsTransformDirty() || DoOver() || !m_fOptimize
            || !m_fOptimizationPossible)
        {
            // If something is dirty, calculate bounds that will cover the 
            // full output area of the transform.  If "blend with output" is
            // set, this will always be the case.  (As long as the caller
            // has dirtied the output appropriately.)

            switch (m_eSlideStyle)
            {
            case CRSS_HIDE:
                hr = _CalcFullBoundsHide();

                break;

            case CRSS_PUSH:
                hr = _CalcFullBoundsPush();

                break;

            case CRSS_SWAP:
                hr = _CalcFullBoundsSwap();

                break;

            default:
                _ASSERT(0);

                break;
            } // switch (m_eSlideStyle)
        }
        else // We can create optimized bounds.
        {
            // If the slide distance hasn't changed, nothing needs to be 
            // updated.

            if (m_lCurSlideDist == m_lPrevSlideDist)
            {
                goto done;
            }

            switch (m_eSlideStyle)
            {
            case CRSS_HIDE:
                hr = _CalcOptBoundsHide();

                break;

            case CRSS_PUSH:
                hr = _CalcFullBoundsPush();

                break;

            case CRSS_SWAP:
                hr = _CalcFullBoundsSwap();

                break;

            default:
                _ASSERT(0);

                break;
            } // switch (m_eSlideStyle)
        } // We can create optimized bounds.
    } // if (1 == m_cBands)

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the
    // DoBnds to that of the input(s).

    if (((LONG)WorkInfo.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WorkInfo.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::WorkProc, CDXBaseNTo1
//
//  Description:    This function is used to calculate the result based on the 
//                  specified bounds and the current effect progress.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    if (1 == m_cBands)
    {
        hr = _WorkProc_Optimized(WI, pbContinue);
    }
    else
    {
        hr = _WorkProc_Multiband(WI, pbContinue);
    }

    return hr;
}
//  CDXTSlideBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_WorkProc_Optimized
//
//  Description:    This function is used to calculate the result based on the 
//                  specified bounds and the current effect progress.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::_WorkProc_Optimized(const CDXTWorkInfoNTo1 & WI, 
                                   BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;
    ULONG   i       = 0;

    long    lInOutOffsetX = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }


    for (i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            bndsDest = bndsSrc;

            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            bndsSrc.Offset(m_aptOffset[i].x, m_aptOffset[i].y, 0, 0);

            hr = DXBitBlt(OutputSurface(), bndsDest,
                          InputSurface(m_alInputIndex[i]), bndsSrc,
                          dwFlags, INFINITE);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTSlideBase::_WorkProc_Optimized


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_WorkProc_Multiband
//
//  Description:    This function is used to calculate the result based on the 
//                  specified bounds and the current effect progress.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::_WorkProc_Multiband(const CDXTWorkInfoNTo1 & WI, 
                                   BOOL * pbContinue)
{
    HRESULT hr          = S_OK;

    long    y           = 0;
    long    lOffsetA    = 0;
    long    lOffsetB    = 0;
    long    lWidthA     = 0;
    long    lWidthB     = 0;
    long    lDoWidth    = WI.DoBnds.Width();
    long    lDoHeight   = WI.DoBnds.Height();

    DXPMSAMPLE *    pRowBuff    = NULL;
    DXPMSAMPLE *    pOutBuff    = NULL;

    DXDITHERDESC    dxdd;

    CComPtr<IDXARGBReadPtr> pInA;
    CComPtr<IDXARGBReadPtr> pInB;
    CComPtr<IDXARGBReadWritePtr> pOut;

    // Lock input 0. Need to lock the whole surface instead of only within 
    // DoBnds.

    hr = InputSurface(0)->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void**)&pInA, 
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Lock input 1.  Need to lock the whole surface instead of only within 
    // DoBnds.

    hr = InputSurface(1)->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void**)&pInB, 
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Lock output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, 
                                      (void**)&pOut, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Allocate buffer for a row of the entire image (not just within the 
    // clip bounds.)

    pRowBuff = DXPMSAMPLE_Alloca(m_sizeInput.cx);

    // Allocate output buffer if needed.

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca( lDoWidth );
    }

    //  Set up the dither structure.

    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = pRowBuff;
        dxdd.cSamples       = lDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    _CalcBounds(lOffsetA, lOffsetB, lWidthA, lWidthB);

    for (y = 0; *pbContinue && (y < lDoHeight); y++)
    {
        long iBand = (y + WI.DoBnds.Top()) * m_cBands / m_sizeInput.cy;

        if (iBand & 1)
        {
            // If there are multiple bands, the odd bands slide in the opposite
            // direction as the even bands.

            // Get the B samples.

            if (lWidthB > 0)
            {
                pInB->MoveToXY(m_sizeInput.cx - lOffsetB - lWidthB, 
                               y + WI.DoBnds.Top());
                pInB->UnpackPremult(pRowBuff, lWidthB, FALSE);
            }

            // Get the A samples.

            if (lWidthA > 0)
            {
                pInA->MoveToXY(m_sizeInput.cx - lOffsetA - lWidthA, 
                               y + WI.DoBnds.Top());
                pInA->UnpackPremult(pRowBuff + lWidthB, lWidthA, FALSE);
            }
        }
        else
        {
            // Even bands (including the case of a single band.)

            // get the A samples
            if (lWidthA > 0)
            {
                pInA->MoveToXY(lOffsetA, y + WI.DoBnds.Top());
                pInA->UnpackPremult(pRowBuff, lWidthA, FALSE);
            }

            // get the B samples
            if (lWidthB > 0)
            {
                pInB->MoveToXY(lOffsetB, y + WI.DoBnds.Top());
                pInB->UnpackPremult(pRowBuff + lWidthA, lWidthB, FALSE);
            }

        }

        // Truncate the row of output image to the portion within the clip 
        // bound.

        if (lDoWidth < m_sizeInput.cx)
        {
            long i = 0;

            for (; i < lDoWidth; i++)
            {
                pRowBuff[i] = pRowBuff[i + WI.DoBnds.Left()];
            }
        }

        // Move to the correct output row.

        pOut->MoveToRow(y);

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            pOut->OverArrayAndMove(pOutBuff, pRowBuff, lDoWidth);
        }
        else
        {
            pOut->PackPremultAndMove(pRowBuff, lDoWidth);
        }
    } // End for

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTSlideBase::_WorkProc_Multiband


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo)
{
    m_lPrevSlideDist = m_lCurSlideDist;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTSlideBase::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::get_bands, ICrSlide
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTSlideBase::get_bands(short * pVal)
{
    HRESULT hr = S_OK;

    if (!pVal)
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_cBands;
    }

    return hr;
}
//  CDXTSlideBase::get_bands, ICrSlide


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::put_bands, ICrSlide
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTSlideBase::put_bands(short newVal)
{
    if (newVal > 0 && newVal < 101)
    {
        if (m_cBands != newVal)
        {
            Lock();
            m_cBands = newVal;
            SetDirty();
            Unlock();
        }
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}
//  CDXTSlideBase::put_bands, ICrSlide


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::get_slideStyle, ICrSlide
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTSlideBase::get_slideStyle(BSTR * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    switch (m_eSlideStyle)
    {
    case CRSS_HIDE:
        *pVal = SysAllocString(L"HIDE");

        break;

    case CRSS_PUSH:
        *pVal = SysAllocString(L"PUSH");

        break;

    case CRSS_SWAP:
        *pVal = SysAllocString(L"SWAP");

        break;

    default:
        _ASSERT(0);

        break;
    }

    if (NULL == pVal)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTSlideBase::get_slideStyle, ICrSlide


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::put_slideStyle, ICrSlide
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTSlideBase::put_slideStyle(BSTR newVal)
{
    CRSLIDESTYLE    eNewStyle;

    if (!newVal)
    {
        return E_POINTER;
    }


    if(!_wcsicmp(newVal, L"HIDE"))
    {
        eNewStyle = CRSS_HIDE;
    }
    else if(!_wcsicmp(newVal, L"PUSH"))
    {
        eNewStyle = CRSS_PUSH;
    }
    else if(!_wcsicmp(newVal, L"SWAP"))
    {
        eNewStyle = CRSS_SWAP;
    }
    else
    {
        return E_INVALIDARG;
    }

    if (eNewStyle != m_eSlideStyle)
    {
        Lock();
        m_eSlideStyle = eNewStyle;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CDXTSlideBase::put_slideStyle, ICrSlide
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\spiral.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:		spiral.h
//
// Created:		06/25/98
//
// Author:		phillu
//
// Discription:		This is the header file for the CrSpiral transform.
//
// 05/01/99 a-matcal    Optimized.  Derived from CGridBase.
// 10/24/99 a-matcal    Changed CSpiral class to CDXTSpiralBase and created two
//                      new classes CDXTSpiral and CDXTSpiralOpt to represent  
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRSPIRAL_H_
#define __CRSPIRAL_H_

#include "resource.h"
#include "gridbase.h"




class ATL_NO_VTABLE CDXTSpiralBase : 
    public CGridBase,
    public IDispatchImpl<ICrSpiral, &IID_ICrSpiral, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTSpiralBase>,
    public IObjectSafetyImpl2<CDXTSpiralBase>,
    public ISpecifyPropertyPagesImpl<CDXTSpiralBase>
{
private:

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // CGridBase overrides

    HRESULT OnDefineGridTraversalPath();

public:

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTSpiralBase)
        COM_INTERFACE_ENTRY(ICrSpiral)
        COM_INTERFACE_ENTRY(IDXTGridSize)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTSpiralBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTSpiralBase)
        PROP_ENTRY("gridSizeX"       , 1, CLSID_CrSpiralPP)
        PROP_ENTRY("gridSizeY"       , 2, CLSID_CrSpiralPP)
        PROP_PAGE(CLSID_CrSpiralPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // IDXTGridSize, ICrSpiral

    DECLARE_IDXTGRIDSIZE_METHODS()

    // IDXEffect

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTSpiral :
    public CDXTSpiralBase,
    public CComCoClass<CDXTSpiral, &CLSID_CrSpiral>,
    public IPersistStorageImpl<CDXTSpiral>,
    public IPersistPropertyBagImpl<CDXTSpiral>
{
public:

    CDXTSpiral()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTSPIRAL)
    DECLARE_POLY_AGGREGATABLE(CDXTSpiral)

    BEGIN_COM_MAP(CDXTSpiral)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTSpiralBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTSpiralOpt :
    public CDXTSpiralBase,
    public CComCoClass<CDXTSpiralOpt, &CLSID_DXTSpiral>,
    public IPersistStorageImpl<CDXTSpiralOpt>,
    public IPersistPropertyBagImpl<CDXTSpiralOpt>
{
public:

    CDXTSpiralOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTSPIRALOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTSpiralOpt)

    BEGIN_COM_MAP(CDXTSpiralOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTSpiralBase)
    END_COM_MAP()
};


#endif //__CRSPIRAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\stretch.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:                stretch.h
//
// Created:                 06/23/98
//
// Author:                  PhilLu
//
// Discription:             This file declares CStretch (Stretch Transforms)
//
// 07/13/98 a-matcal    replaced OnSetSurfacePickOrder with OnSurfacePick so 
//                      that the x values of the picked point will be calculated 
//                      correctly.
// 05/10/99 a-matcal    Optimization.
// 10/24/99 a-matcal    Changed CStretch class to CDXTStretchBase and created two
//                      new classes CDXTStretch and CDXTStretchOpt to represent  
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRSTRETCH_H_
#define __CRSTRETCH_H_

#include "resource.h"

#define MAX_STRETCH_BOUNDS 3

typedef enum CRSTRETCHSTYLE
{
    CRSTS_HIDE,
    CRSTS_PUSH,
    CRSTS_SPIN
} CRSTRETCHSTYLE;




class ATL_NO_VTABLE CDXTStretchBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrStretch, &IID_ICrStretch, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTStretchBase>,
    public IObjectSafetyImpl2<CDXTStretchBase>,
    public ISpecifyPropertyPagesImpl<CDXTStretchBase>
{
private:

    SIZE            m_sizeInput;
    CRSTRETCHSTYLE  m_eStretchStyle;
    long            m_lCurStretchWidth;
    long            m_lPrevStretchWidth;

    CDXDBnds        m_abndsDirty[MAX_STRETCH_BOUNDS];
    long            m_alInputIndex[MAX_STRETCH_BOUNDS];
    ULONG           m_cbndsDirty;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

private:

    // Functions to calculate optimized bounds when the entire output needs to
    // be redrawn.

    HRESULT _CalcFullBoundsHide();
    HRESULT _CalcFullBoundsPush();
    HRESULT _CalcFullBoundsSpin();

    // Functions to calculate optimized bounds when only the dirty parts of the
    // output need to be redrawn.  (Push can't be optimized in this way.)

    HRESULT _CalcOptBoundsHide();
    HRESULT _CalcOptBoundsSpin();

    // This function basically does a sort of a crapola horizontal scale where
    // you can only scale smaller, not larger.  It looks fine in action, though.

    HRESULT _HorizontalSquish(const CDXDBnds & bndsSquish, 
                              const CDXDBnds & bndsDo, IDXSurface * pSurfIn, 
                              const CDXDBnds & bndsSrc, DWORD dwFlags, 
                              ULONG ulTimeout, BOOL * pfContinue);

public:

    CDXTStretchBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTStretchBase)
        COM_INTERFACE_ENTRY(ICrStretch)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTStretchBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTStretchBase)
        PROP_ENTRY("stretchStyle"   , 1, CLSID_CrStretchPP)
        PROP_PAGE(CLSID_CrStretchPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides
    
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec); 
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WorkInfo, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo);

    // ICrStretch methods

    STDMETHOD(get_stretchStyle)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_stretchStyle)(/*[in]*/ BSTR newVal);

    // IDXEffect methods

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTStretch :
    public CDXTStretchBase,
    public CComCoClass<CDXTStretch, &CLSID_CrStretch>,
    public IPersistStorageImpl<CDXTStretch>,
    public IPersistPropertyBagImpl<CDXTStretch>
{
public:

    CDXTStretch()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTSTRETCH)
    DECLARE_POLY_AGGREGATABLE(CDXTStretch)

    BEGIN_COM_MAP(CDXTStretch)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTStretchBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTStretchOpt :
    public CDXTStretchBase,
    public CComCoClass<CDXTStretchOpt, &CLSID_DXTStretch>,
    public IPersistStorageImpl<CDXTStretchOpt>,
    public IPersistPropertyBagImpl<CDXTStretchOpt>
{
public:

    CDXTStretchOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTSTRETCHOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTStretchOpt)

    BEGIN_COM_MAP(CDXTStretchOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTStretchBase)
    END_COM_MAP()
};


#endif //__CRSTRETCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\stretch.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:                stretch.cpp
//
// Created:                 06/23/98
//
// Author:                  PhilLu
//
// Discription:             This file implements the Stretch transform.
//
// History
//
// 06/23/98 phillu      initial creation.
// 07/02/98 phillu      return E_INVALIDARG rather than an error string; check 
//                      for E_POINTER.
// 07/09/98 phillu      implement OnSetSurfacePickOrder().
// 07/13/98 a-matcal    replaced OnSetSurfacePickOrder with OnSurfacePick so 
//                      that the x values of the picked point will be calculated
//                      correctly.
// 07/22/98 phillu      implement clipping.
// 05/10/99 a-matcal    Optimization.
// 05/19/99 a-matcal    Check for out of memory in get_ functions allocating
//                      BSTRs.
// 10/24/99 a-matcal    Changed CStretch class to CDXTStretchBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "stretch.h"

#define DO_STRETCH  0x00010000L




//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::CDXTStretchBase
//
//------------------------------------------------------------------------------
CDXTStretchBase::CDXTStretchBase() :
    m_eStretchStyle(CRSTS_SPIN),
    m_cbndsDirty(0),
    m_lCurStretchWidth(0),
    m_lPrevStretchWidth(0),
    m_fOptimizationPossible(false),
    m_fOptimize(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTStretchBase::CDXTStretchBase


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTStretchBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_CalcFullBoundsHide
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::_CalcFullBoundsHide()
{
    RECT rc;

    // Bounds for stretched input B area.

    rc.left     = 0;
    rc.top      = 0;
    rc.right    = m_lCurStretchWidth;
    rc.bottom   = m_sizeInput.cy;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

    // If bounds take up entire output, no need to do stretch, just copy all of
    // input B to the output.

    if (m_lCurStretchWidth == m_sizeInput.cx)
    {
        m_alInputIndex[m_cbndsDirty] = 1;
    }
    else // Do stretch.
    {
        m_alInputIndex[m_