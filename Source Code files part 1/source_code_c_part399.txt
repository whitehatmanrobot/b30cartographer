erFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        IrpContext = AllocateIrpContext( Irp );
        Status = NwCommonLock( IrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( IrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = Status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error Status that we get back from the
            //  execption code
            //

            Status = NwProcessException( IrpContext, GetExceptionCode() );
        }

    }

    if ( IrpContext ) {
        NwCompleteRequest( IrpContext, Status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NwFsdLock -> %08lx\n", Status );

    TimerStop(Dbg,"NwFsdLockControl");

    return Status;

    UNREFERENCED_PARAMETER(DeviceObject);
}


NTSTATUS
NwCommonLock (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine does the common code for NtLockFile/NtUnlockFile.

Arguments:

    IrpContext - Supplies the request being processed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS status;

    PIRP Irp;
    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PICB icb;
    PFCB fcb;
    PVOID fsContext;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    Irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "CommonLock...\n", 0);
    DebugTrace( 0, Dbg, "Irp  = %08lx\n", (ULONG_PTR)Irp);

    //
    // Decode the file object to figure out who we are.  If the result
    // is not the root DCB then its an illegal parameter.
    //

    nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                       &fsContext,
                                       (PVOID *)&icb );

    if (nodeTypeCode != NW_NTC_ICB) {

        DebugTrace(0, Dbg, "Not a file\n", 0);

        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonLock -> %08lx\n", status );
        return status;
    }

    //
    //  Make sure that this ICB is still active.
    //

    NwVerifyIcb( icb );

    fcb = (PFCB)icb->SuperType.Fcb;
    nodeTypeCode = fcb->NodeTypeCode;

    if (nodeTypeCode == NW_NTC_FCB ) {

        IrpContext->pScb = fcb->Scb;
        IrpContext->pNpScb = IrpContext->pScb->pNpScb;
        IrpContext->Icb = icb;

    } else {

        DebugTrace(0, Dbg, "Not a file\n", 0);

        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonLock -> %08lx\n", status );
        return status;
    }

    switch (irpSp->MinorFunction) {

    case IRP_MN_LOCK:
    case IRP_MN_UNLOCK_SINGLE:
    case IRP_MN_UNLOCK_ALL:
    case IRP_MN_UNLOCK_ALL_BY_KEY:
        status = LockNcp( IrpContext, icb );
        break;

    default:
        //
        //  Minor function added to I/O system that this driver does
        //  not understand.
        //

        status = STATUS_INVALID_PARAMETER;
    }

    DebugTrace(-1, Dbg, "CommonLock -> %08lx\n", status);

    return status;
}

NTSTATUS
LockNcp(
    PIRP_CONTEXT IrpContext,
    PICB Icb
    )
/*++

Routine Description:

    This routine exchanges a series of Lock NCPs with the server.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

    Icb - Supplies the file specific information.

Return Value:

    Status of transfer.

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER Length;
    ULONG Key;

    PSCB pScb;
    PNONPAGED_FCB pNpFcb;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    PNW_FILE_LOCK FileLock = NULL;
    USHORT LockFlags = 3;

    PAGED_CODE();

    irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    ByteOffset = irpSp->Parameters.LockControl.ByteOffset;

    if ( irpSp->Parameters.LockControl.Length != NULL ) {
        Length = *irpSp->Parameters.LockControl.Length;
    } else {
        Length.HighPart =  0;
        Length.LowPart =  0;
    }

    Key = irpSp->Parameters.LockControl.Key;

    DebugTrace(+1, Dbg, "LockNcp...\n", 0);
    DebugTrace( 0, Dbg, "irp     = %08lx\n", (ULONG_PTR)irp);
    DebugTrace( 0, Dbg, "MinorFun= %08lx\n", (ULONG)irpSp->MinorFunction);
    DebugTrace( 0, Dbg, "File    = %wZ\n", &Icb->SuperType.Fcb->FullFileName);
    DebugTrace( 0, Dbg, "HOffset = %lx\n", ByteOffset.HighPart);
    DebugTrace( 0, Dbg, "LOffset = %lx\n", ByteOffset.LowPart);
    DebugTrace( 0, Dbg, "HLength = %lx\n", Length.HighPart);
    DebugTrace( 0, Dbg, "LLength = %lx\n", Length.LowPart);
    DebugTrace( 0, Dbg, "Key     = %lx\n", Key);

    pScb = Icb->SuperType.Fcb->Scb;

    ASSERT (pScb->NodeTypeCode == NW_NTC_SCB);

    pNpFcb =  Icb->SuperType.Fcb->NonPagedFcb;

    //
    //  Get to the front of the ScbQueue to protect access to the lock list.
    //

    NwAppendToQueueAndWait( IrpContext );

    try {

        switch ( irpSp->MinorFunction ) {

        case IRP_MN_LOCK:

            //
            //  Since we are doing a lock we will need to send an End Of Job
            //  for this PID.
            //

            NwSetEndOfJobRequired( pScb->pNpScb, Icb->Pid );

            //
            //  Try to allocate a lock structure before we ask the
            //  server to perform the lock.
            //

            FileLock = ALLOCATE_POOL_EX( NonPagedPool, sizeof( NW_FILE_LOCK ) );
            IrpContext->Specific.Lock.FileLock = FileLock;

            FileLock->NodeTypeCode = NW_NTC_FILE_LOCK;
            FileLock->NodeByteSize = sizeof( NW_FILE_LOCK );

            FileLock->StartFileOffset = ByteOffset.LowPart;
            FileLock->Length = Length.LowPart;
            FileLock->EndFileOffset = ByteOffset.LowPart + Length.LowPart - 1;
            FileLock->Key = Key;
            FileLock->Icb = Icb;
            FileLock->IrpContext = IrpContext;

            //
            // Remember the originating process because NT locks
            // have PROCESS level granularity!!
            //

            FileLock->pOwnerProc = PsGetCurrentProcessId();

            if ( irpSp->Flags & SL_EXCLUSIVE_LOCK ) {
                LockFlags = 0x00;
            } else {
                LockFlags = 0x02;
            }

            FileLock->Flags = LockFlags;

            //
            //  Is this is an overlapping lock
            //

            if ( irpSp->Flags & SL_FAIL_IMMEDIATELY ) {
                IrpContext->Specific.Lock.Wait = FALSE;
            } else {
                IrpContext->Specific.Lock.Wait = TRUE;
            }

            if ( LockIsOverlapping( pNpFcb, ByteOffset.LowPart, Length.LowPart ) ) {

                if ( IrpContext->Specific.Lock.Wait ) {

                    //
                    //  Queue this IRP context to the FCB.  We'll process it
                    //  when the local conflict is removed.
                    //

                    InsertTailList( &pNpFcb->PendingLockList, &FileLock->ListEntry );
                    status = STATUS_PENDING;
                    NwDequeueIrpContext( IrpContext, FALSE );

                } else  {
                    status = STATUS_FILE_LOCK_CONFLICT;
                }

            } else {

                //
                //  Send the lock request.
                //

                status = Exchange (
                            IrpContext,
                            LockNcpCallback,
                            "Fbrddw",
                            NCP_LOCK_RANGE,
                            LockFlags | 0x01,
                            Icb->Handle, sizeof( Icb->Handle ),
                            ByteOffset.LowPart,
                            Length.LowPart,
                            LockTimeoutThreshold );

            }

            break;

        case IRP_MN_UNLOCK_SINGLE:

            if ( !LockExists( pNpFcb, ByteOffset.LowPart, Length.LowPart, &FileLock ) ) {

                status = STATUS_RANGE_NOT_LOCKED;

            } else {

                //
                // Verify that this lock belongs to this process.
                //

                if ( FileLock->pOwnerProc != PsGetCurrentProcessId() ) {

                    DebugTrace( 0, Dbg, "Unlock process not owner!\n", 0 );
                    status = STATUS_ACCESS_DENIED;

                    //
                    // Ensure that we don't free the filelock
                    //

                    FileLock = NULL;

                } else {

                    IrpContext->Specific.Lock.FileLock = FileLock;

                    status = Exchange (
                                 IrpContext,
                                 UnlockNcpCallback,
                                 "F-rddw",
                                 NCP_UNLOCK_RANGE,
                                 Icb->Handle, sizeof( Icb->Handle ),
                                 ByteOffset.LowPart,
                                 Length.LowPart,
                                 1 );
               }
            }

            break;

        case IRP_MN_UNLOCK_ALL:
            IrpContext->Icb = Icb;
            IrpContext->Specific.Lock.ByKey = FALSE ;

            status = UnlockIcbLocks( IrpContext );
            break;

        case IRP_MN_UNLOCK_ALL_BY_KEY:
            IrpContext->Icb = Icb;
            IrpContext->Specific.Lock.Key = Key ;
            IrpContext->Specific.Lock.ByKey = TRUE ;

            status = UnlockIcbLocks( IrpContext );
            break;
        }

    } finally {
        if ( AbnormalTermination() || !NT_SUCCESS( status ) ) {
            if ( FileLock != NULL ) {
                FREE_POOL( FileLock );
            }

            NwDequeueIrpContext( IrpContext, FALSE );
        }
    }

    DebugTrace(-1, Dbg, "LockNcb -> %08lx\n", status );
    return status;
}



NTSTATUS
LockNcpCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )

/*++

Routine Description:

    This routine receives the response from a user NCP.

Arguments:


Return Value:

    VOID

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;

    DebugTrace(+1, Dbg, "LockNcpCallback...\n", 0);

    if ( BytesAvailable == 0) {

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

        FREE_POOL( IrpContext->Specific.Lock.FileLock );

        NwDequeueIrpContext( IrpContext, FALSE );
        NwCompleteRequest( IrpContext, STATUS_REMOTE_NOT_LISTENING );

        DebugTrace(-1, Dbg, "LockNcpCallback -> %08lx\n", STATUS_REMOTE_NOT_LISTENING);
        return STATUS_REMOTE_NOT_LISTENING;
    }

    Irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    Status = ParseResponse( IrpContext, Response, BytesAvailable, "N" );

    if (NT_SUCCESS(Status) ) {

        DebugTrace(0, Dbg, "Lock successfully applied\n", 0);

        //
        //  Record this lock in the Icb lock chain
        //

        AddLockToFcb(
            IrpContext->Icb->NpFcb,
            IrpContext->Specific.Lock.FileLock );

    } else if ( Status == STATUS_FILE_LOCK_CONFLICT &&
                IrpContext->Specific.Lock.Wait ) {

        DebugTrace(0, Dbg, "Lock conflict, adding %08lx to Pending Lock list\n", IrpContext );

        //
        //  The lock conflicts with an existing lock, but the app wants
        //  to wait.  Queue the request to the pending lock list and
        //  return, pending.
        //

        NwDequeueIrpContext( IrpContext, FALSE );
        IrpContext->Specific.Lock.Key = 5;

        ExInterlockedInsertTailList(
            &NwPendingLockList,
            &IrpContext->NextRequest,
            &NwPendingLockSpinLock );

        Status = STATUS_PENDING;

        DebugTrace(-1, Dbg, "LockNcpCallback -> %08lx\n", Status);
        return( Status );

    } else {

        //
        //  Status unsuccesful is returned when trying to lock 0 bytes.
        //  Map the error.
        //

        if ( Status == STATUS_UNSUCCESSFUL ) {

            DebugTrace(-1, Dbg, "Locklength -> %08lx\n",IrpContext->Specific.Lock.FileLock->Length );

            if (IrpContext->Specific.Lock.FileLock->Length == 0) {
                Status = STATUS_INVALID_PARAMETER;
            }

        }

        FREE_POOL( IrpContext->Specific.Lock.FileLock );
    }

    //
    //  If any locks were pending due to a local lock conflict, try
    //  them now.
    //

    ReattemptPendingLocks(IrpContext->Icb->NpFcb);

    //
    //  We're done with this request.  Dequeue the IRP context from
    //  SCB and complete the request.
    //

    NwDequeueIrpContext( IrpContext, FALSE );
    NwCompleteRequest( IrpContext, Status );

    DebugTrace(-1, Dbg, "LockNcpCallback -> %08lx\n", Status);
    return Status;

}


NTSTATUS
UnlockNcpCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )

/*++

Routine Description:

    This routine receives the response from a user NCP.

Arguments:


Return Value:

    VOID

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;

    DebugTrace(0, Dbg, "UnlockNcpCallback...\n", 0);

    //
    //  Remove this lock in the Fcb lock chain, regardlesss of the status
    //  of the IO.
    //

    RemoveLockFromFcb(
        IrpContext->Icb->NpFcb,
        IrpContext->Specific.Lock.FileLock );

    FREE_POOL( IrpContext->Specific.Lock.FileLock );

    //
    //  If any locks were pending due to a local lock conflict, try
    //  them now.
    //

    ReattemptPendingLocks(IrpContext->Icb->NpFcb);

    if ( BytesAvailable == 0) {

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

        NwDequeueIrpContext( IrpContext, FALSE );
        NwCompleteRequest( IrpContext, STATUS_REMOTE_NOT_LISTENING );

        return STATUS_REMOTE_NOT_LISTENING;
    }

    Irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    Status = ParseResponse( IrpContext, Response, BytesAvailable, "N" );

    if (!NT_SUCCESS( Status )) {
        Error(
            EVENT_NWRDR_FAILED_UNLOCK,
            Status,
            NULL,
            0,
            1,
            IrpContext->pNpScb->ServerName.Buffer );
    }

    //
    //  We're done with this request.  Dequeue the IRP context from
    //  SCB and complete the request.
    //

    NwDequeueIrpContext( IrpContext, FALSE );
    NwCompleteRequest( IrpContext, Status );

    return STATUS_SUCCESS;

}

BOOLEAN
LockIsOverlapping(
    PNONPAGED_FCB pNpFcb,
    LONG StartFileOffset,
    ULONG Length
    )
/*++

Routine Description:

    This routine tests to see if the requested lock would overlap an
    existing lock.

    *** This routine must be called at the front of the queue.

Arguments:

    pNpFcb - The FCB of the file being locked.

    StartFileOffset - The first byte in the range to lock.

    Length - The number of bytes to lock.

Return Value:

    TRUE - This lock overlaps an existing lock.
    FALSE - This lock does not overlap an existing lock.

--*/
{
    PLIST_ENTRY ListEntry;
    PNW_FILE_LOCK pFileLock;
    LONG EndFileOffset = StartFileOffset + Length - 1;

    if ( Length == 0 ) {
        return( FALSE );
    }

    for ( ListEntry = pNpFcb->FileLockList.Flink;
          ListEntry != &pNpFcb->FileLockList;
          ListEntry = ListEntry->Flink ) {

        pFileLock = CONTAINING_RECORD( ListEntry, NW_FILE_LOCK, ListEntry );

        //
        //  Stop the search if the current lock starts before the potential
        //  new lock ends.
        //

        if ( pFileLock->StartFileOffset > EndFileOffset ) {
            break;
        }

        //
        //  The new lock overlaps if it starts of ends in the middle of
        //  an existing lock.
        //

        if (( StartFileOffset >= pFileLock->StartFileOffset &&
              StartFileOffset <= pFileLock->EndFileOffset )
                          ||
            ( EndFileOffset >= pFileLock->StartFileOffset &&
              EndFileOffset <= pFileLock->EndFileOffset ) ) {


            DebugTrace(0, Dbg, "Lock is overlapping\n", 0);
            return( TRUE );
        }
    }

    DebugTrace(0, Dbg, "Lock is NOT overlapping\n", 0);
    return( FALSE );
}

VOID
AddLockToFcb(
    PNONPAGED_FCB pNpFcb,
    PNW_FILE_LOCK FileLock
    )
/*++

Routine Description:

    This routine inserts a lock structure into the ordered list of locks
    for this ICB.

    *** This routine must be called when at the front of the ScbQueue.

Arguments:

    NpFcb - The non paged FCB of file that is being locked.

    FileLock - The file lock structure to insert.

Return Value:

     None.

--*/
{
    PLIST_ENTRY ListEntry;
    PNW_FILE_LOCK pFileLock;

    LONG StartFileOffset = FileLock->StartFileOffset;
    LONG EndFileOffset = FileLock->EndFileOffset;

    DebugTrace(0, Dbg, "Adding Lock to FCB %08lx\n", pNpFcb);
    DebugTrace(0, Dbg, "Lock is %08lx\n", FileLock );

    if ( IsListEmpty( &pNpFcb->FileLockList ) ) {
        InsertHeadList( &pNpFcb->FileLockList, &FileLock->ListEntry );
        return;
    }

    for ( ListEntry = pNpFcb->FileLockList.Flink;
          ListEntry != &pNpFcb->FileLockList;
          ListEntry = ListEntry->Flink ) {

        pFileLock = CONTAINING_RECORD( ListEntry, NW_FILE_LOCK, ListEntry );

        //
        //  Stop the search if the current lock starts after the
        //  new lock ends.
        //

        if ( pFileLock->StartFileOffset > EndFileOffset ) {
            break;
        }

    }

    //
    //  Insert the file lock into the ordered list.
    //

    InsertTailList( ListEntry, &FileLock->ListEntry );
}


VOID
RemoveLockFromFcb(
    PNONPAGED_FCB pNpFcb,
    PNW_FILE_LOCK FileLock
    )
/*++

Routine Description:

    This routine removes a lock structure from the ordered list of locks
    for this FCB.

    *** This routine must be called when at the front of the ScbQueue.

Arguments:

    pNpFcb - The non paged FCB of file that is being unlocked.

    FileLock - The file lock structure to remove.

Return Value:

     None.

--*/
{
#if DBG
    PNW_FILE_LOCK foundFileLock;
#endif

    DebugTrace(0, Dbg, "Removing Lock from FCB %08lx\n", pNpFcb);
    DebugTrace(0, Dbg, "Lock is %08lx\n", FileLock );

    ASSERT( LockExists( pNpFcb, FileLock->StartFileOffset, FileLock->Length, &foundFileLock ) );
    ASSERT( foundFileLock == FileLock );

    RemoveEntryList( &FileLock->ListEntry );
    return;
}


VOID
ReattemptPendingLocks(
    PNONPAGED_FCB pNpFcb
    )
/*++

Routine Description:

    This routine reattempts locks that are pending due to a local lock
    conflict.

    *** This routine must be called when at the front of the ScbQueue.

Arguments:

    pNpFcb - The non paged FCB of file that is being processed.

Return Value:

     None.

--*/
{
        PLIST_ENTRY listEntry, nextListEntry;
    PNW_FILE_LOCK fileLock;
    NTSTATUS status;

    DebugTrace(+1, Dbg, "ReattemptPendingLocks...\n", 0);

    //
    //  Run the list of pending locks.
    //

    for ( listEntry = pNpFcb->PendingLockList.Flink;
          listEntry != &pNpFcb->PendingLockList;
          listEntry = nextListEntry ) {

        nextListEntry = listEntry->Flink;

        fileLock = CONTAINING_RECORD( listEntry, NW_FILE_LOCK, ListEntry );

        if ( !LockIsOverlapping( pNpFcb, fileLock->StartFileOffset, fileLock->Length ) ) {

            //
            //  It is now safe to try this lock.
            //

            RemoveEntryList( listEntry );

            DebugTrace(0, Dbg, "Reattempt lock %08lx\n", fileLock->IrpContext);

            status = Exchange (
                        fileLock->IrpContext,
                        LockNcpCallback,
                        "Fbrddw",
                        NCP_LOCK_RANGE,
                        fileLock->Flags | 0x01,
                        fileLock->Icb->Handle, sizeof( fileLock->Icb->Handle ),
                        fileLock->StartFileOffset,
                        fileLock->Length,
                        LockTimeoutThreshold );

            if ( !NT_SUCCESS( status ) ) {

                NwDequeueIrpContext( fileLock->IrpContext, FALSE );
                NwCompleteRequest( fileLock->IrpContext, status );

                FREE_POOL( fileLock );

            } else if ( status == STATUS_PENDING ) {
                DebugTrace(-1, Dbg, "ReattemptPendingLocks\n", 0);
                return;
            }
        }

    }

    DebugTrace(-1, Dbg, "ReattemptPendingLocks\n", 0);
    return;
}


BOOLEAN
LockExists(
    PNONPAGED_FCB pNpFcb,
    LONG StartOffset,
    ULONG Length,
    PNW_FILE_LOCK *FileLock
    )
/*++

Routine Description:

    This routine test whether or not a lock is owned for this ICB.

    *** This routine must be called when at the front of the ScbQueue.

Arguments:

    pNpFcb - The non paged FCB of file that is being locked.

    StartOffset - The starting file offset of the lock.

    Length - The number of bytes to lock.

    FileLock - Returns a pointer to the FileLock structure if it was found.

Return Value:

    TRUE - This lock is being held for this ICB.
    FALSE - This lock is NOT being held for this ICB.

--*/
{
    PLIST_ENTRY ListEntry;
    PNW_FILE_LOCK pFileLock;
    LONG EndOffset = StartOffset + Length - 1;

    for ( ListEntry = pNpFcb->FileLockList.Flink;
          ListEntry != &pNpFcb->FileLockList;
          ListEntry = ListEntry->Flink ) {

        pFileLock = CONTAINING_RECORD( ListEntry, NW_FILE_LOCK, ListEntry );

        //
        //  Search for the lock that exactly matches this one.
        //

        if ( pFileLock->StartFileOffset == StartOffset &&
             pFileLock->EndFileOffset == EndOffset ) {

            *FileLock = pFileLock;
            DebugTrace(0, Dbg, "Found lock\n", 0);
            return( TRUE );
        }

    }

    *FileLock = NULL;

    DebugTrace(0, Dbg, "Could not find lock\n", 0);
    return( FALSE );
}

NTSTATUS
UnlockIcbLocks(
    PIRP_CONTEXT pIrpContext
    )
/*++

Routine Description:

    This routine unlocks the first lock for an ICB.

    *** This routine must be called when at the front of the ScbQueue.

Arguments:

    IrpContext - A pointer to the IRP context pointers for this request.

Return Value:

     None.

--*/
{
    PICB pIcb;
    PNW_FILE_LOCK pFileLock;
    PLIST_ENTRY pLockEntry;
    NTSTATUS Status;
    PNONPAGED_FCB pNpFcb;
    PVOID pLockProc;

    DebugTrace(+1, Dbg, "UnlockIcbLocks...\n", 0);

    pIcb = pIrpContext->Icb;
    pNpFcb = pIcb->NpFcb;

    pLockEntry = &pNpFcb->FileLockList;
    pLockProc = PsGetCurrentProcessId();

    DebugTrace(0, Dbg, "UnlockIcbLocks: current process is %08lx.\n", pLockProc);

    while ( pLockEntry->Flink != &pNpFcb->FileLockList ) {

        pFileLock = CONTAINING_RECORD( pLockEntry->Flink, NW_FILE_LOCK, ListEntry );
  
        //
        // If this lock isn't for this process, skip it.
        //

        if ( pFileLock->pOwnerProc != pLockProc ) {

            DebugTrace(0, Dbg, "Skipping lock %08lx, not for this process.\n", pLockEntry);
            pLockEntry = pLockEntry->Flink;
            continue;
        }

        //
        // If we're unlocking by key and the key doesn't match, skip it.
        //

        if ( ( pIrpContext->Specific.Lock.ByKey ) &&
             ( pFileLock->Key != pIrpContext->Specific.Lock.Key ) ) {

            DebugTrace(0, Dbg, "Skipping lock %08lx, bad key.\n", pLockEntry);
            pLockEntry = pLockEntry->Flink;
            continue;
        }

        //
        // Otherwise, Do our best to free the lock.
        //

        DebugTrace(0, Dbg, "Freeing lock %08lx.\n", pLockEntry);
        RemoveEntryList( &pFileLock->ListEntry );

        Status = ExchangeWithWait (
                 pIrpContext,
                 SynchronousResponseCallback,
                 "F-rddw",
                 NCP_UNLOCK_RANGE,
                 pIcb->Handle, sizeof( pIcb->Handle ),
                 pFileLock->StartFileOffset,
                 pFileLock->Length,
                 1 );

        FREE_POOL( pFileLock );
        pLockEntry = pLockEntry->Flink;

    }

    //
    // We are finished.
    //
    
    DebugTrace(-1, Dbg, "UnlockIcbLocks -> %08lx\n", 0);
    NwDequeueIrpContext( pIrpContext, FALSE );
    return STATUS_SUCCESS;

}


VOID
NwFreeLocksForIcb(
    IN PIRP_CONTEXT pIrpContext,
    PICB Icb
    )

/*++

Routine Description:

    This routine unlocks all locks held for a specific ICB.

    Because its only called from Cleanup prior to a close we can
    simply free the internal structures. The server will clear the
    locks on the handle when it gets the close.

Arguments:

    ICB - The ICB to free the locks for.

Return Value:

    VOID

--*/

{
    PLIST_ENTRY listEntry, nextListEntry;
    PNW_FILE_LOCK pFileLock;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFreeLockForIcb...\n", 0);

    NwAppendToQueueAndWait( pIrpContext );

    for ( listEntry = Icb->NpFcb->FileLockList.Flink;
          listEntry != &Icb->NpFcb->FileLockList;
          listEntry = nextListEntry ) {

        nextListEntry = listEntry->Flink;

        pFileLock = CONTAINING_RECORD(
                        listEntry,
                        NW_FILE_LOCK,
                        ListEntry );

        if ( pFileLock->Icb == Icb ) {

            RemoveEntryList( listEntry );
            FREE_POOL( pFileLock );

            DebugTrace( 0, Dbg, "Freed lock %08lx\n", pFileLock );
        }

    }

    ReattemptPendingLocks( Icb->NpFcb );

    DebugTrace(-1, Dbg, "NwFreeLockForIcb -> VOID\n", 0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\lockcode.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    lockcode.c

Abstract:

Author:

    Chuck Lenzmeier (chuckl) 30-Jan-1994
    Manny Weiser (mannyw)    17-May-1994

Revision History:

--*/

#include "Procs.h"


#ifndef QFE_BUILD

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwReferenceUnlockableCodeSection )
#pragma alloc_text( PAGE, NwDereferenceUnlockableCodeSection )
#endif

extern BOOLEAN TimerStop;   //  From Timer.c

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)


VOID
NwReferenceUnlockableCodeSection (
    VOID
    )
{
    ULONG oldCount;

    //
    // Lock the lockable code database.
    //

    ExAcquireResourceExclusiveLite( &NwUnlockableCodeResource, TRUE );

    //
    // Increment the reference count for the section.
    //

    oldCount = NwSectionDescriptor.ReferenceCount++;

    if ( oldCount == 0 && NwSectionDescriptor.Handle == NULL ) {

        //
        // This is the first reference to the section.  Start the timer.
        // Lock our code.
        //

        NwSectionDescriptor.Handle = MmLockPagableCodeSection( NwSectionDescriptor.Base );
        StartTimer( );

    } else {

        //
        // This is not the first reference to the section.  The section
        // had better be locked!
        //

        ASSERT( NwSectionDescriptor.Handle != NULL );

        //
        //  Restart the timer if the rdr was stopped but didn't unload.
        //

        if (TimerStop == TRUE) {
            StartTimer();
        }

    }

    DebugTrace(+0, Dbg, "NwReferenceCodeSection %d\n", NwSectionDescriptor.ReferenceCount );

    ExReleaseResourceLite( &NwUnlockableCodeResource );

    return;

} // NwReferenceUnlockableCodeSection


VOID
NwDereferenceUnlockableCodeSection (
    VOID
    )
{
    ULONG newCount;

    //
    // Lock the lockable code database.
    //

    ExAcquireResourceExclusiveLite( &NwUnlockableCodeResource, TRUE );

    ASSERT( NwSectionDescriptor.Handle != NULL );
    ASSERT( NwSectionDescriptor.ReferenceCount > 0 &&
            NwSectionDescriptor.ReferenceCount < 0x7FFF );

    //
    // Decrement the reference count for the section.
    //

    newCount = --NwSectionDescriptor.ReferenceCount;

    DebugTrace(+0, Dbg, "NwDereferenceCodeSection %d\n", NwSectionDescriptor.ReferenceCount );

    ExReleaseResourceLite( &NwUnlockableCodeResource );

    return;

} // NwDereferenceUnlockableCodeSection

BOOLEAN
NwUnlockCodeSections(
    IN BOOLEAN BlockIndefinitely
    )
{
    //
    // Lock the lockable code database.
    //

    if (!ExAcquireResourceExclusiveLite( &NwUnlockableCodeResource, BlockIndefinitely )) {
        return FALSE;   //  Avoid potential deadlock in timer.c
    }

    DebugTrace(+0, Dbg, "NwUnlockCodeSections %d\n", NwSectionDescriptor.ReferenceCount );

    if ( NwSectionDescriptor.ReferenceCount == 0 ) {

        if ( NwSectionDescriptor.Handle != NULL ) {

            //
            // This is the last reference to the section.  Stop the timer and
            // unlock the code.
            //

            StopTimer();

            MmUnlockPagableImageSection( NwSectionDescriptor.Handle );
            NwSectionDescriptor.Handle = NULL;

        }

        ExReleaseResourceLite( &NwUnlockableCodeResource );
        return TRUE;
    }

    ExReleaseResourceLite( &NwUnlockableCodeResource );
    return FALSE;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\ndsfsctl.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsFsctl.c

Abstract:

    This implements the NDS user mode hooks to the redirector.

Author:

    Cory West    [CoryWest]    23-Feb-1995

--*/

#include "Procs.h"

#define Dbg (DEBUG_TRACE_NDS)

#pragma alloc_text( PAGE, DispatchNds )
#pragma alloc_text( PAGE, PrepareLockedBufferFromFsd )
#pragma alloc_text( PAGE, DoBrowseFsctl )
#pragma alloc_text( PAGE, NdsRawFragex )
#pragma alloc_text( PAGE, NdsResolveName )
#pragma alloc_text( PAGE, NdsGetObjectInfo )
#pragma alloc_text( PAGE, NdsListSubordinates )
#pragma alloc_text( PAGE, NdsReadAttributes )
#pragma alloc_text( PAGE, NdsGetVolumeInformation )
#pragma alloc_text( PAGE, NdsOpenStream )
#pragma alloc_text( PAGE, NdsSetContext )
#pragma alloc_text( PAGE, NdsGetContext )
#pragma alloc_text( PAGE, NdsVerifyTreeHandle )
#pragma alloc_text( PAGE, NdsGetPrintQueueInfo )
#pragma alloc_text( PAGE, NdsChangePass )
#pragma alloc_text( PAGE, NdsListTrees )

//
// The main handler for all NDS FSCTL calls.
//

NTSTATUS
DispatchNds(
    ULONG IoctlCode,
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine instigates an NDS transaction requested from
    the fsctl interface.

Arguments:

    IoctlCode - Supplies the code to be used for the NDS transaction.
    IrpContext - A pointer to IRP context information for this request.

Return Value:

    Status of transaction.

--*/
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    LARGE_INTEGER Uid;

    PAGED_CODE();

    //
    // Always set the user uid in the irp context so that
    // referral creates NEVER go astray.
    //

    SeCaptureSubjectContext(&SubjectContext);
    Uid = GetUid( &SubjectContext );
    SeReleaseSubjectContext(&SubjectContext);

    IrpContext->Specific.Create.UserUid.QuadPart = Uid.QuadPart;

    switch ( IoctlCode ) {

        //
        // These calls do not require us to lock down
        // the user's buffer, but they do generate wire
        // traffic.
        //

        case FSCTL_NWR_NDS_SETCONTEXT:
            DebugTrace( 0, Dbg, "DispatchNds: Set Context\n", 0 );
            return DoBrowseFsctl( IrpContext, IoctlCode, FALSE );

        case FSCTL_NWR_NDS_GETCONTEXT:
            DebugTrace( 0, Dbg, "DispatchNds: Get Context\n", 0 );
            return DoBrowseFsctl( IrpContext, IoctlCode, FALSE );

        case FSCTL_NWR_NDS_OPEN_STREAM:
            DebugTrace( 0, Dbg, "DispatchNds: Open Stream\n", 0 );
            return DoBrowseFsctl( IrpContext, IoctlCode, FALSE );

        case FSCTL_NWR_NDS_VERIFY_TREE:
            DebugTrace( 0, Dbg, "DispatchNds: Verify Tree\n", 0 );
            return DoBrowseFsctl( IrpContext, IoctlCode, FALSE );

        case FSCTL_NWR_NDS_GET_QUEUE_INFO:
            DebugTrace( 0, Dbg, "DispatchNds: Get Queue Info\n", 0 );
            return DoBrowseFsctl( IrpContext, IoctlCode, FALSE );

        case FSCTL_NWR_NDS_GET_VOLUME_INFO:
            DebugTrace( 0, Dbg, "DispatchNds: Get Volume Info\n", 0 );
            return DoBrowseFsctl( IrpContext, IoctlCode, FALSE );

        //
        // These four fsctl calls are the basis of browsing.  They
        // all require a request packet and a user buffer that we
        // lock down.
        //

        case FSCTL_NWR_NDS_RESOLVE_NAME:
            DebugTrace( 0, Dbg, "DispatchNds: Resolve Name\n", 0 );
            return DoBrowseFsctl( IrpContext, IoctlCode, TRUE );

        case FSCTL_NWR_NDS_LIST_SUBS:
            DebugTrace( 0, Dbg, "DispatchNds: List Subordinates\n", 0 );
            return DoBrowseFsctl( IrpContext, IoctlCode, TRUE );

        case FSCTL_NWR_NDS_READ_INFO:
            DebugTrace( 0, Dbg, "DispatchNds: Read Object Info\n", 0 );
            return DoBrowseFsctl( IrpContext, IoctlCode, TRUE );

        case FSCTL_NWR_NDS_READ_ATTR:
            DebugTrace( 0, Dbg, "DispatchNds: Read Attribute\n", 0 );
            return DoBrowseFsctl( IrpContext, IoctlCode, TRUE );

        //
        // Support for user mode fragment exchange.
        //

        case FSCTL_NWR_NDS_RAW_FRAGEX:
            DebugTrace( 0, Dbg, "DispatchNds: Raw Fragex\n", 0 );
            return NdsRawFragex( IrpContext );

        //
        // Change an NDS password.
        //

        case FSCTL_NWR_NDS_CHANGE_PASS:
            DebugTrace( 0, Dbg, "DispatchNds: Change Password\n", 0 );
            return NdsChangePass( IrpContext );

        //
        // Special fsctl to list the trees that a particular nt user
        // has credentials to since the change pass ui runs under the
        // system luid.  Sigh.
        //

        case FSCTL_NWR_NDS_LIST_TREES:
            DebugTrace( 0, Dbg, "DispatchNds: List trees\n", 0 );
            return NdsListTrees( IrpContext );

        default:

            DebugTrace( 0, Dbg, "DispatchNds: No Such IOCTL\n", 0 );
            break;

    }

    DebugTrace( 0, Dbg, "     -> %08lx\n", Status );
    return Status;

}

NTSTATUS
PrepareLockedBufferFromFsd(
    PIRP_CONTEXT pIrpContext,
    PLOCKED_BUFFER pLockedBuffer
)
/*

Description:

    This routine takes the irp context for an FSD request with
    a user mode buffer, and locks down the buffer so that it may
    be sent to the transport.  The locked down buffer, in addition
    to being described in the irp and irp context, is described
    in the LOCKED_BUFFER structure.

Arguments:

    pIrpContext - irp context for this request
    pLockedBuffer - the locked response buffer

*/
{

    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    PVOID OutputBuffer;
    ULONG OutputBufferLength;

    PAGED_CODE();

    //
    // Get the irp and input buffer information and lock the
    // buffer to the irp.
    //

    irp = pIrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    OutputBufferLength = irpSp->Parameters.FileSystemControl.OutputBufferLength;

    if ( !OutputBufferLength ) {

        DebugTrace( 0, Dbg, "No fsd buffer length in PrepareLockedBufferFromFsd...\n", 0 );
        return STATUS_BUFFER_TOO_SMALL;

    }

    try {
        NwLockUserBuffer( irp, IoWriteAccess, OutputBufferLength );
        NwMapUserBuffer( irp, irp->RequestorMode, (PVOID *)&OutputBuffer );
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    if ( !OutputBuffer ) {

        DebugTrace( 0, Dbg, "No fsd buffer in PrepareLockedBufferFromFsd...\n", 0 );
        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    //  Update the original MDL record in the Irp context, since
    //  NwLockUserBuffer may have created a new MDL.
    //

    pIrpContext->pOriginalMdlAddress = irp->MdlAddress;

    //
    // Fill in our locked buffer description.
    //

    pLockedBuffer->pRecvBufferVa = MmGetMdlVirtualAddress( irp->MdlAddress );
    pLockedBuffer->dwRecvLen = MdlLength( irp->MdlAddress );
    pLockedBuffer->pRecvMdl = irp->MdlAddress;

    // DebugTrace( 0, Dbg, "Locked fsd buffer at %08lx\n", pLockedBuffer->pRecvBufferVa );
    // DebugTrace( 0, Dbg, "     len -> %d\n", pLockedBuffer->dwRecvLen );
    // DebugTrace( 0, Dbg, "     recv mdl at %08lx\n", pLockedBuffer->pRecvMdl );

    return STATUS_SUCCESS;

}

NTSTATUS
DoBrowseFsctl( PIRP_CONTEXT pIrpContext,
               ULONG IoctlCode,
               BOOL LockdownBuffer
)
/*+++

Description:

    This actually sets up for an NDS operation that requires wire
    traffic, including locking down the user buffer if necessary.

Arguments:

    pIrpContext - the irp context for this request
    IoctlCode - the ioctl requested
    LockdownBuffer - do we need to lock down the user buffer

---*/
{

    NTSTATUS Status;

    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    PNWR_NDS_REQUEST_PACKET InputBuffer;
    ULONG InputBufferLength;

    PVOID fsContext, fsObject;
    NODE_TYPE_CODE nodeTypeCode;
    PSCB pScb = NULL;
    PICB pIcb = NULL;

    LOCKED_BUFFER LockedBuffer;
    PNDS_SECURITY_CONTEXT pCredential;
    UNICODE_STRING CredentialName;

    PAGED_CODE();

    //
    // Get the request packet in the input buffer.
    //

    irp = pIrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    InputBuffer = (PNWR_NDS_REQUEST_PACKET) irpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = irpSp->Parameters.FileSystemControl.InputBufferLength;

    if ( !InputBuffer ||
         !InputBufferLength ) {

        DebugTrace( 0, Dbg, "BrowseFsctl has no input buffer...\n", 0 );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // tommye - MS bug 32134 (MCS 265)
    //
    // Probe the input arguments to make sure they are kosher before
    // touching them.
    //

    try {

        if ( irp->RequestorMode != KernelMode ) {
    
            ProbeForRead( InputBuffer,
                          InputBufferLength,
                          sizeof(CHAR));


            //
            // tommye 
            //
            // If the output buffer came from user space, then probe it for write.
            //

            if ((irpSp->Parameters.FileSystemControl.FsControlCode & 3) == METHOD_NEITHER) {
                ULONG OutputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

                ProbeForWrite( irp->UserBuffer,
                               OutputBufferLength,
                               sizeof(CHAR)
                              );
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
          return GetExceptionCode();
    }

    //
    // Decode the file object and point the irp context the
    // the appropriate connection...  Should this be in an
    // exception frame?
    //

    nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                       &fsContext,
                                       &fsObject );

    if ( nodeTypeCode == NW_NTC_ICB_SCB ) {

        pIcb = (PICB) fsObject;
        pScb = (pIcb->SuperType).Scb;

        pIrpContext->pScb = pScb;
        pIrpContext->pNpScb = pIrpContext->pScb->pNpScb;
        pIrpContext->Icb = pIcb;

        //
        // If this is a handle made on an ex-create, then
        // we have to be aware of our credentials while
        // jumping servers.
        //
        // This is not too intuitive since this doesn't
        // seem to be a create path irp, but referrals
        // on any path cause the create paths to be
        // traversed.
        //

        if ( pIcb->IsExCredentialHandle ) {

            pIrpContext->Specific.Create.fExCredentialCreate = TRUE;

            pCredential = (PNDS_SECURITY_CONTEXT) pIcb->pContext;

            Status = GetCredentialFromServerName( &pCredential->NdsTreeName,
                                                  &CredentialName );
            if ( !NT_SUCCESS( Status ) ) {
                return STATUS_INVALID_HANDLE;
            }

            pIrpContext->Specific.Create.puCredentialName = &CredentialName;
        }

    }

    //
    // Lock the users buffer if this destined for the transport.
    //

    if ( LockdownBuffer &&
         nodeTypeCode == NW_NTC_ICB_SCB ) {

        Status = PrepareLockedBufferFromFsd( pIrpContext, &LockedBuffer );

        if ( !NT_SUCCESS( Status ) ) {
            return Status;
        }

        //
        // Call the appropriate browser.
        //

        switch ( IoctlCode ) {

            case FSCTL_NWR_NDS_RESOLVE_NAME:

                return NdsResolveName( pIrpContext, InputBuffer, InputBufferLength, &LockedBuffer );

            case FSCTL_NWR_NDS_LIST_SUBS:

                return NdsListSubordinates( pIrpContext, InputBuffer, &LockedBuffer );

            case FSCTL_NWR_NDS_READ_INFO:

                return NdsGetObjectInfo( pIrpContext, InputBuffer, &LockedBuffer );

            case FSCTL_NWR_NDS_READ_ATTR:

                return NdsReadAttributes( pIrpContext, InputBuffer, InputBufferLength, &LockedBuffer );

            default:

                DebugTrace( 0, Dbg, "Invalid ioctl for locked BrowseFsctl...\n", 0 );
                return STATUS_NOT_SUPPORTED;

        }

    }

    //
    // There's no user reply buffer for these calls, hence there's no lockdown.
    //

    switch ( IoctlCode ) {

        case FSCTL_NWR_NDS_OPEN_STREAM:

            //
            // There has to be an ICB for this!
            //

            if ( nodeTypeCode != NW_NTC_ICB_SCB ) {
                return STATUS_INVALID_HANDLE;
            }

            return NdsOpenStream( pIrpContext, InputBuffer, InputBufferLength );

        case FSCTL_NWR_NDS_SETCONTEXT:

            return NdsSetContext( pIrpContext, InputBuffer, InputBufferLength );

        case FSCTL_NWR_NDS_GETCONTEXT:

            return NdsGetContext( pIrpContext, InputBuffer, InputBufferLength );

        case FSCTL_NWR_NDS_VERIFY_TREE:

            //
            // Verify that this handle is valid for the specified tree.
            //

            return NdsVerifyTreeHandle( pIrpContext, InputBuffer, InputBufferLength );

        case FSCTL_NWR_NDS_GET_QUEUE_INFO:

            //
            // Get the queue info for this print queue.
            //

            return NdsGetPrintQueueInfo( pIrpContext, InputBuffer, InputBufferLength );

        case FSCTL_NWR_NDS_GET_VOLUME_INFO:

            //
            // Get the volume info for this volume object.
            // For the new shell property sheets.
            //

            return NdsGetVolumeInformation( pIrpContext, InputBuffer, InputBufferLength );

        }

    //
    // All others are not supported.
    //

    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
NdsRawFragex(
    PIRP_CONTEXT pIrpContext
)
/*+++

    Send a raw user requested fragment.

---*/
{

    NTSTATUS Status;

    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NODE_TYPE_CODE nodeTypeCode;
    PVOID fsContext, fsObject;
    PSCB pScb = NULL;
    PICB pIcb = NULL;

    DWORD NdsVerb;
    LOCKED_BUFFER NdsRequest;

    PNWR_NDS_REQUEST_PACKET Rrp;
    PBYTE RawRequest;
    DWORD RawRequestLen;
    PNDS_SECURITY_CONTEXT pCredential;
    UNICODE_STRING CredentialName;

    PAGED_CODE();

    //
    // Get the request.
    //

    irp = pIrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    Rrp = ( PNWR_NDS_REQUEST_PACKET ) irpSp->Parameters.FileSystemControl.Type3InputBuffer;
    RawRequestLen = irpSp->Parameters.FileSystemControl.InputBufferLength;

    if ( !Rrp || ( RawRequestLen < sizeof( NWR_NDS_REQUEST_PACKET ) ) ) {

        DebugTrace( 0, Dbg, "No raw request buffer.\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Decode the file object and point the irp context
    // to the appropriate connection.
    //

    nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                       &fsContext,
                                       &fsObject );

    if ( nodeTypeCode != NW_NTC_ICB_SCB ) {

        DebugTrace( 0, Dbg, "A raw fragment request requires a server handle.\n", 0 );
        return STATUS_INVALID_HANDLE;
    }

    pIcb = (PICB) fsObject;
    pScb = (pIcb->SuperType).Scb;

    pIrpContext->pScb = pScb;
    pIrpContext->pNpScb = pIrpContext->pScb->pNpScb;
    pIrpContext->Icb = pIcb;

    //
    // If this is a handle made on an ex-create, then
    // we have to be aware of our credentials while
    // jumping servers.
    //
    // This is not too intuitive since this doesn't
    // seem to be a create path irp, but referrals
    // on any path cause the create paths to be
    // traversed.
    //

    if ( pIcb->IsExCredentialHandle ) {

        pIrpContext->Specific.Create.fExCredentialCreate = TRUE;

        pCredential = (PNDS_SECURITY_CONTEXT) pIcb->pContext;

        Status = GetCredentialFromServerName( &pCredential->NdsTreeName,
                                              &CredentialName );
        if ( !NT_SUCCESS( Status ) ) {
            return STATUS_INVALID_HANDLE;
        }

        pIrpContext->Specific.Create.puCredentialName = &CredentialName;
    }

    //
    // Dig out the parameters.
    //

    NdsVerb = Rrp->Parameters.RawRequest.NdsVerb;
    RawRequestLen = Rrp->Parameters.RawRequest.RequestLength;
    RawRequest = &Rrp->Parameters.RawRequest.Request[0];
    
    //
    // Get the reply buffer all locked in for the fragex.
    //

    Status = PrepareLockedBufferFromFsd( pIrpContext, &NdsRequest );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    try {

        if ( RawRequestLen ) {

            Status = FragExWithWait( pIrpContext,
                                     NdsVerb,
                                     &NdsRequest,
                                     "r",
                                     RawRequest,
                                     RawRequestLen );
        } else {

            Status = FragExWithWait( pIrpContext,
                                     NdsVerb,
                                     &NdsRequest,
                                     NULL );
        }

        if ( NT_SUCCESS( Status ) ) {
           Rrp->Parameters.RawRequest.ReplyLength = NdsRequest.dwBytesWritten;
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();
    }

    return Status;

}

NTSTATUS
NdsResolveName(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength,
    PLOCKED_BUFFER pLockedBuffer
)
/*+++

Description:

    This function decodes the resolve name request and makes the
    actual wire request.

Parameters:

    pIrpContext   - describes the irp for this request
    pLockedBuffer - describes the locked, user mode buffer that we will
                    write the response into
    pNdsRequest   - the request parameters

Return Value:

    The status of the exchange.

---*/
{
    NTSTATUS Status;
    UNICODE_STRING uObjectName;
    DWORD dwResolverFlags;
    DWORD NeededLength;
    WCHAR ObjectName[MAX_NDS_NAME_CHARS];

    PNDS_WIRE_RESPONSE_RESOLVE_NAME pWireResponse;
    PNDS_WIRE_RESPONSE_RESOLVE_NAME_REFERRAL pReferral;
    PNDS_RESPONSE_RESOLVE_NAME pUserResponse;
    IPXaddress *ReferredAddress;
    PSCB Scb, OldScb;

    PAGED_CODE();

    //
    // Fill in the resolver flags and the unicode string for the
    // object name from the request packet.
    //


    try {

        if (RequestLength < (FIELD_OFFSET(NWR_NDS_REQUEST_PACKET, Parameters.ResolveName.ObjectName) + pNdsRequest->Parameters.ResolveName.ObjectNameLength)) {
            DebugTrace( 0, Dbg, "ResolveName Request Length is too short.\n", 0 );
            return STATUS_INVALID_PARAMETER;
        }

        uObjectName.Length = (USHORT)(pNdsRequest->Parameters).ResolveName.ObjectNameLength;
        uObjectName.MaximumLength = sizeof( ObjectName );

        if ( uObjectName.Length > sizeof( ObjectName ) ) {
            ExRaiseStatus( STATUS_INVALID_BUFFER_SIZE );
        }

        RtlCopyMemory( ObjectName,
                       (pNdsRequest->Parameters).ResolveName.ObjectName,
                       uObjectName.Length );

        uObjectName.Buffer = ObjectName;

        dwResolverFlags = (pNdsRequest->Parameters).ResolveName.ResolverFlags;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        DebugTrace( 0, Dbg, "Bad user mode buffer in resolving name.\n", 0 );
        return GetExceptionCode();
    }

    Status = FragExWithWait( pIrpContext,
                             NDSV_RESOLVE_NAME,
                             pLockedBuffer,
                             "DDDSDDDD",
                             0,                       // version
                             dwResolverFlags,         // flags
                             0,                       // scope
                             &uObjectName,            // distinguished name
                             1,0,                     // transport type
                             1,0 );                   // treeWalker type

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    Status = NdsCompletionCodetoNtStatus( pLockedBuffer );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    //
    // We need to convert the NDS_WIRE_RESPONSE_RESOLVE_NAME that
    // we got from the server into an NDS_RESPONSE_RESOLVE_NAME
    // for more general consumption.  Notice that a referral packet
    // has an additional DWORD in it - what a pain.
    //

    pWireResponse = (PNDS_WIRE_RESPONSE_RESOLVE_NAME) pLockedBuffer->pRecvBufferVa;
    pReferral = (PNDS_WIRE_RESPONSE_RESOLVE_NAME_REFERRAL) pLockedBuffer->pRecvBufferVa;
    pUserResponse = (PNDS_RESPONSE_RESOLVE_NAME) pLockedBuffer->pRecvBufferVa;

    try {

        if ( pWireResponse->RemoteEntry == RESOLVE_NAME_ACCEPT_REMOTE ) {

            //
            // This server can handle this request.
            //

            pUserResponse->ServerNameLength = 0;
            (pNdsRequest->Parameters).ResolveName.BytesWritten = 4 * sizeof( DWORD );

            Status = STATUS_SUCCESS;

        } else {

            //
            // tommye - MS 71699 
            // These were BUGB-G's but we made it a valid check instead. 
            // Original comment: I have seen this assertion fail because we only get
            // a valid competion code (four bytes) and no more data.  I wonder
            // if the server is sending us this incomplete packet?  If we
            // don't get a complete referal, we probably shouldn't chase it.
            //

            if ((pWireResponse->RemoteEntry != RESOLVE_NAME_REFER_REMOTE) ||
                (pReferral->ServerAddresses != 1) ||
                (pReferral->AddressType     != 0) ||
                (pReferral->AddressLength   != sizeof(IPXaddress))) {

                return ERROR_INVALID_PARAMETER;
            }

            //
            // We've been referred to another server.  We have to connect
            // to the referred server to get the name for the caller.
            //

            ReferredAddress = (IPXaddress *) pReferral->Address;

            OldScb = pIrpContext->pScb;

            //
            // Dequeue us from our original server.  Do not defer the
            // logon at this point since a referral means we're in the
            // middle of a browse operation.
            //

            NwDequeueIrpContext( pIrpContext, FALSE );

            Status = CreateScb( &Scb,
                                pIrpContext,
                                NULL,
                                ReferredAddress,
                                NULL,
                                NULL,
                                TRUE,
                                FALSE );

            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }

            //
            //  Make sure the output buffer is long enough
            //

            NeededLength = 
                ( 4 * sizeof( DWORD ) ) + Scb->pNpScb->ServerName.Length;

            if (pLockedBuffer->dwRecvLen >= NeededLength) {

                //
                //  If will fit - put the data in
                //

                RtlCopyMemory( pUserResponse->ReferredServer,
                           Scb->pNpScb->ServerName.Buffer,
                           Scb->pNpScb->ServerName.Length );

                pUserResponse->ServerNameLength = Scb->pNpScb->ServerName.Length;
                (pNdsRequest->Parameters).ResolveName.BytesWritten = NeededLength;

                Status = STATUS_SUCCESS;
            }
            else {

                //
                //  Set the return status - we still need to cleanup
                //  since the CreateScb call did succeed.
                //

                Status = STATUS_BUFFER_TOO_SMALL;
            }

            DebugTrace( 0, Dbg, "Resolve name referral to: %wZ\n",
                        &Scb->pNpScb->ServerName );

            //
            // Restore the server pointers, we're not ready to jump
            // servers yet since this might be a request from the fsd.
            //

            NwDequeueIrpContext( pIrpContext, FALSE );
            NwDereferenceScb( Scb->pNpScb );
            pIrpContext->pScb = OldScb;
            pIrpContext->pNpScb = OldScb->pNpScb;

        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        DebugTrace( 0, Dbg, "Bad user mode buffer in resolving name.\n", 0 );
        return GetExceptionCode();

    }

    return Status;
}

NTSTATUS
NdsGetObjectInfo(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    PLOCKED_BUFFER pLockedBuffer
)
/*++

Routine Description:

    Get the basic object information for the listed object.

Routine Arguments:

    pIrpContext   - describes the irp for this request
    pLockedBuffer - describes the locked, user mode buffer that we will
                    write the response into
    pNdsRequest   - the request parameters

Return Value:

    The Status of the exchange.

--*/
{
    NTSTATUS Status;
    DWORD dwObjId;

    PAGED_CODE();

    //
    // Get the object id from the users request packet.
    //

    try {
        dwObjId = (pNdsRequest->Parameters).GetObjectInfo.ObjectId;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        DebugTrace( 0, Dbg, "Bonk! Lost user mode buffer in NdsGetObjectId...\n", 0 );
        Status = GetExceptionCode();
        return Status;
    }

    //
    // Hit the wire.
    //

    Status = FragExWithWait( pIrpContext,
                             NDSV_READ_ENTRY_INFO,
                             pLockedBuffer,
                             "DD",
                             0,
                             dwObjId );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    Status = NdsCompletionCodetoNtStatus( pLockedBuffer );

    if ( NT_SUCCESS( Status ) ) {

        try {

            (pNdsRequest->Parameters).GetObjectInfo.BytesWritten = pLockedBuffer->dwBytesWritten;

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

           DebugTrace( 0, Dbg, "Bonk! Lost user mode buffer after getting object info...\n", 0 );
           Status = GetExceptionCode();
           return Status;

        }
    }

    return Status;

}

NTSTATUS
NdsListSubordinates(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    PLOCKED_BUFFER pLockedBuffer
)
/*++

Routine Description:

    List the immediate subordinates of an object.

Routine Arguments:

    pIrpContext   - describes the irp for this request
    pLockedBuffer - describes the locked, user mode buffer that we will
                    write the response into
    pNdsRequest   - the request parameters

Return Value:

    The Status of the exchange.

--*/
{
    NTSTATUS Status;
    DWORD dwParent, dwIterHandle;

    PAGED_CODE();

    //
    // Dig out the request parameters.
    //

    try {

       dwParent = (pNdsRequest->Parameters).ListSubordinates.ObjectId;
       dwIterHandle = (DWORD) (pNdsRequest->Parameters).ListSubordinates.IterHandle;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

       DebugTrace( 0, Dbg, "Bonk! No user mode buffer in ListSubordinates...\n", 0 );
       Status = GetExceptionCode();
       return Status;

    }

    //
    // Make the request.
    //

    Status = FragExWithWait( pIrpContext,
                             NDSV_LIST,
                             pLockedBuffer,
                             "DDDD",
                             0,
                             0x40,
                             dwIterHandle,
                             dwParent );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    Status = NdsCompletionCodetoNtStatus( pLockedBuffer );

    if ( NT_SUCCESS( Status ) ) {

        try {

            (pNdsRequest->Parameters).ListSubordinates.BytesWritten = pLockedBuffer->dwBytesWritten;

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            DebugTrace( 0, Dbg, "Bonk! Lost user mode buffer after getting subordinate list...\n", 0 );
            Status = GetExceptionCode();
            return Status;

        }
    }

    return Status;

}

NTSTATUS
NdsReadAttributes(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength,
    PLOCKED_BUFFER pLockedBuffer
)
/*++

Routine Description:

    Retrieve the named attribute of an object.

Routine Arguments:

    pIrpContext   - describes the irp for this request
    pLockedBuffer - describes the locked, user mode buffer that we will
                    write the response into
    pNdsRequest   - the request parameters

Return Value:

    The Status of the exchange.

--*/
{
    NTSTATUS Status;

    DWORD dwIterHandle, dwOid;
    UNICODE_STRING uAttributeName;
    WCHAR AttributeName[MAX_NDS_SCHEMA_NAME_CHARS];   // was MAX_NDS_NAME_CHARS

    PAGED_CODE();

    RtlZeroMemory( AttributeName, sizeof( AttributeName ) );

    try {

        if (RequestLength < (FIELD_OFFSET(NWR_NDS_REQUEST_PACKET, Parameters.ReadAttribute.AttributeName) + pNdsRequest->Parameters.ReadAttribute.AttributeNameLength)) {
            DebugTrace( 0, Dbg, "ReadAttributes Request Length is too short.\n", 0 );
            return STATUS_INVALID_PARAMETER;
        }

        uAttributeName.Length = (USHORT)(pNdsRequest->Parameters).ReadAttribute.AttributeNameLength;
        uAttributeName.MaximumLength = sizeof( AttributeName );

        if ( uAttributeName.Length > uAttributeName.MaximumLength ) {
            ExRaiseStatus( STATUS_INVALID_BUFFER_SIZE );
        }

        RtlCopyMemory( AttributeName,
                       (pNdsRequest->Parameters).ReadAttribute.AttributeName,
                       uAttributeName.Length );

        uAttributeName.Buffer = AttributeName;

        dwIterHandle = (DWORD) (pNdsRequest->Parameters).ReadAttribute.IterHandle;
        dwOid = (pNdsRequest->Parameters).ReadAttribute.ObjectId;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        DebugTrace( 0 , Dbg, "Bonk! Exception accessing user mode buffer in read attributes...\n", 0 );
        return GetExceptionCode();
    }

    Status = FragExWithWait( pIrpContext,
                             NDSV_READ,
                             pLockedBuffer,
                             "DDDDDDS",
                             0,                 // version
                             dwIterHandle,      // iteration handle
                             dwOid,             // object id
                             1,                 // info type
                             //
                             // The attribute specifier has been seen at zero and
                             // at 0x4e0000.  I don't know why... but zero doesn't
                             // work sometimes...
                             //
                             0x4e0000,          // attrib type
                             1,                 // number of attribs
                             &uAttributeName ); // attrib name

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    Status = NdsCompletionCodetoNtStatus( pLockedBuffer );

    if ( NT_SUCCESS( Status ) ) {

        try {

            (pNdsRequest->Parameters).ReadAttribute.BytesWritten = pLockedBuffer->dwBytesWritten;

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            DebugTrace( 0, Dbg, "Bonk! Lost user mode buffer after reading attribute...\n", 0 );
            return GetExceptionCode();

        }

    }

    return Status;

}

NTSTATUS
NdsGetVolumeInformation(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength
)
/*+++

Description:

    This function gets the name of the server that hosts
    the listed nds volume.

Parameters:

    pIrpContext   - describes the irp for this request
    pNdsRequest   - the request parameters

---*/
{


    NTSTATUS Status;

    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PSCB pOriginalScb;
    PBYTE OutputBuffer = NULL;
    ULONG OutputBufferLength;

    UNICODE_STRING VolumeObject;
    DWORD VolumeOid;
    UNICODE_STRING HostServerAttr;
    UNICODE_STRING HostVolumeAttr;
    UNICODE_STRING Attribute;

    PWCHAR ServerString;
    ULONG ServerLength;

    PAGED_CODE();

    try {
        if (RequestLength < (FIELD_OFFSET(NWR_NDS_REQUEST_PACKET, Parameters.GetVolumeInfo.VolumeName) + pNdsRequest->Parameters.GetVolumeInfo.VolumeNameLen)) {
            DebugTrace( 0, Dbg, "GetVolumeInfo Request Length is too short.\n", 0 );
            return STATUS_INVALID_PARAMETER;
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        return GetExceptionCode();
    }

    //
    // Get the irp and output buffer information.
    //

    irp = pIrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    OutputBufferLength = irpSp->Parameters.FileSystemControl.OutputBufferLength;

    if ( OutputBufferLength ) {
        NwMapUserBuffer( irp, irp->RequestorMode, (PVOID *)&OutputBuffer );

        //
        // tommye
        //
        // NwMapUserBuffer may return a NULL OutputBuffer in low resource
        // situations; this was not being checked.  
        //

        if (OutputBuffer == NULL) {
            DebugTrace(-1, DEBUG_TRACE_USERNCP, "NwMapUserBuffer returned NULL OutputBuffer", 0);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        return STATUS_BUFFER_TOO_SMALL;
    }

    try {

        //
        // Prepare the input information.
        //

        VolumeObject.Length = (USHORT)pNdsRequest->Parameters.GetVolumeInfo.VolumeNameLen;
        VolumeObject.MaximumLength = VolumeObject.Length;
        VolumeObject.Buffer = &(pNdsRequest->Parameters.GetVolumeInfo.VolumeName[0]);

            // tommye - make sure that the name length isn't bigger than we expect

        if (VolumeObject.Length > MAX_NDS_NAME_SIZE) {
            DebugTrace( 0 , Dbg, "NdsGetVolumeInformation: Volume name too long!.\n", 0 );
            return STATUS_INVALID_PARAMETER;
        }

        DebugTrace( 0, Dbg, "Retrieving volume info for %wZ\n", &VolumeObject );

        HostServerAttr.Buffer = HOST_SERVER_ATTRIBUTE;    //  L"Host Server"
        HostServerAttr.Length = sizeof( HOST_SERVER_ATTRIBUTE ) - sizeof( WCHAR );
        HostServerAttr.MaximumLength = HostServerAttr.Length;

        HostVolumeAttr.Buffer = HOST_VOLUME_ATTRIBUTE;    //  L"Host Resource Name"
        HostVolumeAttr.Length = sizeof( HOST_VOLUME_ATTRIBUTE ) - sizeof( WCHAR );
        HostVolumeAttr.MaximumLength = HostVolumeAttr.Length;


        //
        // NdsResolveNameKm may have to jump servers to service this
        // request, however it's dangerous for us to derefence the original
        // scb because that would expose a scavenger race condition.  So,
        // we add an additional ref-count to the original scb and then clean
        // up appropriately afterwards, depending on whether or not we
        // jumped servers.
        //

        pOriginalScb = pIrpContext->pScb;

        NwReferenceScb( pOriginalScb->pNpScb );

        Status = NdsResolveNameKm ( pIrpContext,
                                    &VolumeObject,
                                    &VolumeOid,
                                    TRUE,
                                    DEFAULT_RESOLVE_FLAGS );

        if ( !NT_SUCCESS( Status )) {
            NwDereferenceScb( pOriginalScb->pNpScb );
            return STATUS_BAD_NETWORK_PATH;
        }

        if ( pIrpContext->pScb == pOriginalScb ) {

            //
            // We didn't jump servers.
            //

            NwDereferenceScb( pOriginalScb->pNpScb );
        }

        //
        // We have to read the server into a temporary buffer so
        // we can strip off the x500 prefix and the context
        // from the server name.  This isn't really what I would
        // call nice, but it's the way Netware works.
        //

        Attribute.Length = 0;
        Attribute.MaximumLength = MAX_NDS_NAME_SIZE;
        Attribute.Buffer = ALLOCATE_POOL( PagedPool, MAX_NDS_NAME_SIZE );

        if (!Attribute.Buffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto CleanupScbReferences;
        }

        Status = NdsReadStringAttribute( pIrpContext,
                                         VolumeOid,
                                         &HostServerAttr,
                                         &Attribute );

        if ( !NT_SUCCESS( Status )) {
            FREE_POOL( Attribute.Buffer );
            goto CleanupScbReferences;
        }

        ServerString = Attribute.Buffer;

        while( Attribute.Length ) {

            if ( *ServerString == L'=' ) {
                ServerString += 1;
                Attribute.Length -= sizeof( WCHAR );
                break;
            }

            ServerString += 1;
            Attribute.Length -= sizeof( WCHAR );
        }

        if ( Attribute.Length == 0 ) {
            DebugTrace( 0, Dbg, "Malformed server for volume.\n", 0 );
            FREE_POOL( Attribute.Buffer );
            Status = STATUS_UNSUCCESSFUL;
            goto CleanupScbReferences;
        }

        ServerLength = 0;

        while ( ServerLength < (Attribute.Length / sizeof( WCHAR )) ) {

            if ( ServerString[ServerLength] == L'.' ) {
                break;
            }

            ServerLength++;
        }

        if ( ServerLength == ( Attribute.Length / sizeof( WCHAR ) ) ) {
            DebugTrace( 0, Dbg, "Malformed server for volume.\n", 0 );
            FREE_POOL( Attribute.Buffer );
            Status = STATUS_UNSUCCESSFUL;
            goto CleanupScbReferences;
        }

        //
        //  Make sure the ServerString will fit in the
        //  OutputBuffer.  If not then return an error
        //

        ServerLength *= sizeof( WCHAR );

        if (ServerLength > OutputBufferLength) {
            FREE_POOL( Attribute.Buffer );
            Status = STATUS_BUFFER_TOO_SMALL;
            goto CleanupScbReferences;
        }

        RtlCopyMemory( OutputBuffer, ServerString, ServerLength );

        pNdsRequest->Parameters.GetVolumeInfo.ServerNameLen = ServerLength;

        FREE_POOL( Attribute.Buffer );

        Attribute.Length = Attribute.MaximumLength = (USHORT)ServerLength;
        Attribute.Buffer = (PWCHAR)OutputBuffer;
        DebugTrace( 0, Dbg, "Host server is: %wZ\n", &Attribute );

        //
        // Now do the volume in place.  This is the easy one.
        //

        Attribute.MaximumLength = (USHORT)( OutputBufferLength - ServerLength );
        Attribute.Buffer = (PWSTR) ( OutputBuffer + ServerLength );
        Attribute.Length = 0;

        Status = NdsReadStringAttribute( pIrpContext,
                                         VolumeOid,
                                         &HostVolumeAttr,
                                         &Attribute );

        if ( !NT_SUCCESS( Status )) {
            goto CleanupScbReferences;
        }

        pNdsRequest->Parameters.GetVolumeInfo.TargetVolNameLen = Attribute.Length;
        DebugTrace( 0, Dbg, "Host volume is: %wZ\n", &Attribute );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        DebugTrace( 0, Dbg, "Exception handling user mode buffer in GetVolumeInfo.\n", 0 );
        goto CleanupScbReferences;

    }

    Status = STATUS_SUCCESS;

CleanupScbReferences:

    if ( pIrpContext->pScb != pOriginalScb ) {

        //
        // We jumped servers and have to cleanup.
        //

        NwDequeueIrpContext( pIrpContext, FALSE );
        NwDereferenceScb( pIrpContext->pScb->pNpScb );
        pIrpContext->pScb = pOriginalScb;
        pIrpContext->pNpScb = pOriginalScb->pNpScb;

    }

    return Status;
}

NTSTATUS
NdsOpenStream(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength
) {

    NTSTATUS Status;

    UNICODE_STRING uStream;
    WCHAR StreamName[MAX_NDS_NAME_CHARS];

    LOCKED_BUFFER NdsRequest;

    DWORD dwOid, StreamAccess;
    DWORD hNwHandle, dwFileLen;

    PICB pIcb;
    PSCB pScb = pIrpContext->pNpScb->pScb;

    BOOLEAN LicensedConnection = FALSE;

    PAGED_CODE();

    pIcb = pIrpContext->Icb;

    uStream.Length = 0;
    uStream.MaximumLength = sizeof( StreamName );
    uStream.Buffer = StreamName;

    DebugTrace( 0 , Dbg, "NDS open stream...\n", 0 );

    try {

        if (RequestLength < (ULONG)(FIELD_OFFSET(NWR_NDS_REQUEST_PACKET, Parameters.OpenStream.StreamNameString) + pNdsRequest->Parameters.OpenStream.StreamName.Length)) {
            DebugTrace( 0, Dbg, "OpenStream Request Length is too short.\n", 0 );
            return STATUS_INVALID_PARAMETER;
        }

        dwOid = (pNdsRequest->Parameters).OpenStream.ObjectOid;
        StreamAccess = (pNdsRequest->Parameters).OpenStream.StreamAccess;
        RtlCopyUnicodeString( &uStream, &(pNdsRequest->Parameters).OpenStream.StreamName );
        (pNdsRequest->Parameters).OpenStream.FileLength = 0;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        DebugTrace( 0 , Dbg, "Bonk! Bad user mode buffer in open stream.\n", 0 );
        return GetExceptionCode();
    }

    //
    // We have the oid and stream name; let's get the handle.
    //

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we haven't licensed this connection yet, it's time.  Get to the
    // head of the queue to protect the SCB fields and authenticate the
    // connection (do not defer the login).
    //

    NwAppendToQueueAndWait( pIrpContext );

    ASSERT( pScb->MajorVersion > 3 );

    if ( ( pScb->UserName.Length == 0 ) &&
         ( pScb->VcbCount == 0 ) &&
         ( pScb->OpenNdsStreams == 0 ) ) {

        if ( pScb->pNpScb->State != SCB_STATE_IN_USE ) {

            Status = ConnectScb( &pScb,
                                 pIrpContext,
                                 &(pScb->pNpScb->ServerName),
                                 NULL,    // address
                                 NULL,    // name
                                 NULL,    // password
                                 FALSE,   // defer login
                                 FALSE,   // delete connection
                                 TRUE );  // existing scb

            if ( !NT_SUCCESS( Status ) ) {
                DebugTrace( 0, Dbg, "Couldn't connect server %08lx to open NDS stream.\n", pScb );
                goto ExitWithCleanup;
            }
        }

        ASSERT( pScb->pNpScb->State == SCB_STATE_IN_USE );

        Status = NdsLicenseConnection( pIrpContext );

        if ( !NT_SUCCESS( Status ) ) {
            Status = STATUS_REMOTE_SESSION_LIMIT;
            goto ExitWithCleanup;
        }

        LicensedConnection = TRUE;
    }

    Status = FragExWithWait( pIrpContext,
                             NDSV_OPEN_STREAM,
                             &NdsRequest,
                             "DDDs",
                             0,                    // version
                             StreamAccess,         // file access
                             dwOid,                // object id
                             &uStream );           // attribute name

    if ( !NT_SUCCESS( Status )) {
        goto ExitWithCleanup;
    }

    Status = NdsCompletionCodetoNtStatus( &NdsRequest );

    if ( !NT_SUCCESS( Status )) {
        goto ExitWithCleanup;
    }

    Status = ParseResponse( NULL,
                            NdsRequest.pRecvBufferVa,
                            NdsRequest.dwBytesWritten,
                            "G_DD",
                            sizeof( DWORD ),     // completion code
                            &hNwHandle,          // remote handle
                            &dwFileLen );        // file length

    if ( !NT_SUCCESS( Status )) {
        goto ExitWithCleanup;
    }

    *(WORD *)(&pIcb->Handle[0]) = (WORD)hNwHandle + 1;
    *( (UNALIGNED DWORD *) (&pIcb->Handle[2]) ) = hNwHandle;

    pIrpContext->pScb->OpenNdsStreams++;

    DebugTrace( 0, Dbg, "File stream opened.  Length = %d\n", dwFileLen );

    try {
        (pNdsRequest->Parameters).OpenStream.FileLength = dwFileLen;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        //We have a handle open but hit exception writing stream length
        //back out to use space.  Previously set length to 0 in case
        //this happened.  Caller must deal with invalid length if
        //we return 0 with a valid stream (file) handle.
    }

    pIcb->HasRemoteHandle = TRUE;

    pIcb->FileObject->CurrentByteOffset.QuadPart = 0;

ExitWithCleanup:

    NdsFreeLockedBuffer( &NdsRequest );

    if ( ( !NT_SUCCESS( Status ) ) &&
         ( LicensedConnection ) ) {
        NdsUnlicenseConnection( pIrpContext );
    }

    NwDequeueIrpContext( pIrpContext, FALSE );
    return Status;

}

NTSTATUS
NdsSetContext(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength
) {

    NTSTATUS Status;

    PLOGON pLogon;

    UNICODE_STRING Tree, Context;
    PNDS_SECURITY_CONTEXT pCredentials;

    PAGED_CODE();

    DebugTrace( 0 , Dbg, "NDS set context.\n", 0 );

    try {
        if (RequestLength < (FIELD_OFFSET(NWR_NDS_REQUEST_PACKET, Parameters.SetContext.TreeAndContextString) + pNdsRequest->Parameters.SetContext.TreeNameLen)) {
            DebugTrace( 0, Dbg, "SetContext Request Length is too short.\n", 0 );
            return STATUS_INVALID_PARAMETER;
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        return GetExceptionCode();
    }
	
    //
    // Find out who this is.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    pLogon = FindUser( &(pIrpContext->Specific.Create.UserUid), FALSE );
    NwReleaseRcb( &NwRcb );

    if ( !pLogon ) {

        DebugTrace( 0, Dbg, "Couldn't find logon data for this user.\n", 0 );
        return STATUS_ACCESS_DENIED;

    }

    //
    // Verify that this context really is a context.
    //

    try {
        Tree.Length = (USHORT)(pNdsRequest->Parameters).SetContext.TreeNameLen;
        Tree.MaximumLength = Tree.Length;
        Tree.Buffer = (pNdsRequest->Parameters).SetContext.TreeAndContextString;

        Context.Length = (USHORT)(pNdsRequest->Parameters).SetContext.ContextLen;
        Context.MaximumLength = Context.Length;
        Context.Buffer = (WCHAR *) (((BYTE *)Tree.Buffer) + Tree.Length);

        Status = NdsVerifyContext( pIrpContext, &Tree, &Context );

        if ( !NT_SUCCESS( Status ) ) {
            return STATUS_INVALID_PARAMETER;
        }

        Status = NdsLookupCredentials( pIrpContext,
                                   &Tree,
                                   pLogon,
                                   &pCredentials,
                                   CREDENTIAL_READ,
                                   TRUE );

        if ( !NT_SUCCESS( Status ) ) {

            DebugTrace( 0, Dbg, "No credentials in set context.\n", 0 );
            return STATUS_NO_SUCH_LOGON_SESSION;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // ALERT! We are holding the credential list!
    //

    if ( Context.Length > MAX_NDS_NAME_SIZE ) {

        DebugTrace( 0, Dbg, "Context too long.\n", 0 );
        Status = STATUS_INVALID_PARAMETER;
        goto ReleaseAndExit;
    }

    try {

        RtlCopyUnicodeString( &pCredentials->CurrentContext, &Context );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        DebugTrace( 0, Dbg, "Bad user buffer in SetContext.\n", 0 );
        Status = STATUS_INVALID_PARAMETER;
        goto ReleaseAndExit;
    }

    NwReleaseCredList( pLogon, pIrpContext );

    //
    // RELAX! The credential list is free.
    //

    DebugTrace( 0, Dbg, "New context: %wZ\n", &Context );
    return STATUS_SUCCESS;

ReleaseAndExit:

    NwReleaseCredList( pLogon, pIrpContext );
    return Status;
}

NTSTATUS
NdsGetContext(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength
) {

    NTSTATUS Status;

    PLOGON pLogon;

    UNICODE_STRING Tree;
    PNDS_SECURITY_CONTEXT pCredentials;

    PAGED_CODE();

    DebugTrace( 0 , Dbg, "NDS get context.\n", 0 );

    try {
        if (RequestLength < (FIELD_OFFSET(NWR_NDS_REQUEST_PACKET, Parameters.GetContext.TreeNameString) + pNdsRequest->Parameters.GetContext.TreeNameLen)) {
            DebugTrace( 0, Dbg, "GetContext Request Length is too short.\n", 0 );
            return STATUS_INVALID_PARAMETER;
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        return GetExceptionCode();
    }

    //
    // Find out who this is.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    pLogon = FindUser( &(pIrpContext->Specific.Create.UserUid), FALSE );
    NwReleaseRcb( &NwRcb );

    if ( !pLogon ) {

        DebugTrace( 0, Dbg, "Couldn't find logon data for this user.\n", 0 );
        return STATUS_ACCESS_DENIED;

    }

    //
    // We know who it is, so get the context.
    //

    try {
        Tree.Length = (USHORT)(pNdsRequest->Parameters).GetContext.TreeNameLen;
        Tree.MaximumLength = Tree.Length;
        Tree.Buffer = (pNdsRequest->Parameters).GetContext.TreeNameString;

        Status = NdsLookupCredentials( pIrpContext,
                                   &Tree,
                                   pLogon,
                                   &pCredentials,
                                   CREDENTIAL_READ,
                                   FALSE );

        if ( !NT_SUCCESS( Status ) ) {

            //
            // No context has been set, so report none.
            //

            try {

                (pNdsRequest->Parameters).GetContext.Context.Length = 0;
                return STATUS_SUCCESS;

            } except ( EXCEPTION_EXECUTE_HANDLER ) {

                DebugTrace( 0, Dbg, "Bad user buffer in GetContext.\n", 0 );
                return STATUS_INVALID_PARAMETER;

            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Make sure we can report the whole thing.
    // ALERT! We are holding the credential list!
    //

    try {
        if ( (pNdsRequest->Parameters).GetContext.Context.MaximumLength <
            pCredentials->CurrentContext.Length ) {

            Status = STATUS_BUFFER_TOO_SMALL;
            goto ReleaseAndExit;
        }

        RtlCopyUnicodeString( &(pNdsRequest->Parameters).GetContext.Context,
                              &pCredentials->CurrentContext );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        DebugTrace( 0, Dbg, "Bad user buffer in GetContext.\n", 0 );
        Status = STATUS_INVALID_PARAMETER;
        goto ReleaseAndExit;
    }

    NwReleaseCredList( pLogon, pIrpContext );

    //
    // RELAX! The credential list is free.
    //

    DebugTrace( 0, Dbg, "Reported context: %wZ\n", &pCredentials->CurrentContext );
    return STATUS_SUCCESS;

ReleaseAndExit:

    NwReleaseCredList( pLogon, pIrpContext );
    return Status;

}

NTSTATUS
NdsVerifyTreeHandle(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength
) {

    NTSTATUS Status;
    UNICODE_STRING NdsTree;
    WCHAR TreeBuffer[NDS_TREE_NAME_LEN];

    PAGED_CODE();

    try {

        if (RequestLength < (ULONG)(FIELD_OFFSET(NWR_NDS_REQUEST_PACKET, Parameters.VerifyTree.NameString) + pNdsRequest->Parameters.VerifyTree.TreeName.Length)) {
            DebugTrace( 0, Dbg, "VerifyTreeHandle Request Length is too short.\n", 0 );
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Check to see if the handle points to a dir server in the
        // specified tree.  Make sure to unmunge the tree name in
        // the SCB first, just in case.
        //

        NdsTree.Length = 0;
        NdsTree.MaximumLength = sizeof( TreeBuffer );
        NdsTree.Buffer = TreeBuffer;

        UnmungeCredentialName( &pIrpContext->pScb->NdsTreeName,
                               &NdsTree );

        if ( !RtlCompareUnicodeString( &NdsTree,
                                       &(pNdsRequest->Parameters).VerifyTree.TreeName,
                                       TRUE ) ) {

            DebugTrace( 0 , Dbg, "NdsVerifyTreeHandle: Success\n", 0 );
            Status = STATUS_SUCCESS;
        } else {

            DebugTrace( 0 , Dbg, "NdsVerifyTreeHandle: Failure\n", 0 );
            Status = STATUS_ACCESS_DENIED;
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        DebugTrace( 0 , Dbg, "NdsVerifyTreeHandle: Invalid parameters.\n", 0 );
        Status = STATUS_INVALID_PARAMETER;

   }

   return Status;

}

NTSTATUS
NdsGetPrintQueueInfo(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
	ULONG RequestLength
) {

    NTSTATUS Status;

    UNICODE_STRING ServerAttribute;
    WCHAR Server[] = L"Host Server";

    PSCB pPrintHost = NULL;
    PNONPAGED_SCB pOriginalNpScb = NULL;

    DWORD dwObjectId, dwObjectType;

    UNICODE_STRING uPrintServer;

    BYTE *pbQueue, *pbRQueue;

    PAGED_CODE();

    try {
        if (RequestLength < (ULONG)FIELD_OFFSET(NWR_NDS_REQUEST_PACKET, Parameters.GetQueueInfo.QueueId)) {
            DebugTrace( 0, Dbg, "GetQueueInfo Request Length is too short.\n", 0 );
            return STATUS_INVALID_PARAMETER;
        }

        if ( pIrpContext->pOriginalIrp->RequestorMode != KernelMode ) {

            ProbeForRead( pNdsRequest->Parameters.GetQueueInfo.QueueName.Buffer,
                          pNdsRequest->Parameters.GetQueueInfo.QueueName.Length,
                          sizeof(CHAR));
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        return GetExceptionCode();
    }

    RtlInitUnicodeString( &ServerAttribute, Server );

    //
    // Make sure we have a print queue object.  We may
    // have to jump servers if we get referred to another
    // replica.  If this is the case, we can't lose the
    // ref count on the original server since that's where
    // the ICB handle is.
    //

    pOriginalNpScb = pIrpContext->pNpScb;

    //
    // tommye - fix for case where pOriginalNpScb == NULL (devctl test case)
    //

    if (pOriginalNpScb == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    NwReferenceScb( pOriginalNpScb );

    try {
        Status = NdsVerifyObject( pIrpContext,
                              &(pNdsRequest->Parameters).GetQueueInfo.QueueName,
                              TRUE,
                              DEFAULT_RESOLVE_FLAGS,
                              &dwObjectId,
                              &dwObjectType );
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if ( pIrpContext->pNpScb == pOriginalNpScb ) {

        //
        // If we were not referred, remove the extra ref
        // count and clear the original pointer.
        //

        NwDereferenceScb( pOriginalNpScb );
        pOriginalNpScb = NULL;
    }

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    if ( dwObjectType != NDS_OBJECTTYPE_QUEUE ) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitWithCleanup;
    }

    //
    // Retrieve the host server name.
    //

    try {
        Status = NdsReadStringAttribute( pIrpContext,
                                     dwObjectId,
                                     &ServerAttribute,
                                     &(pNdsRequest->Parameters).GetQueueInfo.HostServer );
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Dig out the actual server name from the X.500 name.
    //

    try {
        Status = NdsGetServerBasicName( &(pNdsRequest->Parameters).GetQueueInfo.HostServer,
                                    &uPrintServer );
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Connect to the actual host server.  If there was a referral, we
    // can simply dump the referred server since we are holding the ref
    // count on the original owner of the ICB.
    //

    if ( pOriginalNpScb ) {
        NwDereferenceScb( pIrpContext->pNpScb );
    } else {
        pOriginalNpScb = pIrpContext->pNpScb;
    }

    NwDequeueIrpContext( pIrpContext, FALSE );

    Status = CreateScb( &pPrintHost,
                        pIrpContext,
                        &uPrintServer,
                        NULL,
                        NULL,
                        NULL,
                        FALSE,
                        FALSE );

    if ( !NT_SUCCESS( Status ) ) {
        pIrpContext->pNpScb = NULL;
        goto ExitWithCleanup;
    }

    //
    // Re-query the OID of the print queue object on this server.
    // Don't allow any server jumping this time; we only need the
    // oid of the queue.
    //

    try {
        Status = NdsVerifyObject( pIrpContext,
                              &(pNdsRequest->Parameters).GetQueueInfo.QueueName,
                              FALSE,
                              RSLV_CREATE_ID,
                              &dwObjectId,
                              NULL );

        if ( NT_SUCCESS( Status ) ) {

            //
            // Byte swap the queue id.
            //

            pbRQueue = (BYTE *) &dwObjectId;
            pbQueue = (BYTE *) &(pNdsRequest->Parameters).GetQueueInfo.QueueId;

            pbQueue[0] = pbRQueue[3];
            pbQueue[1] = pbRQueue[2];
            pbQueue[2] = pbRQueue[1];
            pbQueue[3] = pbRQueue[0];
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

ExitWithCleanup:

    NwDequeueIrpContext( pIrpContext, FALSE );

    //
    // Restore the pointers and ref counts as appropriate.
    //

    if ( pOriginalNpScb ) {

        if ( pIrpContext->pNpScb ) {
            NwDereferenceScb( pIrpContext->pNpScb );
        }

        pIrpContext->pNpScb = pOriginalNpScb;
        pIrpContext->pScb = pOriginalNpScb->pScb;
    }

    return Status;

}

NTSTATUS
NdsChangePass(
    PIRP_CONTEXT pIrpContext
) {

    NTSTATUS Status;

    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PNWR_NDS_REQUEST_PACKET Rrp;
    ULONGLONG InputBufferLength;

    UNICODE_STRING NdsTree;
    UNICODE_STRING UserName;
    UNICODE_STRING CurrentPassword;
    UNICODE_STRING NewPassword;
    PBYTE CurrentString;
    BOOLEAN ServerReferenced = FALSE;

    OEM_STRING OemCurrentPassword;
    BYTE CurrentBuffer[MAX_PW_CHARS+1]; //+1 for ending NULL

    OEM_STRING OemNewPassword;
    BYTE NewBuffer[MAX_PW_CHARS+1];   //+1 for ending NULL

    NODE_TYPE_CODE nodeTypeCode;
    PSCB Scb;
    PICB pIcb;
    PVOID fsContext, fsObject;
    UNICODE_STRING CredentialName;
    PNDS_SECURITY_CONTEXT pCredential;
    ULONG LocalNdsTreeNameLength;
    ULONG LocalUserNameLength;
    ULONG LocalCurrentPasswordLength;
    ULONG LocalNewPasswordLength;

    PAGED_CODE();

    //
    // Get the request.
    //

    irp = pIrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    Rrp = ( PNWR_NDS_REQUEST_PACKET ) irpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = irpSp->Parameters.FileSystemControl.InputBufferLength;

    if ( !Rrp ) {

        DebugTrace( 0, Dbg, "No raw request buffer.\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    if ( InputBufferLength < 
         ((ULONG) FIELD_OFFSET( NWR_NDS_REQUEST_PACKET, Parameters.ChangePass.StringBuffer[0]))) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Decode the file object to see if this is an ex-create handle.
    //

    nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                       &fsContext,
                                       &fsObject );

    if ( nodeTypeCode == NW_NTC_ICB_SCB ) {

        pIcb = (PICB) fsObject;

        //
        // If this is a handle made on an ex-create, then
        // we have to be aware of our credentials while
        // jumping servers.
        //
        // This is not too intuitive since this doesn't
        // seem to be a create path irp, but referrals
        // on any path cause the create paths to be
        // traversed.
        //

        if ( pIcb->IsExCredentialHandle ) {

            pIrpContext->Specific.Create.fExCredentialCreate = TRUE;

            pCredential = (PNDS_SECURITY_CONTEXT) pIcb->pContext;

            Status = GetCredentialFromServerName( &pCredential->NdsTreeName,
                                                  &CredentialName );
            if ( !NT_SUCCESS( Status ) ) {
                return STATUS_INVALID_HANDLE;
            }

            pIrpContext->Specific.Create.puCredentialName = &CredentialName;
        }

    }
    try {

        if ( irp->RequestorMode != KernelMode ) {

            ProbeForRead( Rrp,
                          (ULONG) InputBufferLength,
                          sizeof(CHAR)
                          );
        }

        //
        // Capture all the interesting parameters locally so that they don't change
        // after validating them.
        //
        
        LocalNdsTreeNameLength = Rrp->Parameters.ChangePass.NdsTreeNameLength;
        LocalUserNameLength = Rrp->Parameters.ChangePass.UserNameLength;
        LocalCurrentPasswordLength = Rrp->Parameters.ChangePass.CurrentPasswordLength;
        LocalNewPasswordLength = Rrp->Parameters.ChangePass.NewPasswordLength;

        if ( InputBufferLength < 
             ((ULONGLONG) FIELD_OFFSET( NWR_NDS_REQUEST_PACKET, Parameters.ChangePass.StringBuffer[0]) +
             (ULONGLONG) LocalNdsTreeNameLength +
             (ULONGLONG) LocalUserNameLength +
             (ULONGLONG) LocalCurrentPasswordLength +
             (ULONGLONG) LocalNewPasswordLength )) {
    
            return( STATUS_INVALID_PARAMETER );
        }
    
        //
        // Dig out the parameters.
        //

        CurrentString = ( PBYTE ) &(Rrp->Parameters.ChangePass.StringBuffer[0]);
    
        NdsTree.Length = NdsTree.MaximumLength =
            ( USHORT ) LocalNdsTreeNameLength;
        NdsTree.Buffer = ( PWCHAR ) CurrentString;
    
        CurrentString += NdsTree.Length;
    
        UserName.Length = UserName.MaximumLength =
            ( USHORT ) LocalUserNameLength;
        UserName.Buffer = ( PWCHAR ) CurrentString;
    
        CurrentString += UserName.Length;
    
        CurrentPassword.Length = CurrentPassword.MaximumLength =
            ( USHORT ) LocalCurrentPasswordLength;
        CurrentPassword.Buffer = ( PWCHAR ) CurrentString;
    
        CurrentString += CurrentPassword.Length;
    
        NewPassword.Length = NewPassword.MaximumLength =
            ( USHORT ) LocalNewPasswordLength;
        NewPassword.Buffer = ( PWCHAR ) CurrentString;
    
        //
        // Get a server to handle this request.
        //
        //
        // Convert the passwords to the appropriate type.
        //

        OemCurrentPassword.Length = 0;
        OemCurrentPassword.MaximumLength = sizeof( CurrentBuffer );
        OemCurrentPassword.Buffer = CurrentBuffer;

        OemNewPassword.Length = 0;
        OemNewPassword.MaximumLength = sizeof( NewBuffer );
        OemNewPassword.Buffer = NewBuffer;

        //
        //  Check the lengths.  We allow for the extra NULL at the
        //  end of the string in the calculation since the 
        //  RtlUnicodeStringToOemSize routine calculates in 
        //  the size of the null.
        //

        {
            ULONG OemCurrentLength = RtlUnicodeStringToOemSize(&CurrentPassword);
            ULONG OemNewLength = RtlUnicodeStringToOemSize(&NewPassword);

            if (OemCurrentLength > (MAX_PW_CHARS+1)) {
                return STATUS_BUFFER_OVERFLOW;
            }
            if (OemNewLength > (MAX_PW_CHARS+1)) {
                return STATUS_BUFFER_OVERFLOW;
            }
        }

        RtlUpcaseUnicodeStringToOemString( &OemCurrentPassword,
                                           &CurrentPassword,
                                           FALSE );

        RtlUpcaseUnicodeStringToOemString( &OemNewPassword,
                                           &NewPassword,
                                           FALSE );

        //
        // Get a dir server to handle the request.
        //

        Status = NdsCreateTreeScb( pIrpContext,
                                   &Scb,
                                   &NdsTree,
                                   NULL,
                                   NULL,
                                   TRUE,
                                   FALSE );

        if ( !NT_SUCCESS( Status ) ) {

            DebugTrace( 0, Dbg, "No dir servers for nds change password.\n", 0 );
            return STATUS_BAD_NETWORK_PATH;
        }

        ServerReferenced = TRUE;

        //
        // Perform the change password.
        //

        Status = NdsTreeLogin( pIrpContext,
                               &UserName,
                               &OemCurrentPassword,
                               &OemNewPassword,
                               NULL );

        NwDereferenceScb( Scb->pNpScb );
        ServerReferenced = FALSE;

        if ( !NT_SUCCESS( Status ) ) {
            goto ExitWithCleanup;
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        DebugTrace( 0, Dbg, "NdsChangePass: Exception dealing with user request.\n", 0 );
        Status = STATUS_INVALID_PARAMETER;
        goto ExitWithCleanup;
    }

    DebugTrace( 0, Dbg, "NdsChangePassword succeeded for %wZ.\n", &UserName );
    Status = STATUS_SUCCESS;

ExitWithCleanup:

    if ( ServerReferenced ) {
        NwDereferenceScb( Scb->pNpScb );
    }

    //
    // We get STATUS_PASSWORD_EXPIRED when the user is not allowed
    // to change their password on the Netware server, so we return
    // PASSWORD_RESTRICTION instead.
    //

    if ( Status == STATUS_PASSWORD_EXPIRED ) {
        Status = STATUS_PASSWORD_RESTRICTION;
    }

    return Status;
}


NTSTATUS
NdsListTrees(
    PIRP_CONTEXT pIrpContext
)
/*+++

Description:

    This odd little routine takes the NTUSER name of the logged in
    user (on the system) and returns a list of NDS trees that the
    NTUSER is connected to and the user names for those connections.
    This is necessary because the change password ui runs in the
    systems luid and can't access the GET_CONN_STATUS api and because
    the change password code might happen when no user is logged in.

    The return data in the users buffer is an array of
    CONN_INFORMATION structures with the strings packed after the
    structures.  There is no continuation of this routine, so pass
    a decent sized buffer.

---*/
{

    NTSTATUS Status;

    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PNWR_NDS_REQUEST_PACKET Rrp;
    DWORD InputBufferLength;
    DWORD OutputBufferLength;
    PBYTE OutputBuffer;

    UNICODE_STRING NtUserName;
    PLOGON pLogon;
    DWORD dwTreesReturned = 0;
    DWORD dwBytesNeeded;

    PCONN_INFORMATION pConnInfo;
    PLIST_ENTRY pNdsList;
    PNDS_SECURITY_CONTEXT pNdsContext;

    PAGED_CODE();

    //
    // Get the request.
    //

    irp = pIrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    Rrp = ( PNWR_NDS_REQUEST_PACKET ) irpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = irpSp->Parameters.FileSystemControl.InputBufferLength;

    OutputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    NwMapUserBuffer( irp, KernelMode, (PVOID *)&OutputBuffer );

    if ( !Rrp || !OutputBufferLength || !OutputBuffer ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // tommye - MS bug 138643
    //
    // Probe the input arguments to make sure they are kosher before
    // touching them.
    //

    try {
        if ( irp->RequestorMode != KernelMode ) {

            ProbeForRead( Rrp,
                          (ULONG) InputBufferLength,
                          sizeof(CHAR)
                          );
        }

        //
        // Dig out the parameters.
        //

        NtUserName.Length = NtUserName.MaximumLength = (USHORT) Rrp->Parameters.ListTrees.NtUserNameLength;
        NtUserName.Buffer = &(Rrp->Parameters.ListTrees.NtUserName[0]);

        DebugTrace( 0, Dbg, "ListTrees: Looking up %wZ\n", &NtUserName );

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        pLogon = FindUserByName( &NtUserName );
        NwReleaseRcb( &NwRcb );

        if ( !pLogon ) {
            DebugTrace( 0, Dbg, "ListTrees: No such NT user.\n", 0 );
            return STATUS_NO_SUCH_USER;
        }

        //
        // Otherwise build the list of trees.
        //

        Rrp->Parameters.ListTrees.UserLuid = pLogon->UserUid;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    NwAcquireExclusiveCredList( pLogon, pIrpContext );
    pConnInfo = ( PCONN_INFORMATION ) OutputBuffer;

    pNdsList = pLogon->NdsCredentialList.Flink;

    try {

        while ( pNdsList != &(pLogon->NdsCredentialList) ) {

            pNdsContext = CONTAINING_RECORD( pNdsList, NDS_SECURITY_CONTEXT, Next );

            //
            // Check to make sure there's a credential.
            //

            if ( pNdsContext->Credential == NULL ) {
                goto ProcessNextListEntry;
            }

            //
            // Don't report ex create credentials.
            //

            if ( IsCredentialName( &(pNdsContext->NdsTreeName) ) ) {
                goto ProcessNextListEntry;
            }

            //
            // Check to make sure there's space to report.
            //

            dwBytesNeeded = ( sizeof( CONN_INFORMATION ) +
                            pNdsContext->Credential->userNameLength +
                            pNdsContext->NdsTreeName.Length -
                            sizeof( WCHAR ) );

            if ( OutputBufferLength < dwBytesNeeded ) {
                break;
            }

            //
            // Report it!  Note that the user name in the credential is NULL terminated.
            //

            pConnInfo->HostServerLength = pNdsContext->NdsTreeName.Length;
            pConnInfo->UserNameLength = pNdsContext->Credential->userNameLength - sizeof( WCHAR );
            pConnInfo->HostServer = (LPWSTR) ( ((BYTE *)pConnInfo) + sizeof( CONN_INFORMATION ) );
            pConnInfo->UserName = (LPWSTR) ( ( (BYTE *)pConnInfo) +
                                               sizeof( CONN_INFORMATION ) +
                                               pConnInfo->HostServerLength );

            RtlCopyMemory( pConnInfo->HostServer,
                           pNdsContext->NdsTreeName.Buffer,
                           pConnInfo->HostServerLength );

            RtlCopyMemory( pConnInfo->UserName,
                           ( ((BYTE *) pNdsContext->Credential ) +
                             sizeof( NDS_CREDENTIAL ) +
                             pNdsContext->Credential->optDataSize ),
                           pConnInfo->UserNameLength );

            OutputBufferLength -= dwBytesNeeded;
            dwTreesReturned++;
            pConnInfo = ( PCONN_INFORMATION ) ( ((BYTE *)pConnInfo) + dwBytesNeeded );

ProcessNextListEntry:

            //
            // Do the next one.
            //

            pNdsList = pNdsList->Flink;
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // If we access violate, stop and return what we have.
        //

        DebugTrace( 0, Dbg, "User mode buffer access problem.\n", 0 );
    }

    NwReleaseCredList( pLogon, pIrpContext );

    DebugTrace( 0, Dbg, "Returning %d tree entries.\n", dwTreesReturned );
    try {
        Rrp->Parameters.ListTrees.TreesReturned = dwTreesReturned;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\fsctl.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for the
    NetWare redirector called by the dispatch driver.

Author:

    Colin Watson     [ColinW]    29-Dec-1992

Revision History:

--*/

#include "Procs.h"
#include "ntddrdr.h"

//
// MUP lock macros
//

#define ACQUIRE_MUP_LOCK()  NwAcquireOpenLock()
#define RELEASE_MUP_LOCK()  NwReleaseOpenLock()

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCTRL)

//
//  Local procedure prototypes
//

NTSTATUS
NwCommonDeviceIoControl (
    IN PIRP_CONTEXT IrpContext
    );

#ifndef _PNP_POWER_

NTSTATUS
StartRedirector(
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
StopRedirector(
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
BindToTransport (
    IN PIRP_CONTEXT IrpContext
    );

#endif

NTSTATUS
ChangePassword (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
SetInfo (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
SetDebug (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
GetMessage (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
GetStats (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
GetPrintJobId (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
GetConnectionDetails(
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
GetConnectionDetails2(
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
GetConnectionPerformance(
    IN PIRP_CONTEXT IrpContext
    );

#ifndef _PNP_POWER_

NTSTATUS
RegisterWithMup(
    VOID
    );

VOID
DeregisterWithMup(
    VOID
    );

#endif

NTSTATUS
QueryPath (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
UserNcp(
    ULONG Function,
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
UserNcpCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    );

NTSTATUS
FspCompleteLogin(
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
GetConnection(
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
EnumConnections(
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
DeleteConnection(
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
WriteNetResourceEntry(
    IN OUT PCHAR *FixedPortion,
    IN OUT PWCHAR *EndOfVariableData,
    IN PUNICODE_STRING ContainerName OPTIONAL,
    IN PUNICODE_STRING LocalName OPTIONAL,
    IN PUNICODE_STRING RemoteName,
    IN ULONG ScopeFlag,
    IN ULONG DisplayFlag,
    IN ULONG UsageFlag,
    IN ULONG ShareType,
    OUT PULONG EntrySize
    );

BOOL
CopyStringToBuffer(
    IN LPCWSTR SourceString OPTIONAL,
    IN DWORD   CharacterCount,
    IN LPCWSTR FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    );

NTSTATUS
GetRemoteHandle(
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
GetUserName(
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
GetChallenge(
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
WriteConnStatusEntry(
    PIRP_CONTEXT pIrpContext,
    PSCB pConnectionScb,
    PBYTE pbUserBuffer,
    DWORD dwBufferLen,
    DWORD *pdwBytesWritten,
    DWORD *pdwBytesNeeded,
    BOOLEAN fCallerScb
    );

NTSTATUS
GetConnStatus(
    IN PIRP_CONTEXT IrpContext,
    PFILE_OBJECT FileObject
    );

NTSTATUS
GetConnectionInfo(
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
GetPreferredServer(
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
SetShareBit(
    IN PIRP_CONTEXT IrpContext,
    PFILE_OBJECT FileObject
    );

//
// Statics
//

HANDLE MupHandle = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdFileSystemControl )
#pragma alloc_text( PAGE, NwCommonFileSystemControl )
#pragma alloc_text( PAGE, NwFsdDeviceIoControl )
#pragma alloc_text( PAGE, NwCommonDeviceIoControl )
#pragma alloc_text( PAGE, ChangePassword )
#pragma alloc_text( PAGE, SetInfo )
#pragma alloc_text( PAGE, GetStats )
#pragma alloc_text( PAGE, GetPrintJobId )
#pragma alloc_text( PAGE, RegisterWithMup )
#pragma alloc_text( PAGE, DeregisterWithMup )
#pragma alloc_text( PAGE, QueryPath )
#pragma alloc_text( PAGE, UserNcp )
#pragma alloc_text( PAGE, GetConnection )
#pragma alloc_text( PAGE, DeleteConnection )
#pragma alloc_text( PAGE, WriteNetResourceEntry )
#pragma alloc_text( PAGE, CopyStringToBuffer )
#pragma alloc_text( PAGE, GetRemoteHandle )
#pragma alloc_text( PAGE, GetUserName )
#pragma alloc_text( PAGE, GetChallenge )
#pragma alloc_text( PAGE, WriteConnStatusEntry )
#pragma alloc_text( PAGE, GetConnectionInfo )
#pragma alloc_text( PAGE, GetPreferredServer )

#ifndef _PNP_POWER_

#pragma alloc_text( PAGE, BindToTransport )
#pragma alloc_text( PAGE, RegisterWithMup )
#pragma alloc_text( PAGE, DeregisterWithMup )

#endif

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, UserNcpCallback )
#pragma alloc_text( PAGE1, GetConnectionDetails )
#pragma alloc_text( PAGE1, GetConnectionDetails2 )
#pragma alloc_text( PAGE1, GetMessage )
#pragma alloc_text( PAGE1, EnumConnections )
#endif

#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above
GetConnStatus


#endif



NTSTATUS
NwFsdFileSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of FileSystem control operations

Arguments:

    DeviceObject - Supplies the redirector device object.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdFileSystemControl\n", 0);

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    //
    //  Allocate the irp context.  If the allocation
    //  fails then an exception if thrown instead of
    //  NULL being returned so we just catch the error
    //  in there.
    //

    try {
        IrpContext = AllocateIrpContext( Irp );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Status = Status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );
        goto CleanupAndExit;
    }

    //
    //  Process the request
    //  IrpContext must be NON-NULL here.
    //

    try {

        SetFlag( IrpContext->Flags, IRP_FLAG_IN_FSD );
        Status = NwCommonFileSystemControl( IrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error Status that we get back from the
        //  execption code
        //

        Status = NwProcessException( IrpContext, GetExceptionCode() );

    }

    if ( IrpContext ) {

        if ( Status != STATUS_PENDING ) {
            NwDequeueIrpContext( IrpContext, FALSE );
        }

        NwCompleteRequest( IrpContext, Status );
    }

CleanupAndExit:
    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NwFsdFileSystemControl -> %08lx\n", Status);

    return Status;
}


NTSTATUS
NwCommonFileSystemControl (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    IrpContext - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PIRP Irp;
    ULONG Function;

    PAGED_CODE();

    NwReferenceUnlockableCodeSection();

    try {

        //
        //  Get a pointer to the current Irp stack location
        //

        Irp = IrpContext->pOriginalIrp;
        IrpSp = IoGetCurrentIrpStackLocation( Irp );
        Function = IrpSp->Parameters.FileSystemControl.FsControlCode;

        DebugTrace(+1, Dbg, "NwCommonFileSystemControl\n", 0);
        DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp);
        DebugTrace( 0, Dbg, "Function      = %08lx\n", Function);
        DebugTrace( 0, Dbg, "Function      = %d\n", (Function >> 2) & 0x0fff);

        //
        //  We know this is a file system control so we'll case on the
        //  minor function, and call a internal worker routine to complete
        //  the irp.
        //

        if (IrpSp->MinorFunction != IRP_MN_USER_FS_REQUEST ) {
            DebugTrace( 0, Dbg, "Invalid FS Control Minor Function %08lx\n", IrpSp->MinorFunction);
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        //
        // tommye 
        //
        // If the output buffer came from user space, then probe it for write.
        //

        if (((Function & 3) == METHOD_NEITHER) && (Irp->RequestorMode != KernelMode)) {
            ULONG OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

            try {
                ProbeForWrite( Irp->UserBuffer,
                               OutputBufferLength,
                               sizeof(CHAR)
                              );

            } except (EXCEPTION_EXECUTE_HANDLER) {
                  
                  return GetExceptionCode();
            }
        }

        switch (Function) {

        case FSCTL_NWR_START:
            Status = StartRedirector( IrpContext );
            break;

        case FSCTL_NWR_STOP:
            Status = StopRedirector( IrpContext );
            break;

        case FSCTL_NWR_LOGON:
            Status = Logon( IrpContext );
            break;

        case FSCTL_NWR_LOGOFF:
            Status = Logoff( IrpContext );
            break;

        case FSCTL_NWR_GET_CONNECTION:
            Status = GetConnection( IrpContext );
            break;

        case FSCTL_NWR_ENUMERATE_CONNECTIONS:
            Status = EnumConnections( IrpContext );
            break;

        case FSCTL_NWR_DELETE_CONNECTION:
            Status = DeleteConnection( IrpContext );
            break;

        case FSCTL_NWR_BIND_TO_TRANSPORT:
#ifndef _PNP_POWER_
            Status = BindToTransport( IrpContext );
#else
            Status = RegisterTdiPnPEventHandlers( IrpContext );
#endif
            break;

        case FSCTL_NWR_CHANGE_PASS:
            Status = ChangePassword( IrpContext );
            break;

        case FSCTL_NWR_SET_INFO:
            Status = SetInfo( IrpContext );
            break;

        case FSCTL_NWR_GET_CONN_DETAILS:
            Status = GetConnectionDetails( IrpContext );
            break;

        case FSCTL_NWR_GET_CONN_DETAILS2:
            Status = GetConnectionDetails2( IrpContext );
            break;

        case FSCTL_NWR_GET_MESSAGE:
            Status = GetMessage( IrpContext );
            break;

        case FSCTL_NWR_GET_STATISTICS:
            Status = GetStats( IrpContext );
            break;

        case FSCTL_NWR_GET_USERNAME:
            Status = GetUserName( IrpContext );
            break;

        case FSCTL_NWR_CHALLENGE:
            Status = GetChallenge( IrpContext );
            break;

        case FSCTL_GET_PRINT_ID:
            Status = GetPrintJobId( IrpContext );
            break;

        case FSCTL_NWR_GET_CONN_STATUS:
            Status = GetConnStatus( IrpContext, IrpSp->FileObject );
            break;

        case FSCTL_NWR_GET_CONN_INFO:
            Status = GetConnectionInfo( IrpContext );
            break;

        case FSCTL_NWR_GET_PREFERRED_SERVER:
            Status = GetPreferredServer( IrpContext );
            break;

        case FSCTL_NWR_GET_CONN_PERFORMANCE:
            Status = GetConnectionPerformance( IrpContext );
            break;

        case FSCTL_NWR_SET_SHAREBIT:
            Status = SetShareBit( IrpContext, IrpSp->FileObject );
            break;

        //Terminal Server merge
        case FSCTL_NWR_CLOSEALL:
            NwCloseAllVcbs( IrpContext );
            Status = STATUS_SUCCESS;
            break;

        default:

            if (( Function >= NWR_ANY_NCP(0)) &&
                ( Function <= NWR_ANY_HANDLE_NCP(0x00ff))) {

                Status = UserNcp( Function, IrpContext );
                break;

            }

            if (( Function >= NWR_ANY_NDS(0)) &&
                ( Function <= NWR_ANY_NDS(0x00ff))) {

                Status = DispatchNds( Function, IrpContext );
                break;
            }

            DebugTrace( 0, Dbg, "Invalid FS Control Code %08lx\n",
                        IrpSp->Parameters.FileSystemControl.FsControlCode);

            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        }

    } finally {

        NwDereferenceUnlockableCodeSection ();

        DebugTrace(-1, Dbg, "NwCommonFileSystemControl -> %08lx\n", Status);

    }

    return Status;
}


NTSTATUS
NwFsdDeviceIoControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of DeviceIoControl file operations

Arguments:

    DeviceObject - Supplies the redirector device object.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdDeviceIoControl\n", 0);

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    //
    //  Allocate the irp context.  If the allocation
    //  fails then an exception if thrown instead of
    //  NULL being returned.
    //

    try {
        IrpContext = AllocateIrpContext( Irp );
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Status = Status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );
        goto CleanupAndExit;
    }
    

    try {

        SetFlag( IrpContext->Flags, IRP_FLAG_IN_FSD );
        Status = NwCommonDeviceIoControl( IrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error Status that we get back from the
        //  execption code
        //

        Status = NwProcessException( IrpContext, GetExceptionCode() );

    }

    if ( IrpContext ) {

        if ( Status != STATUS_PENDING ) {
            NwDequeueIrpContext( IrpContext, FALSE );
        }

        NwCompleteRequest(IrpContext, Status);
    }

CleanupAndExit:
    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NwFsdDeviceIoControl -> %08lx\n", Status);

    return Status;
}


NTSTATUS
NwCommonDeviceIoControl (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    IrpContext - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PIRP Irp;

    PAGED_CODE();

    NwReferenceUnlockableCodeSection();

    try {

        //
        //  Get a pointer to the current Irp stack location
        //

        Irp = IrpContext->pOriginalIrp;
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        DebugTrace(+1, Dbg, "NwCommonDeviceIoControl\n", 0);
        DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp);
        DebugTrace( 0, Dbg, "Function      = %08lx\n",
                        IrpSp->Parameters.DeviceIoControl.IoControlCode);

        //
        //  We know this is a DeviceIoControl so we'll case on the
        //  minor function, and call a internal worker routine to complete
        //  the irp.
        //

        switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_REDIR_QUERY_PATH:
            Status = QueryPath( IrpContext );
            break;

        case IOCTL_NWR_RAW_HANDLE:
            Status = GetRemoteHandle( IrpContext );
            break;

        default:

            DebugTrace( 0, Dbg, "Invalid IO Control Code %08lx\n",
                        IrpSp->Parameters.DeviceIoControl.IoControlCode);

            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    } finally {

        NwDereferenceUnlockableCodeSection ();
        DebugTrace(-1, Dbg, "NwCommonDeviceIoControl -> %08lx\n", Status);

    }

    return Status;
}

#ifndef _PNP_POWER_

NTSTATUS
BindToTransport (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine records the name of the transport to be used and
    initialises the PermanentScb.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PNWR_REQUEST_PACKET InputBuffer = Irp->AssociatedIrp.SystemBuffer;
    ULONG InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    PLOGON Logon;
    LARGE_INTEGER Uid;

    PAGED_CODE();

    //
    // Don't re-register if we have already registered.
    //

    if ( TdiBindingHandle != NULL ) {

        return STATUS_SUCCESS;
    }

    // ========= Multi-user support ==============
    // Get the LOGON structure 
    //
    SeCaptureSubjectContext(&SubjectContext);

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    Uid = GetUid( &SubjectContext );

    Logon = FindUser( &Uid, TRUE );

    NwReleaseRcb( &NwRcb );

    SeReleaseSubjectContext(&SubjectContext);
    //
    // Now we have the the Logon structure for the user
    //=====================================

    //
    // Register the PnP bind handlers.
    //

    DebugTrace( 0 , Dbg, "Register TDI bind handlers.\n", 0 );

    TdiInitialize();

    return TdiRegisterNotificationHandler( HandleTdiBindMessage,
                                           HandleTdiUnbindMessage,
                                           &TdiBindingHandle );

    /************************

    //
    // The old non-pnp code for legacy support.
    //

    DebugTrace(+1, Dbg, "Bind to transport\n", 0);

    try {

        if ( FlagOn( IrpContext->Flags, IRP_FLAG_IN_FSD ) ) {
            Status = NwPostToFsp( IrpContext, TRUE );
            try_return( Status );
        }

        if (IpxHandle != NULL) {

            //
            //  Can only bind to one transport at a time in this implementation
            //

            try_return(Status= STATUS_SHARING_VIOLATION);
        }

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < sizeof(NWR_REQUEST_PACKET)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        if (InputBuffer->Version != REQUEST_PACKET_VERSION) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBufferLength <
                (FIELD_OFFSET(NWR_REQUEST_PACKET,Parameters.Bind.TransportName)) +
                InputBuffer->Parameters.Bind.TransportNameLength) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if ( IpxTransportName.Buffer != NULL ) {
            FREE_POOL( IpxTransportName.Buffer );
        }

        Status = SetUnicodeString ( &IpxTransportName,
                    InputBuffer->Parameters.Bind.TransportNameLength,
                    InputBuffer->Parameters.Bind.TransportName);

        DebugTrace(-1, Dbg, "\"%wZ\"\n", &IpxTransportName);

        if ( !NT_SUCCESS(Status) ) {
            try_return(Status);
        }

        Status = IpxOpen();
        if ( !NT_SUCCESS(Status) ) {
            try_return(Status);
        }

        //
        //  Verify that have a large enough stack size.
        //

        if ( pIpxDeviceObject->StackSize >= FileSystemDeviceObject->StackSize) {
            IpxClose();
            try_return( Status = STATUS_INVALID_PARAMETER );
        }

#ifndef QFE_BUILD

        //
        //  Submit a line change request.
        //

        SubmitLineChangeRequest();
#endif

        //
        //  Open a handle to IPX.
        //

        NwPermanentNpScb.Server.Socket = 0;
        Status = IPX_Open_Socket( IrpContext, &NwPermanentNpScb.Server );
        ASSERT( NT_SUCCESS( Status ) );

        Status = SetEventHandler (
                     IrpContext,
                     &NwPermanentNpScb.Server,
                     TDI_EVENT_RECEIVE_DATAGRAM,
                     &ServerDatagramHandler,
                     &NwPermanentNpScb );

        ASSERT( NT_SUCCESS( Status ) );

        IrpContext->pNpScb = &NwPermanentNpScb;

        NwRcb.State = RCB_STATE_RUNNING;

try_exit:NOTHING;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    DebugTrace(-1, Dbg, "Bind to transport\n", 0);
    return Status;

    ******************/

}

VOID
HandleTdiBindMessage(
    IN PUNICODE_STRING DeviceName
)
/*+++

Description:  This function is the bind handler for NetPnP
    support.  This function is registered with TDI and is called
    whenever a transport starts up or stops.  We watch for IPX
    coming and going and do the appropriate thing.

    See also: HandleTdiUnbindMessage()

---*/
{

    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    PIRP pIrp = NULL;

    PAGED_CODE();

    //
    // See if this is IPX requesting a bind.  We only bind to NwLnkIpx.
    //

    if ( !RtlEqualUnicodeString( &TdiIpxDeviceName, DeviceName, TRUE ) ) {

        DebugTrace( 0, Dbg, "Ignoring PnP Bind request for %wZ\n", DeviceName );
        return;
    }

    //
    // Make sure we aren't already bound.
    //

    if ( ( NwRcb.State != RCB_STATE_NEED_BIND ) ||
         ( IpxHandle != NULL ) ) {

        DebugTrace( 0, Dbg, "Discarding duplicate PnP bind request.\n", 0 );
        return;
    }

    ASSERT( IpxTransportName.Buffer == NULL );
    ASSERT( pIpxDeviceObject == NULL );

    Status = DuplicateUnicodeStringWithString ( &IpxTransportName,
                                                DeviceName,
                                                PagedPool );

    if ( !NT_SUCCESS( Status ) ) {

        DebugTrace( 0, Dbg, "Failing IPX bind: Can't set device name.\n", 0 );
        return;
    }

    //
    // Open IPX.
    //

    Status = IpxOpen();

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    //  Verify that have a large enough stack size.
    //

    if ( pIpxDeviceObject->StackSize >= FileSystemDeviceObject->StackSize) {

        Status = STATUS_INVALID_PARAMETER;
        goto ExitWithCleanup;
    }

    //
    //  Submit a line change request.
    //

    SubmitLineChangeRequest();

    //
    // Allocate an irp and irp context.  AllocateIrpContext may raise status.
    //

    pIrp = ALLOCATE_IRP( pIpxDeviceObject->StackSize, FALSE );

    if ( pIrp == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithCleanup;
    }

    try {

        IrpContext = AllocateIrpContext( pIrp );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithCleanup;
    }

    ASSERT( IrpContext != NULL );

    //
    //  Open a handle to IPX for the permanent scb.
    //

    NwPermanentNpScb.Server.Socket = 0;
    Status = IPX_Open_Socket( IrpContext, &NwPermanentNpScb.Server );
    ASSERT( NT_SUCCESS( Status ) );

    Status = SetEventHandler (
                 IrpContext,
                 &NwPermanentNpScb.Server,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &ServerDatagramHandler,
                 &NwPermanentNpScb );

    ASSERT( NT_SUCCESS( Status ) );

    IrpContext->pNpScb = &NwPermanentNpScb;

    NwRcb.State = RCB_STATE_RUNNING;

    DebugTrace( 0, Dbg, "Opened IPX for NwRdr.\n", 0 );

    Status = STATUS_SUCCESS;

ExitWithCleanup:

    if ( !NT_SUCCESS( Status ) ) {

        //
        // If we failed, clean up our globals.
        //

        if ( pIpxDeviceObject != NULL ) {
            IpxClose();
            pIpxDeviceObject = NULL;
        }

        IpxHandle = NULL;

        if ( IpxTransportName.Buffer != NULL ) {
            FREE_POOL( IpxTransportName.Buffer );
            IpxTransportName.Buffer = NULL;
        }

        DebugTrace( 0, Dbg, "Failing IPX bind request.\n", 0 );

    }

    if ( pIrp != NULL ) {
        FREE_IRP( pIrp );
    }

    if ( IrpContext != NULL ) {
       IrpContext->pOriginalIrp = NULL; // Avoid FreeIrpContext modifying freed Irp.
       FreeIrpContext( IrpContext );
    }

    return;

}

VOID
HandleTdiUnbindMessage(
    IN PUNICODE_STRING DeviceName
)
/*+++

Description:  This function is the unbind handler for NetPnP
    support.  This function is registered with TDI and is called
    whenever a transport stops.  We watch for IPX coming and going
    and do the appropriate thing.

    See also: HandleTdiBindMessage()

---*/
{

    DebugTrace( 0, Dbg, "TDI unbind request ignored.  Not Supported.\n", 0 );
    return;

}

#endif


NTSTATUS
ChangePassword (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine records a change in the user's cached password.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PNWR_REQUEST_PACKET InputBuffer = Irp->AssociatedIrp.SystemBuffer;
    ULONG InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    UNICODE_STRING UserName;
    UNICODE_STRING Password;
    UNICODE_STRING ServerName;
    LARGE_INTEGER Uid;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "change password\n", 0);

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < sizeof(NWR_REQUEST_PACKET)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        if (InputBuffer->Version != REQUEST_PACKET_VERSION) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBufferLength <
                (FIELD_OFFSET(NWR_REQUEST_PACKET,Parameters.ChangePass.UserName)) +
                InputBuffer->Parameters.ChangePass.UserNameLength +
                InputBuffer->Parameters.ChangePass.PasswordLength +
                InputBuffer->Parameters.ChangePass.ServerNameLength ) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        //
        //  Get local pointer to the fsctl parameters
        //

        UserName.Buffer = InputBuffer->Parameters.ChangePass.UserName;
        UserName.Length = (USHORT)InputBuffer->Parameters.ChangePass.UserNameLength;

        Password.Buffer = UserName.Buffer +
            (InputBuffer->Parameters.ChangePass.UserNameLength / 2);
        Password.Length = (USHORT)InputBuffer->Parameters.ChangePass.PasswordLength;

        ServerName.Buffer = Password.Buffer +
            (InputBuffer->Parameters.ChangePass.PasswordLength / 2);
        ServerName.Length = (USHORT)InputBuffer->Parameters.ChangePass.ServerNameLength;

        //
        //  Update the default password for this user
        //

        Status = UpdateUsersPassword( &UserName, &Password, &Uid );

        //
        //  Update the default password for this user
        //

        if ( NT_SUCCESS( Status ) ) {
            UpdateServerPassword( IrpContext, &ServerName, &UserName, &Password, &Uid );
        }

        Status = STATUS_SUCCESS;

try_exit:NOTHING;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    DebugTrace(-1, Dbg, "Change Password\n", 0);
    return Status;
}


NTSTATUS
SetInfo (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine set netware redirector parameters.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PNWR_REQUEST_PACKET InputBuffer = Irp->AssociatedIrp.SystemBuffer;
    ULONG InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    SECURITY_SUBJECT_CONTEXT SubjectContext;
    PLOGON Logon;
    LARGE_INTEGER Uid;

    PAGED_CODE();


    SeCaptureSubjectContext(&SubjectContext);

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    Uid = GetUid( &SubjectContext );

    Logon = FindUser( &Uid, TRUE );

    NwReleaseRcb( &NwRcb );

    SeReleaseSubjectContext(&SubjectContext);

    DebugTrace(+1, Dbg, "Set info\n", 0);

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < sizeof(NWR_REQUEST_PACKET)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        if (InputBuffer->Version != REQUEST_PACKET_VERSION) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBufferLength <
                (FIELD_OFFSET(NWR_REQUEST_PACKET,Parameters.SetInfo.PreferredServer)) +
                InputBuffer->Parameters.SetInfo.PreferredServerLength +
                InputBuffer->Parameters.SetInfo.ProviderNameLength ) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        //
        // We don't do anything with a preferred server change, but if we
        // get a request to change the preferred tree and context, we
        // validate the context.  The rest of the changes happen at the next
        // login.
        //

        if ( InputBuffer->Parameters.SetInfo.PreferredServerLength > 0 &&
             InputBuffer->Parameters.SetInfo.PreferredServer[0] == '*' ) {

            UNICODE_STRING Tree, NewContext;
            USHORT i = 0;

            //
            // Dig out the tree name.  Skip over the *.
            //

            Tree.Length = 0;
            Tree.Buffer = InputBuffer->Parameters.SetInfo.PreferredServer + 1;

            while ( i < InputBuffer->Parameters.SetInfo.PreferredServerLength ) {

                if ( InputBuffer->Parameters.SetInfo.PreferredServer[i] == L'\\' ) {

                    i++;
                    Tree.Length -= sizeof( WCHAR );
                    Tree.MaximumLength = Tree.Length;
                    break;

                } else {

                   Tree.Length += sizeof( WCHAR );
                   i++;

                }
            }

            DebugTrace( 0, Dbg, "Tree: %wZ\n", &Tree );

            NewContext.Length = (USHORT)InputBuffer->Parameters.SetInfo.PreferredServerLength -
                                ( Tree.Length + (2 * sizeof( WCHAR ) ) );
            NewContext.Buffer = &InputBuffer->Parameters.SetInfo.PreferredServer[i];
            NewContext.MaximumLength = NewContext.Length;

            //
            // Strip off any leading period.
            //

            if ( NewContext.Buffer[0] == L'.' ) {

                NewContext.Buffer++;
                NewContext.Length -= sizeof( WCHAR );
                NewContext.MaximumLength -= sizeof( WCHAR );

            }

            DebugTrace( 0, Dbg, "Context: %wZ\n", &NewContext );

            Status = NdsVerifyContext( IrpContext, &Tree, &NewContext );

            if ( !NT_SUCCESS( Status )) {
                try_return( STATUS_INVALID_PARAMETER );
            }
        }

        //
        //  Next set the provider name string.
        //

        if ( InputBuffer->Parameters.SetInfo.ProviderNameLength != 0 ) {

            PWCH TempBuffer;

            TempBuffer = ALLOCATE_POOL_EX( PagedPool, InputBuffer->Parameters.SetInfo.ProviderNameLength );

            if ( NwProviderName.Buffer != NULL ) {
                FREE_POOL( NwProviderName.Buffer );
            }

            NwProviderName.Buffer = TempBuffer;
            NwProviderName.Length = (USHORT)InputBuffer->Parameters.SetInfo.ProviderNameLength;

            RtlCopyMemory(
                NwProviderName.Buffer,
                (PUCHAR)InputBuffer->Parameters.SetInfo.PreferredServer +
                    InputBuffer->Parameters.SetInfo.PreferredServerLength,
                NwProviderName.Length );

        }

        //
        //  Set burst mode parameters
        //

        if ( InputBuffer->Parameters.SetInfo.MaximumBurstSize == 0 ) {
            NwBurstModeEnabled = FALSE;
        } else if ( InputBuffer->Parameters.SetInfo.MaximumBurstSize != -1 ) {
            NwBurstModeEnabled = TRUE;
            NwMaxSendSize = InputBuffer->Parameters.SetInfo.MaximumBurstSize;
            NwMaxReceiveSize = InputBuffer->Parameters.SetInfo.MaximumBurstSize;
        }

        //
        //  Set print options
        //
        //--- Multi-User modification: ------
        // The NwPrintOption is per "Logon" based
        //
        if ( Logon != NULL ) {
            Logon->NwPrintOptions = InputBuffer->Parameters.SetInfo.PrintOption;
        }

try_exit:NOTHING;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    DebugTrace(-1, Dbg, "Set info\n", 0);
    return Status;
}


NTSTATUS
GetMessage (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine queues an IRP to a list of IRP Contexts available for
    reading server administrative messages.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_PENDING;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    PVOID OutputBuffer;
    KIRQL OldIrql;

    DebugTrace(+1, Dbg, "GetMessage\n", 0);

    //
    //  Lock the output buffer - handle any invalid
    //  buffer values here
    //

    try {
        NwLockUserBuffer( Irp, IoWriteAccess, OutputBufferLength );
        NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // tommye MS bug 26590 / MCS 258
    //
    // NwMapUserBuffer may return a NULL OutputBuffer in low resource
    // situations; this was not being checked.  
    //

    if (OutputBuffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {


        //
        //  Update the original MDL record in the Irp context, since
        //  NwLockUserBuffer may have created a new MDL.
        //

        IrpContext->pOriginalMdlAddress = Irp->MdlAddress;

        IrpContext->Specific.FileSystemControl.Buffer = OutputBuffer;
        IrpContext->Specific.FileSystemControl.Length = OutputBufferLength;

        KeAcquireSpinLock( &NwMessageSpinLock, &OldIrql );

        //
        //  tommye MS 17200 / MCS 366
        //
        //  Go ahead and get the cancel lock, this will keep
        //  someone from cancelling the Irp while we're in here.
        //

        IoAcquireCancelSpinLock( &Irp->CancelIrql );

        //
        //  tommye 
        //
        //  If this Irp is cancelled, we're done
        //

        if (Irp->Cancel) {
            
            Status = STATUS_CANCELLED;
        
        } else {

            InsertTailList( &NwGetMessageList, &IrpContext->NextRequest );

            IoMarkIrpPending( Irp );

            //
            // tommye
             //
            // Set the cancel routine and release the cancel lock
            //

            IoSetCancelRoutine( Irp, NwCancelIrp );
        }
        
        IoReleaseCancelSpinLock( Irp->CancelIrql );

        KeReleaseSpinLock( &NwMessageSpinLock, OldIrql );
    }

    DebugTrace(-1, Dbg, "Get Message -> %08lx\n", Status );
    return Status;
}


NTSTATUS
GetStats (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine copies Stats into the users buffer.

    Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_PENDING;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    PVOID OutputBuffer;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "GetStats\n", 0);

    NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );

    //
    // tommye 
    //
    // NwMapUserBuffer may return a NULL OutputBuffer in low resource
    // situations; this was not being checked.  
    //

    if (OutputBuffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        if (NwRcb.State != RCB_STATE_RUNNING) {

            Status = STATUS_REDIRECTOR_NOT_STARTED;

        } else if (OutputBufferLength < sizeof(NW_REDIR_STATISTICS)) {

            Status = STATUS_BUFFER_TOO_SMALL;

        } else if (OutputBufferLength != sizeof(NW_REDIR_STATISTICS)) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            Stats.CurrentCommands = ContextCount;

            try {
                RtlCopyMemory(OutputBuffer, &Stats, OutputBufferLength);
                Irp->IoStatus.Information = OutputBufferLength;
                Status = STATUS_SUCCESS;
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }
        }
    }

    DebugTrace(-1, Dbg, "GetStats -> %08lx\n", Status );
    return Status;
}


NTSTATUS
GetPrintJobId (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine gets the Job ID for this job.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_PENDING;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    PQUERY_PRINT_JOB_INFO OutputBuffer;
    PICB Icb;
    PVOID FsContext;
    NODE_TYPE_CODE NodeTypeCode;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "GetJobId\n", 0);

    NodeTypeCode = NwDecodeFileObject(
                       IrpSp->FileObject,
                       &FsContext,
                       (PVOID *)&Icb );

    if (NodeTypeCode != NW_NTC_ICB) {

        DebugTrace(0, Dbg, "Not a file\n", 0);
        Status = STATUS_INVALID_PARAMETER;

    } else if ( OutputBufferLength < sizeof( QUERY_PRINT_JOB_INFO ) ) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );

        //
        // tommye 
        //
        // NwMapUserBuffer may return a NULL OutputBuffer in low resource
        // situations; this was not being checked.  
        //

        if (OutputBuffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else {

            try {
                OutputBuffer->JobId = Icb->JobId;

                Status = STATUS_SUCCESS;
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }
        }
    }

    DebugTrace(-1, Dbg, "GetJobId -> %08lx\n", Status );
    return Status;
}


NTSTATUS
GetConnectionDetails(
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine gets the details for a connection. This is normally used
    for support of NetWare aware Dos applications.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_PENDING;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    PNWR_GET_CONNECTION_DETAILS OutputBuffer;
    PSCB pScb;
    PNONPAGED_SCB pNpScb;
    PICB Icb;
    PVOID FsContext;
    NODE_TYPE_CODE nodeTypeCode;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "GetConnectionDetails\n", 0);

    if ((nodeTypeCode = NwDecodeFileObject( IrpSp->FileObject,
                                            &FsContext,
                                            (PVOID *)&Icb )) != NW_NTC_ICB_SCB) {

        DebugTrace(0, Dbg, "Incorrect nodeTypeCode %x\n", nodeTypeCode);

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "GetConnectionDetails -> %08lx\n", Status );

        return Status;
    }

    //
    //  Make sure that this ICB is still active.
    //

    NwVerifyIcb( Icb );

    pScb = (PSCB)Icb->SuperType.Scb;
    nodeTypeCode = pScb->NodeTypeCode;

    if (nodeTypeCode != NW_NTC_SCB) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    pNpScb = pScb->pNpScb;

    if ( OutputBufferLength < sizeof( NWR_GET_CONNECTION_DETAILS ) ) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        PLIST_ENTRY ScbQueueEntry;
        KIRQL OldIrql;
        PNONPAGED_SCB pNextNpScb;
        UCHAR OrderNumber;
        OEM_STRING ServerName;

        NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );

        //
        // tommye 
        //
        // NwMapUserBuffer may return a NULL OutputBuffer in low resource
        // situations; this was not being checked.  
        //

        if (OutputBuffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else {

            KeAcquireSpinLock(&ScbSpinLock, &OldIrql);

            for ( ScbQueueEntry = ScbQueue.Flink, OrderNumber = 1;
                  ScbQueueEntry != &ScbQueue ;
                  ScbQueueEntry = ScbQueueEntry->Flink, OrderNumber++ ) {

                pNextNpScb = CONTAINING_RECORD(
                                 ScbQueueEntry,
                                 NONPAGED_SCB,
                                 ScbLinks );

                //
                //  Check to make sure that this SCB is usable.
                //

                if ( pNextNpScb == pNpScb ) {
                    break;
                }
            }

            KeReleaseSpinLock( &ScbSpinLock, OldIrql);

            try {
                OutputBuffer->OrderNumber = OrderNumber;

                RtlZeroMemory( OutputBuffer->ServerName, sizeof(OutputBuffer->ServerName));
                ServerName.Buffer = OutputBuffer->ServerName;
                ServerName.Length = sizeof(OutputBuffer->ServerName);
                ServerName.MaximumLength = sizeof(OutputBuffer->ServerName);
                RtlUpcaseUnicodeStringToCountedOemString( &ServerName, &pNpScb->ServerName, FALSE);

                RtlCopyMemory( OutputBuffer->ServerAddress,
                               &pNpScb->ServerAddress,
                               sizeof(OutputBuffer->ServerAddress) );

                OutputBuffer->ServerAddress[12];
                OutputBuffer->ConnectionNumberLo = pNpScb->ConnectionNo;
                OutputBuffer->ConnectionNumberHi = pNpScb->ConnectionNoHigh;

                //
                // tommye - MS 71688
                //
                //  Changed this from hard-coded '4' and '11' to use the 
                //  values in pScb.
                //

                OutputBuffer->MajorVersion = pScb->MajorVersion;
                OutputBuffer->MinorVersion = pScb->MinorVersion;

                OutputBuffer->Preferred = pScb->PreferredServer;

                Status = STATUS_SUCCESS;
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }
        }
    }

    DebugTrace(-1, Dbg, "GetConnectionDetails -> %08lx\n", Status );
    return Status;
}

#if 0

NTSTATUS
GetOurAddress(
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine gets the value of OurAddress. This is normally used
    for support of NetWare aware Dos applications.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_PENDING;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    PNWR_GET_OUR_ADDRESS OutputBuffer;
    PSCB pScb;
    PNONPAGED_SCB pNpScb;
    PICB Icb;
    PVOID FsContext;
    NODE_TYPE_CODE nodeTypeCode;

    DebugTrace(+1, Dbg, "GetOurAddress\n", 0);

    if ((nodeTypeCode = NwDecodeFileObject( IrpSp->FileObject,
                                            &FsContext,
                                            (PVOID *)&Icb )) != NW_NTC_ICB_SCB) {

        DebugTrace(0, Dbg, "Incorrect nodeTypeCode %x\n", nodeTypeCode);

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "GetOurAddress -> %08lx\n", Status );
    }

    //
    //  Make sure that this ICB is still active.
    //

    NwVerifyIcb( Icb );

    if ( OutputBufferLength < sizeof( NWR_GET_OUR_ADDRESS ) ) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {

        NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );

        //
        // tommye 
        //
        // NwMapUserBuffer may return a NULL OutputBuffer in low resource
        // situations; this was not being checked.  
        //

        if (OutputBuffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else {

            try {
                RtlCopyMemory( OutputBuffer->Address,
                               &OurAddress,
                               sizeof(OurAddress );

                Status = STATUS_SUCCESS;
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }
        }
    }

    DebugTrace(-1, Dbg, "GetOurAddress -> %08lx\n", Status );
    return Status;
}
#endif


#ifndef _PNP_POWER_

NTSTATUS
StartRedirector(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine starts the redirector.

Arguments:

    None.

Return Value:

    NTSTATUS - The status of the operation.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    //
    // We need to be in the FSP to Register the MUP.
    //

    if ( FlagOn( IrpContext->Flags, IRP_FLAG_IN_FSD ) ) {
        Status = NwPostToFsp( IrpContext, TRUE );
        return( Status );
    }

    //  -- MultiUser ---
    //  Logoff and disconnect from all servers.
    //  This makes very sure we do this.  The workstation is having a
    //  hard time deleting other user's connections.  Also (at least on
    //  slow debugging systems) RCB_STATE_SHUTDOWN cannot be on.
    //

    NwLogoffAllServers( IrpContext, NULL );

    NwRcb.State = RCB_STATE_STARTING;

    FspProcess = PsGetCurrentProcess();

#ifdef QFE_BUILD
    StartTimer() ;
#endif

    //
    // Now connect to the MUP.
    //

    RegisterWithMup();

    KeQuerySystemTime( &Stats.StatisticsStartTime );

    NwRcb.State = RCB_STATE_NEED_BIND;

    return( STATUS_SUCCESS );
}


NTSTATUS
StopRedirector(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine shuts down the redirector.

Arguments:

    None.

Return Value:

    NTSTATUS - The status of the operation.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY LogonListEntry;
    ULONG ActiveHandles;
    ULONG RcbOpenCount;

    PAGED_CODE();

    //
    // We need to be in the FSP to Deregister the MUP.
    //

    if ( FlagOn( IrpContext->Flags, IRP_FLAG_IN_FSD ) ) {
        Status = NwPostToFsp( IrpContext, TRUE );
        return( Status );
    }

    //
    // Unregister the bind handler with tdi.
    //

    if ( TdiBindingHandle != NULL ) {
        TdiDeregisterNotificationHandler( TdiBindingHandle );
        TdiBindingHandle = NULL;
    }

    NwRcb.State = RCB_STATE_SHUTDOWN;

    //
    //  Invalid all ICBs
    //

    SetFlag( IrpContext->Flags, IRP_FLAG_SEND_ALWAYS );
    ActiveHandles = NwInvalidateAllHandles(NULL, IrpContext);

    //
    //  To expedite shutdown, set retry count down to 2.
    //

    DefaultRetryCount = 2;

    //
    //  Close all VCBs
    //

    NwCloseAllVcbs( IrpContext );

    //
    //  Logoff and disconnect from all servers.
    //

    NwLogoffAllServers( IrpContext, NULL );

    while ( !IsListEmpty( &LogonList ) ) {

        LogonListEntry = RemoveHeadList( &LogonList );

        FreeLogon(CONTAINING_RECORD( LogonListEntry, LOGON, Next ));
    }

    InsertTailList( &LogonList, &Guest.Next );  // just in-case we don't unload.

    StopTimer();

    IpxClose();

    //
    //  Remember the open count before calling DeristerWithMup since this
    //  will asynchronously cause handle count to get decremented.
    //

    RcbOpenCount = NwRcb.OpenCount;

    DeregisterWithMup( );

    DebugTrace(0, Dbg, "StopRedirector:  Active handle count = %d\n", ActiveHandles );

    //
    //  On shutdown, we need 0 remote handles and 2 open handles to
    //  the redir (one for the service, and one for the MUP) and the timer stopped.
    //

    if ( ActiveHandles == 0 && RcbOpenCount <= 2 ) {
        return( STATUS_SUCCESS );
    } else {
        return( STATUS_REDIRECTOR_HAS_OPEN_HANDLES );
    }
}

#endif


NTSTATUS
RegisterWithMup(
    VOID
    )
/*++

Routine Description:

    This routine register this redirector as a UNC provider.

Arguments:

    None.

Return Value:

    NTSTATUS - The status of the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING RdrName;
    HANDLE LocalMupHandle = 0;

    PAGED_CODE();

    RtlInitUnicodeString( &RdrName, DD_NWFS_DEVICE_NAME_U );

    //
    // tommye MS 29173 / MCS 362
    //
    // We had a problem with us getting in here twice; since
    // there was no lock, the MupHandle got registered twice 
    // and we would leak when we shut down.  Because we didn't
    // know if a lock would affect stability around the register
    // call, we'll go ahead and register using a local handle.
    // If we don't have our global handle, then we'll set it to 
    // the local. Otherwise, we'll just clean up the local and 
    // pretend everything is fine.  MUP_LOCK macros are defined
    // at the top of this file.
    //

    if (MupHandle == 0) {
        Status = FsRtlRegisterUncProvider(
                     &LocalMupHandle,
                     &RdrName,
                     FALSE           // Do not support mailslots
                     );

        /** Lock **/

        ACQUIRE_MUP_LOCK();

        if (MupHandle) {

            RELEASE_MUP_LOCK();

            FsRtlDeregisterUncProvider( LocalMupHandle );
            return STATUS_SUCCESS;
        }
        else {
            MupHandle = LocalMupHandle;
        }

        /** Unlock **/

        RELEASE_MUP_LOCK();
    }

    return( Status );
}



VOID
DeregisterWithMup(
    VOID
    )
/*++

Routine Description:

    This routine deregisters this redirector as a UNC provider.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    if (MupHandle)
    {
        FsRtlDeregisterUncProvider( MupHandle );
        MupHandle = 0;
    }
}


NTSTATUS
QueryPath(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine verifies whether a path is a netware path.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PQUERY_PATH_REQUEST qpRequest;
    PQUERY_PATH_RESPONSE qpResponse;
    UNICODE_STRING FilePathName;
    ULONG OutputBufferLength;
    ULONG InputBufferLength;
    SECURITY_SUBJECT_CONTEXT SubjectContext;

    UNICODE_STRING DriveName;
    UNICODE_STRING ServerName;
    UNICODE_STRING VolumeName;
    UNICODE_STRING PathName;
    UNICODE_STRING FileName;
    UNICODE_STRING UnicodeUid;
    WCHAR DriveLetter;
    DWORD BaseRequestSize = FIELD_OFFSET(QUERY_PATH_REQUEST, FilePathName);

    NTSTATUS status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "QueryPath...\n", 0);
    
    ASSERT (( IOCTL_REDIR_QUERY_PATH & 3) == METHOD_NEITHER);

    RtlInitUnicodeString( &UnicodeUid, NULL );

    try {

        Irp = IrpContext->pOriginalIrp;
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
        InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

        //
        //  The input buffer is either in Irp->AssociatedIrp.SystemBuffer, or
        //  in the Type3InputBuffer for type 3 IRP's.
        //

        qpRequest = (PQUERY_PATH_REQUEST)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
        qpResponse = (PQUERY_PATH_RESPONSE)qpRequest;

        if ((qpRequest == NULL) || 
            (InputBufferLength < BaseRequestSize) || 
            (OutputBufferLength < sizeof(QUERY_PATH_RESPONSE))) {

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Probe before trying to read the request. This will make sure
        // we don't bugcheck when given a bogus address like 0xffff0000.
        //

        if ( Irp->RequestorMode != KernelMode ) {

            try {
                DWORD FullSize;
                DebugTrace(+1, Dbg, "QueryPath...Probing for Read 1\n", 0);

                ProbeForRead( qpRequest,
                              BaseRequestSize,
                              sizeof(ULONG)
                              );

                DebugTrace(+1, Dbg, "QueryPath...Probing for Read 2\n", 0);
            
                //
                //  Check for the full length of the request including
                //  the filename
                //

                FullSize = BaseRequestSize + qpRequest->PathNameLength;

                if (InputBufferLength < FullSize) {
                    try_return( status = STATUS_INVALID_PARAMETER );
                }

                ProbeForRead( qpRequest,
                              FullSize,
                              sizeof(ULONG)
                              );

            } except (EXCEPTION_EXECUTE_HANDLER) {
                  
                  return GetExceptionCode();
            }
        }

        try {
        
            FilePathName.Buffer = qpRequest->FilePathName;
            FilePathName.Length = (USHORT)qpRequest->PathNameLength;
    
            status = CrackPath( &FilePathName, &DriveName, &DriveLetter, &ServerName, &VolumeName, &PathName, &FileName, NULL );
    
            if (( !NT_SUCCESS( status ) ) ||
                ( ServerName.Length == 0 )) {
    
                try_return( status = STATUS_BAD_NETWORK_PATH );
            }
    
            qpResponse->LengthAccepted = VolumeName.Length;
    
            //
            //  As far as the redirector is concerned, QueryPath is a form
            //  of create. Set up the IrpContext appropriately.
            //
    
            IrpContext->Specific.Create.VolumeName = VolumeName;
            IrpContext->Specific.Create.PathName = PathName;
            IrpContext->Specific.Create.DriveLetter = DriveLetter;
            IrpContext->Specific.Create.FullPathName = FilePathName;
            IrpContext->Specific.Create.fExCredentialCreate = FALSE;
    
            RtlInitUnicodeString( &IrpContext->Specific.Create.UidConnectName, NULL );
    
            //
            // The irp context specific data is now zeroed out by AllocateIrpContext,
            // so we don't have to worry about re-setting the specific data here.
            //
    
            SeCaptureSubjectContext(&SubjectContext);
    
            IrpContext->Specific.Create.UserUid = GetUid( &SubjectContext );
    
            SeReleaseSubjectContext(&SubjectContext);
    
    
            //
            // The slightly more complicated approach.  This function
            // handles the resolution of the server/volume duple.  It
            // may use the bindery, cached nds information, or fresh
            // nds information.
            //

            status = HandleVolumeAttach( IrpContext,
                                         &ServerName,
                                         &VolumeName );

        } except( EXCEPTION_EXECUTE_HANDLER ) {
            status = STATUS_BAD_NETWORK_PATH;
        }

try_exit: NOTHING;

    } finally {

        RtlFreeUnicodeString(&UnicodeUid);
    }

    return( status );
}

NTSTATUS
UserNcp(
    ULONG IoctlCode,
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine exchanges an NCP with the server.

    TRACKING - We need to filter or security check what the user is
        doing.

Arguments:

    IoctlCode - Supplies the code to be used for the NCP.

    IrpContext - A pointer to IRP context information for this request.

Return Value:

    Status of transfer.

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PVOID OutputBuffer;
    ULONG OutputBufferLength;
    PCHAR InputBuffer;
    ULONG InputBufferLength;

    PICB icb;
    PSCB pScb;
    NODE_TYPE_CODE nodeTypeCode;
    PVOID fsContext;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    UCHAR Function = ANY_NCP_OPCODE( IoctlCode );
    UCHAR Subfunction = 0;

    irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    OutputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    InputBufferLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;

    DebugTrace(+1, DEBUG_TRACE_USERNCP, "UserNcp...\n", 0);
    DebugTrace( 0, DEBUG_TRACE_USERNCP, "irp  = %08lx\n", (ULONG_PTR)irp);

    //
    //  This F2 and ANY NCP must be addressed either to \Device\NwRdr or
    //  \Device\NwRdr\<servername> any additional name is not allowed.
    //  If the handle used for the Irp specifies \Device\NwRdr then the
    //  redirector gets to choose among the connected servers.
    //
    //  For HANDLE NCP the file must be an FCB.
    //

    nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                       &fsContext,
                                       (PVOID *)&icb );

    if ((nodeTypeCode == NW_NTC_ICB_SCB) &&
        (!IS_IT_NWR_ANY_HANDLE_NCP(IoctlCode))) {

        //  All ok

        //
        //  Make sure that this ICB is still active.
        //

        NwVerifyIcb( icb );

        pScb = (PSCB)icb->SuperType.Scb;
        nodeTypeCode = pScb->NodeTypeCode;

        IrpContext->pScb = pScb;
        IrpContext->pNpScb = IrpContext->pScb->pNpScb;

    } else if (nodeTypeCode == NW_NTC_ICB) {

        if ((IS_IT_NWR_ANY_HANDLE_NCP(IoctlCode)) &&
            (InputBufferLength < 7)) {

            //  Buffer needs enough space for the handle!
            DebugTrace(0, DEBUG_TRACE_USERNCP, "Not enough space for handle %x\n", InputBufferLength);

            status = STATUS_INVALID_PARAMETER;

            DebugTrace(-1, DEBUG_TRACE_USERNCP, "UserNcp -> %08lx\n", status );
            return status;
        }

        //
        //  Make sure that this ICB is still active.
        //  Let through FCB's and DCB's
        //

        NwVerifyIcb( icb );

        pScb = (PSCB)icb->SuperType.Fcb->Scb;
        nodeTypeCode = icb->SuperType.Fcb->NodeTypeCode;

        IrpContext->pScb = pScb;
        IrpContext->pNpScb = IrpContext->pScb->pNpScb;

        //
        // Set the icb pointer in case the cache gets
        // flushed because the write routines look at it.
        //

        IrpContext->Icb = icb;
        AcquireFcbAndFlushCache( IrpContext, icb->NpFcb );

    } else {

        DebugTrace(0, DEBUG_TRACE_USERNCP, "Incorrect nodeTypeCode %x\n", nodeTypeCode);
        DebugTrace(0, DEBUG_TRACE_USERNCP, "Incorrect nodeTypeCode %x\n", irpSp->FileObject);

        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, DEBUG_TRACE_USERNCP, "UserNcp -> %08lx\n", status );
        return status;
    }

    if (icb->Pid == INVALID_PID) {
        status = NwMapPid(pScb->pNpScb, (ULONG_PTR)PsGetCurrentThread(), &icb->Pid );

        if ( !NT_SUCCESS( status ) ) {
            return( status );
        }

        DebugTrace(-1, DEBUG_TRACE_USERNCP, "UserNcp Pid = %02lx\n", icb->Pid );
        NwSetEndOfJobRequired(pScb->pNpScb, icb->Pid);

    }

    //
    //  We now know where to send the NCP.  Lock down the users buffers and
    //  build the Mdls required to transfer the data.
    //

    InputBuffer = irpSp->Parameters.FileSystemControl.Type3InputBuffer;

    //
    // tommye - make sure the input buffer is valid
    //

    try {

        //
        // Probe for safety.
        //

        if ( irp->RequestorMode != KernelMode ) {

            ProbeForRead( InputBuffer,
                          InputBufferLength,
                          sizeof( CHAR ));
        }

        //
        //  Map the output buffer if there is one.
        //

        if ( OutputBufferLength ) {
            NwLockUserBuffer( irp, IoWriteAccess, OutputBufferLength );
            NwMapUserBuffer( irp, KernelMode, (PVOID *)&OutputBuffer );

            //
            // tommye MS bug 26590 / MCS 258
            //
            // NwMapUserBuffer may return a NULL OutputBuffer in low resource
            // situations; this was not being checked.  
            //

            if (OutputBuffer == NULL) {
                DebugTrace(-1, DEBUG_TRACE_USERNCP, "NwMapUserBuffer returned NULL OutputBuffer", 0);
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            OutputBuffer = NULL;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    //
    //  Update the original MDL record in the Irp context, since
    //  NwLockUserBuffer may have created a new MDL.
    //

    IrpContext->pOriginalMdlAddress = irp->MdlAddress;

    try {
        if (InputBufferLength != 0) {
            if (IS_IT_NWR_ANY_NCP(IoctlCode)) {
                Subfunction = InputBuffer[0];
            } else if (InputBufferLength >= 3) {
                Subfunction = InputBuffer[2];
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }


    DebugTrace( 0, DEBUG_TRACE_USERNCP, "UserNcp function = %x\n", Function );
    DebugTrace( 0, DEBUG_TRACE_USERNCP, "   & Subfunction = %x\n", Subfunction );
    dump( DEBUG_TRACE_USERNCP, InputBuffer, InputBufferLength );
    //dump( DEBUG_TRACE_USERNCP, OutputBuffer, OutputBufferLength );

    if ((Function == NCP_ADMIN_FUNCTION ) &&
        (InputBufferLength >= 4 )) {

        if ( ( (Subfunction == NCP_SUBFUNC_79) ||
               (Subfunction == NCP_CREATE_QUEUE_JOB ) ) &&
             icb->HasRemoteHandle) {

            //
            //  Trying to create a job on a queue that already has a job
            //  on it. Cancel the old job.
            //

            status = ExchangeWithWait(
                        IrpContext,
                        SynchronousResponseCallback,
                        "Sdw",
                        NCP_ADMIN_FUNCTION, NCP_CLOSE_FILE_AND_CANCEL_JOB,         // Close File And Cancel Queue Job
                        icb->SuperType.Fcb->Vcb->Specific.Print.QueueId,
                        icb->JobId );

            if (!NT_SUCCESS(status)) {

                DebugTrace( 0, DEBUG_TRACE_USERNCP, "DeleteOldJob got status -> %08lx\n", status );
                // Don't worry if the delete fails, proceed with the create
            }

            icb->IsPrintJob = FALSE;    // App will have to queue or cancel job, not rdr

        } else if ((Subfunction == NCP_PLAIN_TEXT_LOGIN ) ||
                   (Subfunction == NCP_ENCRYPTED_LOGIN )) {

            UNICODE_STRING UserName;
            OEM_STRING OemUserName;

            //
            //  Trying to do a login.
            //

            //
            //  Queue ourselves to the SCB, and wait to get to the front to
            //  protect access to server State.
            //

            NwAppendToQueueAndWait( IrpContext );

            //
            //  Assume success, store the user name in the SCB.
            //

            try {
                try {

                    OemUserName.Length = InputBuffer[ 13 ];
                    OemUserName.Buffer = &InputBuffer[14];

                    UserName.MaximumLength =  OemUserName.Length * sizeof(WCHAR);
                    if ( OemUserName.Length == 0 || OemUserName.Length > MAX_USER_NAME_LENGTH ) {
                        try_return( status = STATUS_NO_SUCH_USER );
                    }

                    UserName.Buffer = ALLOCATE_POOL_EX( NonPagedPool, UserName.MaximumLength );

                    //
                    //  Note the the Rtl function would set pUString->Buffer = NULL,
                    //  if OemString.Length is 0.
                    //

                    if ( OemUserName.Length != 0 ) {
                        status = RtlOemStringToCountedUnicodeString( &UserName, &OemUserName, FALSE );
                    } else {
                        UserName.Length = 0;
                    }
try_exit: NOTHING;
                } finally {
                    NOTHING;
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }

            if ( NT_SUCCESS( status )) {

                if ( pScb->OpenFileCount != 0  &&
                     pScb->pNpScb->State == SCB_STATE_IN_USE ) {

                    if (!RtlEqualUnicodeString( &pScb->UserName, &UserName, TRUE )) {

                        //
                        //  But were already logged in to this server and at
                        //  least one other handle is using the connection and
                        //  the user is trying to change the username.
                        //

                        FREE_POOL( UserName.Buffer );
                        return STATUS_NETWORK_CREDENTIAL_CONFLICT;

                    } else {

                        PUCHAR VerifyBuffer = ALLOCATE_POOL( PagedPool, InputBufferLength );

                        //
                        //  Same username. Validate password is correct.

                        if (VerifyBuffer == NULL) {
                            FREE_POOL( UserName.Buffer );
                            return STATUS_INSUFFICIENT_RESOURCES;
                        }

                        RtlCopyMemory( VerifyBuffer, InputBuffer, InputBufferLength );

                        if (IS_IT_NWR_ANY_NCP(IoctlCode)) {
                            VerifyBuffer[0] = (Subfunction == NCP_PLAIN_TEXT_LOGIN ) ?
                                                NCP_PLAIN_TEXT_VERIFY_PASSWORD:
                                                NCP_ENCRYPTED_VERIFY_PASSWORD;

                        } else {
                            VerifyBuffer[2] = (Subfunction == NCP_PLAIN_TEXT_LOGIN ) ?
                                                NCP_PLAIN_TEXT_VERIFY_PASSWORD:
                                                NCP_ENCRYPTED_VERIFY_PASSWORD;
                        }

                        status = ExchangeWithWait(
                                    IrpContext,
                                    SynchronousResponseCallback,
                                    IS_IT_NWR_ANY_NCP(IoctlCode)? "Sr":"Fbr",
                                    Function, VerifyBuffer[0],
                                    &VerifyBuffer[1], InputBufferLength - 1 );

                        FREE_POOL( UserName.Buffer );
                        FREE_POOL( VerifyBuffer );
                        return status;

                    }
                }

                if (pScb->UserName.Buffer) {
                    FREE_POOL( pScb->UserName.Buffer );  // May include space for password too.
                }

                IrpContext->pNpScb->pScb->UserName = UserName;
                IrpContext->pNpScb->pScb->Password.Buffer = UserName.Buffer;
                IrpContext->pNpScb->pScb->Password.Length = 0;

            } else {
                return( status );
            }
        }
    } else if (Function == NCP_LOGOUT ) {

        //
        //  Queue ourselves to the SCB, and wait to get to the front to
        //  protect access to server State.
        //

        NwAppendToQueueAndWait( IrpContext );

        if ( pScb->OpenFileCount == 0 &&
             pScb->pNpScb->State == SCB_STATE_IN_USE &&
             !pScb->PreferredServer ) {

            NwLogoffAndDisconnect( IrpContext, pScb->pNpScb);
            return STATUS_SUCCESS;

        } else {

            return(STATUS_CONNECTION_IN_USE);

        }
    }

    IrpContext->Icb = icb;

    //
    //  Remember where the response goes.
    //

    IrpContext->Specific.FileSystemControl.Buffer = OutputBuffer;
    IrpContext->Specific.FileSystemControl.Length = OutputBufferLength;

    IrpContext->Specific.FileSystemControl.Function = Function;
    IrpContext->Specific.FileSystemControl.Subfunction = Subfunction;

    //
    //  Decide how to send the buffer.  If it is small enough, send it
    //  by copying the user buffer to our send buffer.  If it is bigger
    //  we will need to build an MDL for the user's buffer, and used a
    //  chained send.
    //

    if ( InputBufferLength == 0 ) {

        //  Simple request such as systime.exe

        IrpContext->Specific.FileSystemControl.InputMdl = NULL;

        status = Exchange(
                     IrpContext,
                     UserNcpCallback,
                     "F", Function);

    } else if ( InputBufferLength < MAX_SEND_DATA - sizeof( NCP_REQUEST ) - 2 ) {

        //
        //  Send the request by copying it to our send buffer.
        //

        IrpContext->Specific.FileSystemControl.InputMdl = NULL;

        if (!IS_IT_NWR_ANY_HANDLE_NCP(IoctlCode)) {

            //
            //  E0, E1, E2 and E3 get mapped to 14,15,16 and 17. These need
            //  a length word before the buffer.
            //

            try {
                status = Exchange(
                            IrpContext,
                            UserNcpCallback,
                            IS_IT_NWR_ANY_NCP(IoctlCode)? "Sr":"Fbr",
                            Function, InputBuffer[0],
                            &InputBuffer[1], InputBufferLength - 1 );
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }
        } else {

            //
            //  Replace the 6 bytes of InputBuffer starting at offset 1
            //  with the 6 byte NetWare address for this icb. This request
            //  is used in some of the 16 bit NCP's used for file locking.
            //  These requests are always fairly small.
            //

            if (!icb->HasRemoteHandle) {
                return STATUS_INVALID_HANDLE;
            }

            try {
                status = Exchange(
                            IrpContext,
                            UserNcpCallback,
                            "Fbrr",
                            Function,
                            InputBuffer[0],
                            &icb->Handle, sizeof(icb->Handle),
                            &InputBuffer[7], InputBufferLength - 7 );
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }
        }

    } else {

        PMDL pMdl = NULL;

        if (IS_IT_NWR_ANY_HANDLE_NCP(IoctlCode)) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        //  We need to chain send the request.  Allocate an MDL.
        //

        try {
            try {
                pMdl = ALLOCATE_MDL(
                            &InputBuffer[1],
                            InputBufferLength - 1,
                            TRUE,     //  Secondary MDL
                            TRUE,     //  Charge quota
                            NULL );

                if ( pMdl == NULL ) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

                MmProbeAndLockPages( pMdl, irp->RequestorMode, IoReadAccess );

                //
                //  Remember the MDL so we can free it.
                //

                IrpContext->Specific.FileSystemControl.InputMdl = pMdl;

                //
                //  Send the request.
                //

                status = Exchange(
                            IrpContext,
                            UserNcpCallback,
                            IS_IT_NWR_ANY_NCP(IoctlCode)? "Sf":"Fbf",
                            Function, InputBuffer[0],
                            pMdl );
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }

        } finally {

            if ((status != STATUS_PENDING ) &&
                ( pMdl != NULL)) {

                FREE_MDL( pMdl );

            }
        }
    }

    DebugTrace(-1, DEBUG_TRACE_USERNCP, "UserNcp -> %08lx\n", status );
    return status;
}



NTSTATUS
UserNcpCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )

/*++

Routine Description:

    This routine receives the response from a user NCP.

Arguments:


Return Value:

    VOID

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID Buffer;
    ULONG BufferLength;
    PIRP Irp;
    ULONG Length;
    PICB Icb = IrpContext->Icb;
    PEPresponse *pResponseParameters;

    DebugTrace(0, DEBUG_TRACE_USERNCP, "UserNcpCallback...\n", 0);

    if ( IrpContext->Specific.FileSystemControl.InputMdl != NULL ) {
        MmUnlockPages( IrpContext->Specific.FileSystemControl.InputMdl );
        FREE_MDL( IrpContext->Specific.FileSystemControl.InputMdl );
    }

    if ( BytesAvailable == 0) {

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

        NwDequeueIrpContext( IrpContext, FALSE );
        NwCompleteRequest( IrpContext, STATUS_REMOTE_NOT_LISTENING );

        return STATUS_REMOTE_NOT_LISTENING;
    }

    dump( DEBUG_TRACE_USERNCP, Response, BytesAvailable );

    Buffer = IrpContext->Specific.FileSystemControl.Buffer;
    BufferLength = IrpContext->Specific.FileSystemControl.Length;

    //
    // Get the data from the response.
    //

    Length = MIN( BufferLength, BytesAvailable - 8 );

    if (IrpContext->Specific.FileSystemControl.Function == NCP_ADMIN_FUNCTION ) {

        if (IrpContext->Specific.FileSystemControl.Subfunction == NCP_SUBFUNC_79) {

            //
            //  Create Queue Job and File Ncp. If the operation was a success
            //  then we need to save the handle. This will allow Write Irps
            //  on this Icb to be sent to the server.
            //

            Status = ParseResponse(
                              IrpContext,
                              Response,
                              BytesAvailable,
                              "N_r",
                              0x3E,
                              Icb->Handle+2,4);

            //  Pad the handle to its full 6 bytes.
            Icb->Handle[0] = 0;
            Icb->Handle[1] = 0;

            if (NT_SUCCESS(Status)) {
                Icb->HasRemoteHandle = TRUE;
            }

            //
            //  Reset the file offset.
            //

            Icb->FileObject->CurrentByteOffset.QuadPart = 0;

        } else if (IrpContext->Specific.FileSystemControl.Subfunction == NCP_CREATE_QUEUE_JOB ) {

            //
            //  Create Queue Job and File Ncp. If the operation was a success
            //  then we need to save the handle. This will allow Write Irps
            //  on this Icb to be sent to the server.
            //

            Status = ParseResponse(
                              IrpContext,
                              Response,
                              BytesAvailable,
                              "N_r",
                              0x2A,
                              Icb->Handle,6);

            if (NT_SUCCESS(Status)) {
                Icb->HasRemoteHandle = TRUE;
            }

            //
            //  Reset the file offset.
            //

            Icb->FileObject->CurrentByteOffset.QuadPart = 0;

        } else if ((IrpContext->Specific.FileSystemControl.Subfunction == NCP_SUBFUNC_7F) ||
                   (IrpContext->Specific.FileSystemControl.Subfunction == NCP_CLOSE_FILE_AND_START_JOB )) {

            //  End Job request

            Icb->HasRemoteHandle = FALSE;

        } else if ((IrpContext->Specific.FileSystemControl.Subfunction == NCP_PLAIN_TEXT_LOGIN ) ||
                   (IrpContext->Specific.FileSystemControl.Subfunction == NCP_ENCRYPTED_LOGIN )) {

            //
            //  Trying to do a login from a 16 bit application.
            //

            Status = ParseResponse(
                         IrpContext,
                         Response,
                         BytesAvailable,
                         "N" );

            if ( NT_SUCCESS( Status ) ) {


                //
                // Set the reconnect attempt flag so that we don't try to
                // run this irp context through the reconnect logic.  Doing
                // this could deadlock the worker thread that's handling this
                // fsp side request.
                //

                SetFlag( IrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT );
                IrpContext->PostProcessRoutine = FspCompleteLogin;
                Status = NwPostToFsp( IrpContext, TRUE );
                return Status;

            } else {
                if (IrpContext->pNpScb->pScb->UserName.Buffer) {
                   FREE_POOL( IrpContext->pNpScb->pScb->UserName.Buffer );
                }
                RtlInitUnicodeString( &IrpContext->pNpScb->pScb->UserName, NULL);
                RtlInitUnicodeString( &IrpContext->pNpScb->pScb->Password, NULL);
            }
        }
    }

    pResponseParameters = (PEPresponse *)( ((PEPrequest *)Response) + 1);

    ParseResponse( IrpContext, Response, BytesAvailable, "Nr", Buffer, Length );

    Status = ( ( pResponseParameters->status &
                 ( NCP_STATUS_BAD_CONNECTION |
                   NCP_STATUS_NO_CONNECTIONS |
                   NCP_STATUS_SERVER_DOWN  ) )  << 8 ) |
             pResponseParameters->error;

    if ( Status ) {
        //
        //  Use the special error code that will cause conversion
        //  of the status back to a Dos error code to leave status and
        //  error unchanged. This is necessary because many of the
        //  NetWare error codes have different meanings depending on the
        //  operation being performed.
        //

        Status |= 0xc0010000;
    }

    Irp = IrpContext->pOriginalIrp;
    Irp->IoStatus.Information = Length;

    //
    //  We're done with this request.  Dequeue the IRP context from
    //  SCB and complete the request.
    //

    NwDequeueIrpContext( IrpContext, FALSE );
    NwCompleteRequest( IrpContext, Status );

    return STATUS_SUCCESS;

}


NTSTATUS
FspCompleteLogin(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine reopens any Vcb directory handles.
    It also sets the Scb as in use. This could have been done
    in the callback routine too.

Arguments:

    None.

Return Value:

    NTSTATUS - The status of the operation.

--*/
{

    IrpContext->pNpScb->State = SCB_STATE_IN_USE;

    ReconnectScb( IrpContext, IrpContext->pScb );

    return STATUS_SUCCESS;
}


NTSTATUS
GetConnection(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine returns the path of a connection.

Arguments:

    None.

Return Value:

    NTSTATUS - The status of the operation.

--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PNWR_SERVER_RESOURCE OutputBuffer;
    PNWR_REQUEST_PACKET InputBuffer;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    PVCB Vcb;
    PWCH DriveName;
    ULONG DriveNameLength;
    PVCB * DriveMapTable;         
    SECURITY_SUBJECT_CONTEXT SubjectContext;

    PAGED_CODE();

    DebugTrace(0, Dbg, "GetConnection...\n", 0);
    Irp = IrpContext->pOriginalIrp;
    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    InputBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    if ( InputBufferLength < (ULONG)FIELD_OFFSET( NWR_REQUEST_PACKET, Parameters.GetConn.DeviceName[1] ) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    Status = STATUS_SUCCESS;

    //---Multi user----
    // Need to get the Uid in order to find the proper DriveMapTable
    // 
    SeCaptureSubjectContext(&SubjectContext);
    DriveMapTable = GetDriveMapTable( GetUid( &SubjectContext ) );
    SeReleaseSubjectContext(&SubjectContext);
    //-----

    //
    //  Find the VCB
    //

    try {
    
        if ( Irp->RequestorMode != KernelMode ) {

            ProbeForRead( InputBuffer,
                          InputBufferLength,
                          sizeof(CHAR)
                          );
        }

        DriveName = InputBuffer->Parameters.GetConn.DeviceName;
        DriveNameLength = InputBuffer->Parameters.GetConn.DeviceNameLength;
        Vcb = NULL;

        //
        // check the device name length to see if its sound. This subtraction can't underflow because of the tests above
        //

        if ( DriveNameLength > InputBufferLength - FIELD_OFFSET( NWR_REQUEST_PACKET, Parameters.GetConn.DeviceName)  ) {

            return STATUS_INVALID_PARAMETER;
        }

        if ( DriveName[0] >= L'A' && DriveName[0] <= L'Z' &&
             DriveName[1] == L':' &&
             DriveNameLength == sizeof( L"X:" ) - sizeof( L'\0' ) ) {

            Vcb = DriveMapTable[DriveName[0] - 'A'];

        } else if ( _wcsnicmp( DriveName, L"LPT", 3 ) == 0 &&
                    DriveName[3] >= '1' && DriveName[3] <= '9' &&
                    DriveNameLength == sizeof( L"LPTX" ) - sizeof( L'\0' ) ) {

            Vcb = DriveMapTable[MAX_DISK_REDIRECTIONS + DriveName[3] - '1'];
        }
    
    
        if ( Vcb == NULL) {

            return STATUS_NO_SUCH_FILE;
        }
    
        
        OutputBuffer = (PNWR_SERVER_RESOURCE)Irp->UserBuffer;
        OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

        if (OutputBufferLength < Vcb->Path.Length + 2 * sizeof(WCHAR)) {
            InputBuffer->Parameters.GetConn.BytesNeeded =
                Vcb->Path.Length + 2 * sizeof(WCHAR);

            return STATUS_BUFFER_TOO_SMALL;
        }
    
        //
        // Probe to ensure that the buffer is kosher.
        //

        if ( Irp->RequestorMode != KernelMode ) {
    
            ProbeForWrite( OutputBuffer,
                           OutputBufferLength,
                           sizeof(CHAR)
                          );
        }
        
        //
        //  Return the Connection name in the form \\server\share<NUL>
        //
    
        OutputBuffer->UncName[0] = L'\\';
    
        RtlMoveMemory(
            &OutputBuffer->UncName[1],
            Vcb->Path.Buffer,
            Vcb->Path.Length );
    
        OutputBuffer->UncName[ (Vcb->Path.Length + sizeof(WCHAR)) / sizeof(WCHAR) ] = L'\0';
    
        Irp->IoStatus.Information = Vcb->Path.Length + 2 * sizeof(WCHAR);
   
    
    } except (EXCEPTION_EXECUTE_HANDLER) {

          return GetExceptionCode();
    }

    return( Status );
}


NTSTATUS
DeleteConnection(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine returns removes a connection if force is specified or
    if there are no open handles on this Vcb.

Arguments:

    None.

Return Value:

    NTSTATUS - The status of the operation.

--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PNWR_REQUEST_PACKET InputBuffer;
    ULONG InputBufferLength;
    PICB Icb;
    PVCB Vcb;
    PDCB Dcb;
    PNONPAGED_DCB NonPagedDcb;
    NODE_TYPE_CODE NodeTypeCode;

    PAGED_CODE();

    DebugTrace(0, Dbg, "DeleteConnection...\n", 0);
    Irp = IrpContext->pOriginalIrp;
    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    InputBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    if ( InputBufferLength < (ULONG)FIELD_OFFSET( NWR_REQUEST_PACKET, Parameters.GetConn.DeviceName[1] ) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    Status = STATUS_SUCCESS;

    //
    //  Wait to get to the head of the SCB queue.   We do this in case
    //  we need to disconnect, so that we can send packets with the RCB
    //  resource held.
    //

    NodeTypeCode = NwDecodeFileObject( IrpSp->FileObject, &NonPagedDcb, &Icb );

    if ( NodeTypeCode == NW_NTC_ICB_SCB ) {
        IrpContext->pNpScb = Icb->SuperType.Scb->pNpScb;
    } else if ( NodeTypeCode == NW_NTC_ICB ) {
        IrpContext->pNpScb = Icb->SuperType.Fcb->Scb->pNpScb;
        Dcb = NonPagedDcb->Fcb;
    } else {
        return( STATUS_INVALID_PARAMETER );
    }

    NwAppendToQueueAndWait( IrpContext );
    ClearFlag( IrpContext->Flags, IRP_FLAG_RECONNECTABLE );

    //
    // Acquire exclusive access to the RCB.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    try {

        //
        // Get the a referenced pointer to the node and make sure it is
        // not being closed, and that it is a directory handle.
        //

        if ( NodeTypeCode == NW_NTC_ICB_SCB ) {


            if ( Icb->IsTreeHandle ) {

                //
                // Do an NDS logoff.  This will release the RCB.
                //

                Status = NdsLogoff( IrpContext );
                DebugTrace( 0, Dbg, "Nds tree logoff -> %08lx\n", Status );

            } else {

                DebugTrace( 0, Dbg, "Delete connection to SCB %X\n", Icb->SuperType.Scb );

                Status = TreeDisconnectScb( IrpContext, Icb->SuperType.Scb );
                DebugTrace(-1, Dbg, "DeleteConnection -> %08lx\n", Status );

            }

            try_return( NOTHING );

        } else if ( NodeTypeCode != NW_NTC_ICB ||
                    Dcb == NULL ||
                    ( Dcb->NodeTypeCode != NW_NTC_DCB &&
                      Dcb->NodeTypeCode != NW_NTC_FCB) ) {

            DebugTrace(0, Dbg, "Invalid file handle\n", 0);

            Status = STATUS_INVALID_HANDLE;

            DebugTrace(-1, Dbg, "DeleteConnection -> %08lx\n", Status );
            try_return( NOTHING );
        }

        //
        //  Make sure that this ICB is still active.
        //

        NwVerifyIcb( Icb );

        Vcb = Dcb->Vcb;
        DebugTrace(0, Dbg, "Attempt to delete VCB = %08lx\n", Vcb);

        //
        //  Vcb->OpenFileCount will be 1, (to account for this DCB), if the
        //  connection can be deleted.
        //

        if ( !BooleanFlagOn( Vcb->Flags, VCB_FLAG_EXPLICIT_CONNECTION ) ) {
            DebugTrace(0, Dbg, "Cannot delete unredireced connection\n", 0);
            try_return( Status = STATUS_INVALID_DEVICE_REQUEST );
        } else {

            if ( Vcb->OpenFileCount > 1 ) {
                DebugTrace(0, Dbg, "Cannot delete in use connection\n", 0);
                Status = STATUS_CONNECTION_IN_USE;
            } else {

                //
                //  To delete the VCB, simply dereference it.
                //

                DebugTrace(0, Dbg, "Deleting connection\n", 0);

                ClearFlag( Vcb->Flags, VCB_FLAG_EXPLICIT_CONNECTION );
                --Vcb->Scb->OpenFileCount;

                NwDereferenceVcb( Vcb, IrpContext, TRUE );
            }
        }

    try_exit: NOTHING;

    } finally {


        //
        // An NDS logoff will have already freed the RCB
        // and dequeued the irp context.
        //

        if ( ! ( Icb->IsTreeHandle ) ) {
            NwReleaseRcb( &NwRcb );
            NwDequeueIrpContext( IrpContext, FALSE );
        }


    }

    Irp->IoStatus.Information = 0;

    return( Status );
}



NTSTATUS
EnumConnections(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine returns the list of redirector connections.

Arguments:

    IrpContext - A pointer to the IRP Context block for this request.

Return Value:

    NTSTATUS - The status of the operation.

--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PNWR_SERVER_RESOURCE OutputBuffer;
    PNWR_REQUEST_PACKET InputBuffer;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    PVCB Vcb;
    PSCB Scb;
    BOOLEAN OwnRcb;

    UNICODE_STRING LocalName;
    WCHAR PrintPlaceHolder[] = L"LPT1";
    WCHAR DiskPlaceHolder[] = L"A:";

    UNICODE_STRING ContainerName;
    PCHAR FixedPortion;
    PWCHAR EndOfVariableData;
    ULONG EntrySize;
    ULONG_PTR OrigResumeKey;
    ULONG_PTR NewResumeKey;

    ULONG ShareType;
    ULONG EntriesRead = 0;
    ULONG EntriesRequested;
    ULONG ConnectionType;

    PLIST_ENTRY ListEntry;
    UNICODE_STRING Path;

    SECURITY_SUBJECT_CONTEXT SubjectContext;
    LARGE_INTEGER Uid;

    DebugTrace(0, Dbg, "EnumConnections...\n", 0);

    Irp = IrpContext->pOriginalIrp;
    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    InputBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    if ( InputBufferLength < (ULONG)FIELD_OFFSET( NWR_REQUEST_PACKET, Parameters.EnumConn.BytesNeeded ) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // tommye - MS bug 32155
    // Added ProbeForRead to check input buffers.
    // OutputBuffer has been probed by caller.
    //

    try {

        //
        // Probe for safety.
        //

        if ( Irp->RequestorMode != KernelMode ) {

            ProbeForRead( InputBuffer,
                          InputBufferLength,
                          sizeof( CHAR ));
        }
        ConnectionType = InputBuffer->Parameters.EnumConn.ConnectionType;


        OutputBuffer = (PNWR_SERVER_RESOURCE)Irp->UserBuffer;
        OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

        //
        // Probe to ensure that the buffer is kosher.
        //

        if ( Irp->RequestorMode != KernelMode ) {
    
            ProbeForWrite( OutputBuffer,
                           OutputBufferLength,
                           sizeof(CHAR));
        }

        // ---- Multiuser ---
        // Get the Uid if passed from above
        if ( ConnectionType & CONNTYPE_UID ) {
            Uid = *(PLARGE_INTEGER)(&InputBuffer->Parameters.EnumConn.Uid);
        }

        EntriesRequested = InputBuffer->Parameters.EnumConn.EntriesRequested;

        OrigResumeKey = InputBuffer->Parameters.EnumConn.ResumeKey;
        NewResumeKey = OrigResumeKey;

        DebugTrace(0, Dbg, "Starting resume key is %d\n", OrigResumeKey );

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    Status = STATUS_SUCCESS;
    // ---- Multiuser ---
    // Get the Uid if we don't have it yet
    if (!(ConnectionType & CONNTYPE_UID)) {

        SeCaptureSubjectContext(&SubjectContext);
        Uid = GetUid( &SubjectContext );
        SeReleaseSubjectContext(&SubjectContext);

    }

    try {

        //
        //  Acquire shared access to the drive map table.
        //

        NwAcquireSharedRcb( &NwRcb, TRUE );
        OwnRcb = TRUE;

        //
        // Initialize returned strings
        //

        RtlInitUnicodeString( &ContainerName, L"\\" );

        FixedPortion = (PCHAR) OutputBuffer;
        EndOfVariableData = (PWCHAR) ((ULONG_PTR) FixedPortion + OutputBufferLength);

        //
        //  Run through the global VCB list looking for redirections.
        //

        for ( ListEntry = GlobalVcbList.Flink;
              ListEntry != &GlobalVcbList &&
              EntriesRequested > EntriesRead &&
              Status == STATUS_SUCCESS ;
              ListEntry = ListEntry->Flink ) {

            Vcb = CONTAINING_RECORD( ListEntry, VCB, GlobalVcbListEntry );

            //
            // Skip connections that we've already enumerated.
            //

            if ( Vcb->SequenceNumber <= OrigResumeKey ) {
                continue;
            }

            /* ---- Multi-user ----
             * Skip connections that are not ours
             */
            if ( Vcb->Scb->UserUid.QuadPart != Uid.QuadPart )
                continue;

            //
            // Skip implicit connections, if they are not requested.
            //

            if ( !(ConnectionType & CONNTYPE_IMPLICIT) &&
                 !BooleanFlagOn( Vcb->Flags, VCB_FLAG_EXPLICIT_CONNECTION )) {

                continue;
            }

            //
            // Skip connections that are not requested.
            //
            if (BooleanFlagOn( Vcb->Flags, VCB_FLAG_PRINT_QUEUE )) {
                if ( !( ConnectionType & CONNTYPE_PRINT ))
                    continue;
            } else {
                if ( !( ConnectionType & CONNTYPE_DISK ))
                    continue;
            }


            if ( Vcb->DriveLetter != 0 ) {
                if (BooleanFlagOn( Vcb->Flags, VCB_FLAG_PRINT_QUEUE )) {
                    RtlInitUnicodeString( &LocalName, (PCWSTR) PrintPlaceHolder );
                    LocalName.Buffer[3] = Vcb->DriveLetter;
                    ShareType = RESOURCETYPE_PRINT;
                } else {
                    RtlInitUnicodeString( &LocalName, (PCWSTR) DiskPlaceHolder );
                    LocalName.Buffer[0] = Vcb->DriveLetter;
                    ShareType = RESOURCETYPE_DISK;
                }
            } else {   // No drive letter connection, i.e. UNC Connection
                if (BooleanFlagOn( Vcb->Flags, VCB_FLAG_PRINT_QUEUE ))
                    ShareType = RESOURCETYPE_PRINT;
                else
                    ShareType = RESOURCETYPE_DISK;
            }

            if ( Vcb->DriveLetter >= L'A' && Vcb->DriveLetter <= L'Z' ) {
                Path.Buffer = Vcb->Name.Buffer + 3;
                Path.Length = Vcb->Name.Length - 6;
            } else if ( Vcb->DriveLetter >= L'1' && Vcb->DriveLetter <= L'9' ) {
                Path.Buffer = Vcb->Name.Buffer + 5;
                Path.Length = Vcb->Name.Length - 10;
            } else {
                Path = Vcb->Name;
            }

            // Strip off the unicode prefix

            Path.Buffer += Vcb->Scb->UnicodeUid.Length/sizeof(WCHAR);
            Path.Length -= Vcb->Scb->UnicodeUid.Length;
            Path.MaximumLength -= Vcb->Scb->UnicodeUid.Length;

            try {
                Status = WriteNetResourceEntry(
                            &FixedPortion,
                            &EndOfVariableData,
                            &ContainerName,
                            Vcb->DriveLetter != 0 ? &LocalName : NULL,
                            &Path,
                            RESOURCE_CONNECTED,
                            RESOURCEDISPLAYTYPE_SHARE,
                            RESOURCEUSAGE_CONNECTABLE,
                            ShareType,
                            &EntrySize
                            );

            } except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();

            }

            if ( Status == STATUS_MORE_ENTRIES ) {

                //
                // Could not write current entry into output buffer.
                //

                try {

                    InputBuffer->Parameters.EnumConn.BytesNeeded = EntrySize;

                } except (EXCEPTION_EXECUTE_HANDLER) {

                    Status = GetExceptionCode();

                }

            } else if ( Status == STATUS_SUCCESS ) {

                //
                // Note that we've returned the current entry.
                //

                EntriesRead++;
                NewResumeKey = Vcb->SequenceNumber;

                DebugTrace(0, Dbg, "Returning VCB %08lx\n", Vcb );
                DebugTrace(0, Dbg, "Sequence # is %08lx\n", NewResumeKey );
            }
        }

        //
        //  Return the Servers we are connected to. This is most important for
        //  support of NetWare aware 16 bit apps.
        //

        if ((ConnectionType & CONNTYPE_IMPLICIT) &&
            ( ConnectionType & CONNTYPE_DISK )) {

            KIRQL OldIrql;
            PNONPAGED_SCB pNpScb;
            PLIST_ENTRY NextScbQueueEntry;
            ULONG EnumSequenceNumber = 0x80000000;

            NwReleaseRcb( &NwRcb );
            OwnRcb = FALSE;

            RtlInitUnicodeString( &ContainerName, L"\\\\" );

            KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

            for ( ListEntry = ScbQueue.Flink;
                  ListEntry != &ScbQueue &&
                  EntriesRequested > EntriesRead &&
                  Status == STATUS_SUCCESS ;
                  ListEntry = NextScbQueueEntry ) {

                pNpScb = CONTAINING_RECORD( ListEntry, NONPAGED_SCB, ScbLinks );
                Scb = pNpScb->pScb;

                NwReferenceScb( pNpScb );

                KeReleaseSpinLock(&ScbSpinLock, OldIrql);

                //
                // Skip connections that we've already enumerated.
                //

                if (( EnumSequenceNumber <= OrigResumeKey ) ||
                   // ---Mutl-user ---
                   // Skip over not ours
                   ( ( Scb != NULL ) && ( Scb->UserUid.QuadPart != Uid.QuadPart ) ) ||
                    ( pNpScb == &NwPermanentNpScb ) ||

                    (( pNpScb->State != SCB_STATE_LOGIN_REQUIRED ) &&
                     ( pNpScb->State != SCB_STATE_IN_USE ))) {

                    //
                    //  Move to next entry in the list
                    //

                    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
                    NextScbQueueEntry = pNpScb->ScbLinks.Flink;
                    NwDereferenceScb( pNpScb );
                    EnumSequenceNumber++;
                    continue;
                }

                DebugTrace( 0, Dbg, " EnumConnections returning Servername = %wZ\n", &pNpScb->ServerName   );

                try {
                    Status = WriteNetResourceEntry(
                                &FixedPortion,
                                &EndOfVariableData,
                                &ContainerName,
                                NULL,
                                &pNpScb->ServerName,
                                RESOURCE_CONNECTED,
                                RESOURCEDISPLAYTYPE_SHARE,
                                RESOURCEUSAGE_CONNECTABLE,
                                RESOURCETYPE_DISK,
                                &EntrySize
                                );
                }
                except (EXCEPTION_EXECUTE_HANDLER) {

                    Status = GetExceptionCode();
                }

                if ( Status == STATUS_MORE_ENTRIES ) {

                    //
                    // Could not write current entry into output buffer.
                    //

                    try {
                        InputBuffer->Parameters.EnumConn.BytesNeeded = EntrySize;
                    }
                    except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = GetExceptionCode();
                    }

                } else if ( Status == STATUS_SUCCESS ) {

                    //
                    // Note that we've returned the current entry.
                    //

                    EntriesRead++;
                    NewResumeKey = EnumSequenceNumber;

                    DebugTrace(0, Dbg, "Returning SCB %08lx\n", Scb );
                    DebugTrace(0, Dbg, "Sequence # is %08lx\n", NewResumeKey );
                }

                //
                //  Move to next entry in the list
                //

                KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
                NextScbQueueEntry = pNpScb->ScbLinks.Flink;
                NwDereferenceScb( pNpScb );
                EnumSequenceNumber++;
            }

            KeReleaseSpinLock(&ScbSpinLock, OldIrql);
        }

        try {
            InputBuffer->Parameters.EnumConn.EntriesReturned = EntriesRead;
            InputBuffer->Parameters.EnumConn.ResumeKey = NewResumeKey;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }

        if ( EntriesRead == 0 ) {

            if (Status == STATUS_SUCCESS) {
                Status = STATUS_NO_MORE_ENTRIES;
            }

            Irp->IoStatus.Information = 0;
        }
        else {
            Irp->IoStatus.Information = OutputBufferLength;
        }

    } finally {
        if (OwnRcb) {
            NwReleaseRcb( &NwRcb );
        }
    }

    return( Status );
}



NTSTATUS
WriteNetResourceEntry(
    IN OUT PCHAR *FixedPortion,
    IN OUT PWCHAR *EndOfVariableData,
    IN PUNICODE_STRING ContainerName OPTIONAL,
    IN PUNICODE_STRING LocalName OPTIONAL,
    IN PUNICODE_STRING RemoteName,
    IN ULONG ScopeFlag,
    IN ULONG DisplayFlag,
    IN ULONG UsageFlag,
    IN ULONG ShareType,
    OUT PULONG EntrySize
    )
/*++

Routine Description:

    This function packages a NETRESOURCE entry into the user output buffer.

Arguments:

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated to point to the next fixed portion entry
        after a NETRESOURCE entry is written.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the
        user information is written into the output buffer starting from
        the end.

        This pointer is updated after any variable length information is
        written to the output buffer.

    ContainerName - Supplies the full path qualifier to make RemoteName
        a full UNC name.

    LocalName - Supplies the local device name, if any.

    RemoteName - Supplies the remote resource name.

    ScopeFlag - Supplies the flag which indicates whether this is a
        CONNECTED or GLOBALNET resource.

    DisplayFlag - Supplies the flag which tells the UI how to display
        the resource.

    UsageFlag - Supplies the flag which indicates that the RemoteName
        is either a container or a connectable resource or both.

    ShareType - Type of the share connected to, RESOURCETYPE_PRINT or
        RESOURCETYPE_DISK

    EntrySize - Receives the size of the NETRESOURCE entry in bytes.

Return Value:

    STATUS_SUCCESS - Successfully wrote entry into user buffer.

    STATUS_NO_MEMORY - Failed to allocate work buffer.

    STATUS_MORE_ENTRIES - Buffer was too small to fit entry.

--*/
{
    BOOL FitInBuffer = TRUE;
    LPNETRESOURCEW NetR = (LPNETRESOURCEW) *FixedPortion;
    UNICODE_STRING TmpRemote;

    PAGED_CODE();

    *EntrySize = sizeof(NETRESOURCEW) +
                 RemoteName->Length + NwProviderName.Length + 2 * sizeof(WCHAR);

    if (ARGUMENT_PRESENT(LocalName)) {
        *EntrySize += LocalName->Length + sizeof(WCHAR);
    }

    if (ARGUMENT_PRESENT(ContainerName)) {
        *EntrySize += ContainerName->Length;
    }

    //
    // See if buffer is large enough to fit the entry.
    //
    if (((ULONG_PTR) *FixedPortion + *EntrySize) >
         (ULONG_PTR) *EndOfVariableData) {

        return STATUS_MORE_ENTRIES;
    }

    NetR->dwScope = ScopeFlag;
    NetR->dwType = ShareType;
    NetR->dwDisplayType = DisplayFlag;
    NetR->dwUsage = UsageFlag;
    NetR->lpComment = NULL;

    //
    // Update fixed entry pointer to next entry.
    //
    (ULONG_PTR) (*FixedPortion) += sizeof(NETRESOURCEW);

    //
    // RemoteName
    //
    if (ARGUMENT_PRESENT(ContainerName)) {

        //
        // Prefix the RemoteName with its container name making the
        // it a fully-qualified UNC name.
        //

        TmpRemote.MaximumLength = RemoteName->Length + ContainerName->Length + sizeof(WCHAR);
        TmpRemote.Buffer = ALLOCATE_POOL(
                               PagedPool,
                               RemoteName->Length + ContainerName->Length + sizeof(WCHAR)
                               );

        if (TmpRemote.Buffer == NULL) {
            return STATUS_NO_MEMORY;
        }

        RtlCopyUnicodeString(&TmpRemote, ContainerName);
        RtlAppendUnicodeStringToString(&TmpRemote, RemoteName);
    }
    else {
        TmpRemote = *RemoteName;
    }

    FitInBuffer = CopyStringToBuffer(
                      TmpRemote.Buffer,
                      TmpRemote.Length / sizeof(WCHAR),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &NetR->lpRemoteName
                      );

    if (ARGUMENT_PRESENT(ContainerName)) {
        FREE_POOL(TmpRemote.Buffer);
    }

    ASSERT(FitInBuffer);

    //
    // LocalName
    //
    if (ARGUMENT_PRESENT(LocalName)) {
        FitInBuffer = CopyStringToBuffer(
                          LocalName->Buffer,
                          LocalName->Length / sizeof(WCHAR),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &NetR->lpLocalName
                          );

        ASSERT(FitInBuffer);
    }
    else {
        NetR->lpLocalName = NULL;
    }

    //
    // ProviderName
    //

    FitInBuffer = CopyStringToBuffer(
                      NwProviderName.Buffer,
                      NwProviderName.Length / sizeof(WCHAR),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &NetR->lpProvider
                      );

    ASSERT(FitInBuffer);

    if (! FitInBuffer) {
        return STATUS_MORE_ENTRIES;
    }

    return STATUS_SUCCESS;
}

BOOL
CopyStringToBuffer(
    IN LPCWSTR SourceString OPTIONAL,
    IN DWORD   CharacterCount,
    IN LPCWSTR FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    )

/*++

Routine Description:

    This is based on ..\nwlib\NwlibCopyStringToBuffer

    This routine puts a single variable-length string into an output buffer.
    The string is not written if it would overwrite the last fixed structure
    in the buffer.

Arguments:

    SourceString - Supplies a pointer to the source string to copy into the
        output buffer.  If SourceString is null then a pointer to a zero terminator
        is inserted into output buffer.

    CharacterCount - Supplies the length of SourceString, not including zero
        terminator.  (This in units of characters - not bytes).

    FixedDataEnd - Supplies a pointer to just after the end of the last
        fixed structure in the buffer.

    EndOfVariableData - Supplies an address to a pointer to just after the
        last position in the output buffer that variable data can occupy.
        Returns a pointer to the string written in the output buffer.

    VariableDataPointer - Supplies a pointer to the place in the fixed
        portion of the output buffer where a pointer to the variable data
        should be written.

Return Value:

    Returns TRUE if string fits into output buffer, FALSE otherwise.

--*/
{
    DWORD CharsNeeded = (CharacterCount + 1);

    PAGED_CODE();

    //
    // Determine if source string will fit, allowing for a zero terminator.
    // If not, just set the pointer to NULL.
    //

    if ((*EndOfVariableData - CharsNeeded) >= FixedDataEnd) {

        //
        // It fits.  Move EndOfVariableData pointer up to the location where
        // we will write the string.
        //

        *EndOfVariableData -= CharsNeeded;

        //
        // Copy the string to the buffer if it is not null.
        //

        if (CharacterCount > 0 && SourceString != NULL) {

            (VOID) wcsncpy(*EndOfVariableData, SourceString, CharacterCount);
        }

        //
        // Set the zero terminator.
        //

        *(*EndOfVariableData + CharacterCount) = L'\0';

        //
        // Set up the pointer in the fixed data portion to point to where the
        // string is written.
        //

        *VariableDataPointer = *EndOfVariableData;

        return TRUE;

    }
    else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        *VariableDataPointer = NULL;

        return FALSE;
    }
}


NTSTATUS
GetRemoteHandle(
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine gets the NetWare handle for a Directory. This is used
    for support of NetWare aware Dos applications.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_PENDING;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    PCHAR OutputBuffer;
    PICB Icb;
    PDCB Dcb;
    PVOID FsContext;
    NODE_TYPE_CODE nodeTypeCode;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "GetRemoteHandle\n", 0);

    if ((nodeTypeCode = NwDecodeFileObject( IrpSp->FileObject,
                                            &FsContext,
                                            (PVOID *)&Icb )) != NW_NTC_ICB) {

        DebugTrace(0, Dbg, "Incorrect nodeTypeCode %x\n", nodeTypeCode);

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "GetRemoteHandle -> %08lx\n", Status );
        return Status;
    }

    Dcb = (PDCB)Icb->SuperType.Fcb;
    nodeTypeCode = Dcb->NodeTypeCode;

    if ( nodeTypeCode != NW_NTC_DCB ) {

        DebugTrace(0, Dbg, "Not a directory\n", 0);

#if 1
        if ( nodeTypeCode != NW_NTC_FCB ) {

            Status = STATUS_INVALID_PARAMETER;

            DebugTrace(-1, Dbg, "GetRemoteHandle -> %08lx\n", Status );
            return Status;
        }

        //
        //  Return the 6 byte NetWare handle for this file.
        //

        if (!Icb->HasRemoteHandle) {

            Status = STATUS_INVALID_HANDLE;

            DebugTrace(-1, Dbg, "GetRemoteHandle -> %08lx\n", Status );
            return Status;
        }

        if ( OutputBufferLength < ( 6 * sizeof( CHAR )) ) {

            Status = STATUS_BUFFER_TOO_SMALL;

            DebugTrace(-1, Dbg, "GetRemoteHandle -> %08lx\n", Status );
            return Status;
        }

        NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );

        //
        // tommye 
        //
        // NwMapUserBuffer may return a NULL OutputBuffer in low resource
        // situations; this was not being checked.  
        //

        if (OutputBuffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DebugTrace(-1, Dbg, "GetRemoteHandle -> %08lx\n", Status );
            return Status;
        }

        //
        // Probe the output buffer before touching it.
        //

        try {
        
            if ( Irp->RequestorMode != KernelMode ) {
             
                ProbeForWrite( OutputBuffer,
                            6 * sizeof(CHAR),
                            sizeof(CHAR)
                            );
            }

            RtlCopyMemory( OutputBuffer, Icb->Handle, 6 * sizeof(CHAR));

        } except (EXCEPTION_EXECUTE_HANDLER) {
              
              return GetExceptionCode();
        }

        IrpContext->pOriginalIrp->IoStatus.Information = 6 * sizeof(CHAR);

        Status = STATUS_SUCCESS;

        DebugTrace(-1, Dbg, "GetRemoteHandle -> %08lx\n", Status );
        return Status;
#else
        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "GetRemoteHandle -> %08lx\n", Status );
        return Status;
#endif
    }

    //
    //  Make sure that this ICB is still active.
    //

    NwVerifyIcb( Icb );

    if ( OutputBufferLength < sizeof( UCHAR ) ) {

        Status = STATUS_BUFFER_TOO_SMALL;

    } else if ( Icb->HasRemoteHandle ) {

        //  Already been asked for the handle

        NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );

        //
        // tommye 
        //
        // NwMapUserBuffer may return a NULL OutputBuffer in low resource
        // situations; this was not being checked.  
        //

        if (OutputBuffer == NULL) {
            DebugTrace(-1, DEBUG_TRACE_USERNCP, "NwMapUserBuffer returned NULL OutputBuffer", 0);
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else {
            try {

                if ( Irp->RequestorMode != KernelMode ) {
             
                    ProbeForWrite( 
                                OutputBuffer,
                                sizeof(CHAR),
                                sizeof(CHAR)
                                );
                }

                *OutputBuffer = Icb->Handle[0];

                IrpContext->pOriginalIrp->IoStatus.Information = sizeof(CHAR);
                Status = STATUS_SUCCESS;

            } except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();
            }
        }

    } else {

        CHAR Handle;

        IrpContext->pScb = Dcb->Scb;
        IrpContext->pNpScb = IrpContext->pScb->pNpScb;

        NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );
        //
        // tommye 
        //
        // NwMapUserBuffer may return a NULL OutputBuffer in low resource
        // situations; this was not being checked.  
        //

        if (OutputBuffer == NULL) {
            DebugTrace(-1, DEBUG_TRACE_USERNCP, "NwMapUserBuffer returned NULL OutputBuffer", 0);
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else {


            Status = ExchangeWithWait (
                         IrpContext,
                         SynchronousResponseCallback,
                         "SbbJ",
                         NCP_DIR_FUNCTION, NCP_ALLOCATE_TEMP_DIR_HANDLE,
                         Dcb->Vcb->Specific.Disk.Handle,
                         0,
                         &Dcb->RelativeFileName );

            if ( NT_SUCCESS( Status ) ) {

                Status = ParseResponse(
                              IrpContext,
                              IrpContext->rsp,
                              IrpContext->ResponseLength,
                              "Nb",
                              &Handle );

                if (NT_SUCCESS(Status)) {
                    try {
                        *OutputBuffer = Handle;
                        Icb->Handle[0] = Handle;
                        Icb->HasRemoteHandle = TRUE;
                        IrpContext->pOriginalIrp->IoStatus.Information = sizeof(CHAR);
                    }
                    except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = GetExceptionCode();
                    }
                }
            }

            NwDequeueIrpContext( IrpContext, FALSE );

            DebugTrace( 0, Dbg, "             -> %02x\n", Handle );
        }

    }

    DebugTrace(-1, Dbg, "GetRemoteHandle -> %08lx\n", Status );
    return Status;
}


NTSTATUS
GetUserName(
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine gets the UserName that would be used to connect to a particular
    server.

    If there are credentials specific to this connection use them
    otherwise use the logon credentials.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{

    NTSTATUS Status = STATUS_PENDING;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PWSTR InputBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    ULONG InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    ULONG OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    PWSTR OutputBuffer;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    LARGE_INTEGER Uid;
    UNICODE_STRING UidServer;
    UNICODE_STRING ServerName;
    UNICODE_STRING ConvertedName;
    PUNICODE_STRING pUserName;
    PSCB pScb;
    PLOGON pLogon;
    BOOLEAN CredentialsHeld = FALSE;
    BOOLEAN FailedTreeLookup = FALSE;
    PNDS_SECURITY_CONTEXT pNdsCredentials;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "GetUserName\n", 0);

    SeCaptureSubjectContext(&SubjectContext);
    Uid = GetUid( &SubjectContext );
    SeReleaseSubjectContext(&SubjectContext);

    //
    // Probe the input arguments to make sure they are kosher before
    // touching them.
    //

    try {

        if ( Irp->RequestorMode != KernelMode ) {
    
            ProbeForRead( InputBuffer,
                          InputBufferLength,
                          sizeof( CHAR )
                          );

        }

        ServerName.Buffer = InputBuffer;
        ServerName.MaximumLength = (USHORT)InputBufferLength;
        ServerName.Length = (USHORT)InputBufferLength;

        Status = MakeUidServer( &UidServer, &Uid, &ServerName );
        if (!NT_SUCCESS(Status)) {
            DebugTrace(-1, Dbg, "GetUserName -> %08lx\n", Status );
            return(Status);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

          return (GetExceptionCode());
    }

    DebugTrace( 0, Dbg, " ->UidServer = \"%wZ\"\n", &UidServer );

    //
    // Get the login for this user.
    //

    NwDequeueIrpContext( IrpContext, FALSE );
    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    pLogon = FindUser( &Uid, FALSE);
    NwReleaseRcb( &NwRcb );

    //
    // First try this name as a server.  Avoid FindScb creating a
    // connection to the server if one doesn't exist already.
    //
    // Since IRP_FLAG_NOCONNECT is set the last parameter of
    // NwFindScb is never used.
    //

    SetFlag( IrpContext->Flags, IRP_FLAG_NOCONNECT );
    NwFindScb( &pScb, IrpContext, &UidServer, NULL );

    pUserName = NULL;

    //
    // Look for bindery server name, or tree login name.
    //

    if ( pScb != NULL ) {

        if ( pScb->UserName.Buffer != NULL ) {

            pUserName = &pScb->UserName;

        } else if ( pScb->NdsTreeName.Buffer != NULL &&
                    pScb->NdsTreeName.Length > 0 ) {

            Status = NdsLookupCredentials( IrpContext,
                                           &pScb->NdsTreeName,
                                           pLogon,
                                           &pNdsCredentials,
                                           CREDENTIAL_READ,
                                           FALSE );

            if ( NT_SUCCESS( Status ) ) {

                CredentialsHeld = TRUE;

                if ( pNdsCredentials->Credential ) {

                    //
                    // If we have login data, get the user name.
                    //

                    ConvertedName.Length = pNdsCredentials->Credential->userNameLength -
                                           sizeof( WCHAR );
                    ConvertedName.MaximumLength = ConvertedName.Length;
                    ConvertedName.Buffer = (USHORT *)
                        ( ((BYTE *) pNdsCredentials->Credential ) +
                                    sizeof( NDS_CREDENTIAL ) +
                                    pNdsCredentials->Credential->optDataSize );

                    pUserName = &ConvertedName;

                } else {

                    //
                    // If there's no credential data, we're not logged in.
                    //

                    FailedTreeLookup = TRUE;
                }

            } else {

                FailedTreeLookup = TRUE;
            }

        }

    }

    //
    // If it wasn't a server and we haven't already tried a tree, do so now.
    //

    if ( pUserName == NULL &&
         !FailedTreeLookup )  {

        //
        //  ServerName points to a user buffer - so we need
        //  to watch for problems accessing the data here
        //
        //  NOTE: ServerName points to a usermode buffer
        //  so we must protect ourselves around this call.
        //

        try {
            Status = NdsLookupCredentials( 
                                       IrpContext,
                                       &ServerName,
                                       pLogon,
                                       &pNdsCredentials,
                                       CREDENTIAL_READ,
                                       FALSE );
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

        }

        if ( NT_SUCCESS( Status ) ) {

            CredentialsHeld = TRUE;

            if ( pNdsCredentials->Credential ) {

                //
                // If we've logged in, get the user name.
                //

                ConvertedName.Length = pNdsCredentials->Credential->userNameLength -
                                       sizeof( WCHAR );
                ConvertedName.MaximumLength = ConvertedName.Length;
                ConvertedName.Buffer = (USHORT *)
                    ( ((BYTE *) pNdsCredentials->Credential ) +
                                sizeof( NDS_CREDENTIAL ) +
                                pNdsCredentials->Credential->optDataSize );

                pUserName = &ConvertedName;

            }
        }

    }

    //
    // If we still don't know, return the default name.
    //

    if ( pUserName == NULL &&
         pLogon != NULL ) {

        pUserName = &pLogon->UserName;
    }

    FREE_POOL(UidServer.Buffer);

    if ( pUserName ) {

        DebugTrace( 0, Dbg, "Get User Name: %wZ\n", pUserName );

        try {

            if (pUserName->Length > OutputBufferLength) {

                DebugTrace(-1, Dbg, "GetUserName -> %08lx\n", STATUS_BUFFER_TOO_SMALL );
                Status = STATUS_BUFFER_TOO_SMALL;
                goto ReleaseAndExit;
            }


            NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );

            //
            // tommye 
            //
            // NwMapUserBuffer may return a NULL OutputBuffer in low resource
            // situations; this was not being checked.  
            //

            if (OutputBuffer == NULL) {
                DebugTrace(-1, DEBUG_TRACE_USERNCP, "NwMapUserBuffer returned NULL OutputBuffer", 0);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ReleaseAndExit;
            }


            //
            // Probe to ensure that the buffer is kosher.
            //
            
            if ( Irp->RequestorMode != KernelMode ) {
            
                ProbeForWrite( OutputBuffer,
                               OutputBufferLength,
                               sizeof(CHAR)
                              );
            }
            
            IrpContext->pOriginalIrp->IoStatus.Information = pUserName->Length;
            RtlMoveMemory( OutputBuffer, pUserName->Buffer, pUserName->Length);

            Status = STATUS_SUCCESS;

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            Status = STATUS_INVALID_PARAMETER;
        }
    }

ReleaseAndExit:

    if ( pScb ) {
        NwDereferenceScb( pScb->pNpScb );
    }

    DebugTrace(-1, Dbg, "GetUserName -> %08lx\n", Status );

    if ( CredentialsHeld ) {
        NwReleaseCredList( pLogon, IrpContext );
    }

    return Status;
}

BOOL
IsSystemLuid()
{
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    LARGE_INTEGER Uid;
    LUID systemLuid = SYSTEM_LUID;
    LUID localServiceLuid = LOCALSERVICE_LUID;
    LUID netServiceLuid = NETWORKSERVICE_LUID;

    SeCaptureSubjectContext(&SubjectContext);
    Uid = GetUid( &SubjectContext );
    SeReleaseSubjectContext(&SubjectContext);

    if (RtlEqualLuid((PLUID)&Uid, &systemLuid))
        return TRUE;
    else if (RtlEqualLuid((PLUID)&Uid, &localServiceLuid))
        return TRUE;
    else if (RtlEqualLuid((PLUID)&Uid, &netServiceLuid))
        return TRUE;
    else
        return FALSE;

}


NTSTATUS
GetChallenge(
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine builds the challenge and session key for rpc using the
    credentials stored in the redirector. The Rpc client can supply a
    password. This allows the redirector to keep the algorithm in one
    place.

    If a password is supplied then use that, if there is a password on this
    specific connection use that, otherwise use the logon credentials.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_PENDING;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PNWR_GET_CHALLENGE_REQUEST InputBuffer = Irp->AssociatedIrp.SystemBuffer;
    ULONG InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    ULONG OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    PNWR_GET_CHALLENGE_REPLY OutputBuffer = Irp->AssociatedIrp.SystemBuffer;
    OEM_STRING Password;
    PSCB pScb = NULL;
    PLOGON pLogon;
    BOOLEAN RcbHeld = FALSE;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    LARGE_INTEGER ProcessUid;
    ULONG RequestFlags;

    LUID _system_luid = SYSTEM_LUID;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "GetChallenge\n", 0);
    
    //
    // Buffer big enough to contain fixed header?
    //

    if (InputBufferLength <
            (ULONG) FIELD_OFFSET(NWR_GET_CHALLENGE_REQUEST,ServerNameorPassword[0])) {
    
        return(STATUS_INVALID_PARAMETER);
    }
    
    //
    // Check output buffer length
    //

    if (OutputBufferLength < sizeof(NWR_GET_CHALLENGE_REPLY)) {
        return(STATUS_INVALID_PARAMETER);
    }
    
    //
    // tommye - make sure the InputBuffer is kosher
    //

    try {

        //
        // Probe for safety.
        //

        if ( Irp->RequestorMode != KernelMode ) {

            ProbeForRead( InputBuffer,
                          InputBufferLength,
                          sizeof( CHAR ));
        }

        //   
        // Buffer big enough to contain the variable portion. Subtraction here can't underflow because
        // of the previous test
    
        if ((InputBufferLength - FIELD_OFFSET(NWR_GET_CHALLENGE_REQUEST,ServerNameorPassword[0]) <
                InputBuffer->ServerNameorPasswordLength)) {
    
            return(STATUS_INVALID_PARAMETER);
        }
    
        //
        // String length must be an even number of characters
        //

        if (InputBuffer->ServerNameorPasswordLength&(sizeof (WCHAR) - 1)) {
            return(STATUS_INVALID_PARAMETER);
        }

        // Pull out the request flags to use later

        RequestFlags = InputBuffer->Flags;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    //
    //  Only allow processes running in the system context to call this api to prevent
    //  password attacks.
    //
    /*
    SeCaptureSubjectContext(&SubjectContext);
    SeQueryAuthenticationIdToken(&SubjectContext.PrimaryToken, (PLUID)&ProcessUid);
    SeReleaseSubjectContext(&SubjectContext);
    */

    // if (! RtlEqualLuid(&ProcessUid, &_system_luid)) {
    if (! IsSystemLuid()) {
        return(STATUS_ACCESS_DENIED);
    }

    Password.Buffer = NULL;
    Password.Length = 0;

    if ( RequestFlags == CHALLENGE_FLAGS_SERVERNAME ) {
        PUNICODE_STRING pPassword;
        LARGE_INTEGER Uid;
        UNICODE_STRING UidServer;

        try {
            UNICODE_STRING ServerName;

            if (InputBuffer->ServerNameorPasswordLength == 0) {
                return(STATUS_INVALID_PARAMETER);
            }

            //
            //  We have to supply the password from the redirector
            //

            SeCaptureSubjectContext(&SubjectContext);
            Uid = GetUid( &SubjectContext );
            SeReleaseSubjectContext(&SubjectContext);

            ServerName.Buffer = (PWSTR)((PUCHAR)InputBuffer +
                    FIELD_OFFSET(NWR_GET_CHALLENGE_REQUEST,ServerNameorPassword[0]));
            ServerName.MaximumLength = (USHORT)InputBuffer->ServerNameorPasswordLength;
            ServerName.Length = (USHORT)InputBuffer->ServerNameorPasswordLength;
     
            Status = MakeUidServer( &UidServer, &Uid, &ServerName );
            if (!NT_SUCCESS(Status)) {
                DebugTrace(-1, Dbg, "GetChallenge -> %08lx\n", Status );
                return(Status);
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode();

        }

        DebugTrace( 0, Dbg, " ->UidServer = \"%wZ\"\n", &UidServer );

        try {

            //
            // Avoid FindScb creating a connection to the server if one
            // doesn't exist already.
            //
            // Since IRP_FLAG_NOCONNECT is set the last parameter of
            // NwFindScb is never used.
            //

            SetFlag( IrpContext->Flags, IRP_FLAG_NOCONNECT );
            NwFindScb( &pScb, IrpContext, &UidServer, NULL );

            if ((pScb != NULL) &&
                (pScb->Password.Buffer != NULL)) {

                pPassword = &pScb->Password;

            } else {

                //
                //  Use default credentials for this UID
                //

                NwDequeueIrpContext( IrpContext, FALSE );
                RcbHeld = TRUE;
                NwAcquireExclusiveRcb( &NwRcb, TRUE );
                pLogon = FindUser( &Uid, FALSE);

                if (pLogon != NULL ) {

                    pPassword = &pLogon->PassWord;

                } else {
                    DebugTrace(-1, Dbg, "GetChallenge -> %08lx\n", STATUS_ACCESS_DENIED );
                    return( STATUS_ACCESS_DENIED );
                }
            }

            if (pPassword->Length != 0) {
                Status = RtlUpcaseUnicodeStringToOemString( &Password, pPassword, TRUE );
                if (!NT_SUCCESS(Status)) {
                    DebugTrace(-1, Dbg, "GetChallenge -> %08lx\n", Status );
                    return( Status );
                }
            } else {
                Password.Buffer = "";
                Password.Length = Password.MaximumLength = 0;
            }
        } finally {

            if (RcbHeld) {
                NwReleaseRcb( &NwRcb );
            }

            if (pScb != NULL) {
                NwDereferenceScb( pScb->pNpScb );
            }

            FREE_POOL(UidServer.Buffer);
        }

    } else {

        UNICODE_STRING LocalPassword;

        try {
            LocalPassword.Buffer = (PWSTR)((PUCHAR)InputBuffer +
                FIELD_OFFSET(NWR_GET_CHALLENGE_REQUEST,ServerNameorPassword[0]));
            LocalPassword.MaximumLength = (USHORT)InputBuffer->ServerNameorPasswordLength;
            LocalPassword.Length = (USHORT)InputBuffer->ServerNameorPasswordLength;

            if (LocalPassword.Length != 0) {
                Status = RtlUpcaseUnicodeStringToOemString( &Password, &LocalPassword, TRUE );
                if (!NT_SUCCESS(Status)) {
                    DebugTrace(-1, Dbg, "GetChallenge -> %08lx\n", Status );
                    return( Status );
                }
            } else {
                Password.Buffer = "";
                Password.Length = Password.MaximumLength = 0;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode();
        }
    }

    DebugTrace( 0, Dbg, " ->Password = \"%Z\"\n", &Password );

    try {
        RespondToChallenge( (PUCHAR)&InputBuffer->ObjectId, &Password, InputBuffer->Challenge, OutputBuffer->Challenge);

    } finally {

        if ( Password.Length > 0 ) {

            RtlFreeAnsiString( &Password );
        }
    }

    Irp->IoStatus.Information = sizeof(NWR_GET_CHALLENGE_REPLY);
    Status = STATUS_SUCCESS;

    DebugTrace(-1, Dbg, "GetChallenge -> %08lx\n", Status );
    return Status;
}

NTSTATUS
WriteConnStatusEntry(
    PIRP_CONTEXT pIrpContext,
    PSCB pConnectionScb,
    PBYTE pbUserBuffer,
    DWORD dwBufferLen,
    DWORD *pdwBytesWritten,
    DWORD *pdwBytesNeeded,
    BOOLEAN fCallerScb
    )
{
    NTSTATUS Status;
    PLOGON pLogon;
    PNDS_SECURITY_CONTEXT pNdsContext;
    BOOLEAN fHoldingCredentials = FALSE;
    PUNICODE_STRING puUserName = NULL;
    UNICODE_STRING CredentialName;
    UNICODE_STRING ServerName;
    PCONN_STATUS pStatus;
    DWORD dwBytesNeeded;
    PBYTE pbStrPtr;
    DWORD dwAllowedHandles;

    //
    // If this is an NDS connection, get the credentials.
    //

    if ( ( pConnectionScb->MajorVersion > 3 ) &&
         ( pConnectionScb->UserName.Length == 0 ) ) {

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        pLogon = FindUser( &(pConnectionScb->UserUid), FALSE );
        NwReleaseRcb( &NwRcb );

        if ( pLogon ) {

            Status = NdsLookupCredentials( pIrpContext,
                                           &(pConnectionScb->NdsTreeName),
                                           pLogon,
                                           &pNdsContext,
                                           CREDENTIAL_READ,
                                           FALSE );

            if ( NT_SUCCESS( Status ) ) {

                fHoldingCredentials = TRUE;

                if ( pNdsContext->Credential != NULL ) {

                    CredentialName.Length = pNdsContext->Credential->userNameLength -
                                            sizeof( WCHAR );
                    CredentialName.MaximumLength = CredentialName.Length;
                    CredentialName.Buffer = (USHORT *)
                        ( ((BYTE *) pNdsContext->Credential ) +
                          sizeof( NDS_CREDENTIAL ) +
                          pNdsContext->Credential->optDataSize );

                    puUserName = &CredentialName;
                }

            }
        }

    } else {

       if ( pConnectionScb->UserName.Length != 0 ) {
           puUserName = &(pConnectionScb->UserName);
       } else {
           puUserName = NULL;
       }

    }

    DebugTrace( 0, Dbg, "WriteConnStatus: UserName %wZ\n", puUserName );

    //
    // Strip off the uid from the server name.
    //

    ServerName.Length = (pConnectionScb->UidServerName).Length;
    ServerName.Buffer = (pConnectionScb->UidServerName).Buffer;

    while ( ServerName.Length ) {

       if ( ServerName.Buffer[0] == L'\\' ) {

           ServerName.Length -= sizeof( WCHAR );
           ServerName.Buffer += 1;
           break;
       }

       ServerName.Length -= sizeof( WCHAR );
       ServerName.Buffer += 1;

    }

    DebugTrace( 0, Dbg, "WriteConnStatus: ServerName %wZ\n", &ServerName );

    //
    // Do we have enough space?  Don't forget that we have to
    // NULL terminate the WCHAR strings.
    //

    dwBytesNeeded = sizeof( CONN_STATUS );

    dwBytesNeeded += ( ServerName.Length + sizeof( WCHAR ) );

    if ( pConnectionScb->NdsTreeName.Length ) {
        dwBytesNeeded += ( pConnectionScb->NdsTreeName.Length + sizeof( WCHAR ) );
    }

    if ( puUserName ) {
        dwBytesNeeded += ( puUserName->Length + sizeof( WCHAR ) );
    }

    //
    // Pad the end to make sure all structures are aligned.
    //

    dwBytesNeeded = ROUNDUP4( dwBytesNeeded );

    if ( dwBytesNeeded > dwBufferLen ) {

        *pdwBytesNeeded = dwBytesNeeded;
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitWithCleanup;
    }

    //
    // Fill in the CONN_STATUS structure.
    //

    try {

        pStatus = (PCONN_STATUS)pbUserBuffer;
        pbStrPtr = pbUserBuffer + sizeof( CONN_STATUS );

        //
        // We always have a server name.
        //

        pStatus->pszServerName = (PWSTR) pbStrPtr;
        pbStrPtr += ( ServerName.Length + sizeof( WCHAR ) );

        //
        // Fill in the user name if applicable.
        //

        if ( puUserName ) {

            pStatus->pszUserName = (PWSTR) pbStrPtr;
            pbStrPtr += ( puUserName->Length + sizeof( WCHAR ) );

        } else {

            pStatus->pszUserName = NULL;
        }

        //
        // Fill in the tree name if applicable.
        //

        if ( pConnectionScb->NdsTreeName.Length ) {

            pStatus->pszTreeName = (PWSTR) pbStrPtr;

        } else {

            pStatus->pszTreeName = NULL;
        }

        //
        // Fill in the connection number if applicable.
        //

        if ( ( pConnectionScb->pNpScb->State == SCB_STATE_IN_USE ) ||
             ( pConnectionScb->pNpScb->State == SCB_STATE_LOGIN_REQUIRED ) ) {

            pStatus->nConnNum = (DWORD)(pConnectionScb->pNpScb->ConnectionNo);

        } else {

            pStatus->nConnNum = 0;

        }

        //
        // Copy the user name over.
        //

        if ( puUserName ) {

            RtlCopyMemory( (PBYTE)(pStatus->pszUserName),
                           (PBYTE)(puUserName->Buffer),
                           puUserName->Length );
            *(pStatus->pszUserName + (puUserName->Length / sizeof( WCHAR ))) = L'\0';

        }

        //
        // Set the NDS flag and authentication fields.
        //

        if ( ( pConnectionScb->MajorVersion > 3 ) &&
             ( pConnectionScb->UserName.Length == 0 ) ) {

            pStatus->fNds = TRUE;

            if ( pConnectionScb->pNpScb->State == SCB_STATE_IN_USE ) {

                if ( ( pConnectionScb->VcbCount ) || ( pConnectionScb->OpenNdsStreams ) ) {
                    pStatus->dwConnType = NW_CONN_NDS_AUTHENTICATED_LICENSED;
                } else {
                    pStatus->dwConnType = NW_CONN_NDS_AUTHENTICATED_NO_LICENSE;
                }

            } else if ( pConnectionScb->pNpScb->State == SCB_STATE_LOGIN_REQUIRED ) {

                pStatus->dwConnType = NW_CONN_NOT_AUTHENTICATED;

            } else {

                pStatus->dwConnType = NW_CONN_DISCONNECTED;

            }

        } else {

            pStatus->fNds = FALSE;

            if ( pConnectionScb->pNpScb->State == SCB_STATE_IN_USE ) {

                pStatus->dwConnType = NW_CONN_BINDERY_LOGIN;

            } else if ( pConnectionScb->pNpScb->State == SCB_STATE_LOGIN_REQUIRED ) {

               pStatus->dwConnType = NW_CONN_NOT_AUTHENTICATED;

            } else {

               pStatus->dwConnType = NW_CONN_DISCONNECTED;

            }

        }

        //
        // Copy over the tree name.
        //

        if ( pConnectionScb->NdsTreeName.Length ) {

            RtlCopyMemory( (PBYTE)(pStatus->pszTreeName),
                           (PBYTE)(pConnectionScb->NdsTreeName.Buffer),
                           pConnectionScb->NdsTreeName.Length );
            *( pStatus->pszTreeName +
               ( pConnectionScb->NdsTreeName.Length / sizeof( WCHAR ) ) ) = L'\0';

        } else {

            pStatus->pszTreeName = NULL;
        }

        //
        // Copy the server name over.
        //

        RtlCopyMemory( (PBYTE)(pStatus->pszServerName),
                       (PBYTE)(ServerName.Buffer),
                       ServerName.Length );
        *(pStatus->pszServerName + (ServerName.Length / sizeof( WCHAR ))) = L'\0';

        //
        // Set the preferred server field if this is a preferred server
        // and there are no explicit uses for the connection.  If the
        // fCallerScb parameter is TRUE, then this SCB has a handle from
        // the caller of the API and we have to make an allowance for
        // that handle. Yes, this is kind of ugly.
        //

        if ( fCallerScb ) {
            dwAllowedHandles = 1;
        } else {
            dwAllowedHandles = 0;
        }

        if ( ( pConnectionScb->PreferredServer ) &&
             ( pConnectionScb->OpenFileCount == 0 ) &&
             ( pConnectionScb->IcbCount == dwAllowedHandles ) ) {

            pStatus->fPreferred = TRUE;

        } else {

            pStatus->fPreferred = FALSE;
        }

        //
        // Fill out the length.
        //

        pStatus->dwTotalLength = dwBytesNeeded;
        *pdwBytesWritten = dwBytesNeeded;
        Status = STATUS_SUCCESS;


    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();
        DebugTrace( 0, Dbg, "Exception %08lx accessing user mode buffer.\n", Status );
        goto ExitWithCleanup;

    }

ExitWithCleanup:

    if ( fHoldingCredentials ) {
        NwReleaseCredList( pLogon, pIrpContext );
    }

    return Status;
}

NTSTATUS
GetConnStatus(
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject
    )
/*++

    Get the connection status for the described connection.
    The following connection requests are valid:

    Server (e.g. "MARS312") - returns a single connection
        status structure for this server if the user has a
        connection to the server.

    Tree (e.g. "*MARSDEV") - returns a connection status
        structure for every server in the tree that the user
        has a connection to.

    All Connections (e.g. "") - returns a connection status
        structure for every server that the user has a
        connection to.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;

    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    PNWR_REQUEST_PACKET InputBuffer;
    ULONG InputBufferLength;
    BYTE *OutputBuffer;
    ULONG OutputBufferLength;

    SECURITY_SUBJECT_CONTEXT SubjectContext;
    LARGE_INTEGER Uid;

    PLIST_ENTRY ListEntry;
    UNICODE_STRING ConnectionName, UidServer;
    BOOL fTreeConnections = FALSE;
    BOOL fServerConnection = FALSE;
    BOOL OwnRcb = FALSE;
    PUNICODE_PREFIX_TABLE_ENTRY PrefixEntry;
    DWORD dwBytesWritten, dwBytesNeeded;
    KIRQL OldIrql;
    PSCB pScb;
    PNONPAGED_SCB pNpScb;
    DWORD dwReturned = 0;
    ULONG SequenceNumber = 0;
    ULONG_PTR ResumeKey;

    NODE_TYPE_CODE nodeTypeCode;
    PICB pIcb;
    PSCB pCallerScb;
    PVOID fsContext, fsContext2;

    //
    // Get the appropriate buffers.
    //

    InputBuffer = (PNWR_REQUEST_PACKET) IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );

    //
    // tommye 
    //
    // NwMapUserBuffer may return a NULL OutputBuffer in low resource
    // situations; this was not being checked.  
    //

    if (OutputBuffer == NULL) {
        DebugTrace(-1, DEBUG_TRACE_USERNCP, "NwMapUserBuffer returned NULL OutputBuffer", 0);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    if ( InputBufferLength < (ULONG)FIELD_OFFSET( NWR_REQUEST_PACKET, Parameters.GetConnStatus.ConnectionName[1] ) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // Figure out who this request applies to.
    //

    SeCaptureSubjectContext(&SubjectContext);
    Uid = GetUid( &SubjectContext );
    SeReleaseSubjectContext(&SubjectContext);

    RtlInitUnicodeString( &ConnectionName, NULL );
    RtlInitUnicodeString( &UidServer, NULL );

    //
    // Figure out who the caller of this routine is so we know to
    // ignore their handle when deciding what to return.
    //

    nodeTypeCode = NwDecodeFileObject( FileObject, &fsContext, &fsContext2 );

    if ( nodeTypeCode == NW_NTC_ICB_SCB ) {

       pIcb = (PICB) fsContext2;
       pCallerScb = pIcb->SuperType.Scb;
       DebugTrace( 0, Dbg, "GetConnStatus called by handle on %08lx\n", pCallerScb );

    } else {

        pCallerScb = NULL;
        DebugTrace( 0, Dbg, "Couldn't figure out who called us.\n", 0 );
    }

    //
    //
    // Figure out which connections we're looking for.
    //

    try {

        //
        // Probe for safety.
        //

        if ( Irp->RequestorMode != KernelMode ) {

            ProbeForRead( InputBuffer,
                          InputBufferLength,
                          sizeof( CHAR )
                          );
        }

        if ( InputBuffer->Parameters.GetConnStatus.ConnectionNameLength != 0 ) {

            //
            // Check the connection name length to see if its sound. This
            // subtraction can't underflow because of the test above.
            //

            if ( InputBuffer->Parameters.GetConnStatus.ConnectionNameLength >
                 InputBufferLength - FIELD_OFFSET( NWR_REQUEST_PACKET, Parameters.GetConnStatus.ConnectionName) ) {

                return STATUS_INVALID_PARAMETER;
            }

            if ( InputBuffer->Parameters.GetConnStatus.ConnectionName[0] == L'*' ) {

                ConnectionName.Buffer = &(InputBuffer->Parameters.GetConnStatus.ConnectionName[1]);
                ConnectionName.Length = (USHORT)
                    ( InputBuffer->Parameters.GetConnStatus.ConnectionNameLength -
                    sizeof( WCHAR ) );
                ConnectionName.MaximumLength = ConnectionName.Length;

                fTreeConnections = TRUE;

                DebugTrace( 0, Dbg, "GetConnStatus: Tree is %wZ\n", &ConnectionName );

            } else {

                ConnectionName.Buffer = InputBuffer->Parameters.GetConnStatus.ConnectionName;
                ConnectionName.Length = (USHORT)
                    (InputBuffer->Parameters.GetConnStatus.ConnectionNameLength);
                ConnectionName.MaximumLength = ConnectionName.Length;

                fServerConnection = TRUE;

                Status = MakeUidServer( &UidServer, &Uid, &ConnectionName );
                if ( !NT_SUCCESS( Status )) {
                    return Status;
                }

                DebugTrace( 0, Dbg, "GetConnStatus: Server is %wZ\n", &UidServer );
            }

        } else {

            DebugTrace( 0, Dbg, "GetConnectionStatus: enumerate all connections.\n", 0 );

        }

        // Pull out the resume key here
        ResumeKey = InputBuffer->Parameters.GetConnStatus.ResumeKey;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

          Status = GetExceptionCode();
          DebugTrace( 0, Dbg, "Bad input buffer in GetConnStatus.\n" , 0 );
          goto ExitWithCleanup;

    }

    //
    // If this is a server connection, find and return it.
    //

    if ( fServerConnection ) {

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        OwnRcb = TRUE;
        PrefixEntry = RtlFindUnicodePrefix( &NwRcb.ServerNameTable, &UidServer, 0 );

        if ( !PrefixEntry ) {
            Status = STATUS_INVALID_PARAMETER;
            goto ExitWithCleanup;
        }

        pScb = CONTAINING_RECORD( PrefixEntry, SCB, PrefixEntry );

        if ( ( pScb->PreferredServer ) ||
             ( pScb->OpenFileCount > 0 ) ) {

            //
            // If there are open files, we need to return this.
            // We always write status entries for the preferred
            // server so that we can give default logon info.
            //

            goto ProcessServer;
        }

        //
        // Are there open handles other than the caller?
        //

        if ( pScb == pCallerScb ) {

            if ( pScb->IcbCount > 1 ) {

                ASSERT( pScb->pNpScb->Reference > 1 );
                goto ProcessServer;
            }

        } else {

            if ( pScb->IcbCount > 0 ) {

                ASSERT( pScb->pNpScb->Reference > 0 );
                goto ProcessServer;
            }
        }

        //
        // Not an explicit use for this server.
        //
        goto ExitWithCleanup;

ProcessServer:

        NwReferenceScb( pScb->pNpScb );

        NwReleaseRcb( &NwRcb );
        OwnRcb = FALSE;

        //  NOTE: This routine protects itself when writing
        //  to the OutputBuffer

        Status = WriteConnStatusEntry( IrpContext,
                                       pScb,
                                       OutputBuffer,
                                       OutputBufferLength,
                                       &dwBytesWritten,
                                       &dwBytesNeeded,
                                       (BOOLEAN)( pScb == pCallerScb ) );

        NwDereferenceScb( pScb->pNpScb );

        try {

            InputBuffer->Parameters.GetConnStatus.ResumeKey = 0;

            if ( !NT_SUCCESS( Status )) {

                InputBuffer->Parameters.GetConnStatus.EntriesReturned = 0;
                InputBuffer->Parameters.GetConnStatus.BytesNeeded = dwBytesNeeded;
                Irp->IoStatus.Information = 0;
                goto ExitWithCleanup;

            } else {

                InputBuffer->Parameters.GetConnStatus.EntriesReturned = 1;
                InputBuffer->Parameters.GetConnStatus.BytesNeeded = 0;
                Irp->IoStatus.Information = dwBytesWritten;
                goto ExitWithCleanup;

            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
        
            Status = GetExceptionCode();

            goto ExitWithCleanup;

        }
    }

    //
    // We want all connections or all tree connections, so
    // we need to walk the list.
    //

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
    ListEntry = ScbQueue.Flink;

    while ( ListEntry != &ScbQueue ) {

        pNpScb = CONTAINING_RECORD( ListEntry, NONPAGED_SCB, ScbLinks );
        pScb = pNpScb->pScb;

        NwReferenceScb( pNpScb );

        KeReleaseSpinLock(&ScbSpinLock, OldIrql);

        //
        // Make sure we pass up the one's we've already returned.
        //

        if ( ( SequenceNumber >= ResumeKey ) &&
             ( pNpScb != &NwPermanentNpScb ) &&
             ( !IsCredentialName( &(pNpScb->pScb->NdsTreeName) ) ) ) {

            //
            // If there are open files, we need to return this.
            // We always write status entries for the preferred
            // server so that we can give default logon info.
            //

            if ( ( pScb->PreferredServer ) ||
                 ( pScb->OpenFileCount > 0 ) ) {
                goto SecondProcessServer;
            }

            //
            // Are there any handles other than the caller?
            //

            if ( pScb == pCallerScb ) {

                if ( pScb->IcbCount > 1 ) {

                    ASSERT( pScb->pNpScb->Reference > 2 );
                    goto SecondProcessServer;
                }

            } else {

                if ( pScb->IcbCount > 0 ) {

                    ASSERT( pScb->pNpScb->Reference > 1 );
                    goto SecondProcessServer;
                }
            }

        }

        //
        // Not an interesting server; move to next entry.
        //

        KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
        ListEntry = pNpScb->ScbLinks.Flink;
        NwDereferenceScb( pNpScb );
        SequenceNumber++;
        continue;

SecondProcessServer:

        //
        // We have a possible candidate; see if the uid and tree are appropriate.
        //

        if ( ( (pScb->UserUid).QuadPart != Uid.QuadPart ) ||

             ( fTreeConnections &&
               !RtlEqualUnicodeString( &(pScb->NdsTreeName),
                                       &ConnectionName,
                                       TRUE ) ) ) {

            //
            // No dice.  Move onto the next one.
            //

           KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
           ListEntry = pNpScb->ScbLinks.Flink;
           NwDereferenceScb( pNpScb );
           SequenceNumber++;
           continue;

        }

        //
        //  Ok, we definitely want to report this one.
        //  NOTE: This routine protects itself when writing
        //  to the OutputBuffer
        //

        Status = WriteConnStatusEntry( IrpContext,
                                       pScb,
                                       OutputBuffer,
                                       OutputBufferLength,
                                       &dwBytesWritten,
                                       &dwBytesNeeded,
                                       (BOOLEAN)( pScb == pCallerScb ) );

        if ( !NT_SUCCESS( Status )) {

            //
            // If we couldn't write this entry, then we have to update
            // the ResumeKey and return.  We don't really know how many
            // more there are going to be so we 'suggest' to the caller
            // a 2k buffer size.
            //

            try {
                InputBuffer->Parameters.GetConnStatus.ResumeKey = SequenceNumber;
                InputBuffer->Parameters.GetConnStatus.EntriesReturned = dwReturned;
                InputBuffer->Parameters.GetConnStatus.BytesNeeded = 2048;
            }
            except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();

            }
            NwDereferenceScb( pNpScb );
            goto ExitWithCleanup;

        } else {

            OutputBuffer = ( OutputBuffer + dwBytesWritten );
            OutputBufferLength -= dwBytesWritten;
            dwReturned++;
        }

        //
        //  Move to next entry in the list.
        //

        KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
        ListEntry = pNpScb->ScbLinks.Flink;
        NwDereferenceScb( pNpScb );
        SequenceNumber++;
    }

    //
    // We made it through the list.
    //

    KeReleaseSpinLock(&ScbSpinLock, OldIrql);

    try {
        InputBuffer->Parameters.GetConnStatus.ResumeKey = 0;
        InputBuffer->Parameters.GetConnStatus.EntriesReturned = dwReturned;
        InputBuffer->Parameters.GetConnStatus.BytesNeeded = 0;

        Status = STATUS_SUCCESS;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();

    }

ExitWithCleanup:

    //
    // If we returned any entries, then set the status to success.
    //

    if ( dwReturned ) {

        ASSERT( SequenceNumber != 0 );
        Status = STATUS_SUCCESS;
    }

    if ( OwnRcb ) {
        NwReleaseRcb( &NwRcb );
    }

    if ( UidServer.Buffer != NULL ) {
        FREE_POOL( UidServer.Buffer );
    }

    return Status;
}

NTSTATUS
GetConnectionInfo(
    IN PIRP_CONTEXT IrpContext
    )
/*+++

GetConnectionInfo:

    Takes a connection name from the new shell and returns
    some info commonly requested by property sheets and the
    such.

    The following connection names are supported:

        Drive Letter: "X:"
        Printer Port: "LPTX:"
        UNC Name:     "\\SERVER\Share\{Path\}


---*/
{

    NTSTATUS Status;

    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PNWR_REQUEST_PACKET InputBuffer;
    PCONN_INFORMATION pConnInfo;
    ULONG InputBufferLength, OutputBufferLength;
    ULONG BytesNeeded;

    SECURITY_SUBJECT_CONTEXT SubjectContext;
    LARGE_INTEGER Uid;
    UNICODE_STRING ConnectionName;
    UNICODE_STRING UidVolumeName;
    WCHAR DriveLetter = 0;

    BOOLEAN OwnRcb = FALSE;
    BOOLEAN ReferenceVcb = FALSE;
    PVCB Vcb = NULL;
    PSCB Scb = NULL;
    PUNICODE_PREFIX_TABLE_ENTRY Prefix;

    PLOGON pLogon;
    UNICODE_STRING CredentialName;
    UNICODE_STRING ServerName;
    PUNICODE_STRING puUserName = NULL;
    PNDS_SECURITY_CONTEXT pNdsContext;
    BOOLEAN fHoldingCredentials = FALSE;
    PVCB * DriveMapTable;

    //
    // Get the input and output buffers.
    //

    InputBuffer = (PNWR_REQUEST_PACKET) IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( OutputBufferLength ) {
        NwMapUserBuffer( Irp, KernelMode, (PVOID *)&pConnInfo );
    } else {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // tommye - MS bug 31996
    // Added ProbeForRead to check input buffer.
    // Also added check for pConnInfo being NULL.
    //

    if (pConnInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {

        //
        // Probe for safety.
        //

        if ( Irp->RequestorMode != KernelMode ) {

            ProbeForRead( InputBuffer,
                          InputBufferLength,
                          sizeof( CHAR ));
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    SeCaptureSubjectContext(&SubjectContext);
    Uid = GetUid( &SubjectContext );
    SeReleaseSubjectContext(&SubjectContext);

    RtlInitUnicodeString( &UidVolumeName, NULL );

    //
    //  tommye - MS bug 129818
    //
    //  Probe ConnectionName for the advertised length
    //

    try {

        ConnectionName.Length = (USHORT)(InputBuffer->Parameters).GetConnInfo.ConnectionNameLength;
        ConnectionName.MaximumLength = ConnectionName.Length;
        ConnectionName.Buffer = &((InputBuffer->Parameters).GetConnInfo.ConnectionName[0]);


        //
        // Probe for safety.
        //

        if ( Irp->RequestorMode != KernelMode ) {
            ProbeForWrite( ConnectionName.Buffer,
                          ConnectionName.Length,
                          sizeof( CHAR ));
        }

        //
        // Ok, this gets a little hand-wavey, but we have to try and figure
        // what this connection name represents.
        //

        if ( ConnectionName.Length == sizeof( L"X:" ) - sizeof( WCHAR ) ) {
            DriveLetter = ConnectionName.Buffer[0];
        } else if ( ConnectionName.Length == sizeof( L"LPT1:" ) - sizeof( WCHAR ) ) {
            DriveLetter = ConnectionName.Buffer[3];
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    OwnRcb = TRUE;

    if ( DriveLetter != 0 ) {
        DriveMapTable = GetDriveMapTable( Uid );
        DebugTrace( 0, Dbg, "GetConnectionInfo: Drive %wZ\n", &ConnectionName );

        //
        //  This is a drive relative path.  Look up the drive letter.
        //

        ASSERT( ( DriveLetter >= L'A' && DriveLetter <= L'Z' ) ||
                ( DriveLetter >= L'1' && DriveLetter <= L'9' ) );

        if ( DriveLetter >= L'A' && DriveLetter <= L'Z' ) {
            Vcb = DriveMapTable[DriveLetter - L'A'];
        } else {
            Vcb = DriveMapTable[MAX_DISK_REDIRECTIONS + DriveLetter - L'1'];
        }

        //
        //  Was the Vcb created for this user?
        //

        if ( ( Vcb != NULL ) && ( Uid.QuadPart != Vcb->Scb->UserUid.QuadPart ) ) {
            Status = STATUS_ACCESS_DENIED;
            goto ExitWithCleanup;
        }

    } else {

        //
        // This is a UNC path.  Skip over the backslashes and
        // prepend the unicode uid.
        //

        try {
            ConnectionName.Length -= (2 * sizeof( WCHAR ) );
            ConnectionName.Buffer += 2;

            Status = MakeUidServer( &UidVolumeName, &Uid, &ConnectionName );
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }

        if ( !NT_SUCCESS( Status )) {
            goto ExitWithCleanup;
        }

        DebugTrace( 0, Dbg, "GetConnectionInfo: %wZ\n", &UidVolumeName );

        Prefix = RtlFindUnicodePrefix( &NwRcb.VolumeNameTable, &UidVolumeName, 0 );
        if ( Prefix != NULL ) {
            Vcb = CONTAINING_RECORD( Prefix, VCB, PrefixEntry );

            if ( Vcb->Name.Length != UidVolumeName.Length ) {
                Vcb = NULL;
            }
        }

        //
        // tommye - MS bug 16129 / MCS 360
        //
        // If the client called WNetGetUser and pass only the server name
        // (e.g. "\\novell41") we would fail because we only looked in the 
        // volume table.  So, we go ahead and look through the server table 
        // to see if there are any matches
        //

        else {
            Prefix = RtlFindUnicodePrefix( &NwRcb.ServerNameTable, &UidVolumeName, 0 );

            if (Prefix != NULL) {
                Scb = CONTAINING_RECORD( Prefix, SCB, PrefixEntry );
                goto GotScb;
            }
        }
    }

    if ( !Vcb ) {
        Status = STATUS_BAD_NETWORK_PATH;
        goto ExitWithCleanup;
    }

    DebugTrace( 0, Dbg, "GetConnectionInfo: Vcb is 0x%08lx\n", Vcb );

    NwReferenceVcb( Vcb );
    ReferenceVcb = TRUE;
    NwReleaseRcb( &NwRcb );
    OwnRcb = FALSE;

    //
    // Get the username.  This is the same code block as in
    // WriteConnStatusEntry; it should be abstracted out.
    //

    Scb = Vcb->Scb;
GotScb:
    ASSERT( Scb != NULL );

    if ( ( Scb->MajorVersion > 3 ) &&
         ( Scb->UserName.Length == 0 ) ) {

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        pLogon = FindUser( &Uid, FALSE );
        NwReleaseRcb( &NwRcb );

        if ( pLogon ) {

            Status = NdsLookupCredentials( IrpContext,
                                           &(Scb->NdsTreeName),
                                           pLogon,
                                           &pNdsContext,
                                           CREDENTIAL_READ,
                                           FALSE );

            if ( NT_SUCCESS( Status ) ) {

                fHoldingCredentials = TRUE;

                if ( pNdsContext->Credential != NULL ) {

                    CredentialName.Length = pNdsContext->Credential->userNameLength -
                                            sizeof( WCHAR );
                    CredentialName.MaximumLength = CredentialName.Length;
                    CredentialName.Buffer = (USHORT *)
                        ( ((BYTE *) pNdsContext->Credential ) +
                          sizeof( NDS_CREDENTIAL ) +
                          pNdsContext->Credential->optDataSize );

                    puUserName = &CredentialName;
                }

            }
        }

    } else {

       puUserName = &(Scb->UserName);

    }

    DebugTrace( 0, Dbg, "GetConnectionInfo: UserName %wZ\n", puUserName );

    //
    // Strip off the uid from the server name.
    //

    ServerName.Length = (Scb->UidServerName).Length;
    ServerName.Buffer = (Scb->UidServerName).Buffer;

    while ( ServerName.Length ) {

       if ( ServerName.Buffer[0] == L'\\' ) {

           ServerName.Length -= sizeof( WCHAR );
           ServerName.Buffer += 1;
           break;
       }

       ServerName.Length -= sizeof( WCHAR );
       ServerName.Buffer += 1;

    }

    DebugTrace( 0, Dbg, "GetConnectionInfo: ServerName %wZ\n", &ServerName );

    //
    // Write a single CONN_INFORMATION structure into the output buffer.
    //

    if ( puUserName ) {

        BytesNeeded = sizeof( CONN_INFORMATION ) +
                      ServerName.Length +
                      puUserName->Length;
    } else {

       BytesNeeded = sizeof( CONN_INFORMATION ) +
                     ServerName.Length;

    }

    if ( BytesNeeded > OutputBufferLength ) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitWithCleanup;
    }

    try {

        pConnInfo->HostServerLength = ServerName.Length;
        pConnInfo->HostServer = (LPWSTR) ( (PBYTE) pConnInfo ) + sizeof( CONN_INFORMATION );
        RtlCopyMemory( pConnInfo->HostServer, ServerName.Buffer, ServerName.Length );

        pConnInfo->UserName = (LPWSTR) ( ( (PBYTE) pConnInfo->HostServer ) +
                                     ServerName.Length );

        if ( puUserName ) {

            pConnInfo->UserNameLength = puUserName->Length;
            RtlCopyMemory( pConnInfo->UserName, puUserName->Buffer, puUserName->Length );

        } else {

            pConnInfo->UserNameLength = 0;
        }

        Status = STATUS_SUCCESS;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
    
        Status = GetExceptionCode();

    }

ExitWithCleanup:

    if ( fHoldingCredentials ) {
        NwReleaseCredList( pLogon, IrpContext );
    }

    if ( OwnRcb ) {
        NwReleaseRcb( &NwRcb );
    }

    if ( ReferenceVcb ) {
        NwDereferenceVcb( Vcb, NULL, FALSE );
    }

    if ( UidVolumeName.Buffer ) {
        FREE_POOL( UidVolumeName.Buffer );
    }

    return Status;
}

NTSTATUS
GetPreferredServer(
    IN PIRP_CONTEXT IrpContext
    )
/*+++

GetPreferredServer:

    Returns the current preferred server.

---*/
{

    NTSTATUS Status;

    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    BYTE *OutputBuffer;
    ULONG OutputBufferLength;

    SECURITY_SUBJECT_CONTEXT SubjectContext;
    LARGE_INTEGER Uid;
    PLOGON pLogon;

    PUNICODE_STRING PreferredServer;

    //
    // Get the output buffer.
    //

    OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( OutputBufferLength ) {
        NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );
    } else {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // tommye
    //
    // NwMapUserBuffer may return a NULL OutputBuffer in low resource
    // situations; this was not being checked.  
    //

    if (OutputBuffer == NULL) {
        DebugTrace(-1, DEBUG_TRACE_USERNCP, "NwMapUserBuffer returned NULL OutputBuffer", 0);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get the logon structure for the user and return the preferred server.
    //

    SeCaptureSubjectContext(&SubjectContext);
    Uid = GetUid( &SubjectContext );
    SeReleaseSubjectContext(&SubjectContext);

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    pLogon = FindUser( &Uid, FALSE );

    Status = STATUS_NO_SUCH_LOGON_SESSION;

    if ( ( pLogon ) &&
         ( pLogon->ServerName.Length ) &&
         ( ( pLogon->ServerName.Length + sizeof( UNICODE_STRING ) ) <= OutputBufferLength ) ) {

        try {

            PreferredServer = (PUNICODE_STRING) OutputBuffer;
            PreferredServer->Length = pLogon->ServerName.Length;
            PreferredServer->MaximumLength = pLogon->ServerName.Length;
            PreferredServer->Buffer = ( PWCHAR ) ( OutputBuffer + sizeof( UNICODE_STRING ) );

            RtlCopyMemory( 
                        PreferredServer->Buffer,
                        pLogon->ServerName.Buffer,
                        pLogon->ServerName.Length );

            Status = STATUS_SUCCESS;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }
    }

    NwReleaseRcb( &NwRcb );

    return Status;
}

NTSTATUS
GetConnectionPerformance(
    IN PIRP_CONTEXT IrpContext
    )
/*+++

GetConnectionPerformance:

    Takes a connection name from the new shell and returns
    some estimated performance info to the shell so the shell
    can decide whether or not it wants to download icons, etc.

    The following connection names are supported:

        Drive Letter: "X:"
        Printer Port: "LPTX:"
        UNC Name:     "\\SERVER\Share\{Path\}

---*/
{

    NTSTATUS Status;

    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PNWR_REQUEST_PACKET InputBuffer;
    ULONG InputBufferLength;

    SECURITY_SUBJECT_CONTEXT SubjectContext;
    LARGE_INTEGER Uid;
    UNICODE_STRING RemoteName;

    WCHAR DriveLetter = 0;
    BOOLEAN OwnRcb = FALSE;
    BOOLEAN ReferenceScb = FALSE;
    PVCB Vcb = NULL;
    PSCB Scb = NULL;

    PLIST_ENTRY ListEntry;
    UNICODE_STRING OriginalUnc;
    PVCB * DriveMapTable;

    //
    // Get the input buffer.
    //

    InputBuffer = (PNWR_REQUEST_PACKET) IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    if ( InputBufferLength < (ULONG)FIELD_OFFSET( NWR_REQUEST_PACKET, Parameters.GetConnPerformance.RemoteName[1] ) ) {
        return( STATUS_INVALID_PARAMETER );
    }
    
    //
    // Get the UID for the caller.
    //

    SeCaptureSubjectContext(&SubjectContext);
    Uid = GetUid( &SubjectContext );
    SeReleaseSubjectContext(&SubjectContext);

    try {

        //
        // Probe for safety.
        //

        if ( Irp->RequestorMode != KernelMode ) {

            ProbeForRead( InputBuffer,
                          InputBufferLength,
                          sizeof( CHAR )
                          );
        }

        //
        // Check the remote name length to see if it is sound. This subtraction
        // can't underflow because of the test above.
        //

        if ( InputBuffer->Parameters.GetConnPerformance.RemoteNameLength >
             InputBufferLength - FIELD_OFFSET( NWR_REQUEST_PACKET, Parameters.GetConnPerformance.RemoteName) ) {

            return STATUS_INVALID_PARAMETER;
        }


        //
        // Dig out the remote name.
        //
    
        RemoteName.Length = (USHORT)(InputBuffer->Parameters).GetConnPerformance.RemoteNameLength;
        RemoteName.MaximumLength = RemoteName.Length;
        RemoteName.Buffer = &((InputBuffer->Parameters).GetConnPerformance.RemoteName[0]);
    
        //
        // Ok, this gets a little hand-wavey, but we have to try and figure
        // what this connection name represents (just like in GetConnectionInfo).
        //
    
        if ( RemoteName.Length == sizeof( L"X:" ) - sizeof( WCHAR ) ) {
            DriveLetter = RemoteName.Buffer[0];
        } else if ( RemoteName.Length == sizeof( L"LPT1:" ) - sizeof( WCHAR ) ) {
            DriveLetter = RemoteName.Buffer[3];
        }
    
        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        OwnRcb = TRUE;
    
        DebugTrace( 0, Dbg, "GetConnectionPerformance: Remote Name %wZ\n", &RemoteName );
    
        if ( DriveLetter != 0 ) {
            DriveMapTable = GetDriveMapTable( Uid );            
    
            if ( ! ( ( ( DriveLetter >= L'a' ) && ( DriveLetter <= L'z' ) ) ||
                     ( ( DriveLetter >= L'A' ) && ( DriveLetter <= L'Z' ) ) ||
                     ( ( DriveLetter >= L'0' ) && ( DriveLetter <= L'9' ) ) ) ) {
    
                Status = STATUS_BAD_NETWORK_PATH;
                goto ExitWithCleanup;
            }
    
            //
            //  This is a drive relative path.  Look up the drive letter.
            //
    
            if ( DriveLetter >= L'a' && DriveLetter <= L'z' ) {
                DriveLetter += (WCHAR) ( L'A' - L'a' );
            }
    
            if ( DriveLetter >= L'A' && DriveLetter <= L'Z' ) {
                Vcb = DriveMapTable[DriveLetter - L'A'];
            } else {
                Vcb = DriveMapTable[MAX_DISK_REDIRECTIONS + DriveLetter - L'1'];
            }
    
            //
            // Did we get a connection?
            //
    
            if ( Vcb == NULL ) {
                Status = STATUS_BAD_NETWORK_PATH;
                goto ExitWithCleanup;
            }
    
            //
            //  Was the Vcb created for this user?
            //
    
            if ( Uid.QuadPart != Vcb->Scb->UserUid.QuadPart ) {
                Status = STATUS_ACCESS_DENIED;
                goto ExitWithCleanup;
            }
    
            Scb = Vcb->Scb;
    
        } else {
    
            //
            // It's valid for the shell to pass us the remote name of a drive
            // with no reference to the drive at all.  Since we file these in
            // volume prefix table with their drive letter information, we won't
            // find them if we do a flat munge and lookup.  Therefore, we have
            // to walk the global vcb list and find the match.
            //
    
            //
            // Skip over the first slash of the provided UNC remote name.
            //
    
            RemoteName.Length -= sizeof( WCHAR );
            RemoteName.Buffer += 1;
    
            for ( ListEntry = GlobalVcbList.Flink;
                  ( ListEntry != &GlobalVcbList ) && ( Scb == NULL );
                  ListEntry = ListEntry->Flink ) {
    
                Vcb = CONTAINING_RECORD( ListEntry, VCB, GlobalVcbListEntry );
    
                OriginalUnc.Length = Vcb->Name.Length;
                OriginalUnc.MaximumLength = Vcb->Name.MaximumLength;
                OriginalUnc.Buffer = Vcb->Name.Buffer;
    
                if ( Vcb->DriveLetter ) {
    
                    //
                    // Try it as a drive connection.
                    //
    
                    while ( ( OriginalUnc.Length ) &&
                            ( OriginalUnc.Buffer[0] != L':' ) ) {
    
                        OriginalUnc.Length -= sizeof( WCHAR );
                        OriginalUnc.Buffer += 1;
                    }
    
                    if ( OriginalUnc.Buffer[0] == L':' ) {
    
                        OriginalUnc.Length -= sizeof( WCHAR );
                        OriginalUnc.Buffer += 1;
    
                        if ( RtlEqualUnicodeString( &OriginalUnc,
                                                    &RemoteName,
                                                    TRUE ) ) {
                            Scb = Vcb->Scb;
                        }
                    }
    
                 } else {
    
                     //
                     // Try it as a UNC connection; start by skipping
                     // only the leading slash, the walking to the next
                     // slash.
                     //
    
                     OriginalUnc.Length -= sizeof( WCHAR );
                     OriginalUnc.Buffer += 1;
    
                     while ( ( OriginalUnc.Length ) &&
                             ( OriginalUnc.Buffer[0] != L'\\' ) ) {
    
                         OriginalUnc.Length -= sizeof( WCHAR );
                         OriginalUnc.Buffer += 1;
                     }
    
                     if ( OriginalUnc.Length ) {
    
                         if ( RtlEqualUnicodeString( &OriginalUnc,
                                                     &RemoteName,
                                                     TRUE ) ) {
                             Scb = Vcb->Scb;
                         }
                     }
    
                 }
            }
    
        }
    
        if ( !Scb ) {
            Status = STATUS_BAD_NETWORK_PATH;
            goto ExitWithCleanup;
        }
    
        NwReferenceScb( Scb->pNpScb );
        ReferenceScb = TRUE;
        NwReleaseRcb( &NwRcb );
        OwnRcb = FALSE;
    
        DebugTrace( 0, Dbg, "GetConnectionPerformance: Scb is 0x%08lx\n", Scb );
    
        //
        // Now dig out the performance info from the LIP negotiation.
        //
        // dwSpeed - The speed of the media to the network resource in units of 100bps (e.g 1,200
        //           baud point to point link returns 12).
        // dwDelay - The delay introduced by the network when sending information (i.e. the time
        //           between starting sending data and the time that it starts being received) in
        //           units of a millisecond. This is in addition to any latency that was incorporated
        //           into the calculation of dwSpeed, so the value returned will be 0 for accessing
        //           most resources.
        // dwOptDataSize - A recommendation for the size of data in bytes that is most efficiently
        //                 sent through the network when an application makes a single request to
        //                 the network resource. For example, for a disk network resource, this
        //                 value might be 2048 or 512 when writing a block of data.
    
        (InputBuffer->Parameters).GetConnPerformance.dwFlags = WNCON_DYNAMIC;
        (InputBuffer->Parameters).GetConnPerformance.dwDelay = 0;
        (InputBuffer->Parameters).GetConnPerformance.dwOptDataSize = Scb->pNpScb->BufferSize;
        (InputBuffer->Parameters).GetConnPerformance.dwSpeed = Scb->pNpScb->LipDataSpeed;
    
        //
        // TRACKING: We don't return any good speed info for servers that have not yet
        // negotiated lip.  We may return out of date information for servers that have
        // become disconnected unless a RAS line transition occurred.  This API is bogus.
        //

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

          Status = GetExceptionCode();
          goto ExitWithCleanup;
    }

    Status = STATUS_SUCCESS;

ExitWithCleanup:

    if ( OwnRcb ) {
        NwReleaseRcb( &NwRcb );
    }

    if ( ReferenceScb ) {
        NwDereferenceScb( Scb->pNpScb );
    }

    return Status;

}

NTSTATUS
SetShareBit(
    IN PIRP_CONTEXT IrpContext,
    PFILE_OBJECT FileObject
    )
/*+++

SetShareBit:

    This function sets the share bit on a file.
    The bit won't get set until all handles to the
    file are closed.

---*/
{

    NTSTATUS Status;

    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    NODE_TYPE_CODE nodeTypeCode;
    PICB pIcb;
    PFCB pFcb;
    PVOID fsContext, fsContext2;

    DebugTrace( 0, Dbg, "SetShareBit.\n", 0 );

    //
    // Make sure this is a handle to a file.
    //

    nodeTypeCode = NwDecodeFileObject( FileObject, &fsContext, &fsContext2 );

    if ( nodeTypeCode != NW_NTC_ICB ) {
        DebugTrace( 0, Dbg, "You can only set the share bit on a file!\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    pIcb = (PICB) fsContext2;
    pFcb = pIcb->SuperType.Fcb;

    if ( pFcb->NodeTypeCode != NW_NTC_FCB ) {
        DebugTrace( 0, Dbg, "You can't set the share bit on a directory!\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Acquire this FCB so we can muck with the flags.
    //

    NwAcquireExclusiveFcb( pFcb->NonPagedFcb, TRUE );

    SetFlag( pFcb->Flags, FCB_FLAGS_LAZY_SET_SHAREABLE );

    NwReleaseFcb( pFcb->NonPagedFcb );

    return STATUS_SUCCESS;

}

VOID
LazySetShareable(
    PIRP_CONTEXT IrpContext,
    PICB pIcb,
    PFCB pFcb
)
/***

Function Description:

    This function gets called everytime an ICB with a remote handle
    is closed.  If we are closing the last ICB to an FCB and the
    caller has requested that we set the shareable bit on the FCB,
    then we need to do so now.  Otherwise, we simply return.

Caveats:

    If we fail to set the shareable bit, there is no way to notify
    the requestor of the operation that the operation was not carried
    out.

***/
{

    NTSTATUS Status;

    PLIST_ENTRY IcbListEntry;
    PICB pCurrentIcb;
    BOOLEAN OtherHandlesExist = FALSE;

    ULONG Attributes;
    BOOLEAN AttributesAreValid = FALSE;


    //
    // Get to the head of the queue, acquire the RCB,
    // and acquire this FCB to protect the ICB list
    // and FCB flags.
    //

    NwAppendToQueueAndWait( IrpContext );
    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    NwAcquireExclusiveFcb( pFcb->NonPagedFcb, TRUE );

    //
    // Scan the other ICBs on this FCB to see if any of
    // them have remote handles.
    //

    for ( IcbListEntry = pFcb->IcbList.Flink;
          IcbListEntry != &(pFcb->IcbList) ;
          IcbListEntry = IcbListEntry->Flink ) {

        pCurrentIcb = CONTAINING_RECORD( IcbListEntry, ICB, ListEntry );

        if ( ( pCurrentIcb != pIcb ) &&
             ( pCurrentIcb->HasRemoteHandle ) ) {
            OtherHandlesExist = TRUE;
        }
    }

    if ( OtherHandlesExist ) {

        //
        // We'll do it when the last handle is closed.
        //

        DebugTrace( 0, Dbg, "LazySetShareable: This isn't the last remote handle.\n", 0 );
        goto ReleaseAllAndExit;
    }

    //
    // We're closing the last handle.  Make sure we have valid attributes.
    //

    if ( !FlagOn( pFcb->Flags, FCB_FLAGS_ATTRIBUTES_ARE_VALID ) ) {

       if ( !BooleanFlagOn( pFcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

           Status = ExchangeWithWait ( IrpContext,
                                       SynchronousResponseCallback,
                                       "FwbbJ",
                                       NCP_SEARCH_FILE,
                                       -1,
                                       pFcb->Vcb->Specific.Disk.Handle,
                                       SEARCH_ALL_FILES,
                                       &pFcb->RelativeFileName );

           if ( NT_SUCCESS( Status ) ) {

               Status = ParseResponse( IrpContext,
                                       IrpContext->rsp,
                                       IrpContext->ResponseLength,
                                       "N==_b",
                                       14,
                                       &Attributes );

               if ( NT_SUCCESS( Status ) ) {
                   AttributesAreValid = TRUE;
               }
           }

       } else {

           Status = ExchangeWithWait ( IrpContext,
                                       SynchronousResponseCallback,
                                       "LbbWDbDbC",
                                       NCP_LFN_GET_INFO,
                                       pFcb->Vcb->Specific.Disk.LongNameSpace,
                                       pFcb->Vcb->Specific.Disk.LongNameSpace,
                                       SEARCH_ALL_FILES,
                                       LFN_FLAG_INFO_ATTRIBUTES,
                                       pFcb->Vcb->Specific.Disk.VolumeNumber,
                                       pFcb->Vcb->Specific.Disk.Handle,
                                       0,
                                       &pFcb->RelativeFileName );

           if ( NT_SUCCESS( Status ) ) {

               Status = ParseResponse( IrpContext,
                                       IrpContext->rsp,
                                       IrpContext->ResponseLength,
                                       "N_e",
                                       4,
                                       &Attributes );

               if ( NT_SUCCESS( Status ) ) {
                   AttributesAreValid = TRUE;
               }

           }

       }

    } else {

        Attributes = pFcb->NonPagedFcb->Attributes;
        AttributesAreValid = TRUE;
    }

    if ( !AttributesAreValid ) {
        DebugTrace( 0, Dbg, "Couldn't get valid attributes for this file.\n", 0 );
        goto ReleaseAllAndExit;
    }

    //
    // Do the set with the shareable bit on!
    //

    if ( BooleanFlagOn( pFcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

        Status = ExchangeWithWait( IrpContext,
                                   SynchronousResponseCallback,
                                   "LbbWDW--WW==WW==_W_bDbC",
                                   NCP_LFN_SET_INFO,
                                   pFcb->Vcb->Specific.Disk.LongNameSpace,
                                   pFcb->Vcb->Specific.Disk.LongNameSpace,
                                   SEARCH_ALL_FILES,
                                   LFN_FLAG_SET_INFO_ATTRIBUTES,
                                   Attributes | 0x80,
                                   0,
                                   0,
                                   0,
                                   0,
                                   8,
                                   0,
                                   8,
                                   pFcb->Vcb->Specific.Disk.VolumeNumber,
                                   pFcb->Vcb->Specific.Disk.Handle,
                                   0,
                                   &pFcb->RelativeFileName );

    } else {

        Status = ExchangeWithWait( IrpContext,
                                   SynchronousResponseCallback,
                                   "FbbbU",
                                   NCP_SET_FILE_ATTRIBUTES,
                                   Attributes | 0x80,
                                   pFcb->Vcb->Specific.Disk.Handle,
                                   SEARCH_ALL_FILES,
                                   &pFcb->RelativeFileName );

    }

    if ( !NT_SUCCESS( Status ) ) {
        DebugTrace( 0, Dbg, "Failed to set the shareable attribute on the file.\n", 0 );
        ASSERT( FALSE && "File NOT marked as shareable!!" );
    } else {
        DebugTrace( 0, Dbg, "Shareable bit successfully set.\n", 0 );
        ClearFlag( pFcb->Flags, FCB_FLAGS_LAZY_SET_SHAREABLE );
    }

ReleaseAllAndExit:

    NwReleaseFcb( pFcb->NonPagedFcb );
    NwReleaseRcb( &NwRcb );
    NwDequeueIrpContext( IrpContext, FALSE );
    return;
}


NTSTATUS
GetConnectionDetails2(
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine retrieves the details of a connection. This will return details
    as to whether a connection is NDS enabled and if yes, it will return the
    treename. The return structure looks like this:
    
    typedef struct _CONN_DETAILS2 {
         BOOL   fNds;             // TRUE if NDS, false for Bindery servers
         WCHAR  NdsTreeName[48];  // The tree name or '\0' for a 2.x or 3.x server
       } CONN_DETAILS2, *PCONN_DETAILS2;
    

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_PENDING;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    PCONN_DETAILS2 OutputBuffer;

    PSCB pScb;
    PNONPAGED_SCB pNpScb;
    PICB Icb;
    PVOID FsContext;
    NODE_TYPE_CODE nodeTypeCode;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "GetConnectionDetails2\n", 0);

    if ((nodeTypeCode = NwDecodeFileObject( IrpSp->FileObject,
                                            &FsContext,
                                            (PVOID *)&Icb )) != NW_NTC_ICB_SCB) {

        DebugTrace(0, Dbg, "Incorrect nodeTypeCode %x\n", nodeTypeCode);

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "GetConnectionDetails2 -> %08lx\n", Status );

        return Status;
    }

    //
    //  Make sure that this ICB is still active.
    //

    NwVerifyIcb( Icb );

    pScb = (PSCB)Icb->SuperType.Scb;
    nodeTypeCode = pScb->NodeTypeCode;

    if (nodeTypeCode != NW_NTC_SCB) {
        
       return STATUS_INVALID_DEVICE_REQUEST;
    }

    pNpScb = pScb->pNpScb;

    if ( OutputBufferLength < sizeof( CONN_DETAILS2 ) ) {
        
       return STATUS_BUFFER_TOO_SMALL;
    } 

    NwMapUserBuffer( Irp, KernelMode, (PVOID *)&OutputBuffer );

    //
    // tommye
    //
    // NwMapUserBuffer may return a NULL OutputBuffer in low resource
    // situations; this was not being checked.  
    //

    if (OutputBuffer == NULL) {
        DebugTrace(-1, DEBUG_TRACE_USERNCP, "NwMapUserBuffer returned NULL OutputBuffer", 0);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    try {
        //
        // Set the NDS flag 
        //

        if ( ( pScb->MajorVersion > 3 ) && ( pScb->UserName.Length == 0 ) ) {

           OutputBuffer->fNds = TRUE;

        } else {

           OutputBuffer->fNds = FALSE;
        }

        //
        // Copy over the tree name.
        //

        if ( pScb->NdsTreeName.Buffer != NULL && pScb->NdsTreeName.Length > 0 ) {

            RtlCopyMemory( 
                        (PBYTE)( OutputBuffer->NdsTreeName ),
                        (PBYTE)(pScb->NdsTreeName.Buffer),
                        pScb->NdsTreeName.Length );

            *( OutputBuffer->NdsTreeName +( pScb->NdsTreeName.Length / sizeof( WCHAR ) ) ) = L'\0';

        } else {

            *OutputBuffer->NdsTreeName = L'\0';

        }
     
        Status = STATUS_SUCCESS;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
   
        Status = GetExceptionCode();
        DebugTrace( 0, Dbg, "Exception %08lx accessing user mode buffer.\n", Status );

    }

    DebugTrace(-1, Dbg, "GetConnectionDetails2 -> %08lx\n", Status );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\nodetype.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:

    Colin Watson     [ColinW]    18-Dec-1992

Revision History:

--*/

#ifndef _NODETYPE_
#define _NODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                   ((NODE_TYPE_CODE)0x0000)

#define NW_NTC_SCB                      ((NODE_TYPE_CODE)0x0F01)
#define NW_NTC_SCBNP                    ((NODE_TYPE_CODE)0x0F02)
#define NW_NTC_FCB                      ((NODE_TYPE_CODE)0x0F03)
#define NW_NTC_DCB                      ((NODE_TYPE_CODE)0x0F04)
#define NW_NTC_VCB                      ((NODE_TYPE_CODE)0x0F05)
#define NW_NTC_ICB                      ((NODE_TYPE_CODE)0x0F06)
#define NW_NTC_IRP_CONTEXT              ((NODE_TYPE_CODE)0x0F07)
#define NW_NTC_NONPAGED_FCB             ((NODE_TYPE_CODE)0x0F08)
#define NW_NTC_RCB                      ((NODE_TYPE_CODE)0x0F0A)
#define NW_NTC_ICB_SCB                  ((NODE_TYPE_CODE)0x0F0B)
#define NW_NTC_PID                      ((NODE_TYPE_CODE)0x0F0C)
#define NW_NTC_FILE_LOCK                ((NODE_TYPE_CODE)0x0F0D)
#define NW_NTC_LOGON                    ((NODE_TYPE_CODE)0x0F0E)
#define NW_NTC_MINI_IRP_CONTEXT         ((NODE_TYPE_CODE)0x0F0F)
#define NW_NTC_NDS_CREDENTIAL           ((NODE_TYPE_CODE)0x0F10)
#define NW_NTC_WORK_CONTEXT             ((NODE_TYPE_CODE)0x0F11)

typedef CSHORT NODE_WORK_CODE;
typedef NODE_WORK_CODE  *PNODE_WORK_CODE;

#define NWC_UNDEFINED                   ((NODE_WORK_CODE)0x0000)

#define NWC_NWC_REROUTE                 ((NODE_WORK_CODE)0x0E01)
#define NWC_NWC_RECONNECT               ((NODE_WORK_CODE)0x0E02)
#define NWC_NWC_TERMINATE               ((NODE_WORK_CODE)0x0E03)


typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\ndsprocs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsProcs.h

Abstract:

    This defines the necessary NDS data structures and
    symbolic constants.

Author:

    Cory West    [CoryWest]    23-Feb-1995

Revision History:

--*/

#include "data.h"
#include "nodetype.h"
#include "struct.h"
#include <stdarg.h>

#include "crypto.h"

//
// Security information.
//

#define ENC_TYPE_RSA_PUBLIC             0x90001
#define ENC_TYPE_RC2_CBC                0x60001

#define RAND_KEY_DATA_LEN               28
#define RAND_FL_DATA_LEN                1024
#define RC2_KEY_LEN                     8

#define MAX_PUBLIC_KEY_LEN              1300
#define MAX_BSAFE_PUBLIC_KEY_LEN        200                // Typically 179.
#define MAX_BSAFE_PRIV_KEY_LEN          280                // Typically 273.

#define MAX_PW_CHARS                    16

//
// The max size for various NDS components.
//

#define MAX_RSA_BITS            512                        // Really 420.

#define NDS_TREE_NAME_LEN         32
#define NDS_BINDERY_TREE_NAME     48

#define MAX_CREDENTIAL_LEN      ( sizeof( NDS_CREDENTIAL ) + MAX_NDS_NAME_SIZE )
#define MAX_SIGNATURE_LEN       ( sizeof( NDS_SIGNATURE ) + MAX_RSA_BYTES )
#define MAX_ENC_PRIV_KEY_LEN    ( MAX_BSAFE_PRIV_KEY_LEN + 64 )

#define BSAFE_CHECKSUM_LEN              5

#define DEFAULT_RESOLVE_FLAGS RSLV_DEREF_ALIASES | RSLV_WALK_TREE | RSLV_WRITABLE

#include <packon.h>

typedef struct {

    DWORD syntaxId;          // OCTET STRING (9)

    struct {
        DWORD nameLength;
        WORD name[11];       // "Public Key"
        WORD filler;
    } attribName;

    DWORD entries;           // = 1
    DWORD totalLength;       // of attribute value OCTET STRING
    DWORD unknown1;          // = 1
    DWORD unknown2;          // = 4
    WORD _issuerDNLength;
    WORD totalDNLength;
    WORD length2;
    WORD length3;
    WORD issuerDNLength;
    WORD userDNLength;
    WORD bsafeSectionLength;
    DWORD length4;

} PUBLIC_KEY_ATTRIB;

#include <packoff.h>

typedef struct {

    DWORD blockLength;   // cipherLength + size of following hdr fields
    DWORD version;       // = 1
    DWORD encType;       // 0x060001 for RC2; 0x090001 and 0x0A0001 for RSA
    WORD  cipherLength;  // of ciphertext
    WORD  dataLength;    // of plaintext

} ENC_BLOCK_HDR, *PENC_BLOCK_HDR;

typedef struct {

    DWORD rand1;
    DWORD rand2Len;
    BYTE  rand2[RAND_FL_DATA_LEN];

} NDS_RAND_BYTE_BLOCK, *PNDS_RAND_BYTE_BLOCK;

typedef struct {

    DWORD version;
    DWORD verb;
    DWORD svrRand;
    DWORD credentialLength;

} NDS_AUTH_MSG, *PNDS_AUTH_MSG;

//
// VLM Uses the Tagged Data Store as a sort of registry on the fly.
// We, of course, don't use it, but still need the headers.
//
// We need these to be packed.
//

#include <packon.h>

typedef struct {
    DWORD version;
    WORD tag;
} TAG_DATA_HEADER;

#define TAG_PRIVATE_KEY 2
#define TAG_PUBLIC_KEY  4
#define TAG_CREDENTIAL  6
#define TAG_SIGNATURE   7
#define TAG_PROOF       8

typedef struct {

    TAG_DATA_HEADER tdh;
    DWORD validityBegin;
    DWORD validityEnd;
    DWORD random;
    WORD optDataSize;
    WORD userNameLength;

    // BYTE optData[optDataSize];
    // BYTE userName[userNameLength];

} NDS_CREDENTIAL, *PNDS_CREDENTIAL;

typedef struct {

    TAG_DATA_HEADER tdh;
    WORD signDataLength;

    //BYTE signData[signLength];

} NDS_SIGNATURE, *PNDS_SIGNATURE;

typedef struct {

    TAG_DATA_HEADER tdh;
    WORD keyDataLength;

    //BYTE BsafeKeyData[keyDataLength];

} NDS_PRIVATE_KEY, *PNDS_PRIVATE_KEY;

typedef struct {

    DWORD dwMaxFragSize;
    DWORD dwRequestSize;
    DWORD dwFragmentFlags;
    DWORD dwNdsVerb;
    DWORD dwReplyBufferSize;

} NDS_REQUEST_HEADER, *PNDS_REQUEST_HEADER;

typedef struct {

    DWORD dwFragmentSize;
    DWORD dwFraggerHandle;

} NDS_REPLY_HEADER, *PNDS_REPLY_HEADER;

#include <packoff.h>

typedef struct _NDS_CONTEXT_HEAD {

    //
    // Node id and list entries.
    //

    NODE_TYPE_CODE ntc;
    NODE_BYTE_SIZE nts;

    //
    // We can set this flag if we need to pause
    // all tree activity (like, for a logout).
    //

    BOOLEAN CredentialLocked;

    LIST_ENTRY Next;

    //
    // User's credentials.
    //

    PNDS_CREDENTIAL Credential;

    //
    // User's signature.
    //

    PNDS_SIGNATURE Signature;

    //
    // Password for this tree connection.
    //

    OEM_STRING Password;

    //
    // User's public key.
    //

    DWORD PublicKeyLen;
    BYTE *PublicNdsKey;


    //
    // If this is a supplemental credential, we track
    // the handle count and the last close time so that
    // we can delete the credential when the last
    // handle closes.
    //

    PLOGON pOwningLogon;
    ULONG SupplementalHandleCount;
    LARGE_INTEGER LastUsedTime;

    //
    // NDS tree name.  Leave enough room for the munged credential name.
    //

    UNICODE_STRING NdsTreeName;
    WCHAR NdsTreeNameBuffer[NDS_TREE_NAME_LEN + MAX_NDS_NAME_CHARS + 2];

    //
    // The current context for this tree.
    //

    UNICODE_STRING CurrentContext;
    WCHAR CurrentContextString[MAX_NDS_NAME_CHARS];

} NDS_SECURITY_CONTEXT, *PNDS_SECURITY_CONTEXT;

typedef struct _NDS_CHPW_MSG {

    DWORD challenge;
    DWORD oldPwLength;
    BYTE oldPwHash[16];
    DWORD unknown;
    DWORD newPwLength;
    BYTE newPwHash[16];
    ENC_BLOCK_HDR encPrivKeyHdr;

    // BYTE encPrivKey[];

} NDS_CHPW_MSG, *PNDS_CHPW_MSG;

//
// Credential list handling routines.
//

#define NwAcquireExclusiveCredList( pLogon, pIrpContext ) \
     ExAcquireResourceExclusiveLite( &((pLogon)->CredentialListResource), TRUE ); \
        SetFlag( (pIrpContext)->Flags, IRP_FLAG_HAS_CREDENTIAL_LOCK )

#define NwReleaseCredList( pLogon, pIrpContext ) \
    ClearFlag( (pIrpContext)->Flags, IRP_FLAG_HAS_CREDENTIAL_LOCK ); \
    ExReleaseResourceLite( &((pLogon)->CredentialListResource) )

#include <packon.h>

typedef struct {

    DWORD verb;
    UINT count;
    char  *bufEnd;
    PVOID nextItem;

} NDS_TAG, *PNDS_TAG;

#include <packoff.h>

typedef struct _nds_list_response {

    DWORD ccode;
    DWORD iterationHandle;
    DWORD numEntries;

    //
    // Followed by an array of these.
    //
    // struct {
    //  DWORD entryId;
    //  DWORD flags;
    //  DWORD subCount;
    //  DWORD modTime;
    //  NDS_STRING BaseClass;
    //  NDS_STRING entryName;
    // } [];
    //

} NDS_LIST_RESPONSE, *PNDS_LIST_RESPONSE;

typedef struct _locked_buffer {

   //
   // Describes a writeable response buffer
   // that we have locked down for the transport.
   //

   PVOID pRecvBufferVa;
   DWORD dwRecvLen;
   PMDL pRecvMdl;
   DWORD dwBytesWritten;

} LOCKED_BUFFER, *PLOCKED_BUFFER;

//
// Some of the response packet formats from ndsapi32.h
//

typedef struct {

    DWORD CompletionCode;
    DWORD RemoteEntry;
    DWORD EntryId;
    DWORD ServerAddresses;
    DWORD AddressType;
    DWORD AddressLength;

    //
    // The address is of length
    // AddressLength, of course.
    //

    BYTE  Address[1];

} NDS_WIRE_RESPONSE_RESOLVE_NAME, *PNDS_WIRE_RESPONSE_RESOLVE_NAME;

typedef struct {

    DWORD CompletionCode;
    DWORD RemoteEntry;
    DWORD EntryId;
    DWORD Unknown;
    DWORD ServerAddresses;
    DWORD AddressType;
    DWORD AddressLength;

    //
    // The address is of length
    // AddressLength, of course.
    //

    BYTE  Address[1];

} NDS_WIRE_RESPONSE_RESOLVE_NAME_REFERRAL,
*PNDS_WIRE_RESPONSE_RESOLVE_NAME_REFERRAL;

//
// Strings for searching ds attributes.
//

#define PUBLIC_KEY_ATTRIBUTE    L"Public Key"
#define VOLUME_ATTRIBUTE        L"Volume"
#define QUEUE_ATTRIBUTE         L"Queue"
#define DIR_MAP_ATTRIBUTE       L"Directory Map"
#define HOST_SERVER_ATTRIBUTE   L"Host Server"
#define HOST_VOLUME_ATTRIBUTE   L"Host Resource Name"
#define HOST_QUEUE_ATTRIBUTE    L"CN"
#define HOST_PATH_ATTRIBUTE     L"Path"

//
// Prototypes from ndslogin.c
//

NTSTATUS
NdsCanonUserName(
    IN PNDS_SECURITY_CONTEXT pNdsContext,
    IN PUNICODE_STRING puUserName,
    IN OUT PUNICODE_STRING puCanonUserName
);

NTSTATUS
NdsCheckCredentials(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword
);

NTSTATUS
NdsCheckCredentialsEx(
    IN PIRP_CONTEXT pIrpContext,
    IN PLOGON pLogon,
    IN PNDS_SECURITY_CONTEXT pNdsContext,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword
);

#define CREDENTIAL_READ         0
#define CREDENTIAL_WRITE        1

NTSTATUS
NdsLookupCredentials(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING puTreeName,
    IN PLOGON pLogon,
    OUT PNDS_SECURITY_CONTEXT *ppCredentials,
    DWORD dwDesiredAccess,
    BOOLEAN fCreate
);

NTSTATUS
NdsLookupCredentials2(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING puTreeName,
    IN PLOGON pLogon,
    OUT PNDS_SECURITY_CONTEXT *ppCredentials,
    BOOL LowerIrpHasLock
);


NTSTATUS
NdsGetCredentials(
    IN PIRP_CONTEXT pIrpContext,
    IN PLOGON pLogon,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword
);

NTSTATUS
ChangeNdsPassword(
    PIRP_CONTEXT     pIrpContext,
    DWORD            dwUserOID,
    DWORD            dwChallenge,
    PBYTE            pbOldPwHash,
    PBYTE            pbNewPwHash,
    PNDS_PRIVATE_KEY pUserPrivKey,
    PBYTE            pServerPublicBsafeKey,
    UINT             ServerPubKeyLen,
    USHORT	     NewPassLen
);

NTSTATUS
DoNdsLogon(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password
);

NTSTATUS
NdsTreeLogin(
    IN PIRP_CONTEXT           pIrpContext,
    IN PUNICODE_STRING        puUser,
    IN POEM_STRING            pOemPassword,
    IN POEM_STRING            pOemNewPassword,
    IN PLOGON                 pUserLogon
);

NTSTATUS
BeginLogin(
   IN PIRP_CONTEXT pIrpContext,
   IN DWORD        userId,
   OUT DWORD       *loginId,
   OUT DWORD       *challenge
);

NTSTATUS
FinishLogin(
    IN PIRP_CONTEXT pIrpContext,
    IN DWORD        dwUserOID,
    IN DWORD        dwLoginFlags,
    IN BYTE         pbEncryptedChallenge[16],
    IN BYTE         *pbServerPublicBsafeKey,
    IN int          cbServerPublicBsafeKeyLen,
    OUT BYTE        *pbUserEncPrivateNdsKey,
    OUT int         *pcbUserEncPrivateNdsKeyLen,
    OUT DWORD       *pdwCredentialStartTime,
    OUT DWORD       *pdwCredentialEndTime
);

NTSTATUS
NdsServerAuthenticate(
    IN PIRP_CONTEXT pIrpContext,
    IN PNDS_SECURITY_CONTEXT pNdsContext
);

NTSTATUS BeginAuthenticate(
    IN PIRP_CONTEXT pIrpContext,
    IN DWORD        dwUserId,
    OUT DWORD       *pdwSvrRandom
);

NTSTATUS
NdsLicenseConnection(
    PIRP_CONTEXT pIrpContext
);

NTSTATUS
NdsUnlicenseConnection(
    PIRP_CONTEXT pIrpContext
);

NTSTATUS
NdsLogoff(
    IN PIRP_CONTEXT pIrpContext
);

//
// Prototypes from fragex.c
//

NTSTATUS
FragExWithWait(
    IN PIRP_CONTEXT    pIrpContext,
    IN DWORD           NdsVerb,
    IN PLOCKED_BUFFER  pReplyBuffer,
    IN BYTE            *NdsRequestStr,
    ...
);

int
_cdecl
FormatBuf(
    char *buf,
    int bufLen,
    const char *format,
    va_list args
);

int
_cdecl
FormatBufS(
    char *buf,
    int bufLen,
    const char *format,
    ...
);

//
// Prototypes from ndsfsctl.c
//

NTSTATUS
NdsCreateTreeScb(
    IN PIRP_CONTEXT pIrpContext,
    IN OUT PSCB *ppScb,
    IN PUNICODE_STRING puTree,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword,
    IN BOOLEAN DeferredLogon,
    IN BOOLEAN DeleteOnClose
);

NTSTATUS
NdsLookupServerName(
    PSCB pTreeScb,
    PIRP_CONTEXT pIrpContext,
    IPXaddress *pDirServerAddress,
    POEM_STRING pOemServerServerName
);

NTSTATUS
DispatchNds(
    IN ULONG IoctlCode,
    IN PIRP_CONTEXT IrpContext
);

NTSTATUS
PrepareLockedBufferFromFsd(
    PIRP_CONTEXT pIrpContext,
    PLOCKED_BUFFER pLockedBuffer
);

NTSTATUS
DoBrowseFsctl( PIRP_CONTEXT pIrpContext,
               ULONG IoctlCode,
               BOOL LockdownBuffer
);

NTSTATUS
ConnectBinderyVolume(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING puServerName,
    PUNICODE_STRING puVolumeName
);

NTSTATUS
HandleVolumeAttach(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING puServerName,
    PUNICODE_STRING puVolumeName
);

NTSTATUS
NdsGetDsObjectFromPath(
    IN PIRP_CONTEXT pIrpContext,
    OUT PUNICODE_STRING puDsObject
);

#define NDS_OBJECTTYPE_VOLUME   1
#define NDS_OBJECTTYPE_QUEUE    2
#define NDS_OBJECTTYPE_DIRMAP   3

NTSTATUS
NdsVerifyObject(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING puVolumeObject,
    IN BOOLEAN fAllowServerJump,
    IN DWORD dwResolverFlags,
    OUT PDWORD pdwVolumeOid,
    OUT PDWORD pdwObjectType
);

NTSTATUS
NdsMapObjectToServerShare(
    PIRP_CONTEXT pIrpContext,
    PSCB *ppScb,
    PUNICODE_STRING puServerSharePath,
    BOOLEAN CreateTreeConnection,
    PDWORD pdwObjectId
);

NTSTATUS
NdsVerifyContext(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING puTree,
    PUNICODE_STRING puContext
);

NTSTATUS
NdsRawFragex(
    PIRP_CONTEXT pIrpContext
);

NTSTATUS
NdsChangePass(
    PIRP_CONTEXT pIrpContext
);

NTSTATUS
NdsListTrees(
    PIRP_CONTEXT pIrpContext
);

//
// Browsing prototypes from ndsread.c
//

NTSTATUS
NdsGetServerBasicName(
    IN PUNICODE_STRING pServerX500Name,
    IN OUT PUNICODE_STRING pServerName
);

NTSTATUS
NdsResolveName(
    IN PIRP_CONTEXT pIrpContext,
    IN PNWR_NDS_REQUEST_PACKET pNdsRequest,
	IN ULONG RequestLength, 
    IN PLOCKED_BUFFER pLockedBuffer
);

NTSTATUS
NdsGetObjectInfo(
    IN PIRP_CONTEXT pIrpContext,
    IN PNWR_NDS_REQUEST_PACKET pNdsRequest,
    IN PLOCKED_BUFFER pLockedBuffer
);

NTSTATUS
NdsListSubordinates(
    IN PIRP_CONTEXT pIrpContext,
    IN PNWR_NDS_REQUEST_PACKET pNdsRequest,
    IN PLOCKED_BUFFER pLockedBuffer
);

NTSTATUS
NdsReadAttributes(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength, 
    PLOCKED_BUFFER pLockedBuffer
);

NTSTATUS
NdsReadAttributesKm(
    PIRP_CONTEXT pIrpContext,
    DWORD dwObjectId,
    PUNICODE_STRING puAttribute,
    PLOCKED_BUFFER pLockedBuffer
);

NTSTATUS
NdsOpenStream(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength
);

NTSTATUS
NdsSetContext(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength
);

NTSTATUS
NdsGetContext(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength
);

NTSTATUS
NdsVerifyTreeHandle(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength
);

NTSTATUS
NdsGetPrintQueueInfo(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength
);

NTSTATUS
NdsGetVolumeInformation(
    PIRP_CONTEXT pIrpContext,
    PNWR_NDS_REQUEST_PACKET pNdsRequest,
    ULONG RequestLength
);

//
// Kernel mode browsing prototypes from ndsread.c
//

NTSTATUS
NdsResolveNameKm (
    PIRP_CONTEXT       pIrpContext,
    IN PUNICODE_STRING puObjectName,
    OUT DWORD          *dwObjectId,
    BOOLEAN            AllowDsJump,
    DWORD              dwFlags
);

NTSTATUS
NdsReadStringAttribute(
    PIRP_CONTEXT        pIrpContext,
    IN DWORD            dwObjectId,
    IN PUNICODE_STRING  puAttributeName,
    OUT PUNICODE_STRING puAttributeVal
);

NTSTATUS
NdsGetServerName(
    IN PIRP_CONTEXT pIrpContext,
    OUT PUNICODE_STRING pUnicodeString
);

NTSTATUS
NdsGetUserName(
    IN PIRP_CONTEXT pIrpContext,
    IN DWORD dwUserOid,
    OUT PUNICODE_STRING puUserName
);

//
// Other helper prototypes from ndsread.c
//

VOID
FreeNdsContext(
    PNDS_SECURITY_CONTEXT pNdsContext
);

VOID
NdsPing(
    IN PIRP_CONTEXT pIrpContext,
    IN PSCB pScb
);

NTSTATUS
NdsSelectConnection(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING puTreeName,
    PUNICODE_STRING puUserName,
    PUNICODE_STRING puPassword,
    BOOL DeferredLogon,
    BOOL UseBinderyConnections,
    PNONPAGED_SCB *ppNpScb
);

NTSTATUS
NdsCompletionCodetoNtStatus(
    IN PLOCKED_BUFFER pLockedBuffer
);

NTSTATUS
NdsReadPublicKey(
    IN PIRP_CONTEXT pIrpContext,
    IN DWORD entryId,
    OUT BYTE *pPubKeyVal,
    IN DWORD *pPubKeyLen
);

int
NdsGetBsafeKey(
    UCHAR       *pPubKey,
    const int   pubKeyLen,
    UCHAR       **ppBsafeKey
);

NTSTATUS
NdsAllocateLockedBuffer(
    PLOCKED_BUFFER NdsRequest,
    DWORD BufferSize
);

NTSTATUS
NdsFreeLockedBuffer(
    PLOCKED_BUFFER NdsRequest
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\ndsread.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsRead.c

Abstract:

    This module implements the NDS read and request routines called
    by the redirector natively and the support routines that go with
    them.

Author:

    Cory West    [CoryWest]    23-Feb-1995

--*/

#include "Procs.h"

#define Dbg (DEBUG_TRACE_NDS)

#pragma alloc_text( PAGE, NdsResolveNameKm )
#pragma alloc_text( PAGE, NdsReadStringAttribute )
#pragma alloc_text( PAGE, NdsReadAttributesKm )
#pragma alloc_text( PAGE, NdsCompletionCodetoNtStatus )
#pragma alloc_text( PAGE, FreeNdsContext )
#pragma alloc_text( PAGE, NdsPing )
#pragma alloc_text( PAGE, NdsGetUserName )
#pragma alloc_text( PAGE, NdsGetServerBasicName )
#pragma alloc_text( PAGE, NdsGetServerName )
#pragma alloc_text( PAGE, NdsReadPublicKey )
#pragma alloc_text( PAGE, NdsAllocateLockedBuffer )
#pragma alloc_text( PAGE, NdsFreeLockedBuffer )

NTSTATUS
NdsResolveNameKm (
    PIRP_CONTEXT       pIrpContext,
    IN PUNICODE_STRING puObjectName,
    OUT DWORD          *dwObjectId,
    BOOLEAN            AllowDsJump,
    DWORD              dwFlags
)
/*++

Description:

    This is a wrapper routine to the browser routine NdsResolveName
    for kernel components that need to resolve NDS names.

Arguments:

    pIrpContext  - must point to the dir server that we should query
    puObjectName - what we want to resolve
    *dwObjectId  - where to report the result
    AllowDsJump  - if we are referred to another dir server, can we jump?

--*/
{

    NTSTATUS Status;

    PNWR_NDS_REQUEST_PACKET Rrp;

    PNDS_RESPONSE_RESOLVE_NAME Rsp;
    LOCKED_BUFFER NdsRequestBuffer;

    PSCB Scb, OldScb;
    UNICODE_STRING ReferredServer;
    BOOL fReleasedCredentials = FALSE;
    PLOGON pLogon;

    PAGED_CODE();

    //
    // Note: If you are holding the credential resource coming in, then you 
    // need to be at the head of the queue.
    //

    //
    // Prepare the request and response buffers.
    //
    if ( puObjectName->Length > NDS_BUFFER_SIZE )
        return STATUS_INVALID_PARAMETER;

    Rrp = ALLOCATE_POOL( PagedPool, NDS_BUFFER_SIZE );

    if ( !Rrp ) {
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = NdsAllocateLockedBuffer( &NdsRequestBuffer, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        FREE_POOL( Rrp );
        return Status;
    }

    //
    // Set up the request packet.
    //

    RtlZeroMemory( Rrp, NDS_BUFFER_SIZE );

    Rrp->Version = 0;
    Rrp->Parameters.ResolveName.ObjectNameLength = puObjectName->Length;
    Rrp->Parameters.ResolveName.ResolverFlags = dwFlags;

    RtlCopyMemory( Rrp->Parameters.ResolveName.ObjectName,
                   puObjectName->Buffer,
                   puObjectName->Length );

    //
    // Do the resolve.
    //

    Status = NdsResolveName( pIrpContext, Rrp, NDS_BUFFER_SIZE, &NdsRequestBuffer );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = NdsCompletionCodetoNtStatus( &NdsRequestBuffer );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Rsp = ( PNDS_RESPONSE_RESOLVE_NAME ) NdsRequestBuffer.pRecvBufferVa;

    if ( ( Rsp->RemoteEntry == RESOLVE_NAME_REFER_REMOTE ) &&
         ( AllowDsJump ) ) {

        //
        // We need to queue this request to another server
        // since this server doesn't have any details about
        // the object.
        //

        ReferredServer.Length = (USHORT) Rsp->ServerNameLength;
        ReferredServer.MaximumLength = ReferredServer.Length;
        ReferredServer.Buffer = Rsp->ReferredServer;

        OldScb = pIrpContext->pScb;
        ASSERT( OldScb != NULL );

        //
        // If you hold the credential lock, this is the time to let go of it or
        // we might deadlock. We can reclaim it after we are at the head of the
        // new SCB queue
        //

        if (BooleanFlagOn (pIrpContext->Flags, IRP_FLAG_HAS_CREDENTIAL_LOCK)) {

           PSCB pScb;

           pScb = pIrpContext->pNpScb->pScb;

           NwAcquireExclusiveRcb( &NwRcb, TRUE );
           pLogon = FindUser( &pScb->UserUid, FALSE );
           NwReleaseRcb( &NwRcb );

           NwReleaseCredList( pLogon, pIrpContext );
           fReleasedCredentials = TRUE;
        }

        NwDequeueIrpContext( pIrpContext, FALSE );

        Status = CreateScb( &Scb,
                            pIrpContext,
                            &ReferredServer,
                            NULL,
                            NULL,
                            NULL,
                            TRUE,
                            FALSE );

        if (fReleasedCredentials == TRUE) {

           //
           // You have to be at the head of the queue before you 
           // grab the resource
           //

           if ( pIrpContext->pNpScb->Requests.Flink != &pIrpContext->NextRequest )
           {
              NwAppendToQueueAndWait( pIrpContext );
           }
           NwAcquireExclusiveCredList( pLogon, pIrpContext );
        }

        if ( !NT_SUCCESS( Status ) ) {
            goto ExitWithCleanup;
        }

        //
        // Since we've jumped servers, dereference the old host
        // server.  The new one was referenced in CreateScb().
        //

        NwDereferenceScb( OldScb->pNpScb );

    }

    *dwObjectId = Rsp->EntryId;

ExitWithCleanup:

    NdsFreeLockedBuffer( &NdsRequestBuffer );
    FREE_POOL( Rrp );
    return Status;

}

NTSTATUS
NdsReadStringAttribute(
    PIRP_CONTEXT        pIrpContext,
    IN DWORD            dwObjectId,
    IN PUNICODE_STRING  puAttributeName,
    OUT PUNICODE_STRING puAttributeVal
)
/*++

Description:

    This is a wrapper routine to the browser routine NdsReadAttributes
    for kernel components that need to read NDS string attributes.

Arguments:

    pIrpContext     - must point to the dir server that we should query
    dwObjectId      - oid of the object to query
    puAttributeName - attribute that we want
    puAttributeVal  - value of the attribute

--*/
{

    NTSTATUS Status;
    PNWR_NDS_REQUEST_PACKET Rrp;
    DWORD dwRequestSize, dwAttributeCount;
    LOCKED_BUFFER NdsRequest;

    PAGED_CODE();

    //
    // Set up the request and response buffers.
    //

    dwRequestSize = sizeof( NWR_NDS_REQUEST_PACKET ) + puAttributeName->Length;

    Rrp = ( PNWR_NDS_REQUEST_PACKET ) ALLOCATE_POOL( PagedPool, dwRequestSize );

    if ( !Rrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        FREE_POOL( Rrp );
        return Status;
    }

    //
    // Prepare the request packet.
    //

    RtlZeroMemory( (BYTE *)Rrp, dwRequestSize );

    Rrp->Version = 0;
    Rrp->Parameters.ReadAttribute.ObjectId = dwObjectId;
    Rrp->Parameters.ReadAttribute.IterHandle = DUMMY_ITER_HANDLE;
    Rrp->Parameters.ReadAttribute.AttributeNameLength = puAttributeName->Length;

    RtlCopyMemory( Rrp->Parameters.ReadAttribute.AttributeName,
                   puAttributeName->Buffer,
                   puAttributeName->Length );

    //
    // Make the request.
    //

    Status = NdsReadAttributes( pIrpContext, Rrp, NDS_BUFFER_SIZE, &NdsRequest );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Dig out the string attribute and return it.
    //

    Status = ParseResponse( NULL,
                            NdsRequest.pRecvBufferVa,
                            NdsRequest.dwBytesWritten,
                            "G___D_S_T",
                            sizeof( DWORD ),   // completion code
                            sizeof( DWORD ),   // iter handle
                            sizeof( DWORD ),   // info type
                            &dwAttributeCount, // attribute count
                            sizeof( DWORD ),   // syntax id
                            NULL,              // attribute name
                            sizeof( DWORD ),   // number of values
                            puAttributeVal );  // attribute string

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }


ExitWithCleanup:

    FREE_POOL( Rrp );
    NdsFreeLockedBuffer( &NdsRequest );
    return Status;

}

NTSTATUS
NdsReadAttributesKm(
    PIRP_CONTEXT pIrpContext,
    IN DWORD dwObjectId,
    IN PUNICODE_STRING puAttributeName,
    IN OUT PLOCKED_BUFFER pNdsRequest
)
/*++

Description:

    This is a wrapper routine to the browser routine NdsReadAttributes
    for kernel components that need to read NDS string attributes and
    get back the raw response.

Arguments:

    pIrpContext     - must point to the dir server that we should query
    dwObjectId      - oid of the object to query
    puAttributeName - attribute that we want
    puAttributeVal  - value of the attribute

--*/
{

    NTSTATUS Status;
    PNWR_NDS_REQUEST_PACKET Rrp;
    DWORD dwRequestSize;

    PAGED_CODE();

    //
    // Set up the request.
    //

    dwRequestSize = sizeof( NWR_NDS_REQUEST_PACKET ) + puAttributeName->Length;

    Rrp = ( PNWR_NDS_REQUEST_PACKET ) ALLOCATE_POOL( PagedPool, dwRequestSize );

    if ( !Rrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( (BYTE *)Rrp, dwRequestSize );

    Rrp->Version = 0;
    Rrp->Parameters.ReadAttribute.ObjectId = dwObjectId;
    Rrp->Parameters.ReadAttribute.IterHandle = DUMMY_ITER_HANDLE;
    Rrp->Parameters.ReadAttribute.AttributeNameLength = puAttributeName->Length;

    RtlCopyMemory( Rrp->Parameters.ReadAttribute.AttributeName,
                   puAttributeName->Buffer,
                   puAttributeName->Length );

    Status = NdsReadAttributes( pIrpContext, Rrp, NDS_BUFFER_SIZE, pNdsRequest );

    FREE_POOL( Rrp );
    return Status;

}

//
// Frosting and other helper wrapper functions.
//

NTSTATUS
NdsCompletionCodetoNtStatus(
    IN PLOCKED_BUFFER pLockedBuffer
)
/*+++

Description:

   Translates the completion code of an NDS transaction into
   an NTSTATUS error code.

Arguments:

   pLockedBuffer - describes the locked reply buffer that contains
                   the response.

---*/
{
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Try to get the completion code from the user's buffer.
    //

    try {

        Status = *((DWORD *)pLockedBuffer->pRecvBufferVa);

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_UNSUCCESSFUL;

    }

    //
    // Decode it.
    //

    if ( Status != STATUS_SUCCESS ) {

        DebugTrace( 0, Dbg, "NDS Error Code: %08lx\n", Status );

        switch ( Status ) {

            case -601:                   // No such entry.
            case -602:                   // No such value.
            case -603:                   // No such attribute.
            case -607:                   // Illegal attribute.
            case -610:                   // Illegal ds name.

                Status = STATUS_BAD_NETWORK_PATH;
                break;

            //
            // These may only come on a VERIFY_PASSWORD verb, which
            // we do not support.  I'm not sure, though.
            //

            case -216:                   // Password too short.
            case -215:                   // Duplicate password.

                Status = STATUS_PASSWORD_RESTRICTION;
                break;

            case -222:                   // Expired password (and no grace logins left).

                Status = STATUS_PASSWORD_EXPIRED;
                break;

            case -223:                   // Expired password; this is a successful grace login.

               Status = NWRDR_PASSWORD_HAS_EXPIRED;
               break;

            case -639:                   // Incomplete authentication.
            case -672:                   // No access.
            case -677:                   // Invalid identity.
            case -669:                   // Wrong password.

                Status = STATUS_WRONG_PASSWORD;
                break;

            case -197:                   // Intruder lockout active.
            case -220:                   // Account expired or disabled.

                Status = STATUS_ACCOUNT_DISABLED;
                break;

            case -218:                   // Login time restrictions.

                Status = STATUS_LOGIN_TIME_RESTRICTION;
                break;

            case -217:                   // Maximum logins exceeded.

                Status = STATUS_CONNECTION_COUNT_LIMIT;
                break;

            case -630:                   // We get this back for bogus resolve
                                         // name calls.  Glenn prefers this error.

                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                break;

            default:

                Status = STATUS_UNSUCCESSFUL;
        }

    }

    return Status;
}

VOID
FreeNdsContext(
    IN PNDS_SECURITY_CONTEXT pNdsSecContext
)
/*++

Routine Description:

    Free the referenced NDS context.

--*/
{
    PAGED_CODE();

    //
    // Make sure this is a valid thing to be mucking with.
    //

    if ( !pNdsSecContext ||
         pNdsSecContext->ntc != NW_NTC_NDS_CREDENTIAL ) {

        DebugTrace( 0, Dbg, "FreeNdsContext didn't get an NDS context.\n", 0 );
        return;
    }

    if ( pNdsSecContext->Credential ) {
        FREE_POOL( pNdsSecContext->Credential );
    }

    if ( pNdsSecContext->Signature ) {
        FREE_POOL( pNdsSecContext->Signature );
    }

    if ( pNdsSecContext->PublicNdsKey ) {
        FREE_POOL( pNdsSecContext->PublicNdsKey );
    }

    if ( pNdsSecContext->Password.Buffer ) {
        FREE_POOL( pNdsSecContext->Password.Buffer );
    }

    DebugTrace( 0, Dbg, "Freeing NDS security context at 0x%08lx\n", pNdsSecContext );

    FREE_POOL( pNdsSecContext );

    return;
}

VOID
NdsPing(
    IN PIRP_CONTEXT pIrpContext,
    IN PSCB pScb
)
/*++

Routine Description:

    Examine the server for NDS support and record the NDS tree
    name in the SCB for later reference.

Routine Arguments:

    pIrpContext    - A pointer to the IRP context for this transaction.
    pScb           - The SCB for the server.

Return Value:

    NTSTATUS - Status of the operation.

--*/
{

   NTSTATUS Status;

   OEM_STRING OemTreeName;
   BYTE OemBuffer[NDS_TREE_NAME_LEN];

   UNICODE_STRING TreeName;
   WCHAR WBuffer[NDS_TREE_NAME_LEN];

   UNICODE_STRING CredentialName;

   PAGED_CODE();

   pScb->NdsTreeName.Length = 0;

   OemTreeName.Length = NDS_TREE_NAME_LEN;
   OemTreeName.MaximumLength = NDS_TREE_NAME_LEN;
   OemTreeName.Buffer = OemBuffer;

   Status = ExchangeWithWait( pIrpContext,
                              SynchronousResponseCallback,
                              "N",
                              NDS_REQUEST,         // NDS Function 104
                              NDS_PING );          // NDS Subfunction 1

   if ( !NT_SUCCESS( Status ) ) {
       return;
   }

   //
   // Pull out the padded NDS name
   //

   Status = ParseResponse( pIrpContext,
                           pIrpContext->rsp,
                           pIrpContext->ResponseLength,
                           "N_r",
                           2 * sizeof( DWORD ),
                           OemBuffer,
                           NDS_TREE_NAME_LEN );

   if ( !NT_SUCCESS( Status ) ) {
       return;
   }

   //
   //  Strip off the padding and convert to unicode.
   //

   while ( OemTreeName.Length > 0 &&
           OemBuffer[OemTreeName.Length - 1] == '_' ) {
       OemTreeName.Length--;
   }

   //
   // Copy or munge the tree name, depending on the create type.
   //

   if ( pIrpContext->Specific.Create.fExCredentialCreate ) {

       TreeName.Length = 0;
       TreeName.MaximumLength = sizeof( WBuffer );
       TreeName.Buffer = WBuffer;

       Status = RtlOemStringToUnicodeString( &TreeName,
                                             &OemTreeName,
                                             FALSE );

       if ( !NT_SUCCESS( Status ) ) {
           pScb->NdsTreeName.Length = 0;
           return;
       }

       Status = BuildExCredentialServerName( &TreeName,
                                             pIrpContext->Specific.Create.puCredentialName,
                                             &CredentialName );

       if ( !NT_SUCCESS( Status ) ) {
           return;
       }

       RtlCopyUnicodeString( &pScb->NdsTreeName, &CredentialName );

       FREE_POOL( CredentialName.Buffer );

   } else {

       Status = RtlOemStringToUnicodeString( &pScb->NdsTreeName,
                                             &OemTreeName,
                                             FALSE );

       if ( !NT_SUCCESS( Status ) ) {
           pScb->NdsTreeName.Length = 0;
           return;
       }

   }

   DebugTrace( 0, Dbg, "Nds Ping: Tree is ""%wZ""\n", &pScb->NdsTreeName);
   return;

}

NTSTATUS
NdsGetUserName(
    IN PIRP_CONTEXT pIrpContext,
    IN DWORD dwUserOid,
    OUT PUNICODE_STRING puUserName
)
/*++

Description:

    Get the fully distinguished name of the user referred to
    by the provided oid.

--*/
{
    NTSTATUS Status;
    LOCKED_BUFFER NdsRequest;

    PAGED_CODE();

    //
    // Allocate buffer space.
    //

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Make the request.
    //

    Status = FragExWithWait( pIrpContext,
                             NDSV_READ_ENTRY_INFO,
                             &NdsRequest,
                             "DD",
                             0,
                             dwUserOid );

    if ( !NT_SUCCESS(Status) ) {
        goto ExitWithCleanup;
    }

    Status = NdsCompletionCodetoNtStatus( &NdsRequest );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = ParseResponse( NULL,
                            NdsRequest.pRecvBufferVa,
                            NdsRequest.dwBytesWritten,
                            "G_St",
                            sizeof( NDS_RESPONSE_GET_OBJECT_INFO ),
                            NULL,
                            puUserName );

    //
    // We either got it or we didn't.
    //

ExitWithCleanup:

    NdsFreeLockedBuffer( &NdsRequest );
    return Status;

}

NTSTATUS
NdsGetServerBasicName(
    IN PUNICODE_STRING pServerX500Name,
    IN OUT PUNICODE_STRING pServerName
) {

   //
   // Dig out the first component of the server's X.500 name.
   // We count on the X500 prefix for the server object being "CN=",
   // which might be unwise.
   //

   USHORT usPrefixSize, usSrv;

   PAGED_CODE();

   usPrefixSize = sizeof( "CN=" ) - sizeof( "" );
   usSrv = 0;

   if ( ( pServerX500Name->Buffer[0] != L'C' ) ||
        ( pServerX500Name->Buffer[1] != L'N' ) ||
        ( pServerX500Name->Buffer[2] != L'=' ) ) {

       DebugTrace( 0, Dbg, "NdsGetServerBasicName: Bad prefix.\n", 0 );
       return STATUS_INVALID_PARAMETER;
   }

   if ( pServerX500Name->Length <= usPrefixSize ) {

      DebugTrace( 0, Dbg, "NdsGetServerBasicName: Bad string length.\n", 0 );
      return STATUS_INVALID_PARAMETER;
   }

   pServerName->Buffer = pServerX500Name->Buffer + usPrefixSize;
   pServerName->Length = 0;

   while ( ( usSrv < MAX_SERVER_NAME_LENGTH ) &&
           ( pServerName->Buffer[usSrv++] != L'.' ) ) {

       pServerName->Length += sizeof( WCHAR );
   }

   if ( usSrv == MAX_SERVER_NAME_LENGTH ) {

       DebugTrace( 0, Dbg, "NdsGetServerBasicName: Bad server name response.\n", 0 );
       return STATUS_BAD_NETWORK_PATH;
   }

   pServerName->MaximumLength = pServerName->Length;
   return STATUS_SUCCESS;

}

NTSTATUS
NdsGetServerName(
    IN PIRP_CONTEXT pIrpContext,
    OUT PUNICODE_STRING puServerName
)
/*++

Description:

    Get the fully distinguished name of the server that we
    are connected to.

--*/
{

    NTSTATUS Status;
    LOCKED_BUFFER NdsRequest;

    PAGED_CODE();

    //
    // Make the request.
    //

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = FragExWithWait( pIrpContext,
                             NDSV_GET_SERVER_ADDRESS,
                             &NdsRequest,
                             NULL );

    if ( !NT_SUCCESS(Status) ) {
        goto ExitWithCleanup;
    }

    Status = NdsCompletionCodetoNtStatus( &NdsRequest );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Get the server name from the response.
    //

    Status = ParseResponse( NULL,
                            NdsRequest.pRecvBufferVa,
                            NdsRequest.dwBytesWritten,
                            "G_T",
                            sizeof( DWORD ),
                            puServerName );

    if ( !NT_SUCCESS(Status) ) {
       goto ExitWithCleanup;
    }

ExitWithCleanup:

    NdsFreeLockedBuffer( &NdsRequest );
    return Status;

}

NTSTATUS
NdsReadPublicKey(
    IN PIRP_CONTEXT pIrpContext,
    IN DWORD        dwEntryId,
    OUT BYTE        *pPubKeyVal,
    IN OUT DWORD    *pPubKeyLen
)
/*++

Routine Description:

    Read the public key referenced by the given entry id.

Routine Arguments:

    pIrpContext    - The IRP context for this connection.
    dwEntryId      - The entry id of the key.
    pPubKeyVal     - The destination buffer for the public key.
    pPubKeyLen     - The length of the public key destination buffer.

Return Value:

    The length of the key.

--*/
{
    NTSTATUS Status;

    LOCKED_BUFFER NdsRequest;

    PNWR_NDS_REQUEST_PACKET Rrp;

    DWORD dwAttrNameLen, dwAttrLen, dwRcvLen, dwNumEntries;
    BYTE *pRcv;

    PAGED_CODE();

    //
    // Allocate and zero send and receive space.
    //

    Rrp = ALLOCATE_POOL( PagedPool, NDS_BUFFER_SIZE );

    if ( !Rrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        FREE_POOL( Rrp );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in and prepare the request buffer.
    //

    RtlZeroMemory( Rrp, NDS_BUFFER_SIZE );

    Rrp->Version = 0;
    Rrp->Parameters.ReadAttribute.ObjectId = dwEntryId;
    Rrp->Parameters.ReadAttribute.IterHandle = DUMMY_ITER_HANDLE;
    Rrp->Parameters.ReadAttribute.AttributeNameLength =
        sizeof( PUBLIC_KEY_ATTRIBUTE ) - sizeof( WCHAR );

    RtlCopyMemory( Rrp->Parameters.ReadAttribute.AttributeName,
                   PUBLIC_KEY_ATTRIBUTE,
                   sizeof( PUBLIC_KEY_ATTRIBUTE ) - sizeof( WCHAR ) );

    //
    // Do the exchange.
    //

    Status = NdsReadAttributes( pIrpContext,
                                Rrp,
                                NDS_BUFFER_SIZE,
                                &NdsRequest );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Skip over the attribute header and name.
    //

    Status = ParseResponse( NULL,
                            NdsRequest.pRecvBufferVa,
                            NdsRequest.dwBytesWritten,
                            "G_D",
                            5 * sizeof( DWORD ),
                            &dwAttrNameLen );

    if ( !NT_SUCCESS( Status ) ) {

        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;
    }

    //
    // Skip over the part we've parsed and pull out the attribute.
    //

    pRcv = (PBYTE)NdsRequest.pRecvBufferVa +
               ( 6 * sizeof( DWORD ) ) +
               ROUNDUP4(dwAttrNameLen);

    dwRcvLen = NdsRequest.dwBytesWritten -
                   ( 6 * sizeof( DWORD ) ) +
                   ROUNDUP4(dwAttrNameLen);

    Status = ParseResponse( NULL,
                            pRcv,
                            dwRcvLen,
                            "GDD",
                            &dwNumEntries,
                            &dwAttrLen );

    if ( !NT_SUCCESS( Status ) ||
         dwNumEntries != 1 ) {

        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;
    }

    DebugTrace( 0, Dbg, "Public Key Length: %d\n", dwAttrLen );
    pRcv += ( 2 * sizeof( DWORD ) );

    if ( dwAttrLen <= *pPubKeyLen ) {

        RtlCopyMemory( pPubKeyVal, pRcv, dwAttrLen );
        *pPubKeyLen = dwAttrLen;
        Status = STATUS_SUCCESS;

    } else {

        DebugTrace( 0, Dbg, "Public key buffer is too small.\n", 0 );
        Status = STATUS_BUFFER_TOO_SMALL;
    }

ExitWithCleanup:

    NdsFreeLockedBuffer( &NdsRequest );
    FREE_POOL( Rrp );
    return Status;

}



NTSTATUS
NdsAllocateLockedBuffer(
    PLOCKED_BUFFER NdsRequest,
    DWORD BufferSize
)
/*++

Description:

    Allocate a buffer for io.  Lock it down and fill in the
    buffer data structure that we pass around.

--*/
{

    PAGED_CODE();

    NdsRequest->pRecvBufferVa = ALLOCATE_POOL( PagedPool, BufferSize );

    if ( !NdsRequest->pRecvBufferVa ) {
        DebugTrace( 0, Dbg, "Couldn't allocate locked io buffer.\n", 0 );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NdsRequest->dwRecvLen = BufferSize;
    NdsRequest->pRecvMdl = ALLOCATE_MDL( NdsRequest->pRecvBufferVa,
                                         BufferSize,
                                         FALSE,
                                         FALSE,
                                         NULL );

    if ( !NdsRequest->pRecvMdl ) {
        DebugTrace( 0, Dbg, "Couldn't allocate mdl for locked io buffer.\n", 0 );
        FREE_POOL( NdsRequest->pRecvBufferVa );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MmProbeAndLockPages( NdsRequest->pRecvMdl,
                         KernelMode,
                         IoWriteAccess );

    return STATUS_SUCCESS;

}

NTSTATUS
NdsFreeLockedBuffer(
    PLOCKED_BUFFER NdsRequest
)
/*++

Description:

    Free a buffer allocated for io.

--*/
{

    PAGED_CODE();

    MmUnlockPages( NdsRequest->pRecvMdl );
    FREE_MDL( NdsRequest->pRecvMdl );
    FREE_POOL( NdsRequest->pRecvBufferVa );
    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\nwpnp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    NwPnP.c

Abstract:

    This module implements the routines related to NwRdr PnP
    and PM functionality.
    
Author:

    Cory West        [CoryWest]      10-Feb-1997
    Anoop Anantha    [AnoopA]        24-Jun-1998

Revision History:

--*/

#include "procs.h"

#define Dbg       ( DEBUG_TRACE_PNP )

#ifdef _PNP_POWER_

#pragma alloc_text( PAGE, StartRedirector )
#pragma alloc_text( PAGE, StopRedirector )
#pragma alloc_text( PAGE, RegisterTdiPnPEventHandlers )
#pragma alloc_text( PAGE, NwFsdProcessPnpIrp )
#pragma alloc_text( PAGE, NwCommonProcessPnpIrp )

HANDLE TdiBindingHandle = NULL;
WCHAR IpxDevice[] = L"\\Device\\NwlnkIpx";
#define IPX_DEVICE_BYTES 32

extern BOOLEAN WorkerRunning;   //  From timer.c

//
// We assume that some devices are active at boot,
// even if we don't get notified.
//

BOOLEAN fSomePMDevicesAreActive = TRUE;


NTSTATUS
StartRedirector(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine starts the redirector.

Arguments:

    None.

Return Value:

    NTSTATUS - The status of the operation.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    //
    // We need to be in the FSP to Register the MUP.
    //

    if ( FlagOn( IrpContext->Flags, IRP_FLAG_IN_FSD ) ) {
        //
        // Check to make sure the caller is allowed to do this operation
        //
        // if ( !SeSinglePrivilegeCheck( RtlConvertLongToLuid (SE_TCB_PRIVILEGE),
        //                               IrpContext->pOriginalIrp->RequestorMode) ) {
        if ( ! IsSystemLuid()) {
            return( STATUS_ACCESS_DENIED );
        }

        Status = NwPostToFsp( IrpContext, TRUE );
        return( Status );
    }

    NwRcb.State = RCB_STATE_STARTING;

    FspProcess = PsGetCurrentProcess();

#ifdef QFE_BUILD
    StartTimer() ;
#endif

    //
    // Now connect to the MUP.
    //

    RegisterWithMup();

    KeQuerySystemTime( &Stats.StatisticsStartTime );

    NwRcb.State = RCB_STATE_NEED_BIND;

    return( STATUS_SUCCESS );
}


NTSTATUS
StopRedirector(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine shuts down the redirector.

Arguments:

    None.

Return Value:

    NTSTATUS - The status of the operation.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY LogonListEntry;
    ULONG ActiveHandles;
    ULONG RcbOpenCount;

    PAGED_CODE();

    //
    // We need to be in the FSP to Deregister the MUP.
    //

    if ( FlagOn( IrpContext->Flags, IRP_FLAG_IN_FSD ) ) {
        //
        // Check to make sure the caller is allowed to do this operation
        //
        // if ( !SeSinglePrivilegeCheck( RtlConvertLongToLuid (SE_TCB_PRIVILEGE),
        //                               IrpContext->pOriginalIrp->RequestorMode) ) {
        if ( ! IsSystemLuid()) {
            return( STATUS_ACCESS_DENIED );
        }

        Status = NwPostToFsp( IrpContext, TRUE );
        return( Status );
    }

    //
    // Unregister the bind handler with tdi.
    //

    if ( TdiBindingHandle != NULL ) {
        TdiDeregisterPnPHandlers( TdiBindingHandle );
        TdiBindingHandle = NULL;
    }

    NwRcb.State = RCB_STATE_SHUTDOWN;

    //
    //  Invalid all ICBs
    //

    SetFlag( IrpContext->Flags, IRP_FLAG_SEND_ALWAYS );
    ActiveHandles = NwInvalidateAllHandles(NULL, IrpContext);

    //
    //  To expedite shutdown, set retry count down to 2.
    //

    DefaultRetryCount = 2;

    //
    //  Close all VCBs
    //

    NwCloseAllVcbs( IrpContext );

    //
    //  Logoff and disconnect from all servers.
    //

    NwLogoffAllServers( IrpContext, NULL );

    while ( !IsListEmpty( &LogonList ) ) {

        LogonListEntry = RemoveHeadList( &LogonList );

        FreeLogon(CONTAINING_RECORD( LogonListEntry, LOGON, Next ));
    }

    InsertTailList( &LogonList, &Guest.Next );  // just in-case we don't unload.

    StopTimer();

    IpxClose();

    //
    //  Remember the open count before calling DeristerWithMup since this
    //  will asynchronously cause handle count to get decremented.
    //

    RcbOpenCount = NwRcb.OpenCount;

    DeregisterWithMup( );

    DebugTrace(0, Dbg, "StopRedirector:  Active handle count = %d\n", ActiveHandles );

    //
    //  On shutdown, we need 0 remote handles and 2 open handles to
    //  the redir (one for the service, and one for the MUP) and the timer stopped.
    //

    if ( ActiveHandles == 0 && RcbOpenCount <= 2 ) {
        return( STATUS_SUCCESS );
    } else {
        return( STATUS_REDIRECTOR_HAS_OPEN_HANDLES );
    }
}

VOID
BindToTransport(
)
/*+++

Description:  This function binds us to IPX.

---*/
{

    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    PIRP pIrp = NULL;
    UNICODE_STRING DeviceName;

    PAGED_CODE();

    //
    // Make sure we aren't already bound.
    //

    if ( ( NwRcb.State != RCB_STATE_NEED_BIND ) ||
         ( IpxHandle != NULL ) ) {

        DebugTrace( 0, Dbg, "Discarding duplicate PnP bind request.\n", 0 );
        return;
    }

    ASSERT( IpxTransportName.Buffer == NULL );
    ASSERT( pIpxDeviceObject == NULL );

    RtlInitUnicodeString( &DeviceName, IpxDevice );

    Status = DuplicateUnicodeStringWithString ( &IpxTransportName,
                                                &DeviceName,
                                                PagedPool );

    if ( !NT_SUCCESS( Status ) ) {

        DebugTrace( 0, Dbg, "Failing IPX bind: Can't set device name.\n", 0 );
        return;
    }

    //
    // Open IPX.
    //

    Status = IpxOpen();

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    //  Verify that have a large enough stack size.
    //

    if ( pIpxDeviceObject->StackSize >= FileSystemDeviceObject->StackSize ) {

        Status = STATUS_INVALID_PARAMETER;
        goto ExitWithCleanup;
    }

    //
    //  Submit a line change request.
    //

    SubmitLineChangeRequest();

    //
    // Allocate an irp and irp context.  AllocateIrpContext may raise status.
    //

    pIrp = ALLOCATE_IRP( pIpxDeviceObject->StackSize, FALSE );

    if ( pIrp == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithCleanup;
    }

    try {

        IrpContext = AllocateIrpContext( pIrp );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithCleanup;
    }

    ASSERT( IrpContext != NULL );

    //
    //  Open a handle to IPX for the permanent scb.
    //

    NwPermanentNpScb.Server.Socket = 0;
    Status = IPX_Open_Socket( IrpContext, &NwPermanentNpScb.Server );

    if ( !NT_SUCCESS( Status ) ) {
       goto ExitWithCleanup;
    }

    Status = SetEventHandler (
                 IrpContext,
                 &NwPermanentNpScb.Server,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &ServerDatagramHandler,
                 &NwPermanentNpScb );

    if ( !NT_SUCCESS( Status ) ) {
       goto ExitWithCleanup;
    }

    IrpContext->pNpScb = &NwPermanentNpScb;

    NwRcb.State = RCB_STATE_RUNNING;

    DebugTrace( 0, Dbg, "Opened IPX for NwRdr.\n", 0 );

    Status = STATUS_SUCCESS;

ExitWithCleanup:

    if ( !NT_SUCCESS( Status ) ) {

        //
        // If we failed, clean up our globals.
        //

        if ( pIpxDeviceObject != NULL ) {
            IpxClose();
            pIpxDeviceObject = NULL;
        }

        IpxHandle = NULL;

        if ( IpxTransportName.Buffer != NULL ) {
            FREE_POOL( IpxTransportName.Buffer );
            IpxTransportName.Buffer = NULL;
        }

        DebugTrace( 0, Dbg, "Failing IPX bind request.\n", 0 );

    }

    if ( pIrp != NULL ) {
        FREE_IRP( pIrp );
    }

    if ( IrpContext != NULL ) {
       
       IrpContext->pOriginalIrp = NULL; // Avoid FreeIrpContext modifying freed Irp.
       FreeIrpContext( IrpContext );
    }

    return;

}

VOID
UnbindFromTransport(
)
/*+++

Description:  This function unbinds us from IPX.

---*/
{

    PIRP_CONTEXT pIrpContext;
    BOOLEAN fAllocatedIrpContext = FALSE;
    ULONG ActiveHandles;
    PNONPAGED_SCB pNpScb;

    DebugTrace( 0, Dbg,"Unbind called\n", 0);

    //
    // Throttle the RCB.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    NwRcb.State = RCB_STATE_NEED_BIND;
    NwReleaseRcb( &NwRcb );

    //
    // Get a nearby server to figure out how much
    // IRP stack space we need for IPX.
    //

    NwReferenceUnlockableCodeSection ();
    
    pNpScb = SelectConnection( NULL );

    if ( pNpScb != NULL ) {

        //
        // If there was a connection, then we have to throttle
        // things back before unbinding the transport.
        //

        fAllocatedIrpContext = 
            NwAllocateExtraIrpContext( &pIrpContext, pNpScb );


        if ( fAllocatedIrpContext ) {

            pIrpContext->pNpScb = pNpScb;
           
            //
            // Flush all cache data.
            //

            FlushAllBuffers( pIrpContext );
            NwDereferenceScb( pNpScb );

            //
            // Invalid all ICBs.
            //

            SetFlag( pIrpContext->Flags, IRP_FLAG_SEND_ALWAYS );

            //  Lock down so that we can send a packet.
            NwReferenceUnlockableCodeSection();

            ActiveHandles = NwInvalidateAllHandles(NULL, pIrpContext);

            DebugTrace(0, Dbg, "Unbind:  Active handle count = %d\n", ActiveHandles );

            //
            // Close all VCBs.
            //

            NwCloseAllVcbs( pIrpContext );

            //
            // Logoff and disconnect from all servers.
            //

            NwLogoffAllServers( pIrpContext, NULL );

            NwDereferenceUnlockableCodeSection ();


            //
            // Free the irp context.
            //

            NwFreeExtraIrpContext( pIrpContext );
        
        } else {

            NwDereferenceScb( pNpScb );
        }

    }

    //
    // Don't stop the DPC timer so the stale SCBs will get scavenged.
    // Don't deregister with the MUP so that we're still visible.
    //

    IpxClose();

    NwDereferenceUnlockableCodeSection ();

    return;

}

VOID
TdiPnpBindHandler(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING DeviceName,
    IN PWSTR MultiSZBindList
) {

    DebugTrace( 0, Dbg, "TdiPnpBindHandler...\n", 0 );

    DebugTrace( 0, Dbg, "    OpCode %d\n", PnPOpcode );
    DebugTrace( 0, Dbg, "    DeviceName %wZ\n", DeviceName );
    DebugTrace( 0, Dbg, "    MultiSzBindList %08lx\n", MultiSZBindList );

    if (DeviceName == NULL) {
       return;
    }

    if ( ( DeviceName->Length != IPX_DEVICE_BYTES ) ||
         ( RtlCompareMemory( DeviceName->Buffer, 
                             IpxDevice,
                             IPX_DEVICE_BYTES ) != IPX_DEVICE_BYTES ) ) {

        DebugTrace( 0, Dbg, "Skipping bind for unknown device.\n", 0 );
        return;
    }

    //
    // If we get an add or a non-null update, we make sure that
    // we are bound.  We don't have to check the bindings because
    // we only support binding to one transport.
    //
    // Duplicate calls to bind or unbind have no effect.
    //

    FsRtlEnterFileSystem();

    if ( ( PnPOpcode == TDI_PNP_OP_ADD ) ||
         ( ( PnPOpcode == TDI_PNP_OP_UPDATE ) &&
           ( MultiSZBindList != NULL ) ) ) {

        BindToTransport( );

    } else if ( ( PnPOpcode == TDI_PNP_OP_DEL ) ||
                ( ( PnPOpcode == TDI_PNP_OP_UPDATE ) &&
                  ( MultiSZBindList == NULL ) ) ) {

        UnbindFromTransport( );

    } else {

        DebugTrace( 0, Dbg, "No known action for binding call.\n", 0 );
    }

    FsRtlExitFileSystem();
    
    return;

}

NTSTATUS
TdiPnpPowerEvent(
    IN PUNICODE_STRING DeviceName,
    IN PNET_PNP_EVENT PnPEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
) {

    NTSTATUS Status;

    DebugTrace( 0, Dbg, "TdiPnPPowerEvent...\n", 0 );

    //
    // Check to see if we care about this PnP/PM event.
    //

    if ( ( DeviceName->Length != IPX_DEVICE_BYTES ) ||
         ( RtlCompareMemory( DeviceName->Buffer, 
                             IpxDevice,
                             IPX_DEVICE_BYTES ) != IPX_DEVICE_BYTES ) ) {

        DebugTrace( 0, Dbg, "Skipping PnP/PM event for unknown device.\n", 0 );
        return STATUS_SUCCESS;
    }

    FsRtlEnterFileSystem();
    
    //
    // Dispatch the event.
    //

    switch ( PnPEvent->NetEvent ) {

        case NetEventSetPower:
            
            Status = PnPSetPower( PnPEvent, Context1, Context2 );
            break;

        case NetEventQueryPower:
        
            Status = PnPQueryPower( PnPEvent, Context1, Context2 );
            break;

        case NetEventQueryRemoveDevice:
        
            Status = PnPQueryRemove( PnPEvent, Context1, Context2 );
            break;

        case NetEventCancelRemoveDevice:
        
            Status = PnPCancelRemove( PnPEvent, Context1, Context2 );
            break;
    }

    FsRtlExitFileSystem();

    return Status;
}


NTSTATUS
RegisterTdiPnPEventHandlers(
    IN PIRP_CONTEXT IrpContext
)
/*++

Routine Description:

    This routine records the name of the transport to be used and
    initialises the PermanentScb.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    TDI_CLIENT_INTERFACE_INFO ClientInfo;
    UNICODE_STRING ClientName;
    WCHAR ClientNameBuffer[] = L"NWCWorkstation";

    PAGED_CODE();

    DebugTrace( 0 , Dbg, "Register TDI PnP handlers.\n", 0 );

    //
    // Don't re-register if we have already registered.
    //

    if ( TdiBindingHandle != NULL ) {

        return STATUS_SUCCESS;
    }

    ClientInfo.MajorTdiVersion = 2;
    ClientInfo.MinorTdiVersion = 0;
    
    RtlInitUnicodeString( &ClientName, ClientNameBuffer );
    ClientInfo.ClientName = &ClientName;

    ClientInfo.BindingHandler = TdiPnpBindHandler;
    
    //
    // We don't support add or delete address handlers.  This will
    // never be a problem unless the user adds multiple net cards
    // and doesn't have their IPX internal net number set correctly
    // beforehand.  We also don't support this in NT4 Net PnP.
    //

    ClientInfo.AddAddressHandler = NULL;
    ClientInfo.DelAddressHandler = NULL;

    ClientInfo.PnPPowerHandler = TdiPnpPowerEvent;

    TdiInitialize();

    return TdiRegisterPnPHandlers( &ClientInfo,
                                   sizeof( TDI_CLIENT_INTERFACE_INFO ),
                                   &TdiBindingHandle );

}

NTSTATUS
PnPSetPower(
    PNET_PNP_EVENT pEvent,
    PTDI_PNP_CONTEXT pContext1,
    PTDI_PNP_CONTEXT pContext2
) {

   NET_DEVICE_POWER_STATE PowerState;
   PIRP_CONTEXT pIrpContext;
   PNONPAGED_SCB pNpScb;
   BOOLEAN fAllocatedIrpContext = FALSE;
   NTSTATUS Status;
   PIRP_CONTEXT IrpContext = NULL;
   PIRP pIrp = NULL;

   //
   // Dig out the power state that the device is going to.
   //

   ASSERT( pEvent->BufferLength == sizeof( NET_DEVICE_POWER_STATE ) );

   PowerState = *((PNET_DEVICE_POWER_STATE) pEvent->Buffer);

   DebugTrace( 0, Dbg, "PnPSetPower came in with power state %d\n", PowerState);
   
   //
   // If we are not powering down, bring the status back to normal, else, we
   // are all ready to go to sleep.
   //

   if ( PowerState == NetDeviceStateD0 ) {

      //
      // UnThrottle the RCB.
      //
   
      NwAcquireExclusiveRcb( &NwRcb, TRUE );
      NwRcb.State = RCB_STATE_RUNNING;
      NwReleaseRcb( &NwRcb );
   
      //
      // Restart the timer so that the scavenger thread gets back to
      // work;
      //

      StartTimer();

      //
      // We can let the worker thread do it's job.
      //
      
      ASSERT( fPoweringDown == TRUE );
      
      fPoweringDown = FALSE;

   }

   if ( ( pContext2->ContextType == TDI_PNP_CONTEXT_TYPE_FIRST_OR_LAST_IF ) &&
        ( pContext2->ContextData ) ) {
      
       if ( PowerState == NetDeviceStateD0 ) {

           //
           // This is the first device coming online.
           //
          
           fSomePMDevicesAreActive = TRUE;

       } else {

           //
           // This is the last device going offline.
           //

           fSomePMDevicesAreActive = FALSE;

       }
   }
 
   DebugTrace( 0, Dbg, "NwRdr::SetPower = %08lx\n", STATUS_SUCCESS );
   return STATUS_SUCCESS;

}

NTSTATUS
PnPQueryPower(
    PNET_PNP_EVENT pEvent,
    PTDI_PNP_CONTEXT pContext1,
    PTDI_PNP_CONTEXT pContext2
) {

    NTSTATUS Status = STATUS_SUCCESS;
    NET_DEVICE_POWER_STATE PowerState;
    ULONG ActiveHandles;
    PIRP_CONTEXT pIrpContext;
    BOOLEAN fAllocatedIrpContext = FALSE;
    PNONPAGED_SCB pNpScb;

    //
    // Dig out the power state that the stack wants to go to.
    //

    ASSERT( pEvent->BufferLength == sizeof( NET_DEVICE_POWER_STATE ) );

    PowerState = *((PNET_DEVICE_POWER_STATE) pEvent->Buffer);

    DebugTrace( 0, Dbg, "PnPQueryPower came in with power state %d\n", PowerState);

    //
    // We have to cover going from the powered state
    // to the unpowered state only.  All other transitions
    // will be allowed regardless of our state.
    //

    if ( ( fSomePMDevicesAreActive ) &&
         ( PowerState != NetDeviceStateD0 ) ) {

        ActiveHandles = PnPCountActiveHandles();

        if (( ActiveHandles ) || ( WorkerRunning == TRUE )) {
            
           Status = STATUS_REDIRECTOR_HAS_OPEN_HANDLES;
        
        } else {

           //
           // We are saying ok to a possible hibernate state. We have 
           // to ensure that the scavenger thread doesn't start. Also,
           // we have to flush buffers.
           // 

           fPoweringDown = TRUE;

           pNpScb = SelectConnection( NULL );

           if ( pNpScb != NULL ) {

               fAllocatedIrpContext =
                   NwAllocateExtraIrpContext( &pIrpContext, pNpScb );

               NwDereferenceScb( pNpScb );

               if ( fAllocatedIrpContext ) {
                   FlushAllBuffers( pIrpContext );
                   NwFreeExtraIrpContext( pIrpContext );
               }
           }
           
           //
           // Throttle down the RCB.
           //
       
           NwAcquireExclusiveRcb( &NwRcb, TRUE );
           NwRcb.State = RCB_STATE_NEED_BIND;
           NwReleaseRcb( &NwRcb );
       
           //
           // The TimerDPC will not fire if we stop the timer.
           //

           StopTimer();

        }
    }

    DebugTrace( 0, Dbg, "NwRdr::QueryPower.  New State = %d\n", PowerState );
    DebugTrace( 0, Dbg, "NwRdr::QueryPower = %08lx\n", Status );
    return Status;
}

NTSTATUS
PnPQueryRemove(
    PNET_PNP_EVENT pEvent,
    PTDI_PNP_CONTEXT pContext1,
    PTDI_PNP_CONTEXT pContext2
) {

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ActiveHandles;

    //
    // We might want to flush all the buffers here, though
    // it should be true that this is followed by an unbind if the
    // device is going to be removed and the unbind will flush all
    // the buffers.
    //

    ActiveHandles = PnPCountActiveHandles();

    if ( ActiveHandles ) {
        Status = STATUS_REDIRECTOR_HAS_OPEN_HANDLES;
    }

    //
    // I think we need to throttle back new creates
    // until we get the unbind or the CancelRemove call.
    //

    DebugTrace( 0, Dbg, "PnPQueryRemove returned with status %d\n", Status);

    DebugTrace( 0, Dbg, "NwRdr::QueryRemove = %08lx\n", Status );
    return Status;
}

NTSTATUS
PnPCancelRemove(
    PNET_PNP_EVENT pEvent,
    PTDI_PNP_CONTEXT pContext1,
    PTDI_PNP_CONTEXT pContext2
) {

    //
    // We don't do anything for a cancel remove
    // because we don't throttle back the redirector
    // on a query remove call.
    //

    DebugTrace( 0, Dbg, "NwRdr::CancelRemove = %08lx\n", STATUS_SUCCESS );
    DebugTrace( 0, Dbg,"PnPCancelRemove returned with status %d\n", STATUS_SUCCESS);
    
    return STATUS_SUCCESS;
}

ULONG
PnPCountActiveHandles(
    VOID
)
/*+++
 
    This routine counts the number of active handles in the
    redirector and returns the count to the caller.

---*/
{

   PNONPAGED_SCB pNpScb;
   PSCB pScb;
   PVCB pVcb;
   KIRQL OldIrql;
   PLIST_ENTRY ScbQueueEntry, NextScbQueueEntry;
   PLIST_ENTRY VcbQueueEntry;
   PLIST_ENTRY NextVcbQueueEntry;
   ULONG OpenFileCount = 0;

   KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

   //
   // Walk the SCB list and check for open files.
   //

   for ( ScbQueueEntry = ScbQueue.Flink ;
         ScbQueueEntry != &ScbQueue ;
         ScbQueueEntry =  NextScbQueueEntry ) {

       pNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );
       pScb = pNpScb->pScb;

       if ( pScb != NULL ) {

           //
           //  Release the SCB spin lock as we are about
           //  to touch nonpaged pool.
           //

           NwReferenceScb( pNpScb ); 
           KeReleaseSpinLock( &ScbSpinLock, OldIrql );

           //
           // Grab the RCB so we can walk the VCB list and
           // check the OpenFileCount.
           //

           NwAcquireExclusiveRcb( &NwRcb, TRUE );

           OpenFileCount += pScb->OpenFileCount;

           //
           // Subtract off the open counts for explicitly
           // connected VCBs; we can shut down with these.
           //
           
           for ( VcbQueueEntry = pScb->ScbSpecificVcbQueue.Flink ;
                 VcbQueueEntry != &pScb->ScbSpecificVcbQueue;
                 VcbQueueEntry = NextVcbQueueEntry ) {

               pVcb = CONTAINING_RECORD( VcbQueueEntry, VCB, VcbListEntry );
               NextVcbQueueEntry = VcbQueueEntry->Flink;

               if ( BooleanFlagOn( pVcb->Flags, VCB_FLAG_EXPLICIT_CONNECTION ) ) {
                   OpenFileCount -= 1;
               }

           }

           NwReleaseRcb( &NwRcb );
           KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
           NwDereferenceScb( pNpScb );
       }

       NextScbQueueEntry = pNpScb->ScbLinks.Flink;
   }

   KeReleaseSpinLock( &ScbSpinLock, OldIrql );

   DebugTrace( 0, Dbg, "PnPCountActiveHandles: %d\n", OpenFileCount );
   return OpenFileCount;

}



NTSTATUS
NwFsdProcessPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the FSD routine that handles the PNP IRP

Arguments:

    DeviceObject - Supplies the device object for the write function.

    Irp - Supplies the IRP to process.

Return Value:

    NTSTATUS - The result status.
    
Notes:

    The query target device relation is the only call that is implemented
    currently. This is done by returing the PDO associated with the transport
    connection object. In any case this routine assumes the responsibility of
    completing the IRP and return STATUS_PENDING.

--*/
{

    PIRP_CONTEXT pIrpContext = NULL;
    NTSTATUS Status;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, DEBUG_TRACE_ALWAYS, "NwFsdProcessPnpIrp \n", 0);

    //
    // Call the common write routine.
    //

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        pIrpContext = AllocateIrpContext( Irp );
        Status = NwCommonProcessPnpIrp( pIrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( pIrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = Status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error Status that we get back from the
            //  execption code
            //

            Status = NwProcessException( pIrpContext, GetExceptionCode() );
      }

    }

    if ( pIrpContext ) {

        NwCompleteRequest(pIrpContext, Status);
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }

    FsRtlExitFileSystem();
    
    //
    // Return to the caller.
    //

    DebugTrace(-1, DEBUG_TRACE_ALWAYS, "NwFsdFsdProcessPnpIrp -> %08lx\n", STATUS_PENDING);

    return Status;

}


NTSTATUS
NwCommonProcessPnpIrp (
    IN PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

Arguments:

    IrpContext - Supplies the request being processed.

Return Value:

    The status of the operation.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;
    PFCB Fcb;
    PICB Icb;
    NODE_TYPE_CODE NodeTypeCode;
    PVOID FsContext;

    PAGED_CODE();

    DebugTrace(0, DEBUG_TRACE_ALWAYS, "NwCommonProcessPnpIrp...\n", 0);

    //
    //  Get the current stack location
    //

    Irp = IrpContext->pOriginalIrp;
    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( 0, DEBUG_TRACE_ALWAYS, "Irp  = %08lx\n", (ULONG_PTR)Irp);

    switch (IrpSp->MinorFunction) {
    
    case IRP_MN_QUERY_DEVICE_RELATIONS:
        
        if (IrpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation) {
            
            PIRP         pAssociatedIrp = NULL;

            if (pIpxFileObject != NULL) {
                
                PDEVICE_OBJECT                     pRelatedDeviceObject;
                PIO_STACK_LOCATION                 pIrpStackLocation,
                                                   pAssociatedIrpStackLocation;

                ObReferenceObject( pIpxFileObject );
                
                pRelatedDeviceObject = IoGetRelatedDeviceObject( pIpxFileObject );

                pAssociatedIrp = ALLOCATE_IRP( pRelatedDeviceObject->StackSize,
                                               FALSE);

                if (pAssociatedIrp != NULL) {
    
                    KEVENT CompletionEvent;
    
                    KeInitializeEvent( &CompletionEvent,
                                       SynchronizationEvent,
                                       FALSE );

                    //
                    // tommye - MS bug 37033/ MCS 270
                    //
                    //  Set the Status to STATUS_NOT_SUPPORTED
                    //

                    pAssociatedIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

                    //
                    // Fill up the associated IRP and call the underlying driver.
                    //

                    pAssociatedIrpStackLocation = IoGetNextIrpStackLocation(pAssociatedIrp);
                    pIrpStackLocation           = IoGetCurrentIrpStackLocation(Irp);
    
                    *pAssociatedIrpStackLocation = *pIrpStackLocation;
    
                    pAssociatedIrpStackLocation->FileObject = pIpxFileObject;
                    pAssociatedIrpStackLocation->DeviceObject = pRelatedDeviceObject;
    
                    IoSetCompletionRoutine(
                        pAssociatedIrp,
                        PnpIrpCompletion,
                        &CompletionEvent,
                        TRUE,TRUE,TRUE);
    
                    Status = IoCallDriver( pRelatedDeviceObject, pAssociatedIrp );
    
                    if (Status == STATUS_PENDING) {
                        (VOID) KeWaitForSingleObject(
                                   &CompletionEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
                    }
    
                    Irp->IoStatus = pAssociatedIrp->IoStatus;
                    Status = Irp->IoStatus.Status;
    
                    if (!NT_SUCCESS(Status)) {
                        Error(EVENT_NWRDR_NETWORK_ERROR,
                              Status,
                              IpxTransportName.Buffer,
                              IpxTransportName.Length,
                              0);

                    }
    
                    ObDereferenceObject( pIpxFileObject );
    
                    FREE_IRP(pAssociatedIrp);
                } else {
                
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    ObDereferenceObject( pIpxFileObject );
                }
            }
        }
    
        break;

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


NTSTATUS
PnpIrpCompletion(
    PDEVICE_OBJECT pDeviceObject,
    PIRP           pIrp,
    PVOID          pContext)
/*++

Routine Description:

    This routine completes the PNP irp.

Arguments:

    DeviceObject - Supplies the device object for the packet being processed.

    pIrp - Supplies the Irp being processed

    pContext - the completion context

--*/
{
    PKEVENT pCompletionEvent = pContext;

    KeSetEvent(
        pCompletionEvent,
        IO_NO_INCREMENT,
        FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\pid.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Pid.c

Abstract:

    This module implements the routines for the NetWare
    redirector to map 32 bit NT pid values to unique 8 bit
    NetWare values.

    The technique used is to maintain a table of up to 256 entries.
    The index of each entry corresponds directly to the 8 bit pid
    values. Each table entry contains the 32 bit pid of the process
    that has obtained exclusive access to the pid and the number of
    handles opened by that process to this server.

    This architecture limits the number of processes on the NT machine
    communicating with any one server to 256.

    Note: This package assumes that the size that the PidTable grows is
    a factor of 256-<initial entries>. This ensures that running out of
    valid entries in the table will occur when 256 entries have been
    allocated.

Author:

    Colin Watson    [ColinW]    02-Mar-1993

Revision History:

--*/

#include "Procs.h"


//
//  The debug trace level
//

#define Dbg                             (DEBUG_TRACE_CREATE)

#define INITIAL_MAPPID_ENTRIES          8
#define MAPPID_INCREASE                 8
#define MAX_PIDS                        256

#define PID_FLAG_EOJ_REQUIRED     0x00000001   // EOJ required for this PID

/*
 *  The PID mapping table has been moved from a global to a per-SCB structure.
 *  The limit of 256, or rather 8-bit NetWare task numbers, should be
 *  only a problem on a per-connection basis.  I.E. Each connection is
 *  now limited to 256 concurrent tasks with a file open.
 *
 *  An example of this working is NAS and OS/2 netx sessions.  Each
 *  netx started is going to use the PSP for the task ID.  But each
 *  netx session on these systems is in a VDM and so have duplicate 
 *  PSP's.
 *
 *  Other than messiness, the only problem with this is that retrieving
 *  the SCB may be a problem in some circumstances.
 *
 *  P.S. The Resource stuff insists on being non-paged memory.
 *
 */

#define PidResource pNpScb->RealPidResource //Terminal Server merge

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwInitializePidTable )
#pragma alloc_text( PAGE, NwUninitializePidTable )
#pragma alloc_text( PAGE, NwMapPid )
#pragma alloc_text( PAGE, NwSetEndOfJobRequired )
#pragma alloc_text( PAGE, NwUnmapPid )
#endif


BOOLEAN
NwInitializePidTable(
    IN PNONPAGED_SCB pNpScb
    )
/*++

Routine Description:

    Creates a table for the MapPid package. The initial table has room for
    INITIAL_MAPPID_ENTRIES entries.

Arguments:


Return Value:

    TRUE or FALSE signifying success or failure.

--*/

{
    int i;
    PNW_PID_TABLE TempPid =
        ALLOCATE_POOL( PagedPool,
            FIELD_OFFSET( NW_PID_TABLE, PidTable[0] ) +
                (sizeof(NW_PID_TABLE_ENTRY) * INITIAL_MAPPID_ENTRIES ));

    PAGED_CODE();

    if (TempPid == NULL) {
        return( FALSE );
    }


    TempPid->NodeByteSize = (CSHORT)(FIELD_OFFSET( NW_PID_TABLE, PidTable[0] ) +
        (sizeof(NW_PID_TABLE_ENTRY) * INITIAL_MAPPID_ENTRIES) );

    TempPid->NodeTypeCode = NW_NTC_PID;

    TempPid->ValidEntries = INITIAL_MAPPID_ENTRIES;

    //
    //  Set the ref count for all PIDs to 0, except for pid 0.  We
    //  do this so that we don't allocate PID 0.
    //

    TempPid->PidTable[0].ReferenceCount = 1;
    for (i = 1; i < INITIAL_MAPPID_ENTRIES ; i++ ) {
        TempPid->PidTable[i].ReferenceCount = 0;
    }
    if (pNpScb) {
        pNpScb->PidTable = TempPid;
    }

    ExInitializeResourceLite( &PidResource );
    return( TRUE );
}

VOID
NwUninitializePidTable(
    IN PNONPAGED_SCB pNpScb
    )
/*++

Routine Description:

    Deletes a table created by the MapPid package.

Arguments:

    Pid - Supplies the table to be deleted.

Return Value:

--*/

{
#ifdef NWDBG
    int i;
#endif
    PNW_PID_TABLE PidTable = NULL;
    PAGED_CODE();

    if (pNpScb) {
         PidTable = pNpScb->PidTable;
    }
#ifdef NWDBG
    ASSERT(PidTable->NodeTypeCode == NW_NTC_PID);
    ASSERT(PidTable->PidTable[0].ReferenceCount == 1);

    for (i = 1; i < PidTable->ValidEntries; i++ ) {
        ASSERT(PidTable->PidTable[i].ReferenceCount == 0);
    }
#endif
    ExAcquireResourceExclusiveLite( &PidResource, TRUE ); 
    if (PidTable) {
        FREE_POOL( PidTable );
        PidTable = NULL;
    }

    if (pNpScb) {
        pNpScb->PidTable = NULL;
    }

    ExReleaseResourceLite( &PidResource );

    ExDeleteResourceLite( &PidResource );
    return;

}

NTSTATUS
NwMapPid(
    IN PNONPAGED_SCB pNpScb,
    IN ULONG_PTR Pid32,
    OUT PUCHAR Pid8
    )
/*++

Routine Description:

    Obtain an 8 bit unique pid for this process. Either use a previosly
    assigned pid for this process or assign an unused value.

Arguments:

    Pid - Supplies the datastructure used by MapPid to assign pids for
    this server.

    Pid32 - Supplies the NT pid to be mapped.

    Pid8 - Returns the 8 bit Pid.

Return Value:

    NTSTATUS of result.

--*/
{
    int i;
    int FirstFree = -1;
    int NewEntries;
    PNW_PID_TABLE TempPid;
    PNW_PID_TABLE PidTable;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite( &PidResource, TRUE );
    ASSERT (pNpScb != NULL);
    if (pNpScb) {
        PidTable = pNpScb->PidTable;
    }
    // DebugTrace(0, Dbg, "NwMapPid for %08lx\n", Pid32);

    for (i=0; i < (PidTable)->ValidEntries ; i++ ) {

        if ((PidTable)->PidTable[i].Pid32 == Pid32) {

            //
            //  This process already has an 8 bit pid value assigned.
            //  Increment the reference and return.
            //

            (PidTable)->PidTable[i].ReferenceCount++;
            *Pid8 = (UCHAR) i;

            // DebugTrace(0, Dbg, "NwMapPid found %08lx\n", (DWORD)i);

            ExReleaseResourceLite( &PidResource );
            ASSERT( *Pid8 != 0 );
            return( STATUS_SUCCESS );
        }

        if ((FirstFree == -1) &&
            ((PidTable)->PidTable[i].ReferenceCount == 0)) {

            //
            //  i is the lowest free 8 bit Pid.
            //

            FirstFree = i;
        }
    }

    //
    //  This process does not have a pid assigned.
    //

    if ( FirstFree != -1 ) {

        //
        //  We had an empty slot so assign it to this process.
        //

        (PidTable)->PidTable[FirstFree].ReferenceCount++;
        (PidTable)->PidTable[FirstFree].Pid32 = Pid32;
        *Pid8 = (UCHAR) FirstFree;

        DebugTrace(0, DEBUG_TRACE_ICBS, "NwMapPid maps %08lx\n", (DWORD)FirstFree);

        ExReleaseResourceLite( &PidResource );
        ASSERT( *Pid8 != 0 );
        return( STATUS_SUCCESS );
    }

    if ( (PidTable)->ValidEntries == MAX_PIDS ) {

        //
        //  We've run out of 8 bit pids.
        //

        ExReleaseResourceLite( &PidResource );

#ifdef NWDBG
        //
        // temporary code to find the PID leak.
        //
        DumpIcbs() ;
        ASSERT(FALSE) ;
#endif

        return(STATUS_TOO_MANY_OPENED_FILES);
    }

    //
    //  Grow the table by MAPPID_INCREASE entries.
    //

    NewEntries = (PidTable)->ValidEntries + MAPPID_INCREASE;

    TempPid =
        ALLOCATE_POOL( PagedPool,
            FIELD_OFFSET( NW_PID_TABLE, PidTable[0] ) +
                (sizeof(NW_PID_TABLE_ENTRY) * NewEntries ));

    if (TempPid == NULL) {
        ExReleaseResourceLite( &PidResource );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlMoveMemory(
        TempPid,
        (PidTable),
        FIELD_OFFSET( NW_PID_TABLE, PidTable[0] ) +
        (sizeof(NW_PID_TABLE_ENTRY) * (PidTable)->ValidEntries ));


    TempPid->NodeByteSize = (CSHORT)(FIELD_OFFSET( NW_PID_TABLE, PidTable[0] ) +
        (sizeof(NW_PID_TABLE_ENTRY) * NewEntries) );

    for ( i = (PidTable)->ValidEntries; i < NewEntries ; i++ ) {
        TempPid->PidTable[i].ReferenceCount = 0;
    }

    TempPid->ValidEntries = NewEntries;

    //
    // Save the index of the first free entry.
    //

    i = (PidTable)->ValidEntries;

    //
    //  The new table is initialized.  Free up the old table and return
    //  the first of the new entries.
    //

    FREE_POOL(PidTable);
    PidTable = TempPid;

    (PidTable)->PidTable[i].ReferenceCount = 1;
    (PidTable)->PidTable[i].Pid32 = Pid32;
    *Pid8 = (UCHAR) i;

    ASSERT (pNpScb != NULL);
    if (pNpScb) {
        pNpScb->PidTable = PidTable;
    }

    DebugTrace(0, DEBUG_TRACE_ICBS, "NwMapPid grows & maps %08lx\n", (DWORD)i);

    ExReleaseResourceLite( &PidResource );
    return( STATUS_SUCCESS );
}

VOID
NwSetEndOfJobRequired(
    IN PNONPAGED_SCB pNpScb,
    IN UCHAR Pid8
    )
/*++

Routine Description:

    Mark a PID as must send End Of Job when the pid reference count
    reaches zero.

Arguments:

    Pid8 - The 8 bit Pid to mark.

Return Value:

    None.

--*/
{
    PNW_PID_TABLE PidTable;
    PAGED_CODE();

    ASSERT( Pid8 != 0 );
    ASSERT (pNpScb != NULL);

    ExAcquireResourceExclusiveLite( &PidResource, TRUE );
    PidTable = pNpScb->PidTable;

    // DebugTrace(0, Dbg, "NwSetEndofJob for %08lx\n", (DWORD)Pid8);
    SetFlag( PidTable->PidTable[Pid8].Flags, PID_FLAG_EOJ_REQUIRED );
    ExReleaseResourceLite( &PidResource );
    return;
}


VOID
NwUnmapPid(
    IN PNONPAGED_SCB pNpScb,
    IN UCHAR Pid8,
    IN PIRP_CONTEXT IrpContext OPTIONAL
    )
/*++

Routine Description:

    This routine dereference an 8 bit PID.  If the reference count reaches
    zero and this PID is marked End Of Job required, this routine will
    also send an EOJ NCP for this PID.

Arguments:

    Pid8 - The 8 bit Pid to mark.

    IrpContext - The IrpContext for the IRP in progress.

Return Value:

    None.

--*/
{
    BOOLEAN EndOfJob;
    PNW_PID_TABLE PidTable;

    PAGED_CODE();

    ASSERT( Pid8 != 0 );
    // DebugTrace(0, Dbg, "NwUnmapPid %08lx\n", (DWORD)Pid8);

    // I think this can occur during shutdown and errors
    if ( pNpScb == NULL ) {   
        return;              
    }
    // This was reported as a problem.
    if ( !pNpScb->PidTable ) {
        return;
    }

    ExAcquireResourceExclusiveLite( &PidResource, TRUE ); // MP safety
    PidTable = pNpScb->PidTable;

    if ( BooleanFlagOn( PidTable->PidTable[Pid8].Flags, PID_FLAG_EOJ_REQUIRED ) &&
         IrpContext != NULL ) {
        ExReleaseResourceLite( &PidResource );
        //
        //  The End of job flag is set.  Obtain a position at the front of
        //  the SCB queue, so that if we need to set an EOJ NCP, we needn't
        //  wait for the SCB queue while holding the PID table lock.
        //

        EndOfJob = TRUE;
        NwAppendToQueueAndWait( IrpContext );

        if ( !pNpScb->PidTable ) {
            return;
        }
        ExAcquireResourceExclusiveLite( &PidResource, TRUE ); // MP safety

    } else {
        EndOfJob = FALSE;
    }

    //
    //  The PidResource lock controls the reference counts.
    //
    ASSERT (pNpScb != NULL);
    //ExAcquireResourceExclusiveLite( &PidResource, TRUE );
    // WWM - Since we release the lock while we wait, pidtable may have moved
    PidTable = pNpScb->PidTable;
    if ( !PidTable ) {
        return;
    }

    if ( --(PidTable)->PidTable[Pid8].ReferenceCount == 0 ) {

        //
        //  Done with this PID, send an EOJ if necessary.
        //

        // DebugTrace(0, Dbg, "NwUnmapPid (ref=0) %08lx\n", (DWORD)Pid8);
        (PidTable)->PidTable[Pid8].Flags = 0;
        (PidTable)->PidTable[Pid8].Pid32 = 0;

        if ( EndOfJob ) {
            (VOID) ExchangeWithWait(
                       IrpContext,
                       SynchronousResponseCallback,
                       "F-",
                       NCP_END_OF_JOB );
        }
    }

    if ( EndOfJob ) {
        NwDequeueIrpContext( IrpContext, FALSE );
    }

    ExReleaseResourceLite( &PidResource );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\ndslogin.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsLogin.c

Abstract:

    This file implements the functionality required to
    perform an NDS login.

Author:

    Cory West    [CoryWest]    23-Feb-1995

Revision History:

--*/

#include "Procs.h"

#define Dbg (DEBUG_TRACE_NDS)

//
// Pageable.
//

#pragma alloc_text( PAGE, NdsCanonUserName )
#pragma alloc_text( PAGE, NdsCheckCredentials )
#pragma alloc_text( PAGE, NdsCheckCredentialsEx )
#pragma alloc_text( PAGE, NdsLookupCredentials )
#pragma alloc_text( PAGE, NdsLookupCredentials2 )
#pragma alloc_text( PAGE, NdsGetCredentials )
#pragma alloc_text( PAGE, DoNdsLogon )
#pragma alloc_text( PAGE, BeginLogin )
#pragma alloc_text( PAGE, FinishLogin )
#pragma alloc_text( PAGE, ChangeNdsPassword )
#pragma alloc_text( PAGE, NdsServerAuthenticate )
#pragma alloc_text( PAGE, BeginAuthenticate )
#pragma alloc_text( PAGE, NdsLicenseConnection )
#pragma alloc_text( PAGE, NdsUnlicenseConnection )
#pragma alloc_text( PAGE, NdsGetBsafeKey )

//
// Non pageable:
//
// NdsTreeLogin (holds a spin lock)
// NdsLogoff (holds a spin lock)
//

VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer
);

NTSTATUS
NdsCanonUserName(
    IN PNDS_SECURITY_CONTEXT pNdsContext,
    IN PUNICODE_STRING puUserName,
    IN OUT PUNICODE_STRING puCanonUserName
)
/*+++

    Canonicalize the user name for the given tree and
    current connection state.  Canonicalization includes
    handling the correct context and cleaning off all
    the X500 prefixes.

    ALERT! The credential list must be held (shared or
    exclusive) while this function is called.

---*/
{

    NTSTATUS Status = STATUS_SUCCESS;

    USHORT CurrentTargetIndex;
    USHORT PrefixBytes;

    UNICODE_STRING UnstrippedName;
    PWCHAR CanonBuffer;

    PAGED_CODE();

    CanonBuffer = ALLOCATE_POOL( PagedPool, MAX_NDS_NAME_SIZE );
    if ( !CanonBuffer ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If the name starts with a dot, it's referenced from the root
    // of the tree and we should not append the context.  We should,
    // however, strip off the leading dot so that name resolution
    // will work.
    //

    if ( puUserName->Buffer[0] == L'.' ) {

        UnstrippedName.Length = puUserName->Length - sizeof( WCHAR );
        UnstrippedName.MaximumLength = UnstrippedName.Length;
        UnstrippedName.Buffer = &(puUserName->Buffer[1]);

        goto StripPrefixes;
    }

    //
    // If the name contains any dots, it's qualified and we
    // should probably just use it as is.
    //

    CurrentTargetIndex= 0;

    while ( CurrentTargetIndex< ( puUserName->Length / sizeof( WCHAR ) ) ) {

        if ( puUserName->Buffer[CurrentTargetIndex] == L'.' ) {

            UnstrippedName.Length = puUserName->Length;
            UnstrippedName.MaximumLength = puUserName->Length;
            UnstrippedName.Buffer = puUserName->Buffer;

            goto StripPrefixes;
        }

        CurrentTargetIndex++;
    }

    //
    // If we have a context for this tree and the name isn't
    // qualified, we should append the context.
    //

    if ( pNdsContext->CurrentContext.Length ) {

        if ( ( puUserName->Length +
             pNdsContext->CurrentContext.Length ) >= MAX_NDS_NAME_SIZE ) {

            DebugTrace( 0, Dbg, "NDS canon name too long.\n", 0 );
            Status = STATUS_INVALID_PARAMETER;
            goto ExitWithCleanup;
        }

        RtlCopyMemory( CanonBuffer, puUserName->Buffer, puUserName->Length );
        CanonBuffer[puUserName->Length / sizeof( WCHAR )] = L'.';

        RtlCopyMemory( ((BYTE *)CanonBuffer) + puUserName->Length + sizeof( WCHAR ),
                       pNdsContext->CurrentContext.Buffer,
                       pNdsContext->CurrentContext.Length );

        UnstrippedName.Length = puUserName->Length +
                                pNdsContext->CurrentContext.Length +
                                sizeof( WCHAR );
        UnstrippedName.MaximumLength = MAX_NDS_NAME_SIZE;
        UnstrippedName.Buffer = CanonBuffer;

        goto StripPrefixes;

    }

    //
    // It wasn't qualified, nor was there a context to append, so fail it.
    //

    DebugTrace( 0, Dbg, "The name %wZ is not canonicalizable.\n", puUserName );
    Status = STATUS_UNSUCCESSFUL;
    goto ExitWithCleanup;

StripPrefixes:

    //
    // All of these indexes are in BYTES, not WCHARS!
    //

    CurrentTargetIndex = 0;
    PrefixBytes = 0;
    puCanonUserName->Length = 0;

    while ( ( CurrentTargetIndex < UnstrippedName.Length ) &&
            ( puCanonUserName->Length < puCanonUserName->MaximumLength ) ) {

        //
        // Strip off the X.500 prefixes.
        //

        if ( UnstrippedName.Buffer[CurrentTargetIndex / sizeof( WCHAR )] == L'=' ) {

            CurrentTargetIndex += sizeof( WCHAR );
            puCanonUserName->Length -= PrefixBytes;
            PrefixBytes = 0;

            continue;
        }

        puCanonUserName->Buffer[puCanonUserName->Length / sizeof( WCHAR )] =
            UnstrippedName.Buffer[CurrentTargetIndex / sizeof( WCHAR )];

        puCanonUserName->Length += sizeof( WCHAR );
        CurrentTargetIndex += sizeof( WCHAR );

        if ( UnstrippedName.Buffer[CurrentTargetIndex / sizeof( WCHAR )] == L'.' ) {
            PrefixBytes = 0;
            PrefixBytes -= sizeof( WCHAR );
        } else {
            PrefixBytes += sizeof( WCHAR );
        }
    }

   DebugTrace( 0, Dbg, "Canonicalized name: %wZ\n", puCanonUserName );

ExitWithCleanup:

   FREE_POOL( CanonBuffer );
   return Status;
}

NTSTATUS
NdsCheckCredentials(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword
)
/*++

    Given a set of credentials and a username and password,
    we need to determine if username and password match those
    that were used to acquire the credentials.

--*/
{

    NTSTATUS Status;
    PLOGON pLogon;
    PNONPAGED_SCB pNpScb;
    PSCB pScb;
    PNDS_SECURITY_CONTEXT pCredentials;

    PAGED_CODE();

    //
    // Grab the user's LOGON structure and credentials.
    //

    pNpScb = pIrpContext->pNpScb;
    pScb = pNpScb->pScb;

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    pLogon = FindUser( &pScb->UserUid, FALSE );
    NwReleaseRcb( &NwRcb );

    if ( !pLogon ) {
        DebugTrace( 0, Dbg, "Invalid client security context in NdsCheckCredentials.\n", 0 );
        return STATUS_ACCESS_DENIED;
    }

    Status = NdsLookupCredentials( pIrpContext,
                                   &pScb->NdsTreeName,
                                   pLogon,
                                   &pCredentials,
                                   CREDENTIAL_READ,
                                   FALSE );

    if( NT_SUCCESS( Status ) ) {

        if ( pCredentials->CredentialLocked ) {

            Status = STATUS_DEVICE_BUSY;

        } else {

            Status = NdsCheckCredentialsEx( pIrpContext,
                                            pLogon,
                                            pCredentials,
                                            puUserName,
                                            puPassword );

        }

        NwReleaseCredList( pLogon, pIrpContext );
    }

    return Status;

}

NTSTATUS
NdsCheckCredentialsEx(
    IN PIRP_CONTEXT pIrpContext,
    IN PLOGON pLogon,
    IN PNDS_SECURITY_CONTEXT pNdsContext,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword
)
/*++

    Given a set of credentials and a username and password,
    we need to determine if username and password match those
    that were used to acquire the credentials.

    ALERT!  The credential list must be held (either shared or
    exclusive) while this function is called.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING CredentialName;

    UNICODE_STRING CanonCredentialName, CanonUserName;
    PWCHAR CredNameBuffer;
    PWCHAR UserNameBuffer;

    UNICODE_STRING StoredPassword;
    PWCHAR Stored;

    PAGED_CODE();

    //
    // If we haven't logged into to the tree, there is no security
    // conflict.  Otherwise, run the check.
    //

    //
    // There are occasions when the credential structure will be NULL
    // This is when supplemental credentials are provided and an empty
    // credential shell is created by ExCreateReferenceCredentials. In
    // such cases, we can safely report back a credential conflict.
    //

     if ( pNdsContext->Credential == NULL) {
   
         DebugTrace( 0, Dbg, "NdsCheckCredentialsEx: Credential conflict due to emtpy cred shell\n", 0);
         Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
         return Status;
     }

    CredNameBuffer = ALLOCATE_POOL( NonPagedPool,
                                    ( 2 * MAX_NDS_NAME_SIZE ) +
                                    ( MAX_PW_CHARS * sizeof( WCHAR ) ) );
    if ( !CredNameBuffer ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    UserNameBuffer = (PWCHAR) (((BYTE *)CredNameBuffer) + MAX_NDS_NAME_SIZE );
    Stored = (PWCHAR) (((BYTE *)UserNameBuffer) + MAX_NDS_NAME_SIZE );

    if ( puUserName && puUserName->Length ) {

        //
        // Canon the incoming name and the credential name.
        //

        CanonUserName.Length = 0;
        CanonUserName.MaximumLength = MAX_NDS_NAME_SIZE;
        CanonUserName.Buffer = UserNameBuffer;

        Status = NdsCanonUserName( pNdsContext,
                                   puUserName,
                                   &CanonUserName );

        if ( !NT_SUCCESS( Status )) {
            Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
            goto ExitWithCleanup;
        }

        CanonCredentialName.Length = 0;
        CanonCredentialName.MaximumLength = MAX_NDS_NAME_SIZE;
        CanonCredentialName.Buffer = CredNameBuffer;

        CredentialName.Length = (USHORT)pNdsContext->Credential->userNameLength - sizeof( WCHAR );
        CredentialName.MaximumLength = CredentialName.Length;
        CredentialName.Buffer = (PWCHAR)( (PBYTE)(pNdsContext->Credential) +
                                          sizeof( NDS_CREDENTIAL ) );

        Status = NdsCanonUserName( pNdsContext,
                                   &CredentialName,
                                   &CanonCredentialName );

        if ( !NT_SUCCESS( Status )) {
            Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
            goto ExitWithCleanup;
        }

        //
        // See if they match.
        //

        if ( RtlCompareUnicodeString( &CanonUserName, &CanonCredentialName, TRUE )) {
            DebugTrace( 0, Dbg, "NdsCheckCredentialsEx: user name conflict.\n", 0 );
            Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
            goto ExitWithCleanup;
        }
    }

    //
    // Now check the password.
    //

    StoredPassword.Length = 0;
    StoredPassword.MaximumLength = MAX_PW_CHARS * sizeof( WCHAR );
    StoredPassword.Buffer = Stored;

    RtlOemStringToUnicodeString( &StoredPassword,
                                 &pNdsContext->Password,
                                 FALSE );
    
    if ( puPassword && puPassword->Length ) {
        

        if ( RtlCompareUnicodeString( puPassword,
                                      &StoredPassword,
                                      TRUE ) ) {
            DebugTrace( 0, Dbg, "NdsCheckCredentialsEx: password conflict.\n", 0 );
            Status = STATUS_WRONG_PASSWORD;
        }
    
        //
        // In the case of a NULL incoming password, the length field will
        // be zero but a buffer field exists.
        //

    } else if ( puPassword && !puPassword->Length  && puPassword->Buffer) {

        if (StoredPassword.Length != 0) {
            DebugTrace( 0, Dbg, "NdsCheckCredentialsEx: password conflict.\n", 0 );
            Status = STATUS_WRONG_PASSWORD;
        }
    }

ExitWithCleanup:

    FREE_POOL( CredNameBuffer );
    return Status;
}

NTSTATUS
NdsLookupCredentials(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING puTreeName,
    IN PLOGON pLogon,
    OUT PNDS_SECURITY_CONTEXT *ppCredentials,
    DWORD dwDesiredAccess,
    BOOLEAN fCreate
)
/*+++

    Retrieve the nds credentials for the given tree from the
    list of valid credentials for the specified user.
    
    puTreeName      - The name of the tree that we want credentials for.  If NULL
                      is specified, we return the credentials for the default tree.
    pLogon          - The logon structure for the user we want to access the tree.
    ppCredentials   - Where to put the pointed to the credentials.
    dwDesiredAccess - CREDENTIAL_READ if we want read/only access, CREDENTIAL_WRITE
                      if we're going to change the credentials.
    fCreate         - If the credentials don't exist, should we create them?

    We return the credentials with the list held in the appropriate mode.  The
    caller is responsible for releasing the list when done with the credentials.

---*/
{

    NTSTATUS Status;

    PLIST_ENTRY pFirst, pNext;
    PNDS_SECURITY_CONTEXT pNdsContext;

    PAGED_CODE();


    if (BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT)) {
       ASSERT( pIrpContext->pNpScb->Requests.Flink == &pIrpContext->NextRequest );
    }

    NwAcquireExclusiveCredList( pLogon, pIrpContext );

    pFirst = &pLogon->NdsCredentialList;
    pNext = pLogon->NdsCredentialList.Flink;

    while ( pNext && ( pFirst != pNext ) ) {

        pNdsContext = (PNDS_SECURITY_CONTEXT)
                      CONTAINING_RECORD( pNext,
                                         NDS_SECURITY_CONTEXT,
                                         Next );

        ASSERT( pNdsContext->ntc == NW_NTC_NDS_CREDENTIAL );

        //
        // If the tree name is null, we'll return the first one
        // on the list.  Otherwise this will work as normal.
        //

        if (puTreeName == NULL) {
            *ppCredentials = pNdsContext;
            return STATUS_SUCCESS;
        }

        //
        //  If this is the one we want then we need to return it.
        //  We have the try/except around this because some places
        //  call this with puTreeName coming from a user buffer.
        //  If the access fails to that then we just pretend
        //  the compare failed
        //

        try {
             if (!RtlCompareUnicodeString( 
                                       puTreeName,
                                       &pNdsContext->NdsTreeName,
                                       TRUE ) ) {

                *ppCredentials = pNdsContext;
                return STATUS_SUCCESS;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            //Just fall thru and keep going
        }

        //
        //  Goto the next entry
        //

        pNext = pNdsContext->Next.Flink;

    }

    //
    // We didn't find the credential.  Should we create it?
    //

    NwReleaseCredList( pLogon, pIrpContext );

    if ( !fCreate || !puTreeName ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Acquire exclusive since we're mucking with the list.
    //

    NwAcquireExclusiveCredList( pLogon, pIrpContext );

    pNdsContext = ( PNDS_SECURITY_CONTEXT )
        ALLOCATE_POOL( PagedPool, sizeof( NDS_SECURITY_CONTEXT ) );

    if ( !pNdsContext ) {

        DebugTrace( 0, Dbg, "Out of memory in NdsLookupCredentials.\n", 0 );
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto UnlockAndExit;
    }

    //
    // Initialize the structure.
    //

    RtlZeroMemory( pNdsContext, sizeof( NDS_SECURITY_CONTEXT ) );
    pNdsContext->ntc = NW_NTC_NDS_CREDENTIAL;
    pNdsContext->nts = sizeof( NDS_SECURITY_CONTEXT );

    //
    // Initialize the tree name.
    //

    pNdsContext->NdsTreeName.MaximumLength = sizeof( pNdsContext->NdsTreeNameBuffer );
    pNdsContext->NdsTreeName.Buffer = pNdsContext->NdsTreeNameBuffer;

    RtlCopyUnicodeString( &pNdsContext->NdsTreeName, puTreeName );

    //
    // Initialize the context buffer.
    //

    pNdsContext->CurrentContext.Length = 0;
    pNdsContext->CurrentContext.MaximumLength = sizeof( pNdsContext->CurrentContextString );
    pNdsContext->CurrentContext.Buffer = pNdsContext->CurrentContextString;

    //
    // Insert the context into the list.
    //

    InsertHeadList( &pLogon->NdsCredentialList, &pNdsContext->Next );
    *ppCredentials = pNdsContext;
    pNdsContext->pOwningLogon = pLogon;

    //
    // There's no chance that someone's going to come in during this
    // small window and do a logout because there's no login data
    // in the credentials.
    //

    return STATUS_SUCCESS;

UnlockAndExit:

    NwReleaseCredList( pLogon, pIrpContext );
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
NdsGetCredentials(
    IN PIRP_CONTEXT pIrpContext,
    IN PLOGON pLogon,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword
)
/*++

    Do an NDS tree login and aquire a valid set of credentials.

--*/
{
    NTSTATUS Status;

    USHORT i;
    UNICODE_STRING LoginName, LoginPassword;
    PWCHAR NdsName;
    PWCHAR NdsPassword;

    OEM_STRING OemPassword;
    PBYTE OemPassBuffer;
    PNDS_SECURITY_CONTEXT pNdsContext;

    PAGED_CODE();

    //
    // Prepare our login name by canonicalizing the supplied user
    // name or using a default user name if appropriate.
    //

    NdsName = ALLOCATE_POOL( NonPagedPool, MAX_NDS_NAME_SIZE +
                                           MAX_PW_CHARS * sizeof( WCHAR ) +
                                           MAX_PW_CHARS );

    if ( !NdsName ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NdsPassword = (PWCHAR) (((BYTE *) NdsName) + MAX_NDS_NAME_SIZE );
    OemPassBuffer = ((BYTE *) NdsPassword ) + ( MAX_PW_CHARS * sizeof( WCHAR ) );

    LoginName.Length = 0;
    LoginName.MaximumLength = MAX_NDS_NAME_SIZE;
    LoginName.Buffer = NdsName;

    Status = NdsLookupCredentials( pIrpContext,
                                   &pIrpContext->pScb->NdsTreeName,
                                   pLogon,
                                   &pNdsContext,
                                   CREDENTIAL_READ,
                                   TRUE );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // If the credential list is locked, someone is logging
    // out and we have to fail the request.
    //

    if ( pNdsContext->CredentialLocked ) {

        Status = STATUS_DEVICE_BUSY;
        NwReleaseCredList( pLogon, pIrpContext );
        goto ExitWithCleanup;
    }

    //
    // Fix up the user name.
    // ALERT! We are holding the credential list!
    //

    if ( puUserName && puUserName->Buffer ) {

        Status = NdsCanonUserName( pNdsContext,
                                   puUserName,
                                   &LoginName );

        if ( !NT_SUCCESS( Status )) {
            Status = STATUS_NO_SUCH_USER;
        }

    } else {

        //
        // There's no name, so try the default name in the
        // current context.
        //

        if ( pNdsContext->CurrentContext.Length > 0 ) {

            //
            // Make sure the lengths fit and all that.
            //

            if ( ( pLogon->UserName.Length +
                 pNdsContext->CurrentContext.Length ) >= LoginName.MaximumLength ) {

                Status = STATUS_INVALID_PARAMETER;
                goto NameResolved;
            }

            RtlCopyMemory( LoginName.Buffer, pLogon->UserName.Buffer, pLogon->UserName.Length );
            LoginName.Buffer[pLogon->UserName.Length / sizeof( WCHAR )] = L'.';

            RtlCopyMemory( ((BYTE *)LoginName.Buffer) + pLogon->UserName.Length + sizeof( WCHAR ),
                           pNdsContext->CurrentContext.Buffer,
                           pNdsContext->CurrentContext.Length );

            LoginName.Length = pLogon->UserName.Length +
                               pNdsContext->CurrentContext.Length +
                               sizeof( WCHAR );

            DebugTrace( 0, Dbg, "Using default name and context for login: %wZ\n", &LoginName );

        } else {
            Status = STATUS_NO_SUCH_USER;
        }

    }

NameResolved:

    NwReleaseCredList( pLogon, pIrpContext );

    //
    // RELAX! The credential list is free.
    //

    if ( !NT_SUCCESS( Status ) ) {
        DebugTrace( 0, Dbg, "No name in NdsGetCredentials.\n", 0 );
        goto ExitWithCleanup;
    }

    //
    // If there's a password, use it.  Otherwise, use the default password.
    //

    if ( puPassword && puPassword->Buffer ) {

        LoginPassword.Length = puPassword->Length;
        LoginPassword.MaximumLength = puPassword->MaximumLength;
        LoginPassword.Buffer = puPassword->Buffer;

    } else {

        LoginPassword.Length = 0;
        LoginPassword.MaximumLength = MAX_PW_CHARS * sizeof( WCHAR );
        LoginPassword.Buffer = NdsPassword;

        RtlCopyUnicodeString( &LoginPassword,
                              &pLogon->PassWord );
    }

    //
    // Convert the password to upcase OEM and login.
    //

    OemPassword.Length = 0;
    OemPassword.MaximumLength = MAX_PW_CHARS;
    OemPassword.Buffer = OemPassBuffer;

    Status = RtlUpcaseUnicodeStringToOemString( &OemPassword,
                                                &LoginPassword,
                                                FALSE );

    if ( !NT_SUCCESS( Status )) {
        Status = STATUS_WRONG_PASSWORD;
        goto ExitWithCleanup;
    }

    Status = NdsTreeLogin( pIrpContext, &LoginName, &OemPassword, NULL, pLogon );

ExitWithCleanup:

   FREE_POOL( NdsName );
   return Status;
}

NTSTATUS
DoNdsLogon(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password
)
/*+++

Description:

    This is the lead function for handling login and authentication to
    Netware Directory Services.  This function acquires credentials to
    the appropriate tree for the server that the irp context points to,
    logging us into that tree if necessary, and authenticates us to the
    current server.

    This routine gets called from reconnect attempts and from
    normal requests.  Since the allowable actions on each of these paths
    are different, it might make sense to have two routines, each
    more maintainable than this single routine.  For now, watch out for
    code in the RECONNECT_ATTEMPT cases.

Arguments:

    pIrpContext - irp context; must refer to appropriate server
    UserName    - login username
    Password    - password

--*/
{

    NTSTATUS Status;
    PLOGON pLogon;
    PNDS_SECURITY_CONTEXT pCredentials;
    PSCB pScb;
    UNICODE_STRING BinderyName;
    UNICODE_STRING uUserName;
    UNICODE_STRING NtGroup;
    USHORT Length;
    PSCB pOriginalServer = NULL;
    DWORD UserOID;

    BOOL AtHeadOfQueue = FALSE;
    BOOL HoldingCredentialResource = FALSE;
    BOOL PasswordExpired = FALSE;
    BOOL LowerIrpHasLock = FALSE;
    PIRP_CONTEXT LowerContext;

    PAGED_CODE();

    //
    // Get to the head of the queue if we need to.
    //

    if ( BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT ) ) {
        ASSERT( pIrpContext->pNpScb->Requests.Flink == &pIrpContext->NextRequest );
    } else {
        NwAppendToQueueAndWait( pIrpContext );
    }

    AtHeadOfQueue = TRUE;

    //
    // Grab the user's logon structure.
    //

    pScb = pIrpContext->pScb;

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    pLogon = FindUser( &pScb->UserUid, FALSE );
    NwReleaseRcb( &NwRcb );

    if ( !pLogon ) {

        DebugTrace( 0, Dbg, "Invalid client security context.\n", 0 );
        Status = STATUS_ACCESS_DENIED;
        goto ExitWithCleanup;
    }

    //
    // If this is a reconnect attempt, check to see if the IRP_CONTEXT 
    // below us has the credential list lock
    //
    
    if (BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT ) ) {

       LowerContext = CONTAINING_RECORD( pIrpContext->NextRequest.Flink,
                                         IRP_CONTEXT,
                                         NextRequest );

       //
       // We cannot be the last IRP_CONTEXT on this queue
       //

       ASSERT (LowerContext != pIrpContext);

       if (BooleanFlagOn ( LowerContext->Flags, IRP_FLAG_HAS_CREDENTIAL_LOCK ) ) {

            LowerIrpHasLock = TRUE;
          }
    }

    //
    // Login and then re-get the tree credentials.
    //

    if (BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT)) {

       Status = NdsLookupCredentials2 ( pIrpContext,
                                        &pScb->NdsTreeName,
                                        pLogon,
                                        &pCredentials,
                                        LowerIrpHasLock );
    }
    else
    {
        Status = NdsLookupCredentials( pIrpContext,
                                       &pScb->NdsTreeName,
                                       pLogon,
                                       &pCredentials,
                                       CREDENTIAL_READ,
                                       FALSE );
    }

    if ( !NT_SUCCESS( Status ) ) {
       HoldingCredentialResource = FALSE;
       goto LOGIN;
    }

    HoldingCredentialResource = TRUE;

    //
    // Are we logged in? We can't hold the
    // credential list while logging in!!
    //

    if ( !pCredentials->Credential ) {

        HoldingCredentialResource = FALSE;

        //
        // We should release the credential resource only if the lower IRP
        // context does not have the lock implying that we have the lock.
        //

        if (!LowerIrpHasLock) {
                   
           NwReleaseCredList( pLogon, pIrpContext );
        }
        goto LOGIN;
    }

    //
    // If this credential is locked, we fail!
    //

    if ( pCredentials->CredentialLocked ) {
        Status = STATUS_DEVICE_BUSY;
        goto ExitWithCleanup;
    }

    Status = NdsCheckCredentialsEx( pIrpContext,
                                    pLogon,
                                    pCredentials,
                                    UserName,
                                    Password );

    if( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    goto AUTHENTICATE;

LOGIN:

    ASSERT( HoldingCredentialResource == FALSE );

    //
    // If this is a reconnect attempt and we don't have credentials
    // already, we have to give up.  We can't acquire credentials
    // during a reconnect and retry because it could cause a deadlock.
    //

    if ( BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT ) ) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;
    }

    Status = NdsGetCredentials( pIrpContext,
                                pLogon,
                                UserName,
                                Password );

    if ( !NT_SUCCESS( Status )) {
        goto ExitWithCleanup;
    }
    //
    // NdsGetCredentials can take us off the head of the queue. So, we need
    // to get back to the head of the queue before we do anything else.
    //

    if (pIrpContext->pNpScb->Requests.Flink != &pIrpContext->NextRequest) {
       NwAppendToQueueAndWait ( pIrpContext );
    }

    if ( Status == NWRDR_PASSWORD_HAS_EXPIRED ) {
        PasswordExpired = TRUE;
    }

    Status = NdsLookupCredentials( pIrpContext,
                                   &pScb->NdsTreeName,
                                   pLogon,
                                   &pCredentials,
                                   CREDENTIAL_READ,
                                   FALSE );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // If this credential is locked, someone is
    // already logging out and so we fail this.
    //

    if ( pCredentials->CredentialLocked ) {
        
       Status = STATUS_DEVICE_BUSY;
        
        if (!LowerIrpHasLock) {
           NwReleaseCredList( pLogon, pIrpContext );
        }
        
        goto ExitWithCleanup;
    }

    HoldingCredentialResource = TRUE;

AUTHENTICATE:

    ASSERT( HoldingCredentialResource == TRUE );
    ASSERT( AtHeadOfQueue == TRUE );

    //
    // Ensure that you are indeed at the head of the queue.
    //

    ASSERT( pIrpContext->pNpScb->Requests.Flink == &pIrpContext->NextRequest );
    
    //
    // NdsServerAuthenticate will not take us off the
    // head of the queue since this is not allowed.
    //

    Status = NdsServerAuthenticate( pIrpContext, pCredentials );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    if (!LowerIrpHasLock) {
        NwReleaseCredList( pLogon, pIrpContext );
    }

    HoldingCredentialResource = FALSE;

ExitWithCleanup:

    if (( HoldingCredentialResource )&& (!LowerIrpHasLock)) {
        NwReleaseCredList( pLogon, pIrpContext );
    }

    if ( AtHeadOfQueue ) {

        //
        // If we failed and this was a reconnect attempt, don't dequeue the
        // irp context or we may deadlock when we try to do the bindery logon.
        // See ReconnectRetry() for more information on this restriction.
        //

        if ( !BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT ) ) {
            NwDequeueIrpContext( pIrpContext, FALSE );
        }

    }

    if ( ( NT_SUCCESS( Status ) ) &&
         ( PasswordExpired ) ) {
        Status = NWRDR_PASSWORD_HAS_EXPIRED;
    }

    DebugTrace( 0, Dbg, "DoNdsLogin: Status = %08lx\n", Status );
    return Status;
    
    
}

NTSTATUS
NdsTreeLogin(
    IN PIRP_CONTEXT    pIrpContext,
    IN PUNICODE_STRING puUser,
    IN POEM_STRING     pOemPassword,
    IN POEM_STRING     pOemNewPassword,
    IN PLOGON          pUserLogon
)
/*++

Routine Description:

    Login the specified user to the NDS tree at the server referred
    to by the given IrpContext using the supplied password.

Arguments:

    pIrpContext     - The irp context for this server connection.
    puUser          - The user login name.
    pOemPassword    - The upper-case, plaintext password.
    pOemNewPassword - The new password for a change pass request.
    pUserLogon      - The LOGON security structure for this user,
                      which may be NULL for a change password
                      request.

Side Effects:

    If successful, the user's credentials, signature, and
    public key are saved in the nds context for this NDS tree
    in the credential list in the LOGON structure.

Notes:

    This function may have to jump around a few servers to
    get all the info needed for login.  If restores the irp
    context to the original server so that when we authenticate,
    we authenticate to the correct server (as requested by the
    user).

--*/
{
    NTSTATUS Status;                   // status of the operation
    int CryptStatus;                   // crypt status

    DWORD dwChallenge;                 // four byte server challenge
    PUNICODE_STRING puServerName;      // server's distinguished name

    DWORD dwUserOID,                   // user oid on the current server
          dwSrcUserOID,                // user oid on the originating server
          dwServerOID;                 // server oid

    BYTE  *pbServerPublicNdsKey,       // server's public key in NDS format
          *pbServerPublicBsafeKey;     // server's public BSAFE key

    int   cbServerPublicNdsKeyLen,     // length of server public NDS key
          cbServerPublicBsafeKeyLen;   // length of server pubilc BSAFE key

    BYTE  *pbUserPrivateNdsKey,        // user's private key in NDS format
          *pbUserPrivateBsafeKey;      // user's private BSAFE key

    int   cbUserPrivateNdsKeyLen;      // length of user private NDS key
    WORD  cbUserPrivateBsafeKeyLen;    // length of user private BSAFE key

    BYTE  pbNw3PasswdHash[16];         // nw3 passwd hash
    BYTE  pbNewPasswdHash[16];         // new passwd hash for change pass
    BYTE  pbPasswdHashRC2Key[8];       // RC2 secret key generated from hash

    BYTE  pbEncryptedChallenge[16];    // RC2 encrypted server challenge
    int   cbEncryptedChallengeLen;     // length of the encrypted challenge

    PNDS_SECURITY_CONTEXT psNdsSecurityContext;  // user's nds context
    BYTE                  *pbSignData;           // user's signature data

    UNICODE_STRING uUserDN;            // users fully distinguished name
    PWCHAR UserDnBuffer;

    DWORD dwValidityStart, dwValidityEnd;
    BOOLEAN AtHeadOfQueue = FALSE;
    BOOLEAN HoldingCredResource = FALSE;
    BOOLEAN PasswordExpired = FALSE;

    UNICODE_STRING PlainServerName;
    USHORT UidLen;
    KIRQL OldIrql;
    PSCB pLoginServer = NULL;
    PSCB pOriginalServer = NULL;
    DWORD dwLoginFlags = 0;

    DebugTrace( 0, Dbg, "Enter NdsTreeLogin...\n", 0 );

    if ( pIrpContext->pNpScb->Requests.Flink != &pIrpContext->NextRequest ) {
        NwAppendToQueueAndWait(pIrpContext);
    }
    ASSERT( pIrpContext->pNpScb->Requests.Flink == &pIrpContext->NextRequest );
    ASSERT( puUser );
    ASSERT( pOemPassword );

    //
    // Allocate space for the server's public key and the user's private key.
    //

    cbServerPublicNdsKeyLen = MAX_PUBLIC_KEY_LEN + MAX_ENC_PRIV_KEY_LEN + MAX_NDS_NAME_SIZE;

    pbServerPublicNdsKey = ALLOCATE_POOL( PagedPool, cbServerPublicNdsKeyLen );

    if ( !pbServerPublicNdsKey ) {

        DebugTrace( 0, Dbg, "Out of memory in NdsTreeLogin...\n", 0 );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // First, jump to a server where we can get this user object.
    // Don't forget the server to which we were originally pointed.
    //

    pOriginalServer = pIrpContext->pScb;
    NwReferenceScb( pOriginalServer->pNpScb );

    Status = NdsResolveNameKm( pIrpContext,
                               puUser,
                               &dwUserOID,
                               TRUE,
                               DEFAULT_RESOLVE_FLAGS );

    if ( !NT_SUCCESS( Status ) ) {
        if ( Status == STATUS_BAD_NETWORK_PATH ) {
            Status = STATUS_NO_SUCH_USER;
        }
        goto ExitWithCleanup;
    }

    //
    // Now get the user name from the object info.
    //

    UserDnBuffer = (PWCHAR) ( pbServerPublicNdsKey +
                              MAX_PUBLIC_KEY_LEN +
                              MAX_ENC_PRIV_KEY_LEN );

    uUserDN.Length = 0;
    uUserDN.MaximumLength = MAX_NDS_NAME_SIZE;
    uUserDN.Buffer = UserDnBuffer;

    Status = NdsGetUserName( pIrpContext,
                             dwUserOID,
                             &uUserDN );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Get the name of the server we are currently on.  We borrow a
    // little space from our key buffer and overwrite it later.
    //

    puServerName = ( PUNICODE_STRING ) pbServerPublicNdsKey;
    puServerName->Buffer = (PWCHAR) pbServerPublicNdsKey + sizeof( UNICODE_STRING );
    puServerName->MaximumLength = (USHORT) cbServerPublicNdsKeyLen - sizeof( UNICODE_STRING );

    Status = NdsGetServerName( pIrpContext,
                               puServerName );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // If the public key for this server is on a partition that's
    // on another server, we'll have to jump over there to get the
    // public key and then return.  The key and user object are
    // only any good on this server!  DO NOT CHANGE THE ORDER OF
    // THIS OR IT WILL BREAK!
    //

    pLoginServer = pIrpContext->pScb;
    NwReferenceScb( pLoginServer->pNpScb );

    Status = NdsResolveNameKm( pIrpContext,
                               puServerName,
                               &dwServerOID,
                               TRUE,
                               DEFAULT_RESOLVE_FLAGS );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Get the server's public key and its length.
    //

    Status = NdsReadPublicKey( pIrpContext,
                               dwServerOID,
                               pbServerPublicNdsKey,
                               &cbServerPublicNdsKeyLen );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Return us to the login server.
    //

    if ( pLoginServer != pIrpContext->pScb ) {

        NwDequeueIrpContext( pIrpContext, FALSE );
        NwDereferenceScb( pIrpContext->pNpScb );
        pIrpContext->pScb = pLoginServer;
        pIrpContext->pNpScb = pLoginServer->pNpScb;

    } else {

       NwDereferenceScb( pLoginServer->pNpScb );
    }

    pLoginServer = NULL;

    //
    // Locate the BSAFE key in the NDS key.
    //

    cbServerPublicBsafeKeyLen = NdsGetBsafeKey( pbServerPublicNdsKey,
                                                cbServerPublicNdsKeyLen,
                                                &pbServerPublicBsafeKey );

    if ( !cbServerPublicBsafeKeyLen ) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;
    }

    //
    // Send the begin login packet.  This returns to us the
    // 4 byte challenge and the object id of the user's account
    // on the server on which it was created.  It may be the
    // same as the object id that we provided if the account
    // was created on this server.
    //

    Status = BeginLogin( pIrpContext,
                         dwUserOID,
                         &dwSrcUserOID,
                         &dwChallenge );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Compute the 16 byte NW3 hash and generate the
    // 8 byte secret key from it.  The 8 byte secret
    // key consists of a MAC checksum of the NW3 hash.
    //

    Shuffle( (UCHAR *)&dwSrcUserOID,
             pOemPassword->Buffer,
             pOemPassword->Length,
             pbNw3PasswdHash );

    GenKey8( pbNw3PasswdHash,
             sizeof( pbNw3PasswdHash ),
             pbPasswdHashRC2Key );

    //
    // RC2 Encrypt the 4 byte challenge using the secret
    // key generated from the password.
    //

    CryptStatus = CBCEncrypt( pbPasswdHashRC2Key,
                              NULL,
                              (BYTE *)&dwChallenge,
                              4,
                              pbEncryptedChallenge,
                              &cbEncryptedChallengeLen,
                              BSAFE_CHECKSUM_LEN );

    if ( CryptStatus ) {

        DebugTrace( 0, Dbg, "CBC encryption failed.\n", 0 );
        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;
    }

    pbUserPrivateNdsKey = pbServerPublicNdsKey + MAX_PUBLIC_KEY_LEN;
    cbUserPrivateNdsKeyLen = MAX_ENC_PRIV_KEY_LEN;

    //
    // Make the finish login packet.  If successful, this routine
    // returns the encrypted user private key and the valid duration
    // of the user's credentials.
    //

    if ( pOemNewPassword ) {
        dwLoginFlags = 1;
    }

    Status = FinishLogin( pIrpContext,
                          dwUserOID,
                          dwLoginFlags,
                          pbEncryptedChallenge,
                          pbServerPublicBsafeKey,
                          cbServerPublicBsafeKeyLen,
                          pbUserPrivateNdsKey,
                          &cbUserPrivateNdsKeyLen,
                          &dwValidityStart,
                          &dwValidityEnd );

    if ( !NT_SUCCESS( Status ) ) {
       goto ExitWithCleanup;
    }

    if ( !pOemNewPassword ) {

        //
        // If the password is expired, report it to the user.
        //

        if ( Status == NWRDR_PASSWORD_HAS_EXPIRED ) {
            PasswordExpired = TRUE;
        }

        //
        // Allocate the credential and set up space for the private key.
        //

        NwAppendToQueueAndWait( pIrpContext );
        AtHeadOfQueue = TRUE;

        Status = NdsLookupCredentials( pIrpContext,
                                       &pIrpContext->pScb->NdsTreeName,
                                       pUserLogon,
                                       &psNdsSecurityContext,
                                       CREDENTIAL_WRITE,
                                       TRUE );

        if ( !NT_SUCCESS( Status ) ) {
            goto ExitWithCleanup;
        }

        //
        // ALERT! We are holding the credential list.
        //

        HoldingCredResource = TRUE;

        psNdsSecurityContext->Credential = ALLOCATE_POOL( PagedPool,
                                                          sizeof( NDS_CREDENTIAL ) +
                                                          uUserDN.Length );

        if ( !psNdsSecurityContext->Credential ) {

            DebugTrace( 0, Dbg, "Out of memory in NdsTreeLogin (for credential)...\n", 0 );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ExitWithCleanup;

        }

        *( (UNALIGNED DWORD *) &( psNdsSecurityContext->Credential->validityBegin ) ) = dwValidityStart;
        *( (UNALIGNED DWORD *) &( psNdsSecurityContext->Credential->validityEnd ) )   = dwValidityEnd;

        DebugTrace( 0, Dbg, "Credential validity start: 0x%08lx\n", dwValidityStart );
        DebugTrace( 0, Dbg, "Credential validity end: 0x%08lx\n", dwValidityEnd );

        //
        // RC2 Decrypt the response to extract the BSAFE private
        // key data in place.
        //

        CryptStatus = CBCDecrypt( pbPasswdHashRC2Key,
                                  NULL,
                                  pbUserPrivateNdsKey,
                                  cbUserPrivateNdsKeyLen,
                                  pbUserPrivateNdsKey,
                                  &cbUserPrivateNdsKeyLen,
                                  BSAFE_CHECKSUM_LEN );

        if ( CryptStatus ) {

            DebugTrace( 0, Dbg, "CBC decryption failed.\n", 0 );
            Status = STATUS_UNSUCCESSFUL;
            goto ExitWithCleanup;
        }

        //
        // Skip over the header.
        //

        pbUserPrivateBsafeKey = ( pbUserPrivateNdsKey + sizeof( TAG_DATA_HEADER ) );
        cbUserPrivateBsafeKeyLen = *( ( WORD * ) pbUserPrivateBsafeKey );
        pbUserPrivateBsafeKey += sizeof( WORD );

        //
        // Create the credential.
        //

        psNdsSecurityContext->Credential->tdh.version = 1;
        psNdsSecurityContext->Credential->tdh.tag = TAG_CREDENTIAL;

        GenRandomBytes( ( BYTE * ) &(psNdsSecurityContext->Credential->random),
                        sizeof( psNdsSecurityContext->Credential->random ) );

        psNdsSecurityContext->Credential->optDataSize = 0;
        psNdsSecurityContext->Credential->userNameLength = uUserDN.Length;

        RtlCopyMemory( ( (BYTE *)psNdsSecurityContext->Credential) + sizeof( NDS_CREDENTIAL ),
                         UserDnBuffer,
                         uUserDN.Length );

        //
        // Generate and save the signature.
        //

        psNdsSecurityContext->Signature = ALLOCATE_POOL( PagedPool, MAX_SIGNATURE_LEN );

        if ( !psNdsSecurityContext->Signature ) {

            DebugTrace( 0, Dbg, "Out of memory in NdsTreeLogin (for signature)...\n", 0 );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ExitWithCleanup;

        }

        pbSignData = ( ( ( BYTE * ) psNdsSecurityContext->Signature ) +
                                    sizeof( NDS_SIGNATURE ) );

        RtlZeroMemory( pbSignData, MAX_RSA_BYTES );

        psNdsSecurityContext->Signature->tdh.version = 1;
        psNdsSecurityContext->Signature->tdh.tag = TAG_SIGNATURE;

        //
        // Create the hash for the signature from the credential.
        //

        MD2( (BYTE *) psNdsSecurityContext->Credential,
             sizeof( NDS_CREDENTIAL ) + ( uUserDN.Length ),
             pbSignData );

        //
        // Compute the 'signature' by RSA-encrypting the
        // 16-byte signature hash with the private key.
        //

        psNdsSecurityContext->Signature->signDataLength = (WORD) RSAPrivate( pbUserPrivateBsafeKey,
                                                                    cbUserPrivateBsafeKeyLen,
                                                                    pbSignData,
                                                                    16,
                                                                    pbSignData );

        if ( !psNdsSecurityContext->Signature->signDataLength ) {

            DebugTrace( 0, Dbg, "RSA private encryption for signature failed.\n", 0 );
            Status = STATUS_UNSUCCESSFUL;
            goto ExitWithCleanup;
        }

        //
        // Round up the signature length, cause that's how VLM stores it.
        //

        psNdsSecurityContext->Signature->signDataLength =
            ROUNDUP4( psNdsSecurityContext->Signature->signDataLength );

        DebugTrace( 0, Dbg, "Signature data length: %d\n",
            psNdsSecurityContext->Signature->signDataLength );

        //
        // Get the user's public key for storage in the nds context.
        //

        psNdsSecurityContext->PublicNdsKey = ALLOCATE_POOL( PagedPool, MAX_PUBLIC_KEY_LEN );

        if ( !psNdsSecurityContext->PublicNdsKey ) {

            DebugTrace( 0, Dbg, "Out of memory in NdsTreeLogin (for public key)...\n", 0 );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ExitWithCleanup;

        }

        psNdsSecurityContext->PublicKeyLen = MAX_PUBLIC_KEY_LEN;

        ASSERT( AtHeadOfQueue );
        ASSERT( HoldingCredResource );

        Status = NdsReadPublicKey( pIrpContext,
                                   dwUserOID,
                                   psNdsSecurityContext->PublicNdsKey,
                                   &(psNdsSecurityContext->PublicKeyLen) );

        if ( !NT_SUCCESS( Status ) ) {
            goto ExitWithCleanup;
        }

        //
        // Store away the password we used to connect.
        //

        if (pOemPassword->Length != 0) {
            
            psNdsSecurityContext->Password.Buffer = ALLOCATE_POOL( NonPagedPool, pOemPassword->Length );

            if ( !psNdsSecurityContext->Password.Buffer ) {
    
                DebugTrace( 0, Dbg, "Out of memory in NdsTreeLogin (for password)\n", 0 );
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ExitWithCleanup;
            }
            
            RtlCopyMemory( psNdsSecurityContext->Password.Buffer,
                           pOemPassword->Buffer,
                           pOemPassword->Length );
        }

        psNdsSecurityContext->Password.Length = pOemPassword->Length;
        psNdsSecurityContext->Password.MaximumLength = pOemPassword->Length;

        //
        // We are logged in to the NDS tree.  Should we zero the private
        // key, or is NT's protection sufficient?
        //

        NwReleaseCredList( pUserLogon, pIrpContext );

        //
        // Try to elect this server as the preferred server if necessary.
        //

        NwAcquireExclusiveRcb( &NwRcb, TRUE );

        if ( ( pUserLogon->ServerName.Length == 0 ) &&
             ( !pIrpContext->Specific.Create.fExCredentialCreate ) ) {

            //
            // Strip off the unicode uid from the server name.
            //

            PlainServerName.Length = pIrpContext->pScb->UidServerName.Length;
            PlainServerName.Buffer = pIrpContext->pScb->UidServerName.Buffer;

            UidLen = 0;

            while ( UidLen < ( PlainServerName.Length / sizeof( WCHAR ) ) ) {

                if ( PlainServerName.Buffer[UidLen++] == L'\\' ) {
                    break;
                }
            }

            PlainServerName.Buffer += UidLen;
            PlainServerName.Length -= ( UidLen * sizeof( WCHAR ) );
            PlainServerName.MaximumLength = PlainServerName.Length;

            if ( PlainServerName.Length ) {

                Status = SetUnicodeString( &(pUserLogon->ServerName),
                                           PlainServerName.Length,
                                           PlainServerName.Buffer );

                if ( NT_SUCCESS( Status ) ) {

                    PLIST_ENTRY pTemp;
                    
                    DebugTrace( 0, Dbg, "Electing preferred server: %wZ\n", &PlainServerName );

                    //
                    // Increase the Scb ref count, set the preferred server
                    // flag, and move the scb to the head of the SCB list.
                    //
                    // If this is already an elected preferred
                    // server, don't mess up the ref count!
                    //

                    if ( !(pIrpContext->pScb->PreferredServer) ) {

                        NwReferenceScb( pIrpContext->pScb->pNpScb );
                        pIrpContext->pScb->PreferredServer = TRUE;
                    }

                    pTemp = &(pIrpContext->pScb->pNpScb->ScbLinks);

                    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

                    RemoveEntryList( pTemp );
                    InsertHeadList( &ScbQueue, pTemp );

                    KeReleaseSpinLock(&ScbSpinLock, OldIrql);

                }
            }
        }

    } else {

        //
        // This isn't a login, but a change password request.
        //
        // First we have to RC2 Decrypt the response to extract
        // the BSAFE private key data in place (just like for a
        // login).
        //

        CryptStatus = CBCDecrypt( pbPasswdHashRC2Key,
                                  NULL,
                                  pbUserPrivateNdsKey,
                                  cbUserPrivateNdsKeyLen,
                                  pbUserPrivateNdsKey,
                                  &cbUserPrivateNdsKeyLen,
                                  BSAFE_CHECKSUM_LEN );

        if ( CryptStatus ) {

            DebugTrace( 0, Dbg, "CBC decryption failed.\n", 0 );
            Status = STATUS_UNSUCCESSFUL;
            goto ExitWithCleanup;
        }

        //
        // Now, compute the hash of the new password.
        //

        Shuffle( (UCHAR *)&dwSrcUserOID,
                 pOemNewPassword->Buffer,
                 pOemNewPassword->Length,
                 pbNewPasswdHash );

        //
        // And finally, make the request.
        //

        Status = ChangeNdsPassword( pIrpContext,
                                    dwUserOID,
                                    dwChallenge,
                                    pbNw3PasswdHash,
                                    pbNewPasswdHash,
                                    ( PNDS_PRIVATE_KEY ) pbUserPrivateNdsKey,
                                    pbServerPublicBsafeKey,
                                    cbServerPublicBsafeKeyLen,
                                    pOemNewPassword->Length );

        if ( !NT_SUCCESS( Status ) ) {
            DebugTrace( 0, Dbg, "Change NDS password failed!\n", 0 );
            goto ExitWithCleanup;
        }

    }

    //
    // Return us to our original server if we've jumped around.
    //

    NwDequeueIrpContext( pIrpContext, FALSE );

    if ( pIrpContext->pScb != pOriginalServer ) {

        NwDereferenceScb( pIrpContext->pNpScb );
        pIrpContext->pScb = pOriginalServer;
        pIrpContext->pNpScb = pOriginalServer->pNpScb;

    } else {

        NwDereferenceScb( pOriginalServer->pNpScb );
    }

    pOriginalServer = NULL;

    if ( !pOemNewPassword ) {
        NwReleaseRcb( &NwRcb );
    }

    FREE_POOL( pbServerPublicNdsKey );

    if ( PasswordExpired ) {
        Status = NWRDR_PASSWORD_HAS_EXPIRED;
    } else {
        Status = STATUS_SUCCESS;
    }

    return Status;

ExitWithCleanup:

    DebugTrace( 0, Dbg, "NdsTreeLogin seems to have failed... cleaning up.\n", 0 );

    FREE_POOL( pbServerPublicNdsKey );

    if ( pLoginServer ) {
        NwDereferenceScb( pLoginServer->pNpScb );
    }

    //
    // If we failed after jumping servers, we have to restore
    // the irp context to the original server.
    //
    
    NwDequeueIrpContext( pIrpContext, FALSE );

    if ( pOriginalServer ) {

        if ( pIrpContext->pScb != pOriginalServer ) {

            NwDereferenceScb( pIrpContext->pNpScb );
            pIrpContext->pScb = pOriginalServer;
            pIrpContext->pNpScb = pOriginalServer->pNpScb;

        } else {

            NwDereferenceScb( pOriginalServer->pNpScb );
        }

    }

    if ( HoldingCredResource ) {

        if ( psNdsSecurityContext->Credential ) {
            FREE_POOL( psNdsSecurityContext->Credential );
            psNdsSecurityContext->Credential = NULL;
        }

        if ( psNdsSecurityContext->Signature ) {
            FREE_POOL( psNdsSecurityContext->Signature );
            psNdsSecurityContext->Signature = NULL;
        }

        if ( psNdsSecurityContext->PublicNdsKey ) {
            FREE_POOL( psNdsSecurityContext->PublicNdsKey );
            psNdsSecurityContext->PublicNdsKey = NULL;
            psNdsSecurityContext->PublicKeyLen = 0;
        }

        NwReleaseCredList( pUserLogon, pIrpContext );
    }

    return Status;

}

NTSTATUS
BeginLogin(
   IN PIRP_CONTEXT pIrpContext,
   IN DWORD        userId,
   OUT DWORD       *loginId,
   OUT DWORD       *challenge
)
/*++

Routine Desription:

    Begin the NDS login process. The loginId returned is objectId of the user
    on the server which created the account (may not be the current server).

Arguments:

    pIrpContext - The IRP context for this connection.
    userId      - The user's NDS object Id.
    loginId     - The objectId used to encrypt password.
    challenge   - The 4 byte random challenge.

Return value:

    NTSTATUS - The result of the operation.

--*/
{

    NTSTATUS Status;
    LOCKED_BUFFER NdsRequest;

    PAGED_CODE();

    DebugTrace( 0, Dbg, "Enter BeginLogin...\n", 0 );

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Announce myself.
    //

    Status = FragExWithWait( pIrpContext,
                             NDSV_BEGIN_LOGIN,
                             &NdsRequest,
                             "DD",
                             0,
                             userId );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = NdsCompletionCodetoNtStatus( &NdsRequest );

    if ( !NT_SUCCESS( Status ) ) {

        if ( Status == STATUS_BAD_NETWORK_PATH ) {
            Status = STATUS_NO_SUCH_USER;
        }

        goto ExitWithCleanup;
    }

    //
    // Get the object id and the challenge string.
    //

    Status = ParseResponse( NULL,
                            NdsRequest.pRecvBufferVa,
                            NdsRequest.dwBytesWritten,
                            "G_DD",
                            sizeof( DWORD ),
                            loginId,
                            challenge );

    if ( NT_SUCCESS( Status ) ) {
        DebugTrace( 0, Dbg, "Login 4 byte challenge: 0x%08lx\n", *challenge );
    } else {
       DebugTrace( 0, Dbg, "Begin login failed...\n", 0 );
    }

ExitWithCleanup:

    NdsFreeLockedBuffer( &NdsRequest );
    return Status;

}

NTSTATUS
FinishLogin(
    IN PIRP_CONTEXT pIrpContext,
    IN DWORD        dwUserOID,
    IN DWORD        dwLoginFlags,
    IN BYTE         pbEncryptedChallenge[16],
    IN BYTE         *pbServerPublicBsafeKey,
    IN int          cbServerPublicBsafeKeyLen,
    OUT BYTE        *pbUserEncPrivateNdsKey,
    OUT int         *pcbUserEncPrivateNdsKeyLen,
    OUT DWORD       *pdwCredentialStartTime,
    OUT DWORD       *pdwCredentialEndTime
)
/*++

Routine Description:

    Constructs and sends the Finish Login request to the server.

Arguments:

    pIrpContext                - (IN)  IRP context for this request
    dwUserOID                  - (IN)  user's NDS object Id
    pbEncryptedChallenge       - (IN)  RC2 encrypted challenge
    pbServerPublicBsafeKey     - (IN)  server public bsafe key
    cbServerPublicBsafeKeyLen  - (IN)  length of server public key

    pbUserEncPrivateNdsKey     - (OUT) user's encrypted private nds key
    pcbUserEncPrivateNdsKeyLen - (OUT) length of pbUserEncPrivateNdsKey
    pdwCredentialStartTime     - (OUT) validity start time for credentials
    pdwCredentialEndTime       - (OUT) validity end time for credentials

--*/
{
    NTSTATUS Status;

    const USHORT cbEncryptedChallengeLen = 16;

    int LOG_DATA_POOL_SIZE,                     // pool sizes for our allocation call
        PACKET_POOL_SIZE,
        RESP_POOL_SIZE;

    BYTE *pbRandomBytes;                        // random bytes used in crypto routines
    BYTE RandRC2SecretKey[RC2_KEY_LEN];         // random RC2 key generated from above
    BYTE pbEncryptedChallengeKey[RC2_KEY_LEN];  // RC2 key that will decode the response

    NDS_RAND_BYTE_BLOCK *psRandByteBlock;

    ENC_BLOCK_HDR  *pbEncRandSeedHead;          // header for encrypted random RC2 key seed
    BYTE           *pbEncRandSeed;              // encrypted random seed
    int            cbPackedRandSeedLen;         // length of the packed rand seed bytes

    ENC_BLOCK_HDR  *pbEncChallengeHead;         // header for encrypted challenge

    ENC_BLOCK_HDR  *pbEncLogDataHead;           // header for encrypted login data
    BYTE           *pbEncLogData;               // encrypted login data
    int            cbEncLogDataLen;             // length of the encrypted login data

    ENC_BLOCK_HDR  *pbEncServerRespHead;        // header for encrypted response
    BYTE           *pbEncServerResp;            // encrypted response

    int CryptStatus,                            // crypt call status
        CryptLen,                               // length of encrypted data
        RequestPacketLen,                       // length of the request packet data
        cbServerRespLen;                        // server response length after decryption

    BYTE *pbServerResponse;                     // response from the server
    DWORD cbEncServerRespLen;                   // server response length before decryption

    DWORD EncKeyLen;                            // length of the encrypted private key
    ENC_BLOCK_HDR *pbPrivKeyHead;               // encryption header of the private key

    LOCKED_BUFFER NdsRequest;                   // fragex locked buffer
    BOOL PasswordExpired = FALSE;

    PAGED_CODE();

    DebugTrace( 0, Dbg, "Enter FinishLogin...\n", 0 );

    //
    // Allocate working space.  The login data pool starts at
    // pbRandomBytes.  The packet data starts at pbEncRandSeedHead.
    // The server response pool starts at pbServerResponse.
    //

    //
    // The alignment of these structures may possibly be wrong on
    // quad aligned machines; check out a hardware independent fix.
    //

    LOG_DATA_POOL_SIZE = RAND_KEY_DATA_LEN +               // 28 bytes for random seed
                         sizeof ( NDS_RAND_BYTE_BLOCK ) +  // login data random header
                         sizeof ( ENC_BLOCK_HDR ) +        // header for encrypted challenge
                         cbEncryptedChallengeLen +         // data for encrypted challenge
                         8;                                // padding
    LOG_DATA_POOL_SIZE = ROUNDUP4( LOG_DATA_POOL_SIZE );

    PACKET_POOL_SIZE =   2048;                             // packet buffer size
    RESP_POOL_SIZE =     2048;                             // packet buffer size

    pbRandomBytes = ALLOCATE_POOL( PagedPool,
                                   LOG_DATA_POOL_SIZE +
                                   PACKET_POOL_SIZE +
                                   RESP_POOL_SIZE );

    if ( !pbRandomBytes ) {

        DebugTrace( 0, Dbg, "Out of memory in FinishLogin (main block)...\n", 0 );
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    pbEncRandSeedHead = ( PENC_BLOCK_HDR ) ( pbRandomBytes + LOG_DATA_POOL_SIZE );
    pbServerResponse = ( pbRandomBytes + LOG_DATA_POOL_SIZE + PACKET_POOL_SIZE );

    //
    // Start working on the login data.  As is common in the crypto world, we
    // generate a random seed and then make a key from it to be used with a
    // bulk cipher algorithm.  In Netware land, we use MAC to make an 8 byte
    // key from the random seed and use 64bit RC2 as our bulk cipher.  We then
    // RSA encrypt the seed using the server's public RSA key and use the bulk
    // cipher to encrypt the rest of our login data.
    //
    // Since Novell uses 64bit RC2, the security isn't great.
    //

    GenRandomBytes( pbRandomBytes, RAND_KEY_DATA_LEN );
    GenKey8( pbRandomBytes, RAND_KEY_DATA_LEN, RandRC2SecretKey );

    //
    // Now work on the actual packet data.  Create the header for the
    // encrypted random seed and pack the seed into it.
    //

    pbEncRandSeed = ( ( BYTE * )pbEncRandSeedHead ) + sizeof( ENC_BLOCK_HDR );

    pbEncRandSeedHead->cipherLength = (WORD) RSAGetInputBlockSize( pbServerPublicBsafeKey,
                                                            cbServerPublicBsafeKeyLen );

    cbPackedRandSeedLen = RSAPack( pbRandomBytes,
                                   RAND_KEY_DATA_LEN,
                                   pbEncRandSeed,
                                   pbEncRandSeedHead->cipherLength );
    //
    // We should have packed exactly one block.
    //

    if( cbPackedRandSeedLen != pbEncRandSeedHead->cipherLength ) {
        DebugTrace( 0, Dbg, "RSAPack didn't pack exactly one block!\n", 0 );
    }

    pbEncRandSeedHead->cipherLength = (WORD) RSAPublic( pbServerPublicBsafeKey,
                                                        cbServerPublicBsafeKeyLen,
                                                        pbEncRandSeed,
                                                        pbEncRandSeedHead->cipherLength,
                                                        pbEncRandSeed );

    if ( !pbEncRandSeedHead->cipherLength ) {

        DebugTrace( 0, Dbg, "Failing in FinishLogin... encryption failed.\n", 0 );
        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;

    }

    //
    // Fill in the rest of the header for the random seed.  We don't count
    // the first DWORD in the EBH; it isn't part of the header as netware
    // wants it, per se.
    //

    pbEncRandSeedHead->blockLength = pbEncRandSeedHead->cipherLength +
                                     sizeof( ENC_BLOCK_HDR ) -
                                     sizeof( DWORD );
    pbEncRandSeedHead->version     = 1;
    pbEncRandSeedHead->encType     = ENC_TYPE_RSA_PUBLIC;
    pbEncRandSeedHead->dataLength  = RAND_KEY_DATA_LEN;

    //
    // Go back to working on the login data.  Fill out the rbb.
    //

    psRandByteBlock = ( PNDS_RAND_BYTE_BLOCK ) ( pbRandomBytes + RAND_KEY_DATA_LEN );

    GenRandomBytes( (BYTE *) &psRandByteBlock->rand1, 4 );
    psRandByteBlock->rand2Len = RAND_FL_DATA_LEN;
    GenRandomBytes( (BYTE *) &psRandByteBlock->rand2[0], RAND_FL_DATA_LEN );

    //
    // Fill out the header for the encrypted challenge right after the rbb.
    //

    pbEncChallengeHead = (ENC_BLOCK_HDR *) ( ((BYTE *)psRandByteBlock) +
                                             sizeof( NDS_RAND_BYTE_BLOCK ) );

    pbEncChallengeHead->version      = 1;
    pbEncChallengeHead->encType      = ENC_TYPE_RC2_CBC;
    pbEncChallengeHead->dataLength   = 4;
    pbEncChallengeHead->cipherLength = cbEncryptedChallengeLen;
    pbEncChallengeHead->blockLength  = cbEncryptedChallengeLen +
                                       sizeof( ENC_BLOCK_HDR ) -
                                       sizeof( DWORD );

    //
    // Place the encrypted challenge immediately after its header.
    //

    RtlCopyMemory( (BYTE *)( ((BYTE *)pbEncChallengeHead) +
                             sizeof( ENC_BLOCK_HDR )),
                   pbEncryptedChallenge,
                   cbEncryptedChallengeLen );

    //
    // Prepare the RC2 key to decrypt FinishLogin response.
    //

    GenKey8( (BYTE *)( &pbEncChallengeHead->version ),
             pbEncChallengeHead->blockLength,
             pbEncryptedChallengeKey );

    //
    // Finish up the packet data by preparing the login data.  Start
    // with the encryption header.
    //

    pbEncLogDataHead = ( PENC_BLOCK_HDR ) ( pbEncRandSeed +
                           ROUNDUP4( pbEncRandSeedHead->cipherLength ) );

    pbEncLogData = ( ( BYTE * )pbEncLogDataHead ) + sizeof( ENC_BLOCK_HDR );

    pbEncLogDataHead->version = 1;
    pbEncLogDataHead->encType = ENC_TYPE_RC2_CBC;
    pbEncLogDataHead->dataLength = sizeof( NDS_RAND_BYTE_BLOCK ) +
                                   sizeof( ENC_BLOCK_HDR ) +
                                   cbEncryptedChallengeLen;

    //
    // Sanity check the packet pool for overflow.
    //

    if ( ( pbEncLogData + pbEncLogDataHead->dataLength + ( 2 * CIPHERBLOCKSIZE ) ) -
         (BYTE *) pbEncRandSeedHead > PACKET_POOL_SIZE ) {

        DebugTrace( 0, Dbg, "Packet pool overflow... I'd better fix this.\n", 0 );
        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;
    }

    //
    // Encrypt the login data.
    //

    CryptStatus = CBCEncrypt( RandRC2SecretKey,
                              NULL,
                              (BYTE *)psRandByteBlock,
                              pbEncLogDataHead->dataLength,
                              pbEncLogData,
                              &CryptLen,
                              BSAFE_CHECKSUM_LEN );

    if ( CryptStatus ) {

        DebugTrace( 0, Dbg, "Encryption failure in FinishLogin...\n", 0 );
        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;
    }

    pbEncLogDataHead->cipherLength = (WORD)CryptLen;
    pbEncLogDataHead->blockLength = pbEncLogDataHead->cipherLength +
                                    sizeof( ENC_BLOCK_HDR ) -
                                    sizeof( DWORD );

    //
    // We can finally send out the finish login request!  Calculate the
    // send amount and make the request.
    //

    RequestPacketLen = (int) (( (BYTE *) pbEncLogData + pbEncLogDataHead->cipherLength ) -
                         (BYTE *) pbEncRandSeedHead);

    NdsRequest.pRecvBufferVa = pbServerResponse;
    NdsRequest.dwRecvLen = RESP_POOL_SIZE;
    NdsRequest.pRecvMdl = NULL;

    NdsRequest.pRecvMdl = ALLOCATE_MDL( pbServerResponse,
                                        RESP_POOL_SIZE,
                                        FALSE,
                                        FALSE,
                                        NULL );
    if ( !NdsRequest.pRecvMdl ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithCleanup;
    }

    MmProbeAndLockPages( NdsRequest.pRecvMdl,
                         KernelMode,
                         IoWriteAccess );

    Status = FragExWithWait( pIrpContext,
                             NDSV_FINISH_LOGIN,
                             &NdsRequest,
                             "DDDDDDDr",
                             2,                    // Version
                             dwLoginFlags,         // Flags
                             dwUserOID,            // Entry ID
                             0x494,                //
                             1,                    // Security Version
                             0x20009,              // Envelope ID 1
                             0x488,                // Envelope length
                             pbEncRandSeedHead,    // Cipher block
                             RequestPacketLen );   // Cipher block length

    MmUnlockPages( NdsRequest.pRecvMdl );
    FREE_MDL( NdsRequest.pRecvMdl );

    if ( !NT_SUCCESS( Status ) ) {
       goto ExitWithCleanup;
    }

    Status = NdsCompletionCodetoNtStatus( &NdsRequest );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    if ( Status == NWRDR_PASSWORD_HAS_EXPIRED ) {
        PasswordExpired = TRUE;
    }

    cbServerRespLen = NdsRequest.dwBytesWritten;

    //
    // Save the credential validity times.
    //

    Status = ParseResponse( NULL,
                            pbServerResponse,
                            cbServerRespLen,
                            "G_DD",
                            sizeof( DWORD ),
                            pdwCredentialStartTime,
                            pdwCredentialEndTime );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Grab the encryption block header for the response.  This response in
    // RC2 encrypted with the pbEncryptedChallengeKey.
    //

    pbEncServerRespHead = (ENC_BLOCK_HDR *) ( pbServerResponse +
                                              ( 3 * sizeof( DWORD ) ) );

    if ( pbEncServerRespHead->encType != ENC_TYPE_RC2_CBC ||
         pbEncServerRespHead->cipherLength >
         ( RESP_POOL_SIZE + sizeof( ENC_BLOCK_HDR ) + 12 ) ) {

        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;
    }

    //
    // Decrypt the server response in place.
    //

    pbEncServerResp = ( BYTE * ) ( ( BYTE * ) pbEncServerRespHead +
                                     sizeof( ENC_BLOCK_HDR ) );

    CryptStatus = CBCDecrypt( pbEncryptedChallengeKey,
                              NULL,
                              pbEncServerResp,
                              pbEncServerRespHead->cipherLength,
                              pbEncServerResp,
                              &cbServerRespLen,
                              BSAFE_CHECKSUM_LEN );

    if ( CryptStatus ||
         cbServerRespLen != pbEncServerRespHead->dataLength ) {

        DebugTrace( 0, Dbg, "Encryption failure (2) in FinishLogin...\n", 0 );
        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;
    }

    //
    // Examine the first random number to make sure the server is authentic.
    //

    if ( psRandByteBlock->rand1 != * ( DWORD * ) pbEncServerResp ) {

       DebugTrace( 0, Dbg, "Server failed to respond to our challenge correctly...\n", 0 );
       Status = STATUS_UNSUCCESSFUL;
       goto ExitWithCleanup;

    }

    //
    // We know things are legit, so we can extract the private key.
    // Careful, though: don't XOR the size dword.
    //

    pbEncServerResp += sizeof( DWORD );
    EncKeyLen = * ( DWORD * ) ( pbEncServerResp );

    pbEncServerResp += sizeof( DWORD );
    while ( EncKeyLen-- ) {

       pbEncServerResp[EncKeyLen] ^= psRandByteBlock->rand2[EncKeyLen];
    }

    //
    // Check the encryption header on the private key.  Don't forget to
    // backup to include the size dword.
    //

    pbPrivKeyHead = ( ENC_BLOCK_HDR * )( pbEncServerResp - sizeof( DWORD ) ) ;

    if ( pbPrivKeyHead->encType != ENC_TYPE_RC2_CBC ) {

        DebugTrace( 0, Dbg, "Bad encryption header on the private key...\n", 0 );
        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;

    }

    //
    // Finally, copy out the user's private NDS key.
    //

    if ( *pcbUserEncPrivateNdsKeyLen >= pbPrivKeyHead->cipherLength ) {

        DebugTrace( 0, Dbg, "Encrypted private key len: %d\n",
                    pbPrivKeyHead->cipherLength );

        RtlCopyMemory( pbUserEncPrivateNdsKey,
                       ((BYTE *)( pbPrivKeyHead )) + sizeof( ENC_BLOCK_HDR ),
                       pbPrivKeyHead->cipherLength );

        *pcbUserEncPrivateNdsKeyLen = pbPrivKeyHead->cipherLength;

        Status = STATUS_SUCCESS;

    } else {

       DebugTrace( 0, Dbg, "Encryption failure on private key in FinishLogin...\n", 0 );
       Status = STATUS_UNSUCCESSFUL;

    }

ExitWithCleanup:

    FREE_POOL( pbRandomBytes );

    if ( ( NT_SUCCESS( Status ) ) &&
         ( PasswordExpired ) ) {
        Status = NWRDR_PASSWORD_HAS_EXPIRED;
    }

    return Status;

}

NTSTATUS
ChangeNdsPassword(
    PIRP_CONTEXT     pIrpContext,
    DWORD            dwUserOID,
    DWORD            dwChallenge,
    PBYTE            pbOldPwHash,
    PBYTE            pbNewPwHash,
    PNDS_PRIVATE_KEY pUserPrivKey,
    PBYTE            pServerPublicBsafeKey,
    UINT             ServerPubKeyLen,
    USHORT       NewPassLen 
)
/*+++

Description:

    Send a change password packet.  Change the users password
    on the NDS tree that this irp context points to.

Arguments:

    pIrpContext           - The irp context for this request.  Points to the target server.
    dwUserOID             - The oid for the current user.
    dwChallenge           - The encrypted challenge from begin login.
    pbOldPwHash           - The 16 byte hash of the old password.
    pbNewPwHash           - The 16 byte hash of the new password.
    pUserPrivKey          - The user's private RSA key with NDS header.
    pServerPublicBsafeKey - The server's public RSA key in BSAFE format.
    ServerPubKeyLen       - The length of the server's public BSAFE key.
    NewPassLen        - The length of the unencrypted new password.    

--*/
{
    NTSTATUS Status;
    BYTE pbNewPwKey[8];
    BYTE pbSecretKey[8];
    PENC_BLOCK_HDR pbEncSecretKey, pbEncChangePassReq;
    BYTE RandomBytes[RAND_KEY_DATA_LEN];
    PBYTE pbEncData;
    PNDS_CHPW_MSG pChangePassMsg;
    INT CryptStatus, CryptLen;
    DWORD dwTotalEncDataLen;
    LOCKED_BUFFER NdsRequest;

    PAGED_CODE();

    //
    // Create a secret key from the new password.
    //

    GenKey8( pbNewPwHash, 16, pbNewPwKey );

    pbEncSecretKey = ALLOCATE_POOL( PagedPool,
                                    ( ( 2 * sizeof( ENC_BLOCK_HDR ) ) +
                                      ( MAX_RSA_BYTES ) +
                                      ( sizeof( NDS_CHPW_MSG ) ) +
                                      ( sizeof( NDS_PRIVATE_KEY ) ) +
                                      ( pUserPrivKey->keyDataLength ) +
                                      16 ) );

    if ( !pbEncSecretKey ) {
        DebugTrace( 0, Dbg, "ChangeNdsPassword: Out of memory.\n", 0 );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        FREE_POOL( pbEncSecretKey );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Generate a random key.
    //

    GenRandomBytes( RandomBytes, RAND_KEY_DATA_LEN );
    GenKey8( RandomBytes, RAND_KEY_DATA_LEN, pbSecretKey );

    //
    // Encrypt the secret key data in the space after the EBH.
    //

    pbEncSecretKey->dataLength = RAND_KEY_DATA_LEN;
    pbEncSecretKey->cipherLength = (WORD) RSAGetInputBlockSize( pServerPublicBsafeKey, ServerPubKeyLen);

    pbEncData = ( PBYTE ) ( pbEncSecretKey + 1 );

    pbEncSecretKey->cipherLength = (WORD) RSAPack( RandomBytes,
                                            pbEncSecretKey->dataLength,
                                            pbEncData,
                                            pbEncSecretKey->cipherLength );

    pbEncSecretKey->cipherLength = (WORD) RSAPublic( pServerPublicBsafeKey,
                                              ServerPubKeyLen,
                                              pbEncData,
                                              pbEncSecretKey->cipherLength,
                                              pbEncData );

    if ( !pbEncSecretKey->cipherLength ) {
        DebugTrace( 0, Dbg, "ChangeNdsPassword: RSA encryption failed.\n", 0 );
        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;
    }

    //
    // Finish filling out the EBH for the secret key block.
    //

    pbEncSecretKey->version =  1;
    pbEncSecretKey->encType = ENC_TYPE_RSA_PUBLIC;
    pbEncSecretKey->blockLength = pbEncSecretKey->cipherLength +
                                    sizeof( ENC_BLOCK_HDR ) -
                                    sizeof( DWORD );

    //
    // Now form the change password request.
    //

    pbEncChangePassReq = ( PENC_BLOCK_HDR )
        ( pbEncData + ROUNDUP4( pbEncSecretKey->cipherLength ) );

    pChangePassMsg = ( PNDS_CHPW_MSG ) ( pbEncChangePassReq + 1 );

    //
    // Init the Change Password message.
    //

    pChangePassMsg->challenge = dwChallenge;
    pChangePassMsg->oldPwLength = pChangePassMsg->newPwLength = 16;

    RtlCopyMemory( pChangePassMsg->oldPwHash, pbOldPwHash, pChangePassMsg->oldPwLength );
    RtlCopyMemory( pChangePassMsg->newPwHash, pbNewPwHash, pChangePassMsg->newPwLength );

    pChangePassMsg->unknown = NewPassLen;

    pChangePassMsg->encPrivKeyHdr.version = 1;
    pChangePassMsg->encPrivKeyHdr.encType = ENC_TYPE_RC2_CBC;
    pChangePassMsg->encPrivKeyHdr.dataLength = pUserPrivKey->keyDataLength + sizeof( NDS_PRIVATE_KEY );

    //
    // Encrypt the private key with the key derived from the new password.
    //

    CryptStatus = CBCEncrypt( pbNewPwKey,
                              NULL,
                              ( PBYTE ) pUserPrivKey,
                              pChangePassMsg->encPrivKeyHdr.dataLength,
                              ( PBYTE ) ( pChangePassMsg + 1 ),
                              &CryptLen,
                              BSAFE_CHECKSUM_LEN );

    if ( CryptStatus ) {
        DebugTrace( 0, Dbg, "ChangeNdsPassword: CBC encrypt failed.\n", 0 );
        Status = STATUS_UNSUCCESSFUL;
        goto ExitWithCleanup;
    }

    //
    // Finish filling out the encryption header.
    //

    pChangePassMsg->encPrivKeyHdr.cipherLength = (WORD) CryptLen;
    pChangePassMsg->encPrivKeyHdr.blockLength =  CryptLen +
                                                 sizeof( ENC_BLOCK_HDR ) -
                                                 sizeof( DWORD );
    pbEncChangePassReq->version =  1;
    pbEncChangePassReq->encType = ENC_TYPE_RC2_CBC;
    pbEncChangePassReq->dataLength = sizeof( NDS_CHPW_MSG ) + (USHORT) CryptLen;

    //
    // Encrypt the whole Change Password message in-place with the secret key.
    //

    CryptStatus = CBCEncrypt( pbSecretKey,
                              NULL,
                              ( PBYTE ) pChangePassMsg,
                              pbEncChangePassReq->dataLength,
                              ( PBYTE ) pChangePassMsg,
                              &CryptLen,
                              BSAFE_CHECKSUM_LEN);

    if ( CryptStatus ) {
       DebugTrace( 0, Dbg, "ChangeNdsPassword: Second CBC encrypt failed.\n", 0 );
       Status = STATUS_UNSUCCESSFUL;
       goto ExitWithCleanup;
    }

    pbEncChangePassReq->cipherLength = (WORD) CryptLen;
    pbEncChangePassReq->blockLength =
        CryptLen + sizeof( ENC_BLOCK_HDR ) - sizeof( DWORD );

    //
    // Calculate the size of the request.
    //

    dwTotalEncDataLen = sizeof( ENC_BLOCK_HDR ) +                    // Secret key header.
                        ROUNDUP4( pbEncSecretKey->cipherLength ) +   // Secret key data.
                        sizeof( ENC_BLOCK_HDR ) +                    // Change pass msg header.
                        CryptLen;                                    // Change pass data.

    //
    // Send this change password message to the server.
    //

    Status = FragExWithWait( pIrpContext,
                             NDSV_CHANGE_PASSWORD,
                             &NdsRequest,
                             "DDDDDDr",
                             0,
                             dwUserOID,
                             dwTotalEncDataLen + ( 3 * sizeof( DWORD ) ),
                             1,
                             0x20009,
                             dwTotalEncDataLen,
                             pbEncSecretKey,
                             dwTotalEncDataLen );

    if ( NT_SUCCESS( Status ) ) {
        Status = NdsCompletionCodetoNtStatus( &NdsRequest );
    }

ExitWithCleanup:

    FREE_POOL( pbEncSecretKey );
    NdsFreeLockedBuffer( &NdsRequest );
    return Status;

}

NTSTATUS
NdsServerAuthenticate(
    IN PIRP_CONTEXT pIrpContext,
    IN PNDS_SECURITY_CONTEXT pNdsContext
)
/*++

Routine Description:

    Authenticate an NDS connection.
    The user must have already logged into the NDS tree.

    If you change this function - know that you cannot
    at any point try to acquire the nds credential
    resource exclusive from here since that could cause
    a dead lock!!!

    You also must not dequeue the irp context!

Arguments:

    pIrpContext - IrpContext for the server that we want to authenticate to.

Return value:

    NTSTATUS

--*/
{
    NTSTATUS Status;

    BYTE *pbUserPublicBsafeKey = NULL;
    int  cbUserPublicBsafeKeyLen = 0;

    NDS_AUTH_MSG *psAuthMsg;
    NDS_CREDENTIAL *psLocalCredential;
    DWORD dwLocalCredentialLen;
    UNICODE_STRING uUserName;
    DWORD UserOID;

    BYTE *x, *y, *r;
    BYTE CredentialHash[16];
    int i, rsaBlockSize = 0, rsaModSize, totalXLen;
    DWORD dwServerRand;

    BYTE *pbResponse;
    DWORD cbResponseLen;
    LOCKED_BUFFER NdsRequest;

    PAGED_CODE();

    DebugTrace( 0, Dbg, "Entering NdsServerAuthenticate...\n", 0 );

    ASSERT( pIrpContext->pNpScb->Requests.Flink == &pIrpContext->NextRequest );
    //
    // Allocate space for the auth msg, credential, G-Q bytes, and
    // the response buffer.
    //

    psAuthMsg = ALLOCATE_POOL( PagedPool,
                               sizeof( NDS_AUTH_MSG ) +    // auth message
                               sizeof( NDS_CREDENTIAL ) +  // credential
                               MAX_NDS_NAME_SIZE +         //
                               ( MAX_RSA_BYTES * 9 ) );    // G-Q rands

    if ( !psAuthMsg ) {

        DebugTrace( 0, Dbg, "Out of memory in NdsServerAuthenticate (0)...\n", 0 );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pbResponse = ALLOCATE_POOL( PagedPool, NDS_BUFFER_SIZE );

    if ( !pbResponse ) {

        DebugTrace( 0, Dbg, "Out of memory in NdsServerAuthenticate (1)...\n", 0 );
        FREE_POOL( psAuthMsg );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    psLocalCredential = (PNDS_CREDENTIAL)( ((BYTE *) psAuthMsg) +
                                        sizeof( NDS_AUTH_MSG ) );

    //
    // Locate the public BSAFE key.
    //

    cbUserPublicBsafeKeyLen = NdsGetBsafeKey ( (BYTE *)(pNdsContext->PublicNdsKey),
                                               pNdsContext->PublicKeyLen,
                                               &pbUserPublicBsafeKey );

    //
    // Can the length of the BSAFE key be 0? I guess not.
    //

    if (( cbUserPublicBsafeKeyLen == 0 ) ||
       ( (DWORD)cbUserPublicBsafeKeyLen > pNdsContext->PublicKeyLen )) {

       Status = STATUS_UNSUCCESSFUL;
       goto ExitWithCleanup;
    }

    DebugTrace( 0, Dbg, "BSAFE key size : %d\n", cbUserPublicBsafeKeyLen );

    //
    // Get the user's object Id but do not jump dir servers.  There is never
    // any optional data, so we don't really need to skip over it.
    //

    uUserName.MaximumLength = pNdsContext->Credential->userNameLength;
    uUserName.Length = uUserName.MaximumLength;
    uUserName.Buffer = ( WCHAR * ) ( ((BYTE *)pNdsContext->Credential) +
                                     sizeof( NDS_CREDENTIAL ) +
                                     pNdsContext->Credential->optDataSize );

    Status = NdsResolveNameKm( pIrpContext,
                               &uUserName,
                               &UserOID,
                               FALSE,
                               RSLV_DEREF_ALIASES | RSLV_CREATE_ID | RSLV_ENTRY_ID );

    if ( !NT_SUCCESS(Status) ) {
        goto ExitWithCleanup;
    }

    //
    // Issue the Begin Authenticate request to get the random server nonce.
    //

    Status = BeginAuthenticate( pIrpContext,
                                UserOID,
                                &dwServerRand );

    if ( !NT_SUCCESS(Status) ) {
        goto ExitWithCleanup;
    }

    //
    // Figure out the size of the zero-padded RSA Blocks.  We use the same
    // size as the modulus field of the public key (typically 56 bytes).
    //

    RSAGetModulus( pbUserPublicBsafeKey,
                   cbUserPublicBsafeKeyLen,
                   &rsaBlockSize);

    DebugTrace( 0, Dbg, "RSA block size for authentication: %d\n", rsaBlockSize );

    //
    // Prepare the credential and the 3 G-Q rands.  The credential,
    // xs, and ys go out in the packet; rs is secret.
    //

    RtlZeroMemory( ( BYTE * )psLocalCredential,
                   sizeof( NDS_CREDENTIAL ) +
                   MAX_NDS_NAME_SIZE +
                   9 * rsaBlockSize );

    dwLocalCredentialLen = sizeof( NDS_CREDENTIAL ) +
                           pNdsContext->Credential->optDataSize +
                           pNdsContext->Credential->userNameLength;

    DebugTrace( 0, Dbg, "Credential length is %d.\n", dwLocalCredentialLen );

    RtlCopyMemory( (BYTE *)psLocalCredential,
                   pNdsContext->Credential,
                   dwLocalCredentialLen );

    x = ( BYTE * ) psAuthMsg + sizeof( NDS_AUTH_MSG ) + dwLocalCredentialLen;
    y = x + ( 3 * rsaBlockSize );
    r = y + ( 3 * rsaBlockSize );

    rsaModSize = RSAGetInputBlockSize( pbUserPublicBsafeKey,
                                       cbUserPublicBsafeKeyLen );

    DebugTrace( 0, Dbg, "RSA modulus size: %d\n", rsaModSize );

    for ( i = 0; i < 3; i++ ) {

        //
        // Create Random numbers r1, r2 and r3  of modulus size.
        //

        GenRandomBytes( r + ( rsaBlockSize * i ), rsaModSize );

        //
        // Compute x = r**e mod N.
        //

        RSAPublic( pbUserPublicBsafeKey,
                   cbUserPublicBsafeKeyLen,
                   r + ( rsaBlockSize * i ),
                   rsaModSize,
                   x + ( rsaBlockSize * i ) );

    }

    //
    // Fill in the AuthMsg fields.
    //

    psAuthMsg->version = 0;
    psAuthMsg->svrRand = dwServerRand;
    psAuthMsg->verb = NDSV_FINISH_AUTHENTICATE;
    psAuthMsg->credentialLength = dwLocalCredentialLen;

    //
    // MD2 hash the auth message, credential and x's.
    //

    MD2( (BYTE *)psAuthMsg,
         sizeof( NDS_AUTH_MSG ) +
         psAuthMsg->credentialLength +
         ( 3 * rsaBlockSize ),
         CredentialHash );

    //
    // Compute yi = ri*(S**ci) mod N; c1,c2,c3 are the first three
    // 16 bit numbers in CredentialHash.
    //

    totalXLen = 3 * rsaBlockSize;

    for ( i = 0; i < 3; i++ ) {

        RSAModExp( pbUserPublicBsafeKey,
                   cbUserPublicBsafeKeyLen,
                   ( (BYTE *)(pNdsContext->Signature) ) + sizeof( NDS_SIGNATURE ),
                   pNdsContext->Signature->signDataLength,
                   &CredentialHash[i * sizeof( WORD )],
                   sizeof( WORD ),
                   y + ( rsaBlockSize * i) );

        RSAModMpy( pbUserPublicBsafeKey,
                   cbUserPublicBsafeKeyLen,
                   y + ( rsaBlockSize * i ),     // input1 = S**ci mod N
                   rsaModSize + 1,
                   r + ( rsaBlockSize * i ),     // input2 = ri
                   rsaModSize,
                   y + ( rsaBlockSize * i ) );   // output = yi
    }

    //
    // Send the auth proof.
    //

    NdsRequest.pRecvBufferVa = pbResponse;
    NdsRequest.dwRecvLen = NDS_BUFFER_SIZE;
    NdsRequest.pRecvMdl = NULL;

    NdsRequest.pRecvMdl = ALLOCATE_MDL( pbResponse,
                                        NDS_BUFFER_SIZE,
                                        FALSE,
                                        FALSE,
                                        NULL );
    if ( !NdsRequest.pRecvMdl ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithCleanup;
    }

    MmProbeAndLockPages( NdsRequest.pRecvMdl,
                         KernelMode,
                         IoWriteAccess );

    Status = FragExWithWait( pIrpContext,
                             NDSV_FINISH_AUTHENTICATE,
                             &NdsRequest,
                             "DDDrDDWWWWr",
                             0,                                       // version
                             0,                                       // sessionKeyLen
                             psAuthMsg->credentialLength,             // credential len
                             (BYTE *)psLocalCredential,               // actual credential
                             ROUNDUP4( psAuthMsg->credentialLength ),
                             12 + ( totalXLen * 2 ),                  // length of remaining
                             1,                                       // proof version?
                             8,                                       // tag?
                             16,                                      // message digest base
                             3,                                       // proof order
                             totalXLen,                               // proofOrder*sizeof(x)
                             x,                                       // x1,x2,x3,y1,y2,y3
                             2 * totalXLen );

    MmUnlockPages( NdsRequest.pRecvMdl );
    FREE_MDL( NdsRequest.pRecvMdl );

    if ( !NT_SUCCESS( Status ) ) {
       goto ExitWithCleanup;
    }

    Status = NdsCompletionCodetoNtStatus( &NdsRequest );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    cbResponseLen = NdsRequest.dwBytesWritten;
    DebugTrace( 0, Dbg, "Authentication returned ok status.\n", 0 );

    //
    // We completed NDS authentication, so clear out the name
    // and password in the SCB so that we use the credentials
    // from now on.
    //

    if ( pIrpContext->pScb->UserName.Buffer != NULL ) {

        DebugTrace( 0, Dbg, "Clearing out bindery login data.\n", 0 );

        pIrpContext->pScb->UserName.Length = 0;
        pIrpContext->pScb->UserName.MaximumLength = 0;

        pIrpContext->pScb->Password.Length = 0;
        pIrpContext->pScb->Password.MaximumLength = 0;

        FREE_POOL( pIrpContext->pScb->UserName.Buffer );
        RtlInitUnicodeString( &pIrpContext->pScb->UserName, NULL );
        RtlInitUnicodeString( &pIrpContext->pScb->Password, NULL );

    }

ExitWithCleanup:

    FREE_POOL( psAuthMsg );
    FREE_POOL( pbResponse );

    return Status;
}

NTSTATUS
BeginAuthenticate(
    IN PIRP_CONTEXT pIrpContext,
    IN DWORD        dwUserId,
    OUT DWORD       *pdwSvrRandom
)
/*++

Routine Description:

    Authenticate an NDS connection.
    The user must have already logged into the NDS tree.

Arguments:

    pIrpContext    - IrpContext for the server that we want to authenticate to.
    dwUserID       - The user OID that we are authenticating ourselves as.
    pdwSvrRandon   - The server random challenge.

Return value:

    NTSTATUS - The result of the operation.

--*/
{
    NTSTATUS Status;
    LOCKED_BUFFER NdsRequest;

    DWORD dwClientRand;

    PAGED_CODE();

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( !NT_SUCCESS( Status ) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    GenRandomBytes( (BYTE *)&dwClientRand, sizeof( dwClientRand ) );

    Status = FragExWithWait( pIrpContext,
                             NDSV_BEGIN_AUTHENTICATE,
                             &NdsRequest,
                             "DDD",
                             0,               // Version.
                             dwUserId,        // Entry Id.
                             dwClientRand );  // Client's random challenge.

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = NdsCompletionCodetoNtStatus( &NdsRequest );

    if ( !NT_SUCCESS( Status ) ) {

        if ( Status == STATUS_BAD_NETWORK_PATH ) {
            Status = STATUS_NO_SUCH_USER;
        }

        goto ExitWithCleanup;
    }

    //
    // The reply actually contains all this, even though we don't look at it?
    //
    //     typedef struct {
    //         DWORD svrRand;
    //         DWORD totalLength;
    //         TAG_DATA_HEADER tdh;
    //         WORD unknown;                         // Always 2.
    //         DWORD encClientRandLength;
    //         CIPHER_BLOCK_HEADER keyCipherHdr;
    //         BYTE keyCipher[];
    //         CIPHER_BLOCK_HEADER encClientRandHdr;
    //         BYTE encClientRand[];
    //     } REPLY_BEGIN_AUTHENTICATE;
    //
    // Nah, that can't be right.
    //

    Status = ParseResponse( NULL,
                            NdsRequest.pRecvBufferVa,
                            NdsRequest.dwBytesWritten,
                            "G_D",
                            sizeof( DWORD ),
                            pdwSvrRandom );

    //
    // We either got it or we didn't.
    //

ExitWithCleanup:

    NdsFreeLockedBuffer( &NdsRequest );
    return Status;
}

NTSTATUS
NdsLicenseConnection(
    PIRP_CONTEXT pIrpContext
)
/*+++

    Send the license NCP to the server to license this connection.

---*/
{

    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace( 0, Dbg, "Licensing connection to %wZ.\n", &(pIrpContext->pNpScb->pScb->UidServerName) );

    //
    // Change the authentication state of the connection.
    //

    Status = ExchangeWithWait ( pIrpContext,
                                SynchronousResponseCallback,
                                "SD",
                                NCP_ADMIN_FUNCTION,
                                NCP_CHANGE_CONN_AUTH_STATUS,
                                NCP_CONN_LICENSED );

    if ( !NT_SUCCESS( Status ) ) {
        DebugTrace( 0, Dbg, "Licensing failed to %wZ.\n", &(pIrpContext->pNpScb->pScb->UidServerName) );
    }

    return Status;

}

NTSTATUS
NdsUnlicenseConnection(
    PIRP_CONTEXT pIrpContext
)
/*+++

    Send the license NCP to the server to license this connection.

---*/
{

    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace( 0, Dbg, "Unlicensing connection to %wZ.\n", &(pIrpContext->pNpScb->pScb->UidServerName) );

    //
    // Change the authentication state of the connection.
    //

    Status = ExchangeWithWait ( pIrpContext,
                                SynchronousResponseCallback,
                                "SD",
                                NCP_ADMIN_FUNCTION,
                                NCP_CHANGE_CONN_AUTH_STATUS,
                                NCP_CONN_NOT_LICENSED );

    if ( !NT_SUCCESS( Status ) ) {
        DebugTrace( 0, Dbg, "Unlicensing failed to %wZ.\n", &(pIrpContext->pNpScb->pScb->UidServerName) );
    }

    return Status;
}

int
NdsGetBsafeKey(
    UCHAR       *pPubKey,
    const int   pubKeyLen,
    UCHAR       **ppBsafeKey
)
/*++

Routine Description:

    Locate the BSAFE key from within the public key.  Note that this does
    not work for private keys in NDS format.  For private keys, you just
    skip the size word.

    This is verbatim from Win95.

Routine Arguments:

    pPubKey        - A pointer to the public key.
    pubKeyLen      - The length of the public key.
    ppBsafeKey     - The pointer to the BSAFE key in the public key.

Return Value:

    The length of the BSAFE key.

--*/
{
    int bsafePubKeyLen = 0, totalDNLen;
    char *pRcv;
    NTSTATUS Status;

    PAGED_CODE();

    totalDNLen = 0;
    Status = ParseResponse( NULL,
                            pPubKey,
                            pubKeyLen,
                            "G_W",
                            ( 2 * sizeof( DWORD ) ) + sizeof( WORD ),
                            &totalDNLen );

    if ( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    Status = ParseResponse( NULL,
                            pPubKey,
                            pubKeyLen - 12,
                            "G__W",
                            12,
                            5 * sizeof( WORD ) +
                            3 * sizeof( DWORD ) +
                            totalDNLen,
                            &bsafePubKeyLen );

    if ( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    *ppBsafeKey = (UCHAR *) pPubKey +
                            14 +
                            5 * sizeof( WORD ) +
                            3 * sizeof( DWORD ) +
                            totalDNLen;


Exit:

    return bsafePubKeyLen;
}

NTSTATUS
NdsLogoff(
    IN PIRP_CONTEXT pIrpContext
)
/*++

Routine Description:

    Sends a logout to the NDS tree, closes all NDS authenticated
    connections, and destroys the current set of NDS credentials.

    This routine acquires the credential list exclusive.

Arguments:

    pIrpContext - The IRP context for this request pointed to a
    valid dir server.

Notes:

    This is only called from DeleteConnection.  The caller owns
    the RCB exclusive and we will free it before returning.

--*/
{
    NTSTATUS Status;
    LOCKED_BUFFER NdsRequest;
    PNDS_SECURITY_CONTEXT pCredentials;
    PLOGON pLogon;
    PSCB pScb;
    PNONPAGED_SCB pNpScb;

    PLIST_ENTRY ScbQueueEntry;
    PNONPAGED_SCB pNextNpScb;
    KIRQL OldIrql;

    //
    // Grab the user's LOGON structure.
    //

    pNpScb = pIrpContext->pNpScb;
    pScb = pNpScb->pScb;

    //
    // The caller owns the RCB.
    //

    pLogon = FindUser( &pScb->UserUid, FALSE );

    if ( !pLogon ) {
        DebugTrace( 0, Dbg, "Invalid security context for NdsLogoff.\n", 0 );
        NwReleaseRcb( &NwRcb );
        NwDequeueIrpContext( pIrpContext, FALSE );
        return STATUS_NO_SUCH_USER;
    }

    //
    // Check to make sure that we have something to log off from.
    //

    Status = NdsLookupCredentials( pIrpContext,
                                   &pScb->NdsTreeName,
                                   pLogon,
                                   &pCredentials,
                                   CREDENTIAL_WRITE,
                                   FALSE );

    if ( !NT_SUCCESS( Status )) {
        DebugTrace( 0, Dbg, "NdsLogoff: Nothing to log off from.\n", 0 );
        NwReleaseRcb( &NwRcb );
        NwDequeueIrpContext( pIrpContext, FALSE );
        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    //
    // If the credentials are locked, then someone is already
    // doing a logout.
    //

    if ( pCredentials->CredentialLocked ) {
        DebugTrace( 0, Dbg, "NdsLogoff: Logoff already in progress.\n", 0 );
        NwReleaseCredList( pLogon, pIrpContext );
        NwReleaseRcb( &NwRcb );
        NwDequeueIrpContext( pIrpContext, FALSE );
        return STATUS_DEVICE_BUSY;
    }

    //
    // Mark the credential locked so we can logout without
    // worrying about others logging in.
    //

    pCredentials->CredentialLocked = TRUE;

    //
    // Release all our resoures so we can jump around servers.
    //

    NwReleaseCredList( pLogon, pIrpContext );
    NwReleaseRcb( &NwRcb );
    NwDequeueIrpContext( pIrpContext, FALSE );

    //
    // Look through the scb list for connections that are in use.  If all
    // existing connections can be closed down, then we can complete the logout.
    //

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    ScbQueueEntry = pNpScb->ScbLinks.Flink;

    if ( ScbQueueEntry == &ScbQueue ) {
        ScbQueueEntry = ScbQueue.Flink;
    }

    pNextNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );

    NwReferenceScb( pNextNpScb );
    KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    while ( pNextNpScb != pNpScb ) {

        if ( pNextNpScb->pScb != NULL ) {

            //
            // Is this connection in use by us and is it NDS authenticated?
            //

            if ( RtlEqualUnicodeString( &pScb->NdsTreeName,
                                        &pNextNpScb->pScb->NdsTreeName,
                                        TRUE ) &&
                 ( pScb->UserUid.QuadPart == pNextNpScb->pScb->UserUid.QuadPart ) &&
                 ( pNextNpScb->State == SCB_STATE_IN_USE ) &&
                 ( pNextNpScb->pScb->UserName.Length == 0 ) ) {

                pIrpContext->pNpScb = pNextNpScb;
                pIrpContext->pScb = pNextNpScb->pScb;
                NwAppendToQueueAndWait( pIrpContext );

                if ( pNextNpScb->pScb->OpenFileCount == 0 ) {

                    //
                    // Can we close it anyway?  Should we check
                    // for open handles and the such here?
                    //

                    pNextNpScb->State = SCB_STATE_LOGIN_REQUIRED;
                    NwDequeueIrpContext( pIrpContext, FALSE );

                } else {

                    DebugTrace( 0, Dbg, "NdsLogoff: Other connections in use.\n", 0 );

                    NwAcquireExclusiveCredList( pLogon, pIrpContext );
                    pCredentials->CredentialLocked = FALSE;
                    NwReleaseCredList( pLogon, pIrpContext );

                    NwDereferenceScb( pNextNpScb );
                    NwDequeueIrpContext( pIrpContext, FALSE );

                    return STATUS_CONNECTION_IN_USE;

                }
            }

        }

        //
        // Select the next scb.
        //

        KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

        ScbQueueEntry = pNextNpScb->ScbLinks.Flink;

        if ( ScbQueueEntry == &ScbQueue ) {
            ScbQueueEntry = ScbQueue.Flink;
        }

        NwDereferenceScb( pNextNpScb );
        pNextNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );

        NwReferenceScb( pNextNpScb );
        KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    }

    //
    // Check to make sure we can close the host scb.
    //

    if ( pScb->OpenFileCount != 0 ) {

        DebugTrace( 0, Dbg, "NdsLogoff: Seed connection in use.\n", 0 );

        NwAcquireExclusiveCredList( pLogon, pIrpContext );
        pCredentials->CredentialLocked = FALSE;
        NwReleaseCredList( pLogon, pIrpContext );
        NwDereferenceScb( pNpScb );

        return STATUS_CONNECTION_IN_USE;
    }

    //
    // We can actually do the logout, so remove the credentials from
    // the resource list, release the resource, and logout.
    //
    // If we are deleting the preferred tree credentials,
    // then we need to clear the preferred server.
    //
    // We should try a little harder to free the preferred
    // server ref count, too, but that's tricky with preferred
    // server election.
    //

    if ( (pLogon->NdsCredentialList).Flink == &(pCredentials->Next) ) {

        if ( pLogon->ServerName.Buffer != NULL ) {

            DebugTrace( 0, Dbg, "Clearing preferred server at logout time.\n", 0 );

            FREE_POOL( pLogon->ServerName.Buffer );
            pLogon->ServerName.Length = pLogon->ServerName.MaximumLength = 0;
            pLogon->ServerName.Buffer = NULL;

        }
    }

    NwAcquireExclusiveCredList( pLogon, pIrpContext );
    RemoveEntryList( &pCredentials->Next );
    NwReleaseCredList( pLogon, pIrpContext );

    FreeNdsContext( pCredentials );

    pIrpContext->pNpScb = pNpScb;
    pIrpContext->pScb = pScb;

    //
    // Try to send the logout request and hope the server
    // is still up and reachable.
    //

    Status = NdsAllocateLockedBuffer( &NdsRequest, NDS_BUFFER_SIZE );

    if ( NT_SUCCESS( Status ) ) {

        Status = FragExWithWait( pIrpContext,
                                 NDSV_LOGOUT,
                                 &NdsRequest,
                                 NULL );

        NdsFreeLockedBuffer( &NdsRequest );

    }

    NwAppendToQueueAndWait( pIrpContext );

    pNpScb->State = SCB_STATE_LOGIN_REQUIRED;

    NwDequeueIrpContext( pIrpContext, FALSE );

    NwDereferenceScb( pNpScb );

    return STATUS_SUCCESS;

}

NTSTATUS
NdsLookupCredentials2(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING puTreeName,
    IN PLOGON pLogon,
    OUT PNDS_SECURITY_CONTEXT *ppCredentials,
    BOOL LowerIrpHasLock
)
/*+++

    Retrieve the nds credentials for the given tree from the
    list of valid credentials for the specified user. This routine is 
    called only during a reconnect attempt.
    
    puTreeName      - The name of the tree that we want credentials for.  If NULL
                      is specified, we return the credentials for the default tree.
    pLogon          - The logon structure for the user we want to access the tree.
    ppCredentials   - Where to put the pointed to the credentials.
    LowerIrpHasLock - TRUE if the IRP_CONTEXT below the current one has the 
                      lock.
    
    If we succeed,we return the credentials.  The caller is responsible for
    releasing the list when done with the credentials.
    
    If we fail, we release the credential list ourselves.

---*/
{

    NTSTATUS Status;

    PLIST_ENTRY pFirst, pNext;
    PNDS_SECURITY_CONTEXT pNdsContext;

    PAGED_CODE();

    //
    // Acquire the lock only if the lower IRP_CONTEXT does not hold
    // the lock. If we always try to grab the lock, we will deadlock !
    //
    
    if (!LowerIrpHasLock){
          
          NwAcquireExclusiveCredList( pLogon, pIrpContext );
       }


    pFirst = &pLogon->NdsCredentialList;
    pNext = pLogon->NdsCredentialList.Flink;

    while ( pNext && ( pFirst != pNext ) ) {

        pNdsContext = (PNDS_SECURITY_CONTEXT)
                      CONTAINING_RECORD( pNext,
                                         NDS_SECURITY_CONTEXT,
                                         Next );

        ASSERT( pNdsContext->ntc == NW_NTC_NDS_CREDENTIAL );

        if ( !puTreeName ||
             !RtlCompareUnicodeString( puTreeName,
                                       &pNdsContext->NdsTreeName,
                                       TRUE ) ) {

            //
            // If the tree name is null, we'll return the first one
            // on the list.  Otherwise this will work as normal.
            //

            *ppCredentials = pNdsContext;
            return STATUS_SUCCESS;
        }

    pNext = pNdsContext->Next.Flink;

    }

    if (!LowerIrpHasLock) {
       
       NwReleaseCredList( pLogon, pIrpContext );
    }
    
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\procs.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Procs.h

Abstract:

    This module defines all of the globally used procedures in the NetWare
    redirector.

Author:

    Colin Watson    [ColinW]    15-Dec-1992

Revision History:

--*/

#ifndef _NWPROCS_
#define _NWPROCS_

#ifndef QFE_BUILD
#define IFS 1
#define NWFASTIO 1
#endif

#ifdef IFS

    #include <ntifs.h>
    #include <ntddmup.h>

#else

    #include <ntioapi.h>
    #include <zwapi.h>
    #include <FsRtl.h>

#endif
#include <string.h>
#include <Tdi.h>
#include <TdiKrnl.h>
#include <Status.h>
#include <nwstatus.h>

//  Netware and Netware redirector specific includes

#ifndef DBG
#define DBG 0
#endif

#if !DBG
#undef NWDBG
#endif

#if NWDBG
#define PAGED_DBG 1
#endif
#ifdef PAGED_DBG
#undef PAGED_CODE
#define PAGED_CODE() \
    struct { ULONG bogus; } ThisCodeCantBePaged; \
    ThisCodeCantBePaged; \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        KdPrint(( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        ASSERT(FALSE); \
        }
#define PAGED_CODE_CHECK() if (ThisCodeCantBePaged) ;
extern ULONG ThisCodeCantBePaged;
#else
#define PAGED_CODE_CHECK()
#endif

#include <NtDDNwfs.h>
#include "Const.h"
#include "Nodetype.h"
#include "ncp.h"
#include "Struct.h"
#include "Data.h"
#include "Exchange.h"
#include <NwEvent.h>

//
// NDS Additions.
//

#include <nds.h>
#include "ndsprocs.h"

//  Attach.c

NTSTATUS
ConnectToServer(
    IN PIRP_CONTEXT pIrpContext,
    OUT PSCB *pScbCollision
);

NTSTATUS
ProcessFindNearest(
    IN struct _IRP_CONTEXT* pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR RspData
    );

NTSTATUS
CrackPath (
    IN PUNICODE_STRING BaseName,
    OUT PUNICODE_STRING DriveName,
    OUT PWCHAR DriveLetter,
    OUT PUNICODE_STRING ServerName,
    OUT PUNICODE_STRING VolumeName,
    OUT PUNICODE_STRING PathName,
    OUT PUNICODE_STRING FileName,
    OUT PUNICODE_STRING FullName OPTIONAL
    );

NTSTATUS
CheckScbSecurity(
    IN PIRP_CONTEXT pIrpContext,
    IN PSCB pScb,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword,
    IN BOOLEAN fDeferLogon
);

NTSTATUS
ConnectScb(
    IN PSCB *Scb,
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING Server,
    IN IPXaddress *pServerAddress,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN DeferLogon,
    IN BOOLEAN DeleteConnection,
    IN BOOLEAN ExistingScb
);

#define IS_ANONYMOUS_SCB( pScb ) \
        ( (pScb->UidServerName).Length == 0 )

NTSTATUS
CreateScb(
    OUT PSCB *Scb,
    IN PIRP_CONTEXT pIrpC,
    IN PUNICODE_STRING Server,
    IN IPXaddress *pServerAddress,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN DeferLogon,
    IN BOOLEAN DeleteConnection
    );

VOID
DestroyAllScb(
    VOID
    );

VOID
InitializeAttach (
    VOID
    );

NTSTATUS
OpenScbSockets(
    PIRP_CONTEXT pIrpC,
    PNONPAGED_SCB pNpScb
    );

PNONPAGED_SCB
SelectConnection(
    PNONPAGED_SCB NpScb
    );

VOID
NwLogoffAndDisconnect(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    );

VOID
NwLogoffAllServers(
    PIRP_CONTEXT pIrpContext,
    PLARGE_INTEGER Uid
    );

VOID
NwDeleteScb(
    PSCB pScb
    );

NTSTATUS
NegotiateBurstMode(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb,
    BOOLEAN *LIPNegotiated
    );

VOID
RenegotiateBurstMode(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    );

BOOLEAN
NwFindScb(
    OUT PSCB *ppScb,
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING UidServerName,
    IN PUNICODE_STRING ServerName
    );

NTSTATUS
QueryServersAddress(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNearestScb,
    PUNICODE_STRING pServerName,
    IPXaddress *pServerAddress
    );

VOID
TreeConnectScb(
    IN PSCB Scb
    );

NTSTATUS
TreeDisconnectScb(
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

VOID
ReconnectScb(
    IN PIRP_CONTEXT IrpContext,
    IN PSCB pScb
    );

//  Cache.c

ULONG
CacheRead(
    IN PNONPAGED_FCB NpFcb,
    IN ULONG FileOffset,
    IN ULONG BytesToRead,
    IN PVOID UserBuffer
#if NWFASTIO
    , IN BOOLEAN WholeBufferOnly
#endif
    );

BOOLEAN
CacheWrite(
    IN PIRP_CONTEXT IrpContext,
    IN PNONPAGED_FCB NpFcb,
    IN ULONG FileOffset,
    IN ULONG BytesToWrite,
    IN PVOID UserBuffer
    );

ULONG
CalculateReadAheadSize(
    IN PIRP_CONTEXT IrpContext,
    IN PNONPAGED_FCB NpFcb,
    IN ULONG CacheReadSize,
    IN ULONG FileOffset,
    IN ULONG ByteCount
    );

NTSTATUS
FlushCache(
    PIRP_CONTEXT IrpContext,
    PNONPAGED_FCB NpFcb
    );

NTSTATUS
AcquireFcbAndFlushCache(
    PIRP_CONTEXT IrpContext,
    PNONPAGED_FCB NpFcb
    );

VOID
FlushAllBuffers(
    PIRP_CONTEXT pIrpContext
);

//  Callback.c


NTSTATUS
SynchronousResponseCallback (
    IN PIRP_CONTEXT pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR RspData
    );

NTSTATUS
AsynchResponseCallback (
    IN PIRP_CONTEXT pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR RspData
    );

NTSTATUS
NcpSearchFileCallback (
    IN PIRP_CONTEXT pIrpContext,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PUCHAR RspData
    );

// Cleanup.c

NTSTATUS
NwFsdCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//  Close.c

NTSTATUS
NwFsdClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//  Create.c

NTSTATUS
NwFsdCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ReadAttachEas(
    IN PIRP Irp,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING Password,
    OUT PULONG ShareType,
    OUT PDWORD CredentialExtension
    );

//  Convert.c

NTSTATUS
pNwErrorToNtStatus(
    UCHAR Error
    );

NTSTATUS
NwBurstResultToNtStatus(
    ULONG Result
    );

#define NwErrorToNtStatus( STATUS ) \
    (STATUS == 0 )? STATUS_SUCCESS : pNwErrorToNtStatus(STATUS)

NTSTATUS
NwConnectionStatusToNtStatus(
    UCHAR NwStatus
    );

UCHAR
NtAttributesToNwAttributes(
    ULONG FileAttributes
    );

UCHAR
NtToNwShareFlags(
    ULONG DesiredAccess,
    ULONG NtShareFlags
    );

LARGE_INTEGER
NwDateTimeToNtTime(
    USHORT Date,
    USHORT Time
    );

NTSTATUS
NwNtTimeToNwDateTime (
    IN LARGE_INTEGER NtTime,
    IN PUSHORT NwDate,
    IN PUSHORT NwTime
    );

//  Data.c

VOID
NwInitializeData(
    VOID
    );

//  Debug.c

#ifdef NWDBG

ULONG
NwMemDbg (
    IN PCH Format,
    ...
    );

VOID
RealDebugTrace(
    IN LONG Indent,
    IN ULONG Level,
    IN PCH Message,
    IN PVOID Parameter
    );

VOID
dump(
    IN ULONG Level,
    IN PVOID far_p,
    IN ULONG  len
    );

VOID
dumpMdl(
    IN ULONG Level,
    IN PMDL Mdl
    );

VOID
DumpIcbs(
    VOID
    ) ;


PVOID
NwAllocatePool(
    ULONG Type,
    ULONG Size,
    BOOLEAN RaiseStatus
    );

VOID
NwFreePool(
    PVOID Buffer
    );

PIRP
NwAllocateIrp(
    CCHAR Size,
    BOOLEAN ChargeQuota
    );

VOID
NwFreeIrp(
    PIRP Irp
    );

PMDL
NwAllocateMdl(
    PVOID Va,
    ULONG Length,
    BOOLEAN Secondary,
    BOOLEAN ChargeQuota,
    PIRP Irp,
    PUCHAR FileName,
    int Line
    );

VOID
NwFreeMdl(
    PMDL Mdl
    );

#else
#define dump( level, pointer, length ) { NOTHING;}
#endif


//  Deviosup.c

VOID
NwMapUserBuffer (
    IN OUT PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *UserBuffer
    );

VOID
NwLockUserBuffer (
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

//  Dir.c

NTSTATUS
NwFsdDirectoryControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//  Encrypt.c

VOID
RespondToChallenge(
    IN PUCHAR achObjectId,
    IN POEM_STRING Password,
    IN PUCHAR pChallenge,
    OUT PUCHAR pResponse
    );

//  Exchange.c

BOOLEAN
AppendToScbQueue(
    IN PIRP_CONTEXT IrpContext,
    IN PNONPAGED_SCB NpScb
    );

VOID
PreparePacket(
    PIRP_CONTEXT pIrpContext,
    PIRP pOriginalIrp,
    PMDL pMdl
    );

NTSTATUS
PrepareAndSendPacket(
    PIRP_CONTEXT    pIrpContext
    );

NTSTATUS
SendPacket(
    PIRP_CONTEXT    pIrpContext,
    PNONPAGED_SCB   pNpScb
    );

VOID
SendNow(
    IN PIRP_CONTEXT IrpContext
    );

VOID
SetEvent(
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
_cdecl
ExchangeWithWait(
    PIRP_CONTEXT    pIrpContext,
    PEX             pEx,
    char*           f,
    ...                         //  format specific parameters
    );

NTSTATUS
_cdecl
BuildRequestPacket(
    PIRP_CONTEXT    pIrpContext,
    PEX             pEx,
    char*           f,
    ...                       //  format specific parameters
    );

NTSTATUS
_cdecl
ParseResponse(
    PIRP_CONTEXT IrpContext,
    PUCHAR RequestHeader,
    ULONG RequestLength,
    char*  f,
    ...                       //  format specific parameters
    );

NTSTATUS
ParseNcpResponse(
    PIRP_CONTEXT IrpContext,
    PNCP_RESPONSE Response
    );

BOOLEAN
VerifyResponse(
    PIRP_CONTEXT pIrpContext,
    PVOID Response
    );

VOID
FreeReceiveIrp(
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
NewRouteRetry(
    IN PIRP_CONTEXT pIrpContext
    );

NTSTATUS
NewRouteBurstRetry(
    IN PIRP_CONTEXT pIrpContext
    );

VOID
ReconnectRetry(
    PIRP_CONTEXT pIrpContext
    );

ULONG
MdlLength (
    register IN PMDL Mdl
    );

VOID
NwProcessSendBurstFailure(
    PNONPAGED_SCB NpScb,
    USHORT MissingFragmentCount
    );

VOID
NwProcessSendBurstSuccess(
    PNONPAGED_SCB NpScb
    );

VOID
NwProcessReceiveBurstFailure(
    PNONPAGED_SCB NpScb,
    USHORT MissingFragmentCount
    );

VOID
NwProcessReceiveBurstSuccess(
    PNONPAGED_SCB NpScb
    );

VOID
NwProcessPositiveAck(
    PNONPAGED_SCB NpScb
    );

//  Errorlog.c

VOID
_cdecl
Error(
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID ExtraInformationBuffer,
    IN USHORT ExtraInformationLength,
    IN USHORT NumberOfInsertionStrings,
    ...
    );

//  FileInfo.c

NTSTATUS
NwFsdQueryInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NwFsdSetInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NwDeleteFile(
    IN PIRP_CONTEXT pIrpContext
    );

ULONG
OccurenceCount (
    IN PUNICODE_STRING String,
    IN WCHAR SearchChar
    );

#if NWFASTIO
BOOLEAN
NwFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NwFastQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );
#endif

//  Filobsup.c

VOID
NwSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2
    );

NODE_TYPE_CODE
NwDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVOID *FsContext,
    OUT PVOID *FsContext2
    );

BOOLEAN
NwIsIrpTopLevel (
    IN PIRP Irp
    );

//  Fsctl.c

NTSTATUS
NwFsdFileSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NwCommonFileSystemControl (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
NwFsdDeviceIoControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifndef _PNP_POWER_

VOID
HandleTdiBindMessage(
    IN PUNICODE_STRING DeviceName
);

VOID
HandleTdiUnbindMessage(
    IN PUNICODE_STRING DeviceName
);

#endif

PLOGON
FindUser(
    IN PLARGE_INTEGER Uid,
    IN BOOLEAN ExactMatch
    );

LARGE_INTEGER
GetUid(
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    );

BOOL
IsSystemLuid();

PLOGON
FindUserByName(
    IN PUNICODE_STRING UserName
);

VOID
LazySetShareable(
    PIRP_CONTEXT IrpContext,
    PICB pIcb,
    PFCB pFcb
);

NTSTATUS
RegisterWithMup(
    VOID
    );

VOID
DeregisterWithMup(
    VOID
    );

//  FspDisp.c

VOID
NwFspDispatch (
    IN PVOID Context
    );

NTSTATUS
NwPostToFsp (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN MarkIrpPending
    );

// hack.c

NTSTATUS
_cdecl
BuildNcpResponse(
    PIRP_CONTEXT    pIrpC,
    char*           f,
    char            Error,
    char            Status,
    ...
    );

NTSTATUS
HackSendMessage(
    PIRP_CONTEXT    pIrpContext
    );

NTSTATUS
_cdecl
HackParseResponse(
    PUCHAR Response,
    char*  FormatString,
    ...                       //  format specific parameters
    );

//  Ipx.c

NTSTATUS
IpxOpenHandle(
    OUT PHANDLE pHandle,
    OUT PDEVICE_OBJECT* ppDeviceObject,
    OUT PFILE_OBJECT* pFileObject,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSTATUS
IpxOpen(
    VOID
    );

VOID
IpxClose(
    VOID
    );

VOID
BuildIpxAddress(
    IN ULONG NetworkAddress,
    IN PUCHAR NodeAddress,
    IN USHORT Socket,
    OUT PTA_IPX_ADDRESS NetworkName
    );

VOID
BuildIpxAddressEa (
    IN ULONG NetworkAddress,
    IN PUCHAR NodeAddress,
    IN USHORT Socket,
    OUT PVOID NetworkName
    );

NTSTATUS
SetEventHandler (
    IN PIRP_CONTEXT pIrpC,
    IN PNW_TDI_STRUCT pTdiStruc,
    IN ULONG EventType,
    IN PVOID pEventHandler,
    IN PVOID pContext
    );

NTSTATUS
GetMaximumPacketSize(
    IN PIRP_CONTEXT pIrpContext,
    IN PNW_TDI_STRUCT pTdiStruct,
    OUT PULONG pMaximumPacketSize
    );

NTSTATUS
GetNewRoute(
    IN PIRP_CONTEXT pIrpContext
    );

NTSTATUS
GetTickCount(
    IN PIRP_CONTEXT pIrpContext,
    OUT PUSHORT HopCount
    );

#ifndef QFE_BUILD

NTSTATUS
SubmitLineChangeRequest(
    VOID
    );

#endif

VOID
FspProcessLineChange(
    IN PVOID Context
    );

//  Lock.c

NTSTATUS
NwFsdLockControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NwFreeLocksForIcb(
    PIRP_CONTEXT pIrpContext,
    PICB Icb
    );

//  Lockcode.c

VOID
NwReferenceUnlockableCodeSection (
    VOID
    );

VOID
NwDereferenceUnlockableCodeSection (
    VOID
    );

BOOLEAN
NwUnlockCodeSections(
    BOOLEAN BlockIndefinitely
    );

//  Pid.c

BOOLEAN
NwInitializePidTable(
//    VOID
    IN PNONPAGED_SCB pNpScb
    );

NTSTATUS
NwMapPid(
    IN PNONPAGED_SCB pNpScb,
    IN ULONG_PTR Pid32,
    OUT PUCHAR Pid8
    );

VOID
NwSetEndOfJobRequired(
    IN PNONPAGED_SCB pNpScb,
    IN UCHAR Pid8
    );

VOID
NwUnmapPid(
    IN PNONPAGED_SCB pNpScb,
    IN UCHAR Pid8,
    IN PIRP_CONTEXT IrpContext OPTIONAL
    );

VOID
NwUninitializePidTable(
    IN PNONPAGED_SCB pNpScb
//    VOID
    );

//  Read.c

NTSTATUS
NwFsdRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
BurstReadTimeout(
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
ResubmitBurstRead (
    IN PIRP_CONTEXT IrpContext
    );

#if NWFASTIO
BOOLEAN
NwFastRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );
#endif

//  Scavenger.c

VOID
DisconnectTimedOutScbs(
    LARGE_INTEGER Now
    );

VOID
NwScavengerRoutine(
    IN PWORK_QUEUE_ITEM WorkItem
    );

BOOLEAN
NwAllocateExtraIrpContext(
    OUT PIRP_CONTEXT *ppIrpContext,
    IN PNONPAGED_SCB pScb
    );

VOID
NwFreeExtraIrpContext(
    IN PIRP_CONTEXT pIrpContext
    );

VOID
CleanupScbs(
    LARGE_INTEGER Now
    );

VOID
CleanupSupplementalCredentials(
    LARGE_INTEGER Now,
    BOOLEAN       bShuttingDown
);

//  Security.c

VOID
CreateAnsiUid(
    OUT PCHAR aUid,
    IN PLARGE_INTEGER Uid
    );

NTSTATUS
MakeUidServer(
    PUNICODE_STRING UidServer,
    PLARGE_INTEGER Uid,
    PUNICODE_STRING Server
    );

NTSTATUS
Logon(
    IN PIRP_CONTEXT IrpContext
    );

VOID
FreeLogon(
    IN PLOGON Logon
    );

NTSTATUS
Logoff(
    IN PIRP_CONTEXT IrpContext
    );


PVCB *
GetDriveMapTable (
    IN LARGE_INTEGER Uid
    );

NTSTATUS
UpdateUsersPassword(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    OUT PLARGE_INTEGER Uid
    );

NTSTATUS
UpdateServerPassword(
    PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN PLARGE_INTEGER Uid
    );

//  String.c

NTSTATUS
DuplicateStringWithString (
    OUT PSTRING DestinationString,
    IN PSTRING SourceString,
    IN POOL_TYPE PoolType
    );


NTSTATUS
DuplicateUnicodeStringWithString (
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN POOL_TYPE PoolType
    );

NTSTATUS
SetUnicodeString (
    IN PUNICODE_STRING Destination,
    IN ULONG Length,
    IN PWCHAR Source
    );

VOID
MergeStrings(
    IN PUNICODE_STRING Destination,
    IN PUNICODE_STRING S1,
    IN PUNICODE_STRING S2,
    IN ULONG Type
    );

//  Strucsup.c

VOID
NwInitializeRcb (
    IN PRCB Rcb
    );

VOID
NwDeleteRcb (
    IN PRCB Rcb
    );

PFCB
NwCreateFcb (
    IN PUNICODE_STRING FileName,
    IN PSCB Scb,
    IN PVCB Vcb
    );

PFCB
NwFindFcb (
    IN PSCB Scb,
    IN PVCB Vcb,
    IN PUNICODE_STRING FileName,
    IN PDCB Dcb OPTIONAL
    );

VOID
NwDereferenceFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

PICB
NwCreateIcb (
    IN USHORT Type,
    IN PVOID Associate
    );

VOID
NwVerifyIcb (
    IN PICB Icb
    );

VOID
NwVerifyIcbSpecial(
    IN PICB Icb
    );

VOID
NwVerifyScb (
    IN PSCB Scb
    );

VOID
NwDeleteIcb (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PICB Icb
    );

PVCB
NwFindVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING VolumeName,
    IN ULONG ShareType,
    IN WCHAR DriveLetter,
    IN BOOLEAN ExplicitConnection,
    IN BOOLEAN FindExisting
    );

PVCB
NwCreateVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PUNICODE_STRING VolumeName,
    IN ULONG ShareType,
    IN WCHAR DriveLetter,
    IN BOOLEAN ExplicitConnection
    );

VOID
NwDereferenceVcb (
    IN PVCB Vcb,
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN BOOLEAN OwnRcb
    );

VOID
NwCleanupVcb(
    IN PVCB pVcb,
    IN PIRP_CONTEXT pIrpContext
    );

VOID
NwCloseAllVcbs(
    PIRP_CONTEXT pIrpContext
    );

VOID
NwReopenVcbHandlesForScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

VOID
NwReopenVcbHandle(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

ULONG
NwInvalidateAllHandles (
    PLARGE_INTEGER Uid,
    PIRP_CONTEXT IrpContext
    );

ULONG
NwInvalidateAllHandlesForScb (
    PSCB Scb
    );

BOOLEAN
IsFatNameValid (
    IN PUNICODE_STRING FileName
    );

VOID
NwFreeDirCacheForIcb(
    IN PICB Icb
    );

//  Timer.c

VOID
StartTimer(
    );

VOID
StopTimer(
    );

//  Util.c

VOID
CopyBufferToMdl(
    PMDL DestinationMdl,
    ULONG DataOffset,
    PVOID SourceData,
    ULONG SourceByteCount
    );

NTSTATUS
GetCredentialFromServerName(
    IN PUNICODE_STRING puServerName,
    OUT PUNICODE_STRING puCredentialName
);

NTSTATUS
BuildExCredentialServerName(
    IN PUNICODE_STRING puServerName,
    IN PUNICODE_STRING puUserName,
    OUT PUNICODE_STRING puExCredServerName
);

NTSTATUS
UnmungeCredentialName(
    IN PUNICODE_STRING puCredName,
    OUT PUNICODE_STRING puServerName
);

BOOLEAN
IsCredentialName(
    IN PUNICODE_STRING puObjectName
);

NTSTATUS
ExCreateReferenceCredentials(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING puResource
);

NTSTATUS
ExCreateDereferenceCredentials(
    PIRP_CONTEXT pIrpContext,
    PNDS_SECURITY_CONTEXT pNdsCredentials
);

//  VolInfo.c

NTSTATUS
NwFsdQueryVolumeInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NwFsdSetVolumeInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//  WorkQue.c

PIRP_CONTEXT
AllocateIrpContext (
    PIRP pIrp
    );

VOID
FreeIrpContext (
    PIRP_CONTEXT IrpContext
    );

VOID
InitializeIrpContext (
    VOID
    );

VOID
UninitializeIrpContext (
    VOID
    );

VOID
NwCompleteRequest (
    PIRP_CONTEXT IrpContext,
    NTSTATUS Status
    );

VOID
NwAppendToQueueAndWait(
    PIRP_CONTEXT IrpContext
    );

VOID
NwDequeueIrpContext(
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN OwnSpinLock
    );

VOID
NwCancelIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PIRP
NwAllocateSendIrp (
    PIRP_CONTEXT IrpContext
    );

PMINI_IRP_CONTEXT
AllocateMiniIrpContext (
    PIRP_CONTEXT IrpContext
    );

VOID
FreeMiniIrpContext (
    PMINI_IRP_CONTEXT MiniIrpContext
    );

PWORK_CONTEXT
AllocateWorkContext (
    VOID
    );

VOID
FreeWorkContext (
   PWORK_CONTEXT
   );

VOID
SpawnWorkerThread (
   VOID
   );

VOID
WorkerThread (
   VOID
    );

VOID
TerminateWorkerThread (
    VOID
    );


//  Write.c

NTSTATUS
NwFsdWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DoWrite(
    PIRP_CONTEXT IrpContext,
    LARGE_INTEGER ByteOffset,
    ULONG BufferLength,
    PVOID WriteBuffer,
    PMDL WriteMdl
    );

NTSTATUS
NwFsdFlushBuffers(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ResubmitBurstWrite(
    PIRP_CONTEXT IrpContext
    );

#if NWFASTIO
BOOLEAN
NwFastWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );
#endif

#ifdef _PNP_POWER_

//
// NwPnP.C
//

NTSTATUS
StartRedirector(
    PIRP_CONTEXT IrpContext
);

NTSTATUS
StopRedirector(
    IN PIRP_CONTEXT IrpContext
);

NTSTATUS
RegisterTdiPnPEventHandlers(
    IN PIRP_CONTEXT IrpContext
);

NTSTATUS
PnPSetPower(
    PNET_PNP_EVENT pEvent,
    PTDI_PNP_CONTEXT pContext1,
    PTDI_PNP_CONTEXT pContext2
);

NTSTATUS
PnPQueryPower(
    PNET_PNP_EVENT pEvent,
    PTDI_PNP_CONTEXT pContext1,
    PTDI_PNP_CONTEXT pContext2
);
NTSTATUS
PnPQueryRemove(
    PNET_PNP_EVENT pEvent,
    PTDI_PNP_CONTEXT pContext1,
    PTDI_PNP_CONTEXT pContext2
);
NTSTATUS
PnPCancelRemove(
    PNET_PNP_EVENT pEvent,
    PTDI_PNP_CONTEXT pContext1,
    PTDI_PNP_CONTEXT pContext2
);

ULONG
PnPCountActiveHandles(
    VOID
);

NTSTATUS
NwFsdProcessPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
PnpIrpCompletion(
    PDEVICE_OBJECT pDeviceObject,
    PIRP           pIrp,
    PVOID          pContext
);

NTSTATUS
NwCommonProcessPnpIrp (
    IN PIRP_CONTEXT IrpContext
);

#endif

//
//  A function that returns finished denotes if it was able to complete the
//  operation (TRUE) or could not complete the operation (FALSE) because the
//  wait value stored in the irp context was false and we would have had
//  to block for a resource or I/O
//

typedef BOOLEAN FINISHED;

//
//  Miscellaneous support routines
//

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise.  It is followed by two macros for setting and clearing
//  flags
//

#ifndef BooleanFlagOn
#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)((((Flags) & (SingleFlag)) != 0)))
#endif

#ifndef SetFlag
#define SetFlag(Flags,SingleFlag) { \
    (Flags) |= (SingleFlag);        \
}
#endif


#ifndef ClearFlag
#define ClearFlag(Flags,SingleFlag) { \
    (Flags) &= ~(SingleFlag);         \
}
#endif

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//

#define CanFsdWait(IRP) IoIsOperationSynchronous(IRP)

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
//  The following two macro are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in the
//  Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as STATUS_FILE_INVALID (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  NwFsdXxx(...)
//  {
//      try {
//
//          ...
//
//      } except(NwExceptionFilter( IrpContext, GetExceptionCode() )) {
//
//          Status = NwProcessException( IrpContext, Irp, GetExceptionCode() );
//      }
//
//      Return Status;
//  }
//
//  To explicitly raise an exception that we expect, such as
//  STATUS_FILE_INVALID, use the below macro NwRaiseStatus().  To raise a
//  status from an unknown origin (such as CcFlushCache()), use the macro
//  NwNormalizeAndRaiseStatus.  This will raise the status if it is expected,
//  or raise STATUS_UNEXPECTED_IO_ERROR if it is not.
//
//  Note that when using these two macros, the original status is placed in
//  IrpContext->ExceptionStatus, signaling NwExceptionFilter and
//  NwProcessException that the status we actually raise is by definition
//  expected.
//

LONG
NwExceptionFilter (
    IN PIRP Irp,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
NwProcessException (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS ExceptionCode
    );

//
//  VOID
//  NwRaiseStatus (
//      IN NT_STATUS Status
//  );
//
//

#define NwRaiseStatus(IRPCONTEXT,STATUS) {   \
    ExRaiseStatus( (STATUS) );                \
    KeBugCheck( NW_FILE_SYSTEM );            \
}

//
//  VOID
//  NwNormalAndRaiseStatus (
//      IN NT_STATUS Status
//  );
//

#define NwNormalizeAndRaiseStatus(IRPCONTEXT,STATUS) {                         \
    if ((STATUS) == STATUS_VERIFY_REQUIRED) { ExRaiseStatus((STATUS)); }        \
    ExRaiseStatus(FsRtlNormalizeNtstatus((STATUS),STATUS_UNEXPECTED_IO_ERROR)); \
    KeBugCheck( NW_FILE_SYSTEM );                                              \
}

//
//  The Following routine makes a popup
//

#define NwRaiseInformationalHardError(STATUS,NAME) {               \
    UNICODE_STRING Name;                                                       \
    if (NT_SUCCESS(RtlOemStringToCountedUnicodeString(&Name, (NAME), TRUE))) { \
        IoRaiseInformationalHardError(Status, &Name, (Irp == NULL ?\
             NULL : &(Irp->Tail.Overlay.Thread)->Tcb));            \
        RtlFreeUnicodeString(&Name);                                           \
    }                                                                          \
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }


#if NWDBG
#define InternalError(String) {                             \
    DbgPrint("Internal NetWare Redirector Error ");         \
    DbgPrint String;                                        \
    DbgPrint("\nFile %s, Line %d\n", __FILE__, __LINE__);   \
    ASSERT(FALSE);                                          \
}
#else
#define InternalError(String) {NOTHING;}
#endif

#define DbgPrintf DbgPrint

//
//  Reference and dereference Macros.
//

VOID
RefDbgTrace (
    PVOID Resource,
    DWORD Count,
    BOOLEAN Reference,
    PBYTE FileName,
    UINT Line
);

#ifdef NWDBG

VOID
ChkNwReferenceScb(
    PNONPAGED_SCB pNpScb,
    PBYTE FileName,
    UINT Line,
    BOOLEAN Silent
);

VOID
ChkNwDereferenceScb(
    PNONPAGED_SCB pNpScb,
    PBYTE FileName,
    UINT Line,
    BOOLEAN Silent
);

#define NwReferenceScb( pNpScb ) \
        ChkNwReferenceScb( pNpScb, __FILE__, __LINE__, FALSE )

#define NwQuietReferenceScb( pNpScb ) \
        ChkNwReferenceScb( pNpScb, __FILE__, __LINE__, TRUE )

#define NwDereferenceScb( pNpScb ) \
        ChkNwDereferenceScb( pNpScb, __FILE__, __LINE__, FALSE )

#define NwQuietDereferenceScb( pNpScb ) \
        ChkNwDereferenceScb( pNpScb, __FILE__, __LINE__, TRUE )

#else

#define NwReferenceScb( pNpScb ) \
        InterlockedIncrement( &(pNpScb)->Reference )

#define NwQuietReferenceScb( pNpScb ) \
        InterlockedIncrement( &(pNpScb)->Reference )

#define NwDereferenceScb( pNpScb ) \
        InterlockedDecrement( &(pNpScb)->Reference )

#define NwQuietDereferenceScb( pNpScb ) \
        InterlockedDecrement( &(pNpScb)->Reference )
#endif

//
// Irpcontext event macro.
//

#define NwSetIrpContextEvent( pIrpContext ) \
        DebugTrace( 0, DEBUG_TRACE_WORKQUE, "Set event for IrpC = %08lx\n", pIrpContext ); \
        DebugTrace( 0, DEBUG_TRACE_WORKQUE, "IrpC->pNpScb = %08lx\n", pIrpContext->pNpScb ); \
        KeSetEvent( &pIrpContext->Event, 0, FALSE )

//
//  VCB macros must be called with the RCB resource held.
//


#if NWDBG
VOID
NwReferenceVcb (
    IN PVCB Vcb
    );
#else
#define NwReferenceVcb( pVcb )      ++(pVcb)->Reference;
#endif

//
// Resource acquisition and release macros
//

#if NWDBG

VOID
NwAcquireExclusiveRcb(
    PRCB Rcb,
    BOOLEAN Wait
    );

VOID
NwAcquireSharedRcb(
    PRCB Rcb,
    BOOLEAN Wait
    );

VOID
NwReleaseRcb(
    PRCB Rcb
    );

VOID
NwAcquireExclusiveFcb(
    PNONPAGED_FCB pFcb,
    BOOLEAN Wait
    );

VOID
NwAcquireSharedFcb(
    PNONPAGED_FCB pFcb,
    BOOLEAN Wait
    );

VOID
NwReleaseFcb(
    PNONPAGED_FCB pFcb
    );

VOID
NwAcquireOpenLock(
    VOID
    );

VOID
NwReleaseOpenLock(
    VOID
    );

#else

#define NwAcquireExclusiveRcb( Rcb, Wait )  \
    ExAcquireResourceExclusiveLite( &((Rcb)->Resource), Wait )

#define NwAcquireSharedRcb( Rcb, Wait )  \
    ExAcquireResourceSharedLite( &((Rcb)->Resource), Wait )

#define NwReleaseRcb( Rcb ) \
    ExReleaseResourceLite( &((Rcb)->Resource) )

#define NwAcquireExclusiveFcb( pFcb, Wait )  \
    ExAcquireResourceExclusiveLite( &((pFcb)->Resource), Wait )

#define NwAcquireSharedFcb( pFcb, Wait )  \
    ExAcquireResourceSharedLite( &((pFcb)->Resource), Wait )

#define NwReleaseFcb( pFcb ) \
    ExReleaseResourceLite( &((pFcb)->Resource) )

#define NwAcquireOpenLock( ) \
    ExAcquireResourceExclusiveLite( &NwOpenResource, TRUE )

#define NwReleaseOpenLock( ) \
    ExReleaseResourceLite( &NwOpenResource )

#endif

#define NwReleaseFcbForThread( pFcb, pThread ) \
    ExReleaseResourceForThreadLite( &((pFcb)->Resource), pThread )

//
//  Memory allocation and deallocation macros
//

#ifdef NWDBG

#define ALLOCATE_POOL_EX( Type, Size )  NwAllocatePool( Type, Size, TRUE )
#define ALLOCATE_POOL( Type, Size )     NwAllocatePool( Type, Size, FALSE )
#define FREE_POOL( Buffer )             NwFreePool( Buffer )

#define ALLOCATE_IRP( Size, ChargeQuota ) \
                                        NwAllocateIrp( Size, ChargeQuota )
#define FREE_IRP( Irp )                 NwFreeIrp( Irp )

#define ALLOCATE_MDL( Va, Length, Secondary, ChargeQuota, Irp ) \
                    NwAllocateMdl(Va, Length, Secondary, ChargeQuota, Irp, __FILE__, __LINE__ )
#define FREE_MDL( Mdl )                 NwFreeMdl( Mdl )

#else

#define ALLOCATE_POOL_EX( Type, Size )  FsRtlAllocatePoolWithTag( Type, Size, 'scwn' )
#ifndef QFE_BUILD
#define ALLOCATE_POOL( Type, Size )     ExAllocatePoolWithTag( Type, Size, 'scwn' )
#else
#define ALLOCATE_POOL( Type, Size )     ExAllocatePool( Type, Size )
#endif
#define FREE_POOL( Buffer )             ExFreePool( Buffer )

#define ALLOCATE_IRP( Size, ChargeQuota ) \
                                        IoAllocateIrp( Size, ChargeQuota )
#define FREE_IRP( Irp )                 IoFreeIrp( Irp )

#define ALLOCATE_MDL( Va, Length, Secondary, ChargeQuota, Irp ) \
                    IoAllocateMdl(Va, Length, Secondary, ChargeQuota, Irp )
#define FREE_MDL( Mdl )                 IoFreeMdl( Mdl )
#endif

//
// Useful macros
//

#define MIN(a,b)     ((a)<(b) ? (a):(b))
#define MAX(a,b)     ((a)>(b) ? (a):(b))

#define DIFFERENT_PAGES( START, SIZE ) \
    (((ULONG)START & ~(4096-1)) != (((ULONG)START + SIZE) & ~(4096-1)))

#define UP_LEVEL_SERVER( Scb )  \
    ( ( Scb->MajorVersion >= 4 ) ||   \
      ( Scb->MajorVersion == 3 && Scb->MinorVersion >= 12 ) )

#define LFN_SUPPORTED( Scb )  \
    ( ( Scb->MajorVersion >= 4 ) ||   \
      ( Scb->MajorVersion == 3 && Scb->MinorVersion >= 11 ) )

#define LongByteSwap( l1, l2 )     \
{                                  \
    PUCHAR c1 = (PUCHAR)&l1;       \
    PUCHAR c2 = (PUCHAR)&l2;       \
    c1[0] = c2[3];                 \
    c1[1] = c2[2];                 \
    c1[2] = c2[1];                 \
    c1[3] = c2[0];                 \
}

#define ShortByteSwap( s1, s2 )    \
{                                  \
    PUCHAR c1 = (PUCHAR)&s1;       \
    PUCHAR c2 = (PUCHAR)&s2;       \
    c1[0] = c2[1];                 \
    c1[1] = c2[0];                 \
}



#define CanLogTimeOutEvent( LastTime, CurrentTime ) \
     ( ( CurrentTime.QuadPart ) - ( LastTime.QuadPart ) >= 0 )

#define UpdateNextEventTime( LastTime, CurrentTime, TimeOutEventInterval ) \
    ( LastTime.QuadPart ) = ( CurrentTime.QuadPart ) + \
                            ( TimeOutEventInterval.QuadPart )



//
//  Macros to isolate NT 3.1 and NT 3.5 differences.
//

#ifdef QFE_BUILD

#define NwGetTopLevelIrp()     (PIRP)(PsGetCurrentThread()->TopLevelIrp)
#define NwSetTopLevelIrp(Irp)  (PIRP)(PsGetCurrentThread())->TopLevelIrp = Irp;


#else

#define NwGetTopLevelIrp()     IoGetTopLevelIrp()
#define NwSetTopLevelIrp(Irp)  IoSetTopLevelIrp(Irp)

#endif

//
// David Goebel - pls figure out which file below should come from
//          io.h cannot be included successfully
//

NTKERNELAPI
VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );

// now all SKUs have TerminalServer flag.  If App Server is enabled, SingleUserTS flag is cleared
#define IsTerminalServer() !(ExVerifySuite(SingleUserTS))

#endif // _NWPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\scavengr.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Scavengr.c

Abstract:

    This module implements the Netware Redirector scavenger thread.

Author:

    Manny Weiser    [MannyW]    15-Feb-1993

Revision History:

  Tommy Evans (tommye) 04-27-2000 MS bug 33463 - added bShuttingDown flag
                        to CleanupSupplementalCredentials() to force cleanup
                        of cached credentials when we are unloaded.
--*/

#include "Procs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_SCAVENGER)

extern BOOLEAN WorkerRunning;   //  From timer.c

#ifdef NWDBG
DWORD DumpIcbFlag = 0 ;
#endif

VOID
CleanupVcbs(
    LARGE_INTEGER Now
    );

VOID
CleanupObjectCache(
    VOID
    );

#ifdef ALLOC_PRAGMA

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, NwAllocateExtraIrpContext )
#pragma alloc_text( PAGE1, NwFreeExtraIrpContext )
#pragma alloc_text( PAGE1, CleanupScbs )
#pragma alloc_text( PAGE1, DisconnectTimedOutScbs )
#endif

#endif

//
// Not pageable:
//
// NwScavengerRoutine - Acquires a spin lock.
// CleanupVcbs - Acquires a spin lock.
//

VOID
NwScavengerRoutine(
    IN PWORK_QUEUE_ITEM WorkItem
    )
/*++

Routine Description:

    This routine implements the scavenger.  The scavenger runs
    periodically in the context of an executive worker thread to
    do background cleanup operations on redirector data.

Arguments:

    WorkItem - The work item for this routine.

Return Value:

    None.

--*/

{
    LARGE_INTEGER Now;
    PMDL LineChangeMdl;
    PWORK_QUEUE_ITEM LineChangeWorkItem;
    KIRQL OldIrql;

    PAGED_CODE();


    DebugTrace(+1, Dbg, "NwScavengerRoutine\n", 0);

    KeQuerySystemTime( &Now );

#ifdef NWDBG
    if (DumpIcbFlag != 0)
        DumpIcbs();
#endif

    //
    //  Try to free unused VCBs.
    //

    CleanupVcbs(Now);

    //
    // Try disconnect from SCBs that are timed out.
    //

    DisconnectTimedOutScbs(Now) ;

    //
    //  Try to invalidate old object cache entries.
    //

    CleanupObjectCache();

    //
    //  Try to free unused SCBs.
    //

    CleanupScbs(Now);

    //
    // Clean up supplemental credentials that are
    // no longer being used.
    //

    CleanupSupplementalCredentials(Now, FALSE);

    //
    //  Flag we're finished now to avoid deadlock in stop timer.
    //

    KeAcquireSpinLock( &NwScavengerSpinLock, &OldIrql );

    if ( DelayedProcessLineChange ) {

        DebugTrace( 0, Dbg, "Scavenger processing a delayed line change notification.\n", 0 );

        LineChangeMdl = DelayedLineChangeIrp->MdlAddress;
        LineChangeWorkItem = ALLOCATE_POOL( NonPagedPool, sizeof( WORK_QUEUE_ITEM ) );

        if ( LineChangeWorkItem == NULL ) {

            //
            // If we couldn't get a work queue item, just blow
            // it all off for now.
            //

            FREE_POOL( LineChangeMdl->MappedSystemVa );
            FREE_MDL( LineChangeMdl );
            FREE_IRP( DelayedLineChangeIrp );

            DelayedLineChangeIrp = NULL;
            DelayedProcessLineChange = FALSE;
            WorkerRunning = FALSE;

            KeReleaseSpinLock( &NwScavengerSpinLock, OldIrql );

        } else {

            //
            // Leave WorkRunning set to TRUE so that the scavenger can't run
            // while the process line change is running, but clear the line
            // change flag.  The FspProcessLineChange function will clear the
            // WorkerRunning flag.
            //

            DelayedProcessLineChange = FALSE;
            KeReleaseSpinLock( &NwScavengerSpinLock, OldIrql );

            //
            //  Use the user buffer field as a convenient place to remember where
            //  the address of the WorkQueueItem.  We can get away with this since
            //  we don't let this IRP complete.
            //

            DelayedLineChangeIrp->UserBuffer = LineChangeWorkItem;

            //
            //  Process the line change in the FSP.
            //

            ExInitializeWorkItem( LineChangeWorkItem, FspProcessLineChange, DelayedLineChangeIrp );
            ExQueueWorkItem( LineChangeWorkItem, DelayedWorkQueue );

        }

    } else {

       //
       // No line change happened while the scavenger was running.
       //

       WorkerRunning = FALSE;
       KeReleaseSpinLock( &NwScavengerSpinLock, OldIrql );

    }

    //
    //  Unlock discardable code, if we are inactive. Don't block
    //  if can't get resource.
    //

    NwUnlockCodeSections(FALSE);


    DebugTrace(-1, Dbg, "NwScavengerRoutine\n", 0);
    return;
}


VOID
CleanupScbs(
    LARGE_INTEGER Now
    )
/*++

Routine Description:

    This routine tries to free unused VCB structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY ScbQueueEntry;
    PNONPAGED_SCB pNpScb;
    PLIST_ENTRY NextScbQueueEntry;
    PSCB pScb;
    LIST_ENTRY DyingScbs;
    LARGE_INTEGER KillTime ;

    DebugTrace(+1, Dbg, "CleanupScbs\n", 0);

    //
    //  Calculate KillTime = Now - 2 minutes.
    //

    InitializeListHead( &DyingScbs );

    KillTime.QuadPart = Now.QuadPart - ( NwOneSecond * DORMANT_SCB_KEEP_TIME );

    //
    //  Scan through the SCBs holding the RCB.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    //
    // find all SCBs that are no longer usable and put them on the dying list.
    // we will take a second pass thru to remove timed out ones, based on
    // what is left.
    //

    for (ScbQueueEntry = ScbQueue.Flink ;
         ScbQueueEntry != &ScbQueue ;
         ScbQueueEntry =  NextScbQueueEntry )
    {

        pNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );
        NextScbQueueEntry = pNpScb->ScbLinks.Flink;

        if ( ( pNpScb->Reference == 0 ) &&
             ( ( pNpScb->LastUsedTime.QuadPart < KillTime.QuadPart ) ||
               ( pNpScb->State == SCB_STATE_FLAG_SHUTDOWN ) ) )
        {
            DebugTrace( 0, Dbg,
                        "Moving SCB %08lx to dead list\n", pNpScb);

            //
            //  The SCB has no references and is not logged in nor attached.
            //

            RemoveEntryList( &pNpScb->ScbLinks );
            InsertHeadList( &DyingScbs, &pNpScb->ScbLinks );
        }

#ifdef MSWDBG
        //
        //  Look for blocked connections. If there's something
        //  queued for this server yet nothing was added or removed
        //  since the last time the scavenger ran then stop
        //

        if ((!IsListEmpty( &pNpScb->Requests ) ) &&
            (pNpScb->RequestQueued == FALSE) &&
            (pNpScb->RequestDequeued == FALSE )) {

            DebugTrace( 0, Dbg, "Server %08lx seems to be locked up!\n", pNpScb );
            ASSERT( FALSE );

        } else {

            pNpScb->RequestQueued = FALSE;
            pNpScb->RequestDequeued = FALSE;

        }
#endif
    }

    //
    //  Now that the dying SCBs are off the ScbQueue we can release
    //  the SCB spin lock.
    //

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    //
    //  Walk the list of Dying SCBs and kill them off.  Note that we are
    //  still holding the RCB.
    //

    while ( !IsListEmpty( &DyingScbs ) ) {

        pNpScb = CONTAINING_RECORD( DyingScbs.Flink, NONPAGED_SCB, ScbLinks );
        pScb = pNpScb->pScb;

        RemoveHeadList( &DyingScbs );
        NwDeleteScb( pScb );
    }

    NwReleaseRcb( &NwRcb );

    DebugTrace(-1, Dbg, "CleanupScbs\n", 0);

}

VOID
CleanupVcbs(
    LARGE_INTEGER Now
    )
/*++

Routine Description:

    This routine tries to free unused VCB structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY ScbQueueEntry;
    PLIST_ENTRY VcbQueueEntry;
    PLIST_ENTRY NextVcbQueueEntry;
    PNONPAGED_SCB pNpScb;
    PSCB pScb;
    PVCB pVcb;
    LARGE_INTEGER KillTime;

    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN VcbDeleted;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "CleanupVcbs...\n", 0 );

    //
    //  Calculate KillTime = Now - 5 minutes.
    //

    KillTime.QuadPart = Now.QuadPart - ( NwOneSecond * DORMANT_VCB_KEEP_TIME );

    //
    //  Scan through the SCBs.
    //

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    ScbQueueEntry = ScbQueue.Flink;

    while ( ScbQueueEntry != &ScbQueue ) {

        pNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );

        //
        //  Reference the SCB so that it won't go away when we release
        //  the SCB spin lock.
        //

        NwReferenceScb( pNpScb );

        KeReleaseSpinLock( &ScbSpinLock, OldIrql );

        pScb = pNpScb->pScb;

        if ( pScb == NULL) {

            //
            //  This must be the permanent SCB.  Just skip it.
            //

            ASSERT( pNpScb == &NwPermanentNpScb );

        } else {

            //
            // Get an irp context and get to the head of the queue.
            //

            if ( NwAllocateExtraIrpContext( &IrpContext, pNpScb ) ) {

                IrpContext->pNpScb = pNpScb;
                IrpContext->pScb = pNpScb->pScb;
                NwAppendToQueueAndWait( IrpContext );

                NwAcquireExclusiveRcb( &NwRcb, TRUE );

                VcbDeleted = TRUE;

                //
                //  NwCleanupVcb releases the RCB, but we can't be guaranteed
                //  the state of the Vcb list when we release the RCB.
                //
                //  If we need to cleanup a VCB, release the lock, and start
                //  processing the list again.
                //

                while ( VcbDeleted ) {

                    VcbDeleted = FALSE;

                    for ( VcbQueueEntry = pScb->ScbSpecificVcbQueue.Flink ;
                          VcbQueueEntry != &pScb->ScbSpecificVcbQueue;
                          VcbQueueEntry = NextVcbQueueEntry ) {

                        pVcb = CONTAINING_RECORD( VcbQueueEntry, VCB, VcbListEntry );
                        NextVcbQueueEntry = VcbQueueEntry->Flink;

                        //
                        //  The VCB has no references, and hasn't been used for
                        //  a long time.  Kill it.
                        //

                        if ( pVcb->Reference == 0 ) {

                            Status = STATUS_SUCCESS;

                            DebugTrace(0, Dbg, "Cleaning up VCB %08lx\n", pVcb );
                            DebugTrace(0, Dbg, "VCB name =  %wZ\n", &pVcb->Name );

                            //  Lock down so that we can send a packet.
                            NwReferenceUnlockableCodeSection();

                            NwCleanupVcb( pVcb, IrpContext );

                            NwDereferenceUnlockableCodeSection ();

                            //
                            // Get back to the head of the queue, re-acquire
                            // the VCB, and restart the processing of this list.
                            //

                            NwAppendToQueueAndWait( IrpContext );
                            NwAcquireExclusiveRcb( &NwRcb, TRUE );
                            VcbDeleted = TRUE;

                            break;
                        }

                    }  // for

                }  // while

            } else {

                IrpContext = NULL;
                DebugTrace( 0, Dbg, "Couldn't cleanup SCB: %08lx\n", pNpScb );

            }

            NwReleaseRcb( &NwRcb );

        }

        //
        // Free the irp context allocated for this SCB.
        //

        if ( IrpContext != NULL ) {
            NwDequeueIrpContext( IrpContext, FALSE );
            NwFreeExtraIrpContext( IrpContext );
            IrpContext = NULL;
        }

        KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
        ScbQueueEntry = pNpScb->ScbLinks.Flink;
        NwDereferenceScb( pNpScb );
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    DebugTrace(-1, Dbg, "CleanupVcbs -> VOID\n", 0 );
}


VOID
DisconnectTimedOutScbs(
    LARGE_INTEGER Now
    )
/*++

Routine Description:

    This routine disconnects any timed out SCBs before they get
    nuked by CleanupScbs() which does not disconnect.

    NOTE: The SCB's are destroyed on a timeout for a couple of
    reasons. The first is because if we used a reference count then
    normal use of UNCs would cause us to be continually reconnecting.
    Another is in FindNearestServer where its useful to collect the
    Near servers that are out of connections so we can avoid them when
    we iterate through the 5 nearest servers and we escalate to General
    SAP response.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY ScbQueueEntry;
    PNONPAGED_SCB pNpScb;
    LARGE_INTEGER KillTime ;

    PIRP_CONTEXT IrpContext = NULL;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "DisconnectTimedOutScbs...\n", 0 );

    //
    //  Calculate KillTime = Now - 5 minutes.
    //

    KillTime.QuadPart = Now.QuadPart - ( NwOneSecond * DORMANT_SCB_KEEP_TIME );

    //
    //  Scan through the SCBs.
    //

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    ScbQueueEntry = ScbQueue.Flink;

    while ( ScbQueueEntry != &ScbQueue )
    {

        pNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );


        if ( (pNpScb != &NwPermanentNpScb) &&
             (pNpScb->Reference == 0 ) &&
             (pNpScb->LastUsedTime.QuadPart < KillTime.QuadPart) )
        {
            //
            //  Reference the SCB so that it won't go away when we release
            //  the SCB spin lock.
            //

            NwReferenceScb( pNpScb );

            KeReleaseSpinLock( &ScbSpinLock, OldIrql );

            //
            // Not the permanent SCB and the reference count is the one
            // we just added, So this is really at zero & has not been used
            // for a while. Note we only allocate the IrpContext once.
            //
            if ( IrpContext ||
                 NwAllocateExtraIrpContext( &IrpContext, pNpScb ) )
            {

                IrpContext->pNpScb = pNpScb;

                //  Lock down so that we can send a packet.
                NwReferenceUnlockableCodeSection();

                //
                // get to front of queue and recheck to make sure we are
                // still with a ref count of 1.
                //
                NwAppendToQueueAndWait( IrpContext );

                if (pNpScb->Reference == 1)
                {
                    //
                    // make sure we do not reconnect.
                    //
                    ClearFlag( IrpContext->Flags, IRP_FLAG_RECONNECTABLE );

                    //
                    // This will result in a logoff and/or disconnect as
                    // need.
                    //
                    NwLogoffAndDisconnect(IrpContext, pNpScb) ;
                }

                NwDequeueIrpContext(IrpContext, FALSE) ;

                NwDereferenceUnlockableCodeSection ();


            }
            else
            {
                //
                // Could not allocate IrpContext. Oh well, we'll just leave
                // this connection for the watch dog.
                //
            }

            KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
            NwDereferenceScb( pNpScb );
        }
        else
        {
            //
            // not timed out or is permanent SCB. dont disconnect.
            //
        }

        ScbQueueEntry = pNpScb->ScbLinks.Flink;
    }

    if ( IrpContext )
        NwFreeExtraIrpContext( IrpContext );

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    DebugTrace(-1, Dbg, "DisconnectTimedOutScbs -> VOID\n", 0 );
}

BOOLEAN
NwAllocateExtraIrpContext(
    OUT PIRP_CONTEXT *ppIrpContext,
    IN PNONPAGED_SCB pNpScb
    )
{
    PIRP Irp;
    BOOLEAN Success = TRUE;

    try {

        //
        //  Try to allocate an IRP
        //

        Irp = ALLOCATE_IRP(  pNpScb->Server.pDeviceObject->StackSize, FALSE );
        if ( Irp == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  Try to allocate an IRP Context.  This will
        //  raise an excpetion if it fails.
        //

        *ppIrpContext = AllocateIrpContext( Irp );
        Irp->Tail.Overlay.Thread = PsGetCurrentThread();

    } except( NwExceptionFilter( Irp, GetExceptionInformation() )) {
        Success = FALSE;
    }

    return( Success );
}

VOID
NwFreeExtraIrpContext(
    IN PIRP_CONTEXT pIrpContext
    )
{
    FREE_IRP( pIrpContext->pOriginalIrp );

    pIrpContext->pOriginalIrp = NULL; // Avoid FreeIrpContext modifying freed Irp.

    FreeIrpContext( pIrpContext );

    return;
}

VOID
CleanupSupplementalCredentials(
    LARGE_INTEGER Now,
    BOOLEAN       bShuttingDown
) {

    PLIST_ENTRY pLogonList;
    PLIST_ENTRY pCredList;
    PLOGON pLogon;
    PNDS_SECURITY_CONTEXT pCredential;
    LARGE_INTEGER KillTime;

    DebugTrace( 0, Dbg, "CleanupSupplementalCredentials...\n", 0 );

    //
    // Grab the RCB to protect the logon list.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

	pLogonList = LogonList.Flink;

    //
    // Walk the logon list.
    //

    while ( pLogonList != &LogonList ) {

        pLogon = CONTAINING_RECORD( pLogonList, LOGON, Next );

        //
        // Grab the credential resource to protect the credential list.
        // If we can't have exclusive access to the credential list,
        // don't wait for it or we may deadlock.
        //

        if ( ExAcquireResourceExclusiveLite( &((pLogon)->CredentialListResource), FALSE ) ) {

            pCredList = pLogon->NdsCredentialList.Flink;

            while ( pCredList != &(pLogon->NdsCredentialList) ) {
                BOOLEAN bRemove = FALSE;

                pCredential = CONTAINING_RECORD( pCredList, NDS_SECURITY_CONTEXT, Next );
                pCredList = pCredential->Next.Flink;

                if (bShuttingDown) {
                    bRemove = TRUE;
                }
                else {
                    if ( ( IsCredentialName( &(pCredential->NdsTreeName) ) ) &&
                         ( pCredential->SupplementalHandleCount == 0 ) ) {

                        //
                        // Calculate KillTime.
                        //

                        KillTime.QuadPart = Now.QuadPart - ( NwOneSecond * DORMANT_SCB_KEEP_TIME );

                        if ( pCredential->LastUsedTime.QuadPart < KillTime.QuadPart ) {
                            bRemove = TRUE;
                        }
                    }
                }

                /** If we are supposed to clean this guy up - do it **/

                if (bRemove) {
                    DebugTrace( 0, Dbg, "Removing credentials for %wZ\n", &pCredential->NdsTreeName );
                    RemoveEntryList( &pCredential->Next );
                    FreeNdsContext( pCredential );
                }
            }

            ExReleaseResourceLite( &((pLogon)->CredentialListResource) );
        }

        pLogonList = pLogon->Next.Flink;
    }

    NwReleaseRcb( &NwRcb );
    return;
}

VOID
CleanupObjectCache(
    VOID
    )
{
    NTSTATUS Status;
    KIRQL OldIrql;
    PLIST_ENTRY ScbEntry;
    PLIST_ENTRY CacheEntry;
    PNONPAGED_SCB NonpagedScb;
    PSCB Scb;
    PNDS_OBJECT_CACHE_ENTRY ObjectCache;
    LARGE_INTEGER CurrentTick;


    //
    //  Get the current tick count for checking timeouts.
    //

    KeQueryTickCount( &CurrentTick );

    //
    //  Walk the SCB queue.
    //

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    ScbEntry = ScbQueue.Flink;

    while( ScbEntry != &ScbQueue ) {

        NonpagedScb = CONTAINING_RECORD( ScbEntry, NONPAGED_SCB, ScbLinks );

        //
        //  Make sure this isn't the permanent SCB.
        //

        if( NonpagedScb != &NwPermanentNpScb ) {

            //
            //  Reference the SCB so it won't go away when we release the SCB lock.
            //

            NwReferenceScb( NonpagedScb );
            KeReleaseSpinLock( &ScbSpinLock, OldIrql );

            Scb = NonpagedScb->pScb;

            if( Scb->ObjectCacheBuffer != NULL ) {

                //
                //  Acquire the cache lock so that the cache can be messed with.
                //  This wait should never fail, but if it does, act as if there
                //  is no cache for this SCB.
                //

                Status = KeWaitForSingleObject( &(Scb->ObjectCacheLock),
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL );

                if( NT_SUCCESS(Status) ) {                

                    //
                    //  Walk the object cache and invalidate any timed-out entries.
                    //

                    CacheEntry = Scb->ObjectCacheList.Flink;

                    while( CacheEntry != &(Scb->ObjectCacheList) ) {

                        ObjectCache = CONTAINING_RECORD( CacheEntry, NDS_OBJECT_CACHE_ENTRY, Links );

                        //
                        //  If this entry has timed out, invalidate it.
                        //

                        if( ObjectCache->Scb != NULL && CurrentTick.QuadPart < ObjectCache->Timeout.QuadPart ) {

                            NwDereferenceScb( ObjectCache->Scb->pNpScb );
                            ObjectCache->Scb = NULL;
                        }

                        //
                        //  Move to the next entry.
                        //

                        CacheEntry = CacheEntry->Flink;
                    }

                    KeReleaseSemaphore( &(Scb->ObjectCacheLock),
                                        0,
                                        1,
                                        FALSE );
                }
            }

            //
            //  Reacquire the SCB lock and dereference the current SCB.
            //

            KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
            NwDereferenceScb( NonpagedScb );
        }

        ScbEntry = ScbEntry->Flink;
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\security.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Security.c

Abstract:

    This module implements security related tasks in the
    NetWare redirector.

Author:

    Colin Watson     [ColinW]    05-Nov-1993

Revision History:

--*/

#include "Procs.h"
#include <stdio.h>

PLOGON
FindUserByName(
    IN PUNICODE_STRING UserName
    );

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_SECURITY)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, CreateAnsiUid )
#pragma alloc_text( PAGE, MakeUidServer )
#pragma alloc_text( PAGE, FindUser )
#pragma alloc_text( PAGE, FindUserByName )
#pragma alloc_text( PAGE, GetUid )
#pragma alloc_text( PAGE, FreeLogon )
#pragma alloc_text( PAGE, Logon )
#pragma alloc_text( PAGE, Logoff )
#pragma alloc_text( PAGE, GetDriveMapTable )
#endif


VOID
CreateAnsiUid(
    OUT PCHAR aUid,
    IN PLARGE_INTEGER Uid
    )
/*++

Routine Description:

    This routine converts the Uid into an array of ansi characters,
    preserving the uniqueness and allocating the buffer in the process.

    Note: aUid needs to be 17 bytes long.

Arguments:

    OUT PCHAR aUid,
    IN PLARGE_INTEGER Uid

Return Value:

    Status

--*/
{
    PAGED_CODE();

    if (Uid->HighPart != 0) {
        sprintf( aUid, "%lx%08lx\\", Uid->HighPart, Uid->LowPart );
    } else {
        sprintf( aUid, "%lx\\", Uid->LowPart );
    }
    return;
}


NTSTATUS
MakeUidServer(
    PUNICODE_STRING UidServer,
    PLARGE_INTEGER Uid,
    PUNICODE_STRING Server
    )

/*++

Routine Description:

    This routine makes a Unicode string of the form 3e7\servername

Arguments:

    OUT PUNICODE_STRING UidServer,
    IN PLARGE_INTEGER Uid,
    IN PUNICODE_STRING Server

Return Value:

    Status

--*/
{
    //
    //  Translate the servername into the form 3e7\Server where 3e7
    //  is the value of the Uid.
    //
    UCHAR aUid[17];
    ANSI_STRING AnsiString;
    ULONG UnicodeLength;
    NTSTATUS Status;

    PAGED_CODE();

    CreateAnsiUid( aUid, Uid);

    RtlInitAnsiString( &AnsiString, aUid );

    UnicodeLength = RtlAnsiStringToUnicodeSize(&AnsiString);

    //
    // Ensuring we don't cause overflow, corrupting memory
    //
    
    if ( (UnicodeLength + (ULONG)Server->Length) > 0xFFFF ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    UidServer->MaximumLength = (USHORT)UnicodeLength + Server->Length;
    UidServer->Buffer = ALLOCATE_POOL(PagedPool,UidServer->MaximumLength);

    if (UidServer->Buffer == NULL) {
        DebugTrace(-1, Dbg, "MakeUidServer -> %08lx\n", STATUS_INSUFFICIENT_RESOURCES);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = RtlAnsiStringToUnicodeString( UidServer, &AnsiString, FALSE);
    ASSERT(NT_SUCCESS(Status) && "MakeUidServer failed!");

    Status = RtlAppendStringToString( (PSTRING)UidServer, (PSTRING)Server);
    ASSERT(NT_SUCCESS(Status) && "MakeUidServer part 2 failed!");
    return STATUS_SUCCESS;
}


PLOGON
FindUser(
    IN PLARGE_INTEGER Uid,
    IN BOOLEAN ExactMatch
    )

/*++

Routine Description:

    This routine searches the LogonList for the user entry corresponding
    to Uid.

    Note: Rcb must be held to prevent LogonList being changed.

Arguments:

    IN PLARGE_INTEGER Uid

    IN BOOLEAN ExactMatch - if TRUE, don't return a default

Return Value:

    None

--*/
{
    PLIST_ENTRY LogonQueueEntry = LogonList.Flink;
    PLOGON DefaultLogon = NULL;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FindUser...\n", 0);
    DebugTrace( 0, Dbg, " ->UserUidHigh = %08lx\n", Uid->HighPart);
    DebugTrace( 0, Dbg, " ->UserUidLow  = %08lx\n", Uid->LowPart);
    while ( LogonQueueEntry != &LogonList ) {

        PLOGON Logon = CONTAINING_RECORD( LogonQueueEntry, LOGON, Next );

        if ( (*Uid).QuadPart == Logon->UserUid.QuadPart ) {
            DebugTrace(-1, Dbg, "        ... %x\n", Logon );
            return Logon;
        }

        LogonQueueEntry = Logon->Next.Flink;
    }

    if (ExactMatch) {
        DebugTrace(-1, Dbg, "        ... DefaultLogon NULL\n", 0 );
        return NULL;
    }

    LogonQueueEntry = LogonList.Flink;
    while ( LogonQueueEntry != &LogonList ) {

        PLOGON Logon = CONTAINING_RECORD( LogonQueueEntry, LOGON, Next );

        if (Logon->UserUid.QuadPart == DefaultLuid.QuadPart) {

            //
            //  This is the first Default Logon entry. If this UID is not
            //  in the table then this is the one to use.
            //

            DebugTrace(-1, Dbg, "        ... DefaultLogon %lx\n", Logon );
            return Logon;
        }

        LogonQueueEntry = Logon->Next.Flink;
    }

    ASSERT( FALSE && "Couldn't find the Id" );

    DebugTrace(-1, Dbg, "        ... DefaultLogon NULL\n", 0 );
    return NULL;
}


PLOGON
FindUserByName(
    IN PUNICODE_STRING UserName
    )
/*++

Routine Description:

    This routine searches the LogonList for the user entry corresponding
    to Username.

    Note: Rcb must be held to prevent LogonList being changed.

Arguments:

    UserName - The user name to find.

Return Value:

    If found, a pointer to the logon structure
    NULL, if no match

--*/
{
    PLIST_ENTRY LogonQueueEntry = LogonList.Flink;
    PLOGON Logon;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FindUserByName...\n", 0);
    DebugTrace( 0, Dbg, " ->UserName = %wZ\n", UserName);

    while ( LogonQueueEntry != &LogonList ) {

        Logon = CONTAINING_RECORD( LogonQueueEntry, LOGON, Next );

        if ( RtlEqualUnicodeString( UserName, &Logon->UserName, TRUE ) ) {
            DebugTrace(-1, Dbg, "        ... %x\n", Logon );
            return Logon;
        }

        LogonQueueEntry = Logon->Next.Flink;
    }

    DebugTrace(-1, Dbg, "        ... NULL\n", 0 );
    return NULL;
}

PVCB *
GetDriveMapTable (
    IN LARGE_INTEGER Uid
    )
/*++

Routine Description:

    This routine searches the LogonList for the user entry corresponding
    to Uid and returns the drive map table.

    Note: Rcb must be held to prevent LogonList being changed.

Arguments:

    Uid - The user ID to find.

Return Value:

    Always returns a value, even if the default

--*/
{
    PLOGON Logon;

    PAGED_CODE();
    Logon = FindUser(&Uid, TRUE);

    if ( Logon != NULL )
       return Logon->DriveMapTable;
    else {
       DebugTrace(+1, Dbg, "Using Global Drive Map Table.\n", 0);
       return GlobalDriveMapTable;
    }

}

LARGE_INTEGER
GetUid(
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    )

/*++

Routine Description:

    This routine gets the effective UID to be used for this create.

Arguments:

    SubjectSecurityContext - Supplies the information from IrpSp.

Return Value:

    None

--*/
{
    LARGE_INTEGER LogonId;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "GetUid ... \n", 0);


    //  Is the thread currently impersonating someone else?

    if (SubjectSecurityContext->ClientToken != NULL) {

        //
        //  If its impersonating someone that is logged in locally then use
        //  the local id.
        //

        SeQueryAuthenticationIdToken(SubjectSecurityContext->ClientToken, (PLUID)&LogonId);

        if (FindUser(&LogonId, TRUE) == NULL) {

            //
            //  Not logged on locally, use the processes LogonId so that the
            //  gateway will work.
            //

            SeQueryAuthenticationIdToken(SubjectSecurityContext->PrimaryToken, (PLUID)&LogonId);
        }

    } else {

        //
        //  Use the processes LogonId
        //

        SeQueryAuthenticationIdToken(SubjectSecurityContext->PrimaryToken, (PLUID)&LogonId);
    }

    DebugTrace( 0, Dbg, " ->UserUidHigh = %08lx\n", LogonId.HighPart);
    DebugTrace(-1, Dbg, " ->UserUidLow  = %08lx\n", LogonId.LowPart);

    return LogonId;
}


VOID
FreeLogon(
    IN PLOGON Logon
    )

/*++

Routine Description:

    This routine free's all the strings inside Logon and the structure itself.

Arguments:

    IN PLOGON Logon

Return Value:

    None

--*/
{
    PLIST_ENTRY pListEntry;
    PNDS_SECURITY_CONTEXT pContext;

    PAGED_CODE();

    if ((Logon == NULL) ||
        (Logon == &Guest)) {
        return;
    }

    if ( Logon->UserName.Buffer != NULL ) {
        FREE_POOL( Logon->UserName.Buffer );
    }

    if ( Logon->PassWord.Buffer != NULL ) {
        FREE_POOL( Logon->PassWord.Buffer );
    }

    if ( Logon->ServerName.Buffer != NULL ) {
        FREE_POOL( Logon->ServerName.Buffer );
    }

    while ( !IsListEmpty(&Logon->NdsCredentialList) ) {

        pListEntry = RemoveHeadList( &Logon->NdsCredentialList );
        pContext = CONTAINING_RECORD(pListEntry, NDS_SECURITY_CONTEXT, Next );
        FreeNdsContext( pContext );

    }

    ExDeleteResourceLite( &Logon->CredentialListResource );
    FREE_POOL( Logon );
}


NTSTATUS
Logon(
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine takes the username and password supplied and makes
    them the default to be used for all connections.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOGON Logon = NULL;

    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PNWR_REQUEST_PACKET InputBuffer = Irp->AssociatedIrp.SystemBuffer;
    ULONGLONG InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    UNICODE_STRING ServerName;
    PNDS_SECURITY_CONTEXT pNdsContext;
    WCHAR FirstServerNameChar;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "Logon\n", 0);

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < sizeof(NWR_REQUEST_PACKET)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        if (InputBuffer->Version != REQUEST_PACKET_VERSION) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBufferLength <
                (ULONGLONG)(FIELD_OFFSET(NWR_REQUEST_PACKET,Parameters.Logon.UserName)) +
                (ULONGLONG)InputBuffer->Parameters.Logon.UserNameLength +
                (ULONGLONG)InputBuffer->Parameters.Logon.PasswordLength +
                (ULONGLONG)InputBuffer->Parameters.Logon.ServerNameLength +
                (ULONGLONG)InputBuffer->Parameters.Logon.ReplicaAddrLength) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if ((InputBuffer->Parameters.Logon.UserNameLength % 2) ||
            (InputBuffer->Parameters.Logon.PasswordLength % 2) ||
            (InputBuffer->Parameters.Logon.ServerNameLength % 2) ||
            (InputBuffer->Parameters.Logon.ReplicaAddrLength % 2)) {
            
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        Logon = ALLOCATE_POOL(NonPagedPool,sizeof(LOGON));
        if (Logon == NULL) {
            try_return( Status = STATUS_INSUFFICIENT_RESOURCES );
        }

        RtlZeroMemory(Logon, sizeof(LOGON));
        Logon->NodeTypeCode = NW_NTC_LOGON;
        Logon->NodeByteSize = sizeof(LOGON);
        InitializeListHead( &Logon->NdsCredentialList );
        ExInitializeResourceLite( &Logon->CredentialListResource );

        Status = SetUnicodeString(&Logon->UserName,
                    InputBuffer->Parameters.Logon.UserNameLength,
                    InputBuffer->Parameters.Logon.UserName);

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        Status = SetUnicodeString(&Logon->PassWord,
                    InputBuffer->Parameters.Logon.PasswordLength,
                    (PWCHAR)
                        ((PUCHAR)InputBuffer->Parameters.Logon.UserName +
                        InputBuffer->Parameters.Logon.UserNameLength));

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        ServerName.Buffer =
                    (PWCHAR)
                        ((PUCHAR)InputBuffer->Parameters.Logon.UserName +
                         InputBuffer->Parameters.Logon.UserNameLength +
                         InputBuffer->Parameters.Logon.PasswordLength);

        ServerName.Length =
                    (USHORT)InputBuffer->Parameters.Logon.ServerNameLength;

        ServerName.MaximumLength =
                    (USHORT)InputBuffer->Parameters.Logon.ServerNameLength;

        if ( ServerName.Length &&
             ServerName.Buffer[0] != L'*' ) {

            //
            // Only set this as the preferred server if it's not
            // a default tree.  Default tree requests start with a '*'.
            //

            Status = SetUnicodeString(&Logon->ServerName,
                        ServerName.Length,
                        ServerName.Buffer );

            if (!NT_SUCCESS(Status)) {
                try_return( Status );
            }
        }

        //
        //  Store the unique userid in both unicode and large integer form
        //  the unicode form is used as a prefix to the servername in all
        //  paths so that each userid gets their own connection to the server.
        //

        *((PLUID)(&Logon->UserUid)) = InputBuffer->Parameters.Logon.LogonId;

        Logon->NwPrintOptions = InputBuffer->Parameters.Logon.PrintOption;

        //  Save Uid for CreateScb

        *((PLUID)(&IrpContext->Specific.Create.UserUid)) =
                                        InputBuffer->Parameters.Logon.LogonId;

        if ( ServerName.Length) {
            FirstServerNameChar = ServerName.Buffer[0];
        }
        else {
            FirstServerNameChar = (WCHAR)0;
        }

try_exit:NOTHING;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();

    }

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    if (NT_SUCCESS(Status)) {

        DebugTrace( 0, Dbg, " ->UserName    = %wZ\n",  &Logon->UserName );
        DebugTrace( 0, Dbg, " ->PassWord    = %wZ\n",  &Logon->PassWord );

        if ( ServerName.Length && FirstServerNameChar == L'*' ) {
            DebugTrace( 0, Dbg, " ->DefaultTree = %wZ\n", &ServerName );
        } else {
            DebugTrace( 0, Dbg, " ->ServerName  = %wZ\n",  &Logon->ServerName );
        }

        DebugTrace( 0, Dbg, " ->UserUidHigh = %08lx\n", Logon->UserUid.HighPart);
        DebugTrace( 0, Dbg, " ->UserUidLow  = %08lx\n", Logon->UserUid.LowPart);

        InsertHeadList( &LogonList, &Logon->Next );
        NwReleaseRcb( &NwRcb );

        if ( ServerName.Length &&
             FirstServerNameChar != L'*' ) {

            PSCB Scb;

            //  See if we can login as this user.

            try {
                Status = CreateScb(
                            &Scb,
                            IrpContext,
                            &ServerName,
                            NULL,
                            NULL,
                            NULL,
                            FALSE,
                            FALSE );
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }

            if (NT_SUCCESS(Status)) {

                //
                //  CreateScb has already boosted the reference count
                //  because this is a preferred server so it will not go
                //  away. We need to dereference it here because there is
                //  no handle associated with the CreateScb
                //

                NwDereferenceScb(Scb->pNpScb);
            }
        }

        if ( ServerName.Length &&
             FirstServerNameChar == L'*' ) {

            PSCB Scb;
            BOOL SetContext;
            UINT ContextLength;
            UNICODE_STRING DefaultContext;
            IPXaddress *ReplicaAddr;

            //
            // Ok, this is a little confusing.  On Login, the provider can
            // specify the address of the replica that we should use to log
            // in.  If this is the case, then we do pre-connect that replica.
            // Otherwise, we do the standard login to any replica.  The
            // reason for this is that standard replica location uses the
            // bindery and doesn't always get us the nearest dir server.
            //

            try {
                if ( InputBuffer->Parameters.Logon.ReplicaAddrLength ==
                    sizeof( TDI_ADDRESS_IPX ) ) {

                    ReplicaAddr = (IPXaddress*)
                        ((PUCHAR) InputBuffer->Parameters.Logon.UserName +
                                InputBuffer->Parameters.Logon.UserNameLength +
                                InputBuffer->Parameters.Logon.PasswordLength +
                                InputBuffer->Parameters.Logon.ServerNameLength);

                    ReplicaAddr->Socket = NCP_SOCKET;

                    Status = CreateScb( 
                                    &Scb,
                                    IrpContext,
                                    NULL,        // anonymous create
                                    ReplicaAddr, // nearest replica add
                                    NULL,        // no user name
                                    NULL,        // no password
                                    TRUE,        // defer the login
                                    FALSE );     // we are not deleting the connection

                    if (NT_SUCCESS(Status)) {
    
                        //
                        //  CreateScb has already boosted the reference count
                        //  because this is a preferred server so it will not go
                        //  away. We need to dereference it here because there is
                        //  no handle associated with the CreateScb
                        //
    
                        NwDereferenceScb(Scb->pNpScb);
                    }
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }

            //
            // Set if this includes a default context.
            //

            try {
                ServerName.Buffer += 1;
                ServerName.Length -= sizeof( WCHAR );
                ServerName.MaximumLength -= sizeof( WCHAR );

                SetContext = FALSE;
                ContextLength = 0;

                while ( ContextLength < ServerName.Length / sizeof( WCHAR ) ) {

                    if ( ServerName.Buffer[ContextLength] == L'\\' ) {

                        SetContext = TRUE;

                        ContextLength++;

                        //
                        // Skip any leading periods.
                        //

                        if ( ServerName.Buffer[ContextLength] == L'.' ) {

                            DefaultContext.Buffer = &ServerName.Buffer[ContextLength + 1];
                            ServerName.Length -= sizeof ( WCHAR ) ;
                            ServerName.MaximumLength -= sizeof ( WCHAR );

                        } else {

                            DefaultContext.Buffer = &ServerName.Buffer[ContextLength];

                        }

                        ContextLength *= sizeof( WCHAR );
                        DefaultContext.Length = ServerName.Length - ContextLength;
                        DefaultContext.MaximumLength = ServerName.MaximumLength - ContextLength;

                        ServerName.Length -= ( DefaultContext.Length + sizeof( WCHAR ) );
                        ServerName.MaximumLength -= ( DefaultContext.Length + sizeof( WCHAR ) );

                    }

                    ContextLength++;
                }

                //
                // Verify that this context is valid before we acquire
                // the credentials and really set the context.
                //

                if ( SetContext ) {
    
                    Status = NdsVerifyContext( IrpContext, &ServerName, &DefaultContext );

                    if ( !NT_SUCCESS( Status )) {
                        SetContext = FALSE;
                    }
                }

            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
                SetContext = FALSE;
            }

            //
            // Generate the credential shell for the default tree and
            // set the context if appropriate.
            //

            try {
                Status = NdsLookupCredentials(  
                                        IrpContext,
                                        &ServerName,
                                        Logon,
                                        &pNdsContext,
                                        CREDENTIAL_WRITE,
                                        TRUE );
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }

            if ( NT_SUCCESS( Status ) ) {

                //
                // Set the context.  It doesn't matter if the
                // credential is locked or not.
                //

                if ( SetContext ) {

                    RtlCopyUnicodeString( &pNdsContext->CurrentContext,
                                          &DefaultContext );
                    DebugTrace( 0, Dbg, "Default Context: %wZ\n", &DefaultContext );
                }

                NwReleaseCredList( Logon, IrpContext );

                //
                // RELAX! The credential list is free.
                //

                DebugTrace( 0, Dbg, "Default Tree: %wZ\n", &ServerName );

                Status = NdsCreateTreeScb( IrpContext,
                                           &Scb,
                                           &ServerName,
                                           NULL,
                                           NULL,
                                           FALSE,
                                           FALSE );

                if (NT_SUCCESS(Status)) {
                    NwDereferenceScb(Scb->pNpScb);
                }
            }
        }

        //
        // No login requested.
        //

    } else {

        FreeLogon( Logon );
        NwReleaseRcb( &NwRcb );

    }


    DebugTrace(-1, Dbg, "Logon %lx\n", Status);
    return Status;
}


NTSTATUS
Logoff(
    IN PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine sets the username back to guest and removes the password.

Arguments:

    IN PIRP_CONTEXT IrpContext - Io Request Packet for request

Return Value:

NTSTATUS

--*/

{
    BOOLEAN Locked = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    PIRP Irp = IrpContext->pOriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PNWR_REQUEST_PACKET InputBuffer = Irp->AssociatedIrp.SystemBuffer;
    ULONG InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    LARGE_INTEGER User;
    PLOGON Logon;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "Logoff...\n", 0);

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < sizeof(NWR_REQUEST_PACKET)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        if (InputBuffer->Version != REQUEST_PACKET_VERSION) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        try {
            *((PLUID)(&User)) = InputBuffer->Parameters.Logoff.LogonId;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            try_return(Status = GetExceptionCode());
        }

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        Locked = TRUE;

        Logon = FindUser(&User, TRUE);

        if ( Logon != NULL ) {

            LARGE_INTEGER Uid = Logon->UserUid;

            //
            // We have found the right user.
            //

            ASSERT( Logon != &Guest);

            NwReleaseRcb( &NwRcb );
            Locked = FALSE;

            DebugTrace( 0, Dbg, " ->UserName    = %wZ\n",  &Logon->UserName );
            DebugTrace( 0, Dbg, " ->ServerName  = %wZ\n",  &Logon->ServerName );
            DebugTrace( 0, Dbg, " ->UserUidHigh = %08lx\n", Logon->UserUid.HighPart);
            DebugTrace( 0, Dbg, " ->UserUidLow  = %08lx\n", Logon->UserUid.LowPart);


            //
            // Invalidating all the handles for this user will also cause logoffs
            // to all the servers in question.
            //

            NwInvalidateAllHandles(&Uid, IrpContext);

            NwAcquireExclusiveRcb( &NwRcb, TRUE );
            Locked = TRUE;

            Logon = FindUser(&User, TRUE);

            if (Logon != NULL) {
                RemoveEntryList( &Logon->Next );
                FreeLogon( Logon );
            } else {
                ASSERT( FALSE && "Double logoff!");
            }

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_UNSUCCESSFUL;
        }

try_exit:NOTHING;
    } finally {
        if (Locked == TRUE ) {
            NwReleaseRcb( &NwRcb );
        }
    }

    DebugTrace(-1, Dbg, "Logoff %lx\n", Status);

    return Status;
}

NTSTATUS
UpdateUsersPassword(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    OUT PLARGE_INTEGER Uid
    )
/*++

Routine Description:

    This routine updates the cached password for a given user.
    If the named user is not logged in, an error is returned.

Arguments:

    UserName - Supplies the name of the user

    Password - Supplies the new password

    Uid - Returns the LUID of the updated user.

Return Value:

    NTSTATUS

--*/
{
    PLOGON Logon;
    NTSTATUS Status;

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    Logon = FindUserByName( UserName );

    if ( Logon != NULL ) {

        if ( Logon->PassWord.Buffer != NULL ) {
            FREE_POOL( Logon->PassWord.Buffer );
        }

        Status = SetUnicodeString(
                     &Logon->PassWord,
                     Password->Length,
                     Password->Buffer );

        *Uid = Logon->UserUid;

    } else {

        Status = STATUS_UNSUCCESSFUL;
    }

    NwReleaseRcb( &NwRcb );
    return( Status );

}

NTSTATUS
UpdateServerPassword(
    PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN PLARGE_INTEGER Uid
    )
/*++

Routine Description:

    This routine updates the cached password for a named server connection.
    If the server does not exist in the server table, an error is returned.

Arguments:

    ServerName - Supplies the name of the server

    UserName - Supplies the name of the user

    Password - Supplies the new password

    Uid - The LUID of the user.

Return Value:

    NTSTATUS

--*/
{
    UNICODE_STRING UidServer;
    NTSTATUS Status;
    PUNICODE_PREFIX_TABLE_ENTRY PrefixEntry;
    PSCB pScb;
    PNONPAGED_SCB pNpScb;
    PVOID Buffer;

    Status = MakeUidServer(
                 &UidServer,
                 Uid,
                 ServerName );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    DebugTrace( 0, Dbg, " ->UidServer              = %wZ\n", &UidServer   );

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    PrefixEntry = RtlFindUnicodePrefix( &NwRcb.ServerNameTable, &UidServer, 0 );

    if ( PrefixEntry != NULL ) {

        pScb = CONTAINING_RECORD( PrefixEntry, SCB, PrefixEntry );
        pNpScb = pScb->pNpScb;

        NwReferenceScb( pNpScb );

        //
        //  Release the RCB.
        //

        NwReleaseRcb( &NwRcb );

    } else {

        NwReleaseRcb( &NwRcb );
        FREE_POOL(UidServer.Buffer);
        return( STATUS_BAD_NETWORK_PATH );
    }

    IrpContext->pNpScb = pNpScb;
    NwAppendToQueueAndWait( IrpContext );

    //
    //  Free the old username password, allocate a new one.
    //

    if (  pScb->UserName.Buffer != NULL ) {
        FREE_POOL( pScb->UserName.Buffer );
    }

    Buffer = ALLOCATE_POOL_EX( NonPagedPool, UserName->Length + Password->Length );

    pScb->UserName.Buffer = Buffer;
    pScb->UserName.Length = pScb->UserName.MaximumLength = UserName->Length;
    RtlMoveMemory( pScb->UserName.Buffer, UserName->Buffer, UserName->Length );

    pScb->Password.Buffer = (PWCHAR)((PCHAR)Buffer + UserName->Length);
    pScb->Password.Length = pScb->Password.MaximumLength = Password->Length;
    RtlMoveMemory( pScb->Password.Buffer, Password->Buffer, Password->Length );

    FREE_POOL(UidServer.Buffer);

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\string.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    string.c

Abstract:

    This module implements the string routines needed for the NT redirector

Author:

    Colin Watson (ColinW) 02-Apr-1993

Revision History:

    14-Jun-1990 LarryO

        Created for Lanman Redirector

    02-Apr-1993 ColinW

        Modified for NwRdr

--*/

#include "Procs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DuplicateStringWithString )
#pragma alloc_text( PAGE, DuplicateUnicodeStringWithString )
#pragma alloc_text( PAGE, SetUnicodeString )
#pragma alloc_text( PAGE, MergeStrings )
#endif


NTSTATUS
DuplicateStringWithString (
    OUT PSTRING DestinationString,
    IN PSTRING SourceString,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This routine duplicates a supplied input string, storing the result
    of the duplication in the supplied string. The maximumlength of the
    new string is determined by the length of the SourceString.


Arguments:

    OUT PSTRING DestinationString - Returns the filled in string.
    IN PSTRING SourceString - Supplies the string to duplicate
    IN POOLTYPE PoolType - Supplies the type of pool (PagedPool or
    NonPagedPool)
Return Value:

    NTSTATUS - Status of resulting operation
                If !NT_SUCCESS then DestinationString->Buffer == NULL
--*/

{
    PAGED_CODE();

    DestinationString->Buffer = NULL;

    try {

        if (SourceString->Length != 0) {
            //
            // Allocate pool to hold the buffer (contents of the string)
            //

            DestinationString->Buffer = (PSZ )ALLOCATE_POOL(PoolType,
                                                SourceString->Length);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

    return GetExceptionCode();

    }

    if (DestinationString->Buffer == NULL && SourceString->Length != 0) {

        //
        //  The allocation failed, return failure.
        //

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    DestinationString->MaximumLength = SourceString->Length;

    //
    //  Copy the source string into the newly allocated
    //  destination string
    //

    RtlCopyString(DestinationString, SourceString);

    return STATUS_SUCCESS;

}


NTSTATUS
DuplicateUnicodeStringWithString (
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This routine duplicates a supplied input string, storing the result
    of the duplication in the supplied string. The maximumlength of the
    new string is determined by the length of the SourceString.


Arguments:

    OUT PSTRING DestinationString - Returns the filled in string.
    IN PSTRING SourceString - Supplies the string to duplicate
    IN POOLTYPE PoolType - Supplies the type of pool (PagedPool or
    NonPagedPool)
Return Value:

    NTSTATUS - Status of resulting operation
                If !NT_SUCCESS then DestinationString->Buffer == NULL

--*/

{
    PAGED_CODE();

    DestinationString->Buffer = NULL;

    try {

        if (SourceString->Length != 0) {
            //
            // Allocate pool to hold the buffer (contents of the string)
            //

            DestinationString->Buffer = (WCHAR *)ALLOCATE_POOL(PoolType,
                                                    SourceString->Length);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();

    }

    if (DestinationString->Buffer == NULL && SourceString->Length != 0) {

        //
        //  The allocation failed, return failure.
        //

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    DestinationString->MaximumLength = SourceString->Length;

    //
    //  Copy the source string into the newly allocated
    //  destination string
    //

    RtlCopyUnicodeString(DestinationString, SourceString);

    return STATUS_SUCCESS;

}

#if 0

VOID
CopyUnicodeStringToUnicode (
    OUT PVOID *Destination,
    IN PUNICODE_STRING Source,
    IN BOOLEAN AdjustPointer
    )

/*++

Routine Description:
    This routine copies the specified source string onto the destination
    asciiz string.

Arguments:

    OUT PUCHAR Destination, - Supplies a pointer to the destination
                 buffer for the string.
    IN PSTRING String - Supplies the source string.
    IN BOOLEAN AdjustPointer - If TRUE, increment destination pointer

Return Value:

    None.

--*/

{
    PAGED_CODE();

    RtlCopyMemory((*Destination), (Source)->Buffer, (Source)->Length);
    if (AdjustPointer) {
        ((PCHAR)(*Destination)) += ((Source)->Length);
    }
}


NTSTATUS
CopyUnicodeStringToAscii (
    OUT PUCHAR *Destination,
    IN PUNICODE_STRING Source,
    IN BOOLEAN AdjustPointer,
    IN USHORT MaxLength
    )
/*++

Routine Description:

    This routine copies the specified source string onto the destination
    asciiz string.

Arguments:

    OUT PUCHAR Destination, - Supplies the destination asciiz string.
    IN PUNICODE_STRING String - Supplies the source string.
    IN BOOLEAN AdjustPointer - If TRUE, increment destination pointer

Return Value:

    Status of conversion.
--*/
{
    ANSI_STRING DestinationString;

    NTSTATUS Status;

    PAGED_CODE();

    DestinationString.Buffer = (*Destination);

    DestinationString.MaximumLength = (USHORT)(MaxLength);

    Status = RtlUnicodeStringToOemString(&DestinationString, (Source), FALSE);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (AdjustPointer) {
        (*Destination) += DestinationString.Length;
    }

    return STATUS_SUCCESS;

}
#endif


NTSTATUS
SetUnicodeString (
    IN PUNICODE_STRING Destination,
    IN ULONG Length,
    IN PWCHAR Source
    )
/*++

Routine Description:

    This routine copies the specified source string onto the destination
    UNICODE string allocating the buffer.

Arguments:


Return Value:

    Status of conversion.
--*/
{
    UNICODE_STRING Temp;

    PAGED_CODE();

    Destination->Buffer = NULL;
    Destination->Length = 0;
    Destination->MaximumLength = 0;

    if (Length == 0) {
        return STATUS_SUCCESS;
    }

    Temp.MaximumLength =
    Temp.Length = (USHORT )Length;
    Temp.Buffer = Source;

    Destination->Buffer =
        ALLOCATE_POOL(NonPagedPool,
            Temp.MaximumLength+sizeof(WCHAR));

    if (Destination->Buffer == NULL) {
        Error(EVENT_NWRDR_RESOURCE_SHORTAGE, STATUS_INSUFFICIENT_RESOURCES, NULL, 0, 0);
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    Destination->MaximumLength = (USHORT)Length;

    RtlCopyUnicodeString(Destination, &Temp);

    Destination->Buffer[(Destination->Length/sizeof(WCHAR))] = UNICODE_NULL;

    return STATUS_SUCCESS;

}


VOID
MergeStrings(
    IN PUNICODE_STRING Destination,
    IN PUNICODE_STRING S1,
    IN PUNICODE_STRING S2,
    IN ULONG Type
    )
/*++

Routine Description:

    This routine Allocates space for Destination.Buffer and copies S1 followed
    by S2 into the buffer.

    Raises status if couldn't allocate buffer

Arguments:

    IN PUNICODE_STRING Destination,
    IN PUNICODE_STRING S1,
    IN PUNICODE_STRING S2,
    IN ULONG Type - PagedPool or NonPagedPool

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Ensuring we don't cause overflow, corrupting memory
    //

    if ( ((ULONG)S1->Length + (ULONG)S2->Length) > 0xFFFF ) {
        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }
    
    Destination->MaximumLength = S1->Length + S2->Length;
    Destination->Length = S1->Length + S2->Length;

    Destination->Buffer = ALLOCATE_POOL_EX( Type, Destination->MaximumLength );

    RtlCopyMemory( Destination->Buffer,
                    S1->Buffer,
                    S1->Length);

    RtlCopyMemory( (PUCHAR)Destination->Buffer + S1->Length,
                    S2->Buffer,
                    S2->Length);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\read.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements support for NtReadFile for the
    NetWare redirector called by the dispatch driver.

Author:

    Colin Watson     [ColinW]    07-Apr-1993

Revision History:

--*/

#include "Procs.h"
#ifdef NWDBG
#include <stdlib.h>    // rand()
#endif

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

#define SIZE_ADJUST( ic ) \
    ( sizeof( ULONG ) + sizeof( ULONG ) + ( ic->Specific.Read.FileOffset & 0x03 ) )

//
//  Local procedure prototypes
//

NTSTATUS
NwCommonRead (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
ReadNcp(
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
ReadNcpCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    );

VOID
BuildReadNcp(
    PIRP_CONTEXT IrpContext,
    ULONG FileOffset,
    USHORT Length
    );

NTSTATUS
ParseReadResponse(
    PIRP_CONTEXT IrpContext,
    PNCP_READ_RESPONSE Response,
    ULONG BytesAvailable,
    PUSHORT Length
    );

NTSTATUS
BurstRead(
    PIRP_CONTEXT IrpContext
    );

VOID
BuildBurstReadRequest(
    IN PIRP_CONTEXT IrpContext,
    IN ULONG Handle,
    IN ULONG FileOffset,
    IN ULONG Length
    );

NTSTATUS
BurstReadCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    );

VOID
RecordPacketReceipt(
    IN OUT PIRP_CONTEXT IrpContext,
    IN PVOID ReadData,
    IN ULONG DataOffset,
    IN USHORT BytesCount,
    IN BOOLEAN CopyData
    );

BOOLEAN
VerifyBurstRead(
    PIRP_CONTEXT IrpContext
    );

VOID
FreePacketList(
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
BurstReadReceive(
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PULONG BytesAccepted,
    IN PUCHAR Response,
    OUT PMDL *pReceiveMdl
    );

NTSTATUS
ReadNcpReceive(
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PULONG BytesAccepted,
    IN PUCHAR Response,
    OUT PMDL *pReceiveMdl
    );

NTSTATUS
ParseBurstReadResponse(
    IN PIRP_CONTEXT IrpContext,
    PVOID Response,
    ULONG BytesAvailable,
    PUCHAR Flags,
    PULONG DataOffset,
    PUSHORT BytesThisPacket,
    PUCHAR *ReadData,
    PULONG TotalBytesRead
    );

PMDL
AllocateReceivePartialMdl(
    PMDL FullMdl,
    ULONG DataOffset,
    ULONG BytesThisPacket
    );

VOID
SetConnectionTimeout(
    PNONPAGED_SCB pNpScb,
    ULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdRead )
#pragma alloc_text( PAGE, NwCommonRead )
#pragma alloc_text( PAGE, ReadNcp )
#pragma alloc_text( PAGE, BurstRead )
#pragma alloc_text( PAGE, BuildBurstReadRequest )
#pragma alloc_text( PAGE, ResubmitBurstRead )
#pragma alloc_text( PAGE, SetConnectionTimeout )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, ReadNcpCallback )
#pragma alloc_text( PAGE1, ReadNcpReceive )
#pragma alloc_text( PAGE1, BuildReadNcp )
#pragma alloc_text( PAGE1, ParseReadResponse )
#pragma alloc_text( PAGE1, BurstReadCallback )
#pragma alloc_text( PAGE1, BurstReadTimeout )
#pragma alloc_text( PAGE1, RecordPacketReceipt )
#pragma alloc_text( PAGE1, VerifyBurstRead )
#pragma alloc_text( PAGE1, FreePacketList )
#pragma alloc_text( PAGE1, BurstReadReceive )
#pragma alloc_text( PAGE1, ParseBurstReadResponse )
#pragma alloc_text( PAGE1, AllocateReceivePartialMdl )
#endif

#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif


NTSTATUS
NwFsdRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the FSD routine that handles NtReadFile.

Arguments:

    NwfsDeviceObject - Supplies the device object for the read function.

    Irp - Supplies the IRP to process.

Return Value:

    NTSTATUS - The result status.

--*/

{
    PIRP_CONTEXT pIrpContext = NULL;
    NTSTATUS status;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdRead\n", 0);

    //
    // Call the common direcotry control routine.
    //

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        pIrpContext = AllocateIrpContext( Irp );
        status = NwCommonRead( pIrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( pIrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error Status that we get back from the
            //  execption code
            //

            status = NwProcessException( pIrpContext, GetExceptionCode() );
        }

    }

    if ( pIrpContext ) {

        if ( status != STATUS_PENDING ) {
            NwDequeueIrpContext( pIrpContext, FALSE );
        }

        NwCompleteRequest( pIrpContext, status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "NwFsdRead -> %08lx\n", status );

    Stats.ReadOperations++;

    return status;
}


NTSTATUS
NwCommonRead (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine does the common code for NtReadFile.

Arguments:

    IrpContext - Supplies the request being processed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS status;

    PIRP Irp;
    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PICB icb;
    PFCB fcb;
    PVOID fsContext;

    ULONG BufferLength;         //  Size application requested to read
    ULONG ByteOffset;
    ULONG PreviousByteOffset;
    ULONG BytesRead;
    ULONG NewBufferLength = 0;
    PVOID SystemBuffer;

    //
    //  Get the current stack location
    //

    Irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "CommonRead...\n", 0);
    DebugTrace( 0, Dbg, "Irp  = %08lx\n", (ULONG_PTR)Irp);
    DebugTrace( 0, Dbg, "IrpSp  = %08lx\n", (ULONG_PTR)irpSp);
    DebugTrace( 0, Dbg, "Irp->OriginalFileObject  = %08lx\n", (ULONG_PTR)(Irp->Tail.Overlay.OriginalFileObject));

    //
    // Decode the file object to figure out who we are.  If the result
    // is not the root DCB then its an illegal parameter.
    //

    nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                       &fsContext,
                                       (PVOID *)&icb );

    fcb = (PFCB)icb->SuperType.Fcb;

    if (((nodeTypeCode != NW_NTC_ICB) &&
         (nodeTypeCode != NW_NTC_ICB_SCB)) ||
        (!icb->HasRemoteHandle) ) {

        DebugTrace(0, Dbg, "Not a file\n", 0);

        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonRead -> %08lx\n", status );
        return status;
    }

    //
    //  Make sure that this ICB is still active.
    //

    NwVerifyIcbSpecial( icb );

    if ( fcb->NodeTypeCode == NW_NTC_FCB ) {

        IrpContext->pScb = fcb->Scb;
        IrpContext->pNpScb = IrpContext->pScb->pNpScb;
        IrpContext->Icb = icb;

    } else if ( fcb->NodeTypeCode == NW_NTC_SCB ) {

        IrpContext->pScb = icb->SuperType.Scb;
        IrpContext->pNpScb = IrpContext->pScb->pNpScb;
        IrpContext->Icb = icb;
        fcb = NULL;

    } else {

        DebugTrace(0, Dbg, "Not a file\n", 0);

        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonRead -> %08lx\n", status );
        return status;
    }

    BufferLength = irpSp->Parameters.Read.Length;
    ByteOffset = irpSp->Parameters.Read.ByteOffset.LowPart;

    //
    //  Fail reads beyond file offset 4GB.
    //

    if ( irpSp->Parameters.Read.ByteOffset.HighPart != 0 ) {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    //  Special case 0 length read.
    //

    if ( BufferLength == 0 ) {
        Irp->IoStatus.Information = 0;
        return( STATUS_SUCCESS );
    }

    if (FlagOn(irpSp->FileObject->Flags, FO_SYNCHRONOUS_IO) &&
        !FlagOn( Irp->Flags, IRP_PAGING_IO)) {

        PreviousByteOffset = irpSp->FileObject->CurrentByteOffset.LowPart;
        irpSp->FileObject->CurrentByteOffset.LowPart = ByteOffset;
    }

    //
    //  First flush the write behind cache unless this is a
    //  file stream operation.
    //

    if ( fcb ) {

        status = AcquireFcbAndFlushCache( IrpContext, fcb->NonPagedFcb );
        if ( !NT_SUCCESS( status ) ) {
            goto ResetByteOffsetAndExit;
        }

        //
        //  Read as much as we can from cache.
        //

        NwMapUserBuffer( Irp, KernelMode, &SystemBuffer );

        //
        // tommye
        //
        // NwMapUserBuffer may return a NULL SystemBuffer in low resource
        // situations; this was not being checked.  
        //

        if (SystemBuffer == NULL) {
            DebugTrace(-1, Dbg, "NwMapUserBuffer returned NULL OutputBuffer", 0);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ResetByteOffsetAndExit;
        }

        BytesRead = CacheRead(
                        fcb->NonPagedFcb,
                        ByteOffset,
                        BufferLength,
#if NWFASTIO
                        SystemBuffer,
                        FALSE );
#else
                        SystemBuffer );
#endif

        //
        //  If all the data was the the cache, we are done.
        //

        if ( BytesRead == BufferLength ) {

            Irp->IoStatus.Information = BytesRead;

            //
            //  Update the current byte offset in the file if it is a
            //  synchronous file (and this is not paging I/O).
            //

            if (FlagOn(irpSp->FileObject->Flags, FO_SYNCHRONOUS_IO) &&
                !FlagOn( Irp->Flags, IRP_PAGING_IO)) {

                irpSp->FileObject->CurrentByteOffset.QuadPart += BytesRead;
            }

            //
            // If this is a paging read, we need to flush the MDL
            // since on some systems the I-cache and D-cache
            // are not synchronized.
            //

            if (FlagOn(Irp->Flags, IRP_PAGING_IO)) {
                KeFlushIoBuffers( Irp->MdlAddress, TRUE, FALSE);
            }

            //
            //  Record read offset and size to discover a sequential read pattern.
            //

            fcb->LastReadOffset = irpSp->Parameters.Read.ByteOffset.LowPart;
            fcb->LastReadSize = irpSp->Parameters.Read.Length;

            DebugTrace(-1, Dbg, "CommonRead -> %08lx\n", STATUS_SUCCESS );
            return( STATUS_SUCCESS );
        }

        NwAppendToQueueAndWait( IrpContext );

        //  Protect read cache
        NwAcquireExclusiveFcb( fcb->NonPagedFcb, TRUE );

        IrpContext->Specific.Read.CacheReadSize = BytesRead;
        fcb->NonPagedFcb->CacheFileOffset = ByteOffset + BufferLength;

        ByteOffset += BytesRead;
        BufferLength -= BytesRead;

        NewBufferLength = CalculateReadAheadSize(
                              IrpContext,
                              fcb->NonPagedFcb,
                              BytesRead,
                              ByteOffset,
                              BufferLength );

        IrpContext->Specific.Read.ReadAheadSize = NewBufferLength - BufferLength;

    } else {

        //
        // This is a read from a ds file stream handle.  For now,
        // there's no cache support.
        //

        NwAppendToQueueAndWait( IrpContext );

        BytesRead = 0;

        IrpContext->Specific.Read.CacheReadSize = BytesRead;
        IrpContext->Specific.Read.ReadAheadSize = 0;
    }

    //
    //  If burst mode is enabled, and this read is too big to do in a single
    //  core read NCP, use burst mode.
    //
    //  We don't support burst against a ds file stream yet.
    //

    if ( IrpContext->pNpScb->ReceiveBurstModeEnabled &&
         NewBufferLength > IrpContext->pNpScb->BufferSize &&
         fcb ) {
        status = BurstRead( IrpContext );
    } else {
        status = ReadNcp( IrpContext );
    }

    Irp->MdlAddress = IrpContext->pOriginalMdlAddress;

    if (Irp->MdlAddress != NULL) {
        //  Next might point to the cache mdl.
        Irp->MdlAddress->Next = NULL;
    }

    if ( NT_SUCCESS( status ) ) {

        //
        //  Update the current byte offset in the file if it is a
        //  synchronous file (and this is not paging I/O).
        //

        if (FlagOn(irpSp->FileObject->Flags, FO_SYNCHRONOUS_IO) &&
            !FlagOn( Irp->Flags, IRP_PAGING_IO)) {

            irpSp->FileObject->CurrentByteOffset.QuadPart += Irp->IoStatus.Information;
        }

        //
        // If this is a paging read, we need to flush the MDL
        // since on some systems the I-cache and D-cache
        // are not synchronized.
        //

        if (FlagOn(Irp->Flags, IRP_PAGING_IO)) {
            KeFlushIoBuffers( Irp->MdlAddress, TRUE, FALSE);
        }

        //
        //  If we received 0 bytes without an error, we must be beyond
        //  the end of file.
        //

        if ( Irp->IoStatus.Information == 0 ) {
            status = STATUS_END_OF_FILE;
        }
    }

    //
    //  Record read offset and size to discover a sequential read pattern.
    //

    if ( fcb ) {

        fcb->LastReadOffset = irpSp->Parameters.Read.ByteOffset.LowPart;
        fcb->LastReadSize = irpSp->Parameters.Read.Length;

        NwReleaseFcb( fcb->NonPagedFcb );

    }

    DebugTrace(-1, Dbg, "CommonRead -> %08lx\n", status);

ResetByteOffsetAndExit:

    //
    // I have seen a case where the Fileobject is nonexistant after errors.
    //

    if ( !NT_SUCCESS( status ) ) {

        if (!(irpSp->FileObject)) {

            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "Fileobject has disappeared\n", 0);
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "Irp  = %08lx\n", (ULONG_PTR)Irp);
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "IrpSp  = %08lx\n", (ULONG_PTR)irpSp);
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "Irp->OriginalFileObject  = %08lx\n", (ULONG_PTR)Irp->Tail.Overlay.OriginalFileObject);
            DbgBreakPoint();
        }

        if (FlagOn(irpSp->FileObject->Flags, FO_SYNCHRONOUS_IO) &&
            !FlagOn( Irp->Flags, IRP_PAGING_IO)) {

            irpSp->FileObject->CurrentByteOffset.LowPart = PreviousByteOffset;

        }
    }

    return status;
}

NTSTATUS
ReadNcp(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine exchanges a series of read NCPs with the server.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

    Icb - Supplies the file specific information.

Return Value:

    Status of transfer.

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG Length;               //  Size we will send to the server
    PMDL DataMdl;

    PSCB pScb;
    PNONPAGED_SCB pNpScb;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PICB Icb;
    ULONG ByteOffset;
    ULONG BufferLength;
    ULONG MdlLength;
    BOOLEAN Done;
    PMDL Mdl, NextMdl;

    irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );
    Icb = IrpContext->Icb;

    BufferLength = irpSp->Parameters.Read.Length +
                   IrpContext->Specific.Read.ReadAheadSize -
                   IrpContext->Specific.Read.CacheReadSize;

    ByteOffset = irpSp->Parameters.Read.ByteOffset.LowPart +
                 IrpContext->Specific.Read.CacheReadSize;

    IrpContext->Specific.Read.FileOffset = ByteOffset;

    DebugTrace(+1, Dbg, "ReadNcp...\n", 0);
    DebugTrace( 0, Dbg, "irp     = %08lx\n", (ULONG_PTR)irp);
    DebugTrace( 0, Dbg, "File    = %wZ\n", &Icb->SuperType.Fcb->FullFileName);
    DebugTrace( 0, Dbg, "Length  = %ld\n", BufferLength);
    DebugTrace( 0, Dbg, "Offset = %d\n", ByteOffset);

    if ( Icb->SuperType.Fcb->NodeTypeCode == NW_NTC_FCB ) {

        pScb = Icb->SuperType.Fcb->Scb;

    } else if ( Icb->SuperType.Fcb->NodeTypeCode == NW_NTC_SCB ) {

        pScb = Icb->SuperType.Scb;

    }

    ASSERT( pScb );

    //
    //  Update the original MDL record in the Irp context so that we
    //  can restore it on i/o completion.
    //

    IrpContext->pOriginalMdlAddress = irp->MdlAddress;

    Length = MIN( IrpContext->pNpScb->BufferSize, BufferLength );

    //
    //  The old servers will not accept reads that cross 4k boundaries in the file
    //

    if ((IrpContext->pNpScb->PageAlign) &&
        (DIFFERENT_PAGES( ByteOffset, Length ))) {

        Length = 4096 - ((ULONG)ByteOffset & (4096-1));

    }

    IrpContext->Specific.Read.Buffer = irp->UserBuffer;
    IrpContext->Specific.Read.ReadOffset = IrpContext->Specific.Read.CacheReadSize;
    IrpContext->Specific.Read.RemainingLength = BufferLength;
    IrpContext->Specific.Read.PartialMdl = NULL;

    //
    //  Set up to process a read NCP
    //

    pNpScb = pScb->pNpScb;
    IrpContext->pEx = ReadNcpCallback;
    IrpContext->Destination = pNpScb->RemoteAddress;
    IrpContext->PacketType = NCP_FUNCTION;
    IrpContext->ReceiveDataRoutine = ReadNcpReceive;

    pNpScb->MaxTimeOut = 2 * pNpScb->TickCount + 10;
    pNpScb->TimeOut = pNpScb->SendTimeout;
    pNpScb->RetryCount = DefaultRetryCount;

    Done = FALSE;

    while ( !Done ) {

        //
        //  Setup to do at most 64K of i/o asynchronously, or buffer length.
        //

        IrpContext->Specific.Read.BurstSize =
            MIN( 64 * 1024, IrpContext->Specific.Read.RemainingLength );

        IrpContext->Specific.Read.BurstRequestOffset = 0;

        //
        //  Try to allocate an MDL for this i/o.
        //

        if ( IrpContext->Specific.Read.ReadAheadSize == 0 ) {
            MdlLength = IrpContext->Specific.Read.BurstSize;
        } else {
            MdlLength = IrpContext->Specific.Read.BurstSize - IrpContext->Specific.Read.ReadAheadSize;
        }

        DataMdl = ALLOCATE_MDL(
                      (PCHAR)IrpContext->Specific.Read.Buffer +
                           IrpContext->Specific.Read.ReadOffset,
                      MdlLength,
                      FALSE, // Secondary Buffer
                      FALSE, // Charge Quota
                      NULL);

        if ( DataMdl == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IrpContext->Specific.Read.FullMdl = DataMdl;

        //
        //  If there is no MDL for this read, probe the data MDL to
        //  lock it's pages down.   Otherwise, use the data MDL as
        //  a partial MDL.
        //

        if ( IrpContext->pOriginalMdlAddress == NULL ) {

            try {
                MmProbeAndLockPages( DataMdl, irp->RequestorMode, IoWriteAccess);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                FREE_MDL( DataMdl );
                return GetExceptionCode();
            }

        } else {

            IoBuildPartialMdl(
                IrpContext->pOriginalMdlAddress,
                DataMdl,
                (PCHAR)IrpContext->Specific.Read.Buffer +
                    IrpContext->Specific.Read.ReadOffset,
                MdlLength );

        }

        IrpContext->Specific.Read.BurstBuffer = MmGetSystemAddressForMdlSafe( DataMdl, NormalPagePriority );
        
        if (IrpContext->Specific.Read.BurstBuffer == NULL) {
            
            if ( IrpContext->pOriginalMdlAddress == NULL ) {
                
                //
                // Unlock the pages which we just locked.
                //
                
                MmUnlockPages( DataMdl );
            }
            
            IrpContext->Specific.Read.FullMdl = NULL;
            FREE_MDL( DataMdl );
            return STATUS_NO_MEMORY;
        }


        if ( IrpContext->Specific.Read.BurstSize ==
             IrpContext->Specific.Read.RemainingLength ) {
            Done = TRUE;
        }

        if ( IrpContext->Specific.Read.ReadAheadSize != 0 ) {
            DataMdl->Next = Icb->NpFcb->CacheMdl;
        }

        IrpContext->Specific.Read.LastReadLength = Length;

        //
        //  Build and send the request.
        //

        BuildReadNcp(
            IrpContext,
            IrpContext->Specific.Read.FileOffset,
            (USHORT) MIN( Length, IrpContext->Specific.Read.RemainingLength ) );

        status = PrepareAndSendPacket( IrpContext );
        if ( NT_SUCCESS( status )) {
            KeWaitForSingleObject(
                &IrpContext->Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );

            status = IrpContext->Specific.Read.Status;

        }

        //
        //  Stop looping if the read failed, or we read less data than
        //  requested.
        //

        if ( !NT_SUCCESS( status ) ||
             IrpContext->Specific.Read.BurstSize != 0 ) {

            Done = TRUE;

        }

        if ( IrpContext->pOriginalMdlAddress == NULL ) {
            MmUnlockPages( DataMdl );
        }

        FREE_MDL( DataMdl );

    }

    //
    //  Free the receive MDL if one was allocated.
    //

    Mdl = IrpContext->Specific.Read.PartialMdl;

    while ( Mdl != NULL ) {
        NextMdl = Mdl->Next;
        FREE_MDL( Mdl );
        Mdl = NextMdl;
    }

    DebugTrace(-1, Dbg, "ReadNcp -> %08lx\n", status );

    Stats.ReadNcps++;

    return status;
}


NTSTATUS
ReadNcpCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )

/*++

Routine Description:

    This routine receives the response from a user NCP.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

    BytesAvailable - Number of bytes in the response.

    Response - The response data.


Return Value:

    VOID

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    ULONG Length;
    USHORT USLength;
    PNONPAGED_FCB NpFcb;

    DebugTrace(0, Dbg, "ReadNcpCallback...\n", 0);

    if ( BytesAvailable == 0) {

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

        IrpContext->Specific.Read.Status = STATUS_REMOTE_NOT_LISTENING;

        NwSetIrpContextEvent( IrpContext );
        return STATUS_REMOTE_NOT_LISTENING;
    }

    //
    //  How much data was received?
    //

    Status = ParseReadResponse(
                 IrpContext,
                 (PNCP_READ_RESPONSE)Response,
                 BytesAvailable,
                 &USLength );

    Length = (ULONG)USLength;
    DebugTrace(0, Dbg, "Ncp contains %d bytes\n", Length);

    if ((NT_SUCCESS(Status)) &&
        (Length != 0)) {

        //
        //  If we are receiving the data at indication time, copy the
        //  user's data to the user's buffer.
        //

        if ( Response != IrpContext->rsp ) {

            //
            //  Read in the data.
            //  Note: If the FileOffset is at an odd byte then the server
            //      will insert an extra pad byte.
            //

            CopyBufferToMdl(
                IrpContext->Specific.Read.FullMdl,
                IrpContext->Specific.Read.BurstRequestOffset,
                Response + sizeof( NCP_READ_RESPONSE ) + ( IrpContext->Specific.Read.FileOffset & 1),
                Length );

            DebugTrace( 0, Dbg, "RxLength= %ld\n", Length);

            dump( Dbg,(PUCHAR)IrpContext->Specific.Read.BurstBuffer +
                    IrpContext->Specific.Read.BurstRequestOffset,
                    Length);

        }

        DebugTrace( 0, Dbg, "RxLength= %ld\n", Length);
        IrpContext->Specific.Read.ReadOffset += Length;
        IrpContext->Specific.Read.BurstRequestOffset += Length;
        IrpContext->Specific.Read.FileOffset += Length;
        IrpContext->Specific.Read.RemainingLength -= Length;
        IrpContext->Specific.Read.BurstSize -= Length;
    }

    DebugTrace( 0, Dbg, "RemainingLength  = %ld\n",IrpContext->Specific.Read.RemainingLength);

    //
    //  If the previous read was succesful, and we received as much data
    //  as we asked for, and there is more locked data, send the next
    //  read request.
    //


    if ( ( NT_SUCCESS( Status ) ) &&
         ( IrpContext->Specific.Read.BurstSize != 0 ) &&
         ( Length == IrpContext->Specific.Read.LastReadLength ) ) {

        //
        //  Read the next packet.
        //

        Length = MIN( IrpContext->pNpScb->BufferSize,
                      IrpContext->Specific.Read.BurstSize );

        //
        //  The server will not accept reads that cross 4k boundaries
        //  in the file.
        //

        if ((IrpContext->pNpScb->PageAlign) &&
            (DIFFERENT_PAGES( IrpContext->Specific.Read.FileOffset, Length ))) {
            Length = 4096 - ((ULONG)IrpContext->Specific.Read.FileOffset & (4096-1));
        }

        IrpContext->Specific.Read.LastReadLength = Length;
        DebugTrace( 0, Dbg, "Length  = %ld\n", Length);

        //
        //  Build and send the request.
        //

        BuildReadNcp(
            IrpContext,
            IrpContext->Specific.Read.FileOffset,
            (USHORT)Length );

        Status = PrepareAndSendPacket( IrpContext );

        Stats.ReadNcps++;

        if ( !NT_SUCCESS(Status) ) {
            //  Abandon this request
            goto returnstatus;
        }

    } else {
returnstatus:

        Irp = IrpContext->pOriginalIrp;
        irpSp = IoGetCurrentIrpStackLocation( Irp );
        NpFcb = IrpContext->Icb->NpFcb;

        if ( IrpContext->Icb->NodeTypeCode == NW_NTC_ICB_SCB ) {
            NpFcb = NULL;
        }

        //
        //  Calculate how much data we read into the cache, and how much data
        //  we read into the users buffer.
        //

        if ( NpFcb ) {

            if ( IrpContext->Specific.Read.ReadOffset > irpSp->Parameters.Read.Length ) {

                ASSERT(NpFcb->CacheBuffer != NULL ) ; // had better be there..

                NpFcb->CacheDataSize = IrpContext->Specific.Read.ReadOffset -
                                       irpSp->Parameters.Read.Length;

                Irp->IoStatus.Information = irpSp->Parameters.Read.Length;

            } else {

                NpFcb->CacheDataSize = 0;
                Irp->IoStatus.Information = IrpContext->Specific.Read.ReadOffset;

            }

        } else {

            Irp->IoStatus.Information = IrpContext->Specific.Read.ReadOffset;

        }

        //
        //  We're done with this request, signal the reading thread.
        //

        IrpContext->Specific.Read.Status = Status;

        NwSetIrpContextEvent( IrpContext );
    }

    DebugTrace( 0, Dbg, "ReadNcpCallback -> %08lx\n", Status );
    return STATUS_SUCCESS;
}

NTSTATUS
ReadNcpReceive(
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PULONG BytesAccepted,
    IN PUCHAR Response,
    OUT PMDL *pReceiveMdl
    )
{
    PMDL ReceiveMdl;
    PMDL Mdl, NextMdl;

    DebugTrace( 0, Dbg, "ReadNcpReceive\n", 0 );

    Mdl = IrpContext->Specific.Read.PartialMdl;
    IrpContext->Specific.Read.PartialMdl = NULL;

    while ( Mdl != NULL ) {
        NextMdl = Mdl->Next;
        FREE_MDL( Mdl );
        Mdl = NextMdl;
    }

    //
    //  Set up receive MDL.  Note that we get an extra byte of header
    //  when reading from an odd offset.
    //

    IrpContext->RxMdl->ByteCount = sizeof( NCP_READ_RESPONSE ) +
        (IrpContext->Specific.Read.FileOffset & 1);

    ASSERT( IrpContext->Specific.Read.FullMdl != NULL );

    //
    //  If we are reading at EOF, or there was a read error there will
    //  be a small response.
    //

    if ( BytesAvailable > MmGetMdlByteCount( IrpContext->RxMdl ) ) {

        ReceiveMdl = AllocateReceivePartialMdl(
                         IrpContext->Specific.Read.FullMdl,
                         IrpContext->Specific.Read.BurstRequestOffset,
                         BytesAvailable - MmGetMdlByteCount( IrpContext->RxMdl ) );

        IrpContext->RxMdl->Next = ReceiveMdl;

        //  Record Mdl to free when CopyIndicatedData or Irp completed.
        IrpContext->Specific.Read.PartialMdl = ReceiveMdl;

    } else {

        IrpContext->RxMdl->Next = NULL;

    }

    *pReceiveMdl = IrpContext->RxMdl;
    return STATUS_SUCCESS;
}


VOID
BuildReadNcp(
    PIRP_CONTEXT IrpContext,
    ULONG FileOffset,
    USHORT Length
    )
{
    PNCP_READ_REQUEST ReadRequest;

    ReadRequest = (PNCP_READ_REQUEST)IrpContext->req;

    ReadRequest->RequestHeader.NcpHeader.Command = PEP_COMMAND_REQUEST;
    ReadRequest->RequestHeader.NcpHeader.ConnectionIdLow =
        IrpContext->pNpScb->ConnectionNo;
    ReadRequest->RequestHeader.NcpHeader.ConnectionIdHigh =
        IrpContext->pNpScb->ConnectionNoHigh;
    ReadRequest->RequestHeader.NcpHeader.TaskId =
        IrpContext->Icb->Pid;

    ReadRequest->RequestHeader.FunctionCode = NCP_READ_FILE;
    ReadRequest->Unused = 0;
    RtlMoveMemory(
        ReadRequest->Handle,
        IrpContext->Icb->Handle,
        sizeof( IrpContext->Icb->Handle ) );

    LongByteSwap( ReadRequest->FileOffset, FileOffset );
    ShortByteSwap( ReadRequest->Length, Length );

    IrpContext->TxMdl->ByteCount = sizeof( *ReadRequest );
    SetFlag( IrpContext->Flags, IRP_FLAG_SEQUENCE_NO_REQUIRED );
    ClearFlag( IrpContext->Flags, IRP_FLAG_RETRY_SEND );

    return;
}

NTSTATUS
ParseReadResponse(
    PIRP_CONTEXT IrpContext,
    PNCP_READ_RESPONSE Response,
    ULONG BytesAvailable,
    PUSHORT Length )
{
    NTSTATUS Status;

    Status = ParseNcpResponse( IrpContext, &Response->ResponseHeader );

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    if ( BytesAvailable < sizeof( NCP_READ_RESPONSE ) ) {
        return( STATUS_UNEXPECTED_NETWORK_ERROR );
    }

    ShortByteSwap( *Length, Response->Length );

    return( Status );
}

NTSTATUS
BurstRead(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine exchanges a series of burst read NCPs with the server.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

    ByteOffset - The file offset for the read.

    BufferLength - The number of bytes to read.

Return Value:

    Status of transfer.

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG Length;               //  Size we will send to the server
    PMDL DataMdl;
    ULONG MdlLength;

    PSCB pScb;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PICB Icb;
    PNONPAGED_SCB pNpScb;
    ULONG ByteOffset;
    ULONG BufferLength;

    BOOLEAN Done;

    PAGED_CODE();

    pNpScb = IrpContext->pNpScb;

    irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );
    Icb = IrpContext->Icb;

    BufferLength = irpSp->Parameters.Read.Length +
                   IrpContext->Specific.Read.ReadAheadSize -
                   IrpContext->Specific.Read.CacheReadSize;

    ByteOffset = irpSp->Parameters.Read.ByteOffset.LowPart +
                 IrpContext->Specific.Read.CacheReadSize;

    IrpContext->Specific.Read.FileOffset = ByteOffset;
    IrpContext->Specific.Read.TotalReadOffset = ByteOffset;
    IrpContext->Specific.Read.TotalReadLength = BufferLength;

    DebugTrace(+1, Dbg, "BurstRead...\n", 0);
    DebugTrace( 0, Dbg, "irp     = %08lx\n", (ULONG_PTR)irp);
    DebugTrace( 0, Dbg, "File    = %wZ\n", &Icb->SuperType.Fcb->FullFileName);
    DebugTrace( 0, Dbg, "Length  = %ld\n", BufferLength);
    DebugTrace( 0, Dbg, "Offset  = %ld\n", ByteOffset);
    DebugTrace( 0, Dbg, "Org Len = %ld\n", irpSp->Parameters.Read.Length );
    DebugTrace( 0, Dbg, "Org Off = %ld\n", irpSp->Parameters.Read.ByteOffset.LowPart );

    ASSERT (Icb->SuperType.Fcb->NodeTypeCode == NW_NTC_FCB);

    pScb = Icb->SuperType.Fcb->Scb;

    ASSERT (pScb->NodeTypeCode == NW_NTC_SCB);

    //
    //  Update the original MDL record in the Irp context so that we
    //  can restore it on i/o completion.
    //

    IrpContext->pOriginalMdlAddress = irp->MdlAddress;

    Length = MIN( pNpScb->MaxReceiveSize, BufferLength );

    if ( pNpScb->BurstRenegotiateReqd ) {
        pNpScb->BurstRenegotiateReqd = FALSE;

        RenegotiateBurstMode( IrpContext, pNpScb );
    }

    IrpContext->Specific.Read.ReadOffset = IrpContext->Specific.Read.CacheReadSize;
    IrpContext->Specific.Read.RemainingLength = BufferLength;
    IrpContext->Specific.Read.LastReadLength = Length;

    InitializeListHead( &IrpContext->Specific.Read.PacketList );
    IrpContext->Specific.Read.BurstRequestOffset = 0;
    IrpContext->Specific.Read.BurstSize = 0;
    IrpContext->Specific.Read.DataReceived = FALSE;

    IrpContext->pTdiStruct = &pNpScb->Burst;
    IrpContext->TimeoutRoutine = BurstReadTimeout;
    IrpContext->ReceiveDataRoutine = BurstReadReceive;

    IrpContext->Specific.Read.Buffer = irp->UserBuffer;

    IrpContext->pEx = BurstReadCallback;
    IrpContext->Destination = pNpScb->RemoteAddress;
    IrpContext->PacketType = NCP_BURST;

    //
    //  Tell BurstWrite that it needs to send a dummy Ncp on the next write.
    //

    pNpScb->BurstDataWritten = 0x00010000;

    //
    //  The server will pause NwReceiveDelay between packets. Make sure we have our timeout
    //  so that we will take that into account.
    //

    SetConnectionTimeout( IrpContext->pNpScb, Length );

    Done = FALSE;

    while ( !Done ) {

        //
        //  Set burst read timeouts to how long we think the burst should take.
        //
        //  tommye - MS bug 2743 changed the RetryCount from 20 to be based off the 
        //  default retry count, nudged up a little. 
        //

        pNpScb->RetryCount = DefaultRetryCount * 2;

        //
        //  Allocate and build an MDL for the users buffer.
        //

        if ( IrpContext->Specific.Read.ReadAheadSize == 0 ) {
            MdlLength = Length;
        } else {
            MdlLength = Length - IrpContext->Specific.Read.ReadAheadSize;
        }

        DataMdl = ALLOCATE_MDL(
                      (PCHAR)IrpContext->Specific.Read.Buffer +
                           IrpContext->Specific.Read.ReadOffset,
                      MdlLength,
                      FALSE, // Secondary Buffer
                      FALSE, // Charge Quota
                      NULL);

        if ( DataMdl == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  If there is no MDL for this read, probe the data MDL to lock it's
        //  pages down.
        //
        //  Otherwise, use the data MDL as a partial MDL and lock the pages
        //  accordingly.
        //

        if ( IrpContext->pOriginalMdlAddress == NULL ) {

            try {
                MmProbeAndLockPages( DataMdl, irp->RequestorMode, IoWriteAccess);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                FREE_MDL( DataMdl );
                return GetExceptionCode();
            }

        } else {

            IoBuildPartialMdl(
                IrpContext->pOriginalMdlAddress,
                DataMdl,
                (PCHAR)IrpContext->Specific.Read.Buffer +
                    IrpContext->Specific.Read.ReadOffset,
                MdlLength );
        }

        IrpContext->Specific.Read.BurstBuffer = MmGetSystemAddressForMdlSafe( DataMdl, NormalPagePriority );

        if (IrpContext->Specific.Read.BurstBuffer == NULL) {
                
            if ( IrpContext->pOriginalMdlAddress == NULL ) {
                
                //
                // Unlock the pages which we just locked.
                //
                
                MmUnlockPages( DataMdl );
            }
            
            FREE_MDL( DataMdl );
            return STATUS_NO_MEMORY;
        }

        IrpContext->Specific.Read.FullMdl = DataMdl;
        
        if ( IrpContext->Specific.Read.ReadAheadSize != 0 ) {
            DataMdl->Next = Icb->NpFcb->CacheMdl;
        }

        SetFlag( IrpContext->Flags, IRP_FLAG_BURST_REQUEST | IRP_FLAG_BURST_PACKET );

        //
        //  Send the request.
        //

        BuildBurstReadRequest(
            IrpContext,
            *(ULONG UNALIGNED *)(&Icb->Handle[2]),
            IrpContext->Specific.Read.FileOffset,
            Length );

        status = PrepareAndSendPacket( IrpContext );
        if ( NT_SUCCESS( status )) {
            status = KeWaitForSingleObject(
                         &IrpContext->Event,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL
                         );
        }

        if ( IrpContext->pOriginalMdlAddress == NULL ) {
            MmUnlockPages( DataMdl );
        }

        FREE_MDL( DataMdl );
        FreePacketList( IrpContext );

        ClearFlag( IrpContext->Flags,  IRP_FLAG_BURST_REQUEST );

        status = IrpContext->Specific.Read.Status;

        if ( status != STATUS_REMOTE_NOT_LISTENING ) {
            IrpContext->pNpScb->BurstRequestNo++;
            NwProcessReceiveBurstSuccess( IrpContext->pNpScb );
        }

        if ( !NT_SUCCESS( status ) ) {
            return( status );
        }

        //
        //  Update the read status data.
        //

        IrpContext->Specific.Read.ReadOffset +=
            IrpContext->Specific.Read.BurstSize;
        IrpContext->Specific.Read.FileOffset +=
            IrpContext->Specific.Read.BurstSize;
        IrpContext->Specific.Read.RemainingLength -=
            IrpContext->Specific.Read.BurstSize;

        if ( IrpContext->Specific.Read.LastReadLength ==
                IrpContext->Specific.Read.BurstSize &&

                IrpContext->Specific.Read.RemainingLength > 0 ) {

            //
            //  We've received all the data from the current burst, and we
            //  received as many bytes as we asked for, and we need more data
            //  to satisfy the users read request, start another read burst.
            //

            Length = MIN( IrpContext->pNpScb->MaxReceiveSize,
                          IrpContext->Specific.Read.RemainingLength );

            DebugTrace( 0, Dbg, "Requesting another burst, length  = %ld\n", Length);

            ASSERT( Length != 0 );

            IrpContext->Specific.Read.LastReadLength = Length;
            (PUCHAR)IrpContext->Specific.Read.BurstBuffer +=
                IrpContext->Specific.Read.BurstSize;
            IrpContext->Specific.Read.BurstRequestOffset = 0;
            IrpContext->Specific.Read.BurstSize = 0;
            IrpContext->Specific.Read.DataReceived = FALSE;

        } else {
            Done = TRUE;
        }

    }


    //
    //  Calculate how much data we read into the cache, and how much data
    //  we read into the users buffer.
    //

    if ( IrpContext->Specific.Read.ReadOffset > irpSp->Parameters.Read.Length ) {

        ASSERT(Icb->NpFcb->CacheBuffer != NULL ) ;  // this had better be there

        Icb->NpFcb->CacheDataSize =
            IrpContext->Specific.Read.ReadOffset -
            irpSp->Parameters.Read.Length;

        irp->IoStatus.Information = irpSp->Parameters.Read.Length;

    } else {

        Icb->NpFcb->CacheDataSize = 0;
        irp->IoStatus.Information = IrpContext->Specific.Read.ReadOffset;

    }

    DebugTrace( 0, Dbg, "BytesRead -> %08lx\n", irp->IoStatus.Information );
    DebugTrace(-1, Dbg, "BurstRead -> %08lx\n", status );

    Stats.PacketBurstReadNcps++;
    return status;
}

VOID
BuildBurstReadRequest(
    IN PIRP_CONTEXT IrpContext,
    IN ULONG Handle,
    IN ULONG FileOffset,
    IN ULONG Length
    )
{
    PNCP_BURST_READ_REQUEST BurstRead;
    PNONPAGED_SCB pNpScb;
    ULONG Temp;

    BurstRead = (PNCP_BURST_READ_REQUEST)(IrpContext->req);
    pNpScb = IrpContext->pNpScb;

    BurstRead->BurstHeader.Command = PEP_COMMAND_BURST;
    BurstRead->BurstHeader.Flags = BURST_FLAG_END_OF_BURST;
    BurstRead->BurstHeader.StreamType = 0x02;
    BurstRead->BurstHeader.SourceConnection = pNpScb->SourceConnectionId;
    BurstRead->BurstHeader.DestinationConnection = pNpScb->DestinationConnectionId;

    LongByteSwap( BurstRead->BurstHeader.SendDelayTime, pNpScb->NwReceiveDelay );

    pNpScb->CurrentBurstDelay = pNpScb->NwReceiveDelay;

    Temp = sizeof( NCP_BURST_READ_REQUEST ) - sizeof( NCP_BURST_HEADER );
    LongByteSwap( BurstRead->BurstHeader.DataSize, Temp);

    BurstRead->BurstHeader.BurstOffset = 0;

    ShortByteSwap( BurstRead->BurstHeader.BurstLength, Temp );

    BurstRead->BurstHeader.MissingFragmentCount = 0;

    BurstRead->Function = 1;
    BurstRead->Handle = Handle;

    LongByteSwap(
        BurstRead->TotalReadOffset,
        IrpContext->Specific.Read.TotalReadOffset );

    LongByteSwap(
        BurstRead->TotalReadLength,
        IrpContext->Specific.Read.TotalReadLength );

    LongByteSwap( BurstRead->Offset, FileOffset );
    LongByteSwap( BurstRead->Length, Length );

    IrpContext->TxMdl->ByteCount = sizeof( NCP_BURST_READ_REQUEST );
}

#ifdef NWDBG
int DropReadPackets;
#endif


NTSTATUS
BurstReadCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )
/*++

Routine Description:

    This routine receives the response from a user NCP.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

    BytesAvailable - Actual number of bytes in the received message.

    RspData - Points to the receive buffer.

Return Value:

    The status of the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DataOffset;
    ULONG TotalBytesRead;
    PUCHAR ReadData;
    USHORT BytesThisPacket = 0;
    UCHAR Flags;
    KIRQL OldIrql;

    DebugTrace(+1, Dbg, "BurstReadCallback...\n", 0);
    DebugTrace( 0, Dbg, "IrpContext = %X\n", IrpContext );

    if ( BytesAvailable == 0) {

        //
        //  No response from server.
        //

        IrpContext->Specific.Read.Status = STATUS_REMOTE_NOT_LISTENING;
        NwSetIrpContextEvent( IrpContext );

        DebugTrace( -1, Dbg, "BurstReadCallback -> %X\n", STATUS_REMOTE_NOT_LISTENING );
        return STATUS_REMOTE_NOT_LISTENING;
    }

    Stats.PacketBurstReadNcps++;

    if ( Response != IrpContext->rsp ) {

        //
        //  Acquire the SCB spin lock to protect access to the list
        //  of received data for this read.
        //

        KeAcquireSpinLock( &IrpContext->pNpScb->NpScbSpinLock, &OldIrql );

        Status = ParseBurstReadResponse(
                     IrpContext,
                     Response,
                     BytesAvailable,
                     &Flags,
                     &DataOffset,
                     &BytesThisPacket,
                     &ReadData,
                     &TotalBytesRead );

        if ( !NT_SUCCESS( Status ) ) {
            IrpContext->Specific.Read.Status = Status;
            KeReleaseSpinLock( &IrpContext->pNpScb->NpScbSpinLock, OldIrql );
            return( STATUS_SUCCESS );
        }

        //
        //  Update the list of data received, and copy the data to the users
        //  buffer.
        //

        RecordPacketReceipt( IrpContext, ReadData, DataOffset, BytesThisPacket, TRUE );
        KeReleaseSpinLock( &IrpContext->pNpScb->NpScbSpinLock, OldIrql );

    } else {
        Flags = IrpContext->Specific.Read.Flags;
    }

    //
    //  If this isn't the last packet setup for the next burst packet.
    //

    if ( !FlagOn( Flags, BURST_FLAG_END_OF_BURST ) ) {

        DebugTrace(0, Dbg, "Waiting for another packet\n", 0);

        IrpContext->pNpScb->OkToReceive = TRUE;

        DebugTrace( -1, Dbg, "BurstReadCallback -> %X\n", STATUS_SUCCESS );
        return( STATUS_SUCCESS );
    }

    DebugTrace(0, Dbg, "Received final packet\n", 0);

    //
    //  Have we received all of the data?   If not, VerifyBurstRead will
    //  send a missing data request.
    //

    if ( VerifyBurstRead( IrpContext ) ) {

        //
        //  All the data for the current burst has been received, notify
        //  the thread that is sending the data.
        //

        if (NT_SUCCESS(IrpContext->Specific.Read.Status)) {

            //
            //  If Irp allocation fails then it is possible for the
            //  packet to have been recorded but not copied into the
            //  user buffer. In this case leave the failure status.
            //

            IrpContext->Specific.Read.Status = STATUS_SUCCESS;
        }

        NwSetIrpContextEvent( IrpContext );

    }

    DebugTrace( -1, Dbg, "BurstReadCallback -> %X\n", STATUS_SUCCESS );
    return STATUS_SUCCESS;

}

VOID
BurstReadTimeout(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine handles a burst read timeout, i.e. no immediate response
    to the current burst read request.   It request to read the packet burst
    data from the last valid received packet.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

Return Value:

    Status of transfer.

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    DebugTrace(0, Dbg, "BurstReadTimeout\n", 0 );

    //
    //  Re-request the data we haven't received.
    //

    if ( !IrpContext->Specific.Read.DataReceived ) {

        DebugTrace( 0, Dbg, "No packets received, retranmit\n", 0 );

        SetFlag( IrpContext->Flags, IRP_FLAG_RETRY_SEND );

        //
        //  We never received any data.  Try retransmitting the previous
        //  request.
        //

        PreparePacket( IrpContext, IrpContext->pOriginalIrp, IrpContext->TxMdl );
        SendNow( IrpContext );

    } else {

        IrpContext->Specific.Read.DataReceived = FALSE;

        //
        //  Verify burst read will send a missing data request if one we
        //  have not received all of the data.
        //

        if ( VerifyBurstRead( IrpContext ) ) {
            NwSetIrpContextEvent( IrpContext );
        }
    }

    Stats.PacketBurstReadTimeouts++;
}

NTSTATUS
ResubmitBurstRead (
    IN PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine handles a rerouted burst read.  The burst request is
    resubmitted on a new burst connection.

Arguments:*

    pIrpContext - A pointer to the context information for this IRP.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    ULONG Length, DataMdlBytes = 0 ;
    PMDL  DataMdl ;

    DebugTrace( 0, Dbg, "ResubmitBurstRead\n", 0 );

    //
    //  Recalculate the burst size, as MaxReceiveSize may have changed.
    //

    Length = MIN( IrpContext->pNpScb->MaxReceiveSize,
                  IrpContext->Specific.Read.RemainingLength );

    //
    // Make sure we dont ask for more than bytes described by MDL
    //
    DataMdl  =  IrpContext->Specific.Read.FullMdl;

    while (DataMdl) {

        DataMdlBytes += MmGetMdlByteCount( DataMdl );
        DataMdl = DataMdl->Next;
    }

    Length = MIN( Length, DataMdlBytes ) ;

    DebugTrace( 0, Dbg, "Requesting another burst, length  = %ld\n", Length);

    ASSERT( Length != 0 );

    //
    //  Free the packet list, and reset all of the current burst context
    //  information.
    //

    FreePacketList( IrpContext );

    IrpContext->Specific.Read.LastReadLength = Length;
    IrpContext->Specific.Read.BurstRequestOffset = 0;
    IrpContext->Specific.Read.BurstSize = 0;
    IrpContext->Specific.Read.DataReceived = FALSE;

    SetConnectionTimeout( IrpContext->pNpScb, Length );

    //
    //  Format and send the request.
    //

    BuildBurstReadRequest(
        IrpContext,
        *(ULONG UNALIGNED *)(&IrpContext->Icb->Handle[2]),
        IrpContext->Specific.Read.FileOffset,
        Length );

    //  Avoid SendNow setting the RetryCount back to the default

    SetFlag( IrpContext->Flags, IRP_FLAG_RETRY_SEND );

    Status = PrepareAndSendPacket( IrpContext );

    return Status;
}

VOID
RecordPacketReceipt(
    PIRP_CONTEXT IrpContext,
    PVOID ReadData,
    ULONG DataOffset,
    USHORT ByteCount,
    BOOLEAN CopyData
    )
/*++

Routine Description:

    This routine records the reciept of a burst read packet.  It allocates
    a burst read entry to record data start and length, and then inserts
    the structure in order in the list of packets received for this burst.
    It then copies the data to the user buffer.

    This routine could release the spin lock before doing the
       data copy.  Would this be useful?

Arguments:

    IrpContext - A pointer to IRP context information for this request.

    ReadData - A pointer to the data to copy.

    DataOffset - The start offset of the data in the received packet.

    ByteCount - The amount of data received.

    CopyData - If FALSE, don't copy the data to the user's buffer.  The
        transport will do it.

Return Value:

    None.

--*/
{
    PBURST_READ_ENTRY BurstReadEntry;
    PBURST_READ_ENTRY ThisBurstReadEntry, NextBurstReadEntry;
    PLIST_ENTRY ListEntry;
#if NWDBG
    BOOLEAN Insert = FALSE;
#endif
    USHORT ExtraBytes;

    DebugTrace(0, Dbg, "RecordPacketReceipt\n", 0 );

    IrpContext->Specific.Read.DataReceived = TRUE;

    //
    //  Allocate and initialize a burst read entry.
    //

    BurstReadEntry = ALLOCATE_POOL( NonPagedPool, sizeof( BURST_READ_ENTRY ) );
    if ( BurstReadEntry == NULL ) {
        DebugTrace(0, Dbg, "Failed to allocate BurstReadEntry\n", 0 );
        return;
    }

    //
    //  Insert this element in the ordered list of received packets.
    //

    if ( IsListEmpty( &IrpContext->Specific.Read.PacketList ) ) {

#if NWDBG
        Insert = TRUE;
#endif

        InsertHeadList(
            &IrpContext->Specific.Read.PacketList,
            &BurstReadEntry->ListEntry );

        DebugTrace(0, Dbg, "First packet in the list\n", 0 );

    } else {

        //
        //  Walk the list of received packets, looking for the place to
        //  insert this entry.  Walk the list backwards, since most of
        //  the time we will be appending to the list.
        //

        ListEntry = IrpContext->Specific.Read.PacketList.Blink;
        ThisBurstReadEntry = NULL;

        while ( ListEntry != &IrpContext->Specific.Read.PacketList ) {

            NextBurstReadEntry = ThisBurstReadEntry;
            ThisBurstReadEntry = CONTAINING_RECORD(
                                   ListEntry,
                                   BURST_READ_ENTRY,
                                   ListEntry );

            if ( ThisBurstReadEntry->DataOffset <= DataOffset ) {

                //
                //  Found the place in the list to insert this entry.
                //

                if ( ThisBurstReadEntry->DataOffset +
                     ThisBurstReadEntry->ByteCount > DataOffset ) {

                    //
                    //  The start of this packet contains data which
                    //  overlaps data we have received.  Chuck the extra
                    //  data.
                    //

                    ExtraBytes = (USHORT)( ThisBurstReadEntry->DataOffset +
                                 ThisBurstReadEntry->ByteCount - DataOffset );

                    if ( ExtraBytes < ByteCount ) {
                        DataOffset += ExtraBytes;
                        (PCHAR)ReadData += ExtraBytes;
                        ByteCount -= ExtraBytes;
                    } else {
                        ByteCount = 0;
                    }

                }

                if ( NextBurstReadEntry != NULL &&
                     DataOffset + ByteCount > NextBurstReadEntry->DataOffset ) {

                    //
                    //  This packet contains some new data, but some of it
                    //  overlaps the NextBurstReadEntry.  Simply ignore
                    //  the overlap by adjusting the byte count.
                    //
                    //  If the packet is all overlap, toss it.
                    //

                    ByteCount = (USHORT)( NextBurstReadEntry->DataOffset - DataOffset );
                }

                if ( ByteCount == 0 ) {
                    FREE_POOL( BurstReadEntry );
                    return;
                }
#if NWDBG
                Insert = TRUE;
#endif
                InsertHeadList( ListEntry, &BurstReadEntry->ListEntry );
                break;

            } else {

                ListEntry = ListEntry->Blink;
            }
        }

        //
        //  Couldn't find the place to insert
        //

        ASSERT( Insert );
    }

    BurstReadEntry->DataOffset = DataOffset;
    BurstReadEntry->ByteCount = ByteCount;

    //
    //  Copy the data to our read buffer.
    //

    if ( CopyData ) {
        CopyBufferToMdl(
            IrpContext->Specific.Read.FullMdl,
            DataOffset,
            ReadData,
            ByteCount );
    }

    return;
}

#include <packon.h>

typedef struct _MISSING_DATA_ENTRY {
    ULONG DataOffset;
    USHORT ByteCount;
} MISSING_DATA_ENTRY, *PMISSING_DATA_ENTRY;

#include <packoff.h>

BOOLEAN
VerifyBurstRead(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine verifies the set of response to a burst read request.
    If some data is missing a missing packet request is sent.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

Return Value:

    TRUE - All the data was received.

    FALSE - Some data was missing.

--*/
{
    ULONG CurrentOffset = 0;
    PLIST_ENTRY ListEntry;
    PBURST_READ_ENTRY BurstReadEntry;
    USHORT MissingFragmentCount = 0;
    USHORT ByteCount;
    ULONG DataOffset;
    MISSING_DATA_ENTRY UNALIGNED *MissingDataEntry;
    KIRQL OldIrql;

    DebugTrace(+1, Dbg, "VerifyBurstRead\n", 0 );

    //
    //  Acquire the SCB spin lock to protect access to the list
    //  of received data for this read.
    //

    KeAcquireSpinLock(&IrpContext->pNpScb->NpScbSpinLock, &OldIrql);

#ifdef NWDBG
    //
    //  Verify that the list is in order.
    //

    ListEntry = IrpContext->Specific.Read.PacketList.Flink;

    while ( ListEntry != &IrpContext->Specific.Read.PacketList ) {

        BurstReadEntry = CONTAINING_RECORD( ListEntry, BURST_READ_ENTRY, ListEntry );
        ASSERT ( BurstReadEntry->DataOffset >= CurrentOffset);
        CurrentOffset = BurstReadEntry->DataOffset + BurstReadEntry->ByteCount;
        ListEntry = ListEntry->Flink;
    }

    CurrentOffset = 0;

#endif

    ListEntry = IrpContext->Specific.Read.PacketList.Flink;

    while ( ListEntry != &IrpContext->Specific.Read.PacketList ) {

        BurstReadEntry = CONTAINING_RECORD( ListEntry, BURST_READ_ENTRY, ListEntry );
        if ( BurstReadEntry->DataOffset != CurrentOffset) {

            //
            //  There is a hole in the data, fill in a missing packet entry.
            //

            MissingDataEntry = (MISSING_DATA_ENTRY UNALIGNED *)
                &IrpContext->req[ sizeof( NCP_BURST_HEADER ) +
                    MissingFragmentCount * sizeof( MISSING_DATA_ENTRY ) ];

            DataOffset = CurrentOffset + SIZE_ADJUST( IrpContext );
            LongByteSwap( MissingDataEntry->DataOffset, DataOffset );

            ByteCount = (USHORT)( BurstReadEntry->DataOffset - CurrentOffset );
            ShortByteSwap( MissingDataEntry->ByteCount, ByteCount );

            ASSERT( BurstReadEntry->DataOffset - CurrentOffset <= IrpContext->pNpScb->MaxReceiveSize );

            DebugTrace(0, Dbg, "Missing data at offset %ld\n", DataOffset );
            DebugTrace(0, Dbg, "Missing %d bytes\n", ByteCount );
            DebugTrace(0, Dbg, "CurrentOffset: %d\n", CurrentOffset );

            MissingFragmentCount++;
        }

        CurrentOffset = BurstReadEntry->DataOffset + BurstReadEntry->ByteCount;
        ListEntry = ListEntry->Flink;
    }

    //
    //  Any data missing off the end?
    //

    if ( CurrentOffset <
         IrpContext->Specific.Read.BurstSize ) {

        //
        //  There is a hole in the data, fill in a missing packet entry.
        //

        MissingDataEntry = (PMISSING_DATA_ENTRY)
            &IrpContext->req[  sizeof( NCP_BURST_HEADER ) +
                    MissingFragmentCount * sizeof( MISSING_DATA_ENTRY ) ];

        DataOffset = CurrentOffset + SIZE_ADJUST( IrpContext );
        LongByteSwap( MissingDataEntry->DataOffset, DataOffset );

        ByteCount = (USHORT)( IrpContext->Specific.Read.BurstSize - CurrentOffset );
        ShortByteSwap( MissingDataEntry->ByteCount, ByteCount );

        ASSERT( IrpContext->Specific.Read.BurstSize - CurrentOffset < IrpContext->pNpScb->MaxReceiveSize );

        DebugTrace(0, Dbg, "Missing data at offset %ld\n", MissingDataEntry->DataOffset );
        DebugTrace(0, Dbg, "Missing %d bytes\n", MissingDataEntry->ByteCount );

        MissingFragmentCount++;
    }


    if ( MissingFragmentCount == 0 ) {

        //
        //  This read is now complete. Don't process any more packets until
        //  the next packet is sent.
        //

        IrpContext->pNpScb->OkToReceive = FALSE;

        KeReleaseSpinLock(&IrpContext->pNpScb->NpScbSpinLock, OldIrql);

        DebugTrace(-1, Dbg, "VerifyBurstRead -> TRUE\n", 0 );

        return( TRUE );

    } else {

        KeReleaseSpinLock(&IrpContext->pNpScb->NpScbSpinLock, OldIrql);

        //
        //  The server dropped a packet, adjust the timers.
        //

        NwProcessReceiveBurstFailure( IrpContext->pNpScb, MissingFragmentCount );

        //
        //  Request the missing data.
        //

        SetFlag( IrpContext->Flags, IRP_FLAG_BURST_PACKET );

        //
        //  Update burst request offset since we are about to request
        //  more data.  Note that this will reset the retry count,
        //  thus giving the server full timeout time to return the
        //  missing data.
        //

        BuildRequestPacket(
            IrpContext,
            BurstReadCallback,
            "Bws",
            0,                     // Frame size for this request is 0
            0,                     // Offset of data
            BURST_FLAG_SYSTEM_PACKET,
            MissingFragmentCount,
            MissingFragmentCount * sizeof( MISSING_DATA_ENTRY )
            );

        PrepareAndSendPacket( IrpContext );

        Stats.PacketBurstReadTimeouts++;

        DebugTrace(-1, Dbg, "VerifyBurstRead -> FALSE\n", 0 );
        return( FALSE );
    }
}


VOID
FreePacketList(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine frees the received packet list for a burst read.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

Return Value:

    None.

--*/
{
    PLIST_ENTRY ListHead;
    PBURST_READ_ENTRY BurstReadEntry;

    ListHead = &IrpContext->Specific.Read.PacketList;
    while ( !IsListEmpty( ListHead )  ) {
        BurstReadEntry = CONTAINING_RECORD( ListHead->Flink, BURST_READ_ENTRY, ListEntry );
        RemoveHeadList( ListHead );
        FREE_POOL( BurstReadEntry );
    }
}

NTSTATUS
BurstReadReceive(
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PULONG BytesAccepted,
    IN PUCHAR Response,
    PMDL *pReceiveMdl
    )
/*++

Routine Description:

    This routine builds an MDL to receive burst read data.  This routine
    is called at data indication time.

    This routine is called with the non paged SCB spin lock held.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

    BytesAvailable - The number of bytes in the entire packet.

    BytesAccepted - Returns the number of bytes accepted from the packet.

    Response - A pointer to the indication buffer.

Return Value:

    Mdl - An MDL to receive the data.
    This routine raise an exception if it cannot receive the data.

--*/
{
    NTSTATUS Status;
    ULONG DataOffset;
    ULONG TotalBytesRead;
    PUCHAR ReadData;
    USHORT BytesThisPacket;
    UCHAR Flags;
    PMDL PartialMdl;

    DebugTrace(0, Dbg, "Burst read receive\n", 0);

    Status = ParseBurstReadResponse(
                 IrpContext,
                 Response,
                 BytesAvailable,
                 &Flags,
                 &DataOffset,
                 &BytesThisPacket,
                 &ReadData,
                 &TotalBytesRead );

    if ( !NT_SUCCESS( Status ) ) {

        DebugTrace(0, Dbg, "Failed to parse burst read response\n", 0);
        return Status;
    }

    //
    //  We can accept up to the size of a burst read header, plus
    //  3 bytes of fluff for the unaligned read case.
    //

    *BytesAccepted = (ULONG) (ReadData - Response);
    ASSERT( *BytesAccepted <= sizeof(NCP_BURST_READ_RESPONSE) + 3 );

    RecordPacketReceipt( IrpContext, ReadData, DataOffset, BytesThisPacket, FALSE );

    IrpContext->Specific.Read.Flags = Flags;

    //
    //  If we did a read at EOF the netware server will return 0 bytes read,
    //  no error.
    //

    ASSERT( IrpContext->Specific.Read.FullMdl != NULL );

    if ( BytesThisPacket > 0 ) {

        PartialMdl = AllocateReceivePartialMdl(
                         IrpContext->Specific.Read.FullMdl,
                         DataOffset,
                         BytesThisPacket );

        if ( !PartialMdl ) {
            IrpContext->Specific.Read.Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        //  Record Mdl to free when CopyIndicatedData or Irp completed.
        IrpContext->Specific.Read.PartialMdl = PartialMdl;

    } else {

        PartialMdl = NULL;

    }

    *pReceiveMdl = PartialMdl;
    return( STATUS_SUCCESS );
}

NTSTATUS
ParseBurstReadResponse(
    IN PIRP_CONTEXT IrpContext,
    PUCHAR Response,
    ULONG BytesAvailable,
    PUCHAR Flags,
    PULONG DataOffset,
    PUSHORT BytesThisPacket,
    PUCHAR *ReadData,
    PULONG TotalBytesRead
    )
/*++

Routine Description:

    This routine parses a burst read response.

    This routine must be called the the nonpagd SCB spinlock held.

Arguments:

        IrpContext - A pointer to IRP context information for this request.

        Response - A pointer to the response buffer.

        BytesAvailable - The number of bytes in the packet.

        Flags - Returns the Burst Flags

        DataOffset - Returns the data offset (within the burst) of the
            data in this packet.

        BytesThisPacket - Returns the number of file data bytes in this packet.

        ReadData - Returns a pointer to the start of the file data in the
            packet buffer.

        TotalBytesRead - Returns the number of byte of file data in the
            entire burst.


Return Value:

    The status of the read.

--*/
{
    NTSTATUS Status;
    ULONG Result;
    PNCP_BURST_READ_RESPONSE ReadResponse;

    DebugTrace(+1, Dbg, "ParseBurstReadResponse\n", 0);

    ReadResponse = (PNCP_BURST_READ_RESPONSE)Response;
    *Flags  = ReadResponse->BurstHeader.Flags;

#ifdef NWDBG
    //
    //  Bad net simulator.
    //

    if ( DropReadPackets != 0 ) {
        if ( ( rand() % DropReadPackets ) == 0 ) {

            IrpContext->pNpScb->OkToReceive = TRUE;
            DebugTrace(  0, Dbg, "Dropping packet\n", 0 );
            DebugTrace( -1, Dbg, "ParseBurstReadResponse -> %X\n", STATUS_UNSUCCESSFUL );
            return ( STATUS_UNSUCCESSFUL );
        }
    }

#endif

    //
    //  If this isn't the last packet, setup for the next burst packet.
    //

    if ( !FlagOn( *Flags, BURST_FLAG_END_OF_BURST ) ) {

        DebugTrace(0, Dbg, "Waiting for another packet\n", 0);

        //
        //  Once we receive the first packet in a read response be aggresive
        //  about timing out while waiting for the rest of the burst.
        //

        IrpContext->pNpScb->TimeOut = IrpContext->pNpScb->SendTimeout ;

        IrpContext->pNpScb->OkToReceive = TRUE;
    }


    LongByteSwap( *DataOffset, ReadResponse->BurstHeader.BurstOffset );
    ShortByteSwap( *BytesThisPacket, ReadResponse->BurstHeader.BurstLength );

    //
    //  How much data was received?
    //

    if ( IsListEmpty( &IrpContext->Specific.Read.PacketList ) ) {

        DebugTrace(0, Dbg, "Expecting initial response\n", 0);

        //
        //  This is the initial burst response packet.
        //

        if ( *DataOffset != 0 ) {

            DebugTrace(0, Dbg, "Invalid initial response tossed\n", 0);

            //
            //  This is actually a subsequent response.  Toss it.
            //

            DebugTrace( -1, Dbg, "ParseBurstReadResponse -> %X\n", STATUS_UNSUCCESSFUL );
            IrpContext->pNpScb->OkToReceive = TRUE;

            return ( STATUS_UNSUCCESSFUL );
        }

        Result = ReadResponse->Result;
        LongByteSwap( *TotalBytesRead, ReadResponse->BytesRead );

        Status = NwBurstResultToNtStatus( Result );
        IrpContext->Specific.Read.Status = Status;

        if ( !NT_SUCCESS( Status ) ) {

            //
            //  Update the burst request number now.
            //

            DebugTrace(0, Dbg, "Read completed, error = %X\n", Status );

            ClearFlag( IrpContext->Flags,  IRP_FLAG_BURST_REQUEST );
            NwSetIrpContextEvent( IrpContext );

            DebugTrace( -1, Dbg, "ParseBurstReadResponse -> %X\n", Status );
            return( Status );
        }

        if ( Result == 3 || *BytesThisPacket < 8 ) {   // No data
            *TotalBytesRead = 0;
            *BytesThisPacket = 8;
        }

        *ReadData = Response + sizeof(NCP_BURST_READ_RESPONSE);

        IrpContext->Specific.Read.BurstSize = *TotalBytesRead;

        //
        //  Bytes this packet includes a LONG status and a LONG byte total.
        //  Adjust the count to reflect the number of data bytes actually
        //  shipped.
        //

        *BytesThisPacket -= sizeof( ULONG ) + sizeof( ULONG );

        //
        //  Adjust this data if the read was not DWORD aligned.
        //

        if ( (IrpContext->Specific.Read.FileOffset & 0x03) != 0
             && *BytesThisPacket != 0 ) {

            *ReadData += IrpContext->Specific.Read.FileOffset & 0x03;
            *BytesThisPacket -= (USHORT)IrpContext->Specific.Read.FileOffset & 0x03;
        }

        DebugTrace(0, Dbg, "Initial response\n", 0);
        DebugTrace(0, Dbg, "Result = %ld\n", Result);
        DebugTrace(0, Dbg, "Total bytes read = %ld\n", *TotalBytesRead );

    } else {

        //
        //  Intermediate response packet.
        //

        *ReadData = Response + sizeof( NCP_BURST_HEADER );
        *DataOffset -= SIZE_ADJUST( IrpContext );

    }

    DebugTrace(0, Dbg, "DataOffset = %ld\n", *DataOffset );
    DebugTrace(0, Dbg, "# bytes received = %d\n", *BytesThisPacket );

    if ( *DataOffset > IrpContext->Specific.Read.BurstSize ||
         *DataOffset + *BytesThisPacket > IrpContext->Specific.Read.BurstSize ) {

        DebugTrace(0, Dbg, "Invalid response tossed\n", 0);

        DebugTrace( -1, Dbg, "ParseBurstReadResponse -> %X\n", STATUS_SUCCESS );
        IrpContext->pNpScb->OkToReceive = TRUE;
        return ( STATUS_UNSUCCESSFUL );
    }

    DebugTrace( -1, Dbg, "ParseBurstReadResponse -> %X\n", STATUS_SUCCESS );
    return( STATUS_SUCCESS );
}


PMDL
AllocateReceivePartialMdl(
    PMDL FullMdl,
    ULONG DataOffset,
    ULONG BytesThisPacket
    )
/*++

Routine Description:

    This routine allocates a partial MDL to receive read data.  This
    routine is called at receive indication time.

Arguments:

    FullMdl - The FullMdl for the buffer.

    DataOffset - The offset into the buffer where the data is to be received.

    BytesThisPacket - The number of data bytes to be received into the buffer.

Return Value:

    MDL - A pointer to an MDL to receive the data
    This routine raises an exception if it cannot allocate an MDL.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR BufferStart, BufferEnd;
    PMDL InitialMdl, NextMdl;
    PMDL ReceiveMdl, PreviousReceiveMdl;
    ULONG BytesThisMdl;

    BufferStart = (PUCHAR)MmGetMdlVirtualAddress( FullMdl ) + DataOffset;
    BufferEnd = (PUCHAR)MmGetMdlVirtualAddress( FullMdl ) +
                    MmGetMdlByteCount( FullMdl );

    //
    //  Walk the MDL chain look for the MDL for the actual buffer for the
    //  start of this data.
    //

    while ( BufferStart >= BufferEnd ) {
        DataOffset -= MmGetMdlByteCount( FullMdl );
        FullMdl = FullMdl->Next;

        //
        // if more data than expected, dont dereference NULL! see next loop.
        //
        if (!FullMdl) {
            ASSERT(FALSE) ;
            break ;
        }

        BufferStart = (PUCHAR)MmGetMdlVirtualAddress( FullMdl ) + DataOffset;
        BufferEnd = (PUCHAR)MmGetMdlVirtualAddress( FullMdl ) +
                         MmGetMdlByteCount( FullMdl );
    }

    PreviousReceiveMdl = NULL;
    InitialMdl = NULL;
    BytesThisMdl = (ULONG)(BufferEnd - BufferStart);

    //
    //  Check FullMdl to cover the case where the server returns more data
    //  than requested.
    //

    while (( BytesThisPacket != 0 ) &&
           ( FullMdl != NULL )) {

        BytesThisMdl = MIN( BytesThisMdl, BytesThisPacket );

        //
        //  Some of the data fits in the first part of the MDL;
        //

        ReceiveMdl = ALLOCATE_MDL(
                         BufferStart,
                         BytesThisMdl,
                         FALSE,
                         FALSE,
                         NULL );

        if ( ReceiveMdl == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        if ( InitialMdl == NULL ) {
            InitialMdl = ReceiveMdl;
        }

        IoBuildPartialMdl(
            FullMdl,
            ReceiveMdl,
            BufferStart,
            BytesThisMdl );

        if ( PreviousReceiveMdl != NULL ) {
            PreviousReceiveMdl->Next = ReceiveMdl;
        }

        PreviousReceiveMdl = ReceiveMdl;

        BytesThisPacket -= BytesThisMdl;

        FullMdl = FullMdl->Next;

        if ( FullMdl != NULL) {
            BytesThisMdl = MmGetMdlByteCount( FullMdl );
            BufferStart = MmGetMdlVirtualAddress( FullMdl );
        }

    }

    if ( Status == STATUS_INSUFFICIENT_RESOURCES ) {

        //
        //  Cleanup allocated MDLs
        //

        while ( InitialMdl != NULL ) {
            NextMdl = InitialMdl->Next;
            FREE_MDL( InitialMdl );
            InitialMdl = NextMdl;
        }

        DebugTrace( 0, Dbg, "AllocateReceivePartialMdl Failed\n", 0 );
    }

    DebugTrace( 0, Dbg, "AllocateReceivePartialMdl -> %08lX\n", InitialMdl );
    return( InitialMdl );
}


VOID
SetConnectionTimeout(
    PNONPAGED_SCB pNpScb,
    ULONG Length
    )
/*++

Routine Description:


    The server will pause NwReceiveDelay between packets. Make sure we have our timeout
    so that we will take that into account.

Arguments:

    pNpScb  - Connection

    Length  - Length of the burst in bytes

Return Value:

    None.

--*/
{

    ULONG TimeInNwUnits;
    LONG SingleTimeInNwUnits;

    SingleTimeInNwUnits = pNpScb->NwSingleBurstPacketTime + pNpScb->NwReceiveDelay;

    TimeInNwUnits = SingleTimeInNwUnits * ((Length / pNpScb->MaxPacketSize) + 1) +
        pNpScb->NwLoopTime;

    //
    //  Convert to 1/18ths of a second ticks and multiply by a fudge
    //  factor. The fudge factor is expressed as a percentage. 100 will
    //  mean no fudge.
    //

    pNpScb->MaxTimeOut = (SHORT)( ((TimeInNwUnits / 555) *
                                   (ULONG)ReadTimeoutMultiplier) / 100 + 1);

    //
    // Now make sure we have a meaningful lower and upper limit.
    //
    if (pNpScb->MaxTimeOut < 2)
    {
        pNpScb->MaxTimeOut = 2 ;
    }

    if (pNpScb->MaxTimeOut > (SHORT)MaxReadTimeout)
    {
        pNpScb->MaxTimeOut = (SHORT)MaxReadTimeout ;
    }

    pNpScb->TimeOut = pNpScb->SendTimeout = pNpScb->MaxTimeOut;

    DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->MaxTimeout = %08lx\n", pNpScb->MaxTimeOut );
}

#if NWFASTIO

BOOLEAN
NwFastRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine does a fast cached read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcCopyRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    NODE_TYPE_CODE nodeTypeCode;
    PICB icb;
    PFCB fcb;
    PVOID fsContext;
    ULONG bytesRead;
    ULONG offset;

    try {
        FsRtlEnterFileSystem();

        DebugTrace(+1, Dbg, "NwFastRead...\n", 0);
    
        //
        //  Special case a read of zero length
        //
    
        if (Length == 0) {
    
            //
            //  A zero length transfer was requested.
            //
    
            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = 0;
    
            DebugTrace(+1, Dbg, "NwFastRead -> TRUE\n", 0);
            return TRUE;
        }
    
        //
        // Decode the file object to figure out who we are.  If the result
        // is not FCB then its an illegal parameter.
        //
    
        if ((nodeTypeCode = NwDecodeFileObject( FileObject,
                                                &fsContext,
                                                (PVOID *)&icb )) != NW_NTC_ICB) {
    
            DebugTrace(0, Dbg, "Not a file\n", 0);
            DebugTrace(-1, Dbg, "NwFastRead -> FALSE\n", 0);
            return FALSE;
        }
    
        fcb = (PFCB)icb->SuperType.Fcb;
        nodeTypeCode = fcb->NodeTypeCode;
        offset = FileOffset->LowPart;
    
        bytesRead = CacheRead(
                        fcb->NonPagedFcb,
                        offset,
                        Length,
                        Buffer,
                        TRUE );
    
        if ( bytesRead != 0 ) {
    
            ASSERT( bytesRead == Length );
            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = bytesRead;
    #ifndef NT1057
            FileObject->CurrentByteOffset.QuadPart = FileOffset->QuadPart + bytesRead;
    #endif
            DebugTrace(-1, Dbg, "NwFastRead -> TRUE\n", 0);
            return( TRUE );
    
        } else {
    
            DebugTrace(-1, Dbg, "NwFastRead -> FALSE\n", 0);
            return( FALSE );
    
        }
    } finally {

        FsRtlExitFileSystem();
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\strucsup.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    strucsup.c

Abstract:

    This module implements the Netware Redirector structure support routines.

Author:

    Manny Weiser (mannyw)    10-Feb-1993

Revision History:

--*/
#include "procs.h"

BOOLEAN
GetLongNameSpaceForVolume(
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING ShareName,
    OUT PCHAR VolumeLongNameSpace,
    OUT PCHAR VolumeNumber
    );

CHAR
GetNewDriveNumber (
    IN PSCB Scb
    );

VOID
FreeDriveNumber(
    IN PSCB Scb,
    IN CHAR DriveNumber
    );

#define Dbg                              (DEBUG_TRACE_STRUCSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwInitializeRcb )
#pragma alloc_text( PAGE, NwDeleteRcb )
#pragma alloc_text( PAGE, NwCreateIcb )
#pragma alloc_text( PAGE, NwDeleteIcb )
#pragma alloc_text( PAGE, NwVerifyIcb )
#pragma alloc_text( PAGE, NwVerifyIcbSpecial )
#pragma alloc_text( PAGE, NwInvalidateAllHandlesForScb )
#pragma alloc_text( PAGE, NwVerifyScb )
#pragma alloc_text( PAGE, NwCreateFcb )
#pragma alloc_text( PAGE, NwFindFcb )
#pragma alloc_text( PAGE, NwDereferenceFcb )
#pragma alloc_text( PAGE, NwFindVcb )
#pragma alloc_text( PAGE, NwCreateVcb )
#pragma alloc_text( PAGE, NwReopenVcbHandlesForScb )
#pragma alloc_text( PAGE, NwReopenVcbHandle )
#ifdef NWDBG
#pragma alloc_text( PAGE, NwReferenceVcb )
#endif
#pragma alloc_text( PAGE, NwDereferenceVcb )
#pragma alloc_text( PAGE, NwCleanupVcb )
#pragma alloc_text( PAGE, GetLongNameSpaceForVolume )
#pragma alloc_text( PAGE, IsFatNameValid )
#pragma alloc_text( PAGE, GetNewDriveNumber )
#pragma alloc_text( PAGE, FreeDriveNumber )
#pragma alloc_text( PAGE, NwFreeDirCacheForIcb )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, NwInvalidateAllHandles )
#pragma alloc_text( PAGE1, NwCloseAllVcbs )
#endif

#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif

VOID
NwInitializeRcb (
    IN PRCB Rcb
    )

/*++

Routine Description:

    This routine initializes new Rcb record.

Arguments:

    Rcb - Supplies the address of the Rcb record being initialized.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwInitializeRcb, Rcb = %08lx\n", (ULONG_PTR)Rcb);

    //
    // We start by first zeroing out all of the RCB, this will guarantee
    // that any stale data is wiped clean.
    //

    RtlZeroMemory( Rcb, sizeof(RCB) );

    //
    // Set the node type code, node byte size, and reference count.
    //

    Rcb->NodeTypeCode = NW_NTC_RCB;
    Rcb->NodeByteSize = sizeof(RCB);
    Rcb->OpenCount = 0;

    //
    // Initialize the resource variable for the RCB.
    //

    ExInitializeResourceLite( &Rcb->Resource );

    //
    // Initialize the server name and file name tables.
    //

    RtlInitializeUnicodePrefix( &Rcb->ServerNameTable );
    RtlInitializeUnicodePrefix( &Rcb->VolumeNameTable );
    RtlInitializeUnicodePrefix( &Rcb->FileNameTable );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "NwInitializeRcb -> VOID\n", 0);

    return;
}


VOID
NwDeleteRcb (
    IN PRCB Rcb
    )

/*++

Routine Description:

    This routine removes the RCB record from our in-memory data
    structures.  It also will remove all associated underlings
    (i.e., FCB records).

Arguments:

    Rcb - Supplies the Rcb to be removed

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwDeleteRcb, Rcb = %08lx\n", (ULONG_PTR)Rcb);

    //
    // Uninitialize the resource variable for the RCB.
    //

    ExDeleteResourceLite( &Rcb->Resource );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "NwDeleteRcb -> VOID\n", 0);

    return;
}


PICB
NwCreateIcb (
    IN USHORT Type,
    IN PVOID Associate
    )

/*++

Routine Description:

    This routine allocates and initialize a new ICB.  The ICB is
    inserted into the FCB's list.

    *** This routine must be called with the RCB held exclusively.

Arguments:

    Type - The type of ICB this will be.

    Associate - A pointer to an associated data structure.
        It will be a FCB, DCB, or SCB.

Return Value:

    ICB - A pointer to the newly created ICB.

    If memory allocation fails, this routine will raise an exception.

--*/

{
    PICB Icb;
    PSCB Scb;

    PAGED_CODE();

    Icb = ALLOCATE_POOL_EX( NonPagedPool, sizeof( ICB ) );

    RtlZeroMemory( Icb, sizeof( ICB ) );

    Icb->NodeTypeCode = Type;
    Icb->NodeByteSize = sizeof( ICB );
    Icb->State = ICB_STATE_OPEN_PENDING;
    Icb->Pid = (UCHAR)INVALID_PID;

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    if ( Type == NW_NTC_ICB ) {

        PFCB Fcb = (PFCB)Associate;

        //
        //  Insert this ICB on the list of ICBs for this FCB.
        //

        InsertTailList( &Fcb->IcbList, &Icb->ListEntry );
        ++Fcb->IcbCount;
        Icb->SuperType.Fcb = Fcb;
        Icb->NpFcb = Fcb->NonPagedFcb;

        Fcb->Vcb->OpenFileCount++;
        Scb = Fcb->Scb;

        Scb->OpenFileCount++;

    } else if ( Type == NW_NTC_ICB_SCB ) {

        Scb = (PSCB)Associate;

        //
        //  Insert this ICB on the list of ICBs for this SCB.
        //

        InsertTailList( &Scb->IcbList, &Icb->ListEntry );
        ++Scb->IcbCount;
        Icb->SuperType.Scb = Scb;

    } else {

        KeBugCheck( RDR_FILE_SYSTEM );

    }

    InitializeListHead( &(Icb->DirCache) );

    NwReleaseRcb( &NwRcb );

    NwReferenceScb( Scb->pNpScb );
    return( Icb );
}


VOID
NwDeleteIcb (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PICB Icb
    )

/*++

Routine Description:

    This routine deletes an ICB in the OPEN_PENDING state.

    ***  The IRP context must be at the head of the SCB queue when
         this routine is called.

Arguments:

    Icb - A pointer the ICB to delete.

Return Value:

    None.

--*/

{
    PFCB Fcb;
    PSCB Scb;

    PAGED_CODE();

    //
    // Acquire the lock to protect the ICB list.
    //
    DebugTrace( 0, DEBUG_TRACE_ICBS, "NwDeleteIcb, Icb = %08lx\n", (ULONG_PTR)Icb);

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    RemoveEntryList( &Icb->ListEntry );

    if ( Icb->NodeTypeCode == NW_NTC_ICB ) {

        Fcb = Icb->SuperType.Fcb;
        Scb = Fcb->Scb;

        //
        //  Decrement the open file count for the VCB.  Note that the ICB
        //  only reference the VCB indirectly via the FCB, so that we do
        //  not dereference the VCB here.
        //

        --Fcb->Vcb->OpenFileCount;
        --Scb->OpenFileCount;

        //
        //  Dereference the FCB.  This frees the FCB if
        //  this was the last ICB for the FCB.
        //

        NwDereferenceFcb( IrpContext, Fcb );

    } else if ( Icb->NodeTypeCode == NW_NTC_ICB_SCB ) {

        Scb = Icb->SuperType.Scb;

        //
        // Decrement of OpenIcb count on the SCB.
        //

        Scb->IcbCount--;

    } else {
        KeBugCheck( RDR_FILE_SYSTEM );
    }

    //
    //  Free the query template buffers.
    //

    RtlFreeOemString( &Icb->NwQueryTemplate );

    if ( Icb->UQueryTemplate.Buffer != NULL ) {
        FREE_POOL( Icb->UQueryTemplate.Buffer );
    }

    //
    // Try and gracefully catch a 16 bit app closing a
    // handle to the server and wipe the connection as
    // soon as possible.  This only applies to bindery
    // authenticated connections because in NDS land,
    // we handle the licensing of the connection
    // dynamically.
    //

    if ( ( Scb->pNpScb->Reference == 1 ) &&
         ( Icb->NodeTypeCode == NW_NTC_ICB_SCB ) &&
         ( !Icb->IsTreeHandle ) &&
         ( IrpContext != NULL ) &&
         ( Scb->UserName.Length != 0 ) )
    {
        LARGE_INTEGER Now;
        KeQuerySystemTime( &Now );

        DebugTrace( 0, Dbg, "Quick disconnecting 16-bit app.\n", 0 );

        NwAppendToQueueAndWait( IrpContext );

        if ( Scb->OpenFileCount == 0 &&
             Scb->pNpScb->State != SCB_STATE_RECONNECT_REQUIRED &&
             !Scb->PreferredServer ) {

            NwLogoffAndDisconnect( IrpContext, Scb->pNpScb);
        }

        Now.QuadPart += ( NwOneSecond * DORMANT_SCB_KEEP_TIME );

        NwDequeueIrpContext( IrpContext, FALSE );
        NwDereferenceScb( Scb->pNpScb );
        DisconnectTimedOutScbs(Now) ;
        CleanupScbs(Now);

    } else {

        NwDereferenceScb( Scb->pNpScb );

    }

    NwFreeDirCacheForIcb( Icb );

    FREE_POOL( Icb );
    NwReleaseRcb( &NwRcb );
}

VOID
NwVerifyIcb (
    IN PICB Icb
    )

/*++

Routine Description:

    This routine verifies that an ICB is in the opened state.
    If it is not, the routine raises an exception.

Arguments:

    Icb - A pointer the ICB to verify.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    if ( Icb->State != ICB_STATE_OPENED ) {
        ExRaiseStatus( STATUS_INVALID_HANDLE );
    }
}

VOID
NwVerifyIcbSpecial (
    IN PICB Icb
    )

/*++

Routine Description:

    This routine verifies that an ICB is in the opened state.
    If it is not, the routine raises an exception.

Arguments:

    Icb - A pointer the ICB to verify.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    if ( (Icb->State != ICB_STATE_OPENED &&
          Icb->State != ICB_STATE_CLEANED_UP) ) {
        ExRaiseStatus( STATUS_INVALID_HANDLE );
    }
}


ULONG
NwInvalidateAllHandles (
    PLARGE_INTEGER Uid OPTIONAL,
    PIRP_CONTEXT IrpContext OPTIONAL
    )

/*++

Routine Description:

    This routine finds all of the ICB in the system that were created
    by the user specified by the Logon credentials and marks them
    invalid.

Arguments:

    Uid - Supplies the userid of the handles to close or NULL if all
            handles to be invalidated.
    IrpContext - The Irpcontext to be used for the NwLogoffAndDisconnect
            call, if appropriate.  If this is NULL, it indicates a RAS
            transition.

Return Value:

    The number of active handles that were closed.

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY ScbQueueEntry, NextScbQueueEntry;
    PNONPAGED_SCB pNpScb;
    PSCB pScb;
    ULONG FilesClosed = 0;

    PAGED_CODE();

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    for (ScbQueueEntry = ScbQueue.Flink ;
         ScbQueueEntry != &ScbQueue ;
         ScbQueueEntry =  NextScbQueueEntry ) {

        pNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );

        pScb = pNpScb->pScb;
        if ( pScb != NULL ) {

            NwReferenceScb( pNpScb );

            //
            //  Release the SCB spin lock as we are about to touch nonpaged pool.
            //

            KeReleaseSpinLock( &ScbSpinLock, OldIrql );

            if ((Uid == NULL) ||
                ( pScb->UserUid.QuadPart == (*Uid).QuadPart)) {


                NwAcquireExclusiveRcb( &NwRcb, TRUE );
                FilesClosed += NwInvalidateAllHandlesForScb( pScb );
                NwReleaseRcb( &NwRcb );

                if ( IrpContext ) {

                    IrpContext->pNpScb = pNpScb;
                    NwLogoffAndDisconnect( IrpContext , pNpScb);
                    NwDequeueIrpContext( IrpContext, FALSE );

                } else {

                    //
                    // No IrpContext means that a RAS transition has occurred.
                    // Let's try to keep our Netware servers happy if the net
                    // is still attached.
                    //

                    PIRP_CONTEXT LocalIrpContext;
                    if (NwAllocateExtraIrpContext(&LocalIrpContext, pNpScb)) {

                        //  Lock down so that we can send a packet.
                        NwReferenceUnlockableCodeSection();

                        LocalIrpContext->pNpScb = pNpScb;
                        NwLogoffAndDisconnect( LocalIrpContext, pNpScb);

                        NwAppendToQueueAndWait( LocalIrpContext );

                        NwDequeueIrpContext( LocalIrpContext, FALSE );
                        NwDereferenceUnlockableCodeSection ();
                        NwFreeExtraIrpContext( LocalIrpContext );

                    }

                    //
                    // Clear the LIP data speed.
                    //

                    pNpScb->LipDataSpeed = 0;
                    pNpScb->State = SCB_STATE_ATTACHING;

                }


            }

            KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

            NwDereferenceScb( pNpScb );
        }

        NextScbQueueEntry = pNpScb->ScbLinks.Flink;
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    return( FilesClosed );
}

ULONG
NwInvalidateAllHandlesForScb (
    PSCB Scb
    )
/*++

Routine Description:

    This routine finds all of the ICB in for an SCB and marks them
    invalid.

    *** The caller must own the RCB shared or exclusive.

Arguments:

    SCB -  A pointer to the SCB whose files are closed.

Return Value:

    The number of files that were closed.

--*/

{
    PLIST_ENTRY VcbQueueEntry;
    PLIST_ENTRY FcbQueueEntry;
    PLIST_ENTRY IcbQueueEntry;
    PVCB pVcb;
    PFCB pFcb;
    PICB pIcb;

    ULONG FilesClosed = 0;

    PAGED_CODE();

    //
    //  Walk the list of VCBs for this SCB
    //

    for ( VcbQueueEntry = Scb->ScbSpecificVcbQueue.Flink;
          VcbQueueEntry != &Scb->ScbSpecificVcbQueue;
          VcbQueueEntry = VcbQueueEntry->Flink ) {

        pVcb = CONTAINING_RECORD( VcbQueueEntry, VCB, VcbListEntry );

        if ( !BooleanFlagOn( pVcb->Flags, VCB_FLAG_PRINT_QUEUE ) ) {
            pVcb->Specific.Disk.Handle = (CHAR)-1;
        }

        //
        //  Walk the list of FCBs and DCSs for this VCB
        //

        for ( FcbQueueEntry = pVcb->FcbList.Flink;
              FcbQueueEntry != &pVcb->FcbList;
              FcbQueueEntry = FcbQueueEntry->Flink ) {

            pFcb = CONTAINING_RECORD( FcbQueueEntry, FCB, FcbListEntry );

            //
            //  Walk the list of ICBs for this FCB or DCB
            //

            for ( IcbQueueEntry = pFcb->IcbList.Flink;
                  IcbQueueEntry != &pFcb->IcbList;
                  IcbQueueEntry = IcbQueueEntry->Flink ) {

                pIcb = CONTAINING_RECORD( IcbQueueEntry, ICB, ListEntry );

                //
                //  Mark the ICB handle invalid.
                //

                pIcb->State = ICB_STATE_CLOSE_PENDING;
                pIcb->HasRemoteHandle = FALSE;
                FilesClosed++;
            }
        }
    }

    return( FilesClosed );
}


VOID
NwVerifyScb (
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine verifies that an SCB is in the opened state.
    If it is not, the routine raises an exception.

Arguments:

    Scb - A pointer the SCB to verify.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    if ( Scb->pNpScb->State == SCB_STATE_FLAG_SHUTDOWN ) {
        ExRaiseStatus( STATUS_INVALID_HANDLE );
    }
}


PFCB
NwCreateFcb (
    IN PUNICODE_STRING FileName,
    IN PSCB Scb,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine allocates and initialize a new FCB.  The FCB is
    inserted into the RCB prefix table.

    *** This routine must be called with the RCB held exclusively.

Arguments:

    FileName - The name of the file to create.

    Scb - A pointer to the SCB for this file.

    Vcb - A pointer to the VCB for the file.

Return Value:

    FCB - A pointer to the newly created DCB.

    If memory allocation fails, this routine will raise an exception.

--*/

{
    PFCB Fcb;
    PNONPAGED_FCB NpFcb;
    PWCH FileNameBuffer;
    SHORT Length;

    PAGED_CODE();

    Fcb = NULL;
    NpFcb = NULL;

    try {

        //
        //  Allocate and initialize structures.
        //

        Fcb = ALLOCATE_POOL_EX(
                  PagedPool,
                  sizeof( FCB ) + FileName->Length + sizeof(WCHAR));

        RtlZeroMemory( Fcb, sizeof( FCB ) );
        Fcb->NodeTypeCode = NW_NTC_FCB;
        Fcb->NodeByteSize = sizeof( FCB ) + FileName->Length;
        Fcb->State = FCB_STATE_OPEN_PENDING;

        InitializeListHead( &Fcb->IcbList );

        Fcb->Vcb = Vcb;
        Fcb->Scb = Scb;

        FileNameBuffer = (PWCH)(Fcb + 1);

        NpFcb = ALLOCATE_POOL_EX( NonPagedPool, sizeof( NONPAGED_FCB ) );
        RtlZeroMemory( NpFcb, sizeof( NONPAGED_FCB ) );

        NpFcb->Header.NodeTypeCode = NW_NTC_NONPAGED_FCB;
        NpFcb->Header.NodeByteSize = sizeof( NONPAGED_FCB );

        NpFcb->Fcb = Fcb;
        Fcb->NonPagedFcb = NpFcb;

        //
        // Initialize the resource variable for the FCB.
        //

        ExInitializeResourceLite( &NpFcb->Resource );

        //
        //  Initialize Advanced FCB Header fields
        //

        ExInitializeFastMutex( &NpFcb->AdvancedFcbHeaderMutex );
        FsRtlSetupAdvancedHeader( &NpFcb->Header, 
                                  &NpFcb->AdvancedFcbHeaderMutex );

        //
        //  Copy the file name
        //

        RtlCopyMemory( FileNameBuffer, FileName->Buffer, FileName->Length );
        Fcb->FullFileName.MaximumLength = FileName->Length;
        Fcb->FullFileName.Length = FileName->Length;
        Fcb->FullFileName.Buffer = FileNameBuffer;

        // Mapping for Novell's handling of Euro char in file names
        {
            int i = 0;
            WCHAR * pCurrChar = FileNameBuffer;
            for (i = 0; i < (FileName->Length / 2); i++)
            {
                if (*(pCurrChar + i) == (WCHAR) 0x20AC) // Its a Euro
                    *(pCurrChar + i) = (WCHAR) 0x2560;  // set it to Novell's mapping for Euro
            }
        }

        //
        //  The Relative name is normally the full name without the
        //  server and volume name.  Also strip the leading backslash.
        //

        Length = FileName->Length - Vcb->Name.Length - sizeof(L'\\');
        if ( Length < 0 ) {
            Length = 0;
        }

        Fcb->RelativeFileName.Buffer = (PWCH)
            ((PCHAR)FileNameBuffer + Vcb->Name.Length + sizeof(L'\\'));

        Fcb->RelativeFileName.MaximumLength = Length;
        Fcb->RelativeFileName.Length = Length;

        //
        //  Insert this file in the prefix table.
        //

        RtlInsertUnicodePrefix(
            &NwRcb.FileNameTable,
            &Fcb->FullFileName,
            &Fcb->PrefixEntry );

        //
        //  Insert this file into the VCB list, and increment the
        //  file open count.
        //

        NwReferenceVcb( Vcb );

        InsertTailList(
            &Vcb->FcbList,
            &Fcb->FcbListEntry );

        //
        //  Initialize the list of file locks for this FCB.
        //

        InitializeListHead( &NpFcb->FileLockList );
        InitializeListHead( &NpFcb->PendingLockList );

        //
        //  Set the long name bit if necessary
        //

        if ( Fcb->Vcb->Specific.Disk.LongNameSpace != LFN_NO_OS2_NAME_SPACE ) {

            //
            // OBSCURE CODE POINT
            //
            // By default FavourLongNames is not set and we use DOS name
            // space unless we know we have to use LFN. Reason is if we
            // start using LFN then DOS apps that dont handle longnames
            // will give us short names and we are hosed because we are
            // using LFN NCPs that dont see the short names. Eg. without
            // the check below, the following will fail (assume mv.exe is
            // DOS app).
            //
            // cd public\longnamedir
            // mv foo bar
            //
            // This is because we will get call with public\longname\foo
            // and the truncated dir name is not accepted. If user values
            // case sensitivity, they can set this reg value and we will
            // use LFN even for short names. They sacrifice the scenario
            // above.
            //
            if ( FavourLongNames || !IsFatNameValid( &Fcb->RelativeFileName ) ) {

                SetFlag( Fcb->Flags, FCB_FLAGS_LONG_NAME );
            }
        }

    } finally {
        if ( AbnormalTermination() ) {
            if ( Fcb != NULL ) FREE_POOL( Fcb );
            if ( NpFcb != NULL ) FREE_POOL( NpFcb );
        }
    }

    return( Fcb );
}


PFCB
NwFindFcb (
    IN PSCB Scb,
    IN PVCB Vcb,
    IN PUNICODE_STRING FileName,
    IN PDCB Dcb OPTIONAL
    )

/*++

Routine Description:

    This routine find an existing FCB by matching the file name.
    If a match is find the FCB reference count is incremented.
    If no match is found an FCB is created.

Arguments:

    Scb - A pointer to the server for this open.

    FileName - The name of the file to find.

    Dcb - A pointer to the DCB for relative opens.  If NULL the FileName
        is an full path name.  If non NUL the FileName is relative to
        this directory.


Return Value:

    FCB - A pointer to the found or newly created DCB.

    If memory allocation fails, this routine will raise an exception.

--*/

{
    PFCB Fcb;
    PUNICODE_PREFIX_TABLE_ENTRY Prefix;
    UNICODE_STRING FullName;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFindFcb\n", 0);
    ASSERT( Scb->NodeTypeCode == NW_NTC_SCB );

    if ( Dcb == NULL ) {

        MergeStrings( &FullName,
            &Scb->UnicodeUid,
            FileName,
            PagedPool );

    } else {

        //
        // Construct full name, ensuring we don't cause overflow
        //

        if ((ULONG)(Dcb->FullFileName.Length + FileName->Length) > (0xFFFF - 2)) {

            return NULL;
        }

        FullName.Length = Dcb->FullFileName.Length + FileName->Length + 2;
        FullName.MaximumLength = FullName.Length;
        FullName.Buffer = ALLOCATE_POOL_EX( PagedPool, FullName.Length );

        RtlCopyMemory(
            FullName.Buffer,
            Dcb->FullFileName.Buffer,
            Dcb->FullFileName.Length );

        FullName.Buffer[ Dcb->FullFileName.Length / sizeof(WCHAR) ] = L'\\';

        RtlCopyMemory(
            FullName.Buffer + Dcb->FullFileName.Length / sizeof(WCHAR) + 1,
            FileName->Buffer,
            FileName->Length );
    }

    DebugTrace( 0, Dbg, " ->FullName               = ""%wZ""\n", &FullName);

    //
    //  Strip the trailing '\' if there is one.
    //

    if ( FullName.Buffer[ FullName.Length/sizeof(WCHAR) - 1] == L'\\' ) {
        FullName.Length -= sizeof(WCHAR);
    }

    Fcb = NULL;

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    Prefix = RtlFindUnicodePrefix( &NwRcb.FileNameTable, &FullName, 0 );

    if ( Prefix != NULL ) {
        Fcb = CONTAINING_RECORD( Prefix, FCB, PrefixEntry );

        if ( Fcb->FullFileName.Length != FullName.Length ) {

            //
            // This was not an exact match.  Ignore it.
            //                  or
            // This Fcb is for a share owned by another LogonId.
            //

            Fcb = NULL;
        }

     }

     try {
         if ( Fcb != NULL ) {
             DebugTrace(0, Dbg, "Found existing FCB = %08lx\n", Fcb);
         } else {
             Fcb = NwCreateFcb( &FullName, Scb, Vcb );
             DebugTrace(0, Dbg, "Created new FCB = %08lx\n", Fcb);
         }
     } finally {

         if ( FullName.Buffer != NULL ) {
             FREE_POOL( FullName.Buffer );
         }

         NwReleaseRcb( &NwRcb );
     }

     ASSERT( Fcb == NULL || Fcb->Scb == Scb );

     DebugTrace(-1, Dbg, "NwFindFcb\n", 0);
     return( Fcb );
}


VOID
NwDereferenceFcb(
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine decrement the ICB count for an FCB.  If the count
    goes to zero, cleanup the FCB.

    *** This routine must be called with the RCB held exclusively.

Arguments:

    FCB - A pointer to an FCB.

Return Value:

    None.

--*/

{
    PNONPAGED_FCB NpFcb;
    PLIST_ENTRY listEntry, nextListEntry;
    PNW_FILE_LOCK pFileLock;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwDereferenceFcb\n", 0);
    DebugTrace(0, Dbg, "New ICB count = %d\n", Fcb->IcbCount-1 );

    ASSERT( NodeType( Fcb ) == NW_NTC_FCB ||
            NodeType( Fcb ) == NW_NTC_DCB );

    if ( --Fcb->IcbCount == 0 ) {

        NpFcb = Fcb->NonPagedFcb;

        ASSERT( IsListEmpty( &Fcb->IcbList ) );

        //
        // If there are outstanding locks, clean them up.  This
        // happens when something causes a remote handle to get
        // closed before the cleanup routine is called by the
        // ios on the regular close path.
        //

        if ( !IsListEmpty( &NpFcb->FileLockList ) ) {

            DebugTrace( 0, Dbg, "Freeing stray locks on FCB %08lx\n", NpFcb );

            for ( listEntry = NpFcb->FileLockList.Flink;
                  listEntry != &NpFcb->FileLockList;
                  listEntry = nextListEntry ) {

                nextListEntry = listEntry->Flink;

                pFileLock = CONTAINING_RECORD( listEntry,
                                               NW_FILE_LOCK,
                                               ListEntry );

                RemoveEntryList( listEntry );
                FREE_POOL( pFileLock );
            }
        }

        if ( !IsListEmpty( &NpFcb->PendingLockList ) ) {

            DebugTrace( 0, Dbg, "Freeing stray pending locks on FCB %08lx\n", NpFcb );

            for ( listEntry = NpFcb->PendingLockList.Flink;
                  listEntry != &NpFcb->PendingLockList;
                  listEntry = nextListEntry ) {

                nextListEntry = listEntry->Flink;

                pFileLock = CONTAINING_RECORD( listEntry,
                                               NW_FILE_LOCK,
                                               ListEntry );

                RemoveEntryList( listEntry );
                FREE_POOL( pFileLock );
            }
        }

        //
        //  Delete the file now, if it is delete pending.
        //

        if ( BooleanFlagOn( Fcb->Flags, FCB_FLAGS_DELETE_ON_CLOSE ) ) {
            NwDeleteFile( IrpContext );
        }

        //
        //  Release any Filter Context structures associated with this FCB
        //

        FsRtlTeardownPerStreamContexts( &NpFcb->Header );

        //
        //  Remove this file in the prefix table.
        //

        RtlRemoveUnicodePrefix(
            &NwRcb.FileNameTable,
            &Fcb->PrefixEntry );

        //
        //  Remove this file from the SCB list, and decrement the
        //  file open count.
        //

        RemoveEntryList( &Fcb->FcbListEntry );
        NwDereferenceVcb( Fcb->Vcb, IrpContext, TRUE );

        //
        //  Delete the resource variable for the FCB.
        //

        ExDeleteResourceLite( &NpFcb->Resource );

        //
        //  Delete the cache buffer and MDL.
        //

        if ( NpFcb->CacheBuffer != NULL ) {
            FREE_POOL( NpFcb->CacheBuffer );
            FREE_MDL( NpFcb->CacheMdl );
        }

        //
        //  Finally free the paged and non-paged memory
        //

        FREE_POOL( Fcb );
        FREE_POOL( NpFcb );
    }

    DebugTrace(-1, Dbg, "NwDereferenceFcb\n", 0);
}


PVCB
NwFindVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING VolumeName,
    IN ULONG ShareType,
    IN WCHAR DriveLetter,
    IN BOOLEAN ExplicitConnection,
    IN BOOLEAN FindExisting
    )

/*++

Routine Description:

    This routine looks for a VCB structure.  If one is found, it
    is referenced and a pointer is returned.  If no VCB is found, an
    attempt is made to connect to the named volume and to create a VCB.

Arguments:

    IrpContext - A pointer to the IRP context block for this request.

    VolumeName - The minimum name of the volume.  This will be in one of
        the following forms:

        \SERVER\SHARE              UNC open server volume
        \TREE\VOLUME               UNC open tree volume in current context
        \TREE\PATH.TO.VOLUME       UNC open distinguished tree volume

        \X:\SERVER\SHARE           tree connect server volume
        \X:\TREE\VOLUME            tree connect tree volume in current context
        \X:\TREE\PATH.TO.VOLUME    tree connect distinguished tree volume

    ShareType - The type of the share to find.

    DriveLetter - The drive letter to find.  A - Z for drive letter, 1 - 9
        for LPT ports or 0 if none.

    ExplicitConnection - If TRUE, the caller is make an explicit connection
        to this Volume.  If FALSE, this is an implicit connection made by
        a UNC operation.

Return Value:

    VCB - Pointer to a found or newly created VCB.

--*/
{
    PVCB Vcb = NULL;
    BOOLEAN OwnRcb = TRUE;
    PUNICODE_PREFIX_TABLE_ENTRY Prefix;
    UNICODE_STRING UidVolumeName;
    PNONPAGED_SCB pNpScb = IrpContext->pScb->pNpScb;

    PAGED_CODE();

    UidVolumeName.Buffer = NULL;

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    try {

        MergeStrings( &UidVolumeName,
            &IrpContext->pScb->UnicodeUid,
            VolumeName,
            PagedPool );

        DebugTrace(+1, Dbg, "NwFindVcb %wZ\n", &UidVolumeName );

        if ( DriveLetter != 0 ) {

            //
            //  This is a drive relative path.  Look up the drive letter.
            //

            ASSERT( ( DriveLetter >= L'A' && DriveLetter <= L'Z' ) ||
                    ( DriveLetter >= L'1' && DriveLetter <= L'9' ) );
            if ( DriveLetter >= L'A' && DriveLetter <= L'Z' ) {
                PVCB * DriveMapTable = GetDriveMapTable( IrpContext->Specific.Create.UserUid );
                Vcb = DriveMapTable[DriveLetter - L'A'];
            } else {
                PVCB * DriveMapTable = GetDriveMapTable( IrpContext->Specific.Create.UserUid );
                Vcb = DriveMapTable[MAX_DISK_REDIRECTIONS + DriveLetter - L'1'];
        }

            //
            //  Was the Vcb created for this user?
            //

            if ((Vcb != NULL) &&
                (IrpContext->Specific.Create.UserUid.QuadPart != Vcb->Scb->UserUid.QuadPart )) {

                ExRaiseStatus( STATUS_ACCESS_DENIED );
            }

        } else {

            //
            //  This is a UNC path.  Look up the path name.
            //

            Prefix = RtlFindUnicodePrefix( &NwRcb.VolumeNameTable, &UidVolumeName, 0 );

            if ( Prefix != NULL ) {
                Vcb = CONTAINING_RECORD( Prefix, VCB, PrefixEntry );

                if ( Vcb->Name.Length != UidVolumeName.Length ) {

                    //
                    // This was not an exact match.  Ignore it.
                    //

                    Vcb = NULL;
                }
            }
        }

        if ( Vcb != NULL ) {

            //
            //  If this is an explicit use to a UNC path, we may find an
            //  existing VCB structure.  Mark this structure, and reference it.
            //

            if ( !BooleanFlagOn( Vcb->Flags, VCB_FLAG_EXPLICIT_CONNECTION ) &&
                 ExplicitConnection ) {

                NwReferenceVcb( Vcb );
                SetFlag( Vcb->Flags, VCB_FLAG_EXPLICIT_CONNECTION );
                SetFlag( Vcb->Flags, VCB_FLAG_DELETE_IMMEDIATELY );

                //
                //  Count this as an open file on the SCB.
                //

                ++Vcb->Scb->OpenFileCount;
            }

            NwReferenceVcb( Vcb );
            DebugTrace(0, Dbg, "Found existing VCB = %08lx\n", Vcb);

            //
            // If this VCB is queued to a different SCB as may
            // happen when we are resolving NDS UNC names, we
            // need to re-point the irpcontext at the correct SCB.
            // We can't hold the RCB or the open lock while we do
            // this!
            //
            // It is ok to release the open lock since we know
            // that we have an already created VCB and that we're
            // not creating a new vcb.
            //

            if ( Vcb->Scb != IrpContext->pScb ) {

               NwReferenceScb( Vcb->Scb->pNpScb );

               NwReleaseOpenLock( );

               NwReleaseRcb( &NwRcb );
               OwnRcb = FALSE;

               NwDequeueIrpContext( IrpContext, FALSE );
               NwDereferenceScb( IrpContext->pNpScb );

               IrpContext->pScb = Vcb->Scb;
               IrpContext->pNpScb = Vcb->Scb->pNpScb;

               NwAppendToQueueAndWait( IrpContext );

               NwAcquireOpenLock( );

           }

        } else if ( !FindExisting ) {

            //
            // Can't hold the RCB while creating a new VCB.
            //

            NwReleaseRcb( &NwRcb );
            OwnRcb = FALSE;

            Vcb = NwCreateVcb(
                      IrpContext,
                      IrpContext->pScb,
                      &UidVolumeName,
                      ShareType,
                      DriveLetter,
                      ExplicitConnection );

            if ( Vcb ) {
                DebugTrace(0, Dbg, "Created new VCB = %08lx\n", Vcb);
            }

        } else {

            //
            // If we didn't find anything and don't want
            // to do a create, make sure the caller doesn't
            // try to process the nds path.
            //

            IrpContext->Specific.Create.NeedNdsData = FALSE;
        }

    } finally {

        if ( OwnRcb ) {
            NwReleaseRcb( &NwRcb );
        }

        if (UidVolumeName.Buffer != NULL) {
            FREE_POOL( UidVolumeName.Buffer );
        }
    }

    DebugTrace(-1, Dbg, "NwFindVcb\n", 0);
    return( Vcb );

}

PVCB
NwCreateVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PUNICODE_STRING VolumeName,
    IN ULONG ShareType,
    IN WCHAR DriveLetter,
    IN BOOLEAN ExplicitConnection
    )

/*++

Routine Description:

    This routine allocates and initialize a new VCB.  The
    workstation tries to connect to the Volume.  If successful
    it creates a VCB and it is inserted into the volume
    prefix table.

Arguments:

    IrpContext - A pointer to IRP context information.

    Scb - A pointer to the SCB for this volume.

    VolumeName - The name of the volume to create.

    ShareType - The type of share to create.

    DriveLetter - The drive letter assigned to this volume, or 0 if none.

    ExplicitConnection - TRUE if we are creating this VCB due to an
        add connection request.  FALSE if we are creating the VCB to
        service a UNC request.

Return Value:

    VCB - A pointer to the newly created DCB.
    NULL - Could not create a DCB, or failed to connect to the volume.

--*/

{
    PVCB Vcb;
    PWCH VolumeNameBuffer;
    PWCH ShareNameBuffer;
    PWCH ConnectNameBuffer;
    UCHAR DirectoryHandle;
    ULONG QueueId;
    BYTE *pbQueue, *pbRQueue;
    BOOLEAN PrintQueue = FALSE;
    NTSTATUS Status;
    CHAR LongNameSpace = LFN_NO_OS2_NAME_SPACE;
    CHAR VolumeNumber = -1;
    CHAR DriveNumber = 0;
    USHORT PreludeLength, ConnectNameLength;
    PNONPAGED_SCB NpScb = Scb->pNpScb;

    UNICODE_STRING ShareName;
    UNICODE_STRING LongShareName;
    PWCH p;

    BOOLEAN InsertedColon;
    BOOLEAN LongName = FALSE;
    BOOLEAN LicensedConnection = FALSE;

    PUNICODE_STRING puConnectName;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwCreateVcb\n", 0);
    DebugTrace( 0, Dbg, " ->Server                   = %wZ\n", &NpScb->ServerName );
    DebugTrace( 0, Dbg, " ->VolumeName               = %wZ\n", VolumeName );
    DebugTrace( 0, Dbg, " ->DriveLetter              = %x\n", DriveLetter );

    Vcb = NULL;
    ShareName.Buffer = NULL;

    if ( IrpContext != NULL &&
         IrpContext->Specific.Create.NdsCreate ) {

        //
        // If we don't have the NDS data for this create, bail out
        // and have the create thread get the data before re-attempting
        // the create.  This is kind of weird, but we have to do it
        // so that we handle the open lock correctly and prevent
        // duplicate creates.
        //

        if ( IrpContext->Specific.Create.NeedNdsData ) {
            DebugTrace( -1, Dbg, "NwCreateVcb: Need NDS data to continue.\n", 0 );
            return NULL;
        }

        ConnectNameLength = IrpContext->Specific.Create.UidConnectName.Length;
        puConnectName = &IrpContext->Specific.Create.UidConnectName;

    } else {

       puConnectName = VolumeName;
       ConnectNameLength = 0;
    }

    DebugTrace( 0, Dbg, " ->ConnectName              = %wZ\n", puConnectName );

    if ( IrpContext != NULL) {

        //
        //  Build the share name from the volume name.
        //
        //  The share name will either be 'volume:' or 'volume:path\path'
        //

        //
        //  Allocate space for the share name buffer, and copy the volume
        //  name to the share name buffer, skipping the server name and
        //  the leading backslash.
        //

        if ( DriveLetter >= L'A' && DriveLetter <= L'Z' ) {

            if ( ShareType == RESOURCETYPE_PRINT ) {
                ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
            } else if ( ShareType == RESOURCETYPE_ANY) {
                ShareType = RESOURCETYPE_DISK;
            }

            PreludeLength = Scb->UidServerName.Length +
                sizeof( L"X:") + sizeof(WCHAR);

        } else if ( DriveLetter >= L'1' && DriveLetter <= L'9' ) {

            if ( ShareType == RESOURCETYPE_DISK ) {
                ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
            } else if ( ShareType == RESOURCETYPE_ANY) {
                ShareType = RESOURCETYPE_PRINT;
            }

            PreludeLength = Scb->UidServerName.Length +
                sizeof( L"LPTX") + sizeof(WCHAR);

        } else {
            PreludeLength = Scb->UidServerName.Length + sizeof(WCHAR);
        }

        //
        //  Quick check for bogus volume name.
        //

        if ( puConnectName->Length <= PreludeLength ) {
            ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
        }

        //
        // Clip the NDS share name at the appropriate spot.
        //

        if ( IrpContext->Specific.Create.NdsCreate ) {
            ShareName.Length = (USHORT)IrpContext->Specific.Create.dwNdsShareLength;
        } else {
            ShareName.Length = puConnectName->Length - PreludeLength;
        }

        ShareName.Buffer = ALLOCATE_POOL_EX( PagedPool, ShareName.Length + sizeof(WCHAR) );

        RtlMoveMemory(
            ShareName.Buffer,
            puConnectName->Buffer + PreludeLength / sizeof(WCHAR),
            ShareName.Length );

        ShareName.MaximumLength = ShareName.Length;

        DebugTrace( 0, Dbg, " ->ServerShare              = %wZ\n", &ShareName );

        //
        //  Create a long share name.
        //

        LongShareName.Length = ShareName.Length;
        LongShareName.Buffer = puConnectName->Buffer + PreludeLength / sizeof(WCHAR);

        //
        //  Now scan the share name for the 1st slash.
        //

        InsertedColon = FALSE;

        for ( p = ShareName.Buffer; p < ShareName.Buffer + ShareName.Length/sizeof(WCHAR); p++ ) {
            if ( *p == L'\\') {
                *p = L':';
                InsertedColon = TRUE;
                break;
            }
        }

        if ( !InsertedColon ) {

            //
            //  We need to append a column to generate the share name.
            //  Since we already allocated an extra WCHAR of buffer space,
            //  just append the ':' to the share name.
            //

            ShareName.Buffer[ShareName.Length / sizeof(WCHAR)] = L':';
            ShareName.Length += 2;
        }

        ASSERT( ShareType == RESOURCETYPE_ANY ||
                ShareType == RESOURCETYPE_DISK ||
                ShareType == RESOURCETYPE_PRINT );

        //
        // If there are no vcb's and no nds streams connected to this scb and
        // this is a Netware 4.x server that is NDS authenticated, then we
        // haven't yet licensed this connection and we should do so.
        //

        if ( ( IrpContext->pScb->MajorVersion > 3 ) &&
             ( IrpContext->pScb->UserName.Length == 0 ) &&
             ( IrpContext->pScb->VcbCount == 0 ) &&
             ( IrpContext->pScb->OpenNdsStreams == 0 ) ) {

                Status = NdsLicenseConnection( IrpContext );

                if ( !NT_SUCCESS( Status ) ) {
                    ExRaiseStatus( STATUS_REMOTE_SESSION_LIMIT );
                }

                LicensedConnection = TRUE;
        }

        if ( ShareType == RESOURCETYPE_ANY ||
             ShareType == RESOURCETYPE_DISK ) {

            GetLongNameSpaceForVolume(
                IrpContext,
                ShareName,
                &LongNameSpace,
                &VolumeNumber );

            //
            // TRACKING: If this is the deref of a directory map, the path we have
            // been provided may be the short name space path.  We don't know
            // how to get the long name path to connect up the long name space
            // for the user, which could cause problems...
            //

            if ( ( IrpContext->Specific.Create.NdsCreate ) &&
                 ( IrpContext->Specific.Create.dwNdsObjectType == NDS_OBJECTTYPE_DIRMAP ) ) {

                if ( ( LongNameSpace == LONG_NAME_SPACE_ORDINAL ) &&
                     ( IsFatNameValid( &LongShareName ) ) &&
                     ( !FavourLongNames ) )  {

                    LongNameSpace = LFN_NO_OS2_NAME_SPACE;
                }

            }

            //
            // Check to see if long names have been completely
            // disabled in the registry...
            //

            if ( LongNameFlags & LFN_FLAG_DISABLE_LONG_NAMES ) {
                LongNameSpace = LFN_NO_OS2_NAME_SPACE;
            }

            //
            //  Try to get a permanent handle to the volume.
            //

            if ( LongNameSpace == LFN_NO_OS2_NAME_SPACE ) {

                DriveNumber = GetNewDriveNumber(Scb);

                Status = ExchangeWithWait (
                             IrpContext,
                             SynchronousResponseCallback,
                             "SbbJ",
                             NCP_DIR_FUNCTION, NCP_ALLOCATE_DIR_HANDLE,
                             0,
                             DriveNumber,
                             &ShareName );

                if ( NT_SUCCESS( Status ) ) {
                    Status = ParseResponse(
                                  IrpContext,
                                  IrpContext->rsp,
                                  IrpContext->ResponseLength,
                                  "Nb",
                                  &DirectoryHandle );
                }

                if ( !NT_SUCCESS( Status ) ) {
                    FreeDriveNumber( Scb, DriveNumber );
                }

            } else {

                Status = ExchangeWithWait (
                             IrpContext,
                             SynchronousResponseCallback,
                             "LbbWbDbC",
                             NCP_LFN_ALLOCATE_DIR_HANDLE,
                             LongNameSpace,
                             0,
                             0,      // Mode = permanent
                             VolumeNumber,
                             LFN_FLAG_SHORT_DIRECTORY,
                             0xFF,   // Flag
                             &LongShareName );

                if ( NT_SUCCESS( Status ) ) {
                    Status = ParseResponse(
                                  IrpContext,
                                  IrpContext->rsp,
                                  IrpContext->ResponseLength,
                                  "Nb",
                                  &DirectoryHandle );
                }

                //
                // WARNING. See comment towards end of NwCreateFcb() !!!
                //
                if ( FavourLongNames || !IsFatNameValid( &LongShareName ) ) {
                    LongName = TRUE;
                }
            }

            if ( ( Status == STATUS_NO_SUCH_DEVICE ) &&
                 ( ShareType != RESOURCETYPE_ANY ) ) {

                //
                //  Asked for disk and it failed. If its ANY, then try print.
                //

                if (DriveNumber) {
                    FreeDriveNumber( Scb, DriveNumber );
                }

                FREE_POOL( ShareName.Buffer );

                if ( LicensedConnection ) {
                    NdsUnlicenseConnection( IrpContext );
                }

                ExRaiseStatus( STATUS_BAD_NETWORK_NAME );
                return( NULL );
            }

        }

        if ( ShareType == RESOURCETYPE_PRINT ||
             ( ShareType == RESOURCETYPE_ANY && !NT_SUCCESS( Status ) ) ) {

            //
            // Try to connect to a print queue.  If this is a bindery
            // server or an nds server with bindery emulation, we scan
            // the bindery for the QueueId.  Otherwise, the QueueId is
            // simply the ds object id with the byte ordering reversed.
            //

            ShareName.Length -= sizeof(WCHAR);

            if ( ( Scb->MajorVersion < 4 ) ||
                 ( !( IrpContext->Specific.Create.NdsCreate ) ) ) {

                Status = ExchangeWithWait(
                             IrpContext,
                             SynchronousResponseCallback,
                             "SdwJ",                // Format string
                             NCP_ADMIN_FUNCTION, NCP_SCAN_BINDERY_OBJECT,
                             -1,                    // Previous ID
                             OT_PRINT_QUEUE,
                             &ShareName );          // Queue Name

                if ( !NT_SUCCESS( Status ) ) {
                    Status = ExchangeWithWait(
                                 IrpContext,
                                 SynchronousResponseCallback,
                                 "SdwJ",                // Format string
                                 NCP_ADMIN_FUNCTION, NCP_SCAN_BINDERY_OBJECT,
                                 -1,                    // Previous ID
                                 OT_JOBQUEUE,
                                 &ShareName );          // Queue Name
                }

                if ( NT_SUCCESS( Status ) ) {
                    Status = ParseResponse(
                                 IrpContext,
                                 IrpContext->rsp,
                                 IrpContext->ResponseLength,
                                 "Nd",
                                 &QueueId );
                }

            } else {

                if ( IrpContext->Specific.Create.dwNdsObjectType == NDS_OBJECTTYPE_QUEUE ) {

                    DebugTrace( 0, Dbg, "Mapping NDS print queue %08lx\n",
                                IrpContext->Specific.Create.dwNdsOid );

                    pbQueue = (BYTE *)&IrpContext->Specific.Create.dwNdsOid;
                    pbRQueue = (BYTE *)&QueueId;

                    pbRQueue[0] = pbQueue[3];
                    pbRQueue[1] = pbQueue[2];
                    pbRQueue[2] = pbQueue[1];
                    pbRQueue[3] = pbQueue[0];

                    Status = STATUS_SUCCESS;

                } else {

                    DebugTrace( 0, Dbg, "Nds object is not a print queue.\n", 0 );
                    Status = STATUS_UNSUCCESSFUL;
                }
            }

            PrintQueue = TRUE;
        }

        if ( !NT_SUCCESS( Status ) ) {

            if (DriveNumber) {
                FreeDriveNumber( Scb, DriveNumber );
            }

            FREE_POOL( ShareName.Buffer );

            if ( LicensedConnection ) {
                NdsUnlicenseConnection( IrpContext );
            }

            ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
            return( NULL );
        }

    } else {
        DirectoryHandle = 1;
    }

    //
    //  Allocate and initialize structures.
    //

    try {

        Vcb = ALLOCATE_POOL_EX( PagedPool, sizeof( VCB ) +           // vcb
                                           VolumeName->Length +      // volume name
                                           ShareName.Length +        // share name
                                           ConnectNameLength );      // connect name

        RtlZeroMemory( Vcb, sizeof( VCB ) );
        Vcb->NodeTypeCode = NW_NTC_VCB;
        Vcb->NodeByteSize = sizeof( VCB ) +
                            VolumeName->Length +
                            ShareName.Length +
                            ConnectNameLength;

        InitializeListHead( &Vcb->FcbList );

        VolumeNameBuffer = (PWCH)(Vcb + 1);
        ShareNameBuffer = (PWCH)((PCHAR)VolumeNameBuffer + VolumeName->Length);
        ConnectNameBuffer = (PWCH)((PCHAR)ShareNameBuffer + ShareName.Length);

        Vcb->Reference = 1;

        //
        //  Copy the volume name
        //

        RtlCopyMemory( VolumeNameBuffer, VolumeName->Buffer, VolumeName->Length );
        Vcb->Name.MaximumLength = VolumeName->Length;
        Vcb->Name.Length = VolumeName->Length;
        Vcb->Name.Buffer = VolumeNameBuffer;

        //
        //  Copy the share name
        //

        if ( IrpContext != NULL) {

            RtlCopyMemory( ShareNameBuffer, ShareName.Buffer, ShareName.Length );
            Vcb->ShareName.MaximumLength = ShareName.Length;
            Vcb->ShareName.Length = ShareName.Length;
            Vcb->ShareName.Buffer = ShareNameBuffer;

        }

        //
        //  Copy the connect name
        //

        if ( ConnectNameLength ) {

            RtlCopyMemory( ConnectNameBuffer,
                           IrpContext->Specific.Create.UidConnectName.Buffer,
                           IrpContext->Specific.Create.UidConnectName.Length );
            Vcb->ConnectName.MaximumLength = IrpContext->Specific.Create.UidConnectName.Length;
            Vcb->ConnectName.Length = IrpContext->Specific.Create.UidConnectName.Length;
            Vcb->ConnectName.Buffer = ConnectNameBuffer;

        }

        if ( ExplicitConnection ) {

            //
            //  Bump the reference count to account for this drive being
            //  mapped via an explicit connection.
            //

            NwReferenceVcb( Vcb );
            SetFlag( Vcb->Flags, VCB_FLAG_EXPLICIT_CONNECTION );
            SetFlag( Vcb->Flags, VCB_FLAG_DELETE_IMMEDIATELY );

        }

        if ( LongName ) {
            SetFlag( Vcb->Flags, VCB_FLAG_LONG_NAME );
        }

        NwAcquireExclusiveRcb( &NwRcb, TRUE );

        if ( DriveLetter != 0) {

            //
            //  Insert this VCB in the drive map table.
            //

            if ( DriveLetter >= 'A' && DriveLetter <= 'Z' ) {
                PVCB * DriveMapTable = GetDriveMapTable( Scb->UserUid );            
                DriveMapTable[DriveLetter - 'A'] = Vcb;
            } else {
                PVCB * DriveMapTable = GetDriveMapTable( Scb->UserUid );
                DriveMapTable[MAX_DISK_REDIRECTIONS + DriveLetter - '1'] = Vcb;
            }

            Vcb->DriveLetter = DriveLetter;

        } else {

            //
            //  Insert this VCB in the prefix table.
            //

            RtlInsertUnicodePrefix(
                &NwRcb.VolumeNameTable,
                &Vcb->Name,
                &Vcb->PrefixEntry );
        }

        //
        //  Add this VCB to the global list.
        //

        InsertTailList( &GlobalVcbList, &Vcb->GlobalVcbListEntry );
        Vcb->SequenceNumber = CurrentVcbEntry++;

        //
        //  Insert this VCB in the per SCB list
        //

        Vcb->Scb = Scb;
        InsertTailList( &Scb->ScbSpecificVcbQueue,  &Vcb->VcbListEntry );
        ++Scb->VcbCount;
        NwReferenceScb( Scb->pNpScb );

        if ( ExplicitConnection ) {

            //
            //  Count this as an open file on the SCB.
            //

            ++Vcb->Scb->OpenFileCount;
        }

        //
        // tommye - MS bug 71690-  Calculate the path 
        //

        if ( Vcb->DriveLetter >= L'A' && Vcb->DriveLetter <= L'Z' ) {
            Vcb->Path.Buffer = Vcb->Name.Buffer + 3;
            Vcb->Path.Length = Vcb->Name.Length - 6;
        } else if ( Vcb->DriveLetter >= L'1' && Vcb->DriveLetter <= L'9' ) {
            Vcb->Path.Buffer = Vcb->Name.Buffer + 5;
            Vcb->Path.Length = Vcb->Name.Length - 10;
        } else {
            Vcb->Path = Vcb->Name;
        }

        // Strip off the unicode prefix
    
        Vcb->Path.Buffer		+= Vcb->Scb->UnicodeUid.Length/sizeof(WCHAR);
        Vcb->Path.Length		-= Vcb->Scb->UnicodeUid.Length;
        Vcb->Path.MaximumLength -= Vcb->Scb->UnicodeUid.Length;

        if ( !PrintQueue) {

            PLIST_ENTRY VcbQueueEntry;
            PVCB pVcb;

            Vcb->Specific.Disk.Handle = DirectoryHandle;
            Vcb->Specific.Disk.LongNameSpace = LongNameSpace;
            Vcb->Specific.Disk.VolumeNumber = VolumeNumber;
            Vcb->Specific.Disk.DriveNumber = DriveNumber;

            //
            //  Appears that some servers can reuse the same permanent drive handle.
            //  if this happens we want to make the old handle invalid otherwise
            //  we will keep on using the new volume as if its the old one.
            //

            for ( VcbQueueEntry = Scb->ScbSpecificVcbQueue.Flink;
                  VcbQueueEntry != &Scb->ScbSpecificVcbQueue;
                  VcbQueueEntry = pVcb->VcbListEntry.Flink ) {

                pVcb = CONTAINING_RECORD( VcbQueueEntry, VCB, VcbListEntry );

                if ( !BooleanFlagOn( pVcb->Flags, VCB_FLAG_PRINT_QUEUE ) ) {

                    if (( pVcb->Specific.Disk.Handle == DirectoryHandle ) &&
                        ( pVcb->Specific.Disk.VolumeNumber != VolumeNumber )) {
                        //  Invalidate the old handle
                        pVcb->Specific.Disk.Handle = (CHAR)-1;

                        //  We could assume that the new one is correct but I don't think we will....
                        Vcb->Specific.Disk.Handle = (CHAR)-1;
                        break;
                    }
                }
            }

        } else {
            SetFlag( Vcb->Flags, VCB_FLAG_PRINT_QUEUE );
            Vcb->Specific.Print.QueueId = QueueId;
        }

        NwReleaseRcb( &NwRcb );

    } finally {

        if ( AbnormalTermination() ) {

            if ( Vcb != NULL ) FREE_POOL( Vcb );

            if ( LicensedConnection ) {
                NdsUnlicenseConnection( IrpContext );
            }
        }

        if ( ShareName.Buffer != NULL ) {
            FREE_POOL( ShareName.Buffer );
        }

        DebugTrace(-1, Dbg, "NwCreateVcb %lx\n", Vcb);
    }

    return( Vcb );
}

VOID
NwReopenVcbHandlesForScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine reopens VCB handles after the autoreconnects to a server.

    ***  This IrpContext must already be at the head of the SCB queue.

Arguments:

    IrpContext - A pointer to IRP context information.

    Scb - A pointer to the SCB for this volume.

Return Value:

    None.

--*/

{
    PLIST_ENTRY VcbQueueEntry, NextVcbQueueEntry;
    PVCB pVcb;

    PLIST_ENTRY FcbQueueEntry;
    PLIST_ENTRY IcbQueueEntry;
    PFCB pFcb;
    PICB pIcb;

    NTSTATUS Status;

    PAGED_CODE();

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    //
    //  Walk the list of VCBs for this SCB
    //

    for ( VcbQueueEntry = Scb->ScbSpecificVcbQueue.Flink;
          VcbQueueEntry != &Scb->ScbSpecificVcbQueue;
          VcbQueueEntry = NextVcbQueueEntry ) {

        pVcb = CONTAINING_RECORD( VcbQueueEntry, VCB, VcbListEntry );

        if ( pVcb->Specific.Disk.Handle != 1 ) {

            //
            //  Skip reconnecting SYS:LOGIN, since we get it for free.
            //

            //
            //  Reference the VCB so it can't disappear on us, then release
            //  the RCB.
            //

            NwReferenceVcb( pVcb );
            NwReleaseRcb( &NwRcb );

            //
            //  Try to get a permanent handle to the volume.
            //

            if ( BooleanFlagOn( pVcb->Flags, VCB_FLAG_PRINT_QUEUE )  ) {

                Status = ExchangeWithWait(
                             IrpContext,
                             SynchronousResponseCallback,
                             "SdwU",               // Format string
                             NCP_ADMIN_FUNCTION, NCP_SCAN_BINDERY_OBJECT,
                             -1,                   // Previous ID
                             OT_PRINT_QUEUE,
                             &pVcb->ShareName );   // Queue Name

                if ( NT_SUCCESS( Status ) ) {
                    Status = ParseResponse(
                                  IrpContext,
                                  IrpContext->rsp,
                                  IrpContext->ResponseLength,
                                  "Nd",
                                  &pVcb->Specific.Print.QueueId );
                }

            } else {

                NwReopenVcbHandle( IrpContext, pVcb);

            }


            //
            // Setup for the next loop iteration.
            //

            NwAcquireExclusiveRcb( &NwRcb, TRUE );

            //
            //  Walk the list of DCSs for this VCB and make them all valid.
            //

            for ( FcbQueueEntry = pVcb->FcbList.Flink;
                  FcbQueueEntry != &pVcb->FcbList;
                  FcbQueueEntry = FcbQueueEntry->Flink ) {

                pFcb = CONTAINING_RECORD( FcbQueueEntry, FCB, FcbListEntry );

                if ( pFcb->NodeTypeCode == NW_NTC_DCB ) {

                    //
                    //  Walk the list of ICBs for this FCB or DCB
                    //

                    for ( IcbQueueEntry = pFcb->IcbList.Flink;
                          IcbQueueEntry != &pFcb->IcbList;
                          IcbQueueEntry = IcbQueueEntry->Flink ) {

                        pIcb = CONTAINING_RECORD( IcbQueueEntry, ICB, ListEntry );

                        //
                        //  Mark the ICB handle invalid.
                        //

                        pIcb->State = ICB_STATE_OPENED;
                    }
                }
            }

        }

        NextVcbQueueEntry = VcbQueueEntry->Flink;

        if ( pVcb->Specific.Disk.Handle != 1 ) {
            NwDereferenceVcb( pVcb, NULL, TRUE );
        }

    }

    NwReleaseRcb( &NwRcb );
}

VOID
NwReopenVcbHandle(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine reopens a VCB handle after it appears that the server
    may have dismounted and remounted the volume.

    ***  This IrpContext must already be at the head of the SCB queue.

Arguments:

    IrpContext - A pointer to IRP context information.

    Vcb - A pointer to the VCB for this volume.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT( Vcb->Scb->pNpScb->Requests.Flink == &IrpContext->NextRequest );

    if ( Vcb->Specific.Disk.LongNameSpace == LFN_NO_OS2_NAME_SPACE ) {

        Status = ExchangeWithWait (
                     IrpContext,
                     SynchronousResponseCallback,
                     "SbbJ",
                     NCP_DIR_FUNCTION, NCP_ALLOCATE_DIR_HANDLE,
                     0,
                     Vcb->Specific.Disk.DriveNumber,
                     &Vcb->ShareName );

    } else {
        UNICODE_STRING Name;

        PWCH thisChar, lastChar;

        Status = DuplicateUnicodeStringWithString (
                    &Name,
                    &Vcb->ShareName,
                    PagedPool);

        if ( !NT_SUCCESS( Status ) ) {
            //  Not much we can do now.
            return;
        }

        thisChar = Name.Buffer;
        lastChar = &Name.Buffer[ Name.Length / sizeof(WCHAR) ];

        //
        //  Change the : to a backslash so that FormatMessage works
        //

        while ( thisChar < lastChar ) {
            if (*thisChar == L':' ) {
                *thisChar = L'\\';
                break;
            }
            thisChar++;
        }

        Status = ExchangeWithWait (
                     IrpContext,
                     SynchronousResponseCallback,
                     "LbbWbDbC",
                     NCP_LFN_ALLOCATE_DIR_HANDLE,
                     Vcb->Specific.Disk.LongNameSpace,
                     0,
                     0,      // Mode = permanent
                     Vcb->Specific.Disk.VolumeNumber,
                     LFN_FLAG_SHORT_DIRECTORY,
                     0xFF,   // Flag
                     &Name );

        if ( Name.Buffer != NULL ) {
            FREE_POOL( Name.Buffer );
        }

    }


    if ( NT_SUCCESS( Status ) ) {
        Status = ParseResponse(
                      IrpContext,
                      IrpContext->rsp,
                      IrpContext->ResponseLength,
                      "Nb",
                      &Vcb->Specific.Disk.Handle );
    }

    if ( !NT_SUCCESS( Status ) ) {
        Vcb->Specific.Disk.Handle = (CHAR)-1;
    } else {

        PLIST_ENTRY VcbQueueEntry;
        PVCB pVcb;

        //
        //  Appears that some servers can reuse the same permanent drive handle.
        //  if this happens we want to make the old handle invalid otherwise
        //  we will keep on using the new volume as if its the old one.
        //
        //  Note that we reach the scb pointer from the npscb pointer because
        //  the scb pointer isn't always valid.  These few cases where only one
        //  pointer is set should be found and fixed.
        //

        for ( VcbQueueEntry = IrpContext->pNpScb->pScb->ScbSpecificVcbQueue.Flink;
              VcbQueueEntry != &IrpContext->pNpScb->pScb->ScbSpecificVcbQueue;
              VcbQueueEntry = pVcb->VcbListEntry.Flink ) {

            pVcb = CONTAINING_RECORD( VcbQueueEntry, VCB, VcbListEntry );

            if ( !BooleanFlagOn( pVcb->Flags, VCB_FLAG_PRINT_QUEUE ) ) {

                if (( pVcb->Specific.Disk.Handle == Vcb->Specific.Disk.Handle ) &&
                    ( pVcb->Specific.Disk.VolumeNumber != Vcb->Specific.Disk.VolumeNumber )) {
                    //  Invalidate the old handle
                    pVcb->Specific.Disk.Handle = (CHAR)-1;

                    //  We could assume that the new one is correct but I don't think we will....
                    Vcb->Specific.Disk.Handle = (CHAR)-1;
                    break;
                }
            }
        }
    }

}
#ifdef NWDBG

VOID
NwReferenceVcb (
    IN PVCB Vcb
    )
/*++

Routine Description:

    This routine increments the FCB count for a VCB.

Arguments:

    VCB - A pointer to an VCB.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwReferenceVcb %08lx\n", Vcb);
    DebugTrace(0, Dbg, "Current Reference count = %d\n", Vcb->Reference );

    ASSERT( NodeType( Vcb ) == NW_NTC_VCB );

    ++Vcb->Reference;

}
#endif


VOID
NwDereferenceVcb (
    IN PVCB Vcb,
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN BOOLEAN OwnRcb
    )
/*++

Routine Description:

    This routine decrement the FCB count for a VCB.
    If the count goes to zero, we record the time.  The scavenger
    thread will cleanup delete the VCB if it remains idle.

    This routine may be called with the RCB owned and the irpcontext
    at the head of the queue.  Be careful when dequeueing the irp
    context or acquiring any resources!

Arguments:

    VCB - A pointer to an VCB.

Return Value:

    None.

--*/

{
    PSCB Scb = Vcb->Scb;
    PNONPAGED_SCB pOrigNpScb = NULL;

#ifdef NWDBG
    BOOLEAN OwnRcbExclusive = FALSE;
#endif

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwDereferenceVcb %08lx\n", Vcb);

    ASSERT( NodeType( Vcb ) == NW_NTC_VCB );

#ifdef NWDBG

    //
    // A little extra lock checking.
    //

    OwnRcbExclusive = ExIsResourceAcquiredExclusiveLite( &(NwRcb.Resource) );

    if ( OwnRcb ) {
        ASSERT( OwnRcbExclusive );
    } else {
        ASSERT( !OwnRcbExclusive );
    }

#endif

    //
    // We have to get to the right scb queue before doing this
    // so that CleanupVcb unlicenses the correct connection.
    //

    if ( ( IrpContext ) &&
         ( IrpContext->pNpScb->pScb->MajorVersion > 3 ) &&
         ( IrpContext->pNpScb != Scb->pNpScb ) ) {

        if ( OwnRcb ) {
            NwReleaseRcb( &NwRcb );
        }

        pOrigNpScb = IrpContext->pNpScb;
        ASSERT( pOrigNpScb != NULL );

        NwDequeueIrpContext( IrpContext, FALSE );

        IrpContext->pScb = Scb;
        IrpContext->pNpScb = Scb->pNpScb;

        NwAppendToQueueAndWait( IrpContext );

        //
        // If the caller owned the RCB, we have to make sure
        // we re-acquire the RCB reference that we freed for
        // them so that they don't lose access to the resource
        // too early.
        //

        if ( OwnRcb ) {
            NwAcquireExclusiveRcb( &NwRcb, TRUE );
        }

    }

    //
    // Acquire the lock to protect the Reference count.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    DebugTrace(0, Dbg, "Current Reference count = %d\n", Vcb->Reference );
    --Vcb->Reference;

    if ( Vcb->Reference == 0 ) {
        if ( !BooleanFlagOn( Vcb->Flags, VCB_FLAG_DELETE_IMMEDIATELY ) ||
             IrpContext == NULL ) {

            //
            //  Either this is a UNC path, or we don't have an IRP context
            //  to do the VCB cleanup.  Simply timestamp the VCB and the
            //  scavenger will cleanup if the VCB remains idle.
            //

            KeQuerySystemTime( &Vcb->LastUsedTime );
            NwReleaseRcb( &NwRcb );

        } else {

            //
            //  This VCB is being explicitly deleted by the user.
            //  Make it go away now.  This will release the RCB.
            //

            NwCleanupVcb( Vcb, IrpContext );

        }

    } else {

        NwReleaseRcb( &NwRcb );
    }

    //
    // At this point, we've released our acquisition of the RCB, but
    // the caller may still own the RCB.  To prevent a deadlock, we
    // have to be careful when we put this irpcontext back on the
    // original server.
    //

    if ( pOrigNpScb ) {

        if ( OwnRcb ) {
            NwReleaseRcb( &NwRcb );
        }

        NwDequeueIrpContext( IrpContext, FALSE );

        IrpContext->pNpScb = pOrigNpScb;
        IrpContext->pScb = pOrigNpScb->pScb;

        NwAppendToQueueAndWait( IrpContext );

        //
        // Re-acquire for the caller.
        //

        if ( OwnRcb ) {
            NwAcquireExclusiveRcb( &NwRcb, TRUE );
        }

    }

    DebugTrace(-1, Dbg, "NwDereferenceVcb\n", 0);

}


VOID
NwCleanupVcb(
    IN PVCB pVcb,
    IN PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine cleans up and frees a VCB.

    This routine must be called with the RCB held to
    protect the drive map tables and unicode prefix
    tables.  The caller must own the IRP context at
    the head of the SCB queue.  This routine will
    free the RCB and dequeue the irp context.

Arguments:

    pVcb -  A pointer to the VCB to free.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    CHAR Handle;
    BOOLEAN CallDeleteScb = FALSE;
    PSCB pScb = pVcb->Scb;
    PNONPAGED_SCB pNpScb = pScb->pNpScb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwCleanupVcb...\n", 0);

    ASSERT( pVcb->NodeTypeCode == NW_NTC_VCB );
    ASSERT( IsListEmpty( &pVcb->FcbList ) );
    ASSERT( pVcb->OpenFileCount == 0 );

    DebugTrace(0, Dbg, "Cleaning Vcb %08lx\n", pVcb);

    //
    //  Remove the VCB from the drive map table.  The RCB is owned, so
    //  the drive map table and vcb lists are protected.
    //

    if ( pVcb->DriveLetter != 0 ) {
        PVCB * DriveMapTable = GetDriveMapTable( pScb->UserUid );
        if ( pVcb->DriveLetter >= L'A' && pVcb->DriveLetter <= L'Z' ) {
            DriveMapTable[pVcb->DriveLetter - L'A'] = NULL;
        } else {
            DriveMapTable[MAX_DISK_REDIRECTIONS + pVcb->DriveLetter - L'1'] = NULL;
        }

        if ( !BooleanFlagOn( pVcb->Flags, VCB_FLAG_PRINT_QUEUE )  ) {
            FreeDriveNumber( pVcb->Scb, pVcb->Specific.Disk.DriveNumber );
        }
    }

    //
    //  Remove the VCB from the Volume Name table.
    //

    RtlRemoveUnicodePrefix ( &NwRcb.VolumeNameTable, &pVcb->PrefixEntry );

    //
    //  Remove the VCB from the global list
    //

    RemoveEntryList( &pVcb->GlobalVcbListEntry );

    //
    //  Remove the VCB from our SCB's VCB list.
    //

    RemoveEntryList( &pVcb->VcbListEntry );

    --pScb->VcbCount;

    //
    // There is no server jumping allowed!!  We should have
    // pre-located the correct server to avoid deadlock problems.
    //

    ASSERT( IrpContext->pNpScb == pNpScb );

    //
    // If we are cleaning up the last vcb on an NDS server and
    // there are no open streams, we can unlicense the connection.
    //

    if ( ( pScb->MajorVersion > 3 ) &&
         ( pScb->UserName.Length == 0 ) &&
         ( pScb->VcbCount == 0 ) &&
         ( pScb->OpenNdsStreams == 0 ) ) {
        NdsUnlicenseConnection( IrpContext );
    }

    //
    //  If this is a VCB for a share, remove the volume handle.
    //

    if ( !BooleanFlagOn( pVcb->Flags, VCB_FLAG_PRINT_QUEUE )  ) {

        Handle = pVcb->Specific.Disk.Handle;

        Status = ExchangeWithWait (
                     IrpContext,
                     SynchronousResponseCallback,
                     "Sb",
                     NCP_DIR_FUNCTION, NCP_DEALLOCATE_DIR_HANDLE,
                     Handle );

        if ( NT_SUCCESS( Status )) {
            Status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "N" );
        }
    }

    //
    //  We can now free the VCB memory.
    //

    FREE_POOL( pVcb );

    //
    //  If there are no handles open (and hence no explicit connections)
    //  and this is a bindery login, then we should logout and disconnect
    //  from this server.  This is most important when a user has a
    //  login count on a server set to 1 and wants to access the server
    //  from another machine.
    //
    //  Release the RCB in case we get off the head of the queue in
    //  NwLogoffAndDisconnect.
    //

    NwReleaseRcb( &NwRcb );

    if ( ( pScb->IcbCount == 0 ) &&
         ( pScb->OpenFileCount == 0 ) &&
         ( pNpScb->State == SCB_STATE_IN_USE ) &&
         ( pScb->UserName.Length != 0 ) ) {

        NwLogoffAndDisconnect( IrpContext, pNpScb );
    }

    //
    // We might need to restore the server pointers.
    //

    NwDequeueIrpContext( IrpContext, FALSE );
    NwDereferenceScb( pScb->pNpScb );

    DebugTrace(-1, Dbg, "NwCleanupVcb exit\n", 0);
    return;
}

VOID
NwCloseAllVcbs(
    PIRP_CONTEXT pIrpContext
    )
/*++

Routine Description:

    This routine sends closes all open VCB handles.

Arguments:

    pIrpContext - The IRP context for this request.

Return Value:

    none.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY ScbQueueEntry, NextScbQueueEntry;
    PLIST_ENTRY VcbQueueEntry, NextVcbQueueEntry;
    PNONPAGED_SCB pNpScb;
    PSCB pScb;
    PVCB pVcb;
    BOOLEAN VcbDeleted;

    PAGED_CODE();

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    ScbQueueEntry = ScbQueue.Flink;

    if (ScbQueueEntry != &ScbQueue) {
        pNpScb = CONTAINING_RECORD(ScbQueueEntry,
                                                 NONPAGED_SCB,
                                                 ScbLinks);
        NwReferenceScb( pNpScb );
    }

    for (;
         ScbQueueEntry != &ScbQueue ;
         ScbQueueEntry =  NextScbQueueEntry ) {

        pNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );
        NextScbQueueEntry = pNpScb->ScbLinks.Flink;


        //
        // Reference the next entry in the list before letting go of the ScbSpinLock
        // to ensure that the scavenger doesn't destroy it.
        //
        
        if (NextScbQueueEntry != &ScbQueue) {
            PNONPAGED_SCB pNextNpScb = CONTAINING_RECORD(NextScbQueueEntry,
                                                         NONPAGED_SCB,
                                                         ScbLinks);
        
            NwReferenceScb( pNextNpScb );
        }
        
        pScb = pNpScb->pScb;

        if ( pScb == NULL ) {
            NwDereferenceScb( pNpScb );
            continue;
        }

        KeReleaseSpinLock( &ScbSpinLock, OldIrql );

        //
        // Get to the head of the SCB queue so that we don't deadlock
        // if we need to send packets in NwCleanupVcb().
        //

        pIrpContext->pNpScb = pNpScb;
        pIrpContext->pScb = pNpScb->pScb;

        NwAppendToQueueAndWait( pIrpContext );
        NwAcquireExclusiveRcb( &NwRcb, TRUE );

        //
        //  NwCleanupVcb releases the RCB, but we can't be guaranteed
        //  the state of the Vcb list when we release the RCB.
        //
        //  If we need to cleanup a VCB, release the lock, and start
        //  processing the list again.
        //

        VcbDeleted = TRUE;

        while ( VcbDeleted ) {

            VcbDeleted = FALSE;

            //
            //  Walk the list of VCBs for this SCB
            //

            for ( VcbQueueEntry = pScb->ScbSpecificVcbQueue.Flink;
                  VcbQueueEntry != &pScb->ScbSpecificVcbQueue;
                  VcbQueueEntry =  NextVcbQueueEntry ) {

                pVcb = CONTAINING_RECORD( VcbQueueEntry, VCB, VcbListEntry );
                NextVcbQueueEntry = VcbQueueEntry->Flink;

                //
                //  If this VCB is mapped to a drive letter, delete the mapping
                //  now.
                //

                if ( BooleanFlagOn( pVcb->Flags, VCB_FLAG_EXPLICIT_CONNECTION )) {

                    //
                    //  Remove the VCB from the global list.
                    //

                    ClearFlag( pVcb->Flags, VCB_FLAG_EXPLICIT_CONNECTION );
                    --pVcb->Reference;
                    --pVcb->Scb->OpenFileCount;
                }

                if ( pVcb->DriveLetter >= L'A' && pVcb->DriveLetter <= L'Z' ) {
                    PVCB * DriveMapTable = GetDriveMapTable( pScb->UserUid );
                    DriveMapTable[ pVcb->DriveLetter - 'A' ] = NULL;
                } else if ( pVcb->DriveLetter >= L'1' && pVcb->DriveLetter <= L'9' ) {
                    PVCB * DriveMapTable = GetDriveMapTable( pScb->UserUid );
                    DriveMapTable[ MAX_DISK_REDIRECTIONS + pVcb->DriveLetter - '1' ] = NULL;
                } else {
                    ASSERT( pVcb->DriveLetter == 0 );
                }

                if ( pVcb->Reference == 0 ) {

                    NwCleanupVcb( pVcb, pIrpContext );

                    //
                    // Get back to the head of the queue.
                    //

                    NwAppendToQueueAndWait( pIrpContext );
                    NwAcquireExclusiveRcb( &NwRcb, TRUE );

                    VcbDeleted = TRUE;
                    break;

                } else {
                    SetFlag( pVcb->Flags, VCB_FLAG_DELETE_IMMEDIATELY );
                }

            }
        }

        //
        // Get off the head of this SCB and move on.
        //

        KeAcquireSpinLock( &ScbSpinLock, &OldIrql );
        NwDequeueIrpContext( pIrpContext, TRUE );
        NwReleaseRcb( &NwRcb );
        NwDereferenceScb( pNpScb );
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );

}

BOOLEAN
GetLongNameSpaceForVolume(
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING ShareName,
    OUT PCHAR VolumeLongNameSpace,
    OUT PCHAR VolumeNumber
    )
/*++

Routine Description:

    This routine determines the name space index for long name support.
    This is accomplished by looking for the OS2 name space.

Arguments:

    pIrpContext - The IRP context for this request.

    ShareName - The name of the interesting volume.

    VolumeLongNameSpace - Returns the name space id of the OS/2 name space.

    VolumeNumber - Returns the volume number.

Return Value:

    TRUE - The volume support long names.
    FALSE - The volume does not support long names.

--*/
{
    NTSTATUS Status;
    char *ptr;
    USHORT i;
    char length;
    BOOLEAN LongNameSpace;
    CHAR NumberOfNameSpaces, NumberOfInfoRecords;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "GetLongNameSpaceForVolume...\n", 0);

    *VolumeLongNameSpace = LFN_NO_OS2_NAME_SPACE;

    //
    //  Get the ordinal number of this volume.
    //

    for ( i = 0; ShareName.Buffer[i] != ':'; i++);
    ShareName.Length = i * sizeof( WCHAR );

    DebugTrace( 0, Dbg, "Volume name %wZ\n", &ShareName );

    Status = ExchangeWithWait (
                 IrpContext,
                 SynchronousResponseCallback,
                 "SU",
                 NCP_DIR_FUNCTION, NCP_GET_VOLUME_NUMBER,
                 &ShareName );

    if ( NT_SUCCESS( Status ) ) {
        Status = ParseResponse(
                      IrpContext,
                      IrpContext->rsp,
                      IrpContext->ResponseLength,
                      "Nb",
                      VolumeNumber );
    }

    if ( !NT_SUCCESS( Status )) {
        DebugTrace( 0, Dbg, "Couldn't get volume number\n", 0);
        DebugTrace(-1, Dbg, "GetLongNameSpaceForVolume -> -1\n", 0);
        return( FALSE );
    }

    //
    //  Send a get name space info request, and wait for the response.
    //

    DebugTrace( 0, Dbg, "Querying volume number %d\n", *VolumeNumber );

    Status = ExchangeWithWait (
                 IrpContext,
                 SynchronousResponseCallback,
                 "Sb",
                 NCP_DIR_FUNCTION, NCP_GET_NAME_SPACE_INFO,
                 *VolumeNumber );

    if ( NT_SUCCESS( Status )) {
        Status = ParseResponse(
                     IrpContext,
                     IrpContext->rsp,
                     IrpContext->ResponseLength,
                     "Nb",
                     &NumberOfNameSpaces );
    }

    if ( !NT_SUCCESS( Status )) {
        DebugTrace( 0, Dbg, "Couldn't get name space info\n", 0);
        DebugTrace(-1, Dbg, "GetLongNameSpaceForVolume -> -1\n", 0);
        return( FALSE );
    }

    //
    //  Parse the response, it has the following format:
    //
    //    NCP Header
    //
    //    Number of Name Space Records (n1, byte)
    //
    //    n1 Name Space Records
    //        Length (l1, byte)
    //        Value (l1 bytes, non-NUL-terminated ASCII string)
    //
    //    Number of Name Space Info Records (n2, byte)
    //
    //    n2 Name Space Info Records
    //        Record number (byte)
    //        Length (l2, byte)
    //        Value (l2 bytes, non-NUL-terminated ASCII string)
    //
    //    Loaded name spaces (n3, byte)
    //    Loaded name space list (n3 bytes, each byte refers to the ordinal
    //         number of a name space record )
    //
    //    Volume name spaces (n3, byte)
    //    Volume name space list (n3 bytes, as above)
    //
    //    Volume Data Streams (n3, byte)
    //    Volume Data Streams (n3 bytes, each byte refers to the ordinal
    //         number of a name space info record )
    //

    DebugTrace( 0, Dbg, "Number of name spaces = %d\n", NumberOfNameSpaces );

    ptr = &IrpContext->rsp[ 9 ];
    LongNameSpace = FALSE;

    //
    //  Skip the loaded name space list.
    //

    for ( i = 0 ; i < NumberOfNameSpaces ; i++ ) {
        length = *ptr++;
        ptr += length;
    }

    //
    //  Skip the supported data streams list.
    //

    NumberOfInfoRecords = *ptr++;

    for ( i = 0 ; i < NumberOfInfoRecords ; i++ ) {
        ptr++;  // Skip record number
        length = *ptr;
        ptr += length + 1;
    }

    //
    //  Skip the supported data streams ordinal list.
    //

    length = *ptr;
    ptr += length + 1;

    //
    //  See if this volume supports long names.
    //

    length = *ptr++;
    for ( i = 0; i < length ; i++ ) {
        if ( *ptr++ == LONG_NAME_SPACE_ORDINAL ) {
            LongNameSpace = TRUE;
            *VolumeLongNameSpace = LONG_NAME_SPACE_ORDINAL;
        }
    }

    if ( LongNameSpace ) {
        DebugTrace(-1, Dbg, "GetLongNameSpaceForVolume -> STATUS_SUCCESS\n", 0 );
    } else {
        DebugTrace(-1, Dbg, "No long name space for volume.\n", 0 );
    }

    return( LongNameSpace );
}

BOOLEAN
IsFatNameValid (
    IN PUNICODE_STRING FileName
    )
/*++

Routine Description:

    This routine checks if the specified file name is conformant to the
    Fat 8.3 file naming rules.

Arguments:

    FileName - Supplies the name to check.

Return Value:

    BOOLEAN - TRUE if the name is valid, FALSE otherwise.

--*/

{
    STRING DbcsName;
    int i;

    PAGED_CODE();

    //
    //  Build up the dbcs string to call the fsrtl routine to check
    //  for legal 8.3 formation
    //

    if (NT_SUCCESS(RtlUnicodeStringToCountedOemString( &DbcsName, FileName, TRUE))) {

        for ( i = 0; i < DbcsName.Length; i++ ) {

            if ( FsRtlIsLeadDbcsCharacter( DbcsName.Buffer[i] ) ) {

               if (Korean){
                   //
                   // Korean NT supports a large DBCS code-range than Korean 
                   // Netware.  We block the extra code-range to avoid 
                   // code conversion problems. 
                   //
                   if ( (UCHAR) DbcsName.Buffer[i] >=0x81 && (UCHAR) DbcsName.Buffer[i] <=0xA0){
                       RtlFreeOemString( &DbcsName );
                       return FALSE; 
                   }else if((UCHAR) DbcsName.Buffer[i+1] <=0xA0){
                       RtlFreeOemString( &DbcsName );
                       return FALSE;
                   }
                   
                }

                //
                //  Ignore lead bytes and trailing bytes
                //

                i++;

            } else {

                //
                // disallow:
                //  '*' + 0x80 alt-170 (0xAA)
                //  '.' + 0x80 alt-174 (0xAE),
                //  '?' + 0x80 alt-191 (0xBF) the same as Dos clients.
                //
                //  May need to add 229(0xE5) too.
                //
                // We also disallow spaces as valid FAT chars since
                // NetWare treats them as part of the OS2 name space.
                //

                if ((DbcsName.Buffer[i] == 0xAA) ||
                    (DbcsName.Buffer[i] == 0xAE) ||
                    (DbcsName.Buffer[i] == 0xBF) ||
                    (DbcsName.Buffer[i] == ' ')) {

                    RtlFreeOemString( &DbcsName );
                    return FALSE;
                }
            }
        }

        if (FsRtlIsFatDbcsLegal( DbcsName, FALSE, TRUE, TRUE )) {

            RtlFreeOemString( &DbcsName );

            return TRUE;

        }

        RtlFreeOemString( &DbcsName );
    }

    //
    //  And return to our caller
    //

    return FALSE;
}

CHAR
GetNewDriveNumber (
    IN PSCB Scb
    )
/*++

Routine Description:

    Portable NetWare needs us to give a different drive letter each time
    we ask for a permanent handle. If we use the same one then:

        net use s: \\port\sys
        net use v: \\port\vol1
        dir s:
        <get contents of \\port\vol1 !!!!>


Arguments:

    Scb

Return Value:

    Letter assigned.

--*/

{

    ULONG result = RtlFindClearBitsAndSet( &Scb->DriveMapHeader, 1, 0 );

    PAGED_CODE();

    if (result == 0xffffffff) {
        return(0);  //  All used!
    } else {
        return('A' + (CHAR)(result & 0x00ff) );
    }
}

VOID
FreeDriveNumber(
    IN PSCB Scb,
    IN CHAR DriveNumber
    )
/*++

Routine Description:

    This routine releases the appropriate Drivehandles bit.

Arguments:

    FileName - Supplies the name to check.

Return Value:

    BOOLEAN - TRUE if the name is valid, FALSE otherwise.

--*/

{
    PAGED_CODE();

    if (DriveNumber) {
        RtlClearBits( &Scb->DriveMapHeader, (DriveNumber - 'A') & 0x00ff, 1);
    }
}


VOID
NwFreeDirCacheForIcb(
    IN PICB Icb
    )
/*++

Routine Description:

    This routine frees the directory cache associated with an ICB.

Arguments:

    Icb - Supplies the ICB to clear the dir cache on.

Return Value:

    
--*/

{
    PAGED_CODE();

    Icb->CacheHint = NULL;

    InitializeListHead( &(Icb->DirCache) );

    if( Icb->DirCacheBuffer ) {
        FREE_POOL( Icb->DirCacheBuffer );
    }

    Icb->DirCacheBuffer = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\struct.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Struct.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the NetWare file system.

Author:

    Colin Watson     [ColinW]    18-Dec-1992

Revision History:

--*/

#ifndef _NWSTRUC_
#define _NWSTRUC_

#define byte UCHAR
#define word USHORT
#define dword ULONG

typedef enum _PACKET_TYPE {
    SAP_BROADCAST,
    NCP_CONNECT,
    NCP_FUNCTION,
    NCP_SUBFUNCTION,
    NCP_DISCONNECT,
    NCP_BURST,
    NCP_ECHO
} PACKET_TYPE;

typedef struct _NW_TDI_STRUCT {
    HANDLE Handle;
    PDEVICE_OBJECT pDeviceObject;
    PFILE_OBJECT pFileObject;
    USHORT Socket;
} NW_TDI_STRUCT, *PNW_TDI_STRUCT;

typedef
NTSTATUS
(*PEX) (
    IN struct _IRP_CONTEXT* pIrpC,
    IN ULONG BytesAvailable,
    IN PUCHAR RspData
    );

typedef
VOID
(*PRUN_ROUTINE) (
    IN struct _IRP_CONTEXT *IrpContext
    );

typedef
NTSTATUS
(*PPOST_PROCESSOR) (
    IN struct _IRP_CONTEXT *IrpContext
    );

typedef
NTSTATUS
(*PRECEIVE_ROUTINE) (
    IN struct _IRP_CONTEXT *IrpContext,
    IN ULONG BytesAvailable,
    IN PULONG BytesAccepted,
    IN PUCHAR Response,
    OUT PMDL *pReceiveMdl
    );


typedef struct _NW_PID_TABLE_ENTRY {
    ULONG_PTR Pid32;
    ULONG_PTR ReferenceCount;
    ULONG_PTR Flags;
} NW_PID_TABLE_ENTRY, *PNW_PID_TABLE_ENTRY;

typedef struct _NW_PID_TABLE {

    //
    //  Type and size of this record (must be NW_NTC_PID)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    int ValidEntries;
    NW_PID_TABLE_ENTRY PidTable[0];
} NW_PID_TABLE, *PNW_PID_TABLE;

//
//  The Scb (Server control Block) record corresponds to every server
//  connected to by the file system.
//  They are ordered in ScbQueue.
//  This structure is allocated from paged pool
//

typedef struct _SCB {

    //
    //  The type and size of this record (must be NW_NTC_SCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Pointer to the non-paged part of the SCB.
    //

    struct _NONPAGED_SCB *pNpScb;

    //
    //  Prefix table entry.
    //

    UNICODE_PREFIX_TABLE_ENTRY PrefixEntry;

    //
    //  Server version number
    //

    UCHAR  MajorVersion;
    UCHAR  MinorVersion;

    //
    //  List of VCBs for this server, and a count of the VCB on the list.
    //  These fields are protected by the RCB resource.
    //

    LIST_ENTRY  ScbSpecificVcbQueue;
    ULONG       VcbCount;

    //
    //  A list of ICBs for the SCB.
    //

    LIST_ENTRY  IcbList;
    ULONG IcbCount;
    ULONG OpenNdsStreams;

    //
    //  User credentials that this Scb relates to.
    //

    LARGE_INTEGER UserUid;

    //
    //  A count of the open files for all the VCBs for this server.
    //  Plus the number of VCB that are explicitly connected.
    //

    ULONG OpenFileCount;

    //
    //  The name of the server for this SCB. Note the pNpScb->ServerName and
    //  UnicodeUid point at subparts of UidServerName->Buffer which must be
    //  non-paged pool.
    //

    UNICODE_STRING UidServerName;   // L"3e7\mars312
    UNICODE_STRING UnicodeUid;      // L"3e7"

    //
    //  The name of nds tree that this server belongs to, if any.
    //

    UNICODE_STRING NdsTreeName;     // L"MARS"

    //
    //  The username / password to use for auto-reconnect.
    //

    UNICODE_STRING UserName;
    UNICODE_STRING Password;

    //
    //  Is this the logon (preferred) server?
    //

    BOOLEAN PreferredServer;

    //
    //  Is this server waiting for us to read a message?
    //

    BOOLEAN MessageWaiting;

    //
    //  The number of tree connects to the root of the SCB.
    //

    ULONG AttachCount;

    RTL_BITMAP DriveMapHeader;
    ULONG DriveMap[ (MAX_DRIVES + 1) / 32 ];

    //
    //  NDS Object Cache.
    //

    PVOID ObjectCacheBuffer;
    LIST_ENTRY ObjectCacheList;
    KSEMAPHORE ObjectCacheLock;

} SCB, *PSCB;

//
//  Values for pNpScb->State
//

//
//  The SCB is on it's way up
//

#define SCB_STATE_ATTACHING              (0x0001)

//
//  The SCB is connected and logged in.
//

#define SCB_STATE_IN_USE                 (0x0003)

//
//  The SCB is being disconnected or shutdown.
//

#define SCB_STATE_DISCONNECTING          (0x0004)
#define SCB_STATE_FLAG_SHUTDOWN          (0x0005)

//
//  The SCB is waiting to be connected.
//

#define SCB_STATE_RECONNECT_REQUIRED     (0x0006)

//
//  The SCB is connected but has not been logged into
//

#define SCB_STATE_LOGIN_REQUIRED         (0x0007)

//
//  The SCB is a fake SCB used to find a dir
//  server for a tree.
//

#define SCB_STATE_TREE_SCB               (0x0008)

//
//  The NONPAGED_SCB (Server control Block) contains all the data required
//  when communicating with a server when a spinlock is held or at raised
//  IRQL such as when being called at indication time by the transport.
//  This structure must be allocated from non-paged pool.
//

typedef struct _NONPAGED_SCB {

    //
    //  The type and size of this record (must be NW_NTC_SCBNP
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Reference count and state information.
    //

    ULONG Reference;
    ULONG State;

    //
    //  The time this SCB was last used.
    //

    LARGE_INTEGER LastUsedTime;

    //
    //  Sending is true between the IoCallDriver to send the datagram and
    //  the completion routine for the send.
    //

    BOOLEAN Sending;

    //
    //  Receiving is true when the transport has indicated to the driver
    //  that there is data to receive and there is too much data to handle
    //  at indication time or we have received indicated data before
    //  the the send IRP completes.
    //

    BOOLEAN Receiving;

    //
    //  Received is true when the rx data is valid. If a receive Irp is
    //  put down when Receiving is set to true then Received is set to
    //  true when the receive Irp completes.
    //

    BOOLEAN Received;

    //
    //  OkToReceive is true iff pEx should be called
    //

    BOOLEAN OkToReceive;

    //
    //  Older servers insist that reads and writes do not cross 4k offsets
    //  in the file.
    //

    BOOLEAN PageAlign;

    //
    //  The links on the global list of SCBs.
    //

    LIST_ENTRY  ScbLinks;

    //
    //  Pointer to the paged component of the Scb
    //

    PSCB pScb;

    //
    //  The list of request in progress for this SCB.
    //

    LIST_ENTRY  Requests;

    //
    //  The name of the server for this SCB.
    //

    UNICODE_STRING ServerName;

    //
    //  Transport related information.
    //

    TA_IPX_ADDRESS LocalAddress;
    TA_IPX_ADDRESS RemoteAddress;
    TA_IPX_ADDRESS EchoAddress;
    IPXaddress  ServerAddress;
    ULONG EchoCounter;

    //
    //  Server is an autoassigned a socket in the range 0x4000 to 0x7fff.
    //  The transport assigns the socket number avoiding in-use sockets.
    //  Watchdog is socket+1 and Send is socket+2.
    //

    NW_TDI_STRUCT Server;           //  Used by us to contact server
    NW_TDI_STRUCT WatchDog;         //  Used by the server to check on us
    NW_TDI_STRUCT Send;             //  Used for send messages
    NW_TDI_STRUCT Echo;             //  Used to determine max packet size
    NW_TDI_STRUCT Burst;            //  Used for burst mode read and write

    USHORT       TickCount;
    USHORT       LipTickAdjustment;

    SHORT       RetryCount;         // Counts down to zero for current request
    SHORT       TimeOut;            // ticks to retransmission of current request
    UCHAR       SequenceNo;
    UCHAR       ConnectionNo;
    UCHAR       ConnectionNoHigh;
    UCHAR       ConnectionStatus;
    USHORT      MaxTimeOut;
    USHORT      BufferSize;
    UCHAR       TaskNo;

    //
    //  Burst mode parameters
    //

    ULONG LipSequenceNumber;
    ULONG SourceConnectionId;       //  High-low order
    ULONG DestinationConnectionId;  //  High-low order
    ULONG MaxPacketSize;
    ULONG MaxSendSize;
    ULONG MaxReceiveSize;
    BOOLEAN SendBurstModeEnabled;
    BOOLEAN ReceiveBurstModeEnabled;
    BOOLEAN BurstRenegotiateReqd;
    ULONG BurstSequenceNo;          //  Counts # of burst packets sent
    USHORT BurstRequestNo;          //  Counts # of burst requests sent
    LONG SendBurstSuccessCount;     //  The number of consecutive successful bursts
    LONG ReceiveBurstSuccessCount;  //  The number of consecutive successful bursts

    //
    //  Send delays and timeouts
    //

    SHORT SendTimeout;              //  Exchange timeout in ticks (1/18th sec)
    ULONG TotalWaitTime;            //  Total time, in ticks, waiting for current response

    LONG  NwLoopTime;               //  Time for a small packet to reach the server and return
    LONG  NwSingleBurstPacketTime;  //  Time for a burst packet to go to the server

    LONG NwMaxSendDelay;            //  Burst send delay time, in 100us units
    LONG NwSendDelay;               //  Burst send delay time, in 100us units
    LONG NwGoodSendDelay;           //  Burst send delay time, in 100us units
    LONG NwBadSendDelay;            //  Burst send delay time, in 100us units
    LONG BurstDataWritten;          //  Bytes written, used for dummy NCP in write.c

    LONG NwMaxReceiveDelay;         //  Burst delay time, in 100us units
    LONG NwReceiveDelay;            //  Burst delay time, in 100us units
    LONG NwGoodReceiveDelay;        //  Burst delay time, in 100us units
    LONG NwBadReceiveDelay;         //  Burst delay time, in 100us units

    LONG CurrentBurstDelay;         //  All requests in the current burst need the same value

    LARGE_INTEGER NtSendDelay;      //  Burst send delay time, in 100ns units

    //
    //  A spin lock used to protect various fields for this SCB.
    //  NpScbInterLock is used to protect pNpScb->Reference.
    //

    KSPIN_LOCK  NpScbSpinLock;
    KSPIN_LOCK  NpScbInterLock;

    //
    //  This field records the last time a time-out event was written to
    //  the event log for this server.
    //

    LARGE_INTEGER NwNextEventTime;

    //
    // LIP estimation of speed in 100bps units.
    //

    ULONG LipDataSpeed;

    //  The Pid mapping table - actually the NCP task ID -
    //  is on a per-SCB basis.
    PNW_PID_TABLE PidTable;
    ERESOURCE RealPidResource;
    //
    //  Server version number - dup from NpScb because accessed in 
    //  WatchDogDatagramHandler
    //
    UCHAR  MajorVersion;

#ifdef MSWDBG
    BOOL RequestQueued;
    BOOL RequestDequeued;

    ULONG SequenceNumber;
#endif

} NONPAGED_SCB, *PNONPAGED_SCB;

//
//  Delete this VCB immediately if the reference count reaches zero.
//

#define  VCB_FLAG_DELETE_IMMEDIATELY  0x00000001
#define  VCB_FLAG_EXPLICIT_CONNECTION 0x00000002
#define  VCB_FLAG_PRINT_QUEUE         0x00000004
#define  VCB_FLAG_LONG_NAME           0x00000008

//
//  The VCB corresponds to a netware volume.
//

typedef struct _VCB {

    //
    //  Type and size of this record (must be NW_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    ULONG Reference;
    LARGE_INTEGER LastUsedTime;

    //
    //  Connection the the global VCB list.
    //

    LIST_ENTRY GlobalVcbListEntry;
    ULONG_PTR SequenceNumber;

    //
    //  The requested volume name in the following form:
    //
    //  \{Server | Tree}\{Share | Volume.Object}\Path
    //

    UNICODE_STRING Name;

    //
    //  If the above name refers to an nds volume, this
    //  contains the resolved server and share name in
    //  the following form:
    //
    //  \Server\Share\Path
    //

    UNICODE_STRING ConnectName;

    //
    //  The share name in Netware compatible form.
    //

    UNICODE_STRING ShareName;

    //
    // tommye - MS bug 71690 - store the VCB path 
    //

    UNICODE_STRING Path;

    //
    //  The prefix table entry for this volume.
    //

    UNICODE_PREFIX_TABLE_ENTRY PrefixEntry;    //  7 DWORDs

    union {

        //
        //  Disk VCB specific data.
        //

        struct {

            //
            //  The volume number
            //

            CHAR VolumeNumber;

            //
            //  The name space number for long name support.  -1 if long name
            //  space is not supported.
            //

            CHAR LongNameSpace;

            //
            //  The remote handle
            //

            CHAR Handle;

            //
            //  The Drive Letter we told the server we were mapping. Portable
            //  NetWare needs this to be different for each permanent handle
            //  we create.
            //

            CHAR DriveNumber;

        } Disk;

        //
        //  Print VCB specific data.
        //

        struct {
            ULONG QueueId;
        } Print;

    } Specific;

    //
    //  The drive letter for this VCB.  (0 if this is UNC).
    //

    WCHAR DriveLetter;

    //
    //  The SCB for this volume, and a link to the VCBs for this SCB
    //

    PSCB Scb;
    LIST_ENTRY VcbListEntry;

    //
    //  List of FCBs and DCBs for this server.  These fields are protected
    //  by the RCB resource.
    //

    LIST_ENTRY FcbList;

    //
    //  The count of open ICBs for this VCB.
    //

    ULONG OpenFileCount;

    //
    //  VCB flags
    //

    ULONG Flags;

} VCB, *PVCB;

//
//  Use default date / time when netware returns no info, or bogus info.
//

#define DEFAULT_DATE   ( 1 + (1 << 5) + (0 << 9) )   /* Jan 1, 1980 */
#define DEFAULT_TIME   ( 0 + (0 << 5) + (0 << 11) )  /* 12:00am */

//
//  The Fcb/Dcb record corresponds to every open file and directory.
//
//  The structure is really divided into two parts.  FCB can be allocated
//  from paged pool which the NONPAGED_FCB must be allocated from non-paged
//  pool.
//

typedef struct _FCB {

    //
    //  Type and size of this record (must be NW_NTC_FCB or NW_NTC_DCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The VCB for this file.
    //

    PVCB Vcb;

    //
    //  The following field is the fully qualified file name for this FCB/DCB.
    //  The file name relative to the root of the volume.
    //

    UNICODE_STRING FullFileName;
    UNICODE_STRING RelativeFileName;

    //
    //  Netware file information.
    //

    USHORT LastModifiedDate;
    USHORT LastModifiedTime;
    USHORT CreationDate;
    USHORT CreationTime;
    USHORT LastAccessDate;

    //
    //  The state of the FCB.
    //

    ULONG State;
    ULONG Flags;

    //
    //  A record of accesss currently granted.
    //

    SHARE_ACCESS ShareAccess;

    //
    //  The prefix table entry for this file.
    //

    UNICODE_PREFIX_TABLE_ENTRY PrefixEntry;

    //
    //  The SCB for this file, and a link to the FCB for this SCB
    //

    PSCB Scb;
    LIST_ENTRY FcbListEntry;

    //
    //  The list of ICB's for this FCB or DCB.
    //

    LIST_ENTRY IcbList;
    ULONG IcbCount;

    //
    //  A pointer to the specific non-paged data for the Fcb.
    //

    struct _NONPAGED_FCB *NonPagedFcb;

    ULONG LastReadOffset;
    ULONG LastReadSize;

} FCB, DCB;
typedef FCB *PFCB;
typedef DCB *PDCB;

typedef enum {
    ReadAhead,
    WriteBehind
} CACHE_TYPE;

typedef struct _NONPAGED_FCB {

    //
    //  The following field is used for fast I/O
    //
    //  The following comments refer to the use of the AllocationSize field
    //  of the FsRtl-defined header to the nonpaged Fcb.
    //
    //  For a directory when we create a Dcb we will not immediately
    //  initialize the cache map, instead we will postpone it until our first
    //  call to NwReadDirectoryFile or NwPrepareWriteDirectoryFile.
    //  At that time we will search the Nw to find out the current allocation
    //  size (by calling NwLookupFileAllocationSize) and then initialize the
    //  cache map to this allocation size.
    //
    //  For a file when we create an Fcb we will not immediately initialize
    //  the cache map, instead we will postpone it until we need it and
    //  then we determine the allocation size from either searching the
    //  fat to determine the real file allocation, or from the allocation
    //  that we've just allocated if we're creating a file.
    //
    //  A value of -1 indicates that we do not know what the current allocation
    //  size really is, and need to examine the fat to find it.  A value
    //  of than -1 is the real file/directory allocation size.
    //
    //  Whenever we need to extend the allocation size we call
    //  NwAddFileAllocation which (if we're really extending the allocation)
    //  will modify the Nw, Rcb, and update this field.  The caller
    //  of NwAddFileAllocation is then responsible for altering the Cache
    //  map size.
    //

    FSRTL_ADVANCED_FCB_HEADER Header;

    PFCB Fcb;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field
    //

    SECTION_OBJECT_POINTERS SegmentObject;

    //
    //  The following field is used to maintain a list of locks owned for
    //  this file.  It points to an ordered list of file locks.
    //

    LIST_ENTRY FileLockList;

    //
    //  The following field is used to maintain a list of pending locks
    //  for this file.  All locks in this list conflict with existing
    //  locks on the FileLockList.
    //

    LIST_ENTRY PendingLockList;

    //
    //  A resource to synchronize access to the FCB and it's ICBs
    //

    ERESOURCE Resource;

    //
    //  Netware file information.
    //

    UCHAR Attributes;

    //
    //   File data cache information
    //

    UCHAR CacheType;        // ReadAhead or WriteBehind
    PUCHAR CacheBuffer;     // The cache buffer
    PMDL CacheMdl;          // The full MDL for the cache buffer
    ULONG CacheSize;        // The size of the cache buffer
    ULONG CacheFileOffset;  // The file offset of this data
    ULONG CacheDataSize;    // The amount of file data in the cache

    //
    //  This is the mutex that is inserted into the FCB_ADVANCED_HEADER
    //  FastMutex field
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

} NONPAGED_FCB, NONPAGED_DCB;

typedef NONPAGED_FCB *PNONPAGED_FCB;
typedef NONPAGED_DCB *PNONPAGED_DCB;

#define FCB_STATE_OPEN_PENDING           0x00000001
#define FCB_STATE_OPENED                 0x00000002
#define FCB_STATE_CLOSE_PENDING          0x00000003

#define FCB_FLAGS_DELETE_ON_CLOSE        0x00000001
#define FCB_FLAGS_TRUNCATE_ON_CLOSE      0x00000002
#define FCB_FLAGS_PAGING_FILE            0x00000004
#define FCB_FLAGS_PREFIX_INSERTED        0x00000008
#define FCB_FLAGS_FORCE_MISS_IN_PROGRESS 0x00000010
#define FCB_FLAGS_ATTRIBUTES_ARE_VALID   0x00000020
#define FCB_FLAGS_LONG_NAME              0x00000040
#define FCB_FLAGS_LAZY_SET_SHAREABLE     0x00000100

//
// This structure is used for directory searches. 
//

typedef struct _NW_DIRECTORY_INFO {
    WCHAR FileNameBuffer[NW_MAX_FILENAME_LENGTH];
    UNICODE_STRING FileName;
    UCHAR Attributes;
    USHORT CreationDate;
    USHORT CreationTime;
    USHORT LastAccessDate;
    USHORT LastUpdateDate;
    USHORT LastUpdateTime;
    ULONG FileSize;
    ULONG DosDirectoryEntry;
    ULONG FileIndexLow;
    ULONG FileIndexHigh;
    NTSTATUS Status;
    LIST_ENTRY ListEntry;
} NW_DIRECTORY_INFO, *PNW_DIRECTORY_INFO;

//
//  The Icb record is allocated for every file object
//

typedef struct _ICB {

    //
    //  Type and size of this record (must be NW_NTC_ICB or NW_NTC_ICB_SCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A link to the list of ICB's for our FCB, and our FCB.
    //

    LIST_ENTRY ListEntry;

    union {
        PFCB Fcb;
        PSCB Scb;
    } SuperType;

    PNONPAGED_FCB NpFcb;    // Valid only for node type NW_ITC_ICB

    //
    // The state of this ICB.
    //

    ULONG State;

    //
    // The remote handle;
    //

    UCHAR Handle[6];           //  Keep  WORD aligned.

    BOOLEAN HasRemoteHandle;   //  TRUE if we have a remote handle for this ICB

    //
    //  The file object for this ICB.
    //

    PFILE_OBJECT FileObject;

    //
    //  The query template is used to filter directory query requests.
    //  It originally is set to null and on the first call the NtQueryDirectory
    //  it is set the the input filename or "*" if the name is supplied.
    //  All subsquent queries then use this template
    //

    OEM_STRING NwQueryTemplate;
    UNICODE_STRING UQueryTemplate;
    ULONG IndexOfLastIcbReturned;
    UCHAR Pid;

    BOOLEAN DotReturned;
    BOOLEAN DotDotReturned;
    BOOLEAN ReturnedSomething;
    BOOLEAN ShortNameSearch;

    //
    //  More search parameters.
    //

    USHORT SearchHandle;
    UCHAR SearchVolume;
    UCHAR SearchAttributes;

    //
    //  Extra search parameters for long name support
    //

    ULONG SearchIndexLow;
    ULONG SearchIndexHigh;

    //
    //  SVR to avoid rescanning from end of dir all
    //  the way through the directory again.
    //

    ULONG LastSearchIndexLow;

    //  SVR end

    //
    //  Print parametres;
    //

    BOOLEAN IsPrintJob;
    USHORT JobId;
    BOOLEAN ActuallyPrinted;

    //
    //  This flag prevents cleanup from updating the access time.
    //

    BOOLEAN UserSetLastAccessTime;

    //
    //  The current file position.
    //

    ULONG FilePosition;

    //
    //  The size of the file if its ICB_SCB
    //

    ULONG FileSize;

    //
    //  The Next dirent offset is used by directory enumeration.  It is
    //  the offset (within the directory file) of the next dirent to examine.
    //

    //VBO OffsetToStartSearchFrom;

    //
    //  If this ICB was created with OPEN_RENAME_TARGET then the following
    //  parameters are used
    //

    BOOLEAN IsAFile;
    BOOLEAN Exists;
    BOOLEAN FailedFindNotify;

    //
    // Is this a tree handle?  We need to know for delete.
    //

    BOOLEAN IsTreeHandle;
    BOOLEAN IsExCredentialHandle;
    PVOID pContext;

    //
    // A linked list of cached directory entries.
    //
    LIST_ENTRY DirCache;

    //
    // A hint into the dir cache.
    //
    PLIST_ENTRY CacheHint;

    //
    // A pointer to the top of the buffer.
    //
    PVOID DirCacheBuffer;

} ICB, *PICB;

#define ICB_STATE_OPEN_PENDING           0x00000001
#define ICB_STATE_OPENED                 0x00000002
#define ICB_STATE_CLEANED_UP             0x00000003
#define ICB_STATE_CLOSE_PENDING          0x00000004

#define INVALID_PID                      0

//
//  A structure used to maintain a list of file locks.
//

typedef struct _NW_FILE_LOCK {

    //
    //  Type and size of this record (must be NW_NTC_FILE_LOCK )
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A link to the list of locks for this FCB.
    //

    LIST_ENTRY ListEntry;

    //
    //  The ICB this lock belongs to.
    //

    PICB Icb;

    //
    //  The IRP Context for this lock request.
    //

    struct _IRP_CONTEXT *IrpContext;

    //
    // The originating process.
    //

    void *pOwnerProc;

    //
    //  The lock offset, length, and key.
    //

    LONG StartFileOffset;
    ULONG Length;
    LONG EndFileOffset;
    ULONG Key;
    USHORT Flags;

} NW_FILE_LOCK, *PNW_FILE_LOCK;

//
//  The Rcb record controls access to the redirector device
//

typedef struct _RCB {

    //
    //  Type and size of this record (must be NW_NTC_RCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The run state of the redirector
    //

    ULONG State;

    //
    //  The count of open handles to the RCB.
    //  Access is protected by the RCB Resource.
    //

    ULONG OpenCount;

    //
    // A resource to synchronize access to the RCB.
    //

    ERESOURCE Resource;

    //
    // A record of accesss currently granted to the RCB.
    //

    SHARE_ACCESS ShareAccess;

    //
    // A prefix table of all connected servers.
    //

    UNICODE_PREFIX_TABLE ServerNameTable;

    //
    // A prefix table of all open volumes.
    //

    UNICODE_PREFIX_TABLE VolumeNameTable;

    //
    // A prefix table of all open files
    //

    UNICODE_PREFIX_TABLE FileNameTable;

} RCB, *PRCB;


#define RCB_STATE_STOPPED                0x00000001
#define RCB_STATE_STARTING               0x00000002
#define RCB_STATE_NEED_BIND              0x00000003
#define RCB_STATE_RUNNING                0x00000004
#define RCB_STATE_SHUTDOWN               0x00000005

//
//  IRP_CONTEXT Flags bits.
//

#define IRP_FLAG_IN_FSD               0x00000001  //  This IRP is being process in the FSD
#define IRP_FLAG_ON_SCB_QUEUE         0x00000002  //  This IRP is queued to an SCB
#define IRP_FLAG_SEQUENCE_NO_REQUIRED 0x00000004  //  This packet requires a sequence #
#define IRP_FLAG_SIGNAL_EVENT         0x00000010
#define IRP_FLAG_RETRY_SEND           0x00000020  //  We are resending a timed out request
#define IRP_FLAG_RECONNECTABLE        0x00000040  //  We are allowed to try a reconnect if this request fails due to a bad connection
#define IRP_FLAG_RECONNECT_ATTEMPT    0x00000080  //  This IRP is being used to attempt a reconnect
#define IRP_FLAG_BURST_REQUEST        0x00000100  //  This is a burst request packet
#define IRP_FLAG_BURST_PACKET         0x00000200  //  This is any burst packet
#define IRP_FLAG_NOT_OK_TO_RECEIVE    0x00000400  //  Don't set ok to receive when sending this packet
#define IRP_FLAG_REROUTE_ATTEMPTED    0x00000800  //  A re-route has been attempted for this packet
#define IRP_FLAG_BURST_WRITE          0x00001000  //  We are processsing a burst write request
#define IRP_FLAG_SEND_ALWAYS          0x00002000  //  Okay to send this packet, even if RCB State is shutdown
#define IRP_FLAG_FREE_RECEIVE_MDL     0x00004000  //  Free the receive irp's MDL when the irp completes
#define IRP_FLAG_NOT_SYSTEM_PACKET    0x00008000  //  Used in burst writes to alternate system packet and normal
#define IRP_FLAG_NOCONNECT            0x00010000  //  Used to inspect server list
#define IRP_FLAG_HAS_CREDENTIAL_LOCK  0X00020000  //  Used to prevent deadlocking
#define IRP_FLAG_REROUTE_IN_PROGRESS  0x00040000  //  A re-route is currently in progress for this packet.

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be NW_NTC_IRP_CONTEXT).
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    // Information about this IRP
    //

    ULONG Flags;

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;  // 4*sizeof(ULONG)

    //  Workspace for exchange()
    PACKET_TYPE PacketType;

    //
    //  Server Control Block to which this request applies.
    //

    PNONPAGED_SCB pNpScb;
    PSCB pScb;

    //
    //  The socket structure to use for this request.  If NULL, use
    //  pNpScb->Server socket.
    //

    PNW_TDI_STRUCT pTdiStruct;

    //
    //  List of requests to a particular server. Listed on Scb->Requests.
    //

    LIST_ENTRY NextRequest;

    //
    //  Used for processing synchronous IRPs.
    //

    KEVENT Event;   //  4 words

    //
    //  A pointer to the originating Irp and its original contents when
    //  the I/O system submitted it to the rdr.
    //

    PIRP pOriginalIrp;
    PVOID pOriginalSystemBuffer;
    PVOID pOriginalUserBuffer;
    PMDL pOriginalMdlAddress;

    //
    //  Information used if we need to post an IRP to process the receive
    //

    PIRP ReceiveIrp;

    //
    //  Pointer to the Mdl used to transmit/receive the Ncp header.
    //

    PMDL TxMdl;
    PMDL RxMdl;

    //
    //  Routine to run when this IRP context reaches the front of the
    //  SCB queue.
    //

    PRUN_ROUTINE RunRoutine;

    //
    //  Routine to handle the response Ncp
    //

    PEX pEx;

    //
    //  Routine to handle packet receipt
    //

    PRECEIVE_ROUTINE ReceiveDataRoutine;

    //
    //  Routine to handle FSP post processing.
    //

    PPOST_PROCESSOR PostProcessRoutine;

    //
    //  Routine to run when this IRP context times out while on the SCB
    //  queue.
    //

    PRUN_ROUTINE TimeoutRoutine;

    //
    //  Routine to run when this IRP has completed a send.
    //

    PIO_COMPLETION_ROUTINE CompletionSendRoutine;

    //
    //  Work Item used for scheduling reconnect.
    //

    PWORK_QUEUE_ITEM pWorkItem;

    //
    //  Buffer used to hold the Ncb to be transmitted/received.
    //

    ULONG Signature1;

    UCHAR req[MAX_SEND_DATA];
    ULONG Signature2;

    ULONG ResponseLength;
    UCHAR rsp[MAX_RECV_DATA];
    ULONG Signature3;

    //
    //  Address to be used in the Send Datagram.
    //

    TA_IPX_ADDRESS Destination;
    TDI_CONNECTION_INFORMATION ConnectionInformation;   //  Remote server

    //
    //  The ICB being processed.
    //

    PICB Icb;

    //
    //  Per IRP processor information.  A handy place to store information
    //  for the IRP in progress.
    //

    union {
        struct {
            UNICODE_STRING FullPathName;
            UNICODE_STRING VolumeName;
            UNICODE_STRING PathName;
            UNICODE_STRING FileName;
            BOOLEAN        NdsCreate;
            BOOLEAN        NeedNdsData;
            DWORD          dwNdsOid;
            DWORD          dwNdsObjectType;
            DWORD          dwNdsShareLength;
            UNICODE_STRING UidConnectName;
            WCHAR   DriveLetter;
            ULONG   ShareType;
            BOOLEAN fExCredentialCreate;
            PVOID   pExCredentials;
            PUNICODE_STRING puCredentialName;
            PCHAR   FindNearestResponse[4];
            ULONG   FindNearestResponseCount;
            LARGE_INTEGER UserUid;
        } Create;

        struct {
            PVOID   Buffer;
            ULONG   Length;
            PVCB    Vcb;
            CHAR VolumeNumber;
        } QueryVolumeInformation;

        struct {
            PVOID   Buffer;
            ULONG   Length;
            PMDL    InputMdl;
            UCHAR   Function;     //  Used for special case post-processing
            UCHAR   Subfunction;  //  during UserNcpCallback

        } FileSystemControl;

        struct {
            PVOID   Buffer;
            ULONG   WriteOffset;
            ULONG   RemainingLength;
            PMDL    PartialMdl;
            PMDL    FullMdl;
            ULONG   FileOffset;
            ULONG   LastWriteLength;

            ULONG   BurstOffset;
            ULONG   BurstLength;
            NTSTATUS Status;

            ULONG   TotalWriteLength;
            ULONG   TotalWriteOffset;

            ULONG   PacketCount;
        } Write;

        struct {
            ULONG   CacheReadSize;      //  Amount of data read from the cache
            ULONG   ReadAheadSize;      //  Extra data to read

            PVOID   Buffer;             //  Buffer for the current read
            PMDL    FullMdl;
            PMDL    PartialMdl;
            ULONG   ReadOffset;
            ULONG   RemainingLength;
            ULONG   FileOffset;
            ULONG   LastReadLength;

            LIST_ENTRY PacketList;      //  List of packets received
            ULONG   BurstRequestOffset; //  Offset in burst buffer for last request
            ULONG   BurstSize;          //  Number of bytes in current burst
            PVOID   BurstBuffer;        //  Buffer for the current burst
            BOOLEAN DataReceived;
            NTSTATUS Status;
            UCHAR   Flags;

            ULONG TotalReadLength;
            ULONG TotalReadOffset;
        } Read;

        struct {
            PNW_FILE_LOCK FileLock;
            ULONG   Key;
            BOOLEAN Wait;
            BOOLEAN ByKey;
        } Lock;

    } Specific;

    struct {
        UCHAR Error;
    } ResponseParameters;

#ifdef NWDBG
    ULONG   DebugValue;
    ULONG   SequenceNumber;
#endif
} IRP_CONTEXT, *PIRP_CONTEXT;

typedef struct _BURST_READ_ENTRY {
    LIST_ENTRY ListEntry;
    ULONG   DataOffset;
    USHORT  ByteCount;
} BURST_READ_ENTRY, *PBURST_READ_ENTRY;

typedef struct _LOGON {

    //
    // The type and size of this record.
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    // List of Login records.
    //

    LIST_ENTRY     Next;

    UNICODE_STRING UserName;
    UNICODE_STRING PassWord;
    UNICODE_STRING ServerName;
    LARGE_INTEGER  UserUid;

    //
    // The NDS credential list, default tree,
    // and default context for this user.
    //

    ERESOURCE CredentialListResource;
    LIST_ENTRY NdsCredentialList;

    ULONG          NwPrintOptions;
    PVCB DriveMapTable[DRIVE_MAP_TABLE_SIZE];
} LOGON, *PLOGON;

typedef struct _MINI_IRP_CONTEXT {

    //
    //  Header information
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A link to queue IRP contexts
    //

    LIST_ENTRY  Next;

    PIRP_CONTEXT IrpContext;
    PIRP Irp;

    PVOID Buffer;      //  The buffer for this request.
    PMDL Mdl1;         //  The MDL for the buffer
    PMDL Mdl2;         //  The MDL for the data
} MINI_IRP_CONTEXT, *PMINI_IRP_CONTEXT;

//
// Definitions for unlockable code sections.
//

typedef struct _SECTION_DESCRIPTOR {
    PVOID Base;
    PVOID Handle;
    ULONG ReferenceCount;
} SECTION_DESCRIPTOR, *PSECTION_DESCRIPTOR;

//
// The work context is a queueable work item. It is used for specifying
// the IRP_CONTEXT to our thread which handles reroute attempts.
//

typedef struct _WORK_CONTEXT {
   
   //
   //  Type and size of this record (must be NW_NTC_WORK_CONTEXT).
   //

   NODE_TYPE_CODE NodeTypeCode;
   NODE_BYTE_SIZE NodeByteSize;

   //
   // The work to be done
   //

   NODE_WORK_CODE NodeWorkCode;
   
   PIRP_CONTEXT pIrpC;
   
   //
   // A link to queue work contexts to the Kernel queue object
   //

   LIST_ENTRY  Next;

} WORK_CONTEXT, *PWORK_CONTEXT;

//
// NDS resolved object entry.
//
// NOTE:  This must be eight byte aligned.
//

typedef struct _NDS_OBJECT_CACHE_ENTRY {
    LIST_ENTRY Links;
    LARGE_INTEGER Timeout;
    DWORD DsOid;
    DWORD ObjectType;
    DWORD ResolverFlags;
    BOOLEAN AllowServerJump;
    BOOLEAN Padding[3];
    PSCB Scb;
    ULONG Reserved;
    UNICODE_STRING ObjectName;
} NDS_OBJECT_CACHE_ENTRY, *PNDS_OBJECT_CACHE_ENTRY;

#endif // _NWSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\timer.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This module contains code which implements the receive and send timeouts
    for each connection.

Author:

    Colin Watson     [ColinW]        21-Feb-1993
    Anoop Anantha    [AnoopA]        24-Jun-1998

Environment:

    Kernel mode

Revision History:

--*/

#include "procs.h"

//
//  The debug trace level
//

#define Dbg                             (DEBUG_TRACE_TIMER)

LARGE_INTEGER DueTime;
KDPC NwDpc;                               // DPC object for timeouts.
KTIMER Timer;                           // kernel timer for this request.
ULONG ScavengerTickCount;

BOOLEAN WorkerRunning = FALSE;
WORK_QUEUE_ITEM WorkItem;

#ifdef NWDBG
BOOLEAN DisableTimer = FALSE;
#endif

//
//  TimerStop reflects the state of the timer.
//

BOOLEAN TimerStop = TRUE;

VOID
TimerDPC(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#if 0

//
// Not Pageable because it may be called from PnPSetPower() and because
// it holds a spinlock
//

StartTimer (VOID)
StopTimer (VOID)
#endif



VOID
StartTimer(
    VOID
    )
/*++

Routine Description:

    This routine starts the timer ticking.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    DebugTrace(+0, Dbg, "Entering StartTimer\n", 0);

    KeAcquireSpinLock( &NwTimerSpinLock, &OldIrql );

    if (TimerStop) {

        //
        //  We need 18.21 ticks per second
        //
    
        DueTime.QuadPart = (( 100000 * MILLISECONDS ) / 1821) * -1;
    
        //
        // This is the first connection with timeouts specified.
        // Set up the timer so that every 500 milliseconds we scan all the
        // connections for timed out receive and sends.
        //
    
        KeInitializeDpc( &NwDpc, TimerDPC, NULL );
        KeInitializeTimer( &Timer );
    
        (VOID)KeSetTimer(&Timer, DueTime, &NwDpc);
        TimerStop = FALSE;
    
        DebugTrace(+0, Dbg, "StartTimer started timer\n", 0);
    
    }

    KeReleaseSpinLock( &NwTimerSpinLock, OldIrql );
}


VOID
StopTimer(
    VOID
    )
/*++

Routine Description:

    This routine stops the timer.  It blocks until the timer has stopped.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    DebugTrace(+0, Dbg, "Entering StopTimer\n", 0);
    
    KeAcquireSpinLock( &NwTimerSpinLock, &OldIrql );

    if (!TimerStop) {
    
        KeCancelTimer( &Timer );
        TimerStop = TRUE;
        DebugTrace(+0, Dbg, "StopTimer stopped timer\n", 0);
    }
    
    KeReleaseSpinLock( &NwTimerSpinLock, OldIrql );

}


VOID
TimerDPC(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is called to search for timed out send and receive
    requests.  This routine is called at DPC level.

Arguments:

    Dpc - Unused.
    Context - Unused.
    SystemArgument1 - Unused.
    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ScbQueueEntry;
    PLIST_ENTRY NextScbQueueEntry;
    PLIST_ENTRY IrpContextEntry;
    PLIST_ENTRY NextIrpContextEntry;
    SHORT RetryCount;
    PIRP_CONTEXT pIrpContext;
    LARGE_INTEGER CurrentTime = {0, 0};
    WCHAR AnonymousName[] = L"UNKNOWN";
    PWCHAR ServerLogName;
    PWORK_CONTEXT workContext;


    //
    //  For each Server see if there is a timeout to process.
    //

#ifdef NWDBG
    if ( DisableTimer ) {
        //
        //  Reset the timer to run for another tick.
        //

        (VOID)KeSetTimer ( &Timer, DueTime, &NwDpc);

        return;
    }
#endif

    //DebugTrace(+1, Dbg, "TimerDpc....\n", 0);

    //
    //  Scan through the Scb's looking for timed out requests.
    //

    KeAcquireSpinLockAtDpcLevel( &ScbSpinLock );

    ScbQueueEntry = ScbQueue.Flink;

    if (ScbQueueEntry != &ScbQueue) {
        PNONPAGED_SCB pNpScb = CONTAINING_RECORD(ScbQueueEntry,
                                                    NONPAGED_SCB,
                                                    ScbLinks);
        NwQuietReferenceScb( pNpScb );
    }

    for (;
         ScbQueueEntry != &ScbQueue ;
         ScbQueueEntry = NextScbQueueEntry ) {

        PNONPAGED_SCB pNpScb = CONTAINING_RECORD(ScbQueueEntry,
                                                    NONPAGED_SCB,
                                                    ScbLinks);

        //  Obtain a pointer to the next SCB in the SCB list before
        //  dereferencing the current one.
        //

        NextScbQueueEntry = pNpScb->ScbLinks.Flink;

        if (NextScbQueueEntry != &ScbQueue) {
            PNONPAGED_SCB pNextNpScb = CONTAINING_RECORD(NextScbQueueEntry,
                                                        NONPAGED_SCB,
                                                        ScbLinks);
            //
            //  Reference the next entry in the list to ensure the scavenger
            //  doesn't put it on another list or destroy it.
            //

            NwQuietReferenceScb( pNextNpScb );
        }

        KeReleaseSpinLockFromDpcLevel( &ScbSpinLock );

        //
        //  Acquire the Scb specific spin lock to protect access
        //  the the Scb fields.
        //

        KeAcquireSpinLockAtDpcLevel( &pNpScb->NpScbSpinLock );

        //
        //  Look at the first request on the queue only (since it is
        //  the only active request).
        //

        if ( ( !IsListEmpty( &pNpScb->Requests )) &&
             ( !pNpScb->Sending ) &&
             ( pNpScb->OkToReceive ) &&
             ( --pNpScb->TimeOut <= 0 ) ) {

            //
            //  This request has timed out.  Try to retransmit the request.
            //

            pIrpContext = CONTAINING_RECORD(
                              pNpScb->Requests.Flink,
                              IRP_CONTEXT,
                              NextRequest);

            pNpScb->TimeOut = pNpScb->MaxTimeOut;

            //
            //  Check the retry count while we own the spin lock.
            //

            RetryCount = --pNpScb->RetryCount;
            NwQuietDereferenceScb( pNpScb );

            //
            //  Set OkToReceive to FALSE, so that if we receive a response
            //  right now, our receive handler won't handle the response
            //  and cause IRP context to be freed.
            //

            pNpScb->OkToReceive = FALSE;
            KeReleaseSpinLockFromDpcLevel( &pNpScb->NpScbSpinLock );

            if ( pIrpContext->pOriginalIrp->Cancel ) {

                //
                //  This IRP has been cancelled.  Call the callback routine.
                //

                DebugTrace(+0, Dbg, "Timer cancel IRP %X\n", pIrpContext->pOriginalIrp );
                pIrpContext->pEx( pIrpContext, 0, NULL );

            } else if ( RetryCount >= 0) {

                //
                //  We're not out of retries.  Resend the request packet.
                //
                //  First adjust the send timeout up.  Adjust the timeout
                //  more slowly on a close by server.
                //

                if ( pNpScb->SendTimeout < pNpScb->MaxTimeOut ) {
                    if ( pNpScb->TickCount <= 4 ) {
                        pNpScb->SendTimeout++;
                    } else {
                        pNpScb->SendTimeout = pNpScb->SendTimeout * 3 / 2;
                        if ( pNpScb->SendTimeout > pNpScb->MaxTimeOut ) {
                            pNpScb->SendTimeout = pNpScb->MaxTimeOut;
                        }
                    }
                }

                pNpScb->TimeOut = pNpScb->SendTimeout;
                DebugTrace(+0, Dbg, "Adjusting send timeout: %x\n", pIrpContext );
                DebugTrace(+0, Dbg, "Adjusting send timeout to: %d\n", pNpScb->TimeOut );

                if ( pIrpContext->TimeoutRoutine != NULL ) {

                    DebugTrace(+0, Dbg, "Timeout Routine, retry %x\n", RetryCount+1);
                    DebugTrace(+0, Dbg, "Calling TimeoutRoutine, %x\n", pIrpContext->TimeoutRoutine);
                    pIrpContext->TimeoutRoutine( pIrpContext );

                } else {

                    DebugTrace(+0, Dbg, "Resending Packet, retry %x\n", RetryCount+1);
                    PreparePacket( pIrpContext, pIrpContext->pOriginalIrp, pIrpContext->TxMdl );

                    SetFlag( pIrpContext->Flags, IRP_FLAG_RETRY_SEND );
                    SendNow( pIrpContext );
                }

                Stats.FailedSessions++;

            } else {

                ASSERT( pIrpContext->pEx != NULL );

                //
                //  We are out of retries.
                //

                if ( (!BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_REROUTE_IN_PROGRESS ) &&
                     ((BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_REROUTE_ATTEMPTED ) ||
                     ((NwAbsoluteTotalWaitTime != 0) && (pNpScb->TotalWaitTime >= NwAbsoluteTotalWaitTime )))))) {


                    ClearFlag( pIrpContext->Flags, IRP_FLAG_RETRY_SEND );

                    //
                    //  He have already attempted to reroute the request.
                    //  Give up.
                    //

                    DebugTrace(+0, Dbg, "Abandon Exchange\n", 0 );

                    if ( pIrpContext->pNpScb != &NwPermanentNpScb ) {

                        //
                        //  Reset to the attaching state.  If the server
                        //  is dead, the next attempt to open a handle will
                        //  fail with a better error than unexpected network
                        //  error.
                        //

                        pIrpContext->pNpScb->State = SCB_STATE_ATTACHING;

                        //
                        //  Determine the CurrentTime. We need to know if
                        //  TimeOutEventInterval minutes have passed before
                        //  we log the next time-out event.
                        //

                        KeQuerySystemTime( &CurrentTime );

                        if ( CanLogTimeOutEvent( pNpScb->NwNextEventTime,
                                                CurrentTime
                                                )) {

                            if ( pNpScb->ServerName.Buffer != NULL ) {
                                ServerLogName = pNpScb->ServerName.Buffer;
                            } else {
                                ServerLogName = &AnonymousName[0];
                            }

                            Error(
                                EVENT_NWRDR_TIMEOUT,
                                STATUS_UNEXPECTED_NETWORK_ERROR,
                                NULL,
                                0,
                                1,
                                ServerLogName );

                            //
                            //  Set the LastEventTime to the CurrentTime
                            //

                            UpdateNextEventTime(
                                    pNpScb->NwNextEventTime,
                                    CurrentTime,
                                    TimeOutEventInterval
                                    );
                        }

                    }

                    pIrpContext->ResponseParameters.Error = ERROR_UNEXP_NET_ERR;
                    pIrpContext->pEx( pIrpContext, 0, NULL );

                } else if (!BooleanFlagOn(pIrpContext->Flags, IRP_FLAG_REROUTE_IN_PROGRESS)) {

                    //
                    //  Attempt to reroute the request if it hasn't already been rerouted
                    //

                   SetFlag( pIrpContext->Flags, IRP_FLAG_REROUTE_ATTEMPTED );

                   if ((WorkerThreadRunning == TRUE) && (workContext = AllocateWorkContext())){
                   
                       //
                       // Prepare the work context
                       //

                       workContext->pIrpC = pIrpContext;
                       workContext->NodeWorkCode = NWC_NWC_REROUTE;
                      
                       //
                       // and queue it.
                       //
                       DebugTrace( 0, Dbg, "Queueing reroute work.\n", 0 );
                       
                       //
                       // Make sure we don't give up on this IrpContext. Also, reference
                       // the SCB so that it doesn't get scavenged.
                       //

                       SetFlag( pIrpContext->Flags, IRP_FLAG_REROUTE_IN_PROGRESS );
                       NwReferenceScb( pIrpContext->pNpScb );

                       KeInsertQueue( &KernelQueue,
                                      &workContext->Next
                                      );

                   } else {

                      //
                      // The worker thread is not running or, we could not 
                      // allocate a work context. Hence, we cannot
                      // attempt the reroute. 
                      //
                      pIrpContext->ResponseParameters.Error = ERROR_UNEXP_NET_ERR;
                      pIrpContext->pEx( pIrpContext, 0, NULL );

                   }

                }                       
            }

        } else {

            if ( ( !IsListEmpty( &pNpScb->Requests )) &&
                 ( !pNpScb->Sending ) &&
                 ( pNpScb->OkToReceive ) ) {

                DebugTrace( 0, Dbg, "TimeOut %d\n", pNpScb->TimeOut );
            }

            //
            //  Nothing to do for this SCB.  Dereference this SCB and
            //  release the spin lock.
            //

            KeReleaseSpinLockFromDpcLevel( &pNpScb->NpScbSpinLock );
            NwQuietDereferenceScb( pNpScb );
        }

        KeAcquireSpinLockAtDpcLevel( &ScbSpinLock );

    }

    KeReleaseSpinLockFromDpcLevel( &ScbSpinLock );

    //
    //  Now see if the scavenger routine needs to be run.
    //  Only ever queue one workitem.
    //

    KeAcquireSpinLockAtDpcLevel( &NwScavengerSpinLock );

    NwScavengerTickCount++;
    if (( !WorkerRunning ) && ( !fPoweringDown ) &&
        ( NwScavengerTickCount > NwScavengerTickRunCount )) {

        ExInitializeWorkItem( &WorkItem, NwScavengerRoutine, &WorkItem );
        ExQueueWorkItem( &WorkItem, DelayedWorkQueue );
        NwScavengerTickCount = 0;
        WorkerRunning = TRUE;
    }

    KeReleaseSpinLockFromDpcLevel( &NwScavengerSpinLock );

    //
    //  Scan the list of pending locks, looking for locks to retry.
    //

    KeAcquireSpinLockAtDpcLevel( &NwPendingLockSpinLock );

    for (IrpContextEntry = NwPendingLockList.Flink ;
         IrpContextEntry != &NwPendingLockList ;
         IrpContextEntry = NextIrpContextEntry ) {

        NextIrpContextEntry = IrpContextEntry->Flink;
        pIrpContext = CONTAINING_RECORD( IrpContextEntry, IRP_CONTEXT, NextRequest );

        if ( --pIrpContext->Specific.Lock.Key <= 0 ) {

            //
            //  Remove the IRP Context from the queue and reattempt the lock.
            //  Set the SEQUENCE_NO_REQUIRED flag so that the packet gets
            //  renumbered.
            //

            RemoveEntryList( &pIrpContext->NextRequest );
            SetFlag( pIrpContext->Flags,  IRP_FLAG_SEQUENCE_NO_REQUIRED );
            PrepareAndSendPacket( pIrpContext );
        }

    }

    KeReleaseSpinLockFromDpcLevel( &NwPendingLockSpinLock );

    //
    //  Reset the timer to run for another tick if nobody has cancelled it
    //  in the meantime.
    //
    
    KeAcquireSpinLockAtDpcLevel( &NwTimerSpinLock );

    if (!TimerStop) {
        (VOID)KeSetTimer ( &Timer, DueTime, &NwDpc);
    }

    KeReleaseSpinLockFromDpcLevel( &NwTimerSpinLock );
    
    //DebugTrace(-1, Dbg, "TimerDpc\n", 0);
    return;

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (Context);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\volinfo.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the get / set volume information routines for
    netware redirector.

    Setting volume information is currently unimplemented.

Author:

     Manny Weiser (mannyw)    4-Mar-1993

Revision History:

--*/

#include "procs.h"

#define NW_FS_NAME  L"NWCompat"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_VOLINFO)

//
// Local procedure prototypes.
//

NTSTATUS
NwCommonQueryVolumeInformation (
    IN PIRP_CONTEXT pIrpContext
    );

NTSTATUS
NwQueryAttributeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

NTSTATUS
NwQueryVolumeInfo (
    IN PIRP_CONTEXT pIrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

NTSTATUS
NwQueryLabelInfo (
    IN PIRP_CONTEXT pIrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_LABEL_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

NTSTATUS
NwQuerySizeInfo (
    IN PIRP_CONTEXT pIrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN ULONG Length
    );

NTSTATUS
QueryFsSizeInfoCallback(
    IN PIRP_CONTEXT pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    );

NTSTATUS
QueryFsSizeInfoCallback2(
    IN PIRP_CONTEXT pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    );

NTSTATUS
NwQueryDeviceInfo (
    IN PIRP_CONTEXT pIrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN ULONG Length
    );

NTSTATUS
NwCommonSetVolumeInformation (
    IN PIRP_CONTEXT pIrpContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdQueryVolumeInformation )
#pragma alloc_text( PAGE, NwCommonQueryVolumeInformation )
#pragma alloc_text( PAGE, NwQueryAttributeInfo )
#pragma alloc_text( PAGE, NwQueryVolumeInfo )
#pragma alloc_text( PAGE, NwQueryLabelInfo )
#pragma alloc_text( PAGE, NwQuerySizeInfo )
#pragma alloc_text( PAGE, NwQueryDeviceInfo )
#pragma alloc_text( PAGE, NwFsdSetVolumeInformation )
#pragma alloc_text( PAGE, NwCommonSetVolumeInformation )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, QueryFsSizeInfoCallback )
#pragma alloc_text( PAGE1, QueryFsSizeInfoCallback2 )
#endif

#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif


NTSTATUS
NwFsdQueryVolumeInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtQueryVolumeInformationFile
    API calls.

Arguments:

    NwfsDeviceObject - Supplies a pointer to the device object to use.

    Irp - Supplies a pointer to the Irp to process.

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;
    PIRP_CONTEXT pIrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdQueryVolumeInformation\n", 0);

    //
    // Call the common query volume information routine.
    //

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        pIrpContext = AllocateIrpContext( Irp );
        status = NwCommonQueryVolumeInformation( pIrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( pIrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error Status that we get back from the
            //  execption code
            //

            status = NwProcessException( pIrpContext, GetExceptionCode() );
        }

    }

    if ( pIrpContext ) {

        if ( status != STATUS_PENDING ) {
            NwDequeueIrpContext( pIrpContext, FALSE );
        }

        NwCompleteRequest( pIrpContext, status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "NwFsdQueryVolumeInformation -> %08lx\n", status );

    return status;
}


NTSTATUS
NwCommonQueryVolumeInformation (
    IN PIRP_CONTEXT pIrpContext
    )

/*++

Routine Description:

    This is the common routine for querying volume information.

Arguments:

    IrpContext - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    ULONG length;
    ULONG bytesWritten = 0;
    FS_INFORMATION_CLASS fsInformationClass;
    PVOID buffer;

    NODE_TYPE_CODE nodeTypeCode;

    PVOID fsContext, fsContext2;
    PICB icb = NULL;
    PVCB vcb = NULL;

    PAGED_CODE();

    //
    // Get the current stack location.
    //

    Irp = pIrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NwCommonQueryInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG_PTR)Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", irpSp->Parameters.QueryFile.Length);
    DebugTrace( 0, Dbg, " ->FsInformationClass = %08lx\n", irpSp->Parameters.QueryVolume.FsInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", (ULONG_PTR)Irp->AssociatedIrp.SystemBuffer);

    //
    // Find out who are.
    //

    if ((nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                            &fsContext,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Handle is closing\n", 0);

        NwCompleteRequest( pIrpContext, STATUS_INVALID_HANDLE );
        status = STATUS_INVALID_HANDLE;

        DebugTrace(-1, Dbg, "NwCommonQueryVolumeInformation -> %08lx\n", status );
        return status;
    }

    //
    // Decide how to handle this request.  A user can query information
    // on a VCB only.
    //

    switch (nodeTypeCode) {

    case NW_NTC_RCB:
        break;

    case NW_NTC_ICB:
        icb = (PICB)fsContext2;

        //
        //  Make sure that this ICB is still active.
        //

        NwVerifyIcb( icb );

        vcb = icb->SuperType.Fcb->Vcb;

        pIrpContext->pNpScb = icb->SuperType.Fcb->Scb->pNpScb;

        break;

    default:           // This is not a nodetype

        DebugTrace(0, Dbg, "Node type code is not incorrect\n", 0);
        DebugTrace(-1, Dbg, "NwCommonQueryVolumeInformation -> STATUS_INVALID_PARAMETER\n", 0);

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make local copies of the input parameters.
    //

    length = irpSp->Parameters.QueryVolume.Length;
    fsInformationClass = irpSp->Parameters.QueryVolume.FsInformationClass;
    buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  It is ok to attempt a reconnect if this request fails with a
    //  connection error.
    //

    SetFlag( pIrpContext->Flags, IRP_FLAG_RECONNECTABLE );

    try {

        //
        // Decide how to handle the request.
        //

        switch (fsInformationClass) {

        case FileFsVolumeInformation:

            status = NwQueryVolumeInfo( pIrpContext, vcb, buffer, length, &bytesWritten );
            break;

        case FileFsLabelInformation:
            status = NwQueryLabelInfo( pIrpContext, vcb, buffer, length, &bytesWritten );
            break;

        case FileFsSizeInformation:
            if ( vcb != NULL ) {
                status = NwQuerySizeInfo( pIrpContext, vcb, buffer, length );
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case FileFsDeviceInformation:
            status = NwQueryDeviceInfo( pIrpContext, vcb, buffer, length );
            bytesWritten = sizeof( FILE_FS_DEVICE_INFORMATION );
            break;

        case FileFsAttributeInformation:

            if ( vcb != NULL ) {
                status = NwQueryAttributeInfo( vcb, buffer, length, &bytesWritten );
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;

        default:

            status = STATUS_INVALID_PARAMETER;
            DebugTrace(0, Dbg, "Unhandled query volume level %d\n", fsInformationClass );
            break;
        }

        //
        //  Set the information field to the number of bytes actually
        //  filled in and then complete the request.
        //
        //  If the worker function returned status pending, it's
        //  callback routine will fill the information field.
        //

        if ( status != STATUS_PENDING ) {
            Irp->IoStatus.Information = bytesWritten;
        }

    } finally {

        DebugTrace(-1, Dbg, "NwCommonQueryVolumeInformation -> %08lx\n", status );
    }

    return status;
}


NTSTATUS
NwQueryAttributeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine performs the query fs attribute information operation.

Arguments:

    Vcb - Supplies the VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

    BytesWritten - Returns the number of bytes written to the buffer.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    NTSTATUS status;
    ULONG bytesToCopy;

    PAGED_CODE();

    DebugTrace(0, Dbg, "QueryFsAttributeInfo...\n", 0);

    //
    // See how many bytes of the file system name we can copy.
    //

    Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0] );

    *BytesWritten = FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0] );

    if ( Length >= sizeof(NW_FS_NAME) - 2 ) {

        status = STATUS_SUCCESS;
        *BytesWritten += sizeof(NW_FS_NAME - 2);
        bytesToCopy = sizeof( NW_FS_NAME - 2 );

    } else {

        status = STATUS_BUFFER_OVERFLOW;
        *BytesWritten += Length;
        bytesToCopy = Length;
    }

    //
    // Fill in the attribute information.
    //

    Buffer->FileSystemAttributes = 0;

    if ( Vcb->Specific.Disk.LongNameSpace == LFN_NO_OS2_NAME_SPACE ) {
        Buffer->MaximumComponentNameLength = 12;
    } else {
        Buffer->MaximumComponentNameLength = NW_MAX_FILENAME_LENGTH;
    }

    //
    // And copy over the file name and its length.
    //

    RtlMoveMemory( &Buffer->FileSystemName[0],
                   NW_FS_NAME,
                   bytesToCopy );

    Buffer->FileSystemNameLength = bytesToCopy;

    return status;
}



NTSTATUS
NwQueryVolumeInfo (
    IN PIRP_CONTEXT pIrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine performs the query fs volume information operation.

Arguments:

    Vcb - The VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    NTSTATUS status;
    UNICODE_STRING VolumeName;

    PAGED_CODE();

    DebugTrace(0, Dbg, "QueryVolumeInfo...\n", 0);

    //
    // Do the volume request synchronously.
    //

    if (!Vcb) {
        return STATUS_INVALID_PARAMETER;
    }

    status = ExchangeWithWait(
                 pIrpContext,
                 SynchronousResponseCallback,
                 "Sb",
                 NCP_DIR_FUNCTION, NCP_GET_VOLUME_STATS,
                 Vcb->Specific.Disk.Handle );

    if ( !NT_SUCCESS( status ) ) {
        return status;
    }

    //
    // Get the data from the response.
    //

    VolumeName.MaximumLength =
        (USHORT)(MIN( MAX_VOLUME_NAME_LENGTH * sizeof( WCHAR ),
                 Length - FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel) ) );
    VolumeName.Buffer = Buffer->VolumeLabel;

    status = ParseResponse(
                 pIrpContext,
                 pIrpContext->rsp,
                 pIrpContext->ResponseLength,
                 "N=====R",
                 &VolumeName,
                 MAX_VOLUME_NAME_LENGTH );

    //
    // Fill in the volume information.
    //

    Buffer->VolumeCreationTime.HighPart = 0;
    Buffer->VolumeCreationTime.LowPart = 0;
    Buffer->VolumeSerialNumber = 0;
    Buffer->VolumeLabelLength = VolumeName.Length;
    Buffer->SupportsObjects = FALSE;

    pIrpContext->pOriginalIrp->IoStatus.Information =
        FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel[0] ) +
        VolumeName.Length;
    *BytesWritten = (ULONG) pIrpContext->pOriginalIrp->IoStatus.Information;

    pIrpContext->pOriginalIrp->IoStatus.Status = status;

    //
    //  If the volume has been unmounted and remounted then we will
    //  fail this dir but the next one will be fine.
    //

    if (status == STATUS_UNSUCCESSFUL) {
        NwReopenVcbHandle( pIrpContext, Vcb);
    }

    return status;
}


NTSTATUS
NwQueryLabelInfo (
    IN PIRP_CONTEXT pIrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_LABEL_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine performs the query fs label information operation.

Arguments:

    Vcb - The VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    NTSTATUS status;
    UNICODE_STRING VolumeName;

    PAGED_CODE();

    DebugTrace(0, Dbg, "QueryLabelInfo...\n", 0);

    //
    // Do the volume query synchronously.
    //

    status = ExchangeWithWait(
                 pIrpContext,
                 SynchronousResponseCallback,
                 "Sb",
                 NCP_DIR_FUNCTION, NCP_GET_VOLUME_STATS,
                 Vcb->Specific.Disk.Handle );

    if ( !NT_SUCCESS( status ) ) {
        return status;
    }

    VolumeName.MaximumLength =
        (USHORT)(MIN( MAX_VOLUME_NAME_LENGTH * sizeof( WCHAR ),
                 Length - FIELD_OFFSET(FILE_FS_LABEL_INFORMATION,  VolumeLabel) ) );
    VolumeName.Buffer = Buffer->VolumeLabel;

    status = ParseResponse(
             pIrpContext,
             pIrpContext->rsp,
             pIrpContext->ResponseLength,
             "N=====R",
             &VolumeName, 12 );

    //
    // Fill in the label information.
    //

    Buffer->VolumeLabelLength = VolumeName.Length;

    pIrpContext->pOriginalIrp->IoStatus.Information =
        FIELD_OFFSET( FILE_FS_LABEL_INFORMATION, VolumeLabel[0] ) +
        VolumeName.Length;
    *BytesWritten = (ULONG) pIrpContext->pOriginalIrp->IoStatus.Information;

    pIrpContext->pOriginalIrp->IoStatus.Status = status;

    return status;

}


NTSTATUS
NwQuerySizeInfo (
    IN PIRP_CONTEXT pIrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine performs the query fs size information operation.

Arguments:

    Vcb - The VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    DebugTrace(0, Dbg, "QueryFsSizeInfo...\n", 0);

    //
    // Remember where the response goes.
    //

    pIrpContext->Specific.QueryVolumeInformation.Buffer = Buffer;
    pIrpContext->Specific.QueryVolumeInformation.Length = Length;
    pIrpContext->Specific.QueryVolumeInformation.VolumeNumber = Vcb->Specific.Disk.VolumeNumber;

    //
    // Start a Get Size Information NCP
    //

    status = Exchange(
                 pIrpContext,
                 QueryFsSizeInfoCallback,
                 "Sb",
                 NCP_DIR_FUNCTION, NCP_GET_VOLUME_STATS,
                 Vcb->Specific.Disk.Handle );

    return( status );
}

NTSTATUS
QueryFsSizeInfoCallback(
    IN PIRP_CONTEXT pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )
/*++

Routine Description:

    This routine receives the query volume size response and generates
    a Query Standard Information response.

Arguments:


Return Value:

    VOID

--*/
{
    PFILE_FS_SIZE_INFORMATION Buffer;
    NTSTATUS Status;

    DebugTrace(0, Dbg, "QueryFsSizeInfoCallback...\n", 0);

    if ( BytesAvailable == 0) {

        //
        //  We're done with this request.  Dequeue the IRP context from
        //  SCB and complete the request.
        //

        NwDequeueIrpContext( pIrpContext, FALSE );
        NwCompleteRequest( pIrpContext, STATUS_REMOTE_NOT_LISTENING );

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

        DebugTrace( 0, Dbg, "Timeout\n", 0);
        return STATUS_REMOTE_NOT_LISTENING;
    }

    //
    // Get the data from the response.
    //

    Buffer = pIrpContext->Specific.QueryVolumeInformation.Buffer;
    RtlZeroMemory( Buffer, sizeof( FILE_FS_SIZE_INFORMATION ) );

    Status = ParseResponse(
                 pIrpContext,
                 Response,
                 BytesAvailable,
                 "Nwww",
                 &Buffer->SectorsPerAllocationUnit,
                 &Buffer->TotalAllocationUnits.LowPart,
                 &Buffer->AvailableAllocationUnits.LowPart );

    if ( NT_SUCCESS( Status ) ) {

        if (Buffer->TotalAllocationUnits.LowPart == 0xffff) {

            //
            // The next callback will fill in all the appropriate size info.
            //

            Status = Exchange(
                         pIrpContext,
                         QueryFsSizeInfoCallback2,
                         "Sb",
                         NCP_DIR_FUNCTION, NCP_GET_VOLUME_INFO,
                         pIrpContext->Specific.QueryVolumeInformation.VolumeNumber );

            if (Status == STATUS_PENDING) {
                return( STATUS_SUCCESS );
            }

        } else {

            //
            // Fill in the remaining size information.
            //

            Buffer->BytesPerSector = 512;

            pIrpContext->pOriginalIrp->IoStatus.Information =
                sizeof( FILE_FS_SIZE_INFORMATION );
        }
    }

    //
    //  We're done with this request.  Dequeue the IRP context from
    //  SCB and complete the request.
    //

    NwDequeueIrpContext( pIrpContext, FALSE );
    NwCompleteRequest( pIrpContext, Status );

    return STATUS_SUCCESS;
}

NTSTATUS
QueryFsSizeInfoCallback2(
    IN PIRP_CONTEXT pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )
/*++

Routine Description:

    This routine receives the query volume size response and generates
    a Query Standard Information response.

Arguments:


Return Value:

    VOID

--*/
{
    PFILE_FS_SIZE_INFORMATION Buffer;
    NTSTATUS Status;
    ULONG PurgeableAllocationUnits;
    ULONG OriginalFreeSpace, OriginalSectorsPerAllocUnit, OriginalTotalSpace;
    ULONG ScaleSectorsPerUnit;

    DebugTrace(0, Dbg, "QueryFsSizeInfoCallback2...\n", 0);

    if ( BytesAvailable == 0) {

        //
        //  We're done with this request.  Dequeue the IRP context from
        //  SCB and complete the request.
        //

        NwDequeueIrpContext( pIrpContext, FALSE );
        NwCompleteRequest( pIrpContext, STATUS_REMOTE_NOT_LISTENING );

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

        DebugTrace( 0, Dbg, "Timeout\n", 0);
        return STATUS_REMOTE_NOT_LISTENING;
    }

    //
    // Get the data from the response.  Save off the data from
    // the GET_VOLUME_STATS call to compute the correct sizes.
    //

    Buffer = pIrpContext->Specific.QueryVolumeInformation.Buffer;

    OriginalTotalSpace = Buffer->TotalAllocationUnits.LowPart;
    OriginalFreeSpace = Buffer->AvailableAllocationUnits.LowPart;
    OriginalSectorsPerAllocUnit = Buffer->SectorsPerAllocationUnit;

    RtlZeroMemory( Buffer, sizeof( FILE_FS_SIZE_INFORMATION ) );

    Status = ParseResponse(
                 pIrpContext,
                 Response,
                 BytesAvailable,
                 "Neee_b",
                 &Buffer->TotalAllocationUnits.LowPart,
                 &Buffer->AvailableAllocationUnits.LowPart,
                 &PurgeableAllocationUnits,
                 16,
                 &Buffer->SectorsPerAllocationUnit);

    if ( NT_SUCCESS( Status ) ) {

        //
        // If the original free space was maxed out, just add the
        // additionally indicated units.  Otherwise, return the
        // original free space (which is the correct limit) and
        // adjust the sectors per allocation units if necessary.
        //

        if ( OriginalFreeSpace != 0xffff ) {

            Buffer->AvailableAllocationUnits.LowPart = OriginalFreeSpace;

            if ( ( Buffer->SectorsPerAllocationUnit != 0 ) &&
                 ( OriginalSectorsPerAllocUnit != 0 ) ) {

                //
                // ScaleSectorsPerUnit should always be a whole number.
                // There's no floating point here!!
                //

                if ( (ULONG) Buffer->SectorsPerAllocationUnit <= OriginalSectorsPerAllocUnit ) {

                    ScaleSectorsPerUnit =
                        OriginalSectorsPerAllocUnit / Buffer->SectorsPerAllocationUnit;
                    Buffer->TotalAllocationUnits.LowPart /= ScaleSectorsPerUnit;

                } else {

                    ScaleSectorsPerUnit =
                        Buffer->SectorsPerAllocationUnit / OriginalSectorsPerAllocUnit;
                    Buffer->TotalAllocationUnits.LowPart *= ScaleSectorsPerUnit;
                }

                Buffer->SectorsPerAllocationUnit = OriginalSectorsPerAllocUnit;
           }

        } else {

            Buffer->AvailableAllocationUnits.QuadPart += PurgeableAllocationUnits;
        }

    } else {

        //
        // If we didn't succeed the second packet, restore the original values.
        //

        Buffer->TotalAllocationUnits.LowPart = OriginalTotalSpace;
        Buffer->AvailableAllocationUnits.LowPart = OriginalFreeSpace;
        Buffer->SectorsPerAllocationUnit = OriginalSectorsPerAllocUnit;

    }

    //
    // Fill in the remaining size information.
    //

    Buffer->BytesPerSector = 512;

    pIrpContext->pOriginalIrp->IoStatus.Information =
        sizeof( FILE_FS_SIZE_INFORMATION );

    //
    //  We're done with this request.  Dequeue the IRP context from
    //  SCB and complete the request.
    //

    NwDequeueIrpContext( pIrpContext, FALSE );
    NwCompleteRequest( pIrpContext, Status );

    return STATUS_SUCCESS;
}



NTSTATUS
NwQueryDeviceInfo (
    IN PIRP_CONTEXT pIrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine performs the query fs size information operation.

Arguments:

    Vcb - The VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "QueryFsDeviceInfo...\n", 0);

    //- Multi-user code merge --
    //  Citrix bug fix.
    //
    if (Vcb && FlagOn( Vcb->Flags, VCB_FLAG_PRINT_QUEUE)) {
        Buffer->DeviceType = FILE_DEVICE_PRINTER;
    } else {
        Buffer->DeviceType = FILE_DEVICE_DISK;
    }

    Buffer->Characteristics = FILE_REMOTE_DEVICE;

    return( STATUS_SUCCESS );
}


NTSTATUS
NwFsdSetVolumeInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD part of the NtSetVolumeInformationFile
    API calls.

Arguments:

    NwfsDeviceObject - Supplies a pointer to the device object to use.

    Irp - Supplies a pointer to the Irp to process.

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;
    PIRP_CONTEXT pIrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdSetVolumeInformation\n", 0);

    //
    // Call the common query volume information routine.
    //

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        pIrpContext = AllocateIrpContext( Irp );
        status = NwCommonSetVolumeInformation( pIrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( pIrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error Status that we get back from the
            //  execption code
            //

            status = NwProcessException( pIrpContext, GetExceptionCode() );
        }
    }

    if ( pIrpContext ) {

        if ( status != STATUS_PENDING ) {
            NwDequeueIrpContext( pIrpContext, FALSE );
        }

        NwCompleteRequest( pIrpContext, status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "NwFsdSetVolumeInformation -> %08lx\n", status );

    return status;
}


NTSTATUS
NwCommonSetVolumeInformation (
    IN PIRP_CONTEXT pIrpContext
    )
/*++

Routine Description:

    This is the common routine for setting volume information.

Arguments:

    IrpContext - Supplies the Irp context to process

Return Value:

    NTSTATUS - the return status for the operation.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    FS_INFORMATION_CLASS fsInformationClass;

    NODE_TYPE_CODE nodeTypeCode;

    PVOID fsContext, fsContext2;
    PICB icb = NULL;
    PVCB vcb = NULL;

    PAGED_CODE();

    //
    // Get the current stack location.
    //

    Irp = pIrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NwCommonSetVolumeInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG_PTR)Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", irpSp->Parameters.QueryFile.Length);
    DebugTrace( 0, Dbg, " ->FsInformationClass = %08lx\n", irpSp->Parameters.QueryVolume.FsInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", (ULONG_PTR)Irp->AssociatedIrp.SystemBuffer);

    //
    // Find out who are.
    //

    if ((nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                            &fsContext,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Handle is closing\n", 0);

        NwCompleteRequest( pIrpContext, STATUS_INVALID_HANDLE );
        status = STATUS_INVALID_HANDLE;

        DebugTrace(-1, Dbg, "NwCommonSetVolumeInformation -> %08lx\n", status );
        return status;
    }

    //
    // Decide how to handle this request.  A user can set information
    // on a VCB only.
    //

    switch (nodeTypeCode) {

    case NW_NTC_RCB:
        break;

    case NW_NTC_ICB:
        icb = (PICB)fsContext2;

        //
        //  Make sure that this ICB is still active.
        //

        NwVerifyIcb( icb );

        vcb = icb->SuperType.Fcb->Vcb;

        pIrpContext->pNpScb = icb->SuperType.Fcb->Scb->pNpScb;

        break;

    default:           // This is not a nodetype

        DebugTrace(0, Dbg, "Node type code is not incorrect\n", 0);
        DebugTrace(-1, Dbg, "NwCommonSetVolumeInformation -> STATUS_INVALID_PARAMETER\n", 0);

        return STATUS_INVALID_PARAMETER;
    }

    fsInformationClass = irpSp->Parameters.SetVolume.FsInformationClass;

    try {

        //
        // Decide how to handle the request.
        //

        switch (fsInformationClass) {

        case FileFsLabelInformation:

            //
            //  We're not allowed to set the label on a Netware volume.
            //

            status = STATUS_ACCESS_DENIED;
            break;

        default:

            status = STATUS_INVALID_PARAMETER;
            DebugTrace(0, Dbg, "Unhandled set volume level %d\n", fsInformationClass );
            break;
        }

        //
        //  Set the information field to the number of bytes actually
        //  filled in and then complete the request.
        //
        //  If the worker function returned status pending, it's
        //  callback routine will fill the information field.
        //

        if ( status != STATUS_PENDING ) {
            Irp->IoStatus.Information = 0;
        }

    } finally {

        DebugTrace(-1, Dbg, "NwCommonSetVolumeInformation -> %08lx\n", status );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\util.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Util.c

Abstract:

    This module contains utilities function for the netware redirector.

Author:

    Manny Weiser     [MannyW]    07-Jan-1994

Revision History:

--*/

#include "Procs.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CONVERT)

#ifdef ALLOC_PRAGMA
#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, CopyBufferToMdl )
#endif
#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif



VOID
CopyBufferToMdl(
    PMDL DestinationMdl,
    ULONG DataOffset,
    PUCHAR SourceData,
    ULONG SourceByteCount
    )
/*++

Routine Description:

    This routine copies data from a buffer described by a pointer to a
    given offset in a buffer described by an MDL.

Arguments:

    DestinationMdl - The MDL for the destination buffer.

    DataOffset - The offset into the destination buffer to copy the data.

    SourceData - A pointer to the source data buffer.

    SourceByteCount - The number of bytes to copy.

Return Value:

    None.

--*/
{
    ULONG BufferOffset;
    ULONG PreviousBufferOffset;
    PMDL Mdl;
    ULONG BytesToCopy;
    ULONG MdlByteCount;
    PVOID pSystemVa;

    DebugTrace( +1, Dbg, "MdlMoveMemory...\n", 0 );
    DebugTrace(  0, Dbg, "Desitination MDL = %X\n", DestinationMdl );
    DebugTrace(  0, Dbg, "DataOffset       = %d\n", DataOffset );
    DebugTrace(  0, Dbg, "SourceData       = %X\n", SourceData );
    DebugTrace(  0, Dbg, "SourceByteCount  = %d\n", SourceByteCount );

    BufferOffset = 0;

    Mdl = DestinationMdl;

    //
    //  Truncate the response if it is too big.
    //

    MdlByteCount = MdlLength( Mdl );
    if ( SourceByteCount + DataOffset > MdlByteCount ) {
        SourceByteCount = MdlByteCount - DataOffset;
    }

    while ( Mdl != NULL && SourceByteCount != 0 ) {

        PreviousBufferOffset = BufferOffset;
        BufferOffset += MmGetMdlByteCount( Mdl );

        if ( DataOffset < BufferOffset ) {

            //
            //  Copy the data to this buffer
            //

            while ( SourceByteCount > 0 ) {

                BytesToCopy = MIN( SourceByteCount,
                                   BufferOffset - DataOffset );

                pSystemVa = MmGetSystemAddressForMdlSafe( Mdl, NormalPagePriority );

                DebugTrace(  0, Dbg, "Copy to    %X\n", (PUCHAR) pSystemVa +
                                                                 DataOffset -
                                                                 PreviousBufferOffset );
                DebugTrace(  0, Dbg, "Copy from  %X\n", SourceData );
                DebugTrace(  0, Dbg, "Copy bytes %d\n", BytesToCopy );

                TdiCopyLookaheadData(
                    (PUCHAR)pSystemVa + DataOffset - PreviousBufferOffset,
                    SourceData,
                    BytesToCopy,
                    0 );

                SourceData += BytesToCopy;
                DataOffset += BytesToCopy;
                SourceByteCount -= BytesToCopy;

                Mdl = Mdl->Next;
                if ( Mdl != NULL ) {
                    PreviousBufferOffset = BufferOffset;
                    BufferOffset += MmGetMdlByteCount( Mdl );
                } else {
                    ASSERT( SourceByteCount == 0 );
                }
            }

        } else {

            Mdl = Mdl->Next;

        }
    }

    DebugTrace( -1, Dbg, "MdlMoveMemory -> VOID\n", 0 );
}

//
// These parsing routines are used to do multiple credential
// connects to a single server.
//

NTSTATUS
GetCredentialFromServerName(
    IN PUNICODE_STRING puServerName,
    OUT PUNICODE_STRING puCredentialName
)
/*+++

   Description:  Given a munged server(credential) name,
   this routine returns the credential.
---*/
{

    DWORD NameLength = 0;
    BOOLEAN FoundFirstParen = FALSE;
    BOOLEAN FoundLastParen = FALSE;

    DebugTrace( 0, Dbg, "GetCredentialFromServerName: %wZ\n", puServerName );

    puCredentialName->Length = puServerName->Length;
    puCredentialName->Buffer = puServerName->Buffer;

    //
    // Find the first paren.
    //

    while ( ( puCredentialName->Length ) && !FoundFirstParen ) {

        if ( puCredentialName->Buffer[0] == L'(' ) {
            FoundFirstParen = TRUE;
        }

        puCredentialName->Buffer++;
        puCredentialName->Length -= sizeof( WCHAR );
    }

    if ( !FoundFirstParen ) {
        DebugTrace( 0, Dbg, "No opening paren for server(credential) name.\n", 0 );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Figure out the name length.
    //

    while ( ( puCredentialName->Length ) && !FoundLastParen ) {

        if ( puCredentialName->Buffer[NameLength] == L')' ) {
            FoundLastParen = TRUE;
        }

        NameLength++;
        puCredentialName->Length -= sizeof( WCHAR );
    }

    if ( !FoundLastParen ) {
        DebugTrace( 0, Dbg, "No closing paren for server(credential) name.\n", 0 );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Format the name and return.  Don't count the closing paren.
    //

    NameLength--;

    if ( !NameLength ) {
        DebugTrace( 0, Dbg, "Null credential name.\n", 0 );
        return STATUS_UNSUCCESSFUL;
    }

    puCredentialName->Length = (USHORT) (NameLength * sizeof( WCHAR ));
    puCredentialName->MaximumLength = puCredentialName->Length;

    DebugTrace( 0, Dbg, "GetCredentialFromServerName --> %wZ\n", puCredentialName );

    return STATUS_SUCCESS;

}

NTSTATUS
BuildExCredentialServerName(
    IN PUNICODE_STRING puServerName,
    IN PUNICODE_STRING puUserName,
    OUT PUNICODE_STRING puExCredServerName
)
/*+++

Description:

    Takes a server name and a user name and makes an
    ExCredServerName, which is simply: server(user)

    This routine allocates memory for the credential
    server name and the caller is responsible for
    freeing the memory when it is no longer needed.

---*/
{

    NTSTATUS Status;
    PBYTE pbCredNameBuffer;

    DebugTrace( 0, Dbg, "BuildExCredentialServerName\n", 0 );

    if ( ( !puExCredServerName ) ||
         ( !puServerName ) ||
         ( !puUserName ) ) {

        DebugTrace( 0, DEBUG_TRACE_ALWAYS, "BuildExCredentialServerName -> STATUS_INVALID_PARAMETER\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    puExCredServerName->MaximumLength = puServerName->Length +
                                        puUserName->Length +
                                        ( 2 * sizeof( WCHAR ) );

    pbCredNameBuffer = ALLOCATE_POOL( PagedPool,
                                      puExCredServerName->MaximumLength );

    if ( pbCredNameBuffer == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    puExCredServerName->Buffer = (PWCHAR) pbCredNameBuffer;
    puExCredServerName->Length = puExCredServerName->MaximumLength;

    //
    // Copy over the server name.
    //

    RtlCopyMemory( pbCredNameBuffer,
                   puServerName->Buffer,
                   puServerName->Length );

    pbCredNameBuffer += puServerName->Length;

    //
    // Add the credential name in parenthesis.
    //

    *( (PWCHAR) pbCredNameBuffer ) = L'(';

    pbCredNameBuffer += sizeof( WCHAR );

    RtlCopyMemory( pbCredNameBuffer,
                   puUserName->Buffer,
                   puUserName->Length );

    pbCredNameBuffer += puUserName->Length;

    *( (PWCHAR) pbCredNameBuffer ) = L')';

    DebugTrace( 0, Dbg, "BuildExCredentialServerName: %wZ\n", puExCredServerName );
    return STATUS_SUCCESS;

}

NTSTATUS
UnmungeCredentialName(
    IN PUNICODE_STRING puCredName,
    OUT PUNICODE_STRING puServerName
)
/*+++

Description:

    Given server(username), return the server
    name portion.

---*/
{

    USHORT Length = 0;

    DebugTrace( 0, Dbg, "UnmungeCredentialName: %wZ\n", puCredName );

    puServerName->Buffer = puCredName->Buffer;
    puServerName->MaximumLength = puCredName->MaximumLength;

    while ( Length < ( puCredName->Length / sizeof( WCHAR ) ) ) {

        //
        // Look for the opening paren.
        //

        if ( puCredName->Buffer[Length] == L'(' ) {
            break;
        }

        Length++;
    }

    puServerName->Length = Length * sizeof( WCHAR );

    DebugTrace( 0, Dbg, "    -> %wZ\n", puServerName );
    return STATUS_SUCCESS;

}

BOOLEAN
IsCredentialName(
    IN PUNICODE_STRING puObjectName
)
/*+++

Description:  This returns TRUE if the object is an extended
              credential munged name.

---*/
{

    DWORD dwCurrent = 0;

    if ( !puObjectName ) {
        return FALSE;
    }

    while ( dwCurrent < ( puObjectName->Length ) / sizeof( WCHAR ) ) {

        if ( puObjectName->Buffer[dwCurrent] == L'(' ) {
            return TRUE;
        }

        dwCurrent++;
    }

    return FALSE;
}

NTSTATUS
ExCreateReferenceCredentials(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING puResource
)
/*+++

    On an extended create this checks for credentials
    and, if they exist, references them and resets the
    last used time.  If the credentials do not exist
    then a credential shell is created and referenced.
    
    This function is responsible for determining the
    tree name from the resource.  The resource may be
    a server in the tree, or the name of the tree.
    
---*/
{

    NTSTATUS Status;
    PLOGON pLogon;
    PSCB pScb;
    UNICODE_STRING TreeName;
    PNDS_SECURITY_CONTEXT pCredentials;
    UNICODE_STRING ExName;

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    pLogon = FindUser( &(pIrpContext->Specific.Create.UserUid), FALSE );
    NwReleaseRcb( &NwRcb );

    if ( !pLogon ) {
        DebugTrace( 0, Dbg, "Invalid client security context in ExCreateReferenceCredentials.\n", 0 );
        return STATUS_ACCESS_DENIED;
    }
    
    //
    // The resource name is either a server or a tree.  We need the tree
    // name to create the credential.  The following should work even if
    // there is a server and tree with the same name.
    //

    Status = CreateScb( &pScb,
                        pIrpContext,
                        puResource,
                        NULL,
                        NULL,
                        NULL,
                        TRUE,
                        FALSE );

    if ( NT_SUCCESS( Status ) ) {

        //
        // This is a server, dig out the tree name.
        //

        TreeName.Length = pScb->NdsTreeName.Length;
        TreeName.MaximumLength = pScb->NdsTreeName.MaximumLength;
        TreeName.Buffer = pScb->NdsTreeName.Buffer;

    } else {

        //
        // This must already be the tree name.
        //

        TreeName.Length = puResource->Length;
        TreeName.MaximumLength = puResource->MaximumLength;
        TreeName.Buffer = puResource->Buffer;
        pScb = NULL;
    }

    //
    // Get/Create the credential shell and reference it.
    //

    if ( !IsCredentialName( &TreeName ) ) {

        Status = BuildExCredentialServerName( 
                     &TreeName,
                     pIrpContext->Specific.Create.puCredentialName,
                     &ExName );

        if ( !NT_SUCCESS( Status ) ) {
            goto ExitWithCleanup;
        }
    }
    else {

        ExName = TreeName ;
    }


    Status = NdsLookupCredentials( pIrpContext,
                                   &ExName,
                                   pLogon,
                                   &pCredentials,
                                   CREDENTIAL_WRITE,
                                   TRUE );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    //
    // Adjust the reference counts.
    //

    ASSERT( IsCredentialName( &pCredentials->NdsTreeName ) );
    pCredentials->SupplementalHandleCount += 1;
    KeQuerySystemTime( &pCredentials->LastUsedTime );
    pIrpContext->Specific.Create.pExCredentials = pCredentials;

    NwReleaseCredList( pLogon, pIrpContext );

    if (ExName.Buffer != TreeName.Buffer) {

        //
        // only free if we allocated it via BuildExCredentialServerName
        //
        FREE_POOL( ExName.Buffer );
    }

ExitWithCleanup:

    if ( pScb ) {
        NwDereferenceScb( pScb->pNpScb );
    }

    return Status;
}

NTSTATUS
ExCreateDereferenceCredentials(
    PIRP_CONTEXT pIrpContext,
    PNDS_SECURITY_CONTEXT pNdsCredentials
)
/*+++

   Dereferce extended credentials.
   
---*/
{

    NwAcquireExclusiveCredList( pNdsCredentials->pOwningLogon, pIrpContext );
    pNdsCredentials->SupplementalHandleCount -= 1;
    KeQuerySystemTime( &pNdsCredentials->LastUsedTime );
    NwReleaseCredList( pNdsCredentials->pOwningLogon, pIrpContext );
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\workque.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Workque.c

Abstract:

    This module implements the queue of work from the FSD to the
    FSP threads (system worker threads) for the NetWare redirector.

Author:

    Colin Watson    [ColinW]    19-Dec-1992

Revision History:

--*/

#include "Procs.h"

LIST_ENTRY IrpContextList;
KSPIN_LOCK IrpContextInterlock;
KSPIN_LOCK ContextInterlock;

LONG FreeContextCount = 4;  //  Allow up to 4 free contexts

LIST_ENTRY MiniIrpContextList;
LONG FreeMiniContextCount = 20;  //  Allow up to 20 free mini contexts
LONG MiniContextCount = 0;  //  Allow up to 20 free mini contexts

HANDLE   WorkerThreadHandle;

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WORKQUE)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, InitializeIrpContext )
#pragma alloc_text( PAGE, UninitializeIrpContext )
#pragma alloc_text( PAGE, NwAppendToQueueAndWait )
#pragma alloc_text( PAGE, WorkerThread )

#ifndef QFE_BUILD
//
//#pragma alloc_text( PAGE1, NwDequeueIrpContext )
//We hold a spinlock coming in or we acquire one inside the function
//So, this should be non-paged.
//
#pragma alloc_text( PAGE1, AllocateMiniIrpContext )
#pragma alloc_text( PAGE1, FreeMiniIrpContext )
#endif

#endif

#if 0  // Not pageable
AllocateIrpContext
FreeIrpContext
NwCompleteRequest
SpawnWorkerThread

// see ifndef QFE_BUILD above

#endif


PIRP_CONTEXT
AllocateIrpContext (
    PIRP pIrp
    )
/*++

Routine Description:

    Initialize a work queue structure, allocating all structures used for it.

Arguments:

    pIrp    -   Supplies the Irp for the applications request


Return Value:

    PIRP_CONTEXT - Newly allocated Irp Context.

--*/
{
    PIRP_CONTEXT IrpContext;

    if ((IrpContext = (PIRP_CONTEXT )ExInterlockedRemoveHeadList(&IrpContextList, &IrpContextInterlock)) == NULL) {

        try {

            //
            //  If there are no IRP contexts in the "zone",  allocate a new
            //  Irp context from non paged pool.
            //

            IrpContext = ALLOCATE_POOL_EX(NonPagedPool, sizeof(IRP_CONTEXT));
            if (IrpContext == NULL) {
                InternalError(("Could not allocate IRP context\n"));
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            } else {
                RtlFillMemory( IrpContext, sizeof(IRP_CONTEXT), 0 );

                IrpContext->TxMdl = NULL;
                IrpContext->RxMdl = NULL;

                KeInitializeEvent( &IrpContext->Event, SynchronizationEvent, FALSE );

                IrpContext->NodeTypeCode = NW_NTC_IRP_CONTEXT;
                IrpContext->NodeByteSize = sizeof(IRP_CONTEXT);

                IrpContext->TxMdl = ALLOCATE_MDL( &IrpContext->req, MAX_SEND_DATA, FALSE, FALSE, NULL );
                if ( IrpContext->TxMdl == NULL) {
                    InternalError(("Could not allocate TxMdl for IRP context\n"));
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

                IrpContext->RxMdl = ALLOCATE_MDL( &IrpContext->rsp, MAX_RECV_DATA, FALSE, FALSE, NULL );
                if ( IrpContext->RxMdl == NULL) {
                    InternalError(("Could not allocate RxMdl for IRP context\n"));
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
            }


        } finally {

            if ( AbnormalTermination() ) {

               if ( IrpContext != NULL ) {

                    if (IrpContext->TxMdl != NULL ) {
                        FREE_MDL( IrpContext->TxMdl );
                    }

                    FREE_POOL( IrpContext );
                } else {
                    InternalError(("Could not allocate pool for IRP context\n"));
                }
            }
        }

        MmBuildMdlForNonPagedPool(IrpContext->TxMdl);
        MmBuildMdlForNonPagedPool(IrpContext->RxMdl);

#ifdef NWDBG
        //  Make it easy to find fields in the context
        IrpContext->Signature1 = 0xfeedf00d;
        IrpContext->Signature2 = 0xfeedf00d;
        IrpContext->Signature3 = 0xfeedf00d;
#endif

        //  IrpContext is allocated. Finish off initialization.

    } else {

        //  Record that we have removed an entry from the free list
        InterlockedIncrement(&FreeContextCount);

        ASSERT( IrpContext != NULL );

        //
        //  The free list uses the start of the structure for the list entry
        //  so restore corrupted fields.
        //

        IrpContext->NodeTypeCode = NW_NTC_IRP_CONTEXT;
        IrpContext->NodeByteSize = sizeof(IRP_CONTEXT);

        //  Ensure mdl's are clean

        IrpContext->TxMdl->Next = NULL;
        IrpContext->RxMdl->Next = NULL;
        IrpContext->RxMdl->ByteCount = MAX_RECV_DATA;

        //
        // Clean "used" fields
        //

        IrpContext->Flags = 0;
        IrpContext->Icb = NULL;
        IrpContext->pEx = NULL;
        IrpContext->TimeoutRoutine = NULL;
        IrpContext->CompletionSendRoutine = NULL;
        IrpContext->ReceiveDataRoutine = NULL;
        IrpContext->pTdiStruct = NULL;

        //
        // Clean the specific data zone.
        //

        RtlZeroMemory( &(IrpContext->Specific), sizeof( IrpContext->Specific ) );

        // 8/13/96 cjc Fix problem with apps not being able to save
        //             files to NDS drives.  This was never reset so
        //             ExchangeWithWait ret'd an error to WriteNCP.

        IrpContext->ResponseParameters.Error = 0;
    }

    InterlockedIncrement(&ContextCount);

    //
    //  Save away the fields in the Irp that might be tromped by
    //  building the Irp for the exchange with the server.
    //

    IrpContext->pOriginalIrp = pIrp;

    if ( pIrp != NULL) {
        IrpContext->pOriginalSystemBuffer = pIrp->AssociatedIrp.SystemBuffer;
        IrpContext->pOriginalUserBuffer = pIrp->UserBuffer;
        IrpContext->pOriginalMdlAddress = pIrp->MdlAddress;
    }

#ifdef NWDBG
    IrpContext->pNpScb = NULL;
#endif

    ASSERT( !BooleanFlagOn( IrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE ) );

    return IrpContext;
}

VOID
FreeIrpContext (
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    Initialize a work queue structure, allocating all structures used for it.

Arguments:

    PIRP_CONTEXT IrpContext - Irp Context to free.
    None


Return Value:


--*/
{

    ASSERT( IrpContext->NodeTypeCode == NW_NTC_IRP_CONTEXT );
    ASSERT( !BooleanFlagOn( IrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE ) );
    ASSERT( IrpContext->PostProcessRoutine == NULL );

    FreeReceiveIrp( IrpContext );

#ifdef NWDBG
    IrpContext->DebugValue = 0;
#endif
    IrpContext->Flags = 0;

    //
    //  Cleanup the Irp needs to be restored to its original settings.
    //

    if ( IrpContext->pOriginalIrp != NULL ) {

        PIRP pIrp = IrpContext->pOriginalIrp;

        pIrp->AssociatedIrp.SystemBuffer = IrpContext->pOriginalSystemBuffer;

        pIrp->UserBuffer = IrpContext->pOriginalUserBuffer;

        pIrp->MdlAddress = IrpContext->pOriginalMdlAddress;

#ifdef NWDBG
        IrpContext->pOriginalIrp = NULL;
#endif
    }

#ifdef NWDBG
    RtlZeroMemory( &IrpContext->WorkQueueItem, sizeof( WORK_QUEUE_ITEM ) );
#endif

    InterlockedDecrement(&ContextCount);

    if ( InterlockedDecrement(&FreeContextCount) >= 0 ) {

        //
        //  We use the first two longwords of the IRP context as a list entry
        //  when we free it to the list.
        //

        ExInterlockedInsertTailList(&IrpContextList,
                                    (PLIST_ENTRY )IrpContext,
                                    &IrpContextInterlock);
    } else {
        //
        //  We already have as many free context as we allow so destroy
        //  this context. Restore FreeContextCount to its original value.
        //

        InterlockedIncrement( &FreeContextCount );

        FREE_MDL( IrpContext->TxMdl );
        FREE_MDL( IrpContext->RxMdl );
        FREE_POOL(IrpContext);
#ifdef NWDBG
        ContextCount --;
#endif
    }
}


VOID
InitializeIrpContext (
    VOID
    )
/*++

Routine Description:

    Initialize the Irp Context system

Arguments:

    None.


Return Value:
    None.

--*/
{
    PAGED_CODE();

    KeInitializeSpinLock(&IrpContextInterlock);
    KeInitializeSpinLock(&ContextInterlock);
    InitializeListHead(&IrpContextList);
    InitializeListHead(&MiniIrpContextList);
}

VOID
UninitializeIrpContext (
    VOID
    )
/*++

Routine Description:

    Initialize the Irp Context system

Arguments:

    None.


Return Value:
    None.

--*/
{
    PIRP_CONTEXT IrpContext;
    PLIST_ENTRY ListEntry;
    PMINI_IRP_CONTEXT MiniIrpContext;

    PAGED_CODE();

    //
    //  Free all the IRP contexts.
    //

    while ( !IsListEmpty( &IrpContextList ) ) {
        IrpContext = (PIRP_CONTEXT)RemoveHeadList( &IrpContextList );

        FREE_MDL( IrpContext->TxMdl );
        FREE_MDL( IrpContext->RxMdl );
        FREE_POOL(IrpContext);
    }

    while ( !IsListEmpty( &MiniIrpContextList ) ) {

        ListEntry = RemoveHeadList( &MiniIrpContextList );
        MiniIrpContext = CONTAINING_RECORD( ListEntry, MINI_IRP_CONTEXT, Next );

        FREE_POOL( MiniIrpContext->Buffer );
        FREE_MDL( MiniIrpContext->Mdl2 );
        FREE_MDL( MiniIrpContext->Mdl1 );
        FREE_IRP( MiniIrpContext->Irp );
        FREE_POOL( MiniIrpContext );
    }
}


VOID
NwCompleteRequest (
    PIRP_CONTEXT IrpContext,
    NTSTATUS Status
    )
/*++

Routine Description:

    The following procedure is used by the FSP and FSD routines to complete
    an IRP.

Arguments:

    IrpContext - A pointer to the IRP context information.

    Status - The status to use to complete the IRP.

Return Value:

    None.

--*/
{
    PIRP Irp;

    if ( IrpContext == NULL ) {
        return;
    }

    if ( Status == STATUS_PENDING ) {
        return;
    }

    if ( Status == STATUS_INSUFFICIENT_RESOURCES ) {
        Error( EVENT_NWRDR_RESOURCE_SHORTAGE, Status, NULL, 0, 0 );
    }

    Irp = IrpContext->pOriginalIrp;

    Irp->IoStatus.Status = Status;
    DebugTrace(0, Dbg, "Completing Irp with status %X\n", Status );

    //  Restore the Irp to its original state

    if ((Irp->CurrentLocation) > (CCHAR) (Irp->StackCount +1)) {

        DbgPrint("Irp is already completed.\n", Irp);
        DbgBreakPoint();
    }

    FreeIrpContext( IrpContext );

    IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

    return;
}


VOID
NwAppendToQueueAndWait(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine appends an IrpContext to the SCB queue, and waits the
    the queue to be ready to process the Irp.

Arguments:

    IrpContext - A pointer to the IRP context information.

Return Value:

    None.

--*/
{
    BOOLEAN AtFront;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwAppendToQueueAndWait\n", 0);

    IrpContext->RunRoutine = SetEvent;

#ifdef MSWDBG
    ASSERT( IrpContext->Event.Header.SignalState == 0 );
#endif

    AtFront = AppendToScbQueue( IrpContext, IrpContext->pNpScb );

    if ( AtFront ) {
        KickQueue( IrpContext->pNpScb );
    }

    //
    //  Wait until we get to the front of the queue.
    //

    KeWaitForSingleObject(
        &IrpContext->Event,
        UserRequest,
        KernelMode,
        FALSE,
        NULL );

    ASSERT( IrpContext->pNpScb->Requests.Flink == &IrpContext->NextRequest );

    DebugTrace(-1, Dbg, "NwAppendToQueueAndWait\n", 0);
    return;
}


VOID
NwDequeueIrpContext(
    IN PIRP_CONTEXT pIrpContext,
    IN BOOLEAN OwnSpinLock
    )
/*++

Routine Description:

    This routine removes an IRP Context from the front the SCB queue.

Arguments:

    IrpContext - A pointer to the IRP context information.

    OwnSpinLock - If TRUE, the caller owns the SCB spin lock.

Return Value:

    None.

--*/
{
    PLIST_ENTRY pListEntry;
    KIRQL OldIrql;
    PNONPAGED_SCB pNpScb;

    DebugTrace(+1, Dbg, "NwDequeueIrpContext\n", 0);

    if (!BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE ) ) {
        DebugTrace(-1, Dbg, "NwDequeueIrpContext\n", 0);
        return;
    }

    pNpScb = pIrpContext->pNpScb;

    if ( !OwnSpinLock ) {
        KeAcquireSpinLock( &pNpScb->NpScbSpinLock, &OldIrql );
    }

    //
    //  Disable timer from looking at this queue.
    //

    pNpScb->OkToReceive = FALSE;

    pListEntry = RemoveHeadList( &pNpScb->Requests );

    if ( !OwnSpinLock ) {
        KeReleaseSpinLock( &pNpScb->NpScbSpinLock, OldIrql );
    }

#ifdef NWDBG
    ASSERT ( CONTAINING_RECORD( pListEntry, IRP_CONTEXT, NextRequest ) == pIrpContext );

    {

        PIRP_CONTEXT RemovedContext = CONTAINING_RECORD( pListEntry, IRP_CONTEXT, NextRequest );
        if ( RemovedContext != pIrpContext ) {
            DbgBreakPoint();
        }

    }

    DebugTrace(
        0,
        Dbg,
        "Dequeued IRP Context %08lx\n",
        CONTAINING_RECORD( pListEntry, IRP_CONTEXT, NextRequest ) );

#ifdef MSWDBG
    pNpScb->RequestDequeued = TRUE;
#endif

#endif

    ClearFlag( pIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE );

    //
    //  Give the next IRP context on the SCB queue a chance to run.
    //

    KickQueue( pNpScb );

    DebugTrace(-1, Dbg, "NwDequeueIrpContext\n", 0);
    return;
}


VOID
NwCancelIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the cancel function for an IRP being processed
    by the redirector.

Arguments:

    DeviceObject - ignored

    Irp - Supplies the Irp being cancelled.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry, nextListEntry;
    KIRQL OldIrql;
    PIRP_CONTEXT pTestIrpContext;
    PIRP pTestIrp;

    UNREFERENCED_PARAMETER( DeviceObject );

    //
    // We now need to void the cancel routine and release the io cancel
    // spin-lock.
    //

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Now we have to search for the IRP to cancel everywhere.  So just
    //  look for cancelled IRPs and process them all.
    //

    //
    //  Process the Get Message queue.
    //

    KeAcquireSpinLock( &NwMessageSpinLock, &OldIrql );

    for ( listEntry = NwGetMessageList.Flink;
          listEntry != &NwGetMessageList;
          listEntry = nextListEntry ) {

        nextListEntry = listEntry->Flink;

        //
        //  If the file object of the queued request, matches the file object
        //  that is being closed, remove the IRP from the queue, and
        //  complete it with an error.
        //

        pTestIrpContext = CONTAINING_RECORD( listEntry, IRP_CONTEXT, NextRequest );
        pTestIrp = pTestIrpContext->pOriginalIrp;

        if ( pTestIrp->Cancel ) {
            RemoveEntryList( listEntry );
            NwCompleteRequest( pTestIrpContext, STATUS_CANCELLED );
        }

    }

    KeReleaseSpinLock( &NwMessageSpinLock, OldIrql );

    //
    //  Process the set of SCB IRP queues.
    //

    //
    //  And return to our caller
    //

    return;
}

PMINI_IRP_CONTEXT
AllocateMiniIrpContext (
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine allocates an IRP, a buffer, and an MDL for sending
    a burst write fragment.

Arguments:

    None.

Return Value:

    Irp - The allocated and initialized IRP.
    NULL - The IRP allocation failed.

--*/

{
    PMINI_IRP_CONTEXT MiniIrpContext;
    PIRP Irp = NULL;
    PMDL Mdl1 = NULL, Mdl2 = NULL;
    PVOID Buffer = NULL;
    PLIST_ENTRY ListEntry;

    ListEntry = ExInterlockedRemoveHeadList(
                   &MiniIrpContextList,
                   &IrpContextInterlock);

    if ( ListEntry == NULL) {

        try {
            MiniIrpContext = ALLOCATE_POOL_EX( NonPagedPool, sizeof( *MiniIrpContext ) );

            MiniIrpContext->NodeTypeCode = NW_NTC_MINI_IRP_CONTEXT;
            MiniIrpContext->NodeByteSize = sizeof( *MiniIrpContext );

            Irp = ALLOCATE_IRP(
                      IrpContext->pNpScb->Server.pDeviceObject->StackSize,
                      FALSE );

            if ( Irp == NULL ) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            Buffer = ALLOCATE_POOL_EX( NonPagedPool, sizeof( NCP_BURST_HEADER ) );

            Mdl1 = ALLOCATE_MDL( Buffer, sizeof( NCP_BURST_HEADER ), FALSE, FALSE, NULL );
            if ( Mdl1 == NULL ) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            MmBuildMdlForNonPagedPool( Mdl1 );

            //
            //  Since this MDL can be used to send a packet on any server,
            //  allocate an MDL large enough for any packet size.
            //

            Mdl2 = ALLOCATE_MDL( 0, 65535 + PAGE_SIZE - 1, FALSE, FALSE, NULL );
            if ( Mdl2 == NULL ) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            Mdl1->Next = Mdl2;

            MiniIrpContext->Irp = Irp;
            MiniIrpContext->Buffer = Buffer;
            MiniIrpContext->Mdl1 = Mdl1;
            MiniIrpContext->Mdl2 = Mdl2;

            InterlockedIncrement( &MiniContextCount );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            if ( Buffer != NULL ) {
                FREE_POOL( Buffer );
            }

            if ( Irp != NULL ) {
                FREE_IRP( Irp );
            }

            if ( Mdl1 != NULL ) {
                FREE_MDL( Mdl1 );
            }

            return( NULL );
        }

    } else {

        //
        //  Record that we have removed an entry from the free list.
        //

        InterlockedIncrement( &FreeMiniContextCount );
        MiniIrpContext = CONTAINING_RECORD( ListEntry, MINI_IRP_CONTEXT, Next );

    }

    MiniIrpContext->IrpContext = IrpContext;

    return( MiniIrpContext );
}

VOID
FreeMiniIrpContext (
    PMINI_IRP_CONTEXT MiniIrpContext
    )
/*++

Routine Description:

    This routine frees a mini IRP Context.

Arguments:

    MiniIrpContext - The mini IRP context to free.

Return Value:

    None.

--*/
{
    InterlockedDecrement( &MiniContextCount );

    if ( InterlockedDecrement( &FreeMiniContextCount ) >= 0 ) {

        //
        //  Ok to keep this mini irp context.  Just queue it to the free list.
        //

        MmPrepareMdlForReuse( MiniIrpContext->Mdl2 );

        ExInterlockedInsertTailList(
            &MiniIrpContextList,
            &MiniIrpContext->Next,
            &IrpContextInterlock );

    } else {

        //
        //  We already have as many free context as we allow so destroy
        //  this context. Restore FreeContextCount to its original value.
        //

        InterlockedIncrement( &FreeContextCount );

        FREE_POOL( MiniIrpContext->Buffer );
        FREE_MDL( MiniIrpContext->Mdl2 );
        FREE_MDL( MiniIrpContext->Mdl1 );
        FREE_IRP( MiniIrpContext->Irp );

        FREE_POOL( MiniIrpContext );
    }
}

PWORK_CONTEXT
AllocateWorkContext (
    VOID
    )
/*++

Routine Description:

   Allocates a work queue structure, and initializes it.

Arguments:

    None.


Return Value:

    PWORK_CONTEXT - Newly allocated Work Context.

--*/
{
   PWORK_CONTEXT pWorkContext;

   try {
      pWorkContext = ALLOCATE_POOL_EX(NonPagedPool, sizeof(WORK_CONTEXT));
   
      RtlFillMemory( pWorkContext, sizeof(WORK_CONTEXT), 0 );
      
      pWorkContext->NodeTypeCode = NW_NTC_WORK_CONTEXT;
      pWorkContext->NodeByteSize = sizeof(WORK_CONTEXT);

      return pWorkContext;
   
   } except( EXCEPTION_EXECUTE_HANDLER ) {

        DebugTrace( 0, Dbg, "Failed to allocate work context\n", 0 );

        return NULL;

   }
}


VOID
FreeWorkContext (
    PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Free the supplied work context.

Arguments:

    PWORK_CONTEXT IrpContext - Work Context to free.

Return Value:

    None

--*/
{

    ASSERT( WorkContext->NodeTypeCode == NW_NTC_WORK_CONTEXT );
    FREE_POOL(WorkContext);
    
}
    
 
VOID
SpawnWorkerThread (
       VOID 
       )
/*++

Routine Description:

   Create our own worker thread which will service reroute and reconnect
   attempts.

Arguments:

   None.

Return Value:

   None.

--*/ 
{
   NTSTATUS status;

   
   status = PsCreateSystemThread(
                              &WorkerThreadHandle,
                              PROCESS_ALL_ACCESS,  // Access mask
                              NULL,             // object attributes
                              NULL,             // Process handle
                              NULL,             // client id
                              (PKSTART_ROUTINE) WorkerThread,     // Start routine
                              NULL              // Startcontext
                              );

         if ( !NT_SUCCESS(status) ) {

            //
            // If we can't create the worker thread, it means that we
            // cannot service reconnect or reroute attempts. It is a 
            // non-critical error.
            //

            DebugTrace( 0, Dbg, "SpawnWorkerThread: Can't create worker thread", 0 );
            
            WorkerThreadRunning = FALSE;
         
         } else {

             DebugTrace( 0, Dbg, "SpawnWorkerThread: created worker thread", 0 );
             WorkerThreadRunning = TRUE;
         }
         
}


VOID
WorkerThread (
   VOID
    )
{

   PLIST_ENTRY listentry;
   PWORK_CONTEXT workContext;
   PIRP_CONTEXT pIrpContext;
   NODE_WORK_CODE workCode;
   PNONPAGED_SCB OriginalNpScb = NULL;
          

   PAGED_CODE();

   DebugTrace( 0, Dbg, "Worker thread \n", 0 );

   IoSetThreadHardErrorMode( FALSE );

   while (TRUE) {
   
      //
      // Check to see if we have any work to do.
      //
   listentry = KeRemoveQueue ( 
                              &KernelQueue,         // Kernel queue object
                              KernelMode,           // Processor wait mode
                              NULL                  // No timeout
                              );

   ASSERT( listentry != (PVOID) STATUS_TIMEOUT);

   //
   // We have atleast one reroute attempt to look into. Get the address of the
   // work item.
   //

   workContext = CONTAINING_RECORD (
                                    listentry,
                                    WORK_CONTEXT,
                                    Next
                                    );

   pIrpContext = workContext->pIrpC;
   workCode = workContext->NodeWorkCode;

   if (pIrpContext) {
       OriginalNpScb = pIrpContext->pNpScb;
   }

   //
   // We don't need the work context anymore
   //

   FreeWorkContext( workContext );

   //
   // The work which this thread does can be one of the following:
   //
   // - Attempt a reroute
   // - Attempt a reconnect
   // - Terminate itself
   //

   switch (workCode) {

   case NWC_NWC_REROUTE:
      {
          ASSERT(BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_REROUTE_IN_PROGRESS ));
          
          DebugTrace( 0, Dbg, "worker got reroute work for scb 0x%x.\n", OriginalNpScb );
          
          if ( BooleanFlagOn( pIrpContext->Flags,
                         IRP_FLAG_BURST_PACKET ) ) {
   
              NewRouteBurstRetry( pIrpContext );
   
          } else {
         
              NewRouteRetry( pIrpContext );
          }

          NwDereferenceScb( OriginalNpScb );
          ClearFlag( pIrpContext->Flags, IRP_FLAG_REROUTE_IN_PROGRESS );
          break;
      }
   case NWC_NWC_RECONNECT:
      {
       DebugTrace( 0, Dbg, "worker got reconnect work.\n", 0 );
       ReconnectRetry( pIrpContext );
       
       break;
      }
   case NWC_NWC_TERMINATE:
      {
         DebugTrace( 0, Dbg, "Terminated worker thread.\n", 0 );
         
         //
         // Flush any remaining work items out of the work queue...
         //

         while (listentry != NULL) {

            listentry = KeRundownQueue( &KernelQueue );
            DebugTrace( 0, Dbg, "Residual workitem in q %X.\n",listentry );
         }

         //
         // and terminate yourself.
         //

         WorkerThreadRunning = FALSE;
         PsTerminateSystemThread( STATUS_SUCCESS );

         break;
      }
   default:
      {
         //
         // There is something wrong here. 
         //

         DebugTrace( 0, Dbg, "Unknown work code...ignoring\n", 0 );
      }
   }
  }
}

VOID
TerminateWorkerThread (
    VOID
    )
{
   PWORK_CONTEXT workContext = NULL;
   LARGE_INTEGER  timeout;
   NTSTATUS    status;

   if (WorkerThreadRunning == TRUE) {

      //
      // set a 5 second timeout for retrying allocation failures
      //

      timeout.QuadPart = (LONGLONG) ( NwOneSecond * 5 * (-1) ); 
      
      //
      // Prepare the work context
      //
      
      workContext = AllocateWorkContext();

      while ( workContext == NULL) {
      
         KeDelayExecutionThread( KernelMode,
                                 FALSE,
                                 &timeout   
                                  );
         
         workContext = AllocateWorkContext();
      }

      workContext->NodeWorkCode = NWC_NWC_TERMINATE;
      workContext->pIrpC = NULL;
      
      //
      // and queue it.
      //
      
      KeInsertQueue( &KernelQueue,
                     &workContext->Next
                     );

      //
      // We now have to wait until the thread terminates itself.
      //

      DebugTrace( 0, Dbg, "TerminateWorkerThread: Waiting for thread termination.\n", 0 );

      do {

          status = ZwWaitForSingleObject( WorkerThreadHandle, 
                                          FALSE,
                                          NULL            // No timeout
                                          );

      } while ( !NT_SUCCESS( status ) );

      DebugTrace( 0, Dbg, "TerminateWorkerThread: Wait returned with 0x%x\n", status );

      status = ZwClose( WorkerThreadHandle );

   
     }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\write.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements support for NtWriteFile for the
    NetWare redirector called by the dispatch driver.

Author:

    Colin Watson     [ColinW]    07-Apr-1993

Revision History:

--*/

#include "Procs.h"
#include <stdlib.h>

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

//
//  The header overhead in the first packet of a burst write.
//

#define BURST_WRITE_HEADER_SIZE \
    ( sizeof( NCP_BURST_WRITE_REQUEST ) - sizeof( NCP_BURST_HEADER ) )

//
//  Local procedure prototypes
//

NTSTATUS
NwCommonWrite (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
WriteNcp(
    PIRP_CONTEXT IrpContext,
    LARGE_INTEGER ByteOffset,
    ULONG BufferLength,
    PVOID WriteBuffer,
    PMDL WriteMdl
    );

NTSTATUS
QueryEofForWriteCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    );

NTSTATUS
WriteNcpCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    );

NTSTATUS
BurstWrite(
    PIRP_CONTEXT IrpContext,
    LARGE_INTEGER ByteOffset,
    ULONG BufferLength,
    PVOID WriteBuffer,
    PMDL WriteMdl
    );

NTSTATUS
SendWriteBurst(
    PIRP_CONTEXT IrpContext,
    ULONG Offset,
    USHORT Length,
    BOOLEAN EndOfBurst,
    BOOLEAN Retransmission
    );

VOID
BuildBurstWriteFirstReq(
    PIRP_CONTEXT IrpContext,
    PVOID Buffer,
    ULONG DataSize,
    PMDL BurstMdl,
    UCHAR Flags,
    ULONG Handle,
    ULONG FileOffset
    );

VOID
BuildBurstWriteNextReq(
    PIRP_CONTEXT IrpContext,
    PVOID Buffer,
    ULONG DataSize,
    UCHAR BurstFlags,
    ULONG BurstOffset,
    PMDL BurstHeaderMdl,
    PMDL BurstDataMdl
    );

NTSTATUS
BurstWriteCompletionSend(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
BurstWriteCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    );

VOID
BurstWriteTimeout(
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
BurstWriteReconnect(
    PIRP_CONTEXT IrpContext
    );

NTSTATUS
NwCommonFlushBuffers (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
FlushBuffersCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    );

NTSTATUS
SendSecondaryPacket(
    PIRP_CONTEXT IrpContext,
    PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdWrite )
#pragma alloc_text( PAGE, NwCommonWrite )
#pragma alloc_text( PAGE, DoWrite )
#pragma alloc_text( PAGE, WriteNcp )
#pragma alloc_text( PAGE, BurstWrite )
#pragma alloc_text( PAGE, SendWriteBurst )
#pragma alloc_text( PAGE, ResubmitBurstWrite )
#pragma alloc_text( PAGE, NwFsdFlushBuffers )
#pragma alloc_text( PAGE, NwCommonFlushBuffers )
#pragma alloc_text( PAGE, BuildBurstWriteFirstReq )
#pragma alloc_text( PAGE, BuildBurstWriteNextReq )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, WriteNcpCallback )
#pragma alloc_text( PAGE1, BurstWriteCompletionSend )
#pragma alloc_text( PAGE1, BurstWriteCallback )
#pragma alloc_text( PAGE1, BurstWriteTimeout )
#pragma alloc_text( PAGE1, FlushBuffersCallback )
#pragma alloc_text( PAGE1, SendSecondaryPacket )
#pragma alloc_text( PAGE1, BurstWriteReconnect )
#endif

#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif


NTSTATUS
NwFsdWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the FSD routine that handles NtWriteFile.

Arguments:

    NwfsDeviceObject - Supplies the device object for the write function.

    Irp - Supplies the IRP to process.

Return Value:

    NTSTATUS - The result status.

--*/

{
    PIRP_CONTEXT pIrpContext = NULL;
    NTSTATUS status;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdWrite\n", 0);

    //
    // Call the common write routine.
    //

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        pIrpContext = AllocateIrpContext( Irp );
        status = NwCommonWrite( pIrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( pIrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error Status that we get back from the
            //  execption code
            //

            status = NwProcessException( pIrpContext, GetExceptionCode() );
       }

    }

    if ( pIrpContext ) {

        if ( status != STATUS_PENDING ) {
            NwDequeueIrpContext( pIrpContext, FALSE );
        }

        NwCompleteRequest( pIrpContext, status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "NwFsdWrite -> %08lx\n", status );

    Stats.WriteOperations++;

    return status;
}


NTSTATUS
NwCommonWrite (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine does the common code for NtWriteFile.

Arguments:

    IrpContext - Supplies the request being processed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS status;

    PIRP Irp;
    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PICB icb;
    PFCB fcb;
    PNONPAGED_FCB pNpFcb;
    PVOID fsContext;

    BOOLEAN WroteToCache;
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER PreviousByteOffset;
    ULONG BufferLength;

    PULONG pFileSize;

    // ULONG FileLength;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    Irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "CommonWrite...\n", 0);
    DebugTrace( 0, Dbg, "Irp  = %08lx\n", (ULONG_PTR)Irp);

    //
    // Decode the file object to figure out who we are.  If the result
    // is not the root DCB then its an illegal parameter.
    //

    nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                       &fsContext,
                                       (PVOID *)&icb );

    fcb = (PFCB)icb->SuperType.Fcb;

    if (((nodeTypeCode != NW_NTC_ICB) &&
         (nodeTypeCode != NW_NTC_ICB_SCB)) ||
        (!icb->HasRemoteHandle) ) {

        DebugTrace(0, Dbg, "Not a file\n", 0);

        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonWrite -> %08lx\n", status );
        return status;
    }

    //
    //  Make sure that this ICB is still active.
    //

    NwVerifyIcbSpecial( icb );

    if ( fcb->NodeTypeCode == NW_NTC_FCB ) {

        IrpContext->pScb = fcb->Scb;
        IrpContext->pNpScb = IrpContext->pScb->pNpScb;
        IrpContext->Icb = icb;
        pFileSize = &icb->NpFcb->Header.FileSize.LowPart;

    } else if ( fcb->NodeTypeCode == NW_NTC_SCB ) {

        IrpContext->pScb = icb->SuperType.Scb;
        IrpContext->pNpScb = IrpContext->pScb->pNpScb;
        IrpContext->Icb = icb;
        fcb = NULL;
        pFileSize = &icb->FileSize;

    } else {

        DebugTrace(0, Dbg, "Not a file or a server\n", 0);

        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonWrite -> %08lx\n", status );
        return status;
    }

    ByteOffset = irpSp->Parameters.Write.ByteOffset;
    BufferLength = irpSp->Parameters.Write.Length;

    //
    //  Can't handle large byte offset, but write to EOF is okay.
    //

    if ( ByteOffset.HighPart != 0 ) {

        if ( ByteOffset.HighPart != 0xFFFFFFFF  ||
             ByteOffset.LowPart  != 0xFFFFFFFF ) {

            return( STATUS_INVALID_PARAMETER );
        }
    }

    if (FlagOn(irpSp->FileObject->Flags, FO_SYNCHRONOUS_IO) &&
        !FlagOn(Irp->Flags, IRP_PAGING_IO)) {

        PreviousByteOffset.QuadPart = irpSp->FileObject->CurrentByteOffset.QuadPart;
        irpSp->FileObject->CurrentByteOffset.QuadPart = ByteOffset.QuadPart;
    }

    //
    //  Paging I/O is not allowed to extend the file
    //

    if ((FlagOn(Irp->Flags, IRP_PAGING_IO)) &&
        (ByteOffset.LowPart + BufferLength > *pFileSize )) {

        NwAppendToQueueAndWait( IrpContext );

        if ( ByteOffset.LowPart + BufferLength <= *pFileSize ) {

            //
            //  Someone else extended the file. Do nothing.
            //

            // continue;

        } else if ( ByteOffset.LowPart > *pFileSize ) {

            //
            //  Whole write is off the end of the buffer
            //

            NwDequeueIrpContext( IrpContext, FALSE );
            Irp->IoStatus.Information = 0;
            return( STATUS_SUCCESS );

        } else {

            //
            //  Truncate request to size of file
            //

            BufferLength = *pFileSize - ByteOffset.LowPart;

        }

        NwDequeueIrpContext( IrpContext, FALSE );
    }


    //
    //  Special case 0 length write.
    //

    if ( BufferLength == 0 ) {
        Irp->IoStatus.Information = 0;
        return( STATUS_SUCCESS );
    }

    //
    //  Remember the original MDL, so that we can restore it when we are done.
    //

    IrpContext->pOriginalMdlAddress = Irp->MdlAddress;

    //
    //  Attempt to write this data to our private cache
    //

    if ( fcb != NULL && Irp->UserBuffer != NULL ) {

        WroteToCache = CacheWrite(
                           IrpContext,
                           fcb->NonPagedFcb,
                           ByteOffset.LowPart,
                           BufferLength,
                           Irp->UserBuffer );

        if ( WroteToCache ) {

            Irp->IoStatus.Information = BufferLength;

            //
            //  Update the current byte offset in the file if it is a
            //  synchronous file (and this is not paging I/O).
            //

            if (FlagOn(irpSp->FileObject->Flags, FO_SYNCHRONOUS_IO) &&
                !FlagOn(Irp->Flags, IRP_PAGING_IO)) {

                irpSp->FileObject->CurrentByteOffset.QuadPart += BufferLength;
            }

            //
            //  Record write offset and size to discover a sequential write pattern.
            //

            fcb->LastReadOffset = irpSp->Parameters.Write.ByteOffset.LowPart;
            fcb->LastReadSize = irpSp->Parameters.Write.Length;

            //
            //  If the file was extended, record the new file size.
            //

            if ( fcb->LastReadOffset + fcb->LastReadSize >
                 fcb->NonPagedFcb->Header.FileSize.LowPart ) {

                fcb->NonPagedFcb->Header.FileSize.LowPart =
                    fcb->LastReadOffset + fcb->LastReadSize;
            }

            DebugTrace(-1, Dbg, "NwCommonWrite -> %08lx\n", STATUS_SUCCESS );
            return( STATUS_SUCCESS );
        }

    }

    status = DoWrite(
                 IrpContext,
                 ByteOffset,
                 BufferLength,
                 Irp->UserBuffer,
                 IrpContext->pOriginalMdlAddress );

    if ( NT_SUCCESS( status ) ) {

        //
        // We actually wrote something out to the wire.  If there was a read
        // cache and this write overlapped it, invalidate the read cache data
        // so that we get good data on future reads.
        //

        if ( fcb != NULL ) {

            pNpFcb = fcb->NonPagedFcb;

            if ( ( pNpFcb->CacheBuffer != NULL ) &&
                 ( pNpFcb->CacheSize != 0 ) &&
                 ( pNpFcb->CacheType == ReadAhead ) ) {

                //
                // Two cases: (1) offset is less than cache offset
                //            (2) offset is inside cached region
                //

                if ( ByteOffset.LowPart < pNpFcb->CacheFileOffset ) {

                    //
                    // Did we run into the read cache?
                    //

                    if ( BufferLength >
                        (pNpFcb->CacheFileOffset - ByteOffset.LowPart) ) {

                        DebugTrace( 0, Dbg, "Invalidated read cache for %08lx.\n", pNpFcb );
                        pNpFcb->CacheDataSize = 0;

                    }

                } else {

                    //
                    // Did we write over any of the cached region.
                    //

                    if ( ByteOffset.LowPart <= ( pNpFcb->CacheFileOffset + pNpFcb->CacheDataSize ) ) {

                        DebugTrace( 0, Dbg, "Invalidated read cache for %08lx.\n", pNpFcb );
                        pNpFcb->CacheDataSize = 0;

                    }
                }
            }

        }

        Irp->IoStatus.Information = IrpContext->Specific.Write.WriteOffset;

        //
        //  Update the current byte offset in the file if it is a
        //  synchronous file (and this is not paging I/O).
        //

        if (FlagOn(irpSp->FileObject->Flags, FO_SYNCHRONOUS_IO) &&
            !FlagOn(Irp->Flags, IRP_PAGING_IO)) {

            irpSp->FileObject->CurrentByteOffset.QuadPart += BufferLength;
        }

        NwAppendToQueueAndWait( IrpContext );

        if (ByteOffset.LowPart + BufferLength > *pFileSize ) {

            *pFileSize = ByteOffset.LowPart + BufferLength;

        }

    } else {

       //
       // The request failed, don't move the file pointer.
       //

       if (FlagOn(irpSp->FileObject->Flags, FO_SYNCHRONOUS_IO) &&
           !FlagOn(Irp->Flags, IRP_PAGING_IO)) {

           irpSp->FileObject->CurrentByteOffset.QuadPart = PreviousByteOffset.QuadPart;
       }

    }

    DebugTrace(-1, Dbg, "CommonWrite -> %08lx\n", status);

    return status;
}

NTSTATUS
DoWrite(
    PIRP_CONTEXT IrpContext,
    LARGE_INTEGER ByteOffset,
    ULONG BufferLength,
    PVOID WriteBuffer,
    PMDL WriteMdl OPTIONAL
    )
/*++

Routine Description:

    This routine does a write to the network via the most efficient
    available protocol.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

    ByteOffset - The file offset to write.

    BufferLength - The number of bytes to write.

    WriteBuffer - A pointer to the source buffer.

    WriteMdl = An optional MDL for the write buffer.

Return Value:

    Status of transfer.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    if ( IrpContext->pNpScb->SendBurstModeEnabled &&
         BufferLength > IrpContext->pNpScb->BufferSize ) {
        status = BurstWrite( IrpContext, ByteOffset, BufferLength, WriteBuffer, WriteMdl );
    } else {
        status = WriteNcp( IrpContext, ByteOffset, BufferLength, WriteBuffer, WriteMdl );
    }

    //
    //  Reset IrpContext parameters
    //

    IrpContext->TxMdl->Next = NULL;
    IrpContext->CompletionSendRoutine = NULL;
    IrpContext->TimeoutRoutine = NULL;
    IrpContext->Flags &= ~(IRP_FLAG_RETRY_SEND | IRP_FLAG_BURST_REQUEST | IRP_FLAG_BURST_PACKET |
                             IRP_FLAG_BURST_WRITE | IRP_FLAG_NOT_SYSTEM_PACKET );
    IrpContext->pTdiStruct = NULL;

    IrpContext->pOriginalIrp->MdlAddress = IrpContext->pOriginalMdlAddress;
    IrpContext->pOriginalIrp->AssociatedIrp.SystemBuffer = IrpContext->pOriginalSystemBuffer;

    return( status );
}

NTSTATUS
WriteNcp(
    PIRP_CONTEXT IrpContext,
    LARGE_INTEGER ByteOffset,
    ULONG BufferLength,
    PVOID WriteBuffer,
    PMDL WriteMdl
    )
/*++

Routine Description:

    This routine exchanges a series of write NCPs with the server.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

    Icb - Supplies the file specific information.

Return Value:

    Status of transfer.

--*/
{
    PICB Icb;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG Length;               //  Size we will send to the server
    ULONG FileLength;

    PSCB pScb;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PMDL DataMdl;
    BOOLEAN Done;

    PAGED_CODE();

    Icb = IrpContext->Icb;
    irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    DebugTrace(+1, Dbg, "WriteNcp...\n", 0);
    DebugTrace( 0, Dbg, "irp     = %08lx\n", (ULONG_PTR)irp);
    DebugTrace( 0, Dbg, "WriteLen= %ld\n", BufferLength);
    DebugTrace( 0, Dbg, "HOffset = %lx\n", ByteOffset.HighPart);
    DebugTrace( 0, Dbg, "LOffset = %lx\n", ByteOffset.LowPart);

    if (Icb->SuperType.Fcb->NodeTypeCode == NW_NTC_FCB) {
        pScb = Icb->SuperType.Fcb->Scb;
        DebugTrace( 0, Dbg, "File    = %wZ\n", &Icb->SuperType.Fcb->FullFileName);
    } else {

        //
        //  Write to a queue
        //

        pScb = Icb->SuperType.Scb;

    }

    ASSERT (pScb->NodeTypeCode == NW_NTC_SCB);

    if ( ByteOffset.HighPart == 0xFFFFFFFF &&
         ByteOffset.LowPart == FILE_WRITE_TO_END_OF_FILE ) {

        //
        // Ensure that you are at the head of the queue
        //

        NwAppendToQueueAndWait( IrpContext );

        //
        //  Write relative to end of file.  Find the end of file.
        //

        status = ExchangeWithWait(
                     IrpContext,
                     SynchronousResponseCallback,
                     "F-r",
                     NCP_GET_FILE_SIZE,
                     &Icb->Handle, sizeof( Icb->Handle ) );

        if ( NT_SUCCESS( status ) ) {
            status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "Nd",
                         &FileLength );

            if ( !NT_SUCCESS( status ) ) {
                return status;
            }

        }

        IrpContext->Specific.Write.FileOffset = FileLength;
    }

    Length = MIN( (ULONG)IrpContext->pNpScb->BufferSize, BufferLength );
    DebugTrace( 0, Dbg, "Length  = %ld\n", Length);

    //
    //  The server will not accept writes that cross 4k boundaries in the file
    //

    if ((IrpContext->pNpScb->PageAlign) &&
        (DIFFERENT_PAGES( ByteOffset.LowPart, Length ))) {
        Length = 4096 -
                ((ULONG)ByteOffset.LowPart & (4096-1));
    }

    IrpContext->Specific.Write.Buffer = WriteBuffer;
    IrpContext->Specific.Write.WriteOffset = 0;
    IrpContext->Specific.Write.RemainingLength = BufferLength;
    IrpContext->Specific.Write.LastWriteLength = Length;
    IrpContext->Specific.Write.FileOffset = ByteOffset.LowPart;
    IrpContext->Specific.Write.PartialMdl = NULL;

    Done = FALSE;

    while ( !Done ) {

        //
        //  Setup to do at most 64K of i/o asynchronously, or buffer length.
        //

        IrpContext->Specific.Write.BurstLength =
            MIN( 64 * 1024, IrpContext->Specific.Write.RemainingLength );
        IrpContext->Specific.Write.BurstOffset = 0;

        //
        //  Try to allocate an MDL for this i/o.
        //

        DataMdl = ALLOCATE_MDL(
                      (PCHAR)IrpContext->Specific.Write.Buffer +
                           IrpContext->Specific.Write.WriteOffset,
                      IrpContext->Specific.Write.BurstLength,
                      FALSE, // Secondary Buffer
                      FALSE, // Charge Quota
                      NULL);

        if ( DataMdl == NULL ) {
            if ( IrpContext->Specific.Write.PartialMdl != NULL ) {
                FREE_MDL( IrpContext->Specific.Write.PartialMdl );
            }
            DebugTrace(-1, Dbg, "WriteNcp -> %X\n", STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IrpContext->Specific.Write.FullMdl = DataMdl;


        //
        //  If there is no MDL for this write probe the data MDL to
        //  lock it's pages down.   Otherwise, use the data MDL as
        //  a partial MDL.
        //

        if ( WriteMdl == NULL ) {

            //
            //  The Probe may cause us to page in some data. If the data is from
            //  the same server we are writing to then we had better not be at
            //  the front of the queue otherwise it will wait indefinitely behind us.
            //  Its a good idea to Dequeue ourselves after each burst anyway because
            //  its a quick operation and it alow smaller requests to overtake a very
            //  large series of bursts.
            //

            NwDequeueIrpContext( IrpContext, FALSE );

            try {
                MmProbeAndLockPages( DataMdl, irp->RequestorMode, IoReadAccess);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                FREE_MDL( DataMdl );
                DebugTrace(-1, Dbg, "WriteNcp -> %X\n", GetExceptionCode() );
                return GetExceptionCode();
            }

        } else {
            IoBuildPartialMdl(
                WriteMdl,
                DataMdl,
                (PCHAR)IrpContext->Specific.Write.Buffer,
                IrpContext->Specific.Write.BurstLength );
        }

        //
        //  Allocate a partial Mdl for the worst possible case of alignment
        //

        IrpContext->Specific.Write.PartialMdl =
            ALLOCATE_MDL( 0 , IrpContext->pNpScb->BufferSize + PAGE_SIZE-1, FALSE, FALSE, NULL);

        if ( IrpContext->Specific.Write.PartialMdl == NULL ) {

            if ( WriteMdl == NULL ) {
                MmUnlockPages( DataMdl );
            }

            FREE_MDL( DataMdl );
            DebugTrace(-1, Dbg, "WriteNcp -> %X\n", STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Build a partial MDL for this write NCP.
        //

        IoBuildPartialMdl(
            DataMdl,
            IrpContext->Specific.Write.PartialMdl,
            MmGetMdlVirtualAddress( DataMdl ),
            Length );

        if ( IrpContext->Specific.Write.BurstLength ==
             IrpContext->Specific.Write.RemainingLength ) {
            Done = TRUE;
        }

        //
        // Ensure that you are at the head of the queue
        //

        NwAppendToQueueAndWait( IrpContext );

        //
        //  Send the request.
        //

        status = ExchangeWithWait(
                     IrpContext,
                     WriteNcpCallback,
                     "F-rdwf",
                     NCP_WRITE_FILE,
                     &Icb->Handle, sizeof( Icb->Handle ),
                     IrpContext->Specific.Write.FileOffset,
                     Length,
                     IrpContext->Specific.Write.PartialMdl );

        Stats.WriteNcps+=2;

        FREE_MDL( IrpContext->Specific.Write.PartialMdl );

        //
        //  Unlock locked pages, and free our MDL.
        //

        if ( WriteMdl == NULL ) {
            MmUnlockPages( DataMdl );
        }

        FREE_MDL( DataMdl );

        //
        // If we had a failure, we need to terminate this loop.
        // The only status that is set is the Specific->Write
        // status.  We can not trust what comes back from the
        // ExchangeWithWait by design.
        //

        if ( !NT_SUCCESS( IrpContext->Specific.Write.Status ) ) {
            Done = TRUE;
        }

        //
        // Reset the packet length since we may have less than
        // a packet to send.
        //

        Length = MIN( (ULONG)IrpContext->pNpScb->BufferSize,
                      IrpContext->Specific.Write.RemainingLength );
        IrpContext->Specific.Write.LastWriteLength = Length;

    }

    status = IrpContext->Specific.Write.Status;

    DebugTrace(-1, Dbg, "WriteNcp -> %08lx\n", status );
    return status;
}


NTSTATUS
WriteNcpCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )
/*++

Routine Description:

    This routine receives the response from a user NCP.

Arguments:


Return Value:

    VOID

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length;
    ULONG LastLength;

    DebugTrace(0, Dbg, "WriteNcpCallback...\n", 0);

    if ( BytesAvailable == 0) {

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

        IrpContext->Specific.Write.Status = STATUS_REMOTE_NOT_LISTENING;

        NwSetIrpContextEvent( IrpContext );
        return STATUS_REMOTE_NOT_LISTENING;
    }

    LastLength  = IrpContext->Specific.Write.LastWriteLength;
    Status = ParseResponse( IrpContext, Response, BytesAvailable, "N" );

    if ( NT_SUCCESS(Status) ) {

        //  If the last write worked then move the pointers appropriately

        IrpContext->Specific.Write.RemainingLength -= LastLength;
        IrpContext->Specific.Write.BurstLength -= LastLength;
        IrpContext->Specific.Write.WriteOffset += LastLength;
        IrpContext->Specific.Write.FileOffset += LastLength;
        IrpContext->Specific.Write.BurstOffset += LastLength;

        //  If this is a print job, remember that we actually wrote data

        if ( IrpContext->Icb->IsPrintJob ) {
            IrpContext->Icb->ActuallyPrinted = TRUE;
        }

    } else {

        //
        //  Abandon this request
        //

        IrpContext->Specific.Write.Status = Status;
        NwSetIrpContextEvent( IrpContext );
        DebugTrace( 0, Dbg, "WriteNcpCallback -> %08lx\n", Status );
        return Status;
    }


    if ( IrpContext->Specific.Write.BurstLength != 0 ) {

        //  Write the next packet.

        DebugTrace( 0, Dbg, "RemainingLength  = %ld\n", IrpContext->Specific.Write.RemainingLength);
        DebugTrace( 0, Dbg, "FileOffset       = %ld\n", IrpContext->Specific.Write.FileOffset);
        DebugTrace( 0, Dbg, "WriteOffset      = %ld\n", IrpContext->Specific.Write.WriteOffset);
        DebugTrace( 0, Dbg, "BurstOffset      = %ld\n", IrpContext->Specific.Write.BurstOffset);


        Length = MIN( (ULONG)IrpContext->pNpScb->BufferSize,
            IrpContext->Specific.Write.BurstLength );

        //
        //  The server will not accept writes that cross 4k boundaries
        //  in the file.
        //

        if ((IrpContext->pNpScb->PageAlign) &&
            (DIFFERENT_PAGES( IrpContext->Specific.Write.FileOffset, Length ))) {

            Length = 4096 -
                ((ULONG)IrpContext->Specific.Write.FileOffset & (4096-1));

        }

        IrpContext->Specific.Write.LastWriteLength = Length;

        DebugTrace( 0, Dbg, "Length           = %ld\n", Length);

        MmPrepareMdlForReuse( IrpContext->Specific.Write.PartialMdl );

        IoBuildPartialMdl(
            IrpContext->Specific.Write.FullMdl,
            IrpContext->Specific.Write.PartialMdl,
            (PUCHAR)MmGetMdlVirtualAddress( IrpContext->Specific.Write.FullMdl ) +
                IrpContext->Specific.Write.BurstOffset,
            Length );

        //
        //  Send the request.
        //

        BuildRequestPacket(
            IrpContext,
            WriteNcpCallback,
            "F-rdwf",
            NCP_WRITE_FILE,
            &IrpContext->Icb->Handle, sizeof( IrpContext->Icb->Handle ),
            IrpContext->Specific.Write.FileOffset,
            Length,
            IrpContext->Specific.Write.PartialMdl );

        Status = PrepareAndSendPacket( IrpContext );

        Stats.WriteNcps+=2;

        DebugTrace(-1, Dbg, "WriteNcbCallBack -> %08lx\n", Status );

        if ( !NT_SUCCESS(Status) ) {

            //
            //  Abandon this request
            //

            IrpContext->Specific.Write.Status = Status;
            NwSetIrpContextEvent( IrpContext );
            DebugTrace( 0, Dbg, "WriteNcpCallback -> %08lx\n", Status );
            return Status;
        }


    } else {

        //
        //  We're done with this request, signal the writing thread.
        //

        IrpContext->Specific.Write.Status = STATUS_SUCCESS;
        NwSetIrpContextEvent( IrpContext );
    }

    DebugTrace( 0, Dbg, "WriteNcpCallback -> %08lx\n", Status );
    return STATUS_SUCCESS;

}


NTSTATUS
BurstWrite(
    PIRP_CONTEXT IrpContext,
    LARGE_INTEGER ByteOffset,
    ULONG BufferLength,
    PVOID WriteBuffer,
    PMDL WriteMdl
    )
/*++

Routine Description:

    This routine exchanges a series of burst write NCPs with the server.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

Return Value:

    Status of the transfer.

--*/
{
    PICB Icb;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG Length;               //  Size we will send to the server

    PSCB pScb;
    PNONPAGED_SCB pNpScb;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PMDL DataMdl;
    BOOLEAN Done;
    BOOLEAN MissingData;

    ULONG TimeInNwUnits;

    ULONG LastLength;
    ULONG Result;
    UCHAR BurstFlags;
    USHORT MissingFragmentCount;
    USHORT i;
    ULONG FragmentOffset;
    USHORT FragmentLength;

    Icb = IrpContext->Icb;
    pNpScb = IrpContext->pNpScb;
    irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    IrpContext->Specific.Write.WriteOffset = 0;
    IrpContext->Specific.Write.RemainingLength = BufferLength;

    IrpContext->Specific.Write.TotalWriteLength = BufferLength;
    IrpContext->Specific.Write.TotalWriteOffset = ByteOffset.LowPart;

    DebugTrace(+1, Dbg, "BurstWrite...\n", 0);
    DebugTrace( 0, Dbg, "irp     = %08lx\n", (ULONG_PTR)irp);
    DebugTrace( 0, Dbg, "WriteLen= %ld\n", BufferLength);
    DebugTrace( 0, Dbg, "HOffset = %lx\n", ByteOffset.HighPart);
    DebugTrace( 0, Dbg, "LOffset = %lx\n", ByteOffset.LowPart);

    //
    //  Renegotiate burst mode, if necessary
    //

    if ( pNpScb->BurstRenegotiateReqd ) {
        pNpScb->BurstRenegotiateReqd = FALSE;

        RenegotiateBurstMode( IrpContext, pNpScb );
    }

    SetFlag( IrpContext->Flags, IRP_FLAG_BURST_WRITE );

    if (Icb->SuperType.Fcb->NodeTypeCode == NW_NTC_FCB) {

        pScb = Icb->SuperType.Fcb->Scb;
        DebugTrace( 0, Dbg, "File    = %wZ\n", &Icb->SuperType.Fcb->FullFileName);

    } else {

        //
        //  Write to a queue
        //

        pScb = Icb->SuperType.Scb;

    }

    ASSERT (pScb->NodeTypeCode == NW_NTC_SCB);

    //
    //  Calculate the length of the burst to send.
    //

    Length = MIN( (ULONG)pNpScb->MaxSendSize, BufferLength );
    DebugTrace( 0, Dbg, "Length  = %ld\n", Length);

    if ( ByteOffset.HighPart == 0xFFFFFFFF &&
         ByteOffset.LowPart == FILE_WRITE_TO_END_OF_FILE ) {

        ULONG FileLength;

        //
        // Ensure that you are at the head of the queue
        //

        NwAppendToQueueAndWait( IrpContext );
        
        //
        //  Write relative to end of file.  Find the end of file.
        //

        status = ExchangeWithWait(
                     IrpContext,
                     SynchronousResponseCallback,
                     "F-r",
                     NCP_GET_FILE_SIZE,
                     &Icb->Handle, sizeof(Icb->Handle) );

        if ( NT_SUCCESS( status ) ) {
            status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "Nd",
                         &FileLength );
        }

        if ( !NT_SUCCESS( status ) ) {
            return( status );
        }

        IrpContext->Specific.Write.FileOffset = FileLength;

    } else {

        IrpContext->Specific.Write.FileOffset = ByteOffset.LowPart;

    }

    //
    //  Setup context parameters for burst write.
    //

    IrpContext->Specific.Write.LastWriteLength = Length;
    IrpContext->Destination = pNpScb->RemoteAddress;

    IrpContext->Specific.Write.Buffer = WriteBuffer;

    //
    //  Set the timeout to be the time for all te burst packets to be sent plus a round
    //  trip delay plus a second.
    //

    TimeInNwUnits = pNpScb->NwSingleBurstPacketTime * ((Length / IrpContext->pNpScb->MaxPacketSize) + 1) +
        IrpContext->pNpScb->NwLoopTime;

    IrpContext->pNpScb->SendTimeout =
        (SHORT)(((TimeInNwUnits / 555) *
                 (ULONG)WriteTimeoutMultiplier) / 100 + 1)  ;

    if (IrpContext->pNpScb->SendTimeout < 2)
    {
        IrpContext->pNpScb->SendTimeout = 2 ;
    }

    if (IrpContext->pNpScb->SendTimeout > (SHORT)MaxWriteTimeout)
    {
        IrpContext->pNpScb->SendTimeout = (SHORT)MaxWriteTimeout ;
    }

    IrpContext->pNpScb->TimeOut = IrpContext->pNpScb->SendTimeout;

    //
    //  tommye - MS bug 2743 changed the RetryCount from 20 to be based off the 
    //  default retry count, nudged up a little. 
    //

    pNpScb->RetryCount = DefaultRetryCount * 2;

    DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->SendTimeout = %08lx\n", IrpContext->pNpScb->SendTimeout );

    Done = FALSE;

    do {

        DataMdl = ALLOCATE_MDL(
                      (PCHAR)IrpContext->Specific.Write.Buffer +
                           IrpContext->Specific.Write.WriteOffset,
                      Length,
                      FALSE, // Secondary Buffer
                      FALSE, // Charge Quota
                      NULL);

        if ( DataMdl == NULL ) {
            return ( STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  If there is no MDL for this write, probe the data MDL to lock it's
        //  pages down.
        //
        //  Otherwise, use the data MDL as a partial MDL and lock the pages
        //  accordingly.
        //

        if ( WriteMdl == NULL ) {

            //
            //  The Probe may cause us to page in some data. If the data is from
            //  the same server we are writing to then we had better not be at
            //  the front of the queue otherwise it will wait indefinitely behind us.
            //  Its a good idea to Dequeue ourselves after each burst anyway because
            //  its a quick operation and it alow smaller requests to overtake a very
            //  large series of bursts.
            //

            NwDequeueIrpContext( IrpContext, FALSE );

            try {
                MmProbeAndLockPages( DataMdl, irp->RequestorMode, IoReadAccess);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                FREE_MDL( DataMdl );
                return GetExceptionCode();
            }

        } else {

            IoBuildPartialMdl(
                WriteMdl,
                DataMdl,
                (PCHAR)IrpContext->Specific.Write.Buffer +
                    IrpContext->Specific.Write.WriteOffset,
                Length );
        }

        pNpScb->BurstDataWritten += Length;

        if (( SendExtraNcp ) &&
            ( pNpScb->BurstDataWritten >= 0x0000ffff )) {


            ULONG Flags;

            //
            //  VLM client sends an NCP when starting a burst mode request
            //  if the last request was not a write. It also does this every
            //  0xfe00 bytes written
            //
            //  When going to a queue we will use handle 2. This is what the vlm
            //  client always seems to do.
            //

            Flags = IrpContext->Flags;

            //
            //  Reset IrpContext parameters
            //

            IrpContext->TxMdl->Next = NULL;
            IrpContext->CompletionSendRoutine = NULL;
            IrpContext->TimeoutRoutine = NULL;
            IrpContext->Flags &= ~(IRP_FLAG_RETRY_SEND | IRP_FLAG_BURST_REQUEST | IRP_FLAG_BURST_PACKET |
                                     IRP_FLAG_BURST_WRITE | IRP_FLAG_NOT_SYSTEM_PACKET );
            IrpContext->pTdiStruct = NULL;

            //
            // Ensure that you are at the head of the queue
            //

            NwAppendToQueueAndWait( IrpContext );

            ExchangeWithWait (
                IrpContext,
                SynchronousResponseCallback,
                "Sb",   // NCP Get Directory Path
                NCP_DIR_FUNCTION, NCP_GET_DIRECTORY_PATH,
                (Icb->SuperType.Fcb->NodeTypeCode == NW_NTC_FCB)?
                    Icb->SuperType.Fcb->Vcb->Specific.Disk.Handle : 2 );

            pNpScb->BurstDataWritten = Length;

            IrpContext->Flags = Flags;
            SetFlag( IrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE );
        }

        IrpContext->TimeoutRoutine = BurstWriteTimeout;
        IrpContext->CompletionSendRoutine = BurstWriteCompletionSend;
        IrpContext->pTdiStruct = &IrpContext->pNpScb->Burst;
        IrpContext->PacketType = NCP_BURST;
        IrpContext->pEx = BurstWriteCallback;

        IrpContext->Specific.Write.FullMdl = DataMdl;

        MmGetSystemAddressForMdlSafe( DataMdl, NormalPagePriority );

        //
        //  Allocate a partial Mdl for the worst possible case of alignment
        //

        IrpContext->Specific.Write.PartialMdl =
            ALLOCATE_MDL( 0, IrpContext->pNpScb->MaxPacketSize + PAGE_SIZE - 1, FALSE, FALSE, NULL);

        if ( IrpContext->Specific.Write.PartialMdl == NULL ) {

            if ( WriteMdl == NULL ) {
                MmUnlockPages( DataMdl );
            }

            FREE_MDL( DataMdl );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Get to the front of the SCB queue, if we are not already there.
        //  Note that can't append this IrpContext to the SCB until after
        //  the probe and lock, since the probe and lock may cause a paging
        //  read on this SCB.
        //

        NwAppendToQueueAndWait( IrpContext );

        status = SendWriteBurst(
                     IrpContext,
                     BURST_WRITE_HEADER_SIZE,
                     (USHORT)Length,
                     TRUE,
                     FALSE );

        MissingData = TRUE;
        while ( MissingData ) {

            KeWaitForSingleObject( &IrpContext->Event, Executive, KernelMode, FALSE, NULL );
            MmPrepareMdlForReuse( IrpContext->Specific.Write.PartialMdl );

            if ( BooleanFlagOn( IrpContext->Flags, IRP_FLAG_RETRY_SEND ) ) {

                //
                //  This burst has timed out, simply resend the burst.
                //

                NwProcessSendBurstFailure( pNpScb, 1 );

                status = SendWriteBurst(
                             IrpContext,
                             BURST_WRITE_HEADER_SIZE,
                             (USHORT)Length,
                             TRUE,
                             TRUE );
                continue;
            }

            if ( !NT_SUCCESS( IrpContext->Specific.Write.Status ) ) {

                status = IrpContext->Specific.Write.Status;
                Done = TRUE;

                goto EndOfLoop;

            } else {

                status = ParseResponse(
                             IrpContext,
                             IrpContext->rsp,
                             IrpContext->ResponseLength,
                             "B_d",
                             &BurstFlags,
                             8,
                             &Result );

            }

            if ( BurstFlags & BURST_FLAG_SYSTEM_PACKET ) {

                //
                //  The server dropped at least one packet.
                //

                MissingData = TRUE;
                DebugTrace( 0, Dbg, "Received system packet\n", 0 );

                //
                //  This is a missing fragment request.
                //

                status = ParseResponse(
                             IrpContext,
                             IrpContext->rsp,
                             IrpContext->ResponseLength,
                             "G_w",
                             34,
                             &MissingFragmentCount );

                ASSERT( NT_SUCCESS( status ) );
                ASSERT( MissingFragmentCount != 0 );

                NwProcessSendBurstFailure( pNpScb, MissingFragmentCount );

                DebugTrace( 0, Dbg, "Received request for %d missing fragment\n", MissingFragmentCount );
                ClearFlag( IrpContext->Flags, IRP_FLAG_RETRY_SEND );

                //
                //  Walk the missing fragment list and send the missing fragments.
                //

                for ( i = 0; i < MissingFragmentCount && NT_SUCCESS( status ); i++ ) {

                    status = ParseResponse(
                                 IrpContext,
                                 IrpContext->rsp,
                                 IrpContext->ResponseLength,
                                 "G_dw",
                                 34 + 2 + 6 * i,
                                 &FragmentOffset,
                                 &FragmentLength
                                 );

                    ASSERT( NT_SUCCESS( status ) );

                    if ( FragmentOffset < Length + BURST_WRITE_HEADER_SIZE &&
                         FragmentOffset + FragmentLength <=
                            Length + BURST_WRITE_HEADER_SIZE ) {

                        //
                        //  Send a burst with the missing data.  Do no set the
                        //  end of burst bit until we have sent the last
                        //  missing fragment packet.
                        //

                        status = SendWriteBurst(
                                     IrpContext,
                                     FragmentOffset,
                                     FragmentLength,
                                     (BOOLEAN)( i == (MissingFragmentCount - 1)),
                                     FALSE );
                    } else {

                        //
                        //  Received a bogus missing fragment request.
                        //  Ignore the remainder of the request.
                        //

                        status = STATUS_INVALID_NETWORK_RESPONSE;
                        Done = TRUE;

                        goto EndOfLoop;

                    }
                }

                Stats.PacketBurstWriteTimeouts++;

            } else {

                NwProcessSendBurstSuccess( pNpScb );

                MissingData = FALSE;

                //
                //  This is not a system packets, check the response.
                //

                if ( Result == 0 ) {

                    //
                    //  If the last write worked then move the pointers appropriately
                    //

                    LastLength  = IrpContext->Specific.Write.LastWriteLength;

                    IrpContext->Specific.Write.RemainingLength -= LastLength;
                    IrpContext->Specific.Write.WriteOffset += LastLength;
                    IrpContext->Specific.Write.FileOffset += LastLength;

                    //
                    //  If this is a print job, remember that we actually wrote data
                    //

                    if ( IrpContext->Icb->IsPrintJob ) {
                        IrpContext->Icb->ActuallyPrinted = TRUE;
                    }

                } else {

                    //
                    //  Abandon this request
                    //

                    Done = TRUE;
                }


                //
                //  Do we need to send another burst to satisfy the write IRP?
                //

                if ( IrpContext->Specific.Write.RemainingLength != 0 ) {

                    //
                    //  Write the next packet.
                    //

                    DebugTrace( 0, Dbg, "RemainingLength  = %ld\n", IrpContext->Specific.Write.RemainingLength);
                    DebugTrace( 0, Dbg, "FileOffset       = %ld\n", IrpContext->Specific.Write.FileOffset);
                    DebugTrace( 0, Dbg, "WriteOffset      = %ld\n", IrpContext->Specific.Write.WriteOffset);

                    Length = MIN( (ULONG)IrpContext->pNpScb->MaxSendSize,
                        IrpContext->Specific.Write.RemainingLength );

                    IrpContext->Specific.Write.LastWriteLength = Length;

                } else {
                    Done = TRUE;
                }

            }  // else  ( not a system packet )

        }  // while ( missing data )

        //
        //  Update the burst request number now.
        //

        if ( status != STATUS_REMOTE_NOT_LISTENING ) {
            IrpContext->pNpScb->BurstRequestNo++;
        }

        //
        //  If we need to reconnect, do it now.
        //

        if ( BooleanFlagOn( IrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT ) ) {
            BurstWriteReconnect( IrpContext );
        }

        //
        //  Dequeue this Irp context in preparation for the next run
        //  through the loop.
        //

EndOfLoop:
        ASSERT( status != STATUS_PENDING );

        FREE_MDL( IrpContext->Specific.Write.PartialMdl );

        //
        //  Unlock locked pages, and free our MDL.
        //

        if ( WriteMdl == NULL ) {
            MmUnlockPages( DataMdl );
        }

        FREE_MDL( DataMdl );

    } while ( !Done );

    DebugTrace(-1, Dbg, "BurstWrite -> %08lx\n", status );
    return status;
}

#ifdef NWDBG
int DropWritePackets;
#endif


NTSTATUS
BurstWriteCompletionSend(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles completion of a burst write send.  If the sending
    thread is waiting for send completion notification, it signals the
    IrpContext Event.

    Note that this routine can be called from SendWriteBurst (i.e. not
    at DPC level), if an allocation fails.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the IrpContext associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    PIRP_CONTEXT pIrpContext = (PIRP_CONTEXT) Context;
    INTERLOCKED_RESULT Result;
    KIRQL OldIrql;
    NTSTATUS Status;

    //
    //  Avoid completing the Irp because the Mdl etc. do not contain
    //  their original values.
    //

    DebugTrace( +1, Dbg, "BurstWriteCompletionSend\n", 0);
    DebugTrace( +0, Dbg, "Irp   %X\n", Irp);
    DebugTrace( +0, Dbg, "pIrpC %X\n", pIrpContext);

    if ( Irp != NULL ) {

        DebugTrace( 0, Dbg, "Burst Write Send = %08lx\n", Irp->IoStatus.Status );

        Status = Irp->IoStatus.Status;

    } else {

        Status = STATUS_SUCCESS;

    }

    //
    //  If this was a secondary IRP, free it now.
    //

    if ( pIrpContext->NodeTypeCode == NW_NTC_MINI_IRP_CONTEXT ) {
        PMINI_IRP_CONTEXT MiniIrpContext;

        MiniIrpContext = (PMINI_IRP_CONTEXT)pIrpContext;

        ASSERT( MiniIrpContext->Mdl2->Next == NULL );

        pIrpContext = MiniIrpContext->IrpContext;
        FreeMiniIrpContext( MiniIrpContext );

    }

    //
    //  Nothing to do unless the last send has completed.
    //

    Result = InterlockedDecrement(
                 &pIrpContext->Specific.Write.PacketCount );

    if ( Result ) {
        DebugTrace( 0, Dbg, "Packets to go = %d\n", pIrpContext->Specific.Write.PacketCount );

        if (Status == STATUS_BAD_NETWORK_PATH) {

            //
            //  IPX has ripped for the destination but failed to find the net. Minimise the
            //  difference between this case and sending a normal burst by completing the
            //  transmission as soon as possible.
            //

            pIrpContext->pNpScb->NwSendDelay = 0;

        }

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    KeAcquireSpinLock( &pIrpContext->pNpScb->NpScbSpinLock, &OldIrql );

    ASSERT( pIrpContext->pNpScb->Sending == TRUE );
    pIrpContext->pNpScb->Sending = FALSE;

    //
    //  Signal to the writing thread that the send has completed, if it
    //  is waiting.
    //

    if ( BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_SIGNAL_EVENT ) ) {
        ClearFlag( pIrpContext->Flags, IRP_FLAG_SIGNAL_EVENT );
        NwSetIrpContextEvent( pIrpContext );
    }

    //
    //  If we processed a receive while waiting for send
    //  completion call the receive handler routine now.
    //

    if ( pIrpContext->pNpScb->Received ) {

        pIrpContext->pNpScb->Receiving = FALSE;
        pIrpContext->pNpScb->Received  = FALSE;

        KeReleaseSpinLock( &pIrpContext->pNpScb->NpScbSpinLock, OldIrql );

        pIrpContext->pEx(
            pIrpContext,
            pIrpContext->ResponseLength,
            pIrpContext->rsp );

    } else {
        if ((Status == STATUS_BAD_NETWORK_PATH) &&
            (pIrpContext->pNpScb->Receiving == FALSE)) {

            //
            //  Usually means a ras connection has gone down during the burst.
            //  Go through the timeout logic now because the ras timeouts take
            //  a long time and unless we re rip things won't get better.
            //

            pIrpContext->Specific.Write.Status = STATUS_REMOTE_NOT_LISTENING;
            ClearFlag( pIrpContext->Flags, IRP_FLAG_RETRY_SEND );

            NwSetIrpContextEvent( pIrpContext );

        }

        KeReleaseSpinLock( &pIrpContext->pNpScb->NpScbSpinLock, OldIrql );
    }

    DebugTrace( -1, Dbg, "BurstWriteCompletionSend -> STATUS_MORE_PROCESSING_REQUIRED\n", 0);
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
}


NTSTATUS
BurstWriteCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )
/*++

Routine Description:

    This routine receives the response a burst write.

Arguments:

    IrpContext - A pointer to the context information for this IRP.

    BytesAvailable - Actual number of bytes in the received message.

    Response - Points to the receive buffer.

Return Value:

    VOID

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugTrace(0, Dbg, "BurstWriteCallback...\n", 0);

    if ( BytesAvailable == 0) {

        //
        //  No response from server. Status is in pIrpContext->Write.Status
        //  Clear the retry send bit so we don't keep retrying.
        //

        IrpContext->Specific.Write.Status = STATUS_REMOTE_NOT_LISTENING;
        ClearFlag( IrpContext->Flags, IRP_FLAG_RETRY_SEND );

        NwSetIrpContextEvent( IrpContext );

        DebugTrace(-1, Dbg, "BurstWriteCallback -> %X\n", STATUS_REMOTE_NOT_LISTENING );
        return STATUS_REMOTE_NOT_LISTENING;
    }

    IrpContext->Specific.Write.Status = STATUS_SUCCESS;
    ASSERT( BytesAvailable < MAX_RECV_DATA );
    ++Stats.PacketBurstWriteNcps;

    //
    //   Clear the retry send bit, since we have a response.
    //

    ClearFlag( IrpContext->Flags, IRP_FLAG_RETRY_SEND );

    //
    //   Copy the burst write response, and signal the users thread
    //   to continue.
    //

    TdiCopyLookaheadData(
        IrpContext->rsp,
        Response,
        BytesAvailable < MAX_RECV_DATA ? BytesAvailable : MAX_RECV_DATA,
        0
        );

    IrpContext->ResponseLength = BytesAvailable;

    NwSetIrpContextEvent( IrpContext );
    return STATUS_SUCCESS;
}


NTSTATUS
SendWriteBurst(
    PIRP_CONTEXT IrpContext,
    ULONG BurstOffset,
    USHORT Length,
    BOOLEAN EndOfBurst,
    BOOLEAN Retransmission
    )
/*++

Routine Description:

    This routine does the actual work of sending a series of burst write
    NCPs to the server.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

    BurstOffset - The offset in the burst to start sending.  If BurstOffset
        equals BURST_WRITE_HEADER_SIZE, start from the beginning of the burst.

    Length - The length of the burst.

    EndOfBurst - If TRUE set the end of burst bit when sending the last
        frame.  Otherwise there is more (discontiguous) data to come in
        the current burst.

    Retransmission - If TRUE, this is a burst write timeout retransmission.
        Send the first packet only.

Return Value:

    Status of transfer.

--*/
{
    UCHAR BurstFlags;
    NTSTATUS Status;
    BOOLEAN MoreData;
    PIRP SendIrp;
    PMINI_IRP_CONTEXT MiniIrpContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "SendWriteBurst...\n", 0);

    DebugTrace( 0, Dbg, "Data offset  = %d\n", BurstOffset );
    DebugTrace( 0, Dbg, "Data length  = %d\n", Length );
    DebugTrace( 0, Dbg, "End of burst = %d\n", EndOfBurst );

    //
    //  Send the request.
    //

    SetFlag( IrpContext->Flags, IRP_FLAG_BURST_REQUEST | IRP_FLAG_BURST_PACKET );

    //
    //  Set the burst flags
    //

    IrpContext->Specific.Write.BurstLength =
        MIN( IrpContext->pNpScb->MaxPacketSize, Length );

    //
    //  Set the end-of-burst bit (and enable receiving the response), if this
    //  is the last packet we expect to send.
    //

    if ( ( !EndOfBurst || IrpContext->Specific.Write.BurstLength < Length )
         && !Retransmission ) {

        IrpContext->pNpScb->OkToReceive = FALSE;
        SetFlag( IrpContext->Flags, IRP_FLAG_NOT_OK_TO_RECEIVE );
        BurstFlags = 0;

    } else {

        DebugTrace( 0, Dbg, "Last packet in the burst\n", 0);
        ClearFlag( IrpContext->Flags, IRP_FLAG_NOT_OK_TO_RECEIVE );
        BurstFlags = BURST_FLAG_END_OF_BURST;

    }

    if ( !EndOfBurst ) {
        SetFlag( IrpContext->Flags, IRP_FLAG_SIGNAL_EVENT );
    }

    //
    //  Build the partial MDL for the first packet in the burst.
    //

    IoBuildPartialMdl(
        IrpContext->Specific.Write.FullMdl,
        IrpContext->Specific.Write.PartialMdl,
        (PUCHAR)MmGetMdlVirtualAddress( IrpContext->Specific.Write.FullMdl ) +
            BurstOffset - BURST_WRITE_HEADER_SIZE,
        IrpContext->Specific.Write.BurstLength );

    //
    //  Set the burst flags
    //

    if ( BurstOffset == BURST_WRITE_HEADER_SIZE ) {
        SetFlag( IrpContext->Flags, IRP_FLAG_BURST_REQUEST | IRP_FLAG_BURST_PACKET );
    }

    if ( ( IrpContext->Specific.Write.BurstLength < Length )  &&
         !Retransmission ) {
        MoreData = TRUE;
    } else {
        MoreData = FALSE;
    }

    if ( BurstOffset == BURST_WRITE_HEADER_SIZE ) {

        BuildBurstWriteFirstReq(
            IrpContext,
            IrpContext->req,
            Length,
            IrpContext->Specific.Write.PartialMdl,
            BurstFlags,
            *(ULONG UNALIGNED *)(&IrpContext->Icb->Handle[2]),
            IrpContext->Specific.Write.FileOffset );

    } else {

        BuildBurstWriteNextReq(
            IrpContext,
            IrpContext->req,
            IrpContext->Specific.Write.LastWriteLength + BURST_WRITE_HEADER_SIZE,
            BurstFlags,
            BurstOffset,
            IrpContext->TxMdl,
            IrpContext->Specific.Write.PartialMdl
            );

    }

    if ( !Retransmission ) {
        IrpContext->Specific.Write.PacketCount =
            ( Length + IrpContext->pNpScb->MaxPacketSize - 1 ) /
                IrpContext->pNpScb->MaxPacketSize;

    } else {
        IrpContext->Specific.Write.PacketCount = 1;
    }

    DebugTrace( 0, Dbg, "Packet count  = %d\n", IrpContext->Specific.Write.PacketCount );

    DebugTrace( 0, DEBUG_TRACE_LIP, "Send delay = %d\n", IrpContext->pNpScb->NwSendDelay );

    //
    //  Use the original IRP context to format the first packet.
    //

    ++Stats.PacketBurstWriteNcps;
    PreparePacket( IrpContext, IrpContext->pOriginalIrp, IrpContext->TxMdl );

    Status = SendPacket( IrpContext, IrpContext->pNpScb );

    while ( MoreData ) {

        if ( IrpContext->pNpScb->NwSendDelay > 0 ) {

            //
            //  Introduce a send delay between packets.
            //

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &IrpContext->pNpScb->NtSendDelay );
        }

        MiniIrpContext = AllocateMiniIrpContext( IrpContext );

        DebugTrace( 0, Dbg, "Allocated mini IrpContext = %X\n", MiniIrpContext );

        //
        //  Calculate the total number of bytes to send during this burst. Do this before
        //  checking to see if MiniIrpContext is NULL so that we skip the packet rather
        //  than sitting in a tight loop.
        //

        BurstOffset += IrpContext->Specific.Write.BurstLength;

        //
        //  Do we need to send another burst write packet?
        //

        Length -= (USHORT)IrpContext->Specific.Write.BurstLength;

        ASSERT ( Length > 0 );

        IrpContext->Specific.Write.BurstLength =
            MIN( IrpContext->pNpScb->MaxPacketSize, (ULONG)Length );

        DebugTrace( +0, Dbg, "More data, sending %d bytes\n", IrpContext->Specific.Write.BurstLength );

        //
        //  If we can't allocate a mini irp context to send the packet,
        //  just skip it and wait for the server to ask a retranmit.  At
        //  this point performance isn't exactly stellar, so don't worry
        //  about having to wait for a timeout.
        //

        if ( MiniIrpContext == NULL ) {

            InterlockedDecrement(
                &IrpContext->Specific.Write.PacketCount );

            if ( Length == IrpContext->Specific.Write.BurstLength ) {
                MoreData = FALSE;
                break;
            }

            continue;
        }

#ifdef NWDBG

        //
        //  If DropWritePackets is enabled, simulate missing packets, by
        //  occasionally dropping 500 bytes of data.
        //

        if ( DropWritePackets != 0 ) {
            if ( ( rand() % DropWritePackets ) == 0 &&
                 Length != IrpContext->Specific.Write.BurstLength ) {

                FreeMiniIrpContext( MiniIrpContext );

                InterlockedDecrement(
                    &IrpContext->Specific.Write.PacketCount );

                continue;
            }
        }
#endif

        //
        //  Build the MDL for the data to send.
        //

        IoBuildPartialMdl(
            IrpContext->Specific.Write.FullMdl,
            MiniIrpContext->Mdl2,
            (PUCHAR)MmGetMdlVirtualAddress( IrpContext->Specific.Write.FullMdl ) +
                BurstOffset - BURST_WRITE_HEADER_SIZE,
            IrpContext->Specific.Write.BurstLength );

        //
        //  Set the burst flags
        //

        if ( !EndOfBurst || IrpContext->Specific.Write.BurstLength < Length ) {

            IrpContext->pNpScb->OkToReceive = FALSE;
            SetFlag( IrpContext->Flags, IRP_FLAG_NOT_OK_TO_RECEIVE );
            BurstFlags = 0;
        } else {
            DebugTrace( 0, Dbg, "Last packet in the burst\n", 0);
            ClearFlag( IrpContext->Flags, IRP_FLAG_NOT_OK_TO_RECEIVE );
            BurstFlags = BURST_FLAG_END_OF_BURST;
        }

        if ( IrpContext->Specific.Write.BurstLength == Length ) {
            MoreData = FALSE;
        }

        BuildBurstWriteNextReq(
            IrpContext,
            MiniIrpContext->Mdl1->MappedSystemVa,
            IrpContext->Specific.Write.LastWriteLength +
                BURST_WRITE_HEADER_SIZE,
            BurstFlags,
            BurstOffset,
            MiniIrpContext->Mdl1,
            MiniIrpContext->Mdl2
            );

        ++Stats.PacketBurstWriteNcps;

        SendIrp = MiniIrpContext->Irp;

        PreparePacket( IrpContext, SendIrp, MiniIrpContext->Mdl1 );

        IoSetCompletionRoutine( SendIrp, BurstWriteCompletionSend, MiniIrpContext, TRUE, TRUE, TRUE);

        ASSERT( MiniIrpContext->Mdl2->Next == NULL );

        Status = SendSecondaryPacket( IrpContext, SendIrp );
    }

    //
    //  If this is not the end-of-burst, wait for send completion here,
    //  since the caller is about to send more data.
    //

    if ( !EndOfBurst ) {
        KeWaitForSingleObject( &IrpContext->Event, Executive, KernelMode, FALSE, NULL );
    }

    DebugTrace( -1, Dbg, "SendWriteBurst -> %X\n", Status );
    return( Status );
}


VOID
BurstWriteTimeout(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine handles a burst write timeout.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

Return Value:

    None

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PIRP Irp;

    DebugTrace(0, Dbg, "BurstWriteTimeout\n", 0 );

    Irp = IrpContext->pOriginalIrp;

    //
    //  Set the RetrySend flag, so that we know to retransmit the request.
    //

    SetFlag( IrpContext->Flags, IRP_FLAG_RETRY_SEND );

    //
    //  Signal the write thread to wakeup and resend the burst.
    //

    NwSetIrpContextEvent( IrpContext );

    Stats.PacketBurstWriteTimeouts++;

    return;
}


NTSTATUS
ResubmitBurstWrite(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine resubmits a burst write over a new burst connection.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

Return Value:

    None

--*/
{

    PNONPAGED_SCB pNpScb = IrpContext->pNpScb;

    PAGED_CODE();

    //
    //  Remember that we need to establish a new burst connection.
    //

    SetFlag( IrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT );

    //
    //  Set the packet size down the largest packet we can use, that
    //  is guaranteed to be routable.
    //

    pNpScb->MaxPacketSize = DEFAULT_PACKET_SIZE;

    //
    //  Crank the delay times down so we give the new connection a chance.
    //

    pNpScb->NwGoodSendDelay = pNpScb->NwBadSendDelay = pNpScb->NwSendDelay = MinSendDelay;
    pNpScb->NwGoodReceiveDelay = pNpScb->NwBadReceiveDelay = pNpScb->NwReceiveDelay = MinReceiveDelay;

    pNpScb->SendBurstSuccessCount = 0;
    pNpScb->ReceiveBurstSuccessCount = 0;

    pNpScb->NtSendDelay.QuadPart = MinSendDelay;

    //
    //  Signal the write thread to wakeup and resend the burst.
    //

    NwSetIrpContextEvent( IrpContext );

    return( STATUS_PENDING );
}


NTSTATUS
BurstWriteReconnect(
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine allocates a new IRP context and renegotiates burst mode.

Arguments:

    IrpContext - A pointer to IRP context information for this request.

Return Value:

    None

--*/
{
    PIRP_CONTEXT pNewIrpContext;
    PNONPAGED_SCB pNpScb = IrpContext->pNpScb;
    BOOLEAN LIPNegotiated ;

    PAGED_CODE();

    //
    //  Attempt to allocate an extra IRP context.
    //

    if ( !NwAllocateExtraIrpContext( &pNewIrpContext, pNpScb ) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pNewIrpContext->Specific.Create.UserUid = IrpContext->Specific.Create.UserUid;

    SetFlag( pNewIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT );
    pNewIrpContext->pNpScb = pNpScb;

    //
    //  Insert this new IrpContext to the head of
    //  the SCB queue for  processing.  We can get away with this
    //  because we own the IRP context currently at the front of
    //  the queue.
    //

    ExInterlockedInsertHeadList(
        &pNpScb->Requests,
        &pNewIrpContext->NextRequest,
        &pNpScb->NpScbSpinLock );

    SetFlag( pNewIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE );

    //
    //  Renegotiate the burst connection, this will automatically re-sync
    //  the burst connection.
    //

    NegotiateBurstMode( pNewIrpContext, pNpScb, &LIPNegotiated );

    //
    //  Reset the sequence numbers.
    //

    pNpScb->BurstSequenceNo = 0;
    pNpScb->BurstRequestNo = 0;

    //
    //  Dequeue and free the bonus IRP context.
    //

    ExInterlockedRemoveHeadList(
        &pNpScb->Requests,
        &pNpScb->NpScbSpinLock );

    ClearFlag( pNewIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE );

    NwFreeExtraIrpContext( pNewIrpContext );

    ClearFlag( IrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT );

    return( STATUS_SUCCESS );
}


NTSTATUS
NwFsdFlushBuffers(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the FSD routine that handles NtFlushBuffersFile.

Arguments:

    DeviceObject - Supplies the device object for the write function.

    Irp - Supplies the IRP to process.

Return Value:

    NTSTATUS - The result status.

--*/

{
    PIRP_CONTEXT pIrpContext = NULL;
    NTSTATUS status;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdFlushBuffers\n", 0);

    //
    // Call the common write routine.
    //

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        pIrpContext = AllocateIrpContext( Irp );
        status = NwCommonFlushBuffers( pIrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( pIrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error Status that we get back from the
            //  execption code
            //

            status = NwProcessException( pIrpContext, GetExceptionCode() );
      }

    }

    if ( pIrpContext ) {
        NwCompleteRequest( pIrpContext, status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "NwFsdFlushBuffers -> %08lx\n", status );

    return status;
}


NTSTATUS
NwCommonFlushBuffers (
    IN PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine requests all dirty cache buffers to be flushed for a
    given file.

Arguments:

    IrpContext - Supplies the request being processed.

Return Value:

    The status of the operation.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    NTSTATUS Status;
    PFCB Fcb;
    PICB Icb;
    NODE_TYPE_CODE NodeTypeCode;
    PVOID FsContext;

    PAGED_CODE();

    DebugTrace(0, Dbg, "NwCommonFlushBuffers...\n", 0);

    //
    //  Get the current stack location
    //

    Irp = IrpContext->pOriginalIrp;
    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( 0, Dbg, "Irp  = %08lx\n", (ULONG_PTR)Irp);

    //
    // Decode the file object to figure out who we are.  If the result
    // is not the a file then its an illegal parameter.
    //

    if (( NodeTypeCode = NwDecodeFileObject( IrpSp->FileObject,
                                             &FsContext,
                                             (PVOID *)&Icb )) != NW_NTC_ICB) {

        DebugTrace(0, Dbg, "Not a file\n", 0);

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "NwCommonFlushBuffers  -> %08lx\n", Status );
        return Status;
    }

    //
    //  Make sure that this ICB is still active.
    //

    NwVerifyIcbSpecial( Icb );

    Fcb = (PFCB)Icb->SuperType.Fcb;
    NodeTypeCode = Fcb->NodeTypeCode;

    if ( NodeTypeCode != NW_NTC_FCB ) {

        DebugTrace(0, Dbg, "Not a file\n", 0);
        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonFlushBuffers -> %08lx\n", Status );
        return Status;
    }

    //
    //  Set up the IRP context to do an exchange
    //

    IrpContext->pScb = Fcb->Scb;
    IrpContext->pNpScb = IrpContext->pScb->pNpScb;
    IrpContext->Icb = Icb;

    //
    //  Send any user data to the server. Note we must not be on the
    //  queue when we do this.
    //

    MmFlushImageSection(&Icb->NpFcb->SegmentObject, MmFlushForWrite);

    //
    //  Flush our dirty data.
    //

    Status = AcquireFcbAndFlushCache( IrpContext, Fcb->NonPagedFcb );
    if ( !NT_SUCCESS( Status )) {
        return( Status  );
    }

    //
    //  Send a flush NCP
    //

    Status = Exchange (
                IrpContext,
                FlushBuffersCallback,
                "F-r",
                NCP_FLUSH_FILE,
                &Icb->Handle, sizeof( Icb->Handle ) );

    return( Status );
}


NTSTATUS
FlushBuffersCallback (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )
/*++

Routine Description:

    This routine receives the flush file size response and completes the
    flush IRP.

Arguments:



Return Value:

    VOID

--*/

{
    NTSTATUS Status;

    DebugTrace(0, Dbg, "FlushBuffersCallback...\n", 0);

    if ( BytesAvailable == 0) {

        //
        //  We're done with this request.  Dequeue the IRP context from
        //  SCB and complete the request.
        //

        NwDequeueIrpContext( IrpContext, FALSE );
        NwCompleteRequest( IrpContext, STATUS_REMOTE_NOT_LISTENING );

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

        DebugTrace( 0, Dbg, "Timeout\n", 0);
        return STATUS_REMOTE_NOT_LISTENING;
    }

    //
    // Get the data from the response.
    //

    Status = ParseResponse(
                 IrpContext,
                 Response,
                 BytesAvailable,
                 "N" );

    //
    //  We're done with this request.  Dequeue the IRP context from
    //  SCB and complete the request.
    //

    NwDequeueIrpContext( IrpContext, FALSE );
    NwCompleteRequest( IrpContext, Status );

    return Status;
}


VOID
BuildBurstWriteFirstReq(
    PIRP_CONTEXT IrpContext,
    PVOID Buffer,
    ULONG DataSize,
    PMDL BurstMdl,
    UCHAR Flags,
    ULONG Handle,
    ULONG FileOffset
    )
{
    PNCP_BURST_WRITE_REQUEST BurstWrite;
    PNONPAGED_SCB pNpScb;
    ULONG RealDataLength;
    USHORT RealBurstLength;

    PAGED_CODE();

    BurstWrite = (PNCP_BURST_WRITE_REQUEST)Buffer;
    pNpScb = IrpContext->pNpScb;

    RealDataLength = DataSize + sizeof( *BurstWrite ) - sizeof( NCP_BURST_HEADER );
    RealBurstLength = (USHORT)MdlLength( BurstMdl ) + sizeof( *BurstWrite ) - sizeof( NCP_BURST_HEADER );

    BurstWrite->BurstHeader.Command = PEP_COMMAND_BURST;
    BurstWrite->BurstHeader.Flags = Flags;
    BurstWrite->BurstHeader.StreamType = 0x02;
    BurstWrite->BurstHeader.SourceConnection = pNpScb->SourceConnectionId;
    BurstWrite->BurstHeader.DestinationConnection = pNpScb->DestinationConnectionId;


    if ( !BooleanFlagOn( IrpContext->Flags, IRP_FLAG_RETRY_SEND ) ) {

        //
        //  Use the same delay on all retransmissions of the burst. Save
        //  the current time.
        //

        pNpScb->CurrentBurstDelay = pNpScb->NwSendDelay;

        //
        //  Send system packet next retransmission.
        //

        ClearFlag( IrpContext->Flags, IRP_FLAG_NOT_SYSTEM_PACKET );

    } else {

        //
        //  This is a retransmission. Alternate between sending a system
        //  packet and the first write.
        //

        if ( !BooleanFlagOn( IrpContext->Flags, IRP_FLAG_NOT_SYSTEM_PACKET ) ) {


            SetFlag( IrpContext->Flags, IRP_FLAG_NOT_SYSTEM_PACKET );

            BurstWrite->BurstHeader.Flags = BURST_FLAG_SYSTEM_PACKET;

            LongByteSwap( BurstWrite->BurstHeader.SendDelayTime, pNpScb->CurrentBurstDelay );

            BurstWrite->BurstHeader.DataSize = 0;
            BurstWrite->BurstHeader.BurstOffset = 0;
            BurstWrite->BurstHeader.BurstLength = 0;
            BurstWrite->BurstHeader.MissingFragmentCount = 0;

            IrpContext->TxMdl->ByteCount = sizeof( NCP_BURST_HEADER );
            IrpContext->TxMdl->Next = NULL;

            return;

        }

        //
        //  Send system packet next retransmission.
        //

        ClearFlag( IrpContext->Flags, IRP_FLAG_NOT_SYSTEM_PACKET );

    }

    LongByteSwap( BurstWrite->BurstHeader.SendDelayTime, pNpScb->CurrentBurstDelay );

    LongByteSwap( BurstWrite->BurstHeader.DataSize, RealDataLength );
    BurstWrite->BurstHeader.BurstOffset = 0;
    ShortByteSwap( BurstWrite->BurstHeader.BurstLength, RealBurstLength );
    BurstWrite->BurstHeader.MissingFragmentCount = 0;

    BurstWrite->Function = BURST_REQUEST_WRITE;
    BurstWrite->Handle = Handle;
    LongByteSwap( BurstWrite->TotalWriteOffset, IrpContext->Specific.Write.TotalWriteOffset );
    LongByteSwap( BurstWrite->TotalWriteLength, IrpContext->Specific.Write.TotalWriteLength );
    LongByteSwap( BurstWrite->Offset, FileOffset );
    LongByteSwap( BurstWrite->Length, DataSize );

    IrpContext->TxMdl->ByteCount = sizeof( *BurstWrite );
    IrpContext->TxMdl->Next = BurstMdl;

    return;
}

VOID
BuildBurstWriteNextReq(
    PIRP_CONTEXT IrpContext,
    PVOID Buffer,
    ULONG DataSize,
    UCHAR BurstFlags,
    ULONG BurstOffset,
    PMDL BurstHeaderMdl,
    PMDL BurstDataMdl
    )
{
    PNCP_BURST_HEADER BurstHeader;
    PNONPAGED_SCB pNpScb;
    USHORT BurstLength;

    PAGED_CODE();

    BurstHeader = (PNCP_BURST_HEADER)Buffer;
    pNpScb = IrpContext->pNpScb;

    BurstLength = (USHORT)MdlLength( BurstDataMdl );

    BurstHeader->Command = PEP_COMMAND_BURST;
    BurstHeader->Flags = BurstFlags;
    BurstHeader->StreamType = 0x02;
    BurstHeader->SourceConnection = pNpScb->SourceConnectionId;
    BurstHeader->DestinationConnection = pNpScb->DestinationConnectionId;

    LongByteSwap( BurstHeader->SendDelayTime, pNpScb->CurrentBurstDelay );

    if ( BooleanFlagOn( IrpContext->Flags, IRP_FLAG_RETRY_SEND ) ) {

        //
        //  This is a retransmission. Alternate between sending a system
        //  packet and the first write.
        //

        if ( !BooleanFlagOn( IrpContext->Flags, IRP_FLAG_NOT_SYSTEM_PACKET ) ) {


            SetFlag( IrpContext->Flags, IRP_FLAG_NOT_SYSTEM_PACKET );

            BurstHeader->Flags = BURST_FLAG_SYSTEM_PACKET;

            LongByteSwap( BurstHeader->SendDelayTime, pNpScb->CurrentBurstDelay );

            BurstHeader->DataSize = 0;
            BurstHeader->BurstOffset = 0;
            BurstHeader->BurstLength = 0;
            BurstHeader->MissingFragmentCount = 0;

            IrpContext->TxMdl->ByteCount = sizeof( NCP_BURST_HEADER );
            IrpContext->TxMdl->Next = NULL;

            return;

        }

        //
        //  Send system packet next retransmission.
        //

        ClearFlag( IrpContext->Flags, IRP_FLAG_NOT_SYSTEM_PACKET );

    } else {

        //
        //  Send system packet next retransmission.
        //

        ClearFlag( IrpContext->Flags, IRP_FLAG_NOT_SYSTEM_PACKET );

    }

    LongByteSwap( BurstHeader->DataSize, DataSize );
    LongByteSwap( BurstHeader->BurstOffset, BurstOffset );
    ShortByteSwap( BurstHeader->BurstLength, BurstLength );
    BurstHeader->MissingFragmentCount = 0;

    BurstHeaderMdl->ByteCount = sizeof( *BurstHeader );
    BurstHeaderMdl->Next = BurstDataMdl;

    return;
}


NTSTATUS
SendSecondaryPacket(
    PIRP_CONTEXT IrpContext,
    PIRP Irp
    )
/*++

Routine Description:

    This routine submits a TDI send request to the tranport layer.

Arguments:

    IrpContext - A pointer to IRP context information for the request
        being processed.

    Irp - The IRP for the packet to send.

Return Value:

    None.

--*/
{
    PNONPAGED_SCB pNpScb;
    NTSTATUS Status;
    PNCP_BURST_HEADER BurstHeader;
    pNpScb = IrpContext->pNpScb;

    DebugTrace( 0, Dbg, "SendSecondaryPacket\n", 0 );

    BurstHeader = (PNCP_BURST_HEADER)( MmGetMdlVirtualAddress( Irp->MdlAddress ) );

    if ( !BooleanFlagOn( IrpContext->Flags, IRP_FLAG_NOT_OK_TO_RECEIVE ) ) {
        pNpScb->OkToReceive = TRUE;
    }

    LongByteSwap( BurstHeader->PacketSequenceNo, pNpScb->BurstSequenceNo );
    pNpScb->BurstSequenceNo++;

    ShortByteSwap( BurstHeader->BurstSequenceNo, pNpScb->BurstRequestNo );
    ShortByteSwap( BurstHeader->AckSequenceNo, pNpScb->BurstRequestNo );

    DebugTrace( +0, Dbg, "Irp   %X\n", Irp );
    DebugTrace( +0, Dbg, "pIrpC %X\n", IrpContext);

#if NWDBG
    dumpMdl( Dbg, IrpContext->TxMdl);
#endif

    Stats.BytesTransmitted.QuadPart += MdlLength( Irp->MdlAddress );
    Stats.NcpsTransmitted.QuadPart += 1;

    Status = IoCallDriver( pNpScb->Server.pDeviceObject, Irp );
    DebugTrace( -1, Dbg, "      %X\n", Status );

    if ( !NT_SUCCESS( Status ) ) {
        Error( EVENT_NWRDR_NETWORK_ERROR, Status, NULL, 0, 0 );
    }

    return Status;
}

#if NWFASTIO

BOOLEAN
NwFastWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine does a fast cached read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcCopyRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    NODE_TYPE_CODE nodeTypeCode;
    PICB icb;
    PFCB fcb;
    PVOID fsContext;
    ULONG offset;
    BOOLEAN wroteToCache;

    try {
    
        FsRtlEnterFileSystem();

        DebugTrace(+1, Dbg, "NwFastWrite...\n", 0);
    
        //
        //  Special case a read of zero length
        //
    
        if (Length == 0) {
    
            //
            //  A zero length transfer was requested.
            //
    
            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = 0;
    
            DebugTrace(+1, Dbg, "NwFastWrite -> TRUE\n", 0);
            return TRUE;
        }
    
        //
        // Decode the file object to figure out who we are.  If the result
        // is not FCB then its an illegal parameter.
        //
    
        if ((nodeTypeCode = NwDecodeFileObject( FileObject,
                                                &fsContext,
                                                (PVOID *)&icb )) != NW_NTC_ICB) {
    
            DebugTrace(0, Dbg, "Not a file\n", 0);
            DebugTrace(-1, Dbg, "NwFastWrite -> FALSE\n", 0);
            return FALSE;
        }
    
        fcb = (PFCB)icb->SuperType.Fcb;
        nodeTypeCode = fcb->NodeTypeCode;
        offset = FileOffset->LowPart;
    
        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = Length;
    
        wroteToCache = CacheWrite(
                           NULL,
                           fcb->NonPagedFcb,
                           offset,
                           Length,
                           Buffer );
    
        DebugTrace(-1, Dbg, "NwFastWrite -> %s\n", wroteToCache ? "TRUE" : "FALSE" );
    
        if ( wroteToCache ) {
    
            //
            //  If the file was extended, record the new file size.
            //
    
            if ( ( offset + Length )  > fcb->NonPagedFcb->Header.FileSize.LowPart ) {
                fcb->NonPagedFcb->Header.FileSize.LowPart = ( offset + Length );
            }
        }
    
    #ifndef NT1057
    
        //
        //  Update the file object if we succeeded.  We know that this
        //  is synchronous and not paging io because it's coming in through
        //  the cache.
        //
    
        if ( wroteToCache ) {
            FileObject->CurrentByteOffset.QuadPart = FileOffset->QuadPart + Length;
        }
    
    #endif
    
        return( wroteToCache );
    
    } finally {

        FsRtlExitFileSystem();
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\rdr\kdext\nwrdrkd.c ===
/*++

NwRdr Kernel Debugger Extensions
Copyright (c) 1995 Microsoft Corporation

Abstract:

    NW Redirector Kernel Debugger extensions.

    This module contains a set of useful kernel debugger
    extensions for the NT nw redirector.

Author:

    Cory West <corywest>, 09-Jan-1994

--*/

#include "procs.h"
#include "nodetype.h"

#include <string.h>
#include <stdlib.h>

//
// Function prototypes.
//

VOID
DumpScbNp(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    BOOL first
    );

VOID
DumpFcbNp(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    BOOL first
    );

//
// Define some macros for simplicity.
//

#define  GET_DWORD( pDest, addr ) \
    (lpExtensionApis->lpReadVirtualMemRoutine)((LPVOID)(addr), pDest, 4, NULL)
#define  GET_WORD( pDest, addr )  \
    (lpExtensionApis->lpReadVirtualMemRoutine)((LPVOID)(addr), pDest, 2, NULL)
#define  GET_STRING( pDest, string ) \
    (lpExtensionApis->lpReadVirtualMemRoutine)(string.Buffer, pDest, \
        string.Length, NULL); pDest[ string.Length/2 ] = L'\0'

#define printf lpExtensionApis->lpOutputRoutine
#define getmem lpExtensionApis->lpReadVirtualMemRoutine
#define getexpr lpExtensionApis->lpGetExpressionRoutine

#ifdef WINDBG
#define getsymaddr( string ) ((lpExtensionApis->lpGetExpressionRoutine))( "&"##string )
#else
#define getsymaddr lpExtensionApis->lpGetExpressionRoutine
#endif

VOID
help(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

    This function prints out usage for the nw debugger extensions.

--*/
{
    printf( "---------------------------------------------------------------------------\n");
    printf( "NwRdr Debugger Extensions:\n\n");

    printf( "Top Level Functions:\n\n");

    printf( "serverlist(void)        - List the servers that the redirector knows.\n");
    printf( "logonlist(void)         - List the users that are logged on.\n");
    printf( "trace(void)             - Display the trace buffer.\n");
    printf( "nwdump(virtual addr)    - Display the object at the given virtual address.\n");
    printf( "                          (This function knows how to dump all NwRdr data\n");
    printf( "                           structures.)\n");
    printf( "help(void)              - Display this message.\n\n");

    printf( "List Management Functions:\n\n");

    printf( "vcblist(scb*, npscb*)   - Given a pointer to any of the specified objects,\n");
    printf( "                          this function dumps the VCB list for that server.\n");
    printf( "irplist(scb*, npscb*)   - Given a pointer to any of the specified objects,\n");
    printf( "                          this function dumps the IRP list for that server.\n");
    printf( "fcblist(vcb*)           - Given a pointer to a VCB, this function dumps\n");
    printf( "                          the FCB/DCB list for that VCB.\n");
    printf( "icblist(scb*, npscb*,\n");
    printf( "        fcb*, dcb*,\n");
    printf( "        npfcb*)         - Given a pointer to any of the specified objects,\n");
    printf( "                          function dumps the ICB list for that object.\n");
    printf( "---------------------------------------------------------------------------\n");
}

VOID
traceflags(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

    This function prints out the trace flag values.

--*/
{
    printf( "DEBUG_TRACE_CLEANUP              (0x00000001)\n");
    printf( "DEBUG_TRACE_CLOSE                (0x00000002)\n");
    printf( "DEBUG_TRACE_CLEANUP              (0x00000001)\n");
    printf( "DEBUG_TRACE_CLOSE                (0x00000002)\n");
    printf( "DEBUG_TRACE_CREATE               (0x00000004)\n");
    printf( "DEBUG_TRACE_FSCTRL               (0x00000008)\n");
    printf( "DEBUG_TRACE_IPX                  (0x00000010)\n");
    printf( "DEBUG_TRACE_LOAD                 (0x00000020)\n");
    printf( "DEBUG_TRACE_EXCHANGE             (0x00000040)\n");
    printf( "DEBUG_TRACE_FILOBSUP             (0x00000080)\n");
    printf( "DEBUG_TRACE_STRUCSUP             (0x00000100)\n");
    printf( "DEBUG_TRACE_FSP_DISPATCHER       (0x00000200)\n");
    printf( "DEBUG_TRACE_FSP_DUMP             (0x00000400)\n");
    printf( "DEBUG_TRACE_WORKQUE              (0x00000800)\n");
    printf( "DEBUG_TRACE_UNWIND               (0x00001000)\n");
    printf( "DEBUG_TRACE_CATCH_EXCEPTIONS     (0x00002000)\n");
    printf( "DEBUG_TRACE_FILEINFO             (0x00008000)\n");
    printf( "DEBUG_TRACE_DIRCTRL              (0x00010000)\n");
    printf( "DEBUG_TRACE_CONVERT              (0x00020000)\n");
    printf( "DEBUG_TRACE_WRITE                (0x00040000)\n");
    printf( "DEBUG_TRACE_READ                 (0x00080000)\n");
    printf( "DEBUG_TRACE_VOLINFO              (0x00100000)\n");
    printf( "DEBUG_TRACE_LOCKCTRL             (0x00200000)\n");
    printf( "DEBUG_TRACE_USERNCP              (0x00400000)\n");
    printf( "DEBUG_TRACE_SECURITY             (0x00800000)\n");
    printf( "DEBUG_TRACE_CACHE                (0x01000000)\n");
    printf( "DEBUG_TRACE_LIP                  (0x02000000)\n");
    printf( "DEBUG_TRACE_MDL                  (0x04000000)\n");
    printf( "DEBUG_TRACE_NDS                  (0x10000000)\n");
    printf( "DEBUG_TRACE_SCAVENGER            (0x40000000)\n");
    printf( "DEBUG_TRACE_TIMER                (0x80000000)\n");
}

//
// Internal helper routines to convert numerical data into symbolic data.
//

NODE_TYPE_CODE
GetNodeType(
    DWORD objAddr,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
/*++

    Given the address of an object, this function will
    attempt to get the node type code for that object.

--*/
{

        NODE_TYPE_CODE ntc;
        GET_WORD( &ntc, objAddr );
        return ntc;

}

LPSTR
RcbStateToString(
    DWORD State
    )
/*++

Routine Description:

    This helper function converts the RCB state from a
    DWORD to a readable text string.

Arguments:

    DWORD State - The DWORD RCB state.

Return Value:

    LPSTR containing the readable text string.

--*/
{
    switch ( State ) {

    case RCB_STATE_STOPPED:
        return("RCB_STATE_STOPPED");


    case RCB_STATE_STARTING:
        return("RCB_STATE_STARTING");

    case RCB_STATE_NEED_BIND:
        return("RCB_STATE_NEED_BIND");

    case RCB_STATE_RUNNING:
        return("RCB_STATE_RUNNING");

    case RCB_STATE_SHUTDOWN:
        return("RCB_STATE_SHUTDOWN");

    default:
        return("(state unknown)" );
    }
}

LPSTR
ScbStateToString(
    DWORD State
    )
/*++

Routine Description:

    This helper function converts the SCB state from a
    DWORD to a readable text string.

Arguments:

    DWORD State - The DWORD SCB state.

Return Value:

    LPSTR containing the readable text string.

--*/
{
    switch ( State ) {

    case SCB_STATE_ATTACHING:
        return("SCB_STATE_ATTACHING" );

    case SCB_STATE_IN_USE:
        return("SCB_STATE_IN_USE" );

    case SCB_STATE_DISCONNECTING:
        return("SCB_STATE_DISCONNECTING" );

    case SCB_STATE_FLAG_SHUTDOWN:
        return("SCB_STATE_FLAG_SHUTDOWN" );

    case SCB_STATE_RECONNECT_REQUIRED:
        return("SCB_STATE_RECONNECT_REQD" );

    case SCB_STATE_LOGIN_REQUIRED:
        return("SCB_STATE_LOGIN_REQUIRED" );

    case SCB_STATE_TREE_SCB:
        return("SCB_STATE_TREE_SCB" );

    default:
        return("(state unknown)" );
    }
}

LPSTR
IcbStateToString(
    DWORD State
    )
/*++

Routine Description:

    This helper function converts the ICB state from a
    DWORD to a readable text string.

--*/
{
    switch ( State ) {

    case ICB_STATE_OPEN_PENDING:
        return("ICB_STATE_OPEN_PENDING" );

    case ICB_STATE_OPENED:
        return("ICB_STATE_OPENED" );

    case ICB_STATE_CLEANED_UP:
        return("ICB_STATE_CLEANED_UP" );

    case ICB_STATE_CLOSE_PENDING:
        return("ICB_STATE_CLOSE_PENDING" );

    default:
        return("(state unknown)" );
    }
}

VOID
PrintIrpContextFlags(
    ULONG Flags,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
/*++

    Print out the flags that are set in the IRP_CONTEXT flags.

--*/
{

    if ( Flags & IRP_FLAG_IN_FSD )
        printf( "\tIRP_FLAG_IN_FSD\n" );

    if ( Flags & IRP_FLAG_ON_SCB_QUEUE )
        printf( "\tIRP_FLAG_ON_SCB_QUEUE\n" );

    if ( Flags & IRP_FLAG_SEQUENCE_NO_REQUIRED )
        printf( "\tIRP_FLAG_SEQUENCE_NO_REQUIRED\n" );

    if ( Flags & IRP_FLAG_SIGNAL_EVENT )
        printf( "\tIRP_FLAG_SIGNAL_EVENT\n" );

    if ( Flags & IRP_FLAG_RETRY_SEND )
        printf( "\tIRP_FLAG_RETRY_SEND\n" );

    if ( Flags & IRP_FLAG_RECONNECTABLE )
        printf( "\tIRP_FLAG_RECONNECTABLE\n" );

    if ( Flags & IRP_FLAG_RECONNECT_ATTEMPT )
        printf( "\tIRP_FLAG_RECONNECT_ATTEMPT\n" );

    if ( Flags & IRP_FLAG_BURST_REQUEST )
        printf( "\tIRP_FLAG_BURST_REQUEST\n" );

    if ( Flags & IRP_FLAG_BURST_PACKET )\
        printf( "\tIRP_FLAG_BURST_PACKET\n" );

    if ( Flags & IRP_FLAG_NOT_OK_TO_RECEIVE )
        printf( "\tIRP_FLAG_NOT_OK_TO_RECEIVE\n" );

    if ( Flags & IRP_FLAG_REROUTE_ATTEMPTED )
        printf( "\tIRP_FLAG_REROUTE_ATTEMPTED\n" );

    if ( Flags & IRP_FLAG_BURST_WRITE )
        printf( "\tIRP_FLAG_BURST_WRITE\n" );

    if ( Flags & IRP_FLAG_SEND_ALWAYS )
        printf( "\tIRP_FLAG_SEND_ALWAYS\n" );

    if ( Flags & IRP_FLAG_FREE_RECEIVE_MDL )
        printf( "\tIRP_FLAG_FREE_RECEIVE_MDL\n" );

    if ( Flags & IRP_FLAG_NOT_SYSTEM_PACKET )
        printf( "\tIRP_FLAG_NOT_SYSTEM_PACKET\n" );

    if ( Flags & IRP_FLAG_NOCONNECT )
        printf( "\tIRP_FLAG_NOCONNECT\n" );

    if ( Flags & IRP_FLAG_HAS_CREDENTIAL_LOCK ) 
        printf( "\tIRP_FLAG_HAS_CREDENTIAL_LOCK\n" );

}

VOID
PrintNpFcbFlags(
    ULONG Flags,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
/*++

    Print out the flags that are set in the IRP_CONTEXT flags.

--*/
{

    if ( Flags & FCB_FLAGS_DELETE_ON_CLOSE )
        printf( "\tFCB_FLAGS_DELETE_ON_CLOSE\n" );

    if ( Flags & FCB_FLAGS_TRUNCATE_ON_CLOSE )
        printf( "\tFCB_FLAGS_TRUNCATE_ON_CLOSE\n" );

    if ( Flags & FCB_FLAGS_PAGING_FILE )
        printf( "\tFCB_FLAGS_PAGING_FILE\n" );

    if ( Flags & FCB_FLAGS_PREFIX_INSERTED )
        printf( "\tFCB_FLAGS_PREFIX_INSERTED\n" );

    if ( Flags & FCB_FLAGS_FORCE_MISS_IN_PROGRESS )
        printf( "\tFCB_FLAGS_FORCE_MISS_IN_PROGRESS\n" );

    if ( Flags & FCB_FLAGS_ATTRIBUTES_ARE_VALID )
        printf( "\tFCB_FLAGS_ATTRIBUTES_ARE_VALID\n" );

    if ( Flags & FCB_FLAGS_LONG_NAME )
        printf( "\tFCB_FLAGS_LONG_NAME\n" );
}

LPSTR
PacketToString(
    UINT pt
    )
/*++

Routine Description:

    This helper function converts a PACKET_TYPE to
    a readable text string.

--*/
{

    switch ( pt ) {

        case SAP_BROADCAST:
            return "SAP_BROADCAST";
        case NCP_CONNECT:
            return "NCP_CONNECT";
        case NCP_FUNCTION:
            return "NCP_FUNCTION";
        case NCP_SUBFUNCTION:
            return "NCP_SUBFUNCTION";
        case NCP_DISCONNECT:
            return "NCP_DISCONNECT";
        case NCP_BURST:
            return "NCP_BURST";
        case NCP_ECHO:
            return "NCP_ECHO";
        default:
            return "(packet type unknown)";
    }

}

//
// The internal object functions for the nwdump() routine.
// These functions must receive good pointers; they are
// neither smart, nor exported.
//

VOID
DumpScb(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    BOOL first
    )
/*++

    This function takes the address of the pageable portion
    of an SCB and a pointer to a debugger extension interface
    block.  It prints out the information in the SCB and
    the corresponding non-pageable SCB.

--*/
{
    WCHAR Buffer[64];
    BOOL b;
    SCB Scb;

    //  Read it.

    b = getmem((PVOID)addr, &Scb, sizeof( Scb ), NULL);
    if ( b == 0 ) {
        printf("<could not read the pageable scb>\n");
        return;
    }
    printf( "-----------------------------SCB at %08lx-------------------------------\n", addr );
    printf( "NodeTypeCode             : NW_NTC_SCB\n" );
    printf( "NodeByteSize             : %d\n", Scb.NodeByteSize );
    printf( "pNpScb Addr              : %08lx\n", Scb.pNpScb );
    printf( "Version                  : %d\\%d\n", Scb.MajorVersion, Scb.MinorVersion );
    printf( "VcbList                  : %08lx (LIST_ENTRY, VCB)\n", addr + FIELD_OFFSET( SCB, ScbSpecificVcbQueue ));
    printf( "VcbCount                 : %d\n", Scb.VcbCount );
    printf( "IcbList                  : %08lx (LIST_ENTRY, ICB)\n", addr + FIELD_OFFSET( SCB, IcbList ));
    printf( "IcbCount                 : %d\n", Scb.IcbCount );
    printf( "OpenNdsStreams           : %d\n", Scb.OpenNdsStreams );
    printf( "UserUid                  : %08lx %08lx\n", Scb.UserUid.HighPart, Scb.UserUid.LowPart );
    printf( "OpenFileCount            : %d\n", Scb.OpenFileCount );

    b = GET_STRING( Buffer, Scb.UidServerName );
    if ( b ) {
       printf( "UidServerName            : %ws\n", Buffer );
    } else {
       printf( "UidServerName            : (unreadable)\n");
    }

    b = GET_STRING( Buffer, Scb.NdsTreeName );
    if ( b ) {
        printf( "NDS Tree Name            : %ws\n", Buffer );
    } else {
        printf( "Nds Tree Name            : (none)\n");
    }

    b = GET_STRING( Buffer, Scb.UnicodeUid );

    if ( b ) {
       printf( "UnicodeUid               : %ws\n", Buffer );
    } else {
       printf( "UnicodeUid               : (unreadable)\n");
    }


    b = GET_STRING( Buffer, Scb.UserName );

    if ( b ) {
       printf( "User name                : %ws\n", Buffer );
    } else {
       printf( "User name                : (unreadable)\n" );
    }

    b = GET_STRING( Buffer, Scb.Password );

    if ( b ) {
       printf( "Password                 : %ws\n", Buffer );
    } else {
       printf( "Password                 : (unreadable)\n" );
    }

    printf( "PreferredServer          : %s\n", Scb.PreferredServer ? "TRUE" : "FALSE" );
    printf( "MessageWaiting           : %s\n", Scb.MessageWaiting ? "TRUE" : "FALSE" );
    printf( "AttachCount              : %d\n", Scb.AttachCount);

    // What about the drive map?

    // Dump both parts.
    if ( first )
        DumpScbNp( (DWORD)Scb.pNpScb, lpExtensionApis, FALSE );
    else
        printf( "---------------------------------------------------------------------------\n");

    return;
}

VOID
DumpScbNp(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    BOOL first
    )
/*++

    This function takes the address of the nonpageable
    portion of an SCB and a pointer to a debugger extension
    interface block.  It prints out the information in the
    nonpageable SCB and the corresponding pageable SCB.

--*/
{
    WCHAR Buffer[64];
    BOOL b;
    NONPAGED_SCB NpScb;

    //  Read it.

    b = getmem( (PVOID)addr, &NpScb, sizeof( NpScb ), NULL );
    if ( b == 0 ) {
        printf("<could not read the nonpageable scb>\n");
        return;
    }

    printf( "------------------------Non-Pageable SCB at %08lx-----------------------\n", addr);
    printf( "NodeTypeCode             : NW_NTC_SCBNP\n" );
    printf( "NodeByteSize             : %d\n", NpScb.NodeByteSize );

    b = GET_STRING( Buffer, NpScb.ServerName );
    if ( b ) {
        printf( "ServerName               : %ws\n", Buffer );
    } else {
        printf( "ServerName               : (unreadable)\n" );
    }

    printf( "pScb Addr                : %08lx\n", NpScb.pScb );
    printf( "Reference Count          : %08lx\n", NpScb.Reference );
    printf( "State                    : %s\n", ScbStateToString( NpScb.State ));
    printf( "Last Used Time           : %08lx %08lx\n", NpScb.LastUsedTime.HighPart, NpScb.LastUsedTime.LowPart );
    printf( "Sending                  : %s\n", NpScb.Sending ? "TRUE" : "FALSE" );
    printf( "Receiving                : %s\n", NpScb.Receiving ? "TRUE" : "FALSE" );
    printf( "Ok To Receive            : %s\n", NpScb.OkToReceive ? "TRUE" : "FALSE" );
    printf( "PageAlign                : %s\n", NpScb.PageAlign ? "TRUE" : "FALSE" );
    printf( "Scblinks                 : %08lx (LIST_ENTRY, NPSCB)\n", addr + FIELD_OFFSET( NONPAGED_SCB, ScbLinks ));
    printf( "Requests                 : %08lx (LIST_ENTRY, NPSCB)\n", addr + FIELD_OFFSET( NONPAGED_SCB, Requests ));
    printf( "------------------------------Transport Info-------------------------------\n" );
    printf( "TickCount                : %d\n", NpScb.TickCount );
    printf( "RetryCount               : %d\n", NpScb.RetryCount );
    printf( "Timeout                  : %d\n", NpScb.TimeOut );
    printf( "SequenceNo               : %d\n", NpScb.SequenceNo );
    printf( "ConnectionNo             : %d\n", NpScb.ConnectionNo );
    printf( "ConnectionNoHi           : %d\n", NpScb.ConnectionNoHigh );
    printf( "ConnectionStat           : %d\n", NpScb.ConnectionStatus );
    printf( "MaxTimeOut               : %d\n", NpScb.MaxTimeOut );
    printf( "BufferSize               : %d\n", NpScb.BufferSize );
    printf( "TaskNo                   : %d\n", NpScb.TaskNo );
    printf( "Spin lock                : %s\n", NpScb.NpScbSpinLock == 0 ? "Released" : "Acquired " );
    printf( "LIP Data Speed           : %d\n", NpScb.LipDataSpeed );
    printf( "---------------------------Burst Mode Parameters---------------------------\n");
    printf( "SourceConnId             : %08lx\n", NpScb.SourceConnectionId );
    printf( "DestConnId               : %08lx\n", NpScb.DestinationConnectionId );
    printf( "MaxPacketSize            : %d\n", NpScb.MaxPacketSize );
    printf( "MaxSendSize              : %ld\n", NpScb.MaxSendSize );
    printf( "MaxReceiveSize           : %ld\n", NpScb.MaxReceiveSize );
    printf( "SendBMEnable             : %s\n", NpScb.SendBurstModeEnabled ? "TRUE" : "FALSE" );
    printf( "ReceiveBMEnable          : %s\n", NpScb.ReceiveBurstModeEnabled ? "TRUE" : "FALSE" );
    printf( "BurstSequenceNo          : %d\n", NpScb.BurstSequenceNo );
    printf( "BurstRequestNo           : %d\n", NpScb.BurstRequestNo );
    printf( "BurstSendDelay           : Good %d,\tCurrent %d,\tBad %d\n", NpScb.NwGoodSendDelay, NpScb.NwSendDelay, NpScb.NwBadSendDelay );
    printf( "BurstReceiveDelay        : Good %d,\tCurrent %d,\tBad %d\n", NpScb.NwGoodReceiveDelay, NpScb.NwReceiveDelay, NpScb.NwBadReceiveDelay );
    printf( "BurstSuccessCount        : Send %d, Receive %d\n", NpScb.SendBurstSuccessCount, NpScb.ReceiveBurstSuccessCount );
    printf( "--------------------------Send Delays and Timeouts-------------------------\n" );
    printf( "SendTimeout              : %d\n", NpScb.SendTimeout );
    printf( "TotalWaitTime            : %d\n", NpScb.TotalWaitTime );
    printf( "NwLoopTime               : %d\n", NpScb.NwLoopTime );
    printf( "NwSingleBurst            : %d\n", NpScb.NwSingleBurstPacketTime );
    printf( "NwMaxSendDelay           : %d\n", NpScb.NwMaxSendDelay );
    printf( "NwGoodSendDelay          : %d\n", NpScb.NwGoodSendDelay );
    printf( "NwBadSendDelay           : %d\n", NpScb.NwBadSendDelay );
    printf( "BurstDataWritten         : %d\n", NpScb.BurstDataWritten );
    printf( "NwMaxReceiveDelay        : %d\n", NpScb.NwMaxReceiveDelay );
    printf( "NwReceiveDelay           : %d\n", NpScb.NwReceiveDelay );
    printf( "NwGoodReceiveDelay       : %d\n", NpScb.NwGoodReceiveDelay );
    printf( "NwBadReceiveDelay        : %d\n", NpScb.NwBadReceiveDelay );
    printf( "CurrentBurstDelay        : %d\n", NpScb.CurrentBurstDelay );
    printf( "NtSendDelay              : %08lx %08lx\n", NpScb.NtSendDelay.HighPart, NpScb.NtSendDelay.LowPart );
    printf( "NwNextEventTime          : %08lx %08lx\n", NpScb.NwNextEventTime.HighPart, NpScb.NwNextEventTime.LowPart );

    // Spin locks?  Transport and TDI info?

    // Dump Both Parts.
    if ( first )
        DumpScb( (DWORD)NpScb.pScb, lpExtensionApis, FALSE );
    else
        printf( "---------------------------------------------------------------------------\n" );

    return;
}

VOID
DumpFcb(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    BOOL first
    )
/*++

    This function takes the address of an FCB or DCB and a pointer
    to a debugger extension interface block.  It prints out
    the information in the FCB or DCB.

--*/
{
    WCHAR Buffer[64];
    BOOL b;
    FCB Fcb;

    b = getmem( (PVOID)addr, &Fcb, sizeof( Fcb ), NULL );
    if ( b == 0 ) {
        printf("<could not read the fcb or dcb>\n");
        return;
    }

    if (Fcb.NodeTypeCode == NW_NTC_FCB) {
        printf( "----------------------------FCB at %08lx--------------------------------\n", addr );
        printf( "NodeTypeCode             : NW_NTC_FCB\n" );
    } else {
        printf( "----------------------------DCB at %08lx--------------------------------\n", addr );
        printf( "NodeTypeCode             : NW_NTC_DCB\n" );
    }

    b = GET_STRING( Buffer, Fcb.FullFileName );
    if ( b ) {
        printf( "FullFileName             : %ws\n", Buffer );
    } else {
        printf( "FullFileName             : (unreadable)\n" );
    }

    b = GET_STRING( Buffer, Fcb.RelativeFileName );
    if ( b ) {
        printf( "RelativeFileName         : %ws\n", Buffer );
    } else {
        printf( "RelativeFileName         : (unreadable)\n" );
    }
    printf( "VCB Addr                 : %08lx\n", Fcb.Vcb );
    printf( "SCB Addr                 : %08lx\n", Fcb.Scb );
    printf( "NpFcb Addr               : %08lx\n", Fcb.NonPagedFcb );
    printf( "LastModifiedDate         : %d\n", Fcb.LastModifiedDate );
    printf( "LastModifiedTime         : %d\n", Fcb.LastModifiedTime );
    printf( "CreationDate             : %d\n", Fcb.CreationDate );
    printf( "CreationTime             : %d\n", Fcb.CreationTime );
    printf( "LastAccessDate           : %d\n", Fcb.LastAccessDate );
    printf( "State                    : %d\n", Fcb.State );
    printf( "Flags                    : %d\n", Fcb.Flags );

    // SHARE_ACCESS?

    printf( "FcbListEntry             : %08lx (LIST_ENTRY, FCB)\n", addr + FIELD_OFFSET( FCB, FcbListEntry ));
    printf( "IcbListEntry             : %08lx (LIST_ENTRY, ICB)\n", addr + FIELD_OFFSET( FCB, IcbList ));
    printf( "IcbCount                 : %d\n", Fcb.IcbCount );
    printf( "LastReadOffset           : %d\n", Fcb.LastReadOffset );
    printf( "LastReadSize             : %d\n", Fcb.LastReadSize );

    // Dump both parts.
    if ( first )
        DumpFcbNp( (DWORD)Fcb.NonPagedFcb, lpExtensionApis, FALSE );
    else
        printf( "---------------------------------------------------------------------------\n" );

}

VOID
DumpVcb(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
/*++

    This function takes the address of a VCB and a pointer
    to a debugger extension interface block.  It prints out
    the information in the VCB.

--*/
{
    WCHAR Buffer[64];
    BOOL b;
    VCB Vcb;

    // Read it.

    b = getmem( (PVOID)addr, &Vcb, sizeof( Vcb ), NULL);
    if ( b == 0 ) {
        printf("<could not read the vcb>\n");
        return;
    }

    printf( "------------------------------VCB at %08lx------------------------------\n", addr);
    printf( "NodeTypeCode             : NW_NTC_VCB\n" );
    printf( "NodeByteSize             : %d\n", Vcb.NodeByteSize );
    printf( "Reference Count          : %08lx\n", Vcb.Reference );
    printf( "Last Used Time           : %08lx %08lx\n", Vcb.LastUsedTime.HighPart, Vcb.LastUsedTime.LowPart );
    printf( "GlobalVcbListEntry       : %08lx (LIST_ENTRY, VCB)\n", addr + FIELD_OFFSET( VCB, GlobalVcbListEntry) );
    printf( "SequenceNumber           : %d\n", Vcb.SequenceNumber );

    b = GET_STRING( Buffer, Vcb.Name );
    if ( b ) {
        printf( "VolumeName               : %ws\n", Buffer );
    } else {
        printf( "VolumeName               : (unreadable)\n" );
    }

    b = GET_STRING( Buffer, Vcb.ConnectName );
    if ( b ) {
        printf( "ConnectName              : %ws\n", Buffer );
    } else {
        printf( "ConnectName              : (unreadable)\n" );
    }

    b = GET_STRING( Buffer, Vcb.ShareName );
    if ( b ) {
        printf( "NW ShareName             : %ws\n", Buffer );
    } else {
        printf( "NW ShareName             : (unreadable)\n" );
    }

    if ( !Vcb.Flags & VCB_FLAG_PRINT_QUEUE ) {
        printf( "VolumeNumber             : %d\n", Vcb.Specific.Disk.VolumeNumber );
        printf( "LongNameSpace            : %d\n", Vcb.Specific.Disk.LongNameSpace );
        printf( "Handle                   : %d\n", Vcb.Specific.Disk.Handle );
    } else {
        printf( "QueueId                  : %d\n", Vcb.Specific.Print.QueueId );
    }

    if ( Vcb.DriveLetter != 0) {
        printf( "Drive letter             : %wc:\n", Vcb.DriveLetter );
    } else {
        printf( "Drive letter             : UNC\n" );
    }

    printf( "Scb Addr                 : %08lx\n", Vcb.Scb );
    printf( "VcbListEntry             : %08lx (LIST_ENTRY, VCB)\n", addr + FIELD_OFFSET( VCB, VcbListEntry) );
    printf( "FcbListEntry             : %08lx (LIST_ENTRY, FCB)\n", addr + FIELD_OFFSET(VCB, FcbList) );
    printf( "OpenFileCount            : %d\n", Vcb.OpenFileCount );
    printf( "Flags                    : %08lx\n", Vcb.Flags );
    printf( "---------------------------------------------------------------------------\n");

}

VOID
DumpIcb(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
/*++

    This function takes the address of an ICB and a pointer
    to a debugger extension interface block.  It prints out
    the information in the ICB.

--*/
{
    WCHAR Buffer[64];
    BOOL b, icbscb;
    ICB Icb;
    UINT hb;

    b = getmem( (PVOID)addr, &Icb, sizeof( Icb ), NULL);
    if ( b == 0 ) {
        printf("<could not read the icb>\n");
        return;
    }

    icbscb = (Icb.NodeTypeCode == NW_NTC_ICB_SCB);

    if ( icbscb ) {
       printf( "---------------------------ICB_SCB at %08lx-----------------------------\n", addr );
       printf( "NodeTypeCode             : NW_NTC_ICB_SCB\n" );
    } else {
       printf( "-----------------------------ICB at %08lx-------------------------------\n", addr );
       printf( "NodeTypeCode             : NW_NTC_ICB\n" );
    }

    printf( "NodeByteSize             : %d\n", Icb.NodeByteSize );
    printf( "ListEntry                : %08lx\n", Icb.ListEntry );

    if (icbscb ) {
       printf( "SuperType Addr           : %08lx (SCB)\n", Icb.SuperType.Scb );
    } else {
       printf( "SuperType Addr           : %08lx (FCB)\n", Icb.SuperType.Fcb );
       printf( "NpFcb Addr               : %08lx\n", Icb.NpFcb );
    }

    printf( "State                    : %s\n", IcbStateToString(Icb.State) );
    printf( "HasRemoteHandle          : %s\n", Icb.HasRemoteHandle ? "TRUE" : "FALSE" );

    if ( Icb.HasRemoteHandle ) {
        printf( "Handle                   : " );
        for ( hb = 0; hb < 6; hb++ ) {
            printf( "%c ", (Icb.Handle)[hb]);
        }
        printf( "\n");
    }

    // What abou the PFILE_OBJECT?

    b = GET_STRING( Buffer, Icb.NwQueryTemplate );
    if ( b ) {
        printf( "NwQueryTemplate          : %s\n", Buffer );
    } else {
        printf( "NWQueryTemplate          : (unreadable)\n" );
    }

    b = GET_STRING( Buffer, Icb.UQueryTemplate );
    if ( b ) {
        printf( "UQueryTemplate           : %ws\n", Buffer );
    } else {
        printf( "UQueryTemplate           : (unreadable)\n" );
    }

    printf( "IndexLastIcbRtr          : %d\n", Icb.IndexOfLastIcbReturned );
    printf( "Pid                      : %d\n", Icb.Pid );
    printf( "DotReturned              : %s\n", Icb.DotReturned ? "TRUE" : "FALSE" );
    printf( "DotDotReturned           : %s\n", Icb.DotDotReturned ? "TRUE" : "FALSE" );
    printf( "ReturnedSmthng           : %s\n", Icb.ReturnedSomething ? "TRUE" : "FALSE" );
    printf( "ShortNameSearch          : %s\n", Icb.ShortNameSearch ? "TRUE" : "FALSE" );
    printf( "SearchHandle             : %d\n", Icb.SearchHandle );
    printf( "SearchVolume             : %d\n", Icb.SearchVolume );
    printf( "SearchAttribts           : %d\n", Icb.SearchAttributes );
    printf( "SearchIndexHigh          : %d\n", Icb.SearchIndexHigh );
    printf( "SearchIndexLow           : %d\n", Icb.SearchIndexLow );
    printf( "IsPrintJob               : %s\n", Icb.IsPrintJob ? "TRUE" : "FALSE" );
    printf( "JobId                    : %d\n", Icb.JobId );
    printf( "ActuallyPrinted          : %s\n", Icb.ActuallyPrinted ? "TRUE" : "FALSE" );
    printf( "USetLastAccessTime       : %s\n", Icb.UserSetLastAccessTime ? "TRUE" : "FALSE" );
    printf( "File Position            : %d\n", Icb.FilePosition );
    printf( "File Size                : %d\n", Icb.FileSize );

    printf( "IsTreeHanle              : %s\n", Icb.IsTreeHandle ? "TRUE" : "FALSE" );

    // This needs to be cleaned up!

    printf( "---------------------------------------------------------------------------\n" );

}

VOID
DumpIrpContext(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
{
    BOOL b;
    IRP_CONTEXT IrpContext;

    b = getmem( (PVOID)addr, &IrpContext, sizeof( IrpContext ), NULL );
    if ( b == 0 ) {
        printf( "<could not read the irpcontext>\n" );
        return;
    }

    printf( "--------------------------IRP CONTEXT at %08lx--------------------------\n", addr );
    printf( "NodeTypeCode             : NW_NTC_IRP_CONTEXT\n" );

    // WORK_QUEUE_ITEM?

    printf( "PacketType               : %s\n", PacketToString(IrpContext.PacketType));
    printf( "NpScb Addr               : %08lx\n", IrpContext.pNpScb );
    printf( "Scb Addr                 : %08lx\n", IrpContext.pScb );
    printf( "TdiStruct                : %08lx\n", IrpContext.pTdiStruct );

    // NextRequest?

    printf( "Event                    : %08lx\n", addr + FIELD_OFFSET( IRP_CONTEXT, Event ) );
    printf( "Original IRP             : %08lx\n", IrpContext.pOriginalIrp );
    printf( "Original SB              : %08lx\n", IrpContext.pOriginalSystemBuffer );
    printf( "Original UB              : %08lx\n", IrpContext.pOriginalUserBuffer );
    printf( "Original MDL             : %08lx\n", IrpContext.pOriginalMdlAddress );
    printf( "Receive IRP              : %08lx\n", IrpContext.ReceiveIrp );
    printf( "TxMdl                    : %08lx\n", IrpContext.TxMdl );
    printf( "RxMdl                    : %08lx\n", IrpContext.RxMdl );
    printf( "RunRoutine               : %08lx\n", IrpContext.RunRoutine );
    printf( "pEx                      : %08lx\n", IrpContext.pEx );
    printf( "PostProcessRtn           : %08lx\n", IrpContext.PostProcessRoutine );
    printf( "TimeoutRtn               : %08lx\n", IrpContext.TimeoutRoutine );
    printf( "ComplSendRtn             : %08lx\n", IrpContext.CompletionSendRoutine );
    printf( "pWorkItem                : %08lx\n", IrpContext.pWorkItem );
    printf( "Req Data Addr            : %08lx\n", addr + FIELD_OFFSET( IRP_CONTEXT, req ) );
    printf( "ResponseLength           : %08lx\n", IrpContext.ResponseLength );
    printf( "Rsp Data Addr            : %08lx\n", addr + FIELD_OFFSET( IRP_CONTEXT, rsp ) );
    printf( "Icb Addr                 : %08lx\n", IrpContext.Icb );
    printf( "Specific Data Addr       : %08lx\n", addr + FIELD_OFFSET( IRP_CONTEXT, Specific.Create.FullPathName ) );
    printf( "------------------------------IRP Context Flags----------------------------\n");
    PrintIrpContextFlags(IrpContext.Flags, lpExtensionApis);
    printf( "---------------------------------------------------------------------------\n" );

    return;
}

VOID
DumpFcbNp(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    BOOL first
    )
{
    WCHAR Buffer[64];
    BOOL b;
    NONPAGED_FCB NpFcb;

    b = getmem( (PVOID)addr, &NpFcb, sizeof( NONPAGED_FCB ), NULL);
    if ( !b ) {
        printf( "<could not read the non-pageable fcb>\n" );
        return;
    }

    printf( "--------------------Common NP FCB Header at %08lx-----------------------\n");
    printf( "NodeTypeCode             : NW_NTC_NONPAGED_FCB\n" );
    printf( "NodeByteSize             : %d\n", NpFcb.Header.NodeByteSize );
    printf( "IsFastIoPossible         : %d\n", NpFcb.Header.IsFastIoPossible );

    // Resource? PagingIoResource?

    printf( "AllocationSize           : %08lx %08lx\n", NpFcb.Header.AllocationSize.HighPart, NpFcb.Header.AllocationSize.LowPart );
    printf( "FileSize                 : %08lx %08lx\n", NpFcb.Header.FileSize.HighPart, NpFcb.Header.FileSize.LowPart );
    printf( "ValidDataLength          : %08lx %08lx\n", NpFcb.Header.ValidDataLength.HighPart, NpFcb.Header.ValidDataLength.LowPart );
    printf( "pFcb Addr                : %08lx\n", NpFcb.Fcb );

    // SegmentObject?

    printf( "FileLockList             : %08lx\n", addr + FIELD_OFFSET( NONPAGED_FCB, FileLockList) );
    printf( "PendLockList             : %08lx\n", addr + FIELD_OFFSET( NONPAGED_FCB, PendingLockList) );
    printf( "Resource                 : %08lx\n", addr + FIELD_OFFSET( NONPAGED_FCB, Resource ) );

    printf( "Attributes               : %d\n", NpFcb.Attributes );
    printf( "CacheType                : %d\n", NpFcb.CacheType );
    printf( "CacheBuffer              : %08lx\n", NpFcb.CacheBuffer );
    printf( "CacheMdl                 : %08lx\n", NpFcb.CacheMdl );
    printf( "CacheSize                : %d\n", NpFcb.CacheSize );
    printf( "CacheFileOffset          : %d\n", NpFcb.CacheFileOffset );
    printf( "CacheDataSize            : %d\n", NpFcb.CacheDataSize );
    printf( "----------------------------------FCB Flags--------------------------------\n" );
    PrintNpFcbFlags( NpFcb.Header.Flags, lpExtensionApis );

    // Dump both parts.
    if ( first )
         DumpFcb( (DWORD)NpFcb.Fcb, lpExtensionApis, FALSE );
    else
         printf( "---------------------------------------------------------------------------\n" );

}

VOID
DumpRcb(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
/*++

    This function takes the address of an ICB and a pointer
    to a debugger extension interface block.  It prints out
    the information in the ICB.

--*/
{
    BOOL b;
    RCB Rcb;

    b = getmem( (PVOID)addr, &Rcb, sizeof( RCB ), NULL);
    if ( b == 0 ) {
        printf("<could not read the rcb>\n");
        return;
    }

    printf( "------------------------------------------------------------\n");
    printf( "NodeTypeCode   : NW_NTC_RCB\n");
    printf( "State          : %s\n", RcbStateToString(Rcb.State));
    printf( "OpenCount      : %ul\n", Rcb.OpenCount);
    printf( "ResourceAddr   : %08lx\n", addr + FIELD_OFFSET( RCB, Resource ));
    printf( "ServerListAddr : %08lx\n", addr + FIELD_OFFSET( RCB,
                                                   ServerNameTable ));
    printf( "VolumeListAddr : %08lx\n", addr + FIELD_OFFSET( RCB,
                                                   VolumeNameTable ));
    printf( "FileListAddr   : %08lx\n", addr + FIELD_OFFSET( RCB,
                                                   FileNameTable ));
    printf( "------------------------------------------------------------\n");

}

VOID
DumpPid(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
/*++

    This function takes the address of a PID and a pointer
    to a debugger extension interface block.  It prints out
    the information in the PID.

--*/
{

    printf( "------------------------------------------------------------\n");
    printf( "NodeTypeCode    : NW_NTC_PID\n" );
    printf( "...Not yet implemented...");
    printf( "------------------------------------------------------------\n");

}

VOID
DumpFileLock(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
/*++

    This function takes the address of a file lock and a pointer
    to a debugger extension interface block.  It prints out
    the information in the file lock.

--*/
{

    printf( "------------------------------------------------------------\n" );
    printf( "NodeTypeCode    : NW_NTC_FILE_LOCK\n" );
    printf( "Not yet implemented...\n" );
    printf( "------------------------------------------------------------\n" );

}

VOID
DumpLogon(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
/*++

    This function takes the address of a logon and a pointer
    to a debugger extension interface block.  It prints out
    the information in the logon.

--*/
{
    BOOL b;
    LOGON Logon;
    WCHAR Buffer[64];

    b = getmem( (PVOID)addr, &Logon, sizeof(LOGON), NULL );
    if (!b ) {
        printf( "<unable to read logon>" );
        return;
    }

    printf( "------------------------------------------------------------\n");
    printf( "NodeTypeCode    : NW_NTC_LOGON\n" );
    printf( "NodeByteSize    : %d\n", Logon.NodeByteSize );
    printf( "NextLogon       : %08lx (LOGON LIST_ENTRY)\n", addr +
                                      FIELD_OFFSET( LOGON, Next ));

    b = GET_STRING( Buffer, Logon.UserName );
    if ( b ) {
        printf( "UserName        : %ws\n", Buffer );
    } else {
        printf( "UserName        : <unreadable>\n" );
    }

    b = GET_STRING( Buffer, Logon.PassWord );
    if ( b ) {
        printf( "Password        : %ws\n", Buffer );
    } else {
        printf( "Password        : <unreadable>\n" );
    }

    b = GET_STRING( Buffer, Logon.ServerName );
    if ( b ) {
        printf( "Pref Server     : %ws\n", Buffer );
    } else {
        printf( "Pref Server     : <unreadable>\n" );
    }

    printf( "UserUid         : %08lx %08lx\n", Logon.UserUid.HighPart,
                                               Logon.UserUid.LowPart);

    printf( "CredListResource: %08lx\n", addr +
        FIELD_OFFSET( LOGON, CredentialListResource ));

    printf( "CredentialList  : %08lx (CREDENTIAL LIST_ENTRY)\n", addr +
                                  FIELD_OFFSET( LOGON, NdsCredentialList ));

    printf( "------------------------------------------------------------\n");

}

VOID
DumpCredential(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
/*++

    This function takes the address of an nds credential and a
    pointer to a debugger extension interface block.  It prints
    out the information in the logon.

--*/
{
    BOOL b;
    NDS_SECURITY_CONTEXT Context;
    NDS_CREDENTIAL Credential;
    NDS_SIGNATURE Signature;

    WCHAR Buffer[512];

    CHAR PackBuffer[2048];
    BYTE *packed;
    ULONG packedlen;

    b = getmem( (PVOID)addr, &Context, sizeof(NDS_SECURITY_CONTEXT), NULL );
    if (!b ) {
        printf( "<unable to read context>\n" );
        return;
    }

    printf( "-------- NDS Security Context at 0x%08lx ----------------\n", addr);
    printf( "NodeTypeCode    : NW_NTC_NDS_CREDENTIAL\n" );
    printf( "NodeByteSize    : %d\n", Context.nts );

    printf( "Next            : %08lx (NDS_SECURITY_CONTEXT LIST_ENTRY)\n", addr +
                                  FIELD_OFFSET( NDS_SECURITY_CONTEXT, Next ));


    b = GET_STRING( Buffer, Context.NdsTreeName );
    if ( b ) {
        printf( "Nds Tree Name   : %ws\n", Buffer );
    } else {
        printf( "Nds Tree Name   : <unreadable>\n" );
    }

    b = GET_STRING( Buffer, Context.CurrentContext );
    if ( b ) {
        printf( "Current Context : %ws\n", Buffer );
    } else {
        printf( "Current Context :<unreadable>\n" );
    }

    printf( "Owning Logon    : %08lx\n", Context.pOwningLogon );
    printf( "Handle Count    : %d\n", Context.SupplementalHandleCount );

    if ( Context.Credential != NULL ) {

        printf( "--------------------- Credential Data ----------------------\n");

        b = getmem( (PVOID)Context.Credential, &Credential, sizeof(NDS_CREDENTIAL), NULL );
        if (!b ) {
            printf( "<unable to read credential>\n" );
            goto DO_SIGNATURE;
        }

        printf( "Start validity  : 0x%08lx\n", Credential.validityBegin );
        printf( "End validity    : 0x%08lx\n", Credential.validityEnd );
        printf( "Random          : 0x%08lx\n", Credential.random );
        printf( "Opt data Len    : %d\n", Credential.optDataSize );
        printf( "UserName Len    : %d\n", Credential.userNameLength );

        //
        // Optional data is the first packed data after the struct.
        //

        packedlen = Credential.optDataSize + Credential.userNameLength;
        packed = ((BYTE *)Context.Credential) + sizeof( NDS_CREDENTIAL );

        if ( Credential.optDataSize ) {
            printf( "Opt data addr   : %08lx\n", packed );
        }

        packed += Credential.optDataSize;

        b = getmem( (PVOID)packed, Buffer, Credential.userNameLength, NULL );
        if ( !b ) {
            printf( "<unable to read user name>\n" );
            goto DO_SIGNATURE;
        }
        printf( "Username        : %ws\n", Buffer );

    } else {

       printf( "-------------------- No Credential Data --------------------\n");

    }

DO_SIGNATURE:

    if ( Context.Signature != NULL ) {

        printf( "---------------------- Signature Data ----------------------\n");

        b = getmem( (PVOID)Context.Signature, &Signature, sizeof(NDS_SIGNATURE), NULL );
        if (!b ) {
            printf( "<unable to read signature>\n" );
            goto DO_END;
        }

        printf( "Signature Len   : %d\n", Signature.signDataLength );

        packedlen = Signature.signDataLength;
        packed = ((BYTE *)Context.Signature) + sizeof( NDS_SIGNATURE );

        printf( "Signature addr  : %08lx\n", packed );

    } else {

       printf( "-------------------- No Signature Data ---------------------\n");

    }

DO_END:

    if ( Context.PublicNdsKey != NULL ) {

        printf( "------------------------------------------------------------\n");

        printf( "Public Key Len  : %d\n", Context.PublicKeyLen );
        printf( "Public Key      : %08lx\n", Context.PublicNdsKey );

        printf( "------------------------------------------------------------\n");

    } else {

       printf( "-------------------- No Public Key Data --------------------\n");

    }

}


VOID
DumpMiniIrpContext(
    DWORD addr,
    PNTKD_EXTENSION_APIS lpExtensionApis
    )
/*++

    This function takes the address of a mini irp context
    and a pointer to a debugger extension interface block.
    It prints out the information in the mini irp context.

--*/
{
    BOOL b;
    MINI_IRP_CONTEXT mini;

    b = getmem( (PVOID)addr, &mini, sizeof(MINI_IRP_CONTEXT), NULL );
    if (!b ) {
        printf( "<unable to read mini irp context>\n");
        return;
    }

    printf( "------------------------------------------------------------\n");
    printf( "NodeTypeCode    : NW_NTC_MINI_IRP_CONTEXT\n" );
    printf( "NodeByteSize    : %d\n", mini.NodeByteSize );
    printf( "ListEntry       : %08lx\n", addr + FIELD_OFFSET( MINI_IRP_CONTEXT,
                                                    Next ));
    printf( "IrpContext      : %08lx\n", mini.IrpContext );
    printf( "Irp             : %08lx\n", mini.Irp );
    printf( "Buffer          : %08lx\n", mini.Buffer );
    printf( "Mdl1            : %08lx\n", mini.Mdl1 );
    printf( "Mdl2            : %08lx\n", mini.Mdl2 );
    printf( "------------------------------------------------------------\n");

}

VOID
nwdump(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

Routine Description:

    This function takes the pointer to a structure,
    figures out what the structure is, and calls the
    appropriate dump routine.

Arguments:

    CurrentPc - Supplies the current pc at the time
        the extension is called.

    lpExtensionApis - Supplies the address of the
        functions callable by this extension.

    lpArgumentString - Supplies the address of the structure.

Return Value:

    None.

---*/
{

    DWORD addr;

    //
    // Determine the node type and dispatch.
    //

    addr = getexpr( lpArgumentString );

    switch ( GetNodeType( addr, lpExtensionApis ) ) {

        case NW_NTC_SCB:

            DumpScb(addr, lpExtensionApis, TRUE);
            break;

        case NW_NTC_SCBNP:

            DumpScbNp(addr, lpExtensionApis, TRUE);
            break;

        case NW_NTC_FCB:
        case NW_NTC_DCB:

             DumpFcb(addr, lpExtensionApis, TRUE);
             break;

        case NW_NTC_VCB:

             DumpVcb(addr, lpExtensionApis);
             break;

        case NW_NTC_ICB:
        case NW_NTC_ICB_SCB:

             DumpIcb(addr, lpExtensionApis);
             break;

        case NW_NTC_IRP_CONTEXT:

             DumpIrpContext(addr, lpExtensionApis);
             break;

        case NW_NTC_NONPAGED_FCB:

             DumpFcbNp(addr, lpExtensionApis, TRUE);
             break;

        case NW_NTC_RCB:

             DumpRcb(addr, lpExtensionApis);
             break;

        case NW_NTC_PID:

             DumpPid(addr, lpExtensionApis);
             break;

        case NW_NTC_FILE_LOCK:

             DumpFileLock(addr, lpExtensionApis);
             break;

        case NW_NTC_LOGON:

             DumpLogon(addr, lpExtensionApis);
             break;

        case NW_NTC_MINI_IRP_CONTEXT:

             DumpMiniIrpContext(addr, lpExtensionApis);
             break;

        case NW_NTC_NDS_CREDENTIAL:

             DumpCredential(addr, lpExtensionApis);
             break;

        default:

             printf("(this object does not have a vaid node type)\n");
             break;
    }

}

//
// Other debugger routines.
//

VOID
serverlist(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

Routine Description:

    This function displays a list of servers that the redirector
    is maintaining connections to.  The information is read from
    the SCB queue, not from the server list in the RCB.  The
    argument to this function is ignored.

--*/
{

    DWORD addrScbQueue;
    WCHAR ServerName[64];
    BOOL b;
    PLIST_ENTRY ScbQueueList;
    DWORD addrNpScb, addrScb;
    NONPAGED_SCB NpScb;
    SCB Scb;
    PNTKD_CHECK_CONTROL_C lpCheckControlCRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;

    //
    // Get the address of the server list in the rdr.
    //

    addrScbQueue = getsymaddr("nwrdr!scbqueue");

    if ( addrScbQueue == 0 ) {
        printf("The server list was not locatable.\n");
        return;
        }

    //
    //  Walk the list of servers.
    //

    printf("pNpScb    pScb           Ref  State                    Name\n");
    printf("---------------------------------------------------------------------------\n");

    for ( GET_DWORD( &ScbQueueList, addrScbQueue );
          ScbQueueList != (PLIST_ENTRY)addrScbQueue;
          GET_DWORD( &ScbQueueList, ScbQueueList ) ) {

        if ( lpCheckControlCRoutine() ) {
            printf("<<<User Stop>>>\n");
            break;
        }

        addrNpScb = (DWORD)CONTAINING_RECORD( ScbQueueList, NONPAGED_SCB, ScbLinks );

        printf("%08lx  ", addrNpScb );

        b = (getmem)((LPVOID)addrNpScb,
                             &NpScb,
                             sizeof( NpScb ),
                             NULL);

        if ( b == 0 ) {
            printf("<could not continue>\n");
            return;
        }

        addrScb = (DWORD)NpScb.pScb;
        printf("%08lx  ", addrScb );

        printf("%8lx  ", NpScb.Reference);
        printf("%-25s", ScbStateToString( NpScb.State ) );

        if ( addrScb != 0 ) {
            b = (getmem)((LPVOID)addrScb,
                                 &Scb,
                                 sizeof( Scb ),
                                 NULL);

            if ( b == 0 ) {
                printf("<unreadable>\n");
                continue;
            }

            // Get the server name.

            b = GET_STRING( ServerName, Scb.UidServerName );

            if ( b ) {
                printf( "%ws\n", ServerName );
            } else {
                printf( "Unreadable\n" );
            }
        } else {
            printf( "Permanent SCB\n" );
        }

    }

    printf("---------------------------------------------------------------------------\n");

}

VOID
trace(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

Routine Description:

    This function dumps the nwrdr trace buffer.  Arguments to
    this function are ignored.

To Be Done:

        Read trace buffer size out of nwrdrd and dynamically size.

--*/

{
    ULONG addrDBuffer, addrDBufferPtr, DBufferPtr;
    ULONG BufferSize;
    PCHAR TraceStart, CurrentPtr;
    char buffer[80 + 1];
    char *bptr;
    char *newptr;
    int i;
    int readsize;
    PNTKD_CHECK_CONTROL_C lpCheckControlCRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;

    addrDBuffer = getsymaddr( "nwrdr!dbuffer" );

    if ( !addrDBuffer ) {
        printf("(unable to locate the trace buffer address)\n");
        return;
    } else {
        printf("Address of Dbuffer = %08lx\n", addrDBuffer );
    }

    addrDBufferPtr = getsymaddr( "nwrdr!dbufferptr" );

    if ( !addrDBuffer ) {
        printf("(unable to locate the trace buffer pointer)\n");
        return;
    } else {
        printf("Address of DbufferPtr = %08lx\n", addrDBufferPtr );
    }

    GET_DWORD( &DBufferPtr, addrDBufferPtr );
    printf("DbufferPtr = %08lx\n", DBufferPtr );

    // Set up state variables and loop.

    TraceStart = (char *)addrDBuffer;
    BufferSize = 100*255+1;
    CurrentPtr = (char *)DBufferPtr;

    buffer[80] = '\0';
    newptr = CurrentPtr + 1;
    while ( 1 ) {

        if ( lpCheckControlCRoutine() ) {
            printf("<<<User Stop>>>\n");
            break;
        }

        if ( newptr + 80 > TraceStart+BufferSize ) {
            readsize = TraceStart+BufferSize - newptr;
        } else {
            readsize = 80;
        }

        getmem( newptr, buffer, readsize, NULL );

        bptr = buffer;
        for (i = 0; i<80 ; i++ ) {
            if ( buffer[i] == '\n') {
                buffer[i] = 0;
                printf( "%s\n", bptr );
                bptr = &buffer[i+1];
            }
        }
        printf( "%s", bptr );

        //
        //  If we're back to where we started, break out of here.
        //

        if ( (newptr <= CurrentPtr) &&
             (newptr + readsize) >= CurrentPtr ) {
            break;
        }

        //
        //  Advance the running pointer.
        //

        newptr += readsize;
        if ( newptr >= TraceStart+BufferSize ) {
            newptr = TraceStart;
        }
    }
    printf( "\n");
}

VOID
reftrace(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

Routine Description:

    This function dumps the nwrdr reference trace buffer.

--*/
{
    ULONG addrRBuffer, addrRBufferPtr, RBufferPtr;
    ULONG BufferSize;
    PCHAR TraceStart, CurrentPtr;
    char buffer[80 + 1];
    char *bptr;
    char *newptr;
    int i;
    int readsize;
    PNTKD_CHECK_CONTROL_C lpCheckControlCRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;

    addrRBuffer = getsymaddr( "nwrdr!RBuffer" );

    if ( !addrRBuffer ) {
        printf("(unable to locate the trace buffer address)\n");
        return;
    } else {
        printf("Address of RBuffer = %08lx\n", addrRBuffer );
    }

    addrRBufferPtr = getsymaddr( "nwrdr!RBufferptr" );

    if ( !addrRBuffer ) {
        printf("(unable to locate the trace buffer pointer)\n");
        return;
    } else {
        printf("Address of RBufferPtr = %08lx\n", addrRBufferPtr );
    }

    GET_DWORD( &RBufferPtr, addrRBufferPtr );
    printf("RBufferPtr = %08lx\n", RBufferPtr );

    // Set up state variables and loop.

    TraceStart = (char *)addrRBuffer;
    BufferSize = 100*255+1;
    CurrentPtr = (char *)RBufferPtr;

    buffer[80] = '\0';
    newptr = CurrentPtr + 1;
    while ( 1 ) {

        if ( lpCheckControlCRoutine() ) {
            printf("<<<User Stop>>>\n");
            break;
        }

        if ( newptr + 80 > TraceStart+BufferSize ) {
            readsize = TraceStart+BufferSize - newptr;
        } else {
            readsize = 80;
        }

        getmem( newptr, buffer, readsize, NULL );

        bptr = buffer;
        for (i = 0; i<80 ; i++ ) {
            if ( buffer[i] == '\n') {
                buffer[i] = 0;
                printf( "%s\n", bptr );
                bptr = &buffer[i+1];
            }
        }
        printf( "%s", bptr );

        //
        //  If we're back to where we started, break out of here.
        //

        if ( (newptr <= CurrentPtr) &&
             (newptr + readsize) >= CurrentPtr ) {
            break;
        }

        //
        //  Advance the running pointer.
        //

        newptr += readsize;
        if ( newptr >= TraceStart+BufferSize ) {
            newptr = TraceStart;
        }
    }
    printf( "\n");
}

VOID
logonlist(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

Routine Description:

    This routine prints out the logon list for the rdr.  Arguments
    to this function are ignored.

--*/

{
    DWORD addrLogonList;
    WCHAR Data[64];
    BOOL b;
    PLIST_ENTRY LogonList;
    DWORD addrLogonEntry;
    LOGON Logon;
    PNTKD_CHECK_CONTROL_C lpCheckControlCRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;

    // Get the address of the logon list.

    addrLogonList = getsymaddr( "nwrdr!logonlist" );

    if ( addrLogonList == 0 ) {
        printf("The logon list could not be located.\n");
        return;
        }

    //  Walk the list of servers

    printf("pLogon    User Name      Password       Pref Server    UID\n" );
    printf("---------------------------------------------------------------------------\n" );

    for ( GET_DWORD( &LogonList, addrLogonList );
          LogonList != (PLIST_ENTRY)addrLogonList;
          GET_DWORD( &LogonList, LogonList ) ) {

        if ( lpCheckControlCRoutine() ) {
            printf("<<<User Stop>>>\n");
            break;
        }

        addrLogonEntry = (DWORD)CONTAINING_RECORD( LogonList, LOGON, Next );

        printf("%08lx  ", addrLogonEntry );

        b = (getmem)((LPVOID)addrLogonEntry,
                             &Logon,
                             sizeof( Logon ),
                             NULL);

        if ( b == 0 ) return;

        if ( Logon.NodeTypeCode != NW_NTC_LOGON ) {
            printf( "<invalid node type>\n" );
            return;
        }

        b = GET_STRING( Data, Logon.UserName );

        if ( b ) {
            printf( "%-15ws", Data );
        } else {
            printf( "%-15s", "Unreadable" );
        }

        /*
        b = GET_STRING( Data, Logon.PassWord );

        if ( b ) {
            printf( "%-15ws", Data );
        } else {
            printf( "%-15s", "Unreadable" );
        }
        */
        printf( "%-15s", "<secret>" );

        b = GET_STRING( Data, Logon.ServerName );

        if ( b ) {
            printf( "%-15ws", Data );
        } else {
            printf( "%-15s", "Unreadable" );
        }

        printf( "%08lx:%08x\n", Logon.UserUid.HighPart, Logon.UserUid.LowPart );
    }

    printf("---------------------------------------------------------------------------\n" );

}

//
// Functions that help mangle lists of objects.
//

VOID
vcblist(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

    This function takes a pointer to the pageable portion
    or non-pageable portion of an SCB and dumps the VCB
    list for that SCB.

--*/
{
    BOOL b;
        PVOID objAddr;

    PLIST_ENTRY VcbList;
    DWORD addrVcbList;
    PVCB addrVcb;
    PNTKD_CHECK_CONTROL_C lpCheckControlCRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;

    // Figure out which object we have.
    objAddr = (PVOID)getexpr( lpArgumentString );

    // Invariant: If we leave the switch, objAddr must point to the
    // pageable portion of the SCB that we are interested in.

        switch ( GetNodeType( (DWORD)objAddr, lpExtensionApis ) ) {

        case NW_NTC_SCB:

            break;

        case NW_NTC_SCBNP:

            GET_DWORD( &objAddr,
                ( (PCHAR)objAddr + FIELD_OFFSET( NONPAGED_SCB, pScb ) ) );
            if ( objAddr == 0 ) return;
            break;

        default:

            printf( "(invalid node type code: argument must point to an scb or npscb)\n" );
            return;
    }

    //  Get the head of the vcb list.
    addrVcbList = (DWORD)((PCHAR)objAddr + FIELD_OFFSET( SCB, ScbSpecificVcbQueue ));

    // Walk the list and print.
    for ( GET_DWORD( &VcbList, addrVcbList ) ;
          VcbList != (PLIST_ENTRY)addrVcbList ;
          GET_DWORD( &VcbList, VcbList ) ) {

        if ( lpCheckControlCRoutine() ) {
            printf("<<<User Stop>>>\n");
            break;
        }

        addrVcb = (PVCB)CONTAINING_RECORD( VcbList, VCB, VcbListEntry );
        if( GetNodeType( (DWORD)addrVcb, lpExtensionApis ) != NW_NTC_VCB )
            printf( "(invalid entry in vcb list)\n" );
        else
            DumpVcb( (DWORD)addrVcb, lpExtensionApis );
    }
}

VOID
irplist(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

    This function takes a pointer to the non-pageable portion
    of an SCB and dumps the IRP list for that non-pageable SCB.

--*/
{
    PLIST_ENTRY IrpList;
    DWORD addrIrpList;
    PIRP_CONTEXT addrIrp;

    PVOID objAddr;
    BOOL b;

    PNTKD_CHECK_CONTROL_C lpCheckControlCRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;


    // Figure out which object we have.
    objAddr = (PVOID)getexpr( lpArgumentString );

    // Invariant: If we leave the switch, objAddr must point to the
    // non-pageable portion of the SCB that we are interested in.

        switch ( GetNodeType( (DWORD)objAddr, lpExtensionApis ) ) {

        case NW_NTC_SCB:

            GET_DWORD( &objAddr,
                ( (PCHAR)objAddr + FIELD_OFFSET( SCB, pNpScb ) ) );
            if ( objAddr == 0 ) return;
            break;

        case NW_NTC_SCBNP:

            break;

        default:

            printf( "(invalid node type code: argument must point to an scb or npscb)\n" );
            return;
    }

    // Get the head of the request list.
    addrIrpList = (DWORD)((PCHAR)objAddr + FIELD_OFFSET( NONPAGED_SCB, Requests ));

    // Walk the list and print.
    for ( GET_DWORD( &IrpList, addrIrpList ) ;
          IrpList != (PLIST_ENTRY)addrIrpList ;
          GET_DWORD( &IrpList, IrpList ) ) {

        if ( lpCheckControlCRoutine() ) {
            printf("<<<User Stop>>>\n");
            break;
        }

        addrIrp = (PIRP_CONTEXT)CONTAINING_RECORD( IrpList, IRP_CONTEXT, NextRequest );
        if( GetNodeType( (DWORD)addrIrp, lpExtensionApis ) != NW_NTC_IRP_CONTEXT )
            printf( "(invalid entry in the irp context list)\n" );
        else
            DumpIrpContext( (DWORD)addrIrp, lpExtensionApis );
    }
}

VOID
fcblist(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

    This function takes a pointer to a VCB and dumps
    the FCB list for that VCB.

--*/
{
    PLIST_ENTRY FcbList;
    DWORD addrFcbList;
    PFCB addrFcb;

    NODE_TYPE_CODE ntc;
    PVOID objAddr;
    BOOL b;

    PNTKD_CHECK_CONTROL_C lpCheckControlCRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;

    // Figure out which object we have.
    objAddr = (PVOID)getexpr( lpArgumentString );

        if ( GetNodeType( (DWORD)objAddr, lpExtensionApis ) != NW_NTC_VCB ) {

        printf( "(invalid node type code: argument must point to a vcb)\n" );
        return;
    }

    // Get the head of the fcb list.
    addrFcbList = (DWORD)((PCHAR)objAddr + FIELD_OFFSET( VCB, FcbList ));

    for ( GET_DWORD( &FcbList, addrFcbList ) ;
          FcbList != (PLIST_ENTRY)addrFcbList ;
          GET_DWORD( &FcbList, FcbList ) ) {

        if ( lpCheckControlCRoutine() ) {
            printf("<<<User Stop>>>\n");
            break;
        }

        addrFcb = (PFCB)CONTAINING_RECORD( FcbList, FCB, FcbListEntry );
        ntc = GetNodeType( (DWORD)addrFcb, lpExtensionApis );
        if( (ntc != NW_NTC_FCB) && (ntc != NW_NTC_DCB) )
           printf( "(invalid entry in the fcb list)\n" );
        else
           DumpFcb( (DWORD)addrFcb, lpExtensionApis, TRUE );
    }

}

VOID
icblist(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

    This function takes a pointer to the pageable portion
    of an SCB or FCB and dumps the ICB list for that SCB or FCB.

--*/
{
    PVOID objAddr;
    BOOL b;
    NODE_TYPE_CODE ntc;

    PICB addrIcb;
    PLIST_ENTRY IcbList;
    DWORD addrIcbList, IcbCount;

    PNTKD_CHECK_CONTROL_C lpCheckControlCRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;

    // Figure out which object we have.
    objAddr = (PVOID)getexpr( lpArgumentString );

    // Invariant: If we leave the switch, addrIcbList must point
    // to the head of the ICB list that we are interested in.

        switch ( GetNodeType( (DWORD)objAddr, lpExtensionApis ) ) {

        case NW_NTC_SCB:

            addrIcbList = (DWORD)((PCHAR)objAddr + FIELD_OFFSET( SCB, IcbList ));
            break;

        case NW_NTC_SCBNP:

            // Look up the pageable portion.
            GET_DWORD( &objAddr,
                ( (PCHAR)objAddr + FIELD_OFFSET( NONPAGED_SCB, pScb ) ) );
            if ( objAddr == 0 ) return;
            // Now get it.
            addrIcbList = (DWORD)((PCHAR)objAddr + FIELD_OFFSET( SCB, IcbList));
            break;

        case NW_NTC_FCB:
        case NW_NTC_DCB:

             addrIcbList = (DWORD)((PCHAR)objAddr + FIELD_OFFSET( FCB, IcbList ));
             break;

        case NW_NTC_NONPAGED_FCB:

             // Look up the pageable portion.
             GET_DWORD( &objAddr,
                 ( (PCHAR)objAddr + FIELD_OFFSET( NONPAGED_FCB, Fcb ) ) );
             if (objAddr == 0) return;
             // Now get it.
             addrIcbList = (DWORD)((PCHAR)objAddr + FIELD_OFFSET( FCB, IcbList ));
             break;

        default:

            printf( "(invalid node type: argument must be: scb, npscb, fcb, dcb, or npfcb)\n" );
            return;
    }

    // Walk the list.
    for ( GET_DWORD( &IcbList, addrIcbList ) ;
          IcbList != (PLIST_ENTRY)addrIcbList ;
          GET_DWORD( &IcbList, IcbList ) ) {

        if ( lpCheckControlCRoutine() ) {
            printf("<<<User Stop>>>\n");
            break;
        }

        addrIcb = (PICB)CONTAINING_RECORD( IcbList, ICB, ListEntry );
        ntc = GetNodeType( (DWORD)addrIcb, lpExtensionApis );
        if( (ntc != NW_NTC_ICB) && (ntc != NW_NTC_ICB_SCB) )
            printf( "(invalid entry in icb list)\n" );
        else
            DumpIcb( (DWORD)addrIcb, lpExtensionApis );

    }

}

VOID
credlist(
#ifdef WINDBG
    HANDLE hProcess,
    HANDLE hThread,
#endif
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
/*++

    This function takes a pointer to a LOGON and dumps
    the NDS credential list for that user.

--*/
{
    PLIST_ENTRY CredList;
    DWORD addrCredList;
    PNDS_SECURITY_CONTEXT addrCred;

    NODE_TYPE_CODE ntc;
    PVOID objAddr;
    BOOL b;

    PNTKD_CHECK_CONTROL_C lpCheckControlCRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;

    // Figure out which object we have.
    objAddr = (PVOID)getexpr( lpArgumentString );

        if ( GetNodeType( (DWORD)objAddr, lpExtensionApis ) != NW_NTC_LOGON ) {

        printf( "(invalid node type code: argument must point to a logon)\n" );
        return;
    }

    // Get the head of the fcb list.
    addrCredList = (DWORD)((PCHAR)objAddr + FIELD_OFFSET( LOGON, NdsCredentialList ));

    for ( GET_DWORD( &CredList, addrCredList ) ;
          CredList != (PLIST_ENTRY)addrCredList ;
          GET_DWORD( &CredList, CredList ) ) {

        if ( lpCheckControlCRoutine() ) {
            printf("<<<User Stop>>>\n");
            break;
        }

        addrCred = (PNDS_SECURITY_CONTEXT)
                   CONTAINING_RECORD( CredList,
                                      NDS_SECURITY_CONTEXT,
                                      Next );
        ntc = GetNodeType( (DWORD)addrCred, lpExtensionApis );
        if( (ntc != NW_NTC_NDS_CREDENTIAL ) )
           printf( "(invalid entry in the credential list)\n" );
        else
           DumpCredential( (DWORD)addrCred, lpExtensionApis);
           printf("\n");
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\authpkg.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    authpkg.c

Abstract:

    This module is the NetWare authentication package.  It saves
    credentials in LSA, and notifies the workstation of a logoff.

Author:

    Jim Kelly        (jimk)   11-Mar-1991
    Cliff Van Dyke   (cliffv) 25-Apr-1991

Revision History:

    Rita Wong        (ritaw)   1-Apr-1993    Cloned for NetWare

--*/

#include <string.h>
#include <stdlib.h>

#include <nwclient.h>

#include <ntlsa.h>
#include <nwreg.h>
#include <nwauth.h>

//
// Netware authentication manager credential
//
#define NW_CREDENTIAL_KEY  "NWCS_Credential"

//-------------------------------------------------------------------//
//                                                                   //
// Local functions                                                   //
//                                                                   //
//-------------------------------------------------------------------//

NTSTATUS
AuthpSetCredential(
    IN PLUID LogonId,
    IN LPWSTR UserName,
    IN LPWSTR Password
    );

NTSTATUS
AuthpGetCredential(
    IN PLUID LogonId,
    OUT PNWAUTH_GET_CREDENTIAL_RESPONSE CredBuf
    );

VOID
ApLogonTerminatedSingleUser(IN PLUID LogonId);


VOID
ApLogonTerminatedMultiUser(IN PLUID LogonId);

NTSTATUS
NwAuthGetCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
NwAuthSetCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

PVOID NwAuthHeap;
ULONG NwAuthPackageId;
LSA_DISPATCH_TABLE Lsa;

//
// LsaApCallPackage() function dispatch table
//
PLSA_AP_CALL_PACKAGE
NwCallPackageDispatch[] = {
    NwAuthGetCredential,
    NwAuthSetCredential
    };

//
// Structure of the credential saved in LSA.
//
typedef struct _NWCREDENTIAL {
    LPWSTR UserName;
    LPWSTR Password;
} NWCREDENTIAL, *PNWCREDENTIAL;

//-------------------------------------------------------------------//
//                                                                   //
// Authentication package dispatch routines.                         //
//                                                                   //
//-------------------------------------------------------------------//

NTSTATUS
LsaApInitializePackage (
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PSTRING Database OPTIONAL,
    IN PSTRING Confidentiality OPTIONAL,
    OUT PSTRING *AuthenticationPackageName
    )

/*++

Routine Description:

    This service is called once by the LSA during system initialization to
    provide the DLL a chance to initialize itself.

Arguments:

    AuthenticationPackageId - The ID assigned to the authentication
        package.

    LsaDispatchTable - Provides the address of a table of LSA
        services available to authentication packages.  The services
        of this table are ordered according to the enumerated type
        LSA_DISPATCH_TABLE_API.

    Database - This parameter is not used by this authentication package.

    Confidentiality - This parameter is not used by this authentication
        package.

    AuthenticationPackageName - Receives the name of the
        authentication package.  The authentication package is
        responsible for allocating the buffer that the string is in
        (using the AllocateLsaHeap() service) and returning its
        address here.  The buffer will be deallocated by LSA when it
        is no longer needed.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.


--*/

{

    PSTRING NameString;
    PCHAR NameBuffer;


    UNREFERENCED_PARAMETER(Database);
    UNREFERENCED_PARAMETER(Confidentiality);

    //
    // Use the process heap for memory allocations.
    //
    NwAuthHeap = RtlProcessHeap();


    NwAuthPackageId = AuthenticationPackageId;

    //
    // Copy the LSA service dispatch table
    //
    Lsa.CreateLogonSession     = LsaDispatchTable->CreateLogonSession;
    Lsa.DeleteLogonSession     = LsaDispatchTable->DeleteLogonSession;
    Lsa.AddCredential          = LsaDispatchTable->AddCredential;
    Lsa.GetCredentials         = LsaDispatchTable->GetCredentials;
    Lsa.DeleteCredential       = LsaDispatchTable->DeleteCredential;
    Lsa.AllocateLsaHeap        = LsaDispatchTable->AllocateLsaHeap;
    Lsa.FreeLsaHeap            = LsaDispatchTable->FreeLsaHeap;
    Lsa.AllocateClientBuffer   = LsaDispatchTable->AllocateClientBuffer;
    Lsa.FreeClientBuffer       = LsaDispatchTable->FreeClientBuffer;
    Lsa.CopyToClientBuffer     = LsaDispatchTable->CopyToClientBuffer;
    Lsa.CopyFromClientBuffer   = LsaDispatchTable->CopyFromClientBuffer;

    //
    // Allocate and return our package name
    //
    NameBuffer = (*Lsa.AllocateLsaHeap)(sizeof(NW_AUTH_PACKAGE_NAME));
    strcpy(NameBuffer, NW_AUTH_PACKAGE_NAME);

    NameString = (*Lsa.AllocateLsaHeap)(sizeof(STRING));
    RtlInitString(NameString, NameBuffer);
    (*AuthenticationPackageName) = NameString;

    //
    // Delete outdated credential information in the registry
    //
    NwDeleteInteractiveLogon(NULL);

    (void) NwDeleteServiceLogon(NULL);

    return STATUS_SUCCESS;
}


NTSTATUS
LsaApLogonUser (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority
    )

/*++

Routine Description:

    This routine is used to authenticate a user logon attempt.  This may be
    the user's initial logon, necessary to gain access to NT, or may
    be a subsequent logon attempt.  If the logon is the user's initial
    logon, then a new LSA logon session will be established for the user
    and a PrimaryToken will be returned.  Otherwise, the authentication
    package will associated appropriate credentials with the already logged
    on user's existing LSA logon session.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    LogonType - Identifies the type of logon being attempted.

    ProtocolSubmitBuffer - Supplies the authentication
        information specific to the authentication package.

    ClientBufferBase - Provides the address within the client
        process at which the authentication information was resident.
        This may be necessary to fix-up any pointers within the
        authentication information buffer.

    SubmitBufferSize - Indicates the Size, in bytes,
        of the authentication information buffer.

    ProfileBuffer - Is used to return the address of the profile
        buffer in the client process.  The authentication package is
        responsible for allocating and returning the profile buffer
        within the client process.  However, if the LSA subsequently
        encounters an error which prevents a successful logon, then
        the LSA will take care of deallocating that buffer.  This
        buffer is expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

    ProfileBufferSize - Receives the size (in bytes) of the
        returned profile buffer.

    LogonId - Points to a buffer into which the authentication
        package must return a logon ID that uniquely
        identifies this logon session.

    SubStatus - If the logon failed due to account restrictions, the
        reason for the failure should be returned via this parameter.
        The reason is authentication-package specific.  The substatus
        values for authentication package "MSV1.0" are:

            STATUS_INVALID_LOGON_HOURS

            STATUS_INVALID_WORKSTATION

            STATUS_PASSWORD_EXPIRED

            STATUS_ACCOUNT_DISABLED

    TokenInformationType - If the logon is successful, this field is
        used to indicate what level of information is being returned
        for inclusion in the Token to be created.  This information
        is returned via the TokenInformation parameter.

    TokenInformation - If the logon is successful, this parameter is
        used by the authentication package to return information to
        be included in the token.  The format and content of the
        buffer returned is indicated by the TokenInformationLevel
        return value.

    AccountName - A Unicode string describing the account name
        being logged on to.  This parameter must always be returned
        regardless of the success or failure of the operation.

    AuthenticatingAuthority - A Unicode string describing the Authenticating
        Authority for the logon.  This string may optionally be omitted.

Return Value:

    STATUS_NOT_IMPLEMENTED - NetWare authentication package does not
        support login.

--*/

{
    UNREFERENCED_PARAMETER(ClientRequest);
    UNREFERENCED_PARAMETER(LogonType);
    UNREFERENCED_PARAMETER(ProtocolSubmitBuffer);
    UNREFERENCED_PARAMETER(ClientBufferBase);
    UNREFERENCED_PARAMETER(SubmitBufferSize);
    UNREFERENCED_PARAMETER(ProfileBuffer);
    UNREFERENCED_PARAMETER(ProfileBufferSize);
    UNREFERENCED_PARAMETER(LogonId);
    UNREFERENCED_PARAMETER(SubStatus);
    UNREFERENCED_PARAMETER(TokenInformationType);
    UNREFERENCED_PARAMETER(TokenInformation);
    UNREFERENCED_PARAMETER(AccountName);
    UNREFERENCED_PARAMETER(AuthenticatingAuthority);

    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
LsaApCallPackage (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage().

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    ClientSubmitBufferBase - Supplies the client address of the submitted
        protocol message.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Is used to return the address of the
        protocol buffer in the client process.  The authentication
        package is responsible for allocating and returning the
        protocol buffer within the client process.  This buffer is
        expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned protocol buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

--*/

{

    ULONG MessageType;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(NWAUTH_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType =
        (ULONG) *((PNWAUTH_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(NwCallPackageDispatch)/sizeof(NwCallPackageDispatch[0])) ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    return (*(NwCallPackageDispatch[MessageType]))(
                  ClientRequest,
                  ProtocolSubmitBuffer,
                  ClientBufferBase,
                  SubmitBufferLength,
                  ProtocolReturnBuffer,
                  ReturnBufferLength,
                  ProtocolStatus
                  ) ;
}


VOID
LsaApLogonTerminated (
    IN PLUID LogonId
    )

/*++

Routine Description:

    This routine is used to notify each authentication package when a logon
    session terminates.  A logon session terminates when the last token
    referencing the logon session is deleted.

Arguments:

    LogonId - Is the logon ID that just logged off.

Return Status:

    None.

--*/

{

#if DBG
    IF_DEBUG(LOGON) {
        KdPrint(("\nNWPROVAU: LsaApLogonTerminated\n"));
    }
#endif

    RpcTryExcept {

        //
        // The logon ID may be for a service login
        //
        if (NwDeleteServiceLogon(LogonId) == NO_ERROR) {

            //
            // Tell workstation to log off the service.
            //
            (void) NwrLogoffUser(NULL, LogonId);
            goto Done;
        }
        if (NwDeleteInteractiveLogon( LogonId ) == NO_ERROR ) {

            //
            // Tell workstation to log off the
            // interactive user.
            //
            (void) NwrLogoffUser(NULL, LogonId);
            goto Done;
        }

Done: ;

    }
    RpcExcept(1) {
        //status = NwpMapRpcError(RpcExceptionCode());

    }
    RpcEndExcept
}


NTSTATUS
NwAuthGetCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )
/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of NwAuth_GetCredential.  It is called by
    the NetWare workstation service to get the username and password
    associated with a logon ID.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{
    NTSTATUS Status;

    PNWAUTH_GET_CREDENTIAL_RESPONSE LocalBuf;


    UNREFERENCED_PARAMETER(ClientBufferBase);

    //
    // Ensure the specified Submit Buffer is of reasonable size.
    //
    if (SubmitBufferSize < sizeof(NWAUTH_GET_CREDENTIAL_REQUEST)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate a local buffer and a buffer in client's address space.
    //
    *ReturnBufferSize = sizeof(NWAUTH_GET_CREDENTIAL_RESPONSE);

    LocalBuf = RtlAllocateHeap(NwAuthHeap, 0, *ReturnBufferSize);

    if (LocalBuf == NULL) {
        return STATUS_NO_MEMORY;
    }

    Status = (*Lsa.AllocateClientBuffer)(
                    ClientRequest,
                    *ReturnBufferSize,
                    (PVOID *) ProtocolReturnBuffer
                    );

    if (! NT_SUCCESS( Status )) {
        RtlFreeHeap(NwAuthHeap, 0, LocalBuf);
        return Status;
    }

    //
    // Get the credential from LSA
    //
    Status = AuthpGetCredential(
                 &(((PNWAUTH_GET_CREDENTIAL_REQUEST) ProtocolSubmitBuffer)->LogonId),
                 LocalBuf
                 );

    if (! NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Copy the data to the client's address space.
    //
    Status = (*Lsa.CopyToClientBuffer)(
                ClientRequest,
                *ReturnBufferSize,
                (PVOID) *ProtocolReturnBuffer,
                (PVOID) LocalBuf
                );

Cleanup:

    RtlFreeHeap(NwAuthHeap, 0, LocalBuf);

    //
    // If we weren't successful, free the buffer in the clients address space.
    // Otherwise, the client will free the memory when done.
    //

    if (! NT_SUCCESS(Status)) {

        (VOID) (*Lsa.FreeClientBuffer)(
                    ClientRequest,
                    *ProtocolReturnBuffer
                    );

        *ProtocolReturnBuffer = NULL;
    }

    //
    // Return status to the caller.
    //
    *ProtocolStatus = Status;

    return STATUS_SUCCESS;
}


NTSTATUS
NwAuthSetCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )
/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of NwAuth_SetCredential.  It is called by
    the NetWare credential manager DLL on user logon to save the username
    and password of the logon session.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

--*/

{
    NTSTATUS Status;


    UNREFERENCED_PARAMETER(ClientBufferBase);


    //
    // Ensure the specified Submit Buffer is of reasonable size.
    //
    if (SubmitBufferSize < sizeof(NWAUTH_SET_CREDENTIAL_REQUEST)) {
        return STATUS_INVALID_PARAMETER;
    }

#if DBG
    IF_DEBUG(LOGON) {
        KdPrint(("NwAuthSetCredential: LogonId %08lx%08lx Username %ws\n",
                 ((PNWAUTH_SET_CREDENTIAL_REQUEST) ProtocolSubmitBuffer)->LogonId.HighPart,
                 ((PNWAUTH_SET_CREDENTIAL_REQUEST) ProtocolSubmitBuffer)->LogonId.LowPart,
                 ((PNWAUTH_SET_CREDENTIAL_REQUEST) ProtocolSubmitBuffer)->UserName
                 ));
    }
#endif

    //
    // Set the credential in LSA
    //
    Status = AuthpSetCredential(
                 &(((PNWAUTH_SET_CREDENTIAL_REQUEST) ProtocolSubmitBuffer)->LogonId),
                 ((PNWAUTH_SET_CREDENTIAL_REQUEST) ProtocolSubmitBuffer)->UserName,
                 ((PNWAUTH_SET_CREDENTIAL_REQUEST) ProtocolSubmitBuffer)->Password
                 );

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


NTSTATUS
AuthpGetCredential(
    IN PLUID LogonId,
    OUT PNWAUTH_GET_CREDENTIAL_RESPONSE CredBuf
    )
/*++

Routine Description:

    This routine retrieves the credential saved in LSA given the
    logon ID.

Arguments:

    LogonId - Supplies the logon ID for the logon session.

    CredBuf - Buffer to receive the credential.

Return Value:


--*/
{
    NTSTATUS Status;

    STRING KeyString;
    STRING CredString;
    ULONG QueryContext = 0;
    ULONG KeyLength;

    PNWCREDENTIAL Credential;


    RtlInitString(&KeyString, NW_CREDENTIAL_KEY);

    Status = (*Lsa.GetCredentials)(
                  LogonId,
                  NwAuthPackageId,
                  &QueryContext,
                  (BOOLEAN) FALSE,  // Just retrieve matching key
                  &KeyString,
                  &KeyLength,
                  &CredString
                  );

    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    Credential = (PNWCREDENTIAL) CredString.Buffer;

#if DBG
    IF_DEBUG(LOGON) {
        KdPrint(("AuthpGetCredential: Got CredentialSize %lu\n", CredString.Length));
    }
#endif

    //
    // Make the pointers absolute.
    //
    Credential->UserName = (LPWSTR) ((DWORD_PTR) Credential->UserName +
                                     (DWORD_PTR) Credential);
    Credential->Password = (LPWSTR) ((DWORD_PTR) Credential->Password +
                                     (DWORD_PTR) Credential);

    wcscpy(CredBuf->UserName, Credential->UserName);
    wcscpy(CredBuf->Password, Credential->Password);

    return STATUS_SUCCESS;
}


NTSTATUS
AuthpSetCredential(
    IN PLUID LogonId,
    IN LPWSTR UserName,
    IN LPWSTR Password
    )
/*++

Routine Description:

    This routine saves the credential in LSA.

Arguments:

    LogonId - Supplies the logon ID for the logon session.

    UserName, Password - Credential for the logon session.

Return Value:


--*/
{
    NTSTATUS Status;
    PNWCREDENTIAL Credential;
    DWORD CredentialSize;

    STRING CredString;
    STRING KeyString;


    //
    // Allocate memory to package the credential.
    //
    CredentialSize = sizeof(NWCREDENTIAL) +
                     (wcslen(UserName) + wcslen(Password) + 2) *
                          sizeof(WCHAR);

#if DBG
    IF_DEBUG(LOGON) {
        KdPrint(("AuthpSetCredential: CredentialSize is %lu\n", CredentialSize));
    }
#endif
    Credential = RtlAllocateHeap(NwAuthHeap, 0, CredentialSize);

    if (Credential == NULL) {
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory(Credential, CredentialSize);

    //
    // Pack the credential
    //
    Credential->UserName = (LPWSTR) (((DWORD_PTR) Credential) + sizeof(NWCREDENTIAL));
    wcscpy(Credential->UserName, UserName);

    Credential->Password = (LPWSTR) ((DWORD_PTR) Credential->UserName +
                                     (wcslen(UserName) + 1) * sizeof(WCHAR));
    wcscpy(Credential->Password, Password);

    //
    // Make the pointers self-relative.
    //
    Credential->UserName = (LPWSTR) ((DWORD_PTR) Credential->UserName -
                                     (DWORD_PTR) Credential);
    Credential->Password = (LPWSTR) ((DWORD_PTR) Credential->Password -
                                     (DWORD_PTR) Credential);

    //
    // Add credential to logon session
    //
    RtlInitString(&KeyString, NW_CREDENTIAL_KEY);

    CredString.Buffer = (PCHAR) Credential;
    CredString.Length = (USHORT) CredentialSize;
    CredString.MaximumLength = (USHORT) CredentialSize;

    Status = (*Lsa.AddCredential)(
                   LogonId,
                   NwAuthPackageId,
                   &KeyString,
                   &CredString
                   );

    if (! NT_SUCCESS(Status)) {
        KdPrint(( "NWPROVAU: AuthpSetCredential: error from AddCredential %lX\n",
                  Status));
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\drawpie.h ===
#ifdef __cplusplus
extern "C" {
#endif

int NEAR IntSqrt(unsigned long dwNum);

#define DP_USEDCOLOR  0
#define DP_FREECOLOR  1
#define DP_USEDSHADOW 2
#define DP_FREESHADOW 3

VOID NEAR DrawPie(HDC hDC, LPCRECT prcItem, UINT uPctX10, BOOL TrueZr100,
		  UINT uOffset, const COLORREF FAR *lpColors);

#ifdef __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\drawpie.c ===
#include <windows.h>
#include "drawpie.h"

#ifdef  WIN32
#define MoveTo(_hdc,_x,_y) MoveToEx(_hdc, _x, _y, NULL)
#endif  // WIN32


int NEAR IntSqrt(unsigned long dwNum)
{
    // We will keep shifting dwNum left and look at the top two bits.

    // initialize sqrt and remainder to 0.
    DWORD dwSqrt = 0, dwRemain = 0, dwTry;
    int i;

    // We iterate 16 times, once for each pair of bits.
    for (i=0; i<16; ++i)
    {
        // Mask off the top two bits of dwNum and rotate them into the
        // bottom of the remainder
        dwRemain = (dwRemain<<2) | (dwNum>>30);

        // Now we shift the sqrt left; next we'll determine whether the
        // new bit is a 1 or a 0.
        dwSqrt <<= 1;

        // This is where we double what we already have, and try a 1 in
        // the lowest bit.
        dwTry = dwSqrt*2 + 1;

        if (dwRemain >= dwTry)
        {
            // The remainder was big enough, so subtract dwTry from
            // the remainder and tack a 1 onto the sqrt.
            dwRemain -= dwTry;
            dwSqrt |= 0x01;
        }

        // Shift dwNum to the left by 2 so we can work on the next few
        // bits.
        dwNum <<= 2;
    }

    return(dwSqrt);
}



VOID NEAR DrawPie(HDC hDC, LPCRECT lprcItem, UINT uPctX10, BOOL TrueZr100,
          UINT uOffset, const COLORREF FAR *lpColors)
{
    int cx, cy, rx, ry, x, y;
    int uQPctX10;
    RECT rcItem;
    HRGN hEllRect = NULL;
    HRGN hEllipticRgn = NULL;
    HRGN hRectRgn = NULL;
    HBRUSH hBrush = NULL;
    HBRUSH hOldBrush;
    HPEN hPen = NULL;
    HPEN hOldPen = NULL;

    rcItem = *lprcItem;
    rcItem.left = lprcItem->left;
    rcItem.top = lprcItem->top;
    rcItem.right = lprcItem->right - rcItem.left;
    rcItem.bottom = lprcItem->bottom - rcItem.top - uOffset;

    rx = rcItem.right / 2;
    cx = rcItem.left + rx;
    ry = rcItem.bottom / 2;
    cy = rcItem.top + ry;
    if (rx<=10 || ry<=10)
    {
        return;
    }

    rcItem.right = rcItem.left+2*rx;
    rcItem.bottom = rcItem.top+2*ry;

    if (uPctX10 > 1000)
    {
        uPctX10 = 1000;
    }

    /* Translate to first quadrant of a Cartesian system
    */
    uQPctX10 = (uPctX10 % 500) - 250;
    if (uQPctX10 < 0)
    {
        uQPctX10 = -uQPctX10;
    }

    /* Calc x and y.  I am trying to make the area be the right percentage.
    ** I don't know how to calculate the area of a pie slice exactly, so I
    ** approximate it by using the triangle area instead.
    */
    if (uQPctX10 < 120)
    {
        x = IntSqrt(((DWORD)rx*(DWORD)rx*(DWORD)uQPctX10*(DWORD)uQPctX10)
            /((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

        y = IntSqrt(((DWORD)rx*(DWORD)rx-(DWORD)x*(DWORD)x)*(DWORD)ry*(DWORD)ry/((DWORD)rx*(DWORD)rx));
    }
    else
    {
        y = IntSqrt((DWORD)ry*(DWORD)ry*(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)
            /((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

        x = IntSqrt(((DWORD)ry*(DWORD)ry-(DWORD)y*(DWORD)y)*(DWORD)rx*(DWORD)rx/((DWORD)ry*(DWORD)ry));
    }

    /* Switch on the actual quadrant
    */
    switch (uPctX10 / 250)
    {
    case 1:
        y = -y;
        break;

    case 2:
        break;

    case 3:
        x = -x;
        break;

    default: // case 0 and case 4
        x = -x;
        y = -y;
        break;
    }

    /* Now adjust for the center.
    */
    x += cx;
    y += cy;

    /* Draw the shadows using regions (to reduce flicker).
    */
    hEllipticRgn = CreateEllipticRgnIndirect(&rcItem);
    if (hEllipticRgn == NULL) {
        goto Cleanup;
    }
    OffsetRgn(hEllipticRgn, 0, uOffset);
    hEllRect = CreateRectRgn(rcItem.left, cy, rcItem.right, cy+uOffset);
    if (hEllRect == NULL) {
        goto Cleanup;
    }
    hRectRgn = CreateRectRgn(0, 0, 0, 0);
    if (hRectRgn == NULL) {
        goto Cleanup;
    }
    CombineRgn(hRectRgn, hEllipticRgn, hEllRect, RGN_OR);
    OffsetRgn(hEllipticRgn, 0, -(int)uOffset);
    CombineRgn(hEllRect, hRectRgn, hEllipticRgn, RGN_DIFF);

    /* Always draw the whole area in the free shadow/
    */
    hBrush = CreateSolidBrush(lpColors[DP_FREESHADOW]);
    if (hBrush)
    {
        FillRgn(hDC, hEllRect, hBrush);
        DeleteObject(hBrush);
        hBrush = NULL;
    }

    /* Draw the used shadow only if the disk is at least half used.
    */
    if (uPctX10>500 && (hBrush=CreateSolidBrush(lpColors[DP_USEDSHADOW]))!=NULL)
    {
        DeleteObject(hRectRgn);
        hRectRgn = CreateRectRgn(x, cy, rcItem.right, lprcItem->bottom);
        if (hRectRgn == NULL) {
            goto Cleanup;
        }
        CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
        FillRgn(hDC, hEllipticRgn, hBrush);
        DeleteObject(hBrush);
        hBrush = NULL;
    }

    hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    if (hPen == NULL) {
        goto Cleanup;
    }
    hOldPen = SelectObject(hDC, hPen);

    if((uPctX10 < 100) && (cy == y))
    {
        hBrush = CreateSolidBrush(lpColors[DP_FREECOLOR]);
        if (hBrush == NULL) {
            goto Cleanup;
        }
        hOldBrush = SelectObject(hDC, hBrush);
        if((TrueZr100 == FALSE) || (uPctX10 != 0))
        {
        Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
            rcItem.left, cy, x, y);
        }
        else
        {
        Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right,
                 rcItem.bottom);
        }
    }
    else if((uPctX10 > (1000 - 100)) && (cy == y))
    {
        hBrush = CreateSolidBrush(lpColors[DP_USEDCOLOR]);
        if (hBrush == NULL) {
            goto Cleanup;
        }
        hOldBrush = SelectObject(hDC, hBrush);
        if((TrueZr100 == FALSE) || (uPctX10 != 1000))
        {
        Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
            rcItem.left, cy, x, y);
        }
        else
        {
        Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right,
                 rcItem.bottom);
        }
    }
    else
    {
        hBrush = CreateSolidBrush(lpColors[DP_USEDCOLOR]);
        if (hBrush == NULL) {
            goto Cleanup;
        }
        hOldBrush = SelectObject(hDC, hBrush);

        Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom);
        SelectObject(hDC, hOldBrush);
        DeleteObject(hBrush);
        hBrush = NULL;

        hBrush = CreateSolidBrush(lpColors[DP_FREECOLOR]);
        if (hBrush == NULL) {
            goto Cleanup;
        }
        hOldBrush = SelectObject(hDC, hBrush);
        Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
            rcItem.left, cy, x, y);
    }
    SelectObject(hDC, hOldBrush);
    DeleteObject(hBrush);
    hBrush = NULL;

    /* Do not draw the lines if the %age is truely 0 or 100 (completely
    ** empty disk or completly full disk)
    */
    if((TrueZr100 == FALSE) || ((uPctX10 != 0) && (uPctX10 != 1000)))
    {
        Arc(hDC, rcItem.left, rcItem.top+uOffset, rcItem.right, rcItem.bottom+uOffset,
            rcItem.left, cy+uOffset, rcItem.right, cy+uOffset-1);
        MoveTo(hDC, rcItem.left, cy);
        LineTo(hDC, rcItem.left, cy+uOffset);
        MoveTo(hDC, rcItem.right-1, cy);
        LineTo(hDC, rcItem.right-1, cy+uOffset);

        if (uPctX10 > 500)
        {
            MoveTo(hDC, x, y);
            LineTo(hDC, x, y+uOffset);
        }
    }
    SelectObject(hDC, hOldPen);

Cleanup:

    if (hRectRgn) {
        DeleteObject(hRectRgn);
    }
    if (hEllipticRgn) {
        DeleteObject(hEllipticRgn);
    }
    if (hEllRect) {
        DeleteObject(hEllRect);
    }
    if (hPen) {
        DeleteObject(hPen);
    }
    if (hBrush) {
        DeleteObject(hBrush);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\caddress.c ===
/*++
Copyright (c) 1994  Microsoft Corporation

Module Name:

    address.c

Abstract:

    This module contains the code to support NPGetAddressByName.

Author:

    Yi-Hsin Sung (yihsins)    18-Apr-94

Revision History:

    yihsins      Created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include "ncp.h"
#include <wsipx.h>
#include <ws2spi.h>
#include <nwxchg.h>
#include <ntddnwfs.h>
#include <rpc.h>
#include <rpcdce.h>
#include "rnrdefs.h"
#include "sapcmn.h"
#include <time.h>
#include <rnraddrs.h>


//-------------------------------------------------------------------//
//                                                                   //
// Special Externs
//                                                                   //
//-------------------------------------------------------------------//

NTSTATUS
NwOpenAServer(
    PWCHAR pwszServName,
    PHANDLE ServerHandle,
    BOOL    fVerify
   );


//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

#define IPX_ADDRESS_LENGTH          12
#define MAX_PROPERTY_BUFFER_LENGTH  128

DWORD
NwrpGetAddressByNameInner(
    IN HANDLE      hServer,
    IN WORD        nServiceType,
    IN LPWSTR      lpServiceName,
    IN BOOL        fAnsi,
    IN OUT LPSOCKADDR_IPX lpSockAddr,
    OUT PDWORD     pdwVersion
    );


BOOL
NwConvertToUnicode(
    OUT LPWSTR *UnicodeOut,
    IN LPSTR  OemIn
    );

DWORD
NwMapBinderyCompletionCode(
    IN NTSTATUS ntstatus
    );

#if 0
DWORD
NwpFetchClassType(
        HANDLE    hServer,
        PUNICODE_STRING pUString,
        PBYTE     pbBuffer
    );
#endif

DWORD
NwppGetClassInfo(
    IN     PWCHAR  pwszServerName,
    IN     LPWSTR  lpszServiceClassName,
    IN     LPGUID  lpServiceClassType,
    OUT    PLONG   plSpare,
    OUT    PDWORD  pdwClassInfos,
    OUT    LPGUID  lpFoundType,
    OUT    PWCHAR  *ppwszFoundName,
    IN     LONG    lSpace,
    OUT    PBYTE   pbBuffer
    );     

BOOL
NwpEnumClassInfoServers(
     IN OUT   PHANDLE    phServ,
     IN OUT   PLONG      plIndex,
     IN       PWCHAR     pwszServerName,
     IN       BOOL       fVerify
    );

#if 0

DWORD
NwppSetClassInfo(
    IN        LPWSTR     pwszClassInfoName,
    IN        LPGUID     lpClassType,
    IN        PCHAR      pbProperty,
    IN        LPWSTR     pwszServerName
    );

#endif

DWORD
NwpCreateAndWriteProperty(
     IN       HANDLE     hServer,
     IN       LPSTR      lpszPropertyName,
     IN       PUNICODE_STRING pusObjectName,
     IN       WORD       ObjectType,
     IN       PCHAR      pbPropertyBuffer
    );

//-------------------------------------------------------------------//
//                                                                   //
// Function Bodies                                                   //
//                                                                   //
//-------------------------------------------------------------------//


DWORD
NwpGetHandleForServer(
    PWCHAR pwszServerName,
    PHANDLE  phServer,
    BOOL    fVerify
    )
/*++
Routine Description:
   Find a handle to use, or make one. This calls into device.c to do the
   real work.
--*/
{
    DWORD err = NO_ERROR;

    if(!*phServer)
    {       
        if(!pwszServerName)
        {
            pwszServerName = NW_RDR_PREFERRED_SUFFIX;
        }


        err = NwOpenAServer(pwszServerName, phServer, fVerify);
    }
    return(err);
}


DWORD
NwpGetRnRAddress(
    IN OUT PHANDLE phServer,
    IN LPWSTR     lpszContext,
    IN OUT PLONG plIndex,
    IN LPWSTR lpServiceName,
    IN WORD  nType,
    OUT PDWORD  pdwVersion,
    DWORD  dwInSize,
    OUT LPWSTR ServiceName,
    OUT LPSOCKADDR_IPX lpSockAddr
    )
/*++
Routine Description:
    Called to get the name and address of the next item of nType type.
    If a name is supplied as well, then there is no enumeration. This is
    called from NSPLookupServiceNext and the parameters are close analogs
    of the ones it receives. 
--*/
{
    NTSTATUS ntstatus;
    CHAR     szObjectName[48];    
    DWORD    err = NO_ERROR;
    PWCHAR    pwszObjectName;
    PWCHAR   pwszConv;
    BOOL     fAll, fAnsi;

    //
    // Open a server for enumeration and querying
    //

    err = NwpGetHandleForServer(lpszContext, phServer, FALSE);
    if(err == NO_ERROR)
    {
        if(!lpServiceName)
        {
            lpServiceName = L"*";
        }           
        if(wcschr(lpServiceName, L'*'))
        {
            WORD ObjectType;
            //
            // we've no name, or we have an enumeration
            //

            UNICODE_STRING U;

            RtlInitUnicodeString(&U, lpServiceName);

            ntstatus = NwlibMakeNcp(
                          *phServer,
                          FSCTL_NWR_NCP_E3H,
                          58,
                          59,
                          "bdwU|dwc",
                          0x37,
                          *plIndex,
                          nType,
                          &U,
                          plIndex,
                          &ObjectType,
                          &szObjectName);                     

            if(NT_SUCCESS(ntstatus))
            {

                //
                // got another one.
                //

                //
                // got another one. Convert the name
                //

                if(!NwConvertToUnicode(&pwszConv, szObjectName))
                {
                    //
                    // out of space ...
                    //

                    err = WN_NO_MORE_ENTRIES;
                }

                fAll = TRUE;

                if(nType == OT_DIRSERVER)
                {
                    //
                    // looking for DIRSERVERs is tricky and requires
                    // preserving the name intact. This includes some
                    // binary cruft, so special case it.
                    //
                    fAnsi = TRUE;
                    pwszObjectName = (PWCHAR)szObjectName;
                }
                else
                {
                    fAnsi = FALSE;
                    pwszObjectName = pwszConv;
                }
            }
        }
        else
        {
            //
            // a non-enumerattion name was given. Use it
            //

            fAnsi = FALSE;
            pwszConv = pwszObjectName = lpServiceName;
            fAll = FALSE;
            ntstatus = 0;
        }
        
        if((err == NO_ERROR)
               &&
           NT_SUCCESS(ntstatus))
        {
            //
            // we've a name and type to lookup. Call the old RnR
            // serice routine to do it. First, return the name.
            // But return the name first

            DWORD dwLen;

            if(fAnsi)
            {
                //
                // it's an NDS tree server. Have to munge the name
                // a bit
                //

                PWCHAR pwszTemp = &pwszConv[31];

                while(*pwszTemp == L'_')
                {
                    pwszTemp--;
                }
                dwLen = (DWORD) ((PCHAR)pwszTemp - (PCHAR)pwszConv + sizeof(WCHAR));
            }
            else
            {
                dwLen = wcslen(pwszConv) * sizeof(WCHAR);
            }

            dwLen = min(dwInSize, dwLen);
 
            RtlCopyMemory(ServiceName, pwszConv, dwLen);

            memset(((PBYTE)ServiceName) + dwLen,
                   0,
                   dwInSize - dwLen);

            err = NwrpGetAddressByNameInner(
                        *phServer,
                        nType,
                        pwszObjectName,
                        fAnsi,
                        lpSockAddr,
                        pdwVersion);

            if(fAll)
            {
                LocalFree(pwszConv);
            }
        }
    }
    if(err == NO_ERROR)
    {
        err = NwMapBinderyCompletionCode(ntstatus);
    }
    return(err);
}

DWORD
NwpGetAddressByName(
    IN LPWSTR      Reserved,
    IN WORD        nServiceType,
    IN LPWSTR      lpServiceName,
    IN OUT LPSOCKADDR_IPX lpSockAddr
    )
/*++

Routine Description:

    This routine returns address information about a specific service.

Arguments:

    Reserved - unused

    nServiceType - netware service type

    lpServiceName - unique string representing the service name, in the
        Netware case, this is the server name

    lpSockAddr - on return, will be filled with SOCKADDR_IPX

Return Value:

    Win32 error.

--*/
{
    
    NTSTATUS ntstatus;
    HANDLE   hServer = 0;
    DWORD    err;

    UNREFERENCED_PARAMETER( Reserved );

    err = NwpGetHandleForServer( 0, &hServer, FALSE );

    if ( err == ERROR_PATH_NOT_FOUND )
        err = ERROR_SERVICE_NOT_ACTIVE;

    if (err == NO_ERROR)
    {
        err = NwrpGetAddressByNameInner(
                        hServer,
                        nServiceType,
                        lpServiceName,
                        FALSE,
                        lpSockAddr,
                        0);
        CloseHandle(hServer);
    }

    return(err);
} 

DWORD
NwrpGetAddressByNameInner(
    IN HANDLE      hServer,
    IN WORD        nServiceType,
    IN LPWSTR      lpServiceName,
    IN BOOL        fAnsi,
    IN OUT LPSOCKADDR_IPX lpSockAddr,
    OUT PDWORD     pdwVersion
    )
/*++

Routine Description:

    This routine returns address information about a specific service.

Arguments:

    Reserved - unused

    nServiceType - netware service type

    lpServiceName - unique string representing the service name, in the
        Netware case, this is the server name

    lpSockAddr - on return, will be filled with SOCKADDR_IPX

    fAnsi -- the input name is in ASCII. This happens only when looking
             for a DIRSERVER.

Return Value:

    Win32 error.

--*/
{
    
    NTSTATUS ntstatus;
    UNICODE_STRING UServiceName;
    STRING   PropertyName;
    BYTE     PropertyValueBuffer[MAX_PROPERTY_BUFFER_LENGTH];
    BYTE     fMoreSegments;
    PCHAR    pszFormat;



    //
    // Send an ncp to find the address of the given service name
    //
    RtlInitString( &PropertyName, "NET_ADDRESS" );
    if(!fAnsi)
    {
        RtlInitUnicodeString( &UServiceName, lpServiceName );
        pszFormat = "bwUbp|rb";

        ntstatus = NwlibMakeNcp(
                       hServer,
                       FSCTL_NWR_NCP_E3H,      // Bindery function
                       72,                     // Max request packet size
                       132,                    // Max response packet size
                       pszFormat,              // Format string
                       0x3D,                   // Read Property Value
                       nServiceType,           // Object Type
                       &UServiceName,          // Object Name
                       1,                      // Segment Number
                       PropertyName.Buffer,    // Property Name
                       PropertyValueBuffer,    // Ignore
                       MAX_PROPERTY_BUFFER_LENGTH,  // size of buffer
                       &fMoreSegments          // TRUE if there are more 
                                               // 128-byte segments
                       );

        if ( NT_SUCCESS( ntstatus))
        {
            //
            // IPX address should fit into the first 128 byte
            // 
            ASSERT( !fMoreSegments );
        
            //
            // Fill in the return buffer
            //
            lpSockAddr->sa_family = AF_IPX;

            RtlCopyMemory( lpSockAddr->sa_netnum,
                           PropertyValueBuffer,
                           IPX_ADDRESS_LENGTH );

            if(pdwVersion)
            {
                //
                // the caller wants the version as well. Get it
                //
                RtlInitString( &PropertyName, "VERSION" );
                ntstatus = NwlibMakeNcp(
                            hServer,
                           FSCTL_NWR_NCP_E3H,      // Bindery function
                           72,                     // Max request packet size
                           132,                    // Max response packet size
                           pszFormat,             // Format string
                           0x3D,                   // Read Property Value
                           nServiceType,           // Object Type
                           &UServiceName,          // Object Name
                           1,                      // Segment Number
                           PropertyName.Buffer,    // Property Name
                           PropertyValueBuffer,    // Ignore
                           MAX_PROPERTY_BUFFER_LENGTH,  // size of buffer
                           &fMoreSegments          // TRUE if there are more 
                                                   // 128-byte segments
                           );
                if(NT_SUCCESS(ntstatus))
                {
                    //
                    // have a version
                    //

                    *pdwVersion = *(PDWORD)PropertyValueBuffer;
                }
                else
                {
                    ntstatus = STATUS_SUCCESS;
                    *pdwVersion = 0;
                }
            }
        }
    }
    else
    {
        //
        // exact match needed
        //

        pszFormat = "bwbrbp|rb";

        ntstatus = NwlibMakeNcp(
                       hServer,
                       FSCTL_NWR_NCP_E3H,      // Bindery function
                       66,                     // Max request packet size
                       132,                    // Max response packet size
                       pszFormat,              // Format string
                       0x3D,                   // Read Property Value
                       nServiceType,           // Object Type
                       48,
                       lpServiceName,          // Object Name
                       48,
                       1,                      // Segment Number
                       PropertyName.Buffer,    // Property Name
                       PropertyValueBuffer,    // Ignore
                       MAX_PROPERTY_BUFFER_LENGTH,  // size of buffer
                       &fMoreSegments          // TRUE if there are more 
                                               // 128-byte segments
                       );

        if ( NT_SUCCESS( ntstatus))
        {
            //
            // IPX address should fit into the first 128 byte
            // 
            ASSERT( !fMoreSegments );
        
            //
            // Fill in the return buffer
            //
            lpSockAddr->sa_family = AF_IPX;

            RtlCopyMemory( lpSockAddr->sa_netnum,
                           PropertyValueBuffer,
                           IPX_ADDRESS_LENGTH );

            if(pdwVersion)
            {
                //
                // the caller wants the version as well. Get it
                //
                RtlInitString( &PropertyName, "VERSION" );
                ntstatus = NwlibMakeNcp(
                            hServer,
                           FSCTL_NWR_NCP_E3H,      // Bindery function
                           66,                     // Max request packet size
                           132,                    // Max response packet size
                           pszFormat,             // Format string
                           0x3D,                   // Read Property Value
                           nServiceType,           // Object Type
                           48,
                           lpServiceName,          // Object Name
                           48,
                           1,                      // Segment Number
                           PropertyName.Buffer,    // Property Name
                           PropertyValueBuffer,    // Ignore
                           MAX_PROPERTY_BUFFER_LENGTH,  // size of buffer
                           &fMoreSegments          // TRUE if there are more 
                                                   // 128-byte segments
                           );
                if(NT_SUCCESS(ntstatus))
                {
                    //
                    // have a version
                    //

                    *pdwVersion = *(PDWORD)PropertyValueBuffer;
                }
                else
                {
                    ntstatus = STATUS_SUCCESS;
                    *pdwVersion = 0;
                }
            }
        }
            
    }
    return NwMapBinderyCompletionCode(ntstatus);
} 

#if 0
DWORD
NwpSetClassInfo(
    IN     LPWSTR  lpszServiceClassName,
    IN     LPGUID  lpServiceClassType,
    IN     PCHAR   lpbProperty
    )
{
    WCHAR    wszServerName[48];
    LONG     lIndex = -1;
    BOOL     fFoundOne = FALSE;
    HANDLE   hServer = 0;

    while(NwpEnumClassInfoServers( &hServer, &lIndex, wszServerName, FALSE))
    {
        DWORD Status =  NwppSetClassInfo(
                                   lpszServiceClassName,
                                   lpServiceClassType,
                                   lpbProperty,
                                   wszServerName);

        if(Status == NO_ERROR)
        {
            fFoundOne = TRUE;
        }
    }
    if(fFoundOne)
    {
        return(NO_ERROR);
    }
    return(NO_DATA);
}

DWORD
NwppSetClassInfo(
    IN        LPWSTR     pwszClassInfoName,
    IN        LPGUID     lpClassType,
    IN        PCHAR      pbProperty,
    IN        LPWSTR     pwszServerName
    )
{
/*++
Routine Description:
    Inner routine for SetClassInfo. This is called for each class info
    server and attempts to create and populate the object
--*/
    HANDLE hServer = 0;
    DWORD err;
    UNICODE_STRING UString;
    WCHAR wszProp[48];
    DWORD dwLen = wcslen(pwszClassInfoName);
    PWCHAR pszProp;
    NTSTATUS Status;

    UuidToString(lpClassType, &pszProp);

    memset(wszProp, 0, sizeof(wszProp));

    dwLen = min(sizeof(wszProp) - sizeof(WCHAR), dwLen);

    RtlMoveMemory(wszProp, pwszClassInfoName, dwLen);

    RtlInitUnicodeString(&UString, pszProp);

    err = NwpGetHandleForServer(pwszServerName, &hServer, TRUE);
    if(err == NO_ERROR)
    {

        Status = NwlibMakeNcp(
                   hServer,
                   FSCTL_NWR_NCP_E3H,
                   56,
                   2,
                   "bbbwU|",
                   0x32,                    // create
                   0,                       // static
                   0x20,                    // security
                   RNRCLASSSAPTYPE,         // type
                   &UString);

        if(!NT_SUCCESS(Status)
                 &&
           ((Status & 0xff) != 0xEE))
        {
            err = NO_DATA;                 // can't do it here
        }
        else
        {
            
            //
            // create and write each property
            //


            err = NwpCreateAndWriteProperty(
                         hServer,
                         RNRTYPE,         // property name
                         &UString,        // object name
                         RNRCLASSSAPTYPE,    // object type
                         (PCHAR)pwszClassInfoName);

           err = NwpCreateAndWriteProperty(
                         hServer,
                         RNRCLASSES,
                         &UString,
                         RNRCLASSSAPTYPE,  // object type
                         pbProperty);     // and this one too
        }
    }
    if(hServer)
    {
        CloseHandle(hServer);
    }

    RpcStringFree(&pszProp);

    return(err);
}

DWORD
NwpGetClassInfo(
    IN     LPWSTR  lpszServiceClassName,
    IN     LPGUID  lpServiceClassType,
    OUT    PLONG   plSpare,
    OUT    PDWORD  pdwClassInfos,
    OUT    LPGUID  lpFoundType,
    OUT    PWCHAR  *ppwszFoundName,
    IN     LONG    lSpace,
    OUT    PBYTE   pbBuffer
    )     
{
/*++
Routine Description:
   Wrapper for the routine below. This comes up with the server name
   and decides whether to enumerate servers

--*/

    HANDLE hServer = 0;
    DWORD err;
    NTSTATUS ntstatus;
    LONG lIndex = -1;
    HANDLE hServ = 0;
    WCHAR wszObjectName[48];

    while(NwpEnumClassInfoServers(&hServer, &lIndex, wszObjectName, FALSE))
    {
        WORD ObjectType;
        PWCHAR pwszName;
    

        err = NwppGetClassInfo(
                         wszObjectName,
                         lpszServiceClassName,
                         lpServiceClassType,
                         plSpare,
                         pdwClassInfos,
                         lpFoundType,
                         ppwszFoundName,
                         lSpace,
                         pbBuffer);
        if((err == NO_ERROR)
                ||
           (err == WSAEFAULT))
        {
            CloseHandle(hServer);
            break;
        }
    }
    return(err);
}    

BOOL
NwpEnumClassInfoServers(
    IN OUT  PHANDLE   phServer,
    IN OUT  PLONG     plIndex,
    OUT     PWCHAR    pwszServerName,
    IN      BOOL      fVerify)
{
/*++
Routine Description:
    Common routine to enumerate Class Info servers. Nothing fancy just
    a way to issue the NCP
--*/
    WORD ObjectType;
    PWCHAR pwszName;
    NTSTATUS Status;
    CHAR szObjectName[48];
    BOOL fRet;
    DWORD err;
    
    err = NwpGetHandleForServer(0, phServer, fVerify);
    if(err == NO_ERROR)
    {
        Status = NwlibMakeNcp(
                      *phServer,
                      FSCTL_NWR_NCP_E3H,
                      58,
                      59,
                      "bdwp|dwc",
                      0x37,
                      *plIndex,
                      CLASSINFOSAPID,
                      "*",
                      plIndex,
                      &ObjectType,
                      &szObjectName);
        if(!NT_SUCCESS(Status))
        {
            err = NwMapBinderyCompletionCode(Status);
        }
        else if(!NwConvertToUnicode(&pwszName, szObjectName))
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            wcscpy(pwszServerName, pwszName);
            LocalFree(pwszName);
        }
    }
    if(err != NO_ERROR)
    {
        fRet = FALSE;
        if(*phServer)
        {
            CloseHandle(*phServer);
            *phServer = 0;
        }
    }
    else
    {
        fRet = TRUE;
    }
    return(fRet);
}

DWORD
NwppGetClassInfo(
    IN     PWCHAR  pwszServerName,
    IN     LPWSTR  lpszServiceClassName,
    IN     LPGUID  lpServiceClassType,
    OUT    PLONG   plSpare,
    OUT    PDWORD  pdwClassInfos,
    OUT    LPGUID  lpFoundType,
    OUT    PWCHAR  *ppwszFoundName,
    IN     LONG    lSpace,
    OUT    PBYTE   pbBuffer
    )     
{
/*++
Routine Description
    Find and return the class info information for the given Class.
    The general methodology is to look up the object
    in the registry, pull out the RnR property, pack what is read into
    Class Info structures, and voila! 
Arguments:
    lpServiceClassName       the class name
    lpServiceClassType       the class type
    plSpare                  Space needed if no class infos returned
    pdwClassInfos            Number of class infos returned
    lSpace                   the space available on input
    pbBuffer                 the scratch are for building this


This was originally an RPC method and the general structure has been preserved
in case we want to revert to using RPC once again.
--*/

    DWORD err = NO_ERROR;
    BYTE PropertyValueBuffer[MAX_PROPERTY_BUFFER_LENGTH];   // max segment size
    STRING PropertyName;
    UNICODE_STRING UString;
    OEM_STRING OString;
    LPWSANSCLASSINFOW pci = (LPWSANSCLASSINFO)pbBuffer;
    LONG lFreeSpace = lSpace;
    PBYTE pbFreeSpace = (PBYTE)((LONG)pbBuffer + lFreeSpace);
    BYTE fMoreSegments;
    HANDLE hServer = 0;
    NTSTATUS ntstatus;
    PWCHAR pwszName;

    UuidToString(lpServiceClassType, &pwszName);

    *pdwClassInfos = 0;
    *plSpare = 0;              // no space needed yet.
    err = NwpGetHandleForServer(pwszServerName, &hServer, FALSE);

    if(err == NO_ERROR)
    {
        DWORD Segment;
        PBINDERYCLASSES pbc = (PBINDERYCLASSES)PropertyValueBuffer;
        DWORD dwTotalSize;
        DWORD dwSS;

        //
        // init the Class Info stuff
        //

        //
        // pwszName is the name of the object we want to use. We must
        // fetch all of the Class Info stuff to return. 
        // 
        //

        RtlInitUnicodeString(&UString, pwszName);

        RtlMoveMemory(lpFoundType,
                      lpServiceClassType,
                      sizeof(GUID));

        RtlInitString(&PropertyName, RNRCLASSES);   // where the data is
        for(Segment = 1;; Segment++)
        {
            ntstatus = NwlibMakeNcp(
                       hServer,
                       FSCTL_NWR_NCP_E3H,      // Bindery function
                       72,                     // Max request packet size
                       132,                    // Max response packet size
                       "bwUbp|rb",             // Format string
                       0x3D,                   // Read Property Value
                       RNRCLASSSAPTYPE,        // Object Type
                       &UString,               // Object Name
                       (BYTE)Segment,
                       PropertyName.Buffer,    // Property Name
                       PropertyValueBuffer,    // Ignore
                       MAX_PROPERTY_BUFFER_LENGTH,  // size of buffer
                       &fMoreSegments          // TRUE if there are more 
                                           // 128-byte segments
                       );
            if(!NT_SUCCESS(ntstatus))
            {    
                break;
            }
            //
            // got another value. Stuff it in if it fits. In all
            // cases, compute the space needed.
            //

            
            if((pbc->bType != BT_WORD)
                     &&
               (pbc->bType != BT_DWORD))
            {
                //
                // Don't know what to do with these ...
                //

                err = WSAEPFNOSUPPORT;
                break;
            }
            
            dwSS = (DWORD)pbc->bSizeOfString;
            dwTotalSize = (DWORD)pbc->bSizeOfType +
                          ((dwSS + 1) * sizeof(WCHAR)) +
                          sizeof(DWORD) - 1;

            dwTotalSize &= ~(sizeof(DWORD) - 1);
            *plSpare += (LONG)dwTotalSize + sizeof(WSANSCLASSINFO);  // running total

            lFreeSpace -= (LONG)dwTotalSize + sizeof(WSANSCLASSINFO);
            if(lFreeSpace >= 0)
            {
                PBYTE pbString;
                PCHAR pbData =  (PCHAR)((PCHAR)pbc +
                                        (DWORD)pbc->bOffset);
                BYTE bRnRName[128];
                PWCHAR pwszRnR;

                //
                // it fits. Pack it in
                //

                pbFreeSpace = (PBYTE)((DWORD)pbFreeSpace - dwTotalSize);
                *pdwClassInfos += 1;             // one more class info.
                pci->dwNameSpace = (DWORD)ntohs(pbc->wNameSpace);
                pci->dwValueType = REG_DWORD;
                pci->dwValueSize = (DWORD)pbc->bSizeOfType;
                pci->lpValue = (PVOID)(pbFreeSpace - pbBuffer);
                pci->lpszName = (PWCHAR)((PBYTE)pci->lpValue +
                                             pci->dwValueSize);
                pci->dwConnectionFlags = (DWORD)pbc->bFlags;
                pci++;

                //
                // now copy the values.
                //
 

                if(pbc->bType == BT_WORD)
                {
                    *(PWORD)pbFreeSpace = ntohs(*(PWORD)pbData);
                    pbString = (PBYTE)((DWORD)pbFreeSpace + sizeof(WORD));
                    pbData = pbData + sizeof(WORD);
                }
                else
                {
                    *(PDWORD)pbFreeSpace = ntohl(*(PDWORD)pbData);
                    pbString = (PBYTE)((DWORD)pbFreeSpace + sizeof(DWORD));
                    pbData = pbData + sizeof(DWORD);
                }

                //
                // the name is in ASCII, and not null terminated.
                //

                RtlMoveMemory(bRnRName, pbData, dwSS);
                bRnRName[dwSS] = 0;
                if(!NwConvertToUnicode(&pwszRnR, bRnRName))
                {
                    //
                    // bad news. Out of space.
                    //

                    err = GetLastError();
                    break;
                }
              
                RtlMoveMemory(pbString,
                              pwszRnR,
                              (dwSS + 1) * sizeof(WCHAR)); 
                LocalFree(pwszRnR);

             }
        }
        if(err == NO_ERROR)
        {
            if(!*ppwszFoundName)
            {
                LONG lLen;

                //
                // need to return the name
                //

                err = NwpFetchClassType(hServer,
                                        &UString,
                                        PropertyValueBuffer);

                if(err == NO_ERROR)
                {
                    lLen = (wcslen((PWCHAR)PropertyValueBuffer) + 1) *
                                  sizeof(WCHAR);

                    lFreeSpace -= lLen;
                    *plSpare += lLen;

                    if(lFreeSpace >= 0)
                    {
                        //
                        // it fits. Move it

                        pbFreeSpace = (PBYTE)((DWORD)pbFreeSpace - lLen);
                        RtlMoveMemory(pbFreeSpace, PropertyValueBuffer, lLen);
                        *ppwszFoundName = (PWCHAR)(pbFreeSpace - pbBuffer);
                    }
                    if(lFreeSpace < 0)
                    {
                        err = WSAEFAULT;
                    }
                }
            }
        }
        else if(*pdwClassInfos == 0)
        {
            err = NO_DATA;
        }
    }

    CloseHandle(hServer);
    RpcStringFree(&pwszName);
    return(err);
}

DWORD
NwpFetchClassType(
        HANDLE    hServer,
        PUNICODE_STRING pUString,
        PBYTE     pbBuffer)
{
/*++
Routine Description
    Common routine to read the class type buffer.
--*/
    BYTE fMoreSegments;
    STRING PropertyName;
    NTSTATUS ntstatus;
   
    RtlInitString(&PropertyName, RNRTYPE);   // where the GUID is

    ntstatus = NwlibMakeNcp(
           hServer,
           FSCTL_NWR_NCP_E3H,      // Bindery function
           72,                     // Max request packet size
           132,                    // Max response packet size
           "bwUbp|rb",             // Format string
           0x3D,                   // Read Property Value
           RNRCLASSSAPTYPE,        // Object Type
           pUString,               // Object Name
           1,                      // Segment Number
           PropertyName.Buffer,    // Property Name
           pbBuffer,
           MAX_PROPERTY_BUFFER_LENGTH,  // size of buffer
           &fMoreSegments          // TRUE if there are more 
                                           // 128-byte segments
                   );

    if(!NT_SUCCESS(ntstatus))
    {
        return(WSASERVICE_NOT_FOUND);
    }
    return(NO_ERROR);
}

#endif
DWORD
NwpCreateAndWriteProperty(
     IN       HANDLE     hServer,
     IN       LPSTR      lpszPropertyName,
     IN       PUNICODE_STRING pusObjectName,
     IN       WORD       wObjectType,
     IN       PCHAR      pbPropertyBuffer
    )
{
/*++
Routine Description:
    Create the named property and write the data.
Arguments:

     hServer:         handle to the server
     lpszPropertyName Name of the property
     pusObjectName    Name of the object
     wObjectType      Type of the object
     pbPropertyBuffer The property data. Must be 128 bytes

Note that the return is always NO_ERROR for now. This may change in the future.
--*/    
    NTSTATUS Status;

    Status = NwlibMakeNcp(
                 hServer,
                 FSCTL_NWR_NCP_E3H,
                 73,
                 2,
                 "bwUbbp|",
                 0x39,               // create property
                 wObjectType,
                 pusObjectName,
                 0,                 // static/item
                 0x20,              // security
                 lpszPropertyName
               );

    //
    // Now write the porperty data
    //
    Status = NwlibMakeNcp(
                 hServer,
                 FSCTL_NWR_NCP_E3H,
                 201,
                 2,
                 "bwUbbpr|",
                 0x3E,                  // write property
                 wObjectType,
                 pusObjectName,
                 1,                     // one segment
                 0,
                 lpszPropertyName,
                 pbPropertyBuffer, 128); 

    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\ccache.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ccache.c

Abstract:

    This module contains the code to keep a cache of the user
    credentials. The cache is used mainly for a user browsing from
    winfile. 

Author:

    Chuck Y Chan (chuckc)    4-Dec-93

Revision History:

    chuckc      Created

--*/

#include <nwclient.h>
#include <nwcanon.h>
#include <nwapi.h>

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
ExtractServerName(
    IN  LPWSTR RemoteName, 
    OUT LPWSTR ServerName,
    IN  DWORD  ServerNameSize
) ;

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

static WCHAR CachedPassword[NW_MAX_PASSWORD_LEN+1] ;
static WCHAR CachedUserName[NW_MAX_USERNAME_LEN+1] ;
static WCHAR CachedServerName[NW_MAX_SERVER_LEN+1] ;
static DWORD CachedCredentialsTime ; 
static UNICODE_STRING CachedPasswordUnicodeStr ;
static UCHAR EncodeSeed = 0 ;

//-------------------------------------------------------------------//
//                                                                   //
// Function Bodies                                                   //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
NwpCacheCredentials(
    IN LPWSTR RemoteName,
    IN LPWSTR UserName,
    IN LPWSTR Password
    )
/*++

Routine Description:

    This function caches the user credentials for the particular
    server. 

Arguments:

    RemoteName - path containg the server we are accessing. only the
                 server component is of interest.

    UserName - user name to remember 

    Password - password to remember

Return Value:

    NO_ERROR - Successfully cached the credentials

    Win32 error code otherwise.

--*/
{
    DWORD status ; 

    //
    // various paramter checks
    //
    if (!RemoteName || !UserName || !Password)
    {
        status = ERROR_INVALID_PARAMETER ;
        goto ExitPoint ;
    }

    if (wcslen(UserName) >= sizeof(CachedUserName)/sizeof(CachedUserName[0]))
    {
        status = ERROR_INVALID_PARAMETER ;
        goto ExitPoint ;
    }

    if (wcslen(Password) >= sizeof(CachedPassword)/sizeof(CachedPassword[0]))
    {
        status = ERROR_INVALID_PARAMETER ;
        goto ExitPoint ;
    }

    //
    // extract the server portion of the path
    //
    status = ExtractServerName(
                 RemoteName,
                 CachedServerName,
                 sizeof(CachedServerName)/sizeof(CachedServerName[0])) ;

    if (status != NO_ERROR)
    {
        goto ExitPoint ;
    }

    //
    // save away the credentials
    //
    wcscpy(CachedUserName, UserName) ;
    wcscpy(CachedPassword, Password) ;

    //
    // encode it since it is in page pool
    //
    RtlInitUnicodeString(&CachedPasswordUnicodeStr, CachedPassword) ;
    RtlRunEncodeUnicodeString(&EncodeSeed, &CachedPasswordUnicodeStr) ;

    //
    // mark the time this happened
    //
    CachedCredentialsTime = GetTickCount() ;
   
    return NO_ERROR ;

ExitPoint:
  
    CachedServerName[0] = 0 ;
    return status ;
}

    
BOOL 
NwpRetrieveCachedCredentials(
    IN  LPWSTR RemoteName,
    OUT LPWSTR *UserName,
    OUT LPWSTR *Password
    )
/*++

Routine Description:

    This function retrieves the cached user credentials for the particular
    server. 

Arguments:

    RemoteName - path containg the server we are accessing. only the
                 server component is of interest.

    UserName - used to return user name 

    Password - used to return password 

Return Value:

    NO_ERROR - Successfully returned at least one entry.

    Win32 error code otherwise.

--*/
{
    DWORD status ; 
    DWORD CurrentTime ;
    WCHAR ServerName[NW_MAX_SERVER_LEN+1] ;

    *UserName = NULL ;
    *Password = NULL ;
    CurrentTime = GetTickCount() ; 
   
    if (!RemoteName)
    {
        return FALSE ;
    }

    //
    // if too old, bag out
    //
    if (((CurrentTime > CachedCredentialsTime) && 
         (CurrentTime - CachedCredentialsTime) > 60000) ||
        ((CurrentTime < CachedCredentialsTime) && 
         (CurrentTime + (MAXULONG - CachedCredentialsTime)) >= 60000))
    {
        CachedServerName[0] = 0 ; // reset to nothing
        return FALSE ;
    }

    status = ExtractServerName(
                 RemoteName,
                 ServerName,
                 sizeof(ServerName)/sizeof(ServerName[0])) ;

    if (status != NO_ERROR)
    {
        return FALSE ;
    }

    //
    // if dont compare, bag out
    //
    if (_wcsicmp(ServerName, CachedServerName) != 0)
    {
        return FALSE ;
    }

    //
    // allocate memory to return data
    //
    if (!(*UserName = (LPWSTR) LocalAlloc(
                          LPTR, 
                          (wcslen(CachedUserName)+1) * sizeof(WCHAR))))
    {
        return FALSE ;
    }
    
    if (!(*Password = (LPWSTR) LocalAlloc(
                          LPTR, 
                          (wcslen(CachedPassword)+1) * sizeof(WCHAR))))
    {
        LocalFree((HLOCAL)*UserName) ;
        *UserName = NULL ;
        return FALSE ;
    }
    
    //
    // decode the string,copy it and then reencode it 
    //
    RtlRunDecodeUnicodeString(EncodeSeed, &CachedPasswordUnicodeStr) ;
    wcscpy(*Password, CachedPassword) ;
    RtlRunEncodeUnicodeString(&EncodeSeed, &CachedPasswordUnicodeStr) ;

    wcscpy(*UserName, CachedUserName) ;

    //
    // update the tick count
    //
    CachedCredentialsTime = GetTickCount() ;
    return TRUE ;
}


DWORD
ExtractServerName(
    IN  LPWSTR RemoteName, 
    OUT LPWSTR ServerName,
    IN  DWORD  ServerNameSize
) 
/*++

Routine Description:

    This function extracts the server name out of a remote name

Arguments:

    RemoteName - the input string to extract the server name from.

    ServerName - the return buffer for the server string
 
    ServerNameSize - size o f buffer in chars 

Return Value:

    NO_ERROR - Successfully cached the credentials

    Win32 error code otherwise.

--*/
{
    LPWSTR ServerStart ;
    LPWSTR ServerEnd ;

    //
    // skip initial backslashes, then find next one delimiting the server name
    //
    ServerStart = RemoteName ;

    while (*ServerStart == L'\\')
        ServerStart++ ;
  
    ServerEnd = wcschr(ServerStart, L'\\') ;
    if (ServerEnd)
        *ServerEnd = 0 ;

    //
    // make sure we can fit
    //
    if (wcslen(ServerStart) >= ServerNameSize)
    {
        if (ServerEnd)
            *ServerEnd = L'\\' ;
        return ERROR_INVALID_PARAMETER ;
    }

    //
    // copy and restore the backslash
    //
    wcscpy(ServerName, ServerStart) ;

    if (ServerEnd)
        *ServerEnd = L'\\' ;

    return NO_ERROR ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\gtadrnr.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gtsadrnr.c

Abstract:

    This module contains the code to support the new RnR APIs. Some
    support code is in getaddr.c, but the interface routines and
    routines specific to RnR2 are herein.

Author:

    ArnoldM      4-Dec-1995
Revision History:

    ArnoldM      Created

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "ncp.h"
#include <rpc.h>
#include <winsock2.h>
#include <ws2spi.h>
#include <wsipx.h>
#include <rnrdefs.h>
#include <svcguid.h>
#include <rnraddrs.h>


//-------------------------------------------------------------------//
//                                                                   //
// Globals in getaddr.c and provider .c                              //
//                                                                   //
//-------------------------------------------------------------------//

GUID HostAddrByInetStringGuid = SVCID_INET_HOSTADDRBYINETSTRING;
GUID ServiceByNameGuid = SVCID_INET_SERVICEBYNAME;
GUID HostAddrByNameGuid = SVCID_INET_HOSTADDRBYNAME;
GUID HostNameGuid = SVCID_HOSTNAME;

DWORD
NwpGetAddressByName(
    IN    LPWSTR  Reserved,
    IN    WORD    nServiceType,
    IN    LPWSTR  lpServiceName,
    IN OUT LPSOCKADDR_IPX  lpsockaddr
);

DWORD
NwpGetAddressViaSap(
    IN WORD        nServiceType,
    IN LPWSTR      lpServiceName,
    IN DWORD       nProt,
    IN OUT LPVOID  lpCsAddrBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN HANDLE      hCancellationEvent,
    OUT LPDWORD    lpcAddress
);

DWORD
NwpRnR2AddServiceType(
    IN  LPWSTR   lpServiceTypeName,
    IN  LPGUID   lpClassType,
    IN  WORD     wSapId,
    IN  WORD     wPort
);

BOOL
NwpRnR2RemoveServiceType(
    IN  LPGUID   lpServiceType
);

DWORD
SapFreeSapSocket(
    SOCKET s
    );

PSAP_RNR_CONTEXT
SapMakeContext
    (
       IN HANDLE Handle,
       DWORD     dwExcess
    );

BOOL
NwpLookupSapInRegistry(
    IN  LPGUID    lpServiceType,
    OUT PWORD     pnSapType,
    OUT PWORD     pwPort,
    IN OUT PDWORD pfConnectionOriented
);

PSAP_RNR_CONTEXT
SapGetContext(
    HANDLE h
    );

DWORD
DoASap(
    IN PSAP_RNR_CONTEXT psrcContext,
    IN WORD QueryType,
    IN PBYTE * ppData,
    IN LPWSAQUERYSETW lpqsResults,
    IN PLONG   pl,
    IN PDWORD  pdw
    );

VOID
SapReleaseContext(
    IN PSAP_RNR_CONTEXT psrcContext
    );

DWORD
SapGetSapSocket(
    SOCKET * ps
    );

DWORD
PrepareForSap(
    IN PSAP_RNR_CONTEXT psrc
    );

DWORD
SapGetSapForType(
    PSAP_BCAST_CONTROL psbc,
    WORD               nServiceType
    );

DWORD
FillBufferWithCsAddr(
    IN LPBYTE       pAddress,
    IN DWORD        nProt,
    IN OUT LPVOID   lpCsAddrBuffer,
    IN OUT LPDWORD  lpdwBufferLength,
    OUT LPDWORD     pcAddress
    );

DWORD
pSapSetService2(
    IN DWORD dwOperation,
    IN LPWSTR lpszServiceInstanceName,
    IN PBYTE  pbAddress,
    IN LPGUID pServiceType,
    IN WORD nServiceType
    );

DWORD
NwpGetRnRAddress(
         PHANDLE phServer,
         PWCHAR  pwszContext,
         PLONG   plIndex,
         LPWSTR  lpServiceName,
         WORD    nServiceType,
         PDWORD  pdwVersion,
         DWORD   dwInSize,
         LPWSTR  OutName,
         SOCKADDR_IPX * pSockAddr
    );


DWORD
NwpSetClassInfo(
    IN    LPWSTR   lpwszClassName,
    IN    LPGUID   lpClassId,
    IN    PCHAR    lpbProp
    );

VOID
pFreeAllContexts();

extern DWORD oldRnRServiceRegister, oldRnRServiceDeRegister;
//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

INT WINAPI
pGetServiceClassInfo(
    IN  LPGUID               lpProviderId,
    IN OUT LPDWORD    lpdwBufSize,
    IN OUT LPWSASERVICECLASSINFOW lpServiceClassInfo,
    IN  PBOOL          pfAdvert
);

DWORD
NwpSetClassInfoAdvertise(
       IN   LPGUID   lpClassType,
       IN   WORD     wSapId
);

BOOL
NSPpCheckCancel(
    PVOID pvArg
    );

DWORD
NSPpGotSap(
    PSAP_BCAST_CONTROL psbc,
    PSAP_IDENT_HEADER pSap,
    PDWORD pdwErr
    );

INT WINAPI
NSPLookupServiceBegin(
    IN  LPGUID               lpProviderId,
    IN  LPWSAQUERYSETW       lpqsRestrictions,
    IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo,
    IN  DWORD                dwControlFlags,
    OUT LPHANDLE             lphLookup
    );

INT WINAPI
NSPLookupServiceNext(
    IN     HANDLE          hLookup,
    IN     DWORD           dwControlFlags,
    IN OUT LPDWORD         lpdwBufferLength,
    OUT    LPWSAQUERYSETW  lpqsResults
    );

INT WINAPI
NSPUnInstallNameSpace(
    IN LPGUID lpProviderId
    );

INT WINAPI
NSPCleanup(
    IN LPGUID lpProviderId
    );

INT WINAPI
NSPLookupServiceEnd(
    IN HANDLE hLookup
    );

INT WINAPI
NSPSetService(
    IN  LPGUID               lpProviderId,
    IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo,
    IN LPWSAQUERYSETW lpqsRegInfo,
    IN WSAESETSERVICEOP essOperation,
    IN DWORD          dwControlFlags
    );

INT WINAPI
NSPInstallServiceClass(
    IN  LPGUID               lpProviderId,
    IN LPWSASERVICECLASSINFOW lpServiceClassInfo
    );

INT WINAPI
NSPRemoveServiceClass(
    IN  LPGUID               lpProviderId,
    IN LPGUID lpServiceCallId
    );

INT WINAPI
NSPGetServiceClassInfo(
    IN  LPGUID               lpProviderId,
    IN OUT LPDWORD    lpdwBufSize,
    IN OUT LPWSASERVICECLASSINFOW lpServiceClassInfo
    );
//-------------------------------------------------------------------//
//                                                                   //
// Data definitions                                                  //
//                                                                   //
//-------------------------------------------------------------------//

NSP_ROUTINE nsrVector = {
    FIELD_OFFSET(NSP_ROUTINE, NSPIoctl),
    1,                                    // major version
    1,                                    // minor version
    NSPCleanup,
    NSPLookupServiceBegin,
    NSPLookupServiceNext,
    NSPLookupServiceEnd,
    NSPSetService,
    NSPInstallServiceClass,
    NSPRemoveServiceClass,
    NSPGetServiceClassInfo
    };

static
GUID HostnameGuid = SVCID_HOSTNAME;

static
GUID InetHostname = SVCID_INET_HOSTADDRBYNAME;

static
GUID AddressGuid = SVCID_INET_HOSTADDRBYINETSTRING;

static
GUID IANAGuid = SVCID_INET_SERVICEBYNAME;

#define GuidEqual(x,y) RtlEqualMemory(x, y, sizeof(GUID))

    
//------------------------------------------------------------------//
//                                                                  //
//  Function Bodies                                                 //
//                                                                  //
//------------------------------------------------------------------//

DWORD
NwpSetClassInfoAdvertise(
       IN   LPGUID   lpClassType,
       IN   WORD     wSapId
)
{
/*++
Routine Description:
  Start a class info advertise. Called upon a SetService call
--*/
    PWCHAR pwszUuid;
    SOCKADDR_IPX sock;

    if (UuidToString(lpClassType, &pwszUuid) != RPC_S_OK) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return SOCKET_ERROR;
    }

    memset(&sock, 0, sizeof(sock));

    *(PWORD)&sock.sa_netnum = htons(wSapId);    // encode the ID here

    return(pSapSetService2( oldRnRServiceRegister,
                            pwszUuid,
                            (PBYTE)&sock,
                            lpClassType,
                            RNRCLASSSAPTYPE));
}

DWORD
pRnRReturnString(
    IN  PWCHAR   pwszSrc,
    IN OUT PBYTE *ppData,
    IN OUT PLONG plBytes
    )
{
/*++
Routine Description:
    Utility routine to pack a string into the spare buffer space,
    update pointers and counts. If the string fits, it is copied. If
    not, the pointer and count are still updated so the caller can
    compute the additional space needed
--*/

    PBYTE pSave = *ppData;
    LONG lLen = (wcslen(pwszSrc) + 1) * sizeof(WCHAR);

    *ppData = pSave + lLen;     // update the buffer pointer

    *plBytes = *plBytes - lLen;   // and the count

    if(*plBytes >= 0)
    {
        //
        // it fits.
        //

        RtlMoveMemory(pSave,
                      pwszSrc,
                      lLen);
        return(NO_ERROR);
    }
    return(WSAEFAULT);
}

DWORD
pLocateSapIdAndProtocls(
       IN LPGUID               lpClassInfoType,
       IN DWORD                dwNumClassInfo,
       IN LPWSANSCLASSINFOW    lpClassInfoBuf,
       OUT PWORD               pwSapId,
       OUT PDWORD              pdwnProt
    )
/*++
Routine Description:
    Locate the SAP ID entry and return it. Also return
    the protocols support.
--*/
{
    DWORD err = NO_ERROR;

    if(GuidEqual(lpClassInfoType, &HostnameGuid)
                 ||
       GuidEqual(lpClassInfoType, &InetHostname) )
    {
        *pwSapId = 0x4;
    }
    else if(IS_SVCID_NETWARE(lpClassInfoType))
    {
        *pwSapId = SAPID_FROM_SVCID_NETWARE(lpClassInfoType);
    }       
    else
    {
        for(; dwNumClassInfo; dwNumClassInfo--, lpClassInfoBuf++)
        {
            //
            // We have some class info data. Rummage through it
            // looking for what we want
            //

            if(!_wcsicmp(SERVICE_TYPE_VALUE_SAPIDW, lpClassInfoBuf->lpszName)
                           &&
               (lpClassInfoBuf->dwValueType == REG_DWORD)
                           &&
               (lpClassInfoBuf->dwValueSize >= sizeof(WORD)))
            {
                //
                // got it
                //

                *pwSapId = *(PWORD)lpClassInfoBuf->lpValue;
                break;

            }
        }
        if(!dwNumClassInfo)
        {
            err = WSA_INVALID_PARAMETER;
        }
    }
    *pdwnProt = SPX_BIT | SPXII_BIT | IPX_BIT;
    return(err);
}
DWORD
pRnRReturnResults(
    IN    PWCHAR  pwszString,
    IN    LPGUID  pgdServiceClass,
    IN    DWORD   dwVersion,
    IN OUT PBYTE *ppData,
    IN OUT PLONG plBytes,
    IN PBYTE lpSockAddr,
    IN  DWORD     nProt,
    IN  DWORD     dwControlFlags,
    OUT    LPWSAQUERYSETW  lpqsResults
    )
{
/*++
Routine Description:
   Return the requested results
--*/
    DWORD err;

    lpqsResults->dwNameSpace = NS_SAP;

    if(dwControlFlags & LUP_RETURN_TYPE)
    {

        lpqsResults->lpServiceClassId = (LPGUID)*ppData;
        *ppData += sizeof(GUID);
        *plBytes -= sizeof(GUID);
        if(*plBytes >= 0)
        {
            *lpqsResults->lpServiceClassId = *pgdServiceClass;
        }
    }

    if(dwVersion
          &&
       (dwControlFlags & LUP_RETURN_VERSION) )
    {
        //
        // have a verion, and the caller wants it
        //

        lpqsResults->lpVersion = (LPWSAVERSION)*ppData;
        *ppData += sizeof(WSAVERSION);
        *plBytes -= sizeof(WSAVERSION);
        if(*plBytes >= 0)
        {
            //
            // and it fits. So return it
            //
            lpqsResults->lpVersion->dwVersion = dwVersion;
            lpqsResults->lpVersion->ecHow = COMP_EQUAL;
        }
    }
        
    if(dwControlFlags & LUP_RETURN_ADDR)
    {
        DWORD dwCsAddrLen;

        if(*plBytes >= 0)
        {
            dwCsAddrLen = (DWORD)*plBytes;       // all of it for now
        }
        else
        {
            dwCsAddrLen = 0;
        }
        lpqsResults->lpcsaBuffer = (PVOID)*ppData;
    
        err = FillBufferWithCsAddr(
                      lpSockAddr,
                      nProt,
                      (PVOID)lpqsResults->lpcsaBuffer,
                      &dwCsAddrLen,
                      &lpqsResults->dwNumberOfCsAddrs);

        //
        // see if it fit. Whether it did or not, compute the space available,
        // align, and do the rest
        //

    
        if(err == NO_ERROR)
        {
            //
            // if it worked, we have to compute the space taken
            //

            dwCsAddrLen = lpqsResults->dwNumberOfCsAddrs * (sizeof(CSADDR_INFO) +
                                       2*sizeof(SOCKADDR_IPX));
        }
        else if(err == ERROR_INSUFFICIENT_BUFFER)
        {
            err = WSAEFAULT;
        }

        *plBytes = *plBytes - dwCsAddrLen;

        *ppData = *ppData + dwCsAddrLen;
    }
    else
    {
        err = NO_ERROR;
    }

    //
    // no padding needed.
    
    if((dwControlFlags & LUP_RETURN_NAME))
    {
        lpqsResults->lpszServiceInstanceName = (LPWSTR)*ppData;
        err = pRnRReturnString(
                pwszString,
                ppData,
                plBytes);
    }
    if(pgdServiceClass)
    {
        //
        // Do we really return this?
        //
    }
    return(err);
}

INT WINAPI
NSPLookupServiceBegin(
    IN  LPGUID               lpProviderId,
    IN  LPWSAQUERYSETW       lpqsRestrictions,
    IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo,
    IN  DWORD                dwControlFlags,
    OUT LPHANDLE             lphLookup
    )
/*++
Routine Description:
    This is the RnR routine that begins a lookup.
--*/
{
    PSAP_RNR_CONTEXT psrc;
    int err;
    DWORD nProt, nProt1;
    OEM_STRING OemServiceName;
    LPWSTR pwszContext;
    WORD wSapid;
    DWORD                dwNumClassInfo;
    LPWSANSCLASSINFOW    lpClassInfoBuf;

    //
    // Do parameter checking.
    //
    if ( lpqsRestrictions == NULL ||
         lpProviderId == NULL )
    {
        SetLastError( WSA_INVALID_PARAMETER );
        return( SOCKET_ERROR );
    }

    if ( lpqsRestrictions->dwNameSpace != NS_ALL &&
         lpqsRestrictions->dwNameSpace != NS_SAP )
    {
        SetLastError( WSAEINVAL );
        return( SOCKET_ERROR );
    }

    if ( lpqsRestrictions->lpServiceClassId == NULL )
    {
        SetLastError( WSA_INVALID_PARAMETER );
        return( SOCKET_ERROR );
    }

    //
    // Test to see if the ServiceClassId is TCP's, if so
    // we don't do the lookup.
    if ( lpqsRestrictions->lpServiceClassId &&
         ( GuidEqual( lpqsRestrictions->lpServiceClassId,
                       &HostAddrByInetStringGuid ) ||
           GuidEqual( lpqsRestrictions->lpServiceClassId,
                       &ServiceByNameGuid ) ||
           GuidEqual( lpqsRestrictions->lpServiceClassId,
                       &HostNameGuid ) ||
           GuidEqual( lpqsRestrictions->lpServiceClassId,
                       &HostAddrByNameGuid ) ) )
    {
        SetLastError( WSASERVICE_NOT_FOUND );
        return( SOCKET_ERROR );
    }

    if(lpqsRestrictions->dwSize < sizeof(WSAQUERYSETW))
    {
        SetLastError(WSAEFAULT);
        return(SOCKET_ERROR);
    }

    if(lpqsRestrictions->lpszContext
                  &&
       (lpqsRestrictions->lpszContext[0] != 0)
                  &&   
       wcscmp(&lpqsRestrictions->lpszContext[0],  L"\\") )
    {
        //
        // if not the default context, we must copy it.
        //
        pwszContext = lpqsRestrictions->lpszContext;
    }
    else
    {
        //
        // map all default contexts into "no context".
        //
        pwszContext = 0;
    }

    //
    // Compute protocols to return, or return them all
    //
    if(lpqsRestrictions->lpafpProtocols)
    {
        //
        // Make certain at least one IPX/SPX protocol is being requested
        //

        DWORD i;

        nProt = 0;

        for ( i = 0; i < lpqsRestrictions->dwNumberOfProtocols; i++ )
        {
            
            if((lpqsRestrictions->lpafpProtocols[i].iAddressFamily == AF_IPX)
                                        ||
               (lpqsRestrictions->lpafpProtocols[i].iAddressFamily == AF_UNSPEC)
              )
            {
                switch(lpqsRestrictions->lpafpProtocols[i].iProtocol) 
                {
                    case NSPROTO_IPX:
                        nProt |= IPX_BIT;
                        break;
                    case NSPROTO_SPX:
                        nProt |= SPX_BIT;
                        break;
                    case NSPROTO_SPXII:
                        nProt |= SPXII_BIT;
                        break;
                    default:
                        break;
                }
            }
        }

        if(!nProt)
        {
            //
            // if the caller doesn't want IPX/SPX addresses, why bother?
            //
            SetLastError(WSANO_DATA);
            return(SOCKET_ERROR);  
        }
    }
    else
    {
        nProt = IPX_BIT | SPX_BIT | SPXII_BIT;
    }

    if(dwControlFlags & LUP_CONTAINERS)
    {
        if(pwszContext)
        {
BadGuid:
           SetLastError(WSANO_DATA);
           return(SOCKET_ERROR);       // can't handle containers in containers
        }
        wSapid = 0x4;
        nProt1 = IPX_BIT;
        err = NO_ERROR;
    }
    else
    {
        
        LPGUID pgClass = lpqsRestrictions->lpServiceClassId;

        if(!pgClass
              ||
           GuidEqual(pgClass, &AddressGuid)
              ||
           GuidEqual(pgClass, &IANAGuid) )
        {
            goto BadGuid;
        }

        if(!lpqsRestrictions->lpszServiceInstanceName
                          ||
           !*lpqsRestrictions->lpszServiceInstanceName)
        {
            SetLastError(WSA_INVALID_PARAMETER);
            return(SOCKET_ERROR);
        }
        if(!lpServiceClassInfo)
        {
           dwNumClassInfo = 0;
        }
        else
        {
            dwNumClassInfo = lpServiceClassInfo->dwCount;
            lpClassInfoBuf = lpServiceClassInfo->lpClassInfos;
        }

        err = pLocateSapIdAndProtocls(pgClass,
                                      dwNumClassInfo,
                                      lpClassInfoBuf,
                                      &wSapid,
                                      &nProt1);
        if(err)
        {
            if(dwNumClassInfo)
            {
                SetLastError(err);
                return(SOCKET_ERROR);
            }
            else
            {
                nProt1 = nProt;
                wSapid = 0;
                err = 0;
            }
        }
    }

    nProt &= nProt1;              // the relevant protocols

    if(!nProt)
    {
        SetLastError(WSANO_DATA);
        return(SOCKET_ERROR);  
    }

    //
    // Make sure a class ID is given since we copy it
    //

    if(!lpqsRestrictions->lpServiceClassId)
    {
        //
        // not. So, fail
        //
        SetLastError(WSA_INVALID_PARAMETER);
        return(SOCKET_ERROR);
    }

    //
    // It looks like a query we can handle. Make a context
    //

    psrc = SapMakeContext(0,
                      sizeof(WSAVERSION) - sizeof(PVOID));
                  
    if(!psrc)
    {
        SetLastError(WSA_NOT_ENOUGH_MEMORY);
        return(SOCKET_ERROR);
    }

    //
    // save things
    //

    psrc->gdType = *lpqsRestrictions->lpServiceClassId;
    psrc->dwControlFlags = dwControlFlags;   // save for Next processing
    psrc->wSapId = wSapid;

    if(pwszContext)
    {
        wcscpy(psrc->wszContext, pwszContext);
    }

    //
    // save the relevant restrictions
    // if the name is a wild-card, don't copy it. A NULL name
    // serves as a wild-card to NSPLookupServiceNext
    //

    if(lpqsRestrictions->lpszServiceInstanceName
             &&
       *lpqsRestrictions->lpszServiceInstanceName
             &&
        wcscmp(lpqsRestrictions->lpszServiceInstanceName, L"*"))
    {
        DWORD dwLen = wcslen(lpqsRestrictions->lpszServiceInstanceName);
        if(dwLen > 48)
        {
            err = WSA_INVALID_PARAMETER;
            goto Done;
        }
        else
        {
            RtlMoveMemory(psrc->chwName,
                          lpqsRestrictions->lpszServiceInstanceName,
                          dwLen * sizeof(WCHAR));
            _wcsupr(psrc->chwName);
        }
    }
  
    psrc->fConnectionOriented = (DWORD) -1;

    *lphLookup = (HANDLE)psrc;
    psrc->nProt = nProt;
    psrc->gdProvider = *lpProviderId;
    if(lpqsRestrictions->lpVersion)
    {
        *(LPWSAVERSION)&psrc->pvVersion = *lpqsRestrictions->lpVersion;
    }
    
Done:
    SapReleaseContext(psrc);
    if(err != NO_ERROR)
    {
        SapReleaseContext(psrc);
        SetLastError(err);
        err = SOCKET_ERROR;
    }
    return(err);
}

INT WINAPI
NSPLookupServiceNext(
    IN     HANDLE          hLookup,
    IN     DWORD           dwControlFlags,
    IN OUT LPDWORD         lpdwBufferLength,
    OUT    LPWSAQUERYSETW  lpqsResults
    )
/*++
Routine Description:
    The continuation of the LookupServiceBegin. Called to fetch
    a matching item.
Arguments:
    See RnR spec
--*/
{
    DWORD err = NO_ERROR;
    PSAP_RNR_CONTEXT psrc;
    SOCKADDR_IPX SockAddr;
    WCHAR OutName[48];
    PBYTE pData = (PBYTE)(lpqsResults + 1);
    LONG lSpare;
    LONG lLastIndex;
    DWORD dwVersion;
    WSAQUERYSETW wsaqDummy;
    BOOL fDoStateMachine;

    if(*lpdwBufferLength < sizeof(WSAQUERYSETW))
    {
        lpqsResults = &wsaqDummy;
    }
    lSpare = (LONG)*lpdwBufferLength - sizeof(WSAQUERYSETW);

    memset(lpqsResults, 0, sizeof(WSAQUERYSETW));
    lpqsResults->dwNameSpace = NS_SAP;
    lpqsResults->dwSize = sizeof(WSAQUERYSETW);
    psrc = SapGetContext(hLookup);
    if(!psrc)
    {
  
        SetLastError(WSA_INVALID_HANDLE);
        return(SOCKET_ERROR);
    }

    //
    // This is a valid context. Determine whether this is the first
    // call to this. If so, we need to determine whether to
    // get the information from the bindery or by using SAP.
    //

    if ( psrc->u_type.bc.lIndex == 0xffffffff )
    {
        err = WSA_E_NO_MORE;
        goto DoneNext;
    }

    //
    // make sure we have the class info info
    //

    if(!psrc->wSapId)
    {
        //
        // Need to get it
        //

        UCHAR Buffer[1000];
        LPWSASERVICECLASSINFOW lpcli = (LPWSASERVICECLASSINFOW)Buffer;
        DWORD dwBufSize;
        DWORD nProt1;

        dwBufSize = 1000;
        lpcli->lpServiceClassId = &psrc->gdType;

        if( (err = NSPGetServiceClassInfo(&psrc->gdProvider,
                                  &dwBufSize,
                                  lpcli)) != NO_ERROR)
        {
            goto DoneNext;
        }

        err = pLocateSapIdAndProtocls(&psrc->gdType,
                                      lpcli->dwCount,
                                      lpcli->lpClassInfos,
                                      &psrc->wSapId,
                                      &nProt1);
        if(err)
        {
            SetLastError(err);
            goto DoneNext;
        }

        psrc->nProt &= nProt1;
        if(!psrc->nProt)
        {
            //
            // no protocols match
            //

            err = WSANO_DATA;
            goto DoneNext;
        }
    }

    //
    // this is the state machine for querying. It selects the bindery or
    // SAP as appropriate.
    //


    fDoStateMachine = TRUE;         // enter the machine

    do
    {
        //
        // switch on the current machine state.
        //
        switch(psrc->dwUnionType)
        {

        case LOOKUP_TYPE_NIL:
            psrc->u_type.bc.lIndex = -1;
            psrc->dwUnionType = LOOKUP_TYPE_BINDERY;
            break;                 // reenter state machine

        case LOOKUP_TYPE_BINDERY:

            //
            // try the bindery
            //


            if(psrc->dwControlFlags & LUP_NEAREST)
            {
                err = NO_DATA;        // skip the bindery
            }
            else
            {
                //
                // otherwise, try the bindery
                //

 
                EnterCriticalSection(&psrc->u_type.sbc.csMonitor);

                lLastIndex = psrc->u_type.bc.lIndex;   // save it


                err = NwpGetRnRAddress(
                             &psrc->hServer,
                             (psrc->wszContext[0] ?
                                     &psrc->wszContext[0] :
                                     0),
                             &psrc->u_type.bc.lIndex,
                             (psrc->chwName[0] ?
                                  psrc->chwName :
                                  0),
                             psrc->wSapId,
                             &dwVersion,
                             48 * sizeof(WCHAR),
                             OutName,
                             &SockAddr);

                LeaveCriticalSection(&psrc->u_type.sbc.csMonitor);
            }

            if(err != NO_ERROR)
            {

                if((psrc->u_type.bc.lIndex == -1))
                {
                    err = PrepareForSap(psrc);
                    if(err)
                    {
                        //
                        // if we can't, exit the state machine
                        //
                        fDoStateMachine = FALSE;
                    }
                }
                else
                {
                    //
                    // no more bindery entries. We will leave the state machine
                    //

                    if(err == ERROR_NO_MORE_ITEMS)
                    {
                        err = WSA_E_NO_MORE;
                    }
                    fDoStateMachine = FALSE;
                }
                break;
            }
            else
            {
                LPWSAVERSION lpVersion = (LPWSAVERSION)&psrc->pvVersion;

                if(lpVersion->dwVersion && dwVersion)
                {
                    //
                    // need to checkout for version matching
                    //

                    switch(lpVersion->ecHow)
                    {
                        case COMP_EQUAL:
                            if(lpVersion->dwVersion != dwVersion)
                            {
                               continue;   //reenter machine
                            }
                            break;

                        case COMP_NOTLESS:
                            if(lpVersion->dwVersion > dwVersion)
                            {
                                continue;
                            }
                            break;

                        default:
                            continue;         // error. If we don't
                                              // know how to compare, we
                                              // must  reject it.
                    }
                }

                //
                // have a suitable item.
                // return the name and type and all
                // that

                err = pRnRReturnResults(
                           OutName,
                           &psrc->gdType,
                           dwVersion,
                           &pData,
                           &lSpare,
                           (PBYTE)SockAddr.sa_netnum,
                           psrc->nProt,
                           psrc->dwControlFlags,
                           lpqsResults);
 
                if(err == WSAEFAULT)
                {
                    //
                    // no room. Return buffer size required and
                    // restore the index
                    //

                    *lpdwBufferLength =
                       (DWORD)((LONG)*lpdwBufferLength - lSpare);
                    psrc->u_type.bc.lIndex = lLastIndex;
            
                }
                fDoStateMachine = FALSE;
            }
            break;

       case LOOKUP_TYPE_SAP:

            //
            // Use SAP.
            //

            {
                WORD QueryType;

                if(psrc->dwControlFlags & LUP_NEAREST)
                {
                    QueryType = QT_NEAREST_QUERY;
                }
                else
                {
                    QueryType = QT_GENERAL_QUERY;
                }

                err = DoASap(psrc,
                             QueryType,
                             &pData,
                             lpqsResults,
                             &lSpare,
                             lpdwBufferLength);

                if((err == WSA_E_NO_MORE)
                        &&
                   !(psrc->fFlags & SAP_F_END_CALLED)
                        &&
                   (QueryType == QT_NEAREST_QUERY) 
                        &&
                   (psrc->dwControlFlags & LUP_DEEP)
                        &&
                    !psrc->u_type.sbc.psdHead)
                {
                    //
                    // didn't find it locally. Turn off LUP_NEAREST
                    // and do this as a general query. This might bring
                    // it back to a SAP query, but this time
                    // without LUP_NEAREST. But starting anew
                    // allows the use of the bindery and that
                    // might find things quickly.
                    //
                    psrc->dwControlFlags &= ~LUP_NEAREST;
                    psrc->dwUnionType = LOOKUP_TYPE_NIL;
                    if(psrc->u_type.sbc.s)
                    {
                        SapFreeSapSocket(psrc->u_type.sbc.s);
                        psrc->u_type.sbc.s = 0;
                    }

                }
                else
                {
                    fDoStateMachine = FALSE;
                }
                break;
            }
        }    // switch
    } while(fDoStateMachine);

DoneNext:
    SapReleaseContext(psrc);
    if((err != NO_ERROR)
            &&
       (err != (DWORD)SOCKET_ERROR))
    {
        SetLastError(err);
        err = (DWORD)SOCKET_ERROR;
    }
    return((INT)err);
}

BOOL
NSPpCheckCancel(
    PVOID pvArg
    )
/*++
Routine Description:
    Coroutine called to check if the SAP lookup has been cancelled.
    For now, this always returns FALSE as we use the flags word in
    the control block instead
--*/
{
    return(FALSE);
}


DWORD
NSPpGotSap(
    PSAP_BCAST_CONTROL psbc,
    PSAP_IDENT_HEADER pSap,
    PDWORD pdwErr
    )
/*++
Routine Description:
    Coroutine called for each SAP reply received. This decides
    whether to keep the data or not and returns a code telling
    the SAP engine whether to proceed

Arguments:
    psbc  --  the SAP_BCAST_CONTROL
    pSap  --  the SAP reply
    pdwErr -- where to put an error code
--*/
{
    PSAP_DATA psdData;
    LPWSAQUERYSETW Results = (LPWSAQUERYSETW)psbc->pvArg;
    PSAP_RNR_CONTEXT psrc = psbc->psrc;
    DWORD dwRet = dwrcNil;
    PCHAR pServiceName = (PCHAR)psrc->chName;
    
    EnterCriticalSection(&psbc->csMonitor);

    //
    // First, check if this is a lookup for a particular name. If so,
    // accept only the name.
    //

    if(*pServiceName)
    {
        if(strcmp(pServiceName, pSap->ServerName))
        {
            goto nota;
        }
        if(!(psrc->dwControlFlags & LUP_NEAREST))
        {
            dwRet = dwrcDone;
            psbc->fFlags |= SBC_FLAG_NOMORE;
        }
    }

    //
    // see if we want to keep this guy
    // We keep it if we don't already have it in the list
    //


    for(psdData = psbc->psdHead;
        psdData;
        psdData = psdData->sapNext)
    {
        if(RtlEqualMemory(  psdData->socketAddr,
                            &pSap->Address,
                            IPX_ADDRESS_LENGTH))
        {
            goto nota;          // we have it already
        }
    }

    psdData = (PSAP_DATA)LocalAlloc(LPTR, sizeof(SAP_DATA));
    if(!psdData)
    {
        goto nota;            // can't save it
    }

    psdData->sapid = pSap->ServerType;
    RtlMoveMemory(psdData->sapname,
                  pSap->ServerName,
                  48);
    RtlMoveMemory(psdData->socketAddr,
                  &pSap->Address,
                  IPX_ADDRESS_LENGTH);

    if(psbc->psdTail)
    {
        psbc->psdTail->sapNext = psdData;
    }
    else
    {
        psbc->psdHead = psdData;
    }
    psbc->psdTail = psdData;
    if(!psbc->psdNext1)
    {
        psbc->psdNext1 = psdData;
    }

nota:

    LeaveCriticalSection(&psbc->csMonitor);

    if((dwRet == dwrcNil)
             &&
       psbc->psdNext1)
    {
        dwRet = dwrcNoWait;
    }
    return(dwRet);
}

INT WINAPI
NSPUnInstallNameSpace(
    IN LPGUID lpProviderId
    )
{
    return(NO_ERROR);
}

INT WINAPI
NSPCleanup(
    IN LPGUID lpProviderId
    )
{
    //
    // Make sure all contexts are released
    //

//    pFreeAllContexts();   // done in Dll Process detach
    return(NO_ERROR);
}

INT WINAPI
NSPLookupServiceEnd(
    IN HANDLE hLookup
    )
{
    PSAP_RNR_CONTEXT psrc;

    psrc = SapGetContext(hLookup);
    if(!psrc)
    {
  
        SetLastError(WSA_INVALID_HANDLE);
        return(SOCKET_ERROR);
    }

    psrc->fFlags |= SAP_F_END_CALLED;
    SapReleaseContext(psrc);         // get rid of it
    SapReleaseContext(psrc);         // and close it. Context cleanup is
                                     //  done on the last derefernce.
    return(NO_ERROR);
}

INT WINAPI
NSPSetService(
    IN  LPGUID               lpProviderId,
    IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo,
    IN LPWSAQUERYSETW lpqsRegInfo,
    IN WSAESETSERVICEOP essOperation,
    IN DWORD          dwControlFlags
    )
{
/*++
Routine Description:
   The routine that implements the RnR SetService routine. Note that
   context is ignored. There is no way to direct the registration to
   a particular server.
--*/
    PBYTE pbAddress;
    DWORD dwOperation;
    PBYTE pbSocket;
    DWORD dwAddrs;
    DWORD err = NO_ERROR;
    WORD wSapId;
    DWORD nProt, dwAddress;
    BOOL fAdvert = FALSE;
    DWORD                dwNumClassInfo;
    LPWSANSCLASSINFOW    lpClassInfoBuf;


    //
    // Verify all args present
    //

    if(!lpqsRegInfo->lpszServiceInstanceName
               ||
       !lpqsRegInfo->lpServiceClassId)
    {
        SetLastError(WSA_INVALID_PARAMETER);
        return(SOCKET_ERROR);
    }

    if(!lpServiceClassInfo && !IS_SVCID_NETWARE(lpqsRegInfo->lpServiceClassId))
    {
        UCHAR Buffer[1000];
        LPWSASERVICECLASSINFOW lpcli = (LPWSASERVICECLASSINFOW)Buffer;
        DWORD dwBufSize;

        dwBufSize = 1000;
        lpcli->lpServiceClassId = lpqsRegInfo->lpServiceClassId;

        if(pGetServiceClassInfo(lpProviderId,
                                  &dwBufSize,
                                  lpcli,
                                  &fAdvert) != NO_ERROR)
        {
            return(SOCKET_ERROR);
        }
        dwNumClassInfo = lpcli->dwCount;
        lpClassInfoBuf = lpcli->lpClassInfos;
    }
    else if (lpServiceClassInfo)
    {
        dwNumClassInfo = lpServiceClassInfo->dwCount;
        lpClassInfoBuf = lpServiceClassInfo->lpClassInfos;
    }
    else
    {
        // lpServiceClassId is a GUID which defines the SapId.  This means
        // that pLocateSapIdAndProtocls doesn't need the lpClassInfoBuf.
        dwNumClassInfo = 0;
        lpClassInfoBuf = 0;
    }

    //
    // Find the IPX address in the input args
    //

    err = pLocateSapIdAndProtocls(lpqsRegInfo->lpServiceClassId,
                                  dwNumClassInfo,
                                  lpClassInfoBuf,
                                  &wSapId,
                                  &nProt);
                                  
    if(err == NO_ERROR)
    {
        if(essOperation == RNRSERVICE_REGISTER)
        {
            PCSADDR_INFO pcsaAddress;

            pcsaAddress = lpqsRegInfo->lpcsaBuffer;

            try
            {
                for(dwAddrs = lpqsRegInfo->dwNumberOfCsAddrs;
                    dwAddrs;
                    dwAddrs--, pcsaAddress++)
                {
                    if(pcsaAddress->LocalAddr.lpSockaddr->sa_family == AF_IPX)
                    {
                        pbSocket = 
                               (PBYTE)pcsaAddress->LocalAddr.lpSockaddr;
                        break;
                    }
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                err = GetExceptionCode();
            }

            if(err || !dwAddrs)
            {
                err = ERROR_INCORRECT_ADDRESS;
            }
            else if(fAdvert)
            {
               NwpSetClassInfoAdvertise(lpqsRegInfo->lpServiceClassId,
                                        wSapId);
            }
        }
        else
        {
            pbSocket = 0;
        }
        if(err == NO_ERROR)
        {
            //
            // map the operation, and call the common worker
            //

            switch(essOperation)
            {
                case RNRSERVICE_REGISTER:
                    dwOperation = oldRnRServiceRegister;
                    break;
                case RNRSERVICE_DEREGISTER:
                case RNRSERVICE_DELETE:
                    dwOperation = oldRnRServiceDeRegister;
                    break;
                default:
                    err = WSA_INVALID_PARAMETER;
                    break;
            }
            if(err == NO_ERROR)
            {
                err = pSapSetService2(
                           dwOperation,
                           lpqsRegInfo->lpszServiceInstanceName,
                           pbSocket,
                           lpqsRegInfo->lpServiceClassId,
                           wSapId);
                   
            }
        }
    }
    if(err != NO_ERROR)
    {
        SetLastError(err);
        err = (DWORD)SOCKET_ERROR;
    }
    return(err);
}

INT WINAPI
NSPInstallServiceClass(
    IN  LPGUID               lpProviderId,
    IN LPWSASERVICECLASSINFOW lpServiceClassInfo
    )
{
    LPWSANSCLASSINFOW pcli, pcli1 = 0;
    DWORD dwIndex = lpServiceClassInfo->dwCount;
    CHAR PropertyBuffer[128];
    PBINDERYCLASSES pbc = (PBINDERYCLASSES)PropertyBuffer;
    BYTE bData = (BYTE)&((PBINDERYCLASSES)0)->cDataArea[0];
    PCHAR pszData = &pbc->cDataArea[0];
    DWORD err;
    DWORD iter;
    WORD port = 0, sap = 0;
    BOOL fIsSAP = FALSE;

    //
    // Check a few parameters . . .
    //
    if ( lpServiceClassInfo == NULL )
    {
        SetLastError(WSA_INVALID_PARAMETER);
        return(SOCKET_ERROR);
    }

    if ( !lpServiceClassInfo->lpServiceClassId ||
         !lpServiceClassInfo->lpszServiceClassName ||
         ( lpServiceClassInfo->dwCount &&
           !lpServiceClassInfo->lpClassInfos ) )
    {
        SetLastError(WSA_INVALID_PARAMETER);
        return(SOCKET_ERROR);
    }

    //
    // Test to see if the ServiceClassId is TCP's, if so we don't allow
    // the service class installation since these are already present.
    //
    if ( GuidEqual( lpServiceClassInfo->lpServiceClassId,
                     &HostAddrByInetStringGuid ) ||
         GuidEqual( lpServiceClassInfo->lpServiceClassId,
                     &ServiceByNameGuid ) ||
         GuidEqual( lpServiceClassInfo->lpServiceClassId,
                     &HostNameGuid ) ||
         GuidEqual( lpServiceClassInfo->lpServiceClassId,
                     &HostAddrByNameGuid ) )
    {
        SetLastError(WSA_INVALID_PARAMETER);
        return(SOCKET_ERROR);
    }

    for( iter = 0; iter < lpServiceClassInfo->dwCount; iter++ )
    {
        if ( lpServiceClassInfo->lpClassInfos[iter].dwNameSpace == NS_SAP ||
             lpServiceClassInfo->lpClassInfos[iter].dwNameSpace == NS_ALL )
            fIsSAP = TRUE;
    }

    if ( !fIsSAP )
    {
        SetLastError(WSA_INVALID_PARAMETER);
        return(SOCKET_ERROR);
    }

    //
    // Find the SapId entry
    //

    for(pcli = lpServiceClassInfo->lpClassInfos;
        dwIndex;
        pcli++, dwIndex--)
    {
        WORD wTemp;

        if ( pcli->dwNameSpace == NS_SAP ||
             pcli->dwNameSpace == NS_ALL )
        {
            if(!_wcsicmp(pcli->lpszName, SERVICE_TYPE_VALUE_IPXPORTW)
                     &&
               (pcli->dwValueSize == sizeof(WORD)))
            {
                //
                // the value may not be aligned
                //
                ((PBYTE)&wTemp)[0] = ((PBYTE)pcli->lpValue)[0];
                ((PBYTE)&wTemp)[1] = ((PBYTE)pcli->lpValue)[1];
                port = wTemp;
            } else if(!_wcsicmp(pcli->lpszName, SERVICE_TYPE_VALUE_SAPIDW)
                     &&
               (pcli->dwValueSize >= sizeof(WORD)))
            {
                ((PBYTE)&wTemp)[0] = ((PBYTE)pcli->lpValue)[0];
                ((PBYTE)&wTemp)[1] = ((PBYTE)pcli->lpValue)[1];
                sap = wTemp;
                pcli1 = pcli;
            }
        }
    }

    if(!(pcli = pcli1))
    {
        SetLastError(WSA_INVALID_PARAMETER);
        return(SOCKET_ERROR);
    }

#if 0                // old way of doing this
    //
    // Found it. Build the property segment
    //

    memset(PropertyBuffer, 0, 128);   // clear out everyting

    pbc->bOffset = bData;
    pbc->bSizeOfString = sizeof("Sapid");

    pbc->bType = BT_WORD;            // just a word, I assure you
    pbc->bSizeOfType = 2;
    pbc->wNameSpace = (WORD)NS_SAP;  // it's us
    *(PWORD)pszData = htons(*(PWORD)pcli->lpValue);
    pszData += sizeof(WORD);         // where the string goes
    strcpy(pszData, "SapId");
//    pbc->bFlags = (BYTE)pcli->dwConnectionFlags;

    err = NwpSetClassInfo(
                   lpServiceClassInfo->lpszServiceClassName,
                   lpServiceClassInfo->lpServiceClassId,
                   PropertyBuffer);
#else
    err = NwpRnR2AddServiceType(
               lpServiceClassInfo->lpszServiceClassName,
               lpServiceClassInfo->lpServiceClassId,
               sap,
               port);
#endif
    if(err != NO_ERROR)
    {
        SetLastError(err);
        err = (DWORD)SOCKET_ERROR;
    }
                
    return(err);
}

INT WINAPI
NSPRemoveServiceClass(
    IN  LPGUID lpProviderId,
    IN  LPGUID lpServiceCallId
    )
{
    BOOL success;

    //
    // Do parameter checking
    //
    if ( lpServiceCallId == NULL )
    {
        SetLastError( WSA_INVALID_PARAMETER );
        return SOCKET_ERROR;
    }

    success = NwpRnR2RemoveServiceType( lpServiceCallId );

    if ( success )
        return( NO_ERROR );
    else
        SetLastError(WSATYPE_NOT_FOUND);
        return (DWORD)SOCKET_ERROR;
}

INT WINAPI
NSPGetServiceClassInfo(
    IN  LPGUID               lpProviderId,
    IN OUT LPDWORD    lpdwBufSize,
    IN OUT LPWSASERVICECLASSINFOW lpServiceClassInfo
    )
{
/*++
Routine Description:
    Get the ClassInfo for this type. Class info data may be in the
    registry, or available via SAP or the bindery. We try all three
    as appropriate
--*/
    BOOL fAdvert;

    return(pGetServiceClassInfo(
                  lpProviderId,
                  lpdwBufSize,
                  lpServiceClassInfo,
                  &fAdvert));
}

INT WINAPI
pGetServiceClassInfo(
    IN  LPGUID               lpProviderId,
    IN OUT LPDWORD    lpdwBufSize,
    IN OUT LPWSASERVICECLASSINFOW lpServiceClassInfo,
    IN  PBOOL          pfAdvert
    )
{
/*++
Routine Description:
    Get the ClassInfo for this type. Class info data may be in the
    registry, or available via SAP or the bindery. We try all three
    as appropriate
--*/
    DWORD err;
    LONG lInSize;
    LONG lSizeNeeded;
    PBYTE pbBuffer;
    GUID gdDummy;
    PWCHAR pwszUuid;
    LPGUID pType;
    WORD wSapId;
    WORD wPort;
    SOCKADDR_IPX sock;
    PWCHAR pwszSaveName = lpServiceClassInfo->lpszServiceClassName;

#define SIZENEEDED (sizeof(WSASERVICECLASSINFO) +   \
                    sizeof(WSANSCLASSINFO) + \
                    sizeof(WSANSCLASSINFO) + \
                    10 + 2                 + \
                    sizeof(GUID) +  12 + 2)

    *pfAdvert = FALSE;

    lInSize = (LONG)*lpdwBufSize - SIZENEEDED;

    pType = (LPGUID)(lpServiceClassInfo + 1);

    pbBuffer = (PBYTE)(pType + 1);

    if(lInSize < 0)
    {
        //
        // it is too small already
        //

        pType = &gdDummy;
    }

    if (UuidToString(lpServiceClassInfo->lpServiceClassId, &pwszUuid) != RPC_S_OK) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return SOCKET_ERROR;
    }

    //
    // First, try the bindery
    //

    err = NwpGetAddressByName(0,
                              RNRCLASSSAPTYPE,
                              pwszUuid,
                              &sock);

    if(err == NO_ERROR)
    {
        wSapId = ntohs(*(PWORD)&sock.sa_netnum);
        wPort = ntohs(*(PWORD)&sock.sa_socket);
    }
    else
    {
        UCHAR Buffer[400];
        DWORD dwLen = 400;
        DWORD dwNum;
        //
        // try SAP
        //

        err = NwpGetAddressViaSap(RNRCLASSSAPTYPE,
                                  pwszUuid,
                                  IPX_BIT,
                                  (PVOID)Buffer,
                                  &dwLen,
                                  0,
                                  &dwNum);
        if((err == NO_ERROR)
                 &&
            (dwNum > 0) )
        {
            PCSADDR_INFO psca = (PCSADDR_INFO)Buffer;
            PSOCKADDR_IPX psock = (PSOCKADDR_IPX)psca->RemoteAddr.lpSockaddr;

            wSapId = ntohs(*(PWORD)&psock->sa_netnum);
            wPort = ntohs(*(PWORD)&sock.sa_socket);
        }
        else
        {
            //
            // try the local bindery
    
    
            if(!NwpLookupSapInRegistry(
                 lpServiceClassInfo->lpServiceClassId,
                 &wSapId,
                 &wPort,
                 NULL))
            {
                err = WSASERVICE_NOT_FOUND;
            }
            else
            {
                *pfAdvert = TRUE;
                err = NO_ERROR;
            }
        }
    }
    
    RpcStringFree(&pwszUuid);

    if(err != NO_ERROR)
    {
        SetLastError(err);
        err = (DWORD)SOCKET_ERROR;
    }
    else
    {
        //
        // we return the input structure and the found type. That's it.
        // The space needed is a constant since we don't return the name
        //

        if(lInSize < 0)
        {
            SetLastError(WSAEFAULT);
            *lpdwBufSize += (DWORD)(-lInSize);
            err = (DWORD)SOCKET_ERROR;
        }
        else
        {
            LPWSANSCLASSINFOW pci = (LPWSANSCLASSINFOW)pbBuffer;
            PUCHAR Buff;
            //
            // it will fit. SO let's go
            //

            if(wPort)
            {
                Buff = (PCHAR)(pci + 2);
            }
            else
            {
                Buff = (PCHAR)(pci + 1);
            }

            *pType = *lpServiceClassInfo->lpServiceClassId;
            lpServiceClassInfo->lpServiceClassId = pType;
            lpServiceClassInfo->lpszServiceClassName = 0;   // not a
            lpServiceClassInfo->dwCount = 1;
            lpServiceClassInfo->lpClassInfos = pci;
            pci->dwNameSpace = NS_SAP;
            pci->dwValueType = REG_DWORD;
            pci->dwValueSize = 2;
            pci->lpszName = (LPWSTR)Buff;
            wcscpy((PWCHAR)Buff, L"SapId");
            Buff += 6 * sizeof(WCHAR);
            pci->lpValue = (LPVOID)Buff;
            *(PWORD)Buff = wSapId;
            Buff += sizeof(WORD);
            if(wPort)
            {
                lpServiceClassInfo->dwCount++;
                pci++;
                pci->dwNameSpace = NS_SAP;
                pci->dwValueType = REG_DWORD;
                pci->dwValueSize = 2;
                pci->lpszName = (LPWSTR)Buff;
                wcscpy((PWCHAR)Buff, L"Port");
                Buff += 5 * sizeof(WCHAR);
                pci->lpValue = (LPVOID)Buff;
                *(PWORD)Buff = wPort;
            }
        }
    }
    return(err);
}

INT WINAPI
NSPStartup(
    IN LPGUID         lpProviderId,
    IN OUT LPNSP_ROUTINE lpsnpRoutines)
{
//    DWORD dwSize = min(sizeof(nsrVector), lpsnpRoutines->cbSize);
    DWORD dwSize = sizeof(nsrVector);
    RtlCopyMemory(lpsnpRoutines,
                  &nsrVector,
                  dwSize);
    return(NO_ERROR);
}

DWORD
DoASap(
    IN PSAP_RNR_CONTEXT psrc,
    IN WORD QueryType,
    IN PBYTE * ppData,
    IN LPWSAQUERYSETW lpqsResults,
    IN PLONG   plSpare,
    IN PDWORD  lpdwBufferLength
    )
/*++
   Small routine to construcst a SAP_BROADCAST pakcet and issue the SAP
--*/
{
    DWORD err;

    if(!psrc->u_type.sbc.s)
    {
        //
        // this is the first time. We must init the
        // structure
        //
        err = SapGetSapSocket(&psrc->u_type.sbc.s);
        if(err)
        {
            psrc->u_type.sbc.s = 0;    // make sure
            return(err);
        }
        psrc->u_type.sbc.Func = NSPpGotSap;
        psrc->u_type.sbc.fCheckCancel = NSPpCheckCancel;
        psrc->u_type.sbc.dwIndex = 0;    // just in case.
        psrc->u_type.sbc.pvArg = (PVOID)lpqsResults;
        psrc->u_type.sbc.psrc = psrc;
        psrc->u_type.sbc.fFlags = 0;

    }

    psrc->u_type.sbc.wQueryType = QueryType;

    if(!psrc->u_type.sbc.psdNext1
                &&
       !(psrc->u_type.sbc.fFlags & SBC_FLAG_NOMORE))
    {
        err = SapGetSapForType(&psrc->u_type.sbc, psrc->wSapId);
    }

    EnterCriticalSection(&psrc->u_type.sbc.csMonitor);
    if(psrc->u_type.sbc.psdNext1)
    {
        //
        // Got something to return.  Let's do it
        //


        //
        // Assume we have to return the name
        //

               
        //
        // We have to convert the name to UNICODE so
        // we can return it to the caller.
        //
        //

        OEM_STRING Oem;
        NTSTATUS status;
        UNICODE_STRING UString;

        RtlInitAnsiString(&Oem,
                          psrc->u_type.sbc.psdNext1->sapname);
        status = RtlOemStringToUnicodeString(
                            &UString,
                            &Oem,
                            TRUE);
        if(NT_SUCCESS(status))
        {
            if(psrc->wSapId == OT_DIRSERVER)
            {
                PWCHAR pwszTemp = &UString.Buffer[31];

                while(*pwszTemp == L'_')
                {
                    *pwszTemp-- = 0;
                }
            }
            err = pRnRReturnResults(
                       UString.Buffer,
                       &psrc->gdType,
                       0,            // never a version
                       ppData,
                       plSpare,
                       psrc->u_type.sbc.psdNext1->socketAddr,
                       psrc->nProt,
                       psrc->dwControlFlags,
                       lpqsResults);
            RtlFreeUnicodeString(&UString);
            if(err == WSAEFAULT)
            {
                //
                // no room. Return buffer size required
                //

                *lpdwBufferLength =
                    (DWORD)((LONG)*lpdwBufferLength - *plSpare);
            }
        }
        else
        {
            err = (DWORD)status;
        }
        if(err == NO_ERROR)
        {
            //
            // if we got it, step the item
            //
            psrc->u_type.sbc.psdNext1 =
                psrc->u_type.sbc.psdNext1->sapNext;
        }
        

    }
    else
    {
         err = (DWORD)WSA_E_NO_MORE;
    }
    LeaveCriticalSection(&psrc->u_type.sbc.csMonitor);
    return(err);
}


DWORD
PrepareForSap(
    IN PSAP_RNR_CONTEXT psrc
    )
/*++
Called when there is no bindery or the bindery does not have the
entry. This initializes the values needed for a SAP search
--*/
{


    OEM_STRING OemServiceName;
    UNICODE_STRING UString;
    NTSTATUS status;

    //
    // the bindery didn't work. Use SAP.
    //


    psrc->u_type.sbc.dwIndex =
      psrc->u_type.sbc.dwTickCount = 0;
    if(psrc->wszContext[0])
    {
        return(WSASERVICE_NOT_FOUND);   // no contexts in SAP
    }
    RtlInitUnicodeString(&UString,
                         psrc->chwName);
    status = RtlUnicodeStringToOemString(&OemServiceName,
                                         &UString,
                                         TRUE);
    if(!NT_SUCCESS(status))
    {
       return( (DWORD)status);
    }
    strcpy((PCHAR)&psrc->chName,
            OemServiceName.Buffer);
    RtlFreeOemString(&OemServiceName);
    psrc->dwUnionType = LOOKUP_TYPE_SAP;
    psrc->u_type.sbc.s = 0;
    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\bind.c ===
/*++

Copyright (c) 1991-1993 Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Contains the client-side RPC bind and unbind routines for Workstation
    service.

Author:

    Rita Wong    (ritaw)    12-Feb-1993

Environment:

    User Mode -Win32

Revision History:

--*/

//
// INCLUDES
//
#include <nwclient.h>
#include <rpcutil.h>    // RpcUtils for binding
#include <nwmisc.h>     // NWWKS_INTERFACE_NAME


handle_t
NWWKSTA_IMPERSONATE_HANDLE_bind(
    NWWKSTA_IMPERSONATE_HANDLE Reserved
    )

/*++

Routine Description:

    This routine is called from the Workstation service client when
    it is necessary create an RPC binding to the server end with
    impersonation level of impersonation.

Arguments:


Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle = 0;
    RPC_STATUS RpcStatus;
    LPWSTR      binding = NULL;


    UNREFERENCED_PARAMETER(Reserved);

/*
	RpcStatus = NetpBindRpc(
                    NULL,
                    NWWKS_INTERFACE_NAME,
                    L"Security=Impersonation Dynamic False",
                    &BindHandle
                    );
*/
    RpcStatus = RpcStringBindingComposeW(
                    0,
                    L"ncalrpc",
                    NULL,
                    L"nwwkslpc",
                    L"Security=Impersonation Dynamic False",
                    &binding );

    if ( RpcStatus != RPC_S_OK )
    {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW( binding, &BindHandle );
    if ( RpcStatus != RPC_S_OK )
    {
        BindHandle = NULL;
    }

    if ( binding )
    {
        RpcStringFreeW( &binding );
    }

	if (RpcStatus != RPC_S_OK) {
        KdPrint((
            "NWWORKSTATION: Client NWWKSTA_IMPERSONATE_HANDLE_bind failed: %lu\n",
            RpcStatus
            ));
    }

    return BindHandle;
}



handle_t
NWWKSTA_IDENTIFY_HANDLE_bind(
    NWWKSTA_IDENTIFY_HANDLE Reserved
    )

/*++

Routine Description:

    This routine is called from the Workstation service client stubs when
    it is necessary create an RPC binding to the server end with
    identification level of impersonation.

Arguments:


Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle = 0;
    RPC_STATUS RpcStatus;
    LPWSTR      binding = NULL;


    UNREFERENCED_PARAMETER(Reserved);

/*
	RpcStatus = NetpBindRpc(
                    NULL,
                    NWWKS_INTERFACE_NAME,
                    L"Security=Identification Dynamic False",
                    &BindHandle
                    );
*/
    RpcStatus = RpcStringBindingComposeW(
                    0,
                    L"ncalrpc",
                    NULL,
                    L"nwwkslpc",
                    L"Security=Identification Dynamic False",
                    &binding );

    if ( RpcStatus != RPC_S_OK )
    {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW( binding, &BindHandle );
    if ( RpcStatus != RPC_S_OK )
    {
        BindHandle = NULL;
    }

    if ( binding )
    {
        RpcStringFreeW( &binding );
    }

    if (RpcStatus != RPC_S_OK) {
        KdPrint((
            "NWWORKSTATION: Client NWWKSTA_IDENTIFY_HANDLE_bind failed: %lu\n",
            RpcStatus
            ));
    }

    return BindHandle;
}



void
NWWKSTA_IMPERSONATE_HANDLE_unbind(
    NWWKSTA_IMPERSONATE_HANDLE Reserved,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine unbinds the impersonation generic handle.

Arguments:

    Reserved -

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(Reserved);

//    NetpUnbindRpc(BindHandle);
    RpcBindingFree( &BindHandle );
}



void
NWWKSTA_IDENTIFY_HANDLE_unbind(
    NWWKSTA_IDENTIFY_HANDLE Reserved,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine unbinds the identification generic handle.

Arguments:

    Reserved -

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(Reserved);

//    NetpUnbindRpc(BindHandle);
    RpcBindingFree( &BindHandle );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\logon.c ===
/*++

Copyright (c) 1993, 1994  Microsoft Corporation

Module Name:

    logon.c

Abstract:

    This module contains NetWare credential management code.

Author:

    Rita Wong  (ritaw)   15-Feb-1993

Revision History:

    Yi-Hsin Sung (yihsins) 10-July-1993
        Moved all dialog handling to nwdlg.c

    Tommy Evans (tommye) 05-05-2000
        Merged with code from Anoop (anoopa) to fix problem with 
        username/password not being stored correctly in the LOGON
        list.

--*/

#include <nwclient.h>
#include <ntmsv1_0.h>
#include <nwsnames.h>
#include <nwcanon.h>
#include <validc.h>
#include <nwevent.h>

#include <nwdlg.h>

#include <nwreg.h>
#include <nwauth.h>
#include <nwapi.h>
#include <nwmisc.h>
#include <ndsapi32.h>

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

VOID
NwpInitializeRegistry(
    IN LPWSTR  NewUserSid,
    OUT LPWSTR PreferredServer,
    IN  DWORD  PreferredServerSize,
    OUT LPWSTR NdsPreferredServer,
    IN  DWORD  NdsPreferredServerSize,
    OUT PDWORD LogonScriptOptions,
    OUT PDWORD PrintOption
    );

DWORD
NwpReadRegInfo(
    IN  HKEY   WkstaKey,
    IN  LPWSTR CurrentUserSid,
    OUT LPWSTR PreferredServer,
    IN  DWORD  PreferredServerSize,
    OUT LPWSTR NdsPreferredServer,
    IN  DWORD  NdsPreferredServerSize,
    OUT PDWORD PrintOption
    );

DWORD
NwpGetCurrentUser(
    OUT LPWSTR *SidString,
    OUT LPWSTR *UserName
    );

DWORD
NwpGetUserSid(
    IN  PLUID  LogonId,
    OUT LPWSTR *UserSidString
    );

BOOL
NwpPollWorkstationStart(
    VOID
    );

VOID
NwpSaveServiceCredential(
    IN PLUID  LogonId,
    IN LPWSTR UserName,
    IN LPWSTR Password
    );

DWORD
NwpSetCredentialInLsa(
    IN PLUID LogonId,
    IN LPWSTR UserName,
    IN LPWSTR Password
    );

NTSTATUS NwNdsOpenRdrHandle(
    OUT PHANDLE  phNwRdrHandle
    );

DWORD
NwpReadLogonScriptOptions(
    IN LPWSTR CurrentUserSid,
    OUT PDWORD pLogonScriptOptions,
    OUT PDWORD pPreferredServerExists
    );

LPWSTR 
NwpConstructLogonScript(
    IN DWORD LogonScriptOptions
    );

VOID
NwpSelectServers(
    IN HWND DialogHandle,
    IN PCHANGE_PW_DLG_PARAM Credential
    );


////////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
NPLogonNotify(
    PLUID lpLogonId,
    LPCWSTR lpAuthentInfoType,
    LPVOID lpAuthentInfo,
    LPCWSTR lpPreviousAuthentInfoType,
    LPVOID lpPreviousAuthentInfo,
    LPWSTR lpStationName,
    LPVOID StationHandle,
    LPWSTR *lpLogonScript
    )
/*++

Routine Description:

    This function is called by Winlogon after the interactive
    user has successfully logged on to the local machine.  We
    are given the username and password, which
    are displayed in the NetWare specific logon dialog if 
    needed. 

Arguments:

    lpLogonId - Ignored.

    lpAuthentInfoType - Supplies a string which if is
        L"MSV1_0:Interactive" means that the user has been logged
        on by the Microsoft primary authenticator.

    lpAuthentInfo - Supplies a pointer to the credentials which
        the user was logged on with.

    lpPreviousAuthentInfoType - Ignored.

    lpPreviousAuthentInfo - Ignored.

    lpStationName - Supplies a string which if it is L"WinSta_0"
        means that Winlogon logged on the user.

    StationHandle - Supplies the handle to the window which to display
        our specific dialog.

    lpLogonScripts - Receives a pointer to memory allocated by this
        routine which contains a MULTI_SZ string of a program to run on
        the command line with arguments, e.g. L"myprogram\0arg1\0arg2\0".
        This memory must be freed by the caller with LocalFree.

Return Value:

    WN_SUCCESS - Successfully saved default credentials.

    WN_NOT_SUPPORTED - Primary authenticator is not Microsoft or
        is not interactive via Winlogon.

    ERROR_FILE_NOT_FOUND - Could not get our own provider DLL handle.

--*/
{
    DWORD status = NO_ERROR;
    INT_PTR Result = FALSE;
    LPWSTR NewUserSid = NULL;
    BOOL LogonAttempted = FALSE;
    PMSV1_0_INTERACTIVE_LOGON NewLogonInfo =
        (PMSV1_0_INTERACTIVE_LOGON) lpAuthentInfo;

    WCHAR NwpServerBuffer[MAX_PATH + 1];
    WCHAR NwpNdsServerBuffer[MAX_PATH + 1];
    WCHAR NwpUserNameBuffer[NW_MAX_USERNAME_LEN + 1];
    WCHAR NwpPasswordBuffer[NW_MAX_PASSWORD_LEN + 1];
    DWORD NwpPrintOption = NW_PRINT_OPTION_DEFAULT;
    DWORD NwpLogonScriptOptions = NW_LOGONSCRIPT_DEFAULT ;
    BOOL  cPasswordDlgClickOK = 0;
    BOOL  ServiceLogin = FALSE ;
    BOOL  NoLoginScript = FALSE ;

    DBG_UNREFERENCED_PARAMETER(lpPreviousAuthentInfoType);
    DBG_UNREFERENCED_PARAMETER(lpPreviousAuthentInfo);

#if DBG
    IF_DEBUG(LOGON) {
        KdPrint(("\nNWPROVAU: NPLogonNotify\n"));
    }
#endif

    RpcTryExcept {

        if (_wcsicmp(lpAuthentInfoType, L"MSV1_0:Interactive") != 0)
        {

            //
            // We only handle a logon where Microsoft is the primary
            // authenticator and it is an interactive logon via Winlogon.
            //
            status = WN_NOT_SUPPORTED;
            goto EndOfTry;
        }

        if (_wcsicmp(lpStationName, L"SvcCtl") == 0)
        {
            ServiceLogin = TRUE ;
        }


        //
        // Initialize credential variables
        //
        NwpServerBuffer[0] = NW_INVALID_SERVER_CHAR;
        NwpServerBuffer[1] = 0;

        NwpNdsServerBuffer[0] = NW_INVALID_SERVER_CHAR;
        NwpNdsServerBuffer[1] = 0;

        RtlZeroMemory(NwpPasswordBuffer, sizeof(NwpPasswordBuffer));

        if (NewLogonInfo->Password.Buffer != NULL) {

            //
            // check for max length to avoid overflowing.
            //
            if (NewLogonInfo->Password.Length > 
                (sizeof(NwpPasswordBuffer) - sizeof(WCHAR))) {

                status = ERROR_INVALID_PARAMETER ;
                goto EndOfTry;
            }

            wcsncpy(
                NwpPasswordBuffer,
                NewLogonInfo->Password.Buffer,
                NewLogonInfo->Password.Length / sizeof(WCHAR)
                );
        }

        RtlZeroMemory(NwpUserNameBuffer, sizeof(NwpUserNameBuffer));

        if (NewLogonInfo->UserName.Buffer != NULL) {

            //
            // check for max length to avoid overflowing.
            //
            if (NewLogonInfo->UserName.Length >
                (sizeof(NwpUserNameBuffer) - sizeof(WCHAR))) {

                status = ERROR_INVALID_PARAMETER ;
                goto EndOfTry;
            }

            wcsncpy(
                NwpUserNameBuffer,
                NewLogonInfo->UserName.Buffer,
                NewLogonInfo->UserName.Length / sizeof(WCHAR)
                );
        }

#if DBG
        IF_DEBUG(LOGON) {
            KdPrint(("\tMessageType     : %lu\n", NewLogonInfo->MessageType));
            KdPrint(("\tLogonDomainName : %ws\n", NewLogonInfo->LogonDomainName.Buffer));
            KdPrint(("\tUserName        : %ws\n", NwpUserNameBuffer));
            KdPrint(("\tPassword        : %ws\n", NwpPasswordBuffer));
        }
#endif

        //
        // if Interactive login, get user related info
        //
        // if (!ServiceLogin) /* It's OK to read print options from service user settings */
        {
            //
            // Get the user SID so that the user Netware username and
            // preferred server is saved under a SID key rather than the
            // LogonDomain*UserName key.  We do this by making ourselves
            // a logon process, and call the special MSV1.0 GetUserInfo
            // interface.
            //
            status = NwpGetUserSid(lpLogonId, &NewUserSid);
    
            if (status == NO_ERROR) {
                //
                // Initialize the registry:
                //   1) Delete the CurrentUser value if it exists (was not clean up
                //      previously because user did not log off--rebooted machine).
                //   2) Read the current user's PreferredServer and PrintOption 
                //      value so that we can display the user's original
                //      preferred server.
                //
                NwpInitializeRegistry( NewUserSid, 
                                    NwpServerBuffer, 
                                    sizeof( NwpServerBuffer ) / 
                                    sizeof( NwpServerBuffer[0]),
                                    NwpNdsServerBuffer, 
                                    sizeof( NwpNdsServerBuffer ) / 
                                    sizeof( NwpNdsServerBuffer[0]),
                                    &NwpLogonScriptOptions,
                                    &NwpPrintOption );
            }
            else if (!ServiceLogin)
                goto EndOfTry;
        }

        //
        // Poll until the NetWare workstation has started, then validate
        // the user credential.
        //
        if ( !NwpPollWorkstationStart() )
        {
            status = WN_NO_NETWORK;
            KdPrint(("NWPROVAU: The Workstation Service is not running, give up\n", status));
            goto EndOfTry;
        }

        //
        // If service login, notify the redir with the username/passwd/
        // LUID triplet and save the logon ID in the registry so that
        // workstation can pick up if stopped and restarted.
        //
        if (ServiceLogin)
        {
            NwpSaveServiceCredential(
                lpLogonId,
                NwpUserNameBuffer,
                NwpPasswordBuffer
                );

            (void) NwrLogonUser(
                       NULL,
                       lpLogonId,
                       NwpUserNameBuffer,
                       NwpPasswordBuffer,
                       NULL,
                       NULL,
               NULL,
                       0,
                       NwpPrintOption             //Terminal Server addition
                       );

        } else {

            //
            // We need to save the user credentials at least once so that
            // the CURRENTUSER Value is stored in the registry.
            // This must be done before any RPC calls but after polling 
            // workstation start.
            //
            NwpSaveLogonCredential(
                                  NewUserSid,
                                  lpLogonId,
                                  NwpUserNameBuffer,
                                  NwpPasswordBuffer,
                                  NULL         // Don't save the preferred server
                                  );

            if (*NwpServerBuffer != NW_INVALID_SERVER_CHAR ) {

                //
                // Preferred server exists. So, try to log the user on.
                // 
                INT nResult;
    
                while (1)
                {
                    WCHAR *DefaultTree = NULL ;
                    WCHAR *DefaultContext = NULL; 
                    WCHAR *PreferredServer = NULL; 
                    PROMPTDLGPARAM PasswdPromptParam;

#if DBG
                    IF_DEBUG(LOGON) {
                        KdPrint(("\tNwrLogonUser\n"));
                        KdPrint(("\tUserName   : %ws\n", NwpUserNameBuffer));
                        KdPrint(("\tServer     : %ws\n", NwpServerBuffer));
                    }
#endif


                    //
                    // make sure user is logged off
                    //
                    (void) NwrLogoffUser(NULL, lpLogonId) ;

                    status = NwrLogonUser(
                                 NULL,
                                 lpLogonId,
                                 NwpUserNameBuffer,
                                 NwpPasswordBuffer,
                                 NwpServerBuffer,    // now either TREE or SERVER
                                 NwpNdsServerBuffer, // Preferred Nds server if one exists
                                 NULL,
                                 0,
                                 NwpPrintOption  //***Terminal Server Added parameter
                                 );
    

                    //
                    // tommye 
                    //
                    // If the error is NO_SUCH_USER, see if the user name has any 
                    // periods in it - if so, then we need to escape them (\.) and 
                    // try the login again.
                    //

                    if (status == ERROR_NO_SUCH_USER) {
                        WCHAR   EscapedName[NW_MAX_USERNAME_LEN * 2];
                        PWSTR   pChar = NwpUserNameBuffer;
                        int     i = 0;
                        BOOL    bEscaped = FALSE;

                        RtlZeroMemory(EscapedName, sizeof(EscapedName));

                        do {
                            if (*pChar == L'.') {
                                EscapedName[i++] = '\\';
                                bEscaped = TRUE;
                            }
                            EscapedName[i++] = *pChar;
                        } while (*pChar++);

                        // Try the login again

                        if (bEscaped) {

                            status = NwrLogonUser(
                                         NULL,
                                         lpLogonId,
                                         EscapedName,
                                         NwpPasswordBuffer,
                                         NwpServerBuffer,    // now either TREE or SERVER
                                         NwpNdsServerBuffer, // Preferred Nds server if one exists
                                         NULL,
                                         0,
                                         NwpPrintOption  //***Terminal Server Added parameter
                                         );
                            if (status != ERROR_NO_SUCH_USER) { // if we matched a username, copy that name into buffer
                                //
                                // check for max length to avoid overflowing.
                                //
                                if (i < (sizeof(NwpUserNameBuffer))) {
                                    wcsncpy(
                                        NwpUserNameBuffer,
                                        EscapedName,
                                        i
                                        );
                                }
                            }
                        }
                    }

                    if (status != ERROR_INVALID_PASSWORD)
                            break ;
    
                    PasswdPromptParam.UserName = NwpUserNameBuffer;
                    PasswdPromptParam.ServerName = NwpServerBuffer ; 
                    PasswdPromptParam.Password  = NwpPasswordBuffer;
                    PasswdPromptParam.PasswordSize = sizeof(NwpPasswordBuffer)/
                                                     sizeof(NwpPasswordBuffer[0]) ;
                    Result = DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_PASSWORD_PROMPT),
                                 (HWND) StationHandle,
                                 NwpPasswdPromptDlgProc,
                                 (LPARAM) &PasswdPromptParam
                                 );

                    if (Result == -1 || Result == IDCANCEL) 
                    {
                        status = ERROR_INVALID_PASSWORD ;
                        break ;
                    }
                    else
                    {
                        cPasswordDlgClickOK++;
                    }
                }

                if (status == NW_PASSWORD_HAS_EXPIRED)
                {
                    WCHAR  szNumber[16] ;
                    DWORD  status1, dwMsgId, dwGraceLogins = 0 ;
                    LPWSTR apszInsertStrings[3] ;

                    //
                    // get the grace login count
                    //
                    status1 = NwGetGraceLoginCount(
                                  NwpServerBuffer,
                                  NwpUserNameBuffer,
                                  &dwGraceLogins) ;

                    //
                    // if hit error, just dont use the number
                    //
                    if (status1 == NO_ERROR) 
                    {
                        //
                        // tommye - MCS bug 251 - changed from SETPASS
                        // message (IDS_PASSWORD_EXPIRED) to 
                        // Ctrl+Alt+Del message.
                        //

                        dwMsgId = IDS_PASSWORD_HAS_EXPIRED0;  // use setpass.exe
                        wsprintfW(szNumber, L"%ld", dwGraceLogins)  ;
                    }
                    else
                    {
                        //
                        // tommye - MCS bug 251 - changed from SETPASS
                        // message (IDS_PASSWORD_EXPIRED1) to 
                        // Ctrl+Alt+Del message.
                        //

                        dwMsgId = IDS_PASSWORD_HAS_EXPIRED2 ; // use setpass.exe
                    }

                    apszInsertStrings[0] = NwpServerBuffer ;
                    apszInsertStrings[1] = szNumber ;
                    apszInsertStrings[2] = NULL ;
                    
                    //
                    // put up message on password expiry
                    //
                    (void) NwpMessageBoxIns( 
                               (HWND) StationHandle,
                               IDS_NETWARE_TITLE,
                               dwMsgId,
                               apszInsertStrings,
                               MB_OK | MB_SETFOREGROUND |
                                   MB_ICONINFORMATION ); 

                    status = NO_ERROR ;
                }


                if ( status != NO_ERROR ) 
                {
                    WCHAR *pszErrorLocation = NwpServerBuffer ;
                    DWORD dwMsgId = IDS_LOGIN_FAILURE_WARNING;
 
                    if (status == ERROR_ACCOUNT_RESTRICTION)
                    {
                        dwMsgId = IDS_LOGIN_ACC_RESTRICTION;
                    }

                    if (status == ERROR_SHARING_PAUSED)
                    {
                        status = IDS_LOGIN_DISABLED;
                    }

                    if (*NwpServerBuffer == L'*')
                    {
                        //
                        // Format into nicer string for user
                        //
                        WCHAR *pszTmp = LocalAlloc(LMEM_ZEROINIT,
                                                   (wcslen(NwpServerBuffer)+2) *
                                                    sizeof(WCHAR)) ;
                        if (pszTmp)
                        {
                            pszErrorLocation = pszTmp ;

                            //
                            // This code formats the NDS
                            // tree UNC to: Tree(Context)
                            //
                            wcscpy(pszErrorLocation, NwpServerBuffer+1) ;

                            if (pszTmp = wcschr(pszErrorLocation, L'\\'))
                            {
                                *pszTmp = L'(' ;
                                wcscat(pszErrorLocation, L")") ;
                            }
                        }
                    }

                    nResult = NwpMessageBoxError( 
                                  (HWND) StationHandle,
                                  IDS_AUTH_FAILURE_TITLE,
                                  dwMsgId, 
                                  status, 
                                  pszErrorLocation, 
                                  MB_YESNO | MB_ICONEXCLAMATION ); 

                    if (pszErrorLocation != NwpServerBuffer)
                    {
                        (void) LocalFree(pszErrorLocation) ;
                    }
    
                    //
                    // User chose not to select another preferred server,
                    // hence just return success.
                    //
                    if ( nResult == IDNO ) {
                        status = NO_ERROR;
                        NoLoginScript = TRUE;
                    }
                }
             
                //
                // The user might have changed the password in the password 
                // prompt dialog. Hence, we need to save the credentials 
                // ( the password ) again. Although the user might choose
                // to select another server, he might canceled out of the 
                // login dialog. We must save logon credentials here no matter
                // what.
                //
                NwpSaveLogonCredential(
                    NewUserSid,
                    lpLogonId,
                    NwpUserNameBuffer,
                    NwpPasswordBuffer,
                    NwpServerBuffer 
                    );
            }

            //
            // Only prompt user with the NetWare login dialog if
            // no preferred server was found or an error occurred
            // while authenticating the user.
            //
            if (  ( status != NO_ERROR) 
               || (*NwpServerBuffer == NW_INVALID_SERVER_CHAR)
               ) 
            {
    
                LOGINDLGPARAM LoginParam;

                if ( cPasswordDlgClickOK  > 0 )
                {
                    // Password might have changed in the password prompt 
                    // dialog. We want to always first use the NT password
                    // when validating a user on a server. Hence,
                    // we need to copy back the original NT password into
                    // NwpPasswordBuffer.
    
                    RtlZeroMemory(NwpPasswordBuffer, sizeof(NwpPasswordBuffer));
                    if (NewLogonInfo->Password.Buffer != NULL) 
                    {
                        wcsncpy(
                            NwpPasswordBuffer,
                            NewLogonInfo->Password.Buffer,
                            NewLogonInfo->Password.Length / sizeof(WCHAR)
                            );
                    }
                }
    
                LoginParam.UserName   = NwpUserNameBuffer;
                LoginParam.ServerName = NwpServerBuffer ; 
                LoginParam.Password   = NwpPasswordBuffer;
                LoginParam.NewUserSid = NewUserSid;
                LoginParam.pLogonId   = lpLogonId;
                LoginParam.ServerNameSize = sizeof( NwpServerBuffer ) /
                                            sizeof( NwpServerBuffer[0]);
                LoginParam.PasswordSize = sizeof( NwpPasswordBuffer ) /
                                          sizeof( NwpPasswordBuffer[0]);
                LoginParam.LogonScriptOptions  = NwpLogonScriptOptions;
                LoginParam.PrintOption  = NwpPrintOption;
                Result = DialogBoxParamW(
                             hmodNW,
                             MAKEINTRESOURCEW(DLG_NETWARE_LOGIN),
                             (HWND) StationHandle,
                             NwpLoginDlgProc,
                             (LPARAM) &LoginParam
                             );
    
                if (Result == -1) {
                    status = GetLastError();
                    KdPrint(("NWPROVAU: DialogBox failed %lu\n", status));
                    goto EndOfTry;
                }

            }
        }

EndOfTry: ;

    }
    RpcExcept(1) {

#if DBG
        DWORD XceptCode;


        XceptCode = RpcExceptionCode();
        IF_DEBUG(LOGON) {
            KdPrint(("NWPROVAU: NPLogonNotify: Exception code is x%08lx\n", XceptCode));
        }
        status = NwpMapRpcError(XceptCode);
#else
        status = NwpMapRpcError(RpcExceptionCode());
#endif

    }
    RpcEndExcept;

    if (!ServiceLogin && !NoLoginScript) {

        DWORD fPServer = 0;

        NwpReadLogonScriptOptions( NewUserSid,
                                   &NwpLogonScriptOptions,
                                   &fPServer );
        if ( fPServer && ( NwpLogonScriptOptions & NW_LOGONSCRIPT_ENABLED ) )
        {
            *lpLogonScript = NwpConstructLogonScript( NwpLogonScriptOptions );
             
            // 
            // set scripts to run synchronously. ignore error if we cant.
            // not a disaster.
            // 
            (void) NwrSetLogonScript(NULL, SYNC_LOGONSCRIPT) ;
        }
        else
        {
            *lpLogonScript = LocalAlloc(LMEM_ZEROINIT, sizeof(WCHAR));
        }
    }
    else 
        *lpLogonScript = NULL;

    if (NewUserSid != NULL) {
        (void) LocalFree((HLOCAL) NewUserSid);
    }

    //
    // Clear the password
    //
    RtlZeroMemory(NwpPasswordBuffer, sizeof(NwpPasswordBuffer));

    if (status == WN_NO_NETWORK) {
        //
        // We don't care if the workstation has not started because
        // we tuck the logon credential in the registry to be picked
        // up by the workstation when it starts up.  If we return
        // ERROR_NO_NETWORK, MPR will poll us forever, causing us
        // to continuously display the login dialog over and over
        // again.
        //
        status = NO_ERROR;
    }

    if (status != NO_ERROR) {
        SetLastError(status);
    }

    return status;
}



DWORD
APIENTRY
NPPasswordChangeNotify(
    LPCWSTR lpAuthentInfoType,
    LPVOID lpAuthentInfo,
    LPCWSTR lpPreviousAuthentInfoType,
    LPVOID lpPreviousAuthentInfo,
    LPWSTR lpStationName,
    LPVOID StationHandle,
    DWORD dwChangeInfo
    )
/*++

Routine Description:

    This function is called after the interactive user has selected to
    change the password for the local logon via the Ctrl-Alt-Del dialog.
    It is also called when the user cannot login because the password
    has expired and must be changed.

Arguments:

    lpAuthentInfoType - Supplies a string which if is
        L"MSV1_0:Interactive" means that the user has been logged
        on by the Microsoft primary authenticator.

    lpAuthentInfo - Supplies a pointer to the credentials to
        change to.

    lpPreviousAuthentInfoType - Supplies a pointer to the old
        credentials.

    lpPreviousAuthentInfo - Ignored.

    lpStationName - Supplies a string which if it is L"WinSta_0"
        means that Winlogon logged on the user.

    StationHandle - Supplies the handle to the window which to display
        our specific dialog.

    dwChangeInfo - Ignored.

Return Value:

    WN_SUCCESS - successful operation.

    WN_NOT_SUPPORTED - Only support change password if MS v1.0 is
        the primary authenticator and is done through Winlogon.

    WN_NO_NETWORK - Workstation service did not start.

--*/
{
    DWORD status = NO_ERROR;


    CHANGE_PW_DLG_PARAM Credential;
    LPBYTE              lpBuffer = NULL;

    PMSV1_0_INTERACTIVE_LOGON NewCredential =
        (PMSV1_0_INTERACTIVE_LOGON) lpAuthentInfo;
    PMSV1_0_INTERACTIVE_LOGON OldCredential =
        (PMSV1_0_INTERACTIVE_LOGON) lpPreviousAuthentInfo;


    DBG_UNREFERENCED_PARAMETER(lpPreviousAuthentInfoType);
    DBG_UNREFERENCED_PARAMETER(dwChangeInfo);

    RtlZeroMemory(&Credential, sizeof(CHANGE_PW_DLG_PARAM));

    RpcTryExcept {

        if ((_wcsicmp(lpAuthentInfoType, L"MSV1_0:Interactive") != 0) ||
            (_wcsicmp(lpStationName, L"WinSta0") != 0)) {

            //
            // We only handle a logon where Microsoft is the primary
            // authenticator and it is an interactive logon via Winlogon.
            //
            status = WN_NOT_SUPPORTED;
            goto EndOfTry;
        }


        if (NewCredential == NULL || OldCredential == NULL) {

            //
            // Credentials not given to us by Winlogon or
            // user did not type the old and new passwords.
            //

#if DBG
            IF_DEBUG(LOGON) {
                KdPrint(("NWPROVAU: PasswordChangeNotify got NULL for new and old credential pointers\n"));
            }
#endif

            (void) NwpMessageBoxError(
                       (HWND) StationHandle,
                       IDS_CHANGE_PASSWORD_TITLE,
                       IDS_BAD_PASSWORDS,
                       0,
                       NULL,
                       MB_OK | MB_ICONSTOP
                       );

            status = WN_NOT_SUPPORTED;
            goto EndOfTry;
        }

        lpBuffer = LocalAlloc( LMEM_ZEROINIT,
                               ( NW_MAX_USERNAME_LEN + 3 +
                                 ( 2 * NW_MAX_PASSWORD_LEN ) ) *
                               sizeof(WCHAR) );

        if (lpBuffer == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto EndOfTry;
        }

        Credential.UserName = (LPWSTR) lpBuffer;
        lpBuffer += (NW_MAX_USERNAME_LEN + 1) * sizeof(WCHAR);
        Credential.OldPassword = (LPWSTR) lpBuffer;
        lpBuffer += (NW_MAX_PASSWORD_LEN + 1) * sizeof(WCHAR);
        Credential.NewPassword = (LPWSTR) lpBuffer;

        if (NewCredential->UserName.Length == 0) {

            //
            // UserName is not specified.  Try to get interactive user's name.
            //

            DWORD CharNeeded = NW_MAX_USERNAME_LEN + 1;


#if DBG
            IF_DEBUG(LOGON) {
                KdPrint(("NWPROVAU: PasswordChangeNotify got empty string for username\n"));
            }
#endif

            if (! GetUserNameW(Credential.UserName, &CharNeeded)) {

                //
                // Could not get interactive user's name.  Give up.
                //
                (void) NwpMessageBoxError(
                           (HWND) StationHandle,
                           IDS_CHANGE_PASSWORD_TITLE,
                           0,
                           ERROR_BAD_USERNAME,
                           NULL,
                           MB_OK | MB_ICONSTOP
                           );
            }
        }
        else {
            wcsncpy(
                Credential.UserName,
                NewCredential->UserName.Buffer,
                NewCredential->UserName.Length / sizeof(WCHAR)
                );
        }

        if (OldCredential->Password.Length > 0)
        {
            wcsncpy(
                Credential.OldPassword,
                OldCredential->Password.Buffer,
                OldCredential->Password.Length / sizeof(WCHAR)
                );
        }
        else
        {
            Credential.OldPassword[0] = 0;
        }

        if (NewCredential->Password.Length > 0)
        {
            wcsncpy(
                Credential.NewPassword,
                NewCredential->Password.Buffer,
                NewCredential->Password.Length / sizeof(WCHAR)
                );
        }
        else
        {
            Credential.NewPassword[0] = 0;
        }

        //
        // Encode the passwords.
        //
        {
            UCHAR EncodeSeed = NW_ENCODE_SEED2;
            UNICODE_STRING PasswordStr;


            RtlInitUnicodeString(&PasswordStr, Credential.OldPassword);
            RtlRunEncodeUnicodeString(&EncodeSeed, &PasswordStr);

            RtlInitUnicodeString(&PasswordStr, Credential.NewPassword);
            RtlRunEncodeUnicodeString(&EncodeSeed, &PasswordStr);
        }

        NwpSelectServers(StationHandle, &Credential);

EndOfTry: ;

    }
    RpcExcept(1) {

#if DBG
        DWORD XceptCode;


        XceptCode = RpcExceptionCode();
        IF_DEBUG(LOGON) {
            KdPrint(("NWPROVAU: NPPasswordChangeNotify: Exception code is x%08lx\n", XceptCode));
        }
        status = NwpMapRpcError(XceptCode);
#else
        status = NwpMapRpcError(RpcExceptionCode());
#endif

    }
    RpcEndExcept;

    if (lpBuffer != NULL) {
        LocalFree(lpBuffer);
    }

    if (status != NO_ERROR) {
        SetLastError(status);
    }

    return status;

}


VOID
NwpInitializeRegistry(
    IN  LPWSTR NewUserSid,
    OUT LPWSTR PreferredServer,
    IN  DWORD  PreferredServerSize,
    OUT LPWSTR NdsPreferredServer,
    IN  DWORD  NdsPreferredServerSize,
    OUT PDWORD pLogonScriptOptions,
    OUT PDWORD PrintOption
    )
/*++

Routine Description:

    This routine initializes the registry before putting up the
    logon dialog.
        1) Deletes the CurrentUser value if it was not cleaned up from
           the last logoff.
        2) Reads the current user's original PreferredServer value 
        3) Reads the current user's PrintOption value 

Arguments:

    NewUserSid - Supplies the newly logged on user's SID in string format
        which is the key name to find the password and preferred server.

Return Value:

    None.

--*/
{
    LONG RegError;
    HKEY WkstaKey;


    //NwDeleteCurrentUser();       //Commented out for Multi-user code merge

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\Option
    //
    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_OPTION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,  
                   &WkstaKey
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpInitializeRegistry open NWCWorkstation\\Parameters\\Option key unexpected error %lu!\n", RegError));
        return;
    }

    //
    // Get user's preferred server information.
    //
    (void) NwpReadRegInfo(WkstaKey, 
                          NewUserSid, 
                          PreferredServer, 
                          PreferredServerSize, 
                          NdsPreferredServer, 
                          NdsPreferredServerSize, 
                          PrintOption
                          );

    (void) RegCloseKey(WkstaKey);
    (void) NwpReadLogonScriptOptions( NewUserSid, pLogonScriptOptions, NULL );
}


DWORD
NwpReadRegInfo(
    IN HKEY WkstaKey,
    IN LPWSTR CurrentUserSid,
    OUT LPWSTR PreferredServer,
    IN  DWORD  PreferredServerSize,
    OUT LPWSTR NdsPreferredServer,
    IN  DWORD  NdsPreferredServerSize,
    OUT PDWORD PrintOption
    )
/*++

Routine Description:

    This routine reads the user's preferred server and print option 
    from the registry.

Arguments:

    WkstaKey - Supplies the handle to the parameters key under the NetWare
        workstation service key.

    CurrentUserSid - Supplies the SID string of the user whose information
        to read.

    PreferredServer - Receives the user's preferred server.

    PrintOption - Receives the user's print option.

Return Value:

    None.

--*/
{
    LONG RegError;

    HKEY UserKey;

    DWORD ValueType;
    DWORD BytesNeeded;

    //
    // Open current user's key to read the original preferred server.
    //
    RegError = RegOpenKeyExW(
                   WkstaKey,
                   CurrentUserSid,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &UserKey
                   );

    if (RegError != NO_ERROR) {

        if ( (RegError == ERROR_FILE_NOT_FOUND) ||
             (RegError == ERROR_PATH_NOT_FOUND) ) {

            //
            // If key doesnt exist assume first time. Use default
            // if present.
            //
            
            LONG RegError1 ;
            HKEY WkstaParamKey ;
            DWORD Disposition, dwScriptOptions,
                  dwScriptOptionsSize = sizeof(dwScriptOptions);
            
            //
            // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
            // \NWCWorkstation\Parameters
            //
            RegError1 = RegOpenKeyExW(
                            HKEY_LOCAL_MACHINE,
                            NW_WORKSTATION_REGKEY,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,  
                            &WkstaParamKey
                            );

            if (RegError1 != NO_ERROR) {

                return (DWORD) RegError; // return original error
            }

            BytesNeeded = PreferredServerSize;
            
            RegError1 = RegQueryValueExW(
                           WkstaParamKey,
                           NW_DEFAULTSERVER_VALUENAME,
                           NULL,
                           &ValueType,
                           (LPBYTE) PreferredServer,
                           &BytesNeeded
                           );


            if (RegError1 != NO_ERROR) {

                (void) RegCloseKey(WkstaParamKey);
                PreferredServer[0] = NW_INVALID_SERVER_CHAR;  
                PreferredServer[1] = 0;  
                return (DWORD) RegError; // return original error
            }

            RegError1 = RegQueryValueExW(
                           WkstaParamKey,
                           NW_DEFAULTSCRIPTOPTIONS_VALUENAME,
                           NULL,
                           &ValueType,
                           (LPBYTE) &dwScriptOptions,
                           &dwScriptOptionsSize
                           );

            (void) RegCloseKey(WkstaParamKey);

            if (RegError1 != NO_ERROR) {

                dwScriptOptions = NW_LOGONSCRIPT_ENABLED | 
                                  NW_LOGONSCRIPT_4X_ENABLED ;
            }

            //
            // We have a default. now write out the info for the current
            // user now.  Note we also write out the login script option.
            // Errors here are not reported.
            //


            //
            // Create the key under NWCWorkstation\Parameters\Option\<usersid>
            //
            RegError = RegCreateKeyExW(
                           WkstaKey,
                           CurrentUserSid,
                           0,
                           WIN31_CLASS,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE | WRITE_DAC,
                           NULL,                      // security attr
                           &UserKey,
                           &Disposition
                           );

            if (RegError == NO_ERROR) {
    
                RegError = NwLibSetEverybodyPermission( UserKey, 
                                                        KEY_SET_VALUE );

                if ( RegError == NO_ERROR ) 
                {
                    //
                    // Write the PreferredServer. Errors ignored.
                    //
                    RegError = RegSetValueExW(
                                   UserKey,
                                   NW_SERVER_VALUENAME,
                                   0,
                                   REG_SZ,
                                   (LPVOID) PreferredServer,
                                   (wcslen(PreferredServer) + 1) * sizeof(WCHAR)
                                   );
        
                    (void) RegCloseKey(UserKey) ;
    
                    (void) NwpSaveLogonScriptOptions( 
                               CurrentUserSid, 
                               dwScriptOptions
                               ) ;
                }
                else {
                    
                    (void) RegCloseKey(UserKey) ;
                }
            }


            *PrintOption = NW_PRINT_OPTION_DEFAULT; 
            return NO_ERROR;

        }
        return (DWORD) RegError;
    }


    //
    // Read PreferredServer value 
    //
    BytesNeeded = PreferredServerSize;

    RegError = RegQueryValueExW(
                   UserKey,
                   NW_SERVER_VALUENAME,
                   NULL,
                   &ValueType,
                   (LPBYTE) PreferredServer,
                   &BytesNeeded
                   );

    ASSERT(BytesNeeded <= PreferredServerSize);

    if (RegError != NO_ERROR) {
#if DBG
        IF_DEBUG(LOGON) {
            KdPrint(("NWPROVAU: Attempt to read original preferred server failed %lu\n",
                     RegError));
        }
#endif
        PreferredServer[0] = NW_INVALID_SERVER_CHAR;  // Display login dialog
        PreferredServer[1] = 0;  
        goto CleanExit;
    }

    //
    // Read NdsPreferredServer value 
    //
    BytesNeeded = NdsPreferredServerSize;

    RegError = RegQueryValueExW(
                   UserKey,
                   NW_NDS_SERVER_VALUENAME,
                   NULL,
                   &ValueType,
                   (LPBYTE) NdsPreferredServer,
                   &BytesNeeded
                   );

    ASSERT(BytesNeeded <= NdsPreferredServerSize);

    if (RegError != NO_ERROR) {
#if DBG
        IF_DEBUG(LOGON) {
            KdPrint(("NWPROVAU: Attempt to read NDS preferred server failed %lu\n",
                     RegError));
        }
#endif
        NdsPreferredServer[0] = 0;
        NdsPreferredServer[1] = 0;  
    goto CleanExit;
    }
    

CleanExit:

    //
    // Read PrintOption value into NwpPrintOption.
    //
    BytesNeeded = sizeof(PrintOption);

    RegError = RegQueryValueExW(
                   UserKey,
                   NW_PRINTOPTION_VALUENAME,
                   NULL,
                   &ValueType,
                   (LPBYTE) PrintOption,
                   &BytesNeeded
                   );

    if (RegError != NO_ERROR ) {
#if DBG
        IF_DEBUG(LOGON) {
            KdPrint(("NWPROVAU: Attempt to read original print option failed %lu\n", RegError));
        }
#endif

        *PrintOption = NW_PRINT_OPTION_DEFAULT; 
    }

    (void) RegCloseKey(UserKey);

    return NO_ERROR;
}

DWORD
NwpReadLogonScriptOptions(
    IN LPWSTR CurrentUserSid,
    OUT PDWORD pLogonScriptOptions,
    OUT PDWORD pPreferredServerExists

    )
/*++

Routine Description:

    This routine reads the user's logon script options from the registry.

Arguments:

    CurrentUserSid - Supplies the SID string of the user whose information
        to read.

    pLogonScriptOptions - Receives the user's script options

    pPreferredServerExists - Prefered server specified

Return Value:

    None.

--*/
{
    LONG RegError;

    HKEY UserKey;

    DWORD ValueType;
    DWORD BytesNeeded;
    HKEY WkstaKey;
    WCHAR PreferredServer[MAX_PATH + 1];

    //
    // initialize output values
    //
    *pLogonScriptOptions = NW_LOGONSCRIPT_DEFAULT;

    if (pPreferredServerExists)
        *pPreferredServerExists = 0 ;


    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\Option
    //
    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_OPTION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,  
                   &WkstaKey
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpReadLogonScriptOptions open NWCWorkstation\\Parameters\\Option key unexpected error %lu!\n", RegError));
        return (DWORD) RegError;
    }

    //
    // Open current user's key 
    //
    RegError = RegOpenKeyExW(
                   WkstaKey,
                   CurrentUserSid,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &UserKey
                   );

    if (RegError != NO_ERROR) {
#if DBG
        IF_DEBUG(LOGON) {
            KdPrint(("NWPROVAU: Open of CurrentUser %ws existing key failed %lu\n",
                     CurrentUserSid, RegError));
        }
#endif
        (void) RegCloseKey(WkstaKey);
        return (DWORD) RegError;
    }


    //
    // Read LogonScriptOption value
    //
    BytesNeeded = sizeof(*pLogonScriptOptions);

    RegError = RegQueryValueExW(
                   UserKey,
                   NW_LOGONSCRIPT_VALUENAME,
                   NULL,
                   &ValueType,
                   (LPBYTE) pLogonScriptOptions,
                   &BytesNeeded
                   );

    if (RegError != NO_ERROR ) {
#if DBG
        IF_DEBUG(LOGON) {
            KdPrint(("NWPROVAU: Attempt to read original logon script option failed %lu\n", RegError));
        }
#endif

        // leave *pLogonScriptOptions as 0
    }

    if ( pPreferredServerExists != NULL ) {

        //
        // Read PreferredServer value 
        //
        BytesNeeded = sizeof( PreferredServer );

        RegError = RegQueryValueExW(
                       UserKey,
                       NW_SERVER_VALUENAME,
                       NULL,
                       &ValueType,
                       (LPBYTE) PreferredServer,
                       &BytesNeeded
                       );

        ASSERT(BytesNeeded <= sizeof(PreferredServer));

        if (RegError != NO_ERROR) {
#if DBG
            IF_DEBUG(LOGON) {
                KdPrint(("NWPROVAU: Attempt to read original preferred server failed %lu\n",
                         RegError));
            }
#endif
            *pPreferredServerExists = FALSE;
        }
    else {
        if ( lstrcmp( PreferredServer, L"" ) ) 
                *pPreferredServerExists = TRUE;
            else
                *pPreferredServerExists = FALSE;
    }
    }

    (void) RegCloseKey(UserKey);
    (void) RegCloseKey(WkstaKey);

    return NO_ERROR;
}

LPWSTR
NwpConstructLogonScript(
    IN DWORD LogonScriptOptions
)
/*++

Routine Description:

    This routine constructs the multi-string for the logon script,
    based on the options

Arguments:

    LogonScriptOptions - Logon Script options

Return Value:

    Allocated multi-string

--*/
{
    LPWSTR pLogonScript;
    DWORD BytesNeeded;

#define NW_NETWARE_SCRIPT_NAME       L"nwscript.exe"
#define NW_NETWARE_DEBUG_NAME        L"ntsd "

    if ( !( LogonScriptOptions & NW_LOGONSCRIPT_ENABLED ) ) {
        return NULL;
    }

    BytesNeeded = MAX_PATH * sizeof(WCHAR);

    if (pLogonScript = LocalAlloc( LMEM_ZEROINIT, BytesNeeded))
    {
        DWORD dwSkipBytes = 0 ;
        UINT  retval ;

#if DBG
        //
        // if have exact match then start under NTSD.
        //
        if ( LogonScriptOptions == (NW_LOGONSCRIPT_ENABLED |
                                    NW_LOGONSCRIPT_4X_ENABLED |
                                    NW_LOGONSCRIPT_DEBUG) ) {

            retval = GetSystemDirectory(pLogonScript,
                                        BytesNeeded );
            if (retval == 0) {

                (void)LocalFree(pLogonScript) ;
                return(NULL) ;
            }
            wcscat( pLogonScript, L"\\" );
            wcscat( pLogonScript, NW_NETWARE_DEBUG_NAME );
            dwSkipBytes = (retval * sizeof(WCHAR)) +
                          sizeof(NW_NETWARE_DEBUG_NAME) ;
            BytesNeeded -= dwSkipBytes ;
        }
#endif

        retval = GetSystemDirectory(pLogonScript + (dwSkipBytes/sizeof(WCHAR)),
                                    BytesNeeded );

        if (retval == 0) {

            (void)LocalFree(pLogonScript) ;
            return(NULL) ;
        }

        wcscat( pLogonScript, L"\\" );
        wcscat( pLogonScript, NW_NETWARE_SCRIPT_NAME );
    }

    return (pLogonScript);

}

DWORD
NwpSaveLogonScriptOptions(
    IN LPWSTR CurrentUserSid,
    IN DWORD LogonScriptOptions
    )
/*++

Routine Description:

    This routine saves the logon script options in the registry.

Arguments:

    CurrentUserSid - Supplies the user's SID string 

    LogonScriptOptions - Logon script options

Return Value:

    Error from registry

--*/
{
    LONG RegError;
    HKEY WkstaOptionKey;
    HKEY CurrentUserOptionKey;

    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\Option
    //
    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_OPTION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE | KEY_CREATE_SUB_KEY | DELETE,
                   &WkstaOptionKey
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveLogonScriptOptions open NWCWorkstation\\Parameters\\Option key unexpected error %lu!\n", RegError));
        return RegError;
    }

    //
    // Open the <NewUser> key under Option
    //
    RegError = RegOpenKeyExW(
                   WkstaOptionKey,
                   CurrentUserSid,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE,
                   &CurrentUserOptionKey
                   );

    (void) RegCloseKey(WkstaOptionKey);

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveLogonScriptOptions failed to save options %lu\n", RegError));
        return RegError;
    }

    //
    // Write the options
    //
    RegError = RegSetValueExW(
                   CurrentUserOptionKey,
                   NW_LOGONSCRIPT_VALUENAME,
                   0,
                   REG_DWORD,
                   (LPVOID) &LogonScriptOptions,
                   sizeof(LogonScriptOptions)
                   );

    (void) RegCloseKey(CurrentUserOptionKey);

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveLogonScriptOptions failed to save options %lu\n", RegError));
    }

    return RegError;

}


VOID
NwpSaveLogonCredential(
    IN LPWSTR NewUserSid,
    IN PLUID  LogonId,
    IN LPWSTR UserName,
    IN LPWSTR Password,
    IN LPWSTR PreferredServer OPTIONAL
    )
/*++

Routine Description:

    This routine saves the user logon credential in the registry
    and LSA's memory.  This is normally called when NwrLogonUser is
    successful.

Arguments:

    NewUserSid - Supplies the newly logged on user's SID string to be
        set as the CurrentUser value as well as the name of the key for
        the user's preferred server.

    LogonId - Supplies the user's logon ID.  If NULL is specified,
        just read the existing logon ID from the registry rather
        than save a new one.

    UserName - Supplies the name of the user.

    Password - Supplies the password which the user wants to use on
        the NetWare network.

    PreferredServer - Supplies the name of the preferred server.

Return Value:

    Error from redirector if login is rejected.

--*/
{

    DWORD status;

    LONG RegError;
    HKEY WkstaOptionKey;
    HKEY NewUserOptionKey;

#define SIZE_OF_LOGONID_TOKEN_INFORMATION sizeof( ULONG )

    HKEY   InteractiveLogonKey;
    HKEY   LogonIdKey;
    DWORD  Disposition;
    WCHAR  LogonIdKeyName[NW_MAX_LOGON_ID_LEN];
    HANDLE TokenHandle;
    UCHAR  TokenInformation[ SIZE_OF_LOGONID_TOKEN_INFORMATION ];
    ULONG  ReturnLength;
    ULONG  WinStationId = 0L;

#if DBG
    IF_DEBUG(LOGON) {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential: %ws, %ws, %ws, %ws\n",
                 NewUserSid, UserName, Password, PreferredServer));
    }
#endif

    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\Option
    //
    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_OPTION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE | KEY_CREATE_SUB_KEY | DELETE,
                   &WkstaOptionKey
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential open NWCWorkstation\\Parameters\\Option key unexpected error %lu!\n", RegError));
        return;
    }

    //
    // Open the <NewUser> key under Option
    //
    RegError = RegOpenKeyExW(
                   WkstaOptionKey,
                   NewUserSid,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE,
                   &NewUserOptionKey
                   );


    if (RegError == ERROR_FILE_NOT_FOUND) 
    {
        DWORD Disposition;

        //
        // Create <NewUser> key under NWCWorkstation\Parameters\Option
        //
        RegError = RegCreateKeyExW(
                       WkstaOptionKey,
                       NewUserSid,
                       0,
                       WIN31_CLASS,
                       REG_OPTION_NON_VOLATILE,
                       KEY_WRITE | WRITE_DAC,
                       NULL,                      // security attr
                       &NewUserOptionKey,
                       &Disposition
                       );


        if (RegError != NO_ERROR) {
            KdPrint(("NWPROVAU: NwpSaveLogonCredential create Option\\%ws key unexpected error %lu!\n", NewUserSid, RegError));

            (void) RegCloseKey(WkstaOptionKey);
            return;
        }

        RegError = NwLibSetEverybodyPermission( NewUserOptionKey, 
                                                KEY_SET_VALUE );

        if ( RegError != NO_ERROR ) 
        {
            KdPrint(("NWPROVAU: NwpSaveLogonCredential set security on Option\\%ws key unexpected error %lu!\n", NewUserSid, RegError));

            (void) RegCloseKey(WkstaOptionKey);
            return;
        }

    }
    else if (RegError != NO_ERROR) 
    {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential open Option\\%ws unexpected error %lu!\n", NewUserSid, RegError));

        (void) RegCloseKey(WkstaOptionKey);
        return;
    }

    (void) RegCloseKey(WkstaOptionKey);

    //
    // Successfully opened or created an existing user entry.  
    // We will now save the credential in LSA.
    //
    status = NwpSetCredentialInLsa(
                 LogonId,
                 UserName,
                 Password
                 );

    if (status != NO_ERROR) {
        //
        // Could not save new credential.
        //
        KdPrint(("NWPROVAU: NwpSaveLogonCredential failed to set credential %lu\n", status));
    }


    //
    // If PreferredServer is not supplied, then that means we don't want to
    // save the preferred server into the registry.
    //

    if (ARGUMENT_PRESENT(PreferredServer)) 
    {
        //
        // Write the PreferredServer
        //
        RegError = RegSetValueExW(
                       NewUserOptionKey,
                       NW_SERVER_VALUENAME,
                       0,
                       REG_SZ,
                       (LPVOID) PreferredServer,
                       (wcslen(PreferredServer) + 1) * sizeof(WCHAR)
                       );


        if (RegError != NO_ERROR) {
            KdPrint(("NWPROVAU: NwpSaveLogonCredential failed to save PreferredServer %ws %lu\n", PreferredServer, RegError));
        }
    }

    (void) RegCloseKey(NewUserOptionKey);

    //
    // Write the logon ID to the registry.
    // This replaces the single user CURRENTUSER stuff

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\InteractiveLogon, create if does not exist
    //
    RegError = RegCreateKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_INTERACTIVE_LOGON_REGKEY,
                   0,
                   WIN31_CLASS,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE,
                   NULL,                      // security attr
                   &InteractiveLogonKey,
                   &Disposition
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential open NWCWorkstation\\Parameters\\InteractiveLogon key unexpected error %lu!\n", RegError));
        return;
    }

    NwLuidToWStr(LogonId, LogonIdKeyName);

    //
    // Create the logon ID key under ServiceLogon
    //
    RegError = RegCreateKeyExW(
                   InteractiveLogonKey,
                   LogonIdKeyName,
                   0,
                   WIN31_CLASS,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE,
                   NULL,                      // security attr
                   &LogonIdKey,
                   &Disposition
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveInteractiveCredential create NWCWorkstation\\Parameters\\InteractiveLogon\\<LogonId> key unexpected error %lu!\n", RegError));
        RegCloseKey(InteractiveLogonKey);
        return;
    }

    // We can use OpenProcessToken because this thread is a client
    // I.E. It should be WinLogon

    if ( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_READ,
                           &TokenHandle ))
    {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential OpenThreadToken failed: Error %d\n", GetLastError()));
        goto NoWinStation;
    }

    // notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure


    if ( !GetTokenInformation( TokenHandle,
                               TokenSessionId,
                               TokenInformation,
                               sizeof( TokenInformation ),
                               &ReturnLength ))
    {
        KdPrint(("NWPROVAU NwpSaveLogonCredential: GetTokenInformation failed: Error %d\n",
                   GetLastError()));
        CloseHandle( TokenHandle );
        goto NoWinStation;
    }


    WinStationId = *(PULONG)TokenInformation;

    CloseHandle( TokenHandle );

NoWinStation:

    //
    // Write the WinStation ID to the registry.
    //
    RegError = RegSetValueExW(
                   LogonIdKey,
                   NW_WINSTATION_VALUENAME,
                   0,
                   REG_BINARY,
                   (LPVOID) &WinStationId,
                   sizeof(WinStationId)
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential failed to save Winstation ID %lu\n", RegError));
    }

    RegError = RegSetValueExW(
                   LogonIdKey,
                   NW_SID_VALUENAME,
                   0,
                   REG_SZ,
                   (LPVOID) NewUserSid,
                   (wcslen(NewUserSid) + 1) * sizeof(WCHAR)
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential failed to save NewUser %ws %lu\n", NewUserSid, RegError));
    }

    RegCloseKey(LogonIdKey);
    RegCloseKey(InteractiveLogonKey);

}

VOID
NwpSaveLogonCredentialMultiUser(
    IN LPWSTR NewUserSid,
    IN PLUID  LogonId,
    IN LPWSTR UserName,
    IN LPWSTR Password,
    IN LPWSTR PreferredServer OPTIONAL
    )
{
    DWORD status;

    LONG RegError;
    HKEY WkstaOptionKey;
    HKEY NewUserOptionKey;
#define SIZE_OF_LOGONID_TOKEN_INFORMATION sizeof( ULONG )

    HKEY   InteractiveLogonKey;
    HKEY   LogonIdKey;
    DWORD  Disposition;
    WCHAR  LogonIdKeyName[NW_MAX_LOGON_ID_LEN];
    HANDLE TokenHandle;
    UCHAR  TokenInformation[ SIZE_OF_LOGONID_TOKEN_INFORMATION ];
    ULONG  ReturnLength;
    ULONG  WinStationId = 0L;


    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\Option
    //
    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_OPTION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE | KEY_CREATE_SUB_KEY | DELETE,
                   &WkstaOptionKey
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential open NWCWorkstation\\Parameters\\Option key unexpected error %lu!\n", RegError));
        return;
    }


    //
    // Open the <NewUser> key under Option
    //
    RegError = RegOpenKeyExW(
                   WkstaOptionKey,
                   NewUserSid,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE,
                   &NewUserOptionKey
                   );


    if (RegError == ERROR_FILE_NOT_FOUND) 
    {
        DWORD Disposition;

        //
        // Create <NewUser> key under NWCWorkstation\Parameters\Option
        //
        RegError = RegCreateKeyExW(
                       WkstaOptionKey,
                       NewUserSid,
                       0,
                       WIN31_CLASS,
                       REG_OPTION_NON_VOLATILE,
                       KEY_WRITE | WRITE_DAC,
                       NULL,                      // security attr
                       &NewUserOptionKey,
                       &Disposition
                       );


        if (RegError != NO_ERROR) {
            KdPrint(("NWPROVAU: NwpSaveLogonCredential create Option\\%ws key unexpected error %lu!\n", NewUserSid, RegError));

            (void) RegCloseKey(WkstaOptionKey);
            return;
        }

        RegError = NwLibSetEverybodyPermission( NewUserOptionKey, 
                                                KEY_SET_VALUE );

        if ( RegError != NO_ERROR ) 
        {
            KdPrint(("NWPROVAU: NwpSaveLogonCredential set security on Option\\%ws key unexpected error %lu!\n", NewUserSid, RegError));

            (void) RegCloseKey(WkstaOptionKey);
            return;
        }

    }
    else if (RegError != NO_ERROR) 
    {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential open Option\\%ws unexpected error %lu!\n", NewUserSid, RegError));

        (void) RegCloseKey(WkstaOptionKey);
        return;
    }

    (void) RegCloseKey(WkstaOptionKey);

    //
    // Successfully opened or created an existing user entry.  
    // We will now save the credential in LSA.
    //
    status = NwpSetCredentialInLsa(
                 LogonId,
                 UserName,
                 Password
                 );

    if (status != NO_ERROR) {
        //
        // Could not save new credential.
        //
        KdPrint(("NWPROVAU: NwpSaveLogonCredential failed to set credential %lu\n", status));
    }


    //
    // If PreferredServer is not supplied, then that means we don't want to
    // save the preferred server into the registry.
    //

    if (ARGUMENT_PRESENT(PreferredServer)) 
    {
        //
        // Write the PreferredServer
        //
        RegError = RegSetValueExW(
                       NewUserOptionKey,
                       NW_SERVER_VALUENAME,
                       0,
                       REG_SZ,
                       (LPVOID) PreferredServer,
                       (wcslen(PreferredServer) + 1) * sizeof(WCHAR)
                       );


        if (RegError != NO_ERROR) {
            KdPrint(("NWPROVAU: NwpSaveLogonCredential failed to save PreferredServer %ws %lu\n", PreferredServer, RegError));
        }
    }

    (void) RegCloseKey(NewUserOptionKey);

    //
    // Write the logon ID to the registry.
    // This replaces the single user CURRENTUSER stuff

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\InteractiveLogon, create if does not exist
    //
    RegError = RegCreateKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_INTERACTIVE_LOGON_REGKEY,
                   0,
                   WIN31_CLASS,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE,
                   NULL,                      // security attr
                   &InteractiveLogonKey,
                   &Disposition
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential open NWCWorkstation\\Parameters\\InteractiveLogon key unexpected error %lu!\n", RegError));
        return;
    }

    NwLuidToWStr(LogonId, LogonIdKeyName);

    //
    // Create the logon ID key under ServiceLogon
    //
    RegError = RegCreateKeyExW(
                   InteractiveLogonKey,
                   LogonIdKeyName,
                   0,
                   WIN31_CLASS,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE,
                   NULL,                      // security attr
                   &LogonIdKey,
                   &Disposition
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveInteractiveCredential create NWCWorkstation\\Parameters\\InteractiveLogon\\<LogonId> key unexpected error %lu!\n", RegError));
        RegCloseKey(InteractiveLogonKey);
        return;
    }

    // We can use OpenProcessToken because this thread is a client
    // I.E. It should be WinLogon

    if ( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_READ,
                           &TokenHandle ))
    {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential OpenThreadToken failed: Error %d\n", GetLastError()));
        goto NoWinStation;
    }

    // notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure


    if ( !GetTokenInformation( TokenHandle,
                               TokenSessionId,
                               TokenInformation,
                               sizeof( TokenInformation ),
                               &ReturnLength ))
    {
        KdPrint(("NWPROVAU NwpSaveLogonCredential: GetTokenInformation failed: Error %d\n",
                   GetLastError()));
        CloseHandle( TokenHandle );
        goto NoWinStation;
    }


    WinStationId = *(PULONG)TokenInformation;

    CloseHandle( TokenHandle );

NoWinStation:

    //
    // Write the WinStation ID to the registry.
    //
    RegError = RegSetValueExW(
                   LogonIdKey,
                   NW_WINSTATION_VALUENAME,
                   0,
                   REG_BINARY,
                   (LPVOID) &WinStationId,
                   sizeof(WinStationId)
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential failed to save Winstation ID %lu\n", RegError));
    }

    RegError = RegSetValueExW(
                   LogonIdKey,
                   NW_SID_VALUENAME,
                   0,
                   REG_SZ,
                   (LPVOID) NewUserSid,
                   (wcslen(NewUserSid) + 1) * sizeof(WCHAR)
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveLogonCredential failed to save NewUser %ws %lu\n", NewUserSid, RegError));
    }

    RegCloseKey(LogonIdKey);
    RegCloseKey(InteractiveLogonKey);

}

VOID
NwpSaveServiceCredential(
    IN PLUID  LogonId,
    IN LPWSTR UserName,
    IN LPWSTR Password
    )
/*++

Routine Description:

    This routine saves the service logon ID in the registry and
    the credential in LSA's memory.

Arguments:

    LogonId - Supplies the service's logon ID.

    UserName - Supplies the name of the service.

    Password - Supplies the password of the service.

Return Value:

    None.

--*/
{
    DWORD status;

    LONG RegError;
    HKEY ServiceLogonKey;
    HKEY LogonIdKey;

    DWORD Disposition;
    WCHAR LogonIdKeyName[NW_MAX_LOGON_ID_LEN];

    //
    // Write the logon ID to the registry.

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\ServiceLogon, create if does not exist
    //
    RegError = RegCreateKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_SERVICE_LOGON_REGKEY,
                   0,
                   WIN31_CLASS,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE,
                   NULL,                      // security attr
                   &ServiceLogonKey,
                   &Disposition
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveServiceCredential open NWCWorkstation\\Parameters\\ServiceLogon key unexpected error %lu!\n", RegError));
        return;
    }

    NwLuidToWStr(LogonId, LogonIdKeyName);

    //
    // Create the logon ID key under ServiceLogon
    //
    RegError = RegCreateKeyExW(
                   ServiceLogonKey,
                   LogonIdKeyName,
                   0,
                   WIN31_CLASS,
                   REG_OPTION_NON_VOLATILE,
                   KEY_WRITE,
                   NULL,                      // security attr
                   &LogonIdKey,
                   &Disposition
                   );

    RegCloseKey(ServiceLogonKey);

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpSaveServiceCredential create NWCWorkstation\\Parameters\\ServiceLogon\\<LogonId> key unexpected error %lu!\n", RegError));
        return;
    }

    RegCloseKey(LogonIdKey);

    //
    // Save the service logon credential in LSA.
    //
    status = NwpSetCredentialInLsa(
                 LogonId,
                 UserName,
                 Password
                 );

    if (status != NO_ERROR) {
        //
        // Could not save new credential.
        //
        KdPrint(("NWPROVAU: NwpSaveServiceCredential failed to set credential %lu\n", status));
    }
}


DWORD
NwpGetUserSid(
    IN PLUID LogonId,
    OUT LPWSTR *UserSidString
    )
/*++

Routine Description:

    This routine looks up the SID of a user given the user's logon ID.
    It does this by making the current process a logon process and then
    call to LSA to get the user SID.

Arguments:

    LogonId - Supplies the logon ID of the user to lookup the SID.

    UserSidString - Receives a pointer to a buffer allocated by this routine
        which contains the user SID in string form.  This must be freed with
        LocalFree when done.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    NTSTATUS AuthPackageStatus;

    STRING InputString;
    LSA_OPERATIONAL_MODE SecurityMode = 0;

    HANDLE LsaHandle;
    ULONG AuthPackageId;

    MSV1_0_GETUSERINFO_REQUEST UserInfoRequest;
    PMSV1_0_GETUSERINFO_RESPONSE UserInfoResponse = NULL;
    ULONG UserInfoResponseLength;




    //
    // Register this process as a logon process so that we can call
    // MS V 1.0 authentication package.
    //
    RtlInitString(&InputString, "Microsoft NetWare Credential Manager");

    ntstatus = LsaRegisterLogonProcess(
                   &InputString,
                   &LsaHandle,
                   &SecurityMode
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: LsaRegisterLogonProcess returns x%08lx\n",
                 ntstatus));
        return RtlNtStatusToDosError(ntstatus);
    }

    //
    // Look up the MS V1.0 authentication package
    //
    RtlInitString(&InputString, MSV1_0_PACKAGE_NAME);

    ntstatus = LsaLookupAuthenticationPackage(
                   LsaHandle,
                   &InputString,
                   &AuthPackageId
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: LsaLookupAuthenticationPackage returns x%08lx\n",
                 ntstatus));
        status = RtlNtStatusToDosError(ntstatus);
        goto CleanExit;
    }

    //
    // Ask authentication package for user information.
    //
    UserInfoRequest.MessageType = MsV1_0GetUserInfo;
    RtlCopyLuid(&UserInfoRequest.LogonId, LogonId);

    ntstatus = LsaCallAuthenticationPackage(
                   LsaHandle,
                   AuthPackageId,
                   &UserInfoRequest,
                   sizeof(MSV1_0_GETUSERINFO_REQUEST),
                   (PVOID *) &UserInfoResponse,
                   &UserInfoResponseLength,
                   &AuthPackageStatus
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = AuthPackageStatus;
    }
    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: LsaCallAuthenticationPackage returns x%08lx\n",
                 ntstatus));
        status = RtlNtStatusToDosError(ntstatus);
        goto CleanExit;
    }

    //
    // Convert the SID to string.  This routine also allocates the
    // output buffer.
    //
    status = NwpConvertSid(
                 UserInfoResponse->UserSid,
                 UserSidString
                 );

CleanExit:
    if (UserInfoResponse != NULL) {
        (void) LsaFreeReturnBuffer((PVOID) UserInfoResponse);
    }

    (void) LsaDeregisterLogonProcess(LsaHandle);

    return status;
}


DWORD
NwpConvertSid(
    IN PSID Sid,
    OUT LPWSTR *UserSidString
    )
{
    NTSTATUS ntstatus;
    UNICODE_STRING SidString;


    //
    // Initialize output pointer
    //
    *UserSidString = NULL;

    ntstatus = RtlConvertSidToUnicodeString(
                  &SidString,
                  Sid,
                  TRUE       // Allocate destination string
                  );

    if (ntstatus != STATUS_SUCCESS) {
        KdPrint(("NWPROVAU: RtlConvertSidToUnicodeString returns %08lx\n",
                 ntstatus));
        return RtlNtStatusToDosError(ntstatus);
    }

    //
    // Create the buffer to return the SID string
    //
    if ((*UserSidString = (LPVOID) LocalAlloc(
                                       LMEM_ZEROINIT,
                                       SidString.Length + sizeof(WCHAR)
                                       )) == NULL) {
        RtlFreeUnicodeString(&SidString);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(*UserSidString, SidString.Buffer, SidString.Length);

    RtlFreeUnicodeString(&SidString);

#if DBG
    IF_DEBUG(LOGON) {
        KdPrint(("NWPROVAU: NwpConvertSid got %ws\n", *UserSidString));
    }
#endif

    return NO_ERROR;
}


BOOL
NwpPollWorkstationStart(
    VOID
    )
/*++

Routine Description:

    This routine polls for the workstation to complete starting.
    It gives up after 90 seconds.

Arguments:

    None.

Return Value:

    Returns TRUE if the NetWare workstation is running; FALSE otherwise.

--*/
{
    DWORD err;
    SC_HANDLE ScManager = NULL;
    SC_HANDLE Service = NULL;
    SERVICE_STATUS ServiceStatus;
    DWORD TryCount = 0;
    BOOL Started = FALSE;


    if ((ScManager = OpenSCManager(
                         NULL,
                         NULL,
                         SC_MANAGER_CONNECT
                         )) == (SC_HANDLE) NULL) {

        err = GetLastError();

        KdPrint(("NWPROVAU: NwpPollWorkstationStart: OpenSCManager failed %lu\n",
                 err));
        goto CleanExit;
    }

    if ((Service = OpenService(
                       ScManager,
                       NW_WORKSTATION_SERVICE,
                       SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG
                       )) == (SC_HANDLE) NULL) {

        err = GetLastError();

        (void) CloseServiceHandle(ScManager);

        KdPrint(("NWPROVAU: NwpPollWorkstationStart: OpenService failed %lu\n",
                 err));
        goto CleanExit;
    }


    do {
        if (! QueryServiceStatus(
                  Service,
                  &ServiceStatus
                  )) {

            err = GetLastError();
            KdPrint(("NWPROVAU: NwpPollWorkstationStart: QueryServiceStatus failed %lu\n",
                     err));
            goto CleanExit;
        }

        if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
             (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
             (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
             (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {

            Started = TRUE;
        }
        else if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING ||
                 (ServiceStatus.dwCurrentState == SERVICE_STOPPED &&
                  ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED)) {

            //
            // If workstation is stopped and never started before but it's
            // not auto-start, don't poll.
            //
            if (TryCount == 0 &&
                ServiceStatus.dwCurrentState == SERVICE_STOPPED &&
                ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED) {

                BYTE OutBuffer[sizeof(QUERY_SERVICE_CONFIGW) + 256];
                DWORD BytesNeeded;


                if (QueryServiceConfigW(
                        Service,
                        (LPQUERY_SERVICE_CONFIGW) OutBuffer,
                        sizeof(OutBuffer),
                        &BytesNeeded
                        )) {

                    if (((LPQUERY_SERVICE_CONFIGW) OutBuffer)->dwStartType !=
                        SERVICE_AUTO_START) {

#if DBG
                        IF_DEBUG(LOGON) {
                            KdPrint(("NWPROVAU: NwpPollWorkstationStart: Not waiting for the workstation to start\n"));
                        }
#endif

                        goto CleanExit;
                    }
                }
                else {
                    err = GetLastError();
                    KdPrint(("NWPROVAU: QueryServiceConfig failed %lu, BytesNeeded %lu\n",
                             err, BytesNeeded));
                }

            }


            //
            // Wait only if the workstation is start pending, or it has not
            // been attempted to start before.
            //

            Sleep(5000);  // Sleep for 5 seconds before rechecking.
            TryCount++;
        }
        else {
            goto CleanExit;
        }

    } while (! Started && TryCount < 18);

    if (Started) {

#if DBG
        IF_DEBUG(LOGON) {
            KdPrint(("NWPROVAU: NetWare workstation is started after we've polled %lu times\n",
                     TryCount));
        }
#endif

    }

CleanExit:
    if (ScManager != NULL) {
        (void) CloseServiceHandle(ScManager);
    }

    if (Service != NULL) {
        (void) CloseServiceHandle(Service);
    }

    return Started;
}



DWORD
NwpSetCredentialInLsa(
    IN PLUID LogonId,
    IN LPWSTR UserName,
    IN LPWSTR Password
    )
/*++

Routine Description:

    This routine calls to the NetWare authentication package to save
    the user credential.

Arguments:

    LogonId - Supplies the logon ID of the user.

    UserName - Supplies the username.

    Password - Supplies the password.


Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    NTSTATUS AuthPackageStatus;

    STRING InputString;
    LSA_OPERATIONAL_MODE SecurityMode = 0;

    HANDLE LsaHandle;

    ULONG AuthPackageId;

    NWAUTH_SET_CREDENTIAL_REQUEST SetCredRequest;
    PCHAR DummyOutput;
    ULONG DummyOutputLength;

    UNICODE_STRING PasswordStr;
    UCHAR EncodeSeed = NW_ENCODE_SEED;


    //
    // Register this process as a logon process so that we can call
    // NetWare authentication package.
    //
    RtlInitString(&InputString, "Microsoft NetWare Credential Manager");

    ntstatus = LsaRegisterLogonProcess(
                   &InputString,
                   &LsaHandle,
                   &SecurityMode
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: NwpSetCredential: LsaRegisterLogonProcess returns x%08lx\n",
                 ntstatus));
        return RtlNtStatusToDosError(ntstatus);
    }

    //
    // Look up the NetWare authentication package
    //
    RtlInitString(&InputString, NW_AUTH_PACKAGE_NAME);

    ntstatus = LsaLookupAuthenticationPackage(
                   LsaHandle,
                   &InputString,
                   &AuthPackageId
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: NwpSetCredential: LsaLookupAuthenticationPackage returns x%08lx\n",
                 ntstatus));
        status = RtlNtStatusToDosError(ntstatus);
        goto CleanExit;
    }

    //
    // Ask authentication package for user information.
    //
    SetCredRequest.MessageType = NwAuth_SetCredential;
    RtlCopyLuid(&SetCredRequest.LogonId, LogonId);
    wcscpy(SetCredRequest.UserName, UserName);
    wcscpy(SetCredRequest.Password, Password);

    //
    // Encode the password.
    //
    RtlInitUnicodeString(&PasswordStr, SetCredRequest.Password);
    RtlRunEncodeUnicodeString(&EncodeSeed, &PasswordStr);

    ntstatus = LsaCallAuthenticationPackage(
                   LsaHandle,
                   AuthPackageId,
                   &SetCredRequest,
                   sizeof(SetCredRequest),
                   (PVOID *) &DummyOutput,
                   &DummyOutputLength,
                   &AuthPackageStatus
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = AuthPackageStatus;
    }
    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: NwpSetCredential: LsaCallAuthenticationPackage returns x%08lx\n",
                 ntstatus));
        status = RtlNtStatusToDosError(ntstatus);
    }
    else {
        status = NO_ERROR;
    }

CleanExit:
    (void) LsaDeregisterLogonProcess(LsaHandle);

    return status;
}

NTSTATUS NwNdsOpenRdrHandle(
    OUT PHANDLE  phNwRdrHandle
) 
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | GENERIC_READ;

    WCHAR NameStr[] = L"\\Device\\NwRdr\\*";
    UNICODE_STRING uOpenName;

    //
    // Prepare the open name.
    //

    RtlInitUnicodeString( &uOpenName, NameStr );

   //
   // Set up the object attributes.
   //

   InitializeObjectAttributes(
       &ObjectAttributes,
       &uOpenName,
       OBJ_CASE_INSENSITIVE,
       NULL,
       NULL );

   ntstatus = NtOpenFile(
                  phNwRdrHandle,
                  DesiredAccess,
                  &ObjectAttributes,
                  &IoStatusBlock,
                  FILE_SHARE_VALID_FLAGS,
                  FILE_SYNCHRONOUS_IO_NONALERT );

   if ( !NT_ERROR(ntstatus) &&
        !NT_INFORMATION(ntstatus) &&
        !NT_WARNING(ntstatus))  {

       return IoStatusBlock.Status;

   }

   return ntstatus;
}

VOID
NwpSelectServers(
    IN HWND DialogHandle,
    IN PCHANGE_PW_DLG_PARAM Credential
    )
/*++

Routine Description:

    This routine displays the dialog for user to select individual trees
    to change password on.  It then changes the password on the selected
    list. After the password has been changed, it displays a dialog which lists
    the 3.X bindery servers where the change could not be made.

Arguments:

    DialogHandle - Supplies the handle to display dialog.

    Credential - Provides on input the old and new passwords, and
                 the logged in user's name. Other field are ignored
                 on input and consecuently used within this function.

Return Value:

    None.

--*/
{
    INT_PTR Result;

    Credential->TreeList = NULL;
    Credential->UserList = NULL;
    Credential->Entries = 0;
    Credential->ChangedOne = FALSE;

    Result = DialogBoxParamW( hmodNW,
                              MAKEINTRESOURCEW(DLG_PW_SELECT_SERVERS),
                              (HWND) DialogHandle,
                              NwpSelectServersDlgProc,
                              (LPARAM) Credential );

    if ( Result == IDOK )
    {
        //
        // Display list of trees (if any) for which password was changed.
        //
        DialogBoxParamW( hmodNW,
                         MAKEINTRESOURCEW(DLG_PW_CHANGED),
                         (HWND) DialogHandle,
                         NwpChangePasswordSuccessDlgProc,
                         (LPARAM) Credential );

        if ( Credential->TreeList != NULL )
        {
            LocalFree( Credential->TreeList );
        }

        //
        // Display a dialog to tell users to use SetPass if they have an
        // account on a NetWare 3.X server.
        //
        NwpMessageBoxError( DialogHandle,
                            IDS_NETWARE_TITLE,
                            IDS_CHANGE_PASSWORD_INFO,
                            0,
                            NULL,
                            MB_OK );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\getaddr.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    getaddr.c

Abstract:

    This module contains the code to support NPGetAddressByName.

Author:

    Yi-Hsin Sung (yihsins)    18-Apr-94
    Glenn A. Curtis (glennc)  31-Jul-95
    Arnold Miller (ArnoldM)   7-Dec-95

Revision History:

    yihsins      Created
    glennc       Modified     31-Jul-95
    ArnoldM      Modified     7-Dec-95

--*/


#include <nwclient.h>
#include <winsock.h>
#include <wsipx.h>
#include <nspapi.h>
#include <nspapip.h>
#include <wsnwlink.h>
#include <svcguid.h>
#include <nwsap.h>
#include <align.h>
#include <nwmisc.h>
#include <rnrdefs.h>

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

#define NW_SAP_PRIORITY_VALUE_NAME        L"SapPriority"
#define NW_WORKSTATION_SVCPROVIDER_REGKEY L"System\\CurrentControlSet\\Services\\NWCWorkstation\\ServiceProvider"

#define NW_GUID_VALUE_NAME       L"GUID"
#define NW_SERVICETYPES_KEY_NAME L"ServiceTypes"
#define NW_SERVICE_TYPES_REGKEY  L"System\\CurrentControlSet\\Control\\ServiceProvider\\ServiceTypes"

#define DLL_VERSION        1
#define WSOCK_VER_REQD     0x0101

//
// critical sections used
//

extern CRITICAL_SECTION NwServiceListCriticalSection;
extern HANDLE           NwServiceListDoneEvent;

                                     // have been returned
BOOL
OldRnRCheckCancel(
    PVOID pvArg
    );

DWORD
OldRnRCheckSapData(
    PSAP_BCAST_CONTROL psbc,
    PSAP_IDENT_HEADER pSap,
    PDWORD  pdwErr
    );

DWORD
SapGetSapForType(
    PSAP_BCAST_CONTROL psbc,
    WORD               nServiceType
    );

DWORD
SapFreeSapSocket(
    SOCKET s
    );

DWORD
SapGetSapSocket(
    SOCKET * ppsocket
    );

VOID
pFreeAllContexts();

PSAP_RNR_CONTEXT
SapGetContext(
    IN HANDLE Handle
    );

PSAP_RNR_CONTEXT
SapMakeContext(
    IN HANDLE Handle,
    IN DWORD  dwExcess
    );

VOID
SapReleaseContext(
    PSAP_RNR_CONTEXT psrcContext
    );

INT
SapGetAddressByName(
    IN LPGUID      lpServiceType,
    IN LPWSTR      lpServiceName,
    IN LPDWORD     lpdwProtocols,
    IN DWORD       dwResolution,
    IN OUT LPVOID  lpCsAddrBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPWSTR  lpAliasBuffer,
    IN OUT LPDWORD lpdwAliasBufferLength,
    IN HANDLE      hCancellationEvent
);

DWORD
SapGetService (
    IN LPGUID          lpServiceType,
    IN LPWSTR          lpServiceName,
    IN DWORD           dwProperties,
    IN BOOL            fUnicodeBlob,
    OUT LPSERVICE_INFO lpServiceInfo,
    IN OUT LPDWORD     lpdwBufferLen
);

DWORD
SapSetService (
    IN DWORD          dwOperation,
    IN DWORD          dwFlags,
    IN BOOL           fUnicodeBlob,
    IN LPSERVICE_INFO lpServiceInfo
);

DWORD
NwpGetAddressViaSap( 
    IN WORD        nServiceType,
    IN LPWSTR      lpServiceName,
    IN DWORD       nProt,
    IN OUT LPVOID  lpCsAddrBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN HANDLE      hCancellationEvent,
    OUT LPDWORD    lpcAddress 
);

BOOL 
NwpLookupSapInRegistry( 
    IN  LPGUID    lpServiceType, 
    OUT PWORD     pnSapType,
    OUT PWORD     pwPort,
    IN OUT PDWORD pfConnectionOriented
);

DWORD
NwpRnR2AddServiceType(
    IN  LPWSTR   lpServiceTypeName,
    IN  LPGUID   lpClassType,
    IN  WORD     wSapId,
    IN  WORD     wPort
);

BOOL
NwpRnR2RemoveServiceType(
    IN  LPGUID   lpServiceType
);

DWORD 
NwpAddServiceType( 
    IN LPSERVICE_INFO lpServiceInfo, 
    IN BOOL fUnicodeBlob 
);

DWORD 
NwpDeleteServiceType( 
    IN LPSERVICE_INFO lpServiceInfo, 
    IN BOOL fUnicodeBlob 
);

DWORD
FillBufferWithCsAddr(
    IN LPBYTE      pAddress,
    IN DWORD       nProt,
    IN OUT LPVOID  lpCsAddrBuffer,  
    IN OUT LPDWORD lpdwBufferLength,
    OUT LPDWORD    pcAddress
);

DWORD
AddServiceToList(
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD nSapType,
    IN BOOL fAdvertiseBySap,
    IN INT  nIndexIPXAddress
);

VOID
RemoveServiceFromList(
    IN PREGISTERED_SERVICE pSvc
);

DWORD
pSapSetService2(
    IN DWORD dwOperation,
    IN LPWSTR lpszServiceInstance,
    IN PBYTE pbAddress,
    IN LPGUID pType,
    IN WORD nServiceType
    );

DWORD
pSapSetService(
    IN DWORD dwOperation,
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD nServiceType
    );

//
// Misc Functions
//

DWORD NwInitializeSocket(
    IN HANDLE hEventHandle
);

DWORD
NwAdvertiseService(
    IN LPWSTR pServiceName,
    IN WORD nSapType,
    IN LPSOCKADDR_IPX pAddr,
    IN HANDLE hEventHandle
);

DWORD SapFunc(
    IN HANDLE hEventHandle
);

DWORD
NwpGetAddressByName(
    IN    LPWSTR  Reserved, 
    IN    WORD    nServiceType,
    IN    LPWSTR  lpServiceName,
    IN OUT LPSOCKADDR_IPX  lpsockaddr
);
 


//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// This is the address we send to 
//

UCHAR SapBroadcastAddress[] = {
    AF_IPX, 0,                          // Address Family    
    0x00, 0x00, 0x00, 0x00,             // Dest. Net Number  
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Dest. Node Number 
    0x04, 0x52,                         // Dest. Socket      
    0x04                                // Packet type       
};

PSAP_RNR_CONTEXT psrcSapContexts;

//
// Misc. variables used if we need to advertise ourselves, i.e.
// when the SAP service is not installed/active.
//

BOOL fInitSocket = FALSE;    // TRUE if we have created the second thread
SOCKET socketSap;            // Socket used to send SAP advertise packets
PREGISTERED_SERVICE pServiceListHead = NULL;  // Points to head of link list
PREGISTERED_SERVICE pServiceListTail = NULL;  // Points to tail of link list

//
// needed to map old and new RnR functions
//
DWORD oldRnRServiceRegister = SERVICE_REGISTER;
DWORD oldRnRServiceDeRegister = SERVICE_DEREGISTER;

HMODULE hThisDll = INVALID_HANDLE_VALUE;

//-------------------------------------------------------------------//
//                                                                   //
// Function Bodies                                                   //
//                                                                   //
//-------------------------------------------------------------------//

VOID
pFreeAllContexts()
/*++
Routine Description:
   Called at Cleanup time to free all NSP resource
--*/
{
    PSAP_RNR_CONTEXT psrcContext;

    EnterCriticalSection( &NwServiceListCriticalSection );
    while(psrcContext = psrcSapContexts)
    {
        (VOID)SapReleaseContext(psrcContext);
    }
    LeaveCriticalSection( &NwServiceListCriticalSection );
}

PSAP_RNR_CONTEXT
SapGetContext(HANDLE Handle)
/*++

Routine Description:

    This routine checks the existing SAP contexts to see if we have one
    for this calll.

Arguments:

    Handle    - the RnR handle, if appropriate

--*/
{
    PSAP_RNR_CONTEXT psrcContext;

    EnterCriticalSection( &NwServiceListCriticalSection );

    for(psrcContext = psrcSapContexts;
        psrcContext && (psrcContext->Handle != Handle);
        psrcContext = psrcContext->pNextContext);

    if(psrcContext)
    {
        ++psrcContext->lInUse;
    }
    LeaveCriticalSection( &NwServiceListCriticalSection );
    return(psrcContext);
}

PSAP_RNR_CONTEXT
SapMakeContext(
       IN HANDLE Handle,
       IN DWORD  dwExcess
    )
{
/*++

Routine Description:

    This routine makes a SAP conext for a given RnR handle

Arguments:

    Handle    - the RnR handle. If NULL, use the context as the handle
    dwType    - the type of the context

--*/
    PSAP_RNR_CONTEXT psrcContext;

    psrcContext = (PSAP_RNR_CONTEXT)
                           LocalAlloc(LPTR, sizeof(SAP_RNR_CONTEXT) +
                                             dwExcess);
    if(psrcContext)
    {
        InitializeCriticalSection(&psrcContext->u_type.sbc.csMonitor);
        psrcContext->lInUse = 2;
        psrcContext->Handle = (Handle ? Handle : (HANDLE)psrcContext);
        psrcContext->lSig = RNR_SIG;
        EnterCriticalSection( &NwServiceListCriticalSection );
        psrcContext->pNextContext = psrcSapContexts;
        psrcSapContexts = psrcContext;
        LeaveCriticalSection( &NwServiceListCriticalSection );
    }
    return(psrcContext);
}

VOID
SapReleaseContext(PSAP_RNR_CONTEXT psrcContext)
/*++

Routine Description:

    Dereference an RNR Context and free it if it is no longer referenced.
    Determining no referneces is a bit tricky because we try to avoid
    obtaining the CritSec unless we think the context may be unneeded. Hence
    the code goes through some fuss. It could be much simpler if we always
    obtained the CritSec whenever we changed the reference count, but
    this is faster for the nominal case.

Arguments:

    psrcContext -- The context

--*/
{
    EnterCriticalSection( &NwServiceListCriticalSection );
    if(--psrcContext->lInUse == 0)
    {
        PSAP_RNR_CONTEXT psrcX, psrcPrev;
        PSAP_DATA psdData;

        //
        //  Done with it. Remove from the lisgt
        //

        psrcPrev = 0;
        for(psrcX = psrcSapContexts;
            psrcX;
            psrcX = psrcX->pNextContext)
        {
            if(psrcX == psrcContext)
            {
                //
                // Found it. 
                //

                if(psrcPrev)
                { 
                    psrcPrev->pNextContext = psrcContext->pNextContext;
                }
                else
                {
                    psrcSapContexts = psrcContext->pNextContext;
                }
                break;
            }
            psrcPrev = psrcX;
        }

        ASSERT(psrcX);

        //
        // release SAP data, if any
        //
        if(psrcContext->dwUnionType == LOOKUP_TYPE_SAP)
        {
            for(psdData = psrcContext->u_type.sbc.psdHead;
                psdData;)
            {
                PSAP_DATA psdTemp = psdData->sapNext;

                LocalFree(psdData);
                psdData = psdTemp;
            }

            if(psrcContext->u_type.sbc.s)
            {
                SapFreeSapSocket(psrcContext->u_type.sbc.s);
            }
        }
        DeleteCriticalSection(&psrcContext->u_type.sbc.csMonitor);
        if(psrcContext->hServer)
        {
            CloseHandle(psrcContext->hServer);
        }
        LocalFree(psrcContext);
    }
    LeaveCriticalSection( &NwServiceListCriticalSection );
}
        
INT
APIENTRY
NPLoadNameSpaces(
    IN OUT LPDWORD      lpdwVersion,
    IN OUT LPNS_ROUTINE nsrBuffer,
    IN OUT LPDWORD      lpdwBufferLength 
    )
{
/*++

Routine Description:

    This routine returns name space info and functions supported in this
    dll. 

Arguments:

    lpdwVersion - dll version

    nsrBuffer - on return, this will be filled with an array of 
        NS_ROUTINE structures

    lpdwBufferLength - on input, the number of bytes contained in the buffer
        pointed to by nsrBuffer. On output, the minimum number of bytes
        to pass for the nsrBuffer to retrieve all the requested info

Return Value:

    The number of NS_ROUTINE structures returned, or SOCKET_ERROR (-1) if 
    the nsrBuffer is too small. Use GetLastError() to retrieve the 
    error code.

--*/
    DWORD err;
    DWORD dwLengthNeeded; 
    HKEY  providerKey;

    DWORD dwSapPriority = NS_STANDARD_FAST_PRIORITY;

    *lpdwVersion = DLL_VERSION;

    //
    // Check to see if the buffer is large enough
    //
    dwLengthNeeded = sizeof(NS_ROUTINE) + 4 * sizeof(LPFN_NSPAPI);

    if (  ( *lpdwBufferLength < dwLengthNeeded )
       || ( nsrBuffer == NULL )
       )
    {
        *lpdwBufferLength = dwLengthNeeded;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return (DWORD) SOCKET_ERROR;
    }
  
    //
    // Get the Sap priority from the registry. We will ignore all errors
    // from the registry and have a default priority if we failed to read
    // the value.
    //
    err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                         NW_WORKSTATION_SVCPROVIDER_REGKEY,
                         0,
                         KEY_READ,
                         &providerKey  );

    if ( !err )
    {
        DWORD BytesNeeded = sizeof( dwSapPriority );
        DWORD ValueType;

        err = RegQueryValueExW( providerKey,
                                NW_SAP_PRIORITY_VALUE_NAME,
                                NULL,
                                &ValueType,
                                (LPBYTE) &dwSapPriority,
                                &BytesNeeded );

        if ( err )  // set default priority if error occurred
            dwSapPriority = NS_STANDARD_FAST_PRIORITY;
        (void) RegCloseKey( providerKey );
    }
           
    //
    // We only support 1 name space for now, so fill in the NS_ROUTINE.
    //
    nsrBuffer->dwFunctionCount = 3;  
    nsrBuffer->alpfnFunctions = (LPFN_NSPAPI *) 
        ((BYTE *) nsrBuffer + sizeof(NS_ROUTINE)); 
    (nsrBuffer->alpfnFunctions)[NSPAPI_GET_ADDRESS_BY_NAME] = 
        (LPFN_NSPAPI) SapGetAddressByName;
    (nsrBuffer->alpfnFunctions)[NSPAPI_GET_SERVICE] = 
        (LPFN_NSPAPI) SapGetService;
    (nsrBuffer->alpfnFunctions)[NSPAPI_SET_SERVICE] = 
        (LPFN_NSPAPI) SapSetService;
    (nsrBuffer->alpfnFunctions)[3] = NULL;

    nsrBuffer->dwNameSpace = NS_SAP;
    nsrBuffer->dwPriority  = dwSapPriority;

    return 1;  // number of namespaces
}

INT
SapGetAddressByName(
    IN LPGUID      lpServiceType,
    IN LPWSTR      lpServiceName,
    IN LPDWORD     lpdwProtocols,
    IN DWORD       dwResolution,
    IN OUT LPVOID  lpCsAddrBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPWSTR  lpAliasBuffer,
    IN OUT LPDWORD lpdwAliasBufferLength,
    IN HANDLE      hCancellationEvent
    )
/*++

Routine Description:

    This routine returns address information about a specific service.

Arguments:

    lpServiceType - pointer to the GUID for the service type

    lpServiceName - unique string representing the service name, in the
        Netware case, this is the server name

    lpdwProtocols - a zero terminated array of protocol ids. This parameter
        is optional; if lpdwProtocols is NULL, information on all available
        Protocols is returned

    dwResolution - can be one of the following values:
        RES_SOFT_SEARCH, RES_FIND_MULTIPLE

    lpCsAddrBuffer - on return, will be filled with CSADDR_INFO structures

    lpdwBufferLength - on input, the number of bytes contained in the buffer
        pointed to by lpCsAddrBuffer. On output, the minimum number of bytes
        to pass for the lpCsAddrBuffer to retrieve all the requested info

    lpAliasBuffer - not used

    lpdwAliasBufferLength - not used

    hCancellationEvent - the event which signals us to cancel the request

Return Value:

    The number of CSADDR_INFO structures returned, or SOCKET_ERROR (-1) if 
    the lpCsAddrBuffer is too small. Use GetLastError() to retrieve the 
    error code.

--*/
{
    DWORD err;
    WORD  nServiceType;
    DWORD cAddress = 0;   // Count of the number of address returned 
                          // in lpCsAddrBuffer
    DWORD cProtocols = 0; // Count of the number of protocols contained
                          // in lpdwProtocols + 1 ( for zero terminate )
    DWORD nProt = IPX_BIT | SPXII_BIT; 
    DWORD fConnectionOriented = (DWORD) -1;
    SOCKADDR_IPX sockaddr;

    if (  ARGUMENT_PRESENT( lpdwAliasBufferLength ) 
       && ARGUMENT_PRESENT( lpAliasBuffer ) 
       )
    {
        if ( *lpdwAliasBufferLength >= sizeof(WCHAR) )
           *lpAliasBuffer = 0;
    }          

    //
    // Check for invalid parameters
    //
    if (  ( lpServiceType == NULL )
       || ( lpServiceName == NULL )
       || ( lpdwBufferLength == NULL )
       )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return SOCKET_ERROR;
    }

    //
    // If an array of protocol ids is passed in, check to see if 
    // the IPX protocol is requested. If not, return 0 since
    // we only support IPX. 
    //
    if ( lpdwProtocols != NULL )
    {
        INT i = -1;

        nProt = 0;
        while ( lpdwProtocols[++i] != 0 )
        {
            if ( lpdwProtocols[i] == NSPROTO_IPX )
                nProt |= IPX_BIT;

            if ( lpdwProtocols[i] == NSPROTO_SPX )
                nProt |= SPX_BIT;
            
            if ( lpdwProtocols[i] == NSPROTO_SPXII )
                nProt |= SPXII_BIT;
             
        }
 
        if ( nProt == 0 ) 
            return 0;  // No address found
 
        cProtocols = i+1;
    }

    //
    // Check to see if the service type is supported in NetWare
    // 
    if ( NwpLookupSapInRegistry( lpServiceType, &nServiceType, NULL, 
                                 &fConnectionOriented ))
    {
        if ( fConnectionOriented != -1 )  // Got value from registry
        {
            if ( fConnectionOriented )
            {
                nProt &= ~IPX_BIT; 
            }
            else  // connectionless
            {
                nProt &= ~(SPX_BIT | SPXII_BIT ); 
            }

            if ( nProt == 0 )
                return 0; // No address found
        }
    }
    else
    {
        //
        // Couldn't find it in the registry, see if it is a well-known GUID
        //
        if ( IS_SVCID_NETWARE( lpServiceType ))
        {
            nServiceType = SAPID_FROM_SVCID_NETWARE( lpServiceType );
        }
        else
        {
            //
            // Not a well-known GUID either
            //
            return 0; // No address found
        }
    }
    

    if ((dwResolution & RES_SERVICE) != 0)
    {
        err = FillBufferWithCsAddr( NULL,
                                    nProt,
                                    lpCsAddrBuffer,
                                    lpdwBufferLength,
                                    &cAddress );

        if ( err )
        {
            SetLastError( err );
            return SOCKET_ERROR;
        }

        return cAddress;
    }

    //
    // Try to get the address from the bindery first
    //
    err = NwpGetAddressByName( NULL, 
                               nServiceType,
                               lpServiceName,
                               &sockaddr );
 
    if ( err == NO_ERROR )
    {
        err = FillBufferWithCsAddr( sockaddr.sa_netnum,
                                    nProt,
                                    lpCsAddrBuffer,
                                    lpdwBufferLength,
                                    &cAddress );
    }

    if (  err  && ( err != ERROR_INSUFFICIENT_BUFFER ) ) 
    {
        if ( err == ERROR_SERVICE_NOT_ACTIVE )
        {
            //
            // We could not find the service name in the bindery, and we
            // need to try harder ( RES_SOFT_SEARCH not defined ), so send out
            // SAP query packets to see if we can find it.
            // 

            err = NwpGetAddressViaSap( 
                                       nServiceType,
                                       lpServiceName,
                                       nProt,
                                       lpCsAddrBuffer,
                                       lpdwBufferLength,
                                       hCancellationEvent,
                                       &cAddress );
#if DBG
            IF_DEBUG(OTHER)
            {
                if ( err == NO_ERROR )
                {
                    KdPrint(("Successfully got %d address for %ws from SAP.\n", 
                            cAddress, lpServiceName ));
                }
                else
                {
                    KdPrint(("Failed with err %d when getting address for %ws from SAP.\n", err, lpServiceName ));
                } 
            }
#endif
        }
        else
        {
            err = NO_ERROR;
            cAddress = 0;
        }
    }

    if ( err )
    {
        SetLastError( err );
        return SOCKET_ERROR;
    }
                                   
    return cAddress;
    
} 

DWORD
SapGetService (
    IN     LPGUID          lpServiceType,
    IN     LPWSTR          lpServiceName,
    IN     DWORD           dwProperties,
    IN     BOOL            fUnicodeBlob,
    OUT    LPSERVICE_INFO  lpServiceInfo,
    IN OUT LPDWORD         lpdwBufferLen
    )
/*++

Routine Description:

    This routine returns the service info for the given service type/name.

Arguments:

    lpServiceType - pointer to the GUID for the service type

    lpServiceName - service name

    dwProperties -  the properties of the service to return

    lpServiceInfo - points to a buffer to return store the return info
 
    lpdwBufferLen - on input, the count of bytes in lpServiceInfo. On output,
                    the minimum buffer size that can be passed to this API
                    to retrieve all the requested information 

Return Value:

    Win32 error code.

--*/
{
    DWORD err;
    WORD  nServiceType;

    //
    // Check for invalid parameters
    //
    if (  ( dwProperties == 0 )
       || ( lpServiceType == NULL )
       || ( lpServiceName == NULL )
       || ( lpServiceName[0] == 0 )   
       || ( lpdwBufferLen == NULL )
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Check to see if the service type is supported in NetWare
    // 
    if ( !(NwpLookupSapInRegistry( lpServiceType, &nServiceType, NULL, NULL )))
    {
        //
        // Couldn't find it in the registry, see if it is a well-known GUID
        //
        if ( IS_SVCID_NETWARE( lpServiceType ))
        {
            nServiceType = SAPID_FROM_SVCID_NETWARE( lpServiceType );
        }
        else
        {
            //
            // Not a well-known GUID either, return error
            //
            return ERROR_SERVICE_NOT_FOUND;
        }
    }
    
    UNREFERENCED_PARAMETER(fUnicodeBlob) ;

    RpcTryExcept
    {
        err = NwrGetService( NULL,
                             nServiceType,
                             lpServiceName,
                             dwProperties,
                             (LPBYTE) lpServiceInfo,
                             *lpdwBufferLen,
                             lpdwBufferLen  );

        if ( err == NO_ERROR )
        {
            INT i ;
            LPSERVICE_INFO p = (LPSERVICE_INFO) lpServiceInfo;
            LPSERVICE_ADDRESS lpAddress ;
            
            //
            // fix up pointers n main structure (convert from offsets)
            //
            if ( p->lpServiceType != NULL )
                p->lpServiceType = (LPGUID) ((DWORD_PTR) p->lpServiceType + 
                                             (LPBYTE) p);
            if ( p->lpServiceName != NULL )
                p->lpServiceName = (LPWSTR) 
                    ((DWORD_PTR) p->lpServiceName + (LPBYTE) p);
            if ( p->lpComment != NULL )
                p->lpComment = (LPWSTR) ((DWORD_PTR) p->lpComment + (LPBYTE) p);
            if ( p->lpLocale != NULL )
                p->lpLocale = (LPWSTR) ((DWORD_PTR) p->lpLocale + (LPBYTE) p);
            if ( p->lpMachineName != NULL )
                p->lpMachineName = (LPWSTR) 
                    ((DWORD_PTR) p->lpMachineName + (LPBYTE)p);
            if ( p->lpServiceAddress != NULL )
                p->lpServiceAddress = (LPSERVICE_ADDRESSES) 
                    ((DWORD_PTR) p->lpServiceAddress + (LPBYTE) p);
            if ( p->ServiceSpecificInfo.pBlobData != NULL )
                p->ServiceSpecificInfo.pBlobData = (LPBYTE) 
                    ((DWORD_PTR) p->ServiceSpecificInfo.pBlobData + (LPBYTE) p);

            //
            // fix up pointers in the array of addresses
            //
            for (i = p->lpServiceAddress->dwAddressCount; 
                 i > 0; 
                 i--)
            {
                lpAddress = 
                    &(p->lpServiceAddress->Addresses[i-1]) ;
                lpAddress->lpAddress = 
                    ((LPBYTE)p) + (DWORD_PTR)lpAddress->lpAddress ;
                lpAddress->lpPrincipal = 
                    ((LPBYTE)p) + (DWORD_PTR)lpAddress->lpPrincipal ;
            }
        }
    }
    RpcExcept(1)
    {
        err = ERROR_SERVICE_NOT_ACTIVE;
#if 0            // the following is a good idea, but hard to get right
        DWORD code = RpcExceptionCode();

        if ( (code == RPC_S_SERVER_UNAVAILABLE)
                        ||
             (code == RPC_S_UNKNOWN_IF) )
        err
            err = ERROR_SERVICE_NOT_ACTIVE;
        else
            err = NwpMapRpcError( code );
#endif
    }
    RpcEndExcept

    if ( err == ERROR_SERVICE_NOT_ACTIVE )
    {
        //
        //CSNW not available, going to get it ourselves
        //
        err = NwGetService( NULL,
                            nServiceType,
                            lpServiceName,
                            dwProperties,
                            (LPBYTE) lpServiceInfo,
                            *lpdwBufferLen,
                            lpdwBufferLen  );

        if ( err == NO_ERROR )
        {
            INT i ;
            LPSERVICE_INFO p = (LPSERVICE_INFO) lpServiceInfo;
            LPSERVICE_ADDRESS lpAddress ;
            
            //
            // fix up pointers n main structure (convert from offsets)
            //
            if ( p->lpServiceType != NULL )
                p->lpServiceType = (LPGUID) ((DWORD_PTR) p->lpServiceType + 
                                             (LPBYTE) p);
            if ( p->lpServiceName != NULL )
                p->lpServiceName = (LPWSTR) 
                    ((DWORD_PTR) p->lpServiceName + (LPBYTE) p);
            if ( p->lpComment != NULL )
                p->lpComment = (LPWSTR) ((DWORD_PTR) p->lpComment + (LPBYTE) p);
            if ( p->lpLocale != NULL )
                p->lpLocale = (LPWSTR) ((DWORD_PTR) p->lpLocale + (LPBYTE) p);
            if ( p->lpMachineName != NULL )
                p->lpMachineName = (LPWSTR) 
                    ((DWORD_PTR) p->lpMachineName + (LPBYTE)p);
            if ( p->lpServiceAddress != NULL )
                p->lpServiceAddress = (LPSERVICE_ADDRESSES) 
                    ((DWORD_PTR) p->lpServiceAddress + (LPBYTE) p);
            if ( p->ServiceSpecificInfo.pBlobData != NULL )
                p->ServiceSpecificInfo.pBlobData = (LPBYTE) 
                    ((DWORD_PTR) p->ServiceSpecificInfo.pBlobData + (LPBYTE) p);

            //
            // fix up pointers in the array of addresses
            //
            for (i = p->lpServiceAddress->dwAddressCount; 
                 i > 0; 
                 i--)
            {
                lpAddress = 
                    &(p->lpServiceAddress->Addresses[i-1]) ;
                lpAddress->lpAddress = 
                    ((LPBYTE)p) + (DWORD_PTR)lpAddress->lpAddress ;
                lpAddress->lpPrincipal = 
                    ((LPBYTE)p) + (DWORD_PTR)lpAddress->lpPrincipal ;
            }
        }
    }

    return err;
}

DWORD
SapSetService (
    IN     DWORD           dwOperation,
    IN     DWORD           dwFlags,
    IN     BOOL            fUnicodeBlob,
    IN     LPSERVICE_INFO  lpServiceInfo
    )
/*++

Routine Description:

    This routine registers or deregisters the given service type/name.

Arguments:

    dwOperation - Either SERVICE_REGISTER, SERVICE_DEREGISTER,
                         SERVICE_ADD_TYPE, SERVICE_DELETE_TYPE,
                         or SERVICE_FLUSH

    dwFlags - ignored

    lpServiceInfo - Pointer to a SERVICE_INFO structure containing all info
                    about the service.
 
Return Value:

    Win32 error code.

--*/
{
    DWORD err;
    WORD  nServiceType;

    UNREFERENCED_PARAMETER( dwFlags );

    //
    // Check for invalid parameters
    //
    switch ( dwOperation )
    {
        case SERVICE_REGISTER:
        case SERVICE_DEREGISTER:
        case SERVICE_ADD_TYPE:
        case SERVICE_DELETE_TYPE: 
            break;
 
        case SERVICE_FLUSH: 
            //
            // This is a no-op in our provider, so just return success
            //
            return NO_ERROR;

        default:
            //
            // We can probably say all other operations which we have no 
            // knowledge of are ignored by us. So, just return success.
            //
            return NO_ERROR;
    }

    if (  ( lpServiceInfo == NULL )
       || ( lpServiceInfo->lpServiceType == NULL )
       || ( ((lpServiceInfo->lpServiceName == NULL) || 
             (lpServiceInfo->lpServiceName[0] == 0 )) && 
            ((dwOperation != SERVICE_ADD_TYPE) && 
             (dwOperation != SERVICE_DELETE_TYPE)) 
          )
       
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // See if operation is adding or deleting a service type
    //
    if ( dwOperation == SERVICE_ADD_TYPE )
    {
        return NwpAddServiceType( lpServiceInfo, fUnicodeBlob );
    }
    else if ( dwOperation == SERVICE_DELETE_TYPE )
    {
        return NwpDeleteServiceType( lpServiceInfo, fUnicodeBlob );
    }

    //
    // Check to see if the service type is supported in NetWare
    // 
    if ( !(NwpLookupSapInRegistry( lpServiceInfo->lpServiceType, &nServiceType, NULL, NULL )))
    {
        //
        // Couldn't find it in the registry, see if it is a well-known GUID
        //
        if ( IS_SVCID_NETWARE( lpServiceInfo->lpServiceType ))
        {
            nServiceType = SAPID_FROM_SVCID_NETWARE( lpServiceInfo->lpServiceType );
        }
        else
        {
            //
            // Not a well-known GUID either, return error
            //
            return ERROR_SERVICE_NOT_FOUND;
        }
    }
    
    //
    // Operation is either SERVICE_REGISTER or SERVICE_DEREGISTER.
    // Pass it on to the common code used by this and the RnR2
    // SetService
    //

    err = pSapSetService(dwOperation, lpServiceInfo, nServiceType);
    return(err);
}

DWORD
pSapSetService2(
    IN DWORD dwOperation,
    IN LPWSTR lpszServiceInstance,
    IN PBYTE pbAddress,
    IN LPGUID pType,
    IN WORD nServiceType
    )
/*++
Routine Description:
    Jacket routine called by the RnR2 SetService. This routine is
    an impedance matcher to coerce data structures. It winds
    up calling pSapSetService2 once it has constructed the
    SERVICE_INFO structure.
--*/
{
    SERVICE_INFO siInfo;
    SERVICE_ADDRESSES ServiceAddresses;
    LPSERVICE_ADDRESS psa = &ServiceAddresses.Addresses[0];

    ServiceAddresses.dwAddressCount = 1;
    memset(&siInfo, 0, sizeof(siInfo));
    siInfo.lpServiceName = lpszServiceInstance;
    siInfo.lpServiceAddress = &ServiceAddresses;
    psa->dwAddressType = AF_IPX;
    psa->dwAddressFlags = psa->dwPrincipalLength = 0;
    psa->dwAddressLength = sizeof(SOCKADDR_IPX);
    psa->lpPrincipal = 0;
    psa->lpAddress = pbAddress;
    siInfo.lpServiceType = pType;
    return(pSapSetService(dwOperation, &siInfo, nServiceType));
}


DWORD
pSapSetService(
    IN DWORD dwOperation,
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD nServiceType)
/*++
Routine Description:
    Common routine to do the SAP advertisement.
--*/
{
    DWORD err;

    RpcTryExcept
    {
        err = NwrSetService( NULL, dwOperation, lpServiceInfo, nServiceType );
    }
    RpcExcept(1)
    {
        err = ERROR_SERVICE_NOT_ACTIVE;
#if 0
        DWORD code = RpcExceptionCode();

        if ( (code == RPC_S_SERVER_UNAVAILABLE)
                     ||
             (code == RPC_S_UNKNOWN_IF) )
        {
            err = ERROR_SERVICE_NOT_ACTIVE;
        }
        else
        {
            err = NwpMapRpcError( code );
        }
#endif
    }
    RpcEndExcept

    if ( err == ERROR_SERVICE_NOT_ACTIVE )
    {
        //
        //CSNW not available, going to try use the SAP agent, else we do it ourselves
        //
        err = NO_ERROR;

        //
        // Check if all parameters passed in are valid
        //
        if ( wcslen( lpServiceInfo->lpServiceName ) > SAP_OBJECT_NAME_MAX_LENGTH-1 )
        {
            return ERROR_INVALID_PARAMETER;
        }

        switch ( dwOperation )
        {
            case SERVICE_REGISTER:
                err = NwRegisterService( lpServiceInfo,
                                         nServiceType,
                                         NwServiceListDoneEvent );
                break;

            case SERVICE_DEREGISTER:
                err = NwDeregisterService( lpServiceInfo, nServiceType );
                break;

            default:    //this should never occur, but just in case . . .
                err = ERROR_INVALID_PARAMETER;
                break;
        }
    }

    return err;
}

DWORD
SapFreeSapSocket(SOCKET s)
{
/*++
Routine Description:

    Release the socket and clean up
--*/
    DWORD err = NO_ERROR;

    closesocket( s );
    return(err);
}

DWORD
SapGetSapSocket(SOCKET * ps)
{
/*++
Routine Description:

    Get a socket suitable for making SAP queries

Arguments: None

--*/
    SOCKET socketSap;
    WSADATA wsaData;
    SOCKADDR_IPX socketAddr;
    DWORD err = NO_ERROR;
    INT nValue;
    DWORD dwNonBlocking = 1;

    //
    // Initialize the socket interface
    //
//    err = WSAStartup( WSOCK_VER_REQD, &wsaData );
//    if ( err )
//    {
//        return err;
//    }

    //
    // Open an IPX datagram socket
    //
    socketSap = socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
    if ( socketSap == INVALID_SOCKET )
    {
        err = WSAGetLastError();
//        (VOID) WSACleanup();
        return err;
    }

    //
    // Set the socket to non-blocking
    //
    if ( ioctlsocket( socketSap, FIONBIO, &dwNonBlocking ) == SOCKET_ERROR )
    {
        err = WSAGetLastError();
        goto ErrExit;
    }
 
    //
    // Allow sending of broadcasts
    //
    nValue = 1;
    if ( setsockopt( socketSap, 
                     SOL_SOCKET, 
                     SO_BROADCAST, 
                     (PVOID) &nValue, 
                     sizeof(INT)) == SOCKET_ERROR )
    {
        err = WSAGetLastError();
        goto ErrExit;
    }

    //
    // Bind the socket 
    //
    memset( &socketAddr, 0, sizeof( SOCKADDR_IPX));
    socketAddr.sa_family = AF_IPX;
    socketAddr.sa_socket = 0;      // no specific port

    if ( bind( socketSap, 
               (PSOCKADDR) &socketAddr, 
               sizeof( SOCKADDR_IPX)) == SOCKET_ERROR )
    {
        err = WSAGetLastError();
        goto ErrExit;
    }
    
    //
    // Set the extended address option
    //
    nValue = 1;
    if ( setsockopt( socketSap,                     // Socket Handle    
                     NSPROTO_IPX,                   // Option Level     
                     IPX_EXTENDED_ADDRESS,          // Option Name  
                     (PUCHAR)&nValue,               // Ptr to on/off flag
                     sizeof(INT)) == SOCKET_ERROR ) // Length of flag
    {
        err = WSAGetLastError();
        goto ErrExit;
    }

    *ps = socketSap;

    return(err);

ErrExit:
    SapFreeSapSocket(socketSap);   // cleans up lots of stuff
    return(err);
}       


DWORD
NwpGetAddressForRnRViaSap(
    IN HANDLE  hRnRHandle,
    IN WORD nServiceType,
    IN LPWSTR lpServiceName,
    IN DWORD  nProt,
    IN OUT LPVOID  lpCsAddrBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN HANDLE hCancellationEvent,
    OUT LPDWORD lpcAddress 
    )
{
/*++
Routine Description:

    This routine uses SAP requests to find the address of the given service 
    name/type. It can handle looking up by type only, or by name and type.
    The latter case is the same as the old RnR code, see below for
    it and for a description of the arguments
--*/
    return(0);
}

#define MAX_LOOPS_FOR_SAP 4

DWORD
SapGetSapForType(
    PSAP_BCAST_CONTROL psbc,
    WORD               nServiceType)
{
/*++
Routine Description:
    Does the work of send Sap queries and fetching results.
    The first message sent is done according to the requester, and
    may be limited to the local LAN or not. 
    
Arguments:
    psbc -- pointer to the control information
    wSapType -- Sap type
--*/
    SAP_REQUEST sapRequest;
    UCHAR destAddr[SAP_ADDRESS_LENGTH];
    DWORD startTickCount;
    UCHAR recvBuffer[SAP_MAXRECV_LENGTH];
    INT bytesReceived;
    BOOL fFound = FALSE;
    DWORD err = NO_ERROR;

    sapRequest.QueryType  = htons( psbc->wQueryType );
    sapRequest.ServerType = htons( nServiceType );

    //
    // Set the address to send to
    //
    memcpy( destAddr, SapBroadcastAddress, SAP_ADDRESS_LENGTH );
    
    //
    // Ready to go. This might be the inital call, in which case
    // we start off by sending. In all other cases, we start
    // out receiving.
    //

    //
    // In the full case,
    // we will send out SAP requests 3 times and wait 1 sec for
    // Sap responses the first time, 2 sec the second and 4 sec the
    // third time.
    //
    for (; !fFound && (psbc->dwIndex < MAX_LOOPS_FOR_SAP); psbc->dwIndex++ ) 
    {
        DWORD dwRet;
        DWORD dwTimeOut = (1 << psbc->dwIndex) * 1000;

        if(psbc->dwTickCount)
        {
            dwRet = dwrcNil;
            //
            // Need to do some reading ...
            //
            do
            {
                PSAP_IDENT_HEADER pSap;


                if((psbc->psrc->fFlags & SAP_F_END_CALLED)
                          ||
                   psbc->fCheckCancel(psbc->pvArg))
                {
                    err = dwrcCancel;
                    goto CleanExit;
                }

                //
                // Sleeps for 50 ms so that we might get something on first read
                //
                Sleep( 50 );    

                bytesReceived = recvfrom( psbc->s,
                                          recvBuffer,
                                          SAP_MAXRECV_LENGTH,
                                          0,
                                          NULL,
                                          NULL );

                if ( bytesReceived == SOCKET_ERROR )
                {
                    err = WSAGetLastError();
                    if ( err == WSAEWOULDBLOCK )  // no data on socket, continue looping
                    {
                        if(dwRet == dwrcNoWait)
                        {
                             fFound = TRUE;
                        }
                        err = NO_ERROR;
                        continue;
                    }
                }

                if (  ( err != NO_ERROR )     // err occurred in recvfrom  
                   || ( bytesReceived == 0 )  // or socket closed
                   )
                {
                    goto CleanExit;
                }

                //
                // Skip over query type
                //
                bytesReceived -= sizeof(USHORT);
                pSap = (PSAP_IDENT_HEADER) &(recvBuffer[sizeof(USHORT)]);  
                  
                //
                // Tell the caller we've something to look over
                //
                while ( bytesReceived >= sizeof( SAP_IDENT_HEADER ))
                {
    
                    dwRet = psbc->Func(psbc, pSap, &err);
                    if((dwRet == dwrcDone)
                              ||
                       (dwRet == dwrcCancel))
                    {
                        fFound = TRUE;
                        break;
                    }                   

                    pSap++;
                    bytesReceived -= sizeof( SAP_IDENT_HEADER );
                }
            }
            while (  !fFound  
                     && ((GetTickCount() - psbc->dwTickCount) < dwTimeOut )
                  );
        }


        // Send the packet out
        //
        if((fFound && (dwRet == dwrcNoWait))
                  ||
            (psbc->dwIndex == (MAX_LOOPS_FOR_SAP -1)))
        {
            goto CleanExit;
        }
        if ( sendto( psbc->s, 
                     (PVOID) &sapRequest,
                     sizeof( sapRequest ),
                     0,
                     (PSOCKADDR) destAddr,
                     SAP_ADDRESS_LENGTH ) == SOCKET_ERROR ) 
        {
            err = WSAGetLastError();
            goto CleanExit;
        }
        psbc->dwTickCount = GetTickCount();
    }

    if(!fFound)
    {
        err = WSAEADDRNOTAVAIL;
    }

CleanExit:

    return err;     
}

BOOL 
NwpLookupSapInRegistry( 
    IN  LPGUID lpServiceType, 
    OUT PWORD  pnSapType,
    OUT PWORD  pwPort,
    IN OUT PDWORD pfConnectionOriented
    )
/*++

Routine Description:

    This routine looks up the GUID in the registry under 
    Control\ServiceProvider\ServiceTypes and trys to read the SAP type
    from the registry. 

Arguments:

    lpServiceType - the GUID to look for
    pnSapType - on return, contains the SAP type

Return Value:
   
    Returns FALSE if we can't get the SAP type, TRUE otherwise

--*/
{
    DWORD err;
    BOOL  fFound = FALSE;

    HKEY  hkey = NULL;
    HKEY  hkeyServiceType = NULL;
    DWORD dwIndex = 0;
    WCHAR szBuffer[ MAX_PATH + 1];
    DWORD dwLen; 
    FILETIME ftLastWrite; 

    //
    // Open the service types key
    //
    err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                         NW_SERVICE_TYPES_REGKEY,
                         0,
                         KEY_READ,
                         &hkey );
    
    if ( err )
    {
        // Cannot find the key because it is not created yet since no 
        // one called Add service type. We return FALSE indicating
        // Sap type not found. 
        return FALSE;
    }

    //
    // Loop through all subkey of service types to find the GUID
    //
    for ( dwIndex = 0; ; dwIndex++ )
    {
        GUID guid;

        dwLen = sizeof( szBuffer ) / sizeof( WCHAR );
        err = RegEnumKeyExW( hkey,
                             dwIndex,
                             szBuffer,  // Buffer big enough to 
                                        // hold any key name
                             &dwLen,    // in characters
                             NULL,
                             NULL,
                             NULL,
                             &ftLastWrite );

        //
        // We will break out of here on any error, this includes
        // the error ERROR_NO_MORE_ITEMS which means that we have finish 
        // enumerating all the keys.
        //
        if ( err )  
        {
            if ( err == ERROR_NO_MORE_ITEMS )   // No more to enumerate
                err = NO_ERROR;
            break;
        }

        err = RegOpenKeyExW( hkey,
                             szBuffer,
                             0,
                             KEY_READ,
                             &hkeyServiceType );
         

        if ( err )
            break;   

        dwLen = sizeof( szBuffer );
        err = RegQueryValueExW( hkeyServiceType,
                                NW_GUID_VALUE_NAME,
                                NULL,
                                NULL,
                                (LPBYTE) szBuffer,  // Buffer big enough to 
                                                    // hold any GUID
                                &dwLen ); // in bytes

        if ( err == ERROR_FILE_NOT_FOUND )
            continue;  // continue with the next key
        else if ( err )
            break;


        // Get rid of the end curly brace 
        szBuffer[ dwLen/sizeof(WCHAR) - 2] = 0;

        err = UuidFromStringW( szBuffer + 1,  // go past the first curly brace
                               &guid );

        if ( err )
            continue;  // continue with the next key, err might be returned
                        // if buffer does not contain a valid GUID

        if ( !memcmp( lpServiceType, &guid, sizeof(GUID)))
        {
            DWORD dwTmp;
            dwLen = sizeof( dwTmp );
            err = RegQueryValueExW( hkeyServiceType,
                                    SERVICE_TYPE_VALUE_SAPID,
                                    NULL,
                                    NULL,
                                    (LPBYTE) &dwTmp, 
                                    &dwLen );  // in bytes

            if ( !err )
            {
                fFound = TRUE;
                *pnSapType = (WORD) dwTmp;
                if ( ARGUMENT_PRESENT( pwPort ))
                {
                    err = RegQueryValueExW( hkeyServiceType,
                                            L"Port",
                                            NULL,
                                            NULL,
                                            (LPBYTE) &dwTmp, 
                                            &dwLen );  // in bytes

                    if ( !err )
                    {
                        *pwPort = (WORD)dwTmp;
                    }
                }
                if ( ARGUMENT_PRESENT( pfConnectionOriented ))
                {
                    err = RegQueryValueExW( hkeyServiceType,
                                            SERVICE_TYPE_VALUE_CONN,
                                            NULL,
                                            NULL,
                                            (LPBYTE) &dwTmp, 
                                            &dwLen );  // in bytes

                    if ( !err )
                        *pfConnectionOriented = dwTmp? 1: 0;
                }
            }
            else if ( err == ERROR_FILE_NOT_FOUND )
            {
                continue;  // continue with the next key since we can't
                           // find Sap Id
            }
            break;
        }
 
        RegCloseKey( hkeyServiceType );
        hkeyServiceType = NULL;
    }

    if ( hkeyServiceType != NULL )
        RegCloseKey( hkeyServiceType );

    if ( hkey != NULL )
        RegCloseKey( hkey );

    return fFound;
}

DWORD
NwpRnR2AddServiceType(
    IN  LPWSTR   lpServiceTypeName,
    IN  LPGUID   lpClassType,
    IN  WORD     wSapId,
    IN  WORD     wPort
)
{
    HKEY hKey, hKeyService;
    PWCHAR pwszUuid;
    DWORD dwDisposition, err;
    DWORD dwValue = (DWORD)wSapId;
    WCHAR  wszUuid[36 + 1 + 2];    // to hold the GUID

    err = RegCreateKeyEx(  HKEY_LOCAL_MACHINE,
                           NW_SERVICE_TYPES_REGKEY,
                           0,
                           TEXT(""),
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE,
                           NULL,
                           &hKey,
                           &dwDisposition );
    
    if(err)
    {
        return(GetLastError());
    }

    //
    // Open the key corresponding to the service (create if not there).
    //

    err = RegCreateKeyEx(
              hKey,
              lpServiceTypeName,
              0,
              TEXT(""),
              REG_OPTION_NON_VOLATILE,
              KEY_READ | KEY_WRITE,
              NULL,
              &hKeyService,
              &dwDisposition
              );

    if(!err)
    {
        //
        // ready to put the GUID value in.
        //

        UuidToString(
            lpClassType,
            &pwszUuid);

        wszUuid[0] = L'{';
        memcpy(&wszUuid[1], pwszUuid, 36 * sizeof(WCHAR));
        wszUuid[37] = L'}';
        wszUuid[38] = 0;

        RpcStringFree(&pwszUuid);

        //
        // write it
        //

        err = RegSetValueEx(
                     hKeyService,
                     L"GUID",
                     0,
                     REG_SZ,
                     (LPBYTE)wszUuid,
                     39 * sizeof(WCHAR));

        if(!err)
        {
            err = RegSetValueEx(
                     hKeyService,
                     L"SAPID",
                     0,
                     REG_DWORD,
                     (LPBYTE)&dwValue,
                     sizeof(DWORD));

            dwValue = (DWORD)wPort;

            err = RegSetValueEx(
                     hKeyService,
                     L"PORT",
                     0,
                     REG_DWORD,
                     (LPBYTE)&dwValue,
                     sizeof(DWORD));
        }
        RegCloseKey(hKeyService);
    }
    RegCloseKey(hKey);
    if(err)
    {
        err = GetLastError();
    }
    return(err);
}


BOOL
NwpRnR2RemoveServiceType(
    IN  LPGUID   lpServiceType
)
{
    DWORD err;
    BOOL  fFound = FALSE;

    HKEY  hkey = NULL;
    HKEY  hkeyServiceType = NULL;
    DWORD dwIndex = 0;
    WCHAR szBuffer[ MAX_PATH + 1];
    WCHAR szGuid[ MAX_PATH + 1];
    DWORD dwLen;
    FILETIME ftLastWrite;

    //
    // Open the service types key
    //
    err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                         NW_SERVICE_TYPES_REGKEY,
                         0,
                         KEY_READ,
                         &hkey );

    if ( err )
    {
        // Cannot find the key because it is not created yet since no
        // one called Add service type. We return FALSE indicating
        // Sap type not found.
        return FALSE;
    }

    //
    // Loop through all subkey of service types to find the GUID
    //
    for ( dwIndex = 0; ; dwIndex++ )
    {
        GUID guid;

        dwLen = sizeof( szBuffer ) / sizeof( WCHAR );
        err = RegEnumKeyExW( hkey,
                             dwIndex,
                             szBuffer,  // Buffer big enough to
                                        // hold any key name
                             &dwLen,    // in characters
                             NULL,
                             NULL,
                             NULL,
                             &ftLastWrite );

        //
        // We will break out of here on any error, this includes
        // the error ERROR_NO_MORE_ITEMS which means that we have finish
        // enumerating all the keys.
        //
        if ( err )
        {
            if ( err == ERROR_NO_MORE_ITEMS )   // No more to enumerate
                err = NO_ERROR;
            break;
        }

        err = RegOpenKeyExW( hkey,
                             szBuffer,
                             0,
                             KEY_READ,
                             &hkeyServiceType );


        if ( err )
            break;

        dwLen = sizeof( szGuid );
        err = RegQueryValueExW( hkeyServiceType,
                                NW_GUID_VALUE_NAME,
                                NULL,
                                NULL,
                                (LPBYTE) szGuid,  // Buffer big enough to
                                                  // hold any GUID
                                &dwLen ); // in bytes

        RegCloseKey( hkeyServiceType );
        hkeyServiceType = NULL;

        if ( err == ERROR_FILE_NOT_FOUND )
            continue;  // continue with the next key
        else if ( err )
            break;

        // Get rid of the end curly brace
        szGuid[ dwLen/sizeof(WCHAR) - 2] = 0;

        err = UuidFromStringW( szGuid + 1,  // go past the first curly brace
                               &guid );

        if ( err )
            continue;  // continue with the next key, err might be returned
                       // if buffer does not contain a valid GUID

        if ( !memcmp( lpServiceType, &guid, sizeof(GUID)))
        {
            (void) RegDeleteKey( hkey, szBuffer );
            fFound = TRUE;
        }
    }

    if ( hkeyServiceType != NULL )
        RegCloseKey( hkeyServiceType );

    if ( hkey != NULL )
        RegCloseKey( hkey );

    return fFound;
}


DWORD 
NwpAddServiceType( 
    IN LPSERVICE_INFO lpServiceInfo, 
    IN BOOL fUnicodeBlob 
)
/*++

Routine Description:

    This routine adds a new service type and its info to the registry under
    Control\ServiceProvider\ServiceTypes

Arguments:

    lpServiceInfo - the ServiceSpecificInfo contains the service type info
    fUnicodeBlob - TRUE if the above field contains unicode data, 
                   FALSE otherwise

Return Value:
   
    Win32 error

--*/
{
    DWORD err;
    HKEY hkey = NULL; 
    HKEY hkeyType = NULL;

    SERVICE_TYPE_INFO *pSvcTypeInfo = (SERVICE_TYPE_INFO *)
        lpServiceInfo->ServiceSpecificInfo.pBlobData;
    LPWSTR pszSvcTypeName;
    UNICODE_STRING uniStr;
    DWORD i;
    PSERVICE_TYPE_VALUE pVal;

    //
    // Get the new service type name
    //
    if ( fUnicodeBlob ) 
    { 
        pszSvcTypeName = (LPWSTR) (((LPBYTE) pSvcTypeInfo) + 
                                   pSvcTypeInfo->dwTypeNameOffset );
    }
    else
    {
        ANSI_STRING ansiStr;

        RtlInitAnsiString( &ansiStr, 
                           (LPSTR) (((LPBYTE) pSvcTypeInfo) + 
                                    pSvcTypeInfo->dwTypeNameOffset ));

        err = RtlAnsiStringToUnicodeString( &uniStr, &ansiStr, TRUE );
        if ( err )
            return err;

        pszSvcTypeName = uniStr.Buffer;
    }

    //
    // If the service type name is an empty string, return error.
    //
    if (  ( pSvcTypeInfo->dwTypeNameOffset == 0 )
       || ( pszSvcTypeName == NULL )
       || ( *pszSvcTypeName == 0 )   // empty string
       )
    {
        err = ERROR_INVALID_PARAMETER;
        goto CleanExit;
         
    }

    //
    // The following keys should have already been created
    //
    err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                         NW_SERVICE_TYPES_REGKEY,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hkey );
    
    if ( err )
        goto CleanExit;
  
    err = RegOpenKeyExW( hkey,
                         pszSvcTypeName,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hkeyType );

    if ( err )
        goto CleanExit;

    //
    // Loop through all values in the specific and add them one by one 
    // to the registry if it belongs to our name space
    //
    for ( i = 0, pVal = pSvcTypeInfo->Values; 
          i < pSvcTypeInfo->dwValueCount; 
          i++, pVal++ )
    {
        if ( ! ((pVal->dwNameSpace == NS_SAP)    ||
                (pVal->dwNameSpace == NS_DEFAULT)) )
        {
            continue;  // ignore values not in our name space
        }

        if ( fUnicodeBlob )
        {
            err = RegSetValueExW( 
                      hkeyType,
                      (LPWSTR) ( ((LPBYTE) pSvcTypeInfo) + pVal->dwValueNameOffset),
                      0,
                      pVal->dwValueType,
                      (LPBYTE) ( ((LPBYTE) pSvcTypeInfo) + pVal->dwValueOffset),
                      pVal->dwValueSize 
                      );
        }
        else
        {
            err = RegSetValueExA( 
                      hkeyType,
                      (LPSTR) ( ((LPBYTE) pSvcTypeInfo) + pVal->dwValueNameOffset),
                      0,
                      pVal->dwValueType,
                      (LPBYTE) ( ((LPBYTE) pSvcTypeInfo) + pVal->dwValueOffset),
                      pVal->dwValueSize 
                      );
        }
    }
     
CleanExit:

    if ( !fUnicodeBlob )
        RtlFreeUnicodeString( &uniStr );

    if ( hkeyType != NULL )
        RegCloseKey( hkeyType );

    if ( hkey != NULL )
        RegCloseKey( hkey );

    return err;

}

DWORD 
NwpDeleteServiceType( 
    IN LPSERVICE_INFO lpServiceInfo, 
    IN BOOL fUnicodeBlob 
)
/*++

Routine Description:

    This routine deletes a service type and its info from the registry under
    Control\ServiceProvider\ServiceTypes

Arguments:

    lpServiceInfo - the ServiceSpecificInfo contains the service type info
    fUnicodeBlob - TRUE if the above field contains unicode data, 
                   FALSE otherwise

Return Value:
   
    Win32 error

--*/
{
    DWORD err;
    HKEY  hkey = NULL;
    SERVICE_TYPE_INFO *pSvcTypeInfo = (SERVICE_TYPE_INFO *)
        lpServiceInfo->ServiceSpecificInfo.pBlobData;
    LPWSTR pszSvcTypeName;
    UNICODE_STRING uniStr;

    //
    // Get the service type name to be deleted
    //
    if ( fUnicodeBlob ) 
    { 
        pszSvcTypeName = (LPWSTR) (((LPBYTE) pSvcTypeInfo) + 
                                   pSvcTypeInfo->dwTypeNameOffset );
    }
    else
    {
        ANSI_STRING ansiStr;

        RtlInitAnsiString( &ansiStr, 
                           (LPSTR) (((LPBYTE) pSvcTypeInfo) + 
                                    pSvcTypeInfo->dwTypeNameOffset ));

        err = RtlAnsiStringToUnicodeString( &uniStr, &ansiStr, TRUE );
        if ( err )
            return err;

        pszSvcTypeName = uniStr.Buffer;
    }

    //
    // If the service type name is an empty string, return error.
    //
    if (  ( pSvcTypeInfo->dwTypeNameOffset == 0 )
       || ( pszSvcTypeName == NULL )
       || ( *pszSvcTypeName == 0 )   // empty string
       )
    {
        err = ERROR_INVALID_PARAMETER;
        goto CleanExit;
         
    }

    err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                         NW_SERVICE_TYPES_REGKEY, 
                         0,
                         KEY_READ | KEY_WRITE,
                         &hkey );


    if ( !err )
    {
        err = RegDeleteKey( hkey,
                            pszSvcTypeName );
    }
   
    if ( err == ERROR_FILE_NOT_FOUND )
    {   
        // Perhaps before calling my provider, the router already deleted the
        // this key, hence just return success;
        err = NO_ERROR;
    }

CleanExit:

    if ( !fUnicodeBlob )
        RtlFreeUnicodeString( &uniStr );

    if ( hkey != NULL )
        RegCloseKey( hkey );

    return err;   
       
}

#define SOCKSIZE (sizeof(SOCKADDR_IPX) + sizeof(DWORD) - 1)

DWORD
FillBufferWithCsAddr(
    IN LPBYTE       pAddress,
    IN DWORD        nProt,
    IN OUT LPVOID   lpCsAddrBuffer,  
    IN OUT LPDWORD  lpdwBufferLength,  
    OUT LPDWORD     pcAddress
)
{
    DWORD nAddrCount = 0;
    CSADDR_INFO  *pCsAddr;
    SOCKADDR_IPX *pAddrLocal, *pAddrRemote;
    DWORD i;
    LPBYTE pBuffer;

    if ( nProt & SPXII_BIT )
        nAddrCount++;

    if ( nProt & IPX_BIT )
        nAddrCount++;

    if ( nProt & SPX_BIT )
        nAddrCount++;

    
    if ( *lpdwBufferLength < 
         nAddrCount * ( sizeof( CSADDR_INFO) + (2*SOCKSIZE)))
    {
        *lpdwBufferLength = sizeof(DWORD) -1 + (nAddrCount * 
                            ( sizeof( CSADDR_INFO) + (2 * SOCKSIZE)));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    pBuffer = ((LPBYTE) lpCsAddrBuffer) + sizeof( CSADDR_INFO) * nAddrCount;

    for ( i = 0, pCsAddr = (CSADDR_INFO *)lpCsAddrBuffer; 
          (i < nAddrCount) && ( nProt != 0 );
          i++, pCsAddr++ ) 
    {
        if ( nProt & SPXII_BIT )
        {
            pCsAddr->iSocketType = SOCK_SEQPACKET;
            pCsAddr->iProtocol   = NSPROTO_SPXII;
            nProt &= ~SPXII_BIT;
        }
        else if ( nProt & IPX_BIT )
        {
            pCsAddr->iSocketType = SOCK_DGRAM;
            pCsAddr->iProtocol   = NSPROTO_IPX;
            nProt &= ~IPX_BIT;
        }
        else if ( nProt & SPX_BIT )
        {
            pCsAddr->iSocketType = SOCK_SEQPACKET;
            pCsAddr->iProtocol   = NSPROTO_SPX;
            nProt &= ~SPX_BIT;
        }
        else
        {
            break;
        }

        pCsAddr->LocalAddr.iSockaddrLength  = sizeof( SOCKADDR_IPX );
        pCsAddr->RemoteAddr.iSockaddrLength = sizeof( SOCKADDR_IPX );
        pCsAddr->LocalAddr.lpSockaddr =  
            (LPSOCKADDR) pBuffer;
        pCsAddr->RemoteAddr.lpSockaddr = 
            (LPSOCKADDR) ( pBuffer + sizeof(SOCKADDR_IPX));
        pBuffer += 2 * sizeof( SOCKADDR_IPX );

        pAddrLocal  = (SOCKADDR_IPX *) pCsAddr->LocalAddr.lpSockaddr;
        pAddrRemote = (SOCKADDR_IPX *) pCsAddr->RemoteAddr.lpSockaddr;

        pAddrLocal->sa_family  = AF_IPX;
        pAddrRemote->sa_family = AF_IPX;

        //
        // The default local sockaddr is for IPX is
        // sa_family = AF_IPX and all other bytes = 0.
        //

        RtlZeroMemory( pAddrLocal->sa_netnum,
                       IPX_ADDRESS_LENGTH );

        //
        // If pAddress is NULL, i.e. we are doing RES_SERVICE, 
        // just make all bytes in remote address zero. 
        //
        if ( pAddress == NULL )
        {
            RtlZeroMemory( pAddrRemote->sa_netnum,
                           IPX_ADDRESS_LENGTH );
        }
        else
        {
            RtlCopyMemory( pAddrRemote->sa_netnum,
                           pAddress,
                           IPX_ADDRESS_LENGTH );
        }
    }

    *pcAddress = nAddrCount;

    return NO_ERROR;
}

VOID
NwInitializeServiceProvider(
    VOID
    )
/*++

Routine Description:

    This routine initializes the service provider.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // nothing more to do
}

VOID
NwTerminateServiceProvider(
    VOID
    )
/*++

Routine Description:

    This routine cleans up the service provider.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PREGISTERED_SERVICE pSvc, pNext;

    //
    // Clean up the link list and stop sending all SAP advertise packets
    //

    EnterCriticalSection( &NwServiceListCriticalSection );

    SetEvent( NwServiceListDoneEvent );

    for ( pSvc = pServiceListHead; pSvc != NULL; pSvc = pNext )
    {
        pNext = pSvc->Next;

        if ( pSvc->fAdvertiseBySap )
        {
            UNICODE_STRING uServer;
            OEM_STRING oemServer;
            NTSTATUS ntstatus;

            RtlInitUnicodeString( &uServer, pSvc->pServiceInfo->lpServiceName );
            ntstatus = RtlUnicodeStringToOemString( &oemServer, &uServer, TRUE);
            if ( NT_SUCCESS( ntstatus ) )
            {
                (VOID) SapRemoveAdvertise( oemServer.Buffer,
                                           pSvc->nSapType );
                RtlFreeOemString( &oemServer );
            }
        }

        (VOID) LocalFree( pSvc->pServiceInfo );
        (VOID) LocalFree( pSvc );
    }

    LeaveCriticalSection( &NwServiceListCriticalSection );

    //
    // Clean up the SAP interface
    //
    (VOID) SapLibShutdown();

    //
    // Clean up the socket interface
    //
    if ( fInitSocket )
    {
        closesocket( socketSap );
//        (VOID) WSACleanup();
    }

}

DWORD
NwRegisterService(
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD nSapType,
    IN HANDLE hEventHandle
    )
/*++

Routine Description:

    This routine registers the given service.

Arguments:

    lpServiceInfo - contains the service information

    nSapType - The SAP type to advertise

    hEventHandle - A handle to the NwDoneEvent if this code is running in
                   the context of Client Services for NetWare. If this is NULL,
                   then CSNW is not available and this code is running in the
                   context of a regular executable.

Return Value:

    Win32 error.

--*/
{
    DWORD err = NO_ERROR;
    NTSTATUS ntstatus;
    DWORD i;
    INT nIPX = -1;

    //
    // Check to see if the service address array contains IPX address,
    // we will only use the first ipx address contained in the array.
    //
    if ( lpServiceInfo->lpServiceAddress == NULL )
        return ERROR_INCORRECT_ADDRESS;

    for ( i = 0; i < lpServiceInfo->lpServiceAddress->dwAddressCount; i++)
    {
        if ( lpServiceInfo->lpServiceAddress->Addresses[i].dwAddressType
             == AF_IPX )
        {
            nIPX = (INT) i;
            break;
        }
    }

    //
    // If we cannot find a IPX address, return error
    //
    if ( nIPX == -1 )
        return ERROR_INCORRECT_ADDRESS;

    //
    // Try to deregister the service since the service might have
    // been registered but not deregistered
    //
    err = NwDeregisterService( lpServiceInfo, nSapType );
    if (  ( err != NO_ERROR )   // deregister successfully
       && ( err != ERROR_SERVICE_NOT_FOUND )  // service not registered before
       )
    {
        return err;
    }

    err = NO_ERROR;

    //
    // Try and see if SAP service can advertise the service for us.
    //
    ntstatus = SapLibInit();
    if ( NT_SUCCESS( ntstatus ))
    {
        UNICODE_STRING uServer;
        OEM_STRING oemServer;
        INT sapRet;
        BOOL fContinueLoop = FALSE;

        RtlInitUnicodeString( &uServer, lpServiceInfo->lpServiceName );
        ntstatus = RtlUnicodeStringToOemString( &oemServer, &uServer, TRUE );
        if ( !NT_SUCCESS( ntstatus ))
            return RtlNtStatusToDosError( ntstatus );


        do
        {
            fContinueLoop = FALSE;

            sapRet = SapAddAdvertise( oemServer.Buffer,
                                      nSapType,
                                      (LPBYTE) (((LPSOCKADDR_IPX) lpServiceInfo->lpServiceAddress->Addresses[nIPX].lpAddress)->sa_netnum),
                                      FALSE );

            switch ( sapRet )
            {
                case SAPRETURN_SUCCESS:
                {
                    err = AddServiceToList( lpServiceInfo, nSapType, TRUE, nIPX );
                    if ( err )
                        (VOID) SapRemoveAdvertise( oemServer.Buffer, nSapType );
                    RtlFreeOemString( &oemServer );

                    return err;
                }

                case SAPRETURN_NOMEMORY:
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;

                case SAPRETURN_EXISTS:
                {
                    //
                    // Someone else is already advertising the service
                    // directly through SAP service. Remove it and
                    // readvertise with the new information.
                    //
                    sapRet = SapRemoveAdvertise( oemServer.Buffer, nSapType );
                    switch ( sapRet )
                    {
                        case SAPRETURN_SUCCESS:
                            fContinueLoop = TRUE;   // go thru once more
                            break;

                        case SAPRETURN_NOMEMORY:
                            err = ERROR_NOT_ENOUGH_MEMORY;
                            break;

                        case SAPRETURN_NOTEXIST:
                        case SAPRETURN_INVALIDNAME:
                        default:  // Should not have any other errors
                            err = ERROR_INVALID_PARAMETER;
                            break;
                    }
                    break;
                }

                case SAPRETURN_INVALIDNAME:
                    err = ERROR_INVALID_PARAMETER;
                    break;

                case SAPRETURN_DUPLICATE:
                    err = NO_ERROR;
                    break;

                default:  // Should not have any other errors
                    err = ERROR_INVALID_PARAMETER;
                    break;
            }
        } while ( fContinueLoop );

        RtlFreeOemString( &oemServer );

        if ( err )
        {
            return err;
        }
    }

    //
    // At this point, we failed to ask Sap service to advertise the
    // service for us.  So we advertise it ourselves.
    //

    if ( !fInitSocket )
    {
        err = NwInitializeSocket( hEventHandle );
    }

    if ( err == NO_ERROR )
    {
        err = NwAdvertiseService( lpServiceInfo->lpServiceName,
                                  nSapType,
                                  ((LPSOCKADDR_IPX) lpServiceInfo->lpServiceAddress->Addresses[nIPX].lpAddress),
                                  hEventHandle );

        //
        // Adding the service to the list will result in a resend
        // of advertising packets every 60 seconds
        //

        if ( err == NO_ERROR )
        {
            err = AddServiceToList( lpServiceInfo, nSapType, FALSE, nIPX );
        }
    }

    return err;
}

DWORD
NwDeregisterService(
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD nSapType
    )
/*++

Routine Description:

    This routine deregisters the given service.

Arguments:

    lpServiceInfo - contains the service information

    nSapType - SAP type to deregister

Return Value:

    Win32 error.

--*/
{
    PREGISTERED_SERVICE pSvc;

    //
    // Check if the requested service type and name has already been registered.
    // If yes, then return error.
    //

    pSvc = GetServiceItemFromList( nSapType, lpServiceInfo->lpServiceName );
    if ( pSvc == NULL )
        return ERROR_SERVICE_NOT_FOUND;

    //
    // If SAP service is advertising the service for us, ask
    // the SAP service to stop advertising.
    //

    if ( pSvc->fAdvertiseBySap )
    {
        UNICODE_STRING uServer;
        OEM_STRING oemServer;
        NTSTATUS ntstatus;
        INT sapRet;

        RtlInitUnicodeString( &uServer, lpServiceInfo->lpServiceName );
        ntstatus = RtlUnicodeStringToOemString( &oemServer, &uServer, TRUE );
        if ( !NT_SUCCESS( ntstatus ) )
            return RtlNtStatusToDosError( ntstatus );

        sapRet = SapRemoveAdvertise( oemServer.Buffer, nSapType );
        RtlFreeOemString( &oemServer );

        switch ( sapRet )
        {
            case SAPRETURN_NOMEMORY:
                return ERROR_NOT_ENOUGH_MEMORY;

            case SAPRETURN_NOTEXIST:
            case SAPRETURN_INVALIDNAME:
                return ERROR_INVALID_PARAMETER;

            case SAPRETURN_SUCCESS:
                break;

            // Should not have any other errors
            default:
                break;
        }

    }

    //
    // Remove the service item from the link list
    //
    RemoveServiceFromList( pSvc );

    return NO_ERROR;
}

BOOL
OldRnRCheckCancel(
    PVOID pvArg
    )
/*++
Routine Description:
    Determine if the cancel event is signaled
--*/
{
    POLDRNRSAP porns = (POLDRNRSAP)pvArg;

    if ((porns->hCancel) == NULL)
        return(FALSE);
    else if(!WaitForSingleObject(porns->hCancel, 0))
    {
        return(TRUE);
    }
    return(FALSE);
}


DWORD
OldRnRCheckSapData(
    PSAP_BCAST_CONTROL psbc,
    PSAP_IDENT_HEADER pSap,
    PDWORD pdwErr
    )
{
/*++
Routine Description:
    Coroutine called when a SAP reply is recevied. This checks to see
    if the reply satisfies the request.
Argument:
    pvArg -- actually a pointer to an SAP_BCAST_CONTROL
--*/
    POLDRNRSAP porns = (POLDRNRSAP)psbc->pvArg;

    if(strcmp(porns->poem->Buffer, pSap->ServerName) == 0)
    {
        //
        // it matches. We are done!
        //

        *pdwErr = FillBufferWithCsAddr(pSap->Address,
                                       porns->nProt,
                                       porns->lpCsAddrBuffer,
                                       porns->lpdwBufferLength,
                                       porns->lpcAddress);
        return(dwrcDone);
    }
    return(dwrcNil);
}
        


DWORD
NwpGetAddressViaSap( 
    IN WORD nServiceType,
    IN LPWSTR lpServiceName,
    IN DWORD  nProt,
    IN OUT LPVOID  lpCsAddrBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN HANDLE hCancellationEvent,
    OUT LPDWORD lpcAddress 
    )
/*++

Routine Description:

    This routine uses SAP requests to find the address of the given service 
    name/type. It can handle looking up by name and type alone.

Arguments:

    Handle    - the RnR handle, if appropriate

    nServiceType - service type

    lpServiceName - unique string representing the service name

    lpCsAddrBuffer - on return, will be filled with CSADDR_INFO structures

    lpdwBufferLength - on input, the number of bytes contained in the buffer
        pointed to by lpCsAddrBuffer. On output, the minimum number of bytes
        to pass for the lpCsAddrBuffer to retrieve all the requested info

    hCancellationEvent - the event which signals us to cancel the request

    lpcAddress - on output, the number of CSADDR_INFO structures returned

Return Value:

    Win32 error code.

--*/
{
    DWORD err = NO_ERROR;
    NTSTATUS ntstatus;
    UNICODE_STRING UServiceName;
    OEM_STRING OemServiceName;
    SOCKET socketSap;
    SAP_RNR_CONTEXT src;
    PSAP_BCAST_CONTROL psbc = &src.u_type.sbc;
    OLDRNRSAP ors;

    *lpcAddress = 0;

    _wcsupr( lpServiceName );
    RtlInitUnicodeString( &UServiceName, lpServiceName ); 
    ntstatus = RtlUnicodeStringToOemString( &OemServiceName,
                                            &UServiceName,
                                            TRUE );
    if ( !NT_SUCCESS( ntstatus ))
        return RtlNtStatusToDosError( ntstatus );
        
    memset(&src, 0, sizeof(src));

    err = SapGetSapSocket(&psbc->s);
    if ( err )
    {
        RtlFreeOemString( &OemServiceName );
        return err;
    }

    psbc->psrc = &src;
    psbc->dwIndex = 0;
    psbc->dwTickCount = 0;
    psbc->pvArg = (PVOID)&ors;
    psbc->Func = OldRnRCheckSapData;
    psbc->fCheckCancel =  OldRnRCheckCancel;
    psbc->fFlags = 0;
    psbc->wQueryType = QT_GENERAL_QUERY;

    

    ors.poem = &OemServiceName;
    ors.hCancel = hCancellationEvent,
    ors.lpCsAddrBuffer = lpCsAddrBuffer;
    ors.lpdwBufferLength = lpdwBufferLength;
    ors.lpcAddress = lpcAddress;
    ors.nProt = nProt;

    err = SapGetSapForType(psbc, nServiceType);

    RtlFreeOemString( &OemServiceName );

    //
    // Clean up the socket interface
    //
    (VOID)SapFreeSapSocket(psbc->s);

    return err;     
}



DWORD
NwGetService(
    IN  LPWSTR  Reserved,
    IN  WORD    nSapType,
    IN  LPWSTR  lpServiceName,
    IN  DWORD   dwProperties,
    OUT LPBYTE  lpServiceInfo,
    IN  DWORD   dwBufferLength,
    OUT LPDWORD lpdwBytesNeeded
    )
/*++
Routine Description:

    This routine gets the service info.

Arguments:

    Reserved - unused

    nSapType - SAP type

    lpServiceName - service name

    dwProperties -  specifys the properties of the service info needed

    lpServiceInfo - on output, contains the SERVICE_INFO

    dwBufferLength - size of buffer pointed by lpServiceInfo

    lpdwBytesNeeded - if the buffer pointed by lpServiceInfo is not large
                      enough, this will contain the bytes needed on output

Return Value:

    Win32 error.

--*/
{
    DWORD err = NO_ERROR;
    DWORD nSize = sizeof(SERVICE_INFO);
    PREGISTERED_SERVICE pSvc;
    PSERVICE_INFO pSvcInfo = (PSERVICE_INFO) lpServiceInfo;
    LPBYTE pBufferStart;

    UNREFERENCED_PARAMETER( Reserved );

    //
    // Check if all parameters passed in are valid
    //
    if ( lpServiceInfo == NULL || lpServiceName == NULL ||
        wcslen( lpServiceName ) > SAP_OBJECT_NAME_MAX_LENGTH-1 )
        return ERROR_INVALID_PARAMETER;

    pSvc = GetServiceItemFromList( nSapType, lpServiceName );
    if ( pSvc == NULL )
        return ERROR_SERVICE_NOT_FOUND;

    //
    // Calculate the size needed to return the requested info
    //
    if (  (( dwProperties == PROP_ALL ) || ( dwProperties & PROP_COMMENT ))
       && ( pSvc->pServiceInfo->lpComment != NULL )
       )
    {
        nSize += ( wcslen( pSvc->pServiceInfo->lpComment) + 1) * sizeof(WCHAR);
    }

    if (  (( dwProperties == PROP_ALL ) || ( dwProperties & PROP_LOCALE ))
       && ( pSvc->pServiceInfo->lpLocale != NULL )
       )
    {
        nSize += ( wcslen( pSvc->pServiceInfo->lpLocale) + 1) * sizeof(WCHAR);
    }

    if (  (( dwProperties == PROP_ALL ) || ( dwProperties & PROP_MACHINE ))
       && ( pSvc->pServiceInfo->lpMachineName != NULL )
       )
    {
        nSize += ( wcslen( pSvc->pServiceInfo->lpMachineName) + 1) * sizeof(WCHAR);
    }

    if (( dwProperties == PROP_ALL ) || ( dwProperties & PROP_ADDRESSES ))
    {
        DWORD i;
        DWORD dwCount = pSvc->pServiceInfo->lpServiceAddress->dwAddressCount;

        nSize = ROUND_UP_COUNT( nSize, ALIGN_QUAD );
        nSize += sizeof( SERVICE_ADDRESSES );
        if ( dwCount > 1 )
            nSize += ( dwCount - 1 ) * sizeof( SERVICE_ADDRESS );

        for ( i = 0; i < dwCount; i++ )
        {
            SERVICE_ADDRESS *pAddr =
                &(pSvc->pServiceInfo->lpServiceAddress->Addresses[i]);


            nSize = ROUND_UP_COUNT( nSize, ALIGN_QUAD );
            nSize += pAddr->dwAddressLength;
            nSize = ROUND_UP_COUNT( nSize, ALIGN_QUAD );
            nSize += pAddr->dwPrincipalLength;
        }
    }

    if (( dwProperties == PROP_ALL ) || ( dwProperties & PROP_SD ))
    {
        nSize = ROUND_UP_COUNT( nSize, ALIGN_QUAD );
        nSize += pSvc->pServiceInfo->ServiceSpecificInfo.cbSize;
    }

    //
    // Return error if the buffer passed in is not big enough
    //
    if ( dwBufferLength < nSize )
    {
        *lpdwBytesNeeded = nSize;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Fill in all requested service info
    //
    memset( pSvcInfo, 0, sizeof(*pSvcInfo)); // Make all fields 0 i.e.
                                             // all pointer fields NULL

    pSvcInfo->dwDisplayHint = pSvc->pServiceInfo->dwDisplayHint;
    pSvcInfo->dwVersion = pSvc->pServiceInfo->dwVersion;
    pSvcInfo->dwTime = pSvc->pServiceInfo->dwTime;

    pBufferStart = ((LPBYTE) pSvcInfo) + sizeof( *pSvcInfo );

    if (  (( dwProperties == PROP_ALL ) || ( dwProperties & PROP_COMMENT ))
       && ( pSvc->pServiceInfo->lpComment != NULL )
       )
    {
        pSvcInfo->lpComment = (LPWSTR) pBufferStart;
        wcscpy( pSvcInfo->lpComment, pSvc->pServiceInfo->lpComment );
        pBufferStart += ( wcslen( pSvcInfo->lpComment ) + 1) * sizeof(WCHAR);

        pSvcInfo->lpComment = (LPWSTR) ((LPBYTE) pSvcInfo->lpComment - lpServiceInfo );
    }

    if (  (( dwProperties == PROP_ALL ) || ( dwProperties & PROP_LOCALE ))
       && ( pSvc->pServiceInfo->lpLocale != NULL )
       )
    {
        pSvcInfo->lpLocale = (LPWSTR) pBufferStart;
        wcscpy( pSvcInfo->lpLocale, pSvc->pServiceInfo->lpLocale );
        pBufferStart += ( wcslen( pSvcInfo->lpLocale ) + 1) * sizeof(WCHAR);
        pSvcInfo->lpLocale = (LPWSTR) ((LPBYTE) pSvcInfo->lpLocale - lpServiceInfo);
    }

    if (  (( dwProperties == PROP_ALL ) || ( dwProperties & PROP_MACHINE ))
       && ( pSvc->pServiceInfo->lpMachineName != NULL )
       )
    {
        pSvcInfo->lpMachineName = (LPWSTR) pBufferStart;
        wcscpy( pSvcInfo->lpMachineName, pSvc->pServiceInfo->lpMachineName );
        pBufferStart += ( wcslen( pSvcInfo->lpMachineName) + 1) * sizeof(WCHAR);
        pSvcInfo->lpMachineName = (LPWSTR) ((LPBYTE) pSvcInfo->lpMachineName -
                                                 lpServiceInfo );
    }

    if (( dwProperties == PROP_ALL ) || ( dwProperties & PROP_ADDRESSES ))
    {
        DWORD i, dwCount, dwLen;

        pBufferStart = ROUND_UP_POINTER( pBufferStart, ALIGN_QUAD );
        pSvcInfo->lpServiceAddress = (LPSERVICE_ADDRESSES) pBufferStart;
        dwCount = pSvcInfo->lpServiceAddress->dwAddressCount =
                  pSvc->pServiceInfo->lpServiceAddress->dwAddressCount;

        pBufferStart += sizeof( SERVICE_ADDRESSES );

        for ( i = 0; i < dwCount; i++ )
        {
            SERVICE_ADDRESS *pTmpAddr =
                &( pSvcInfo->lpServiceAddress->Addresses[i]);

            SERVICE_ADDRESS *pAddr =
                &( pSvc->pServiceInfo->lpServiceAddress->Addresses[i]);

            pTmpAddr->dwAddressType  = pAddr->dwAddressType;
            pTmpAddr->dwAddressFlags = pAddr->dwAddressFlags;

            //
            // setup Address
            //
            pBufferStart = ROUND_UP_POINTER( pBufferStart, ALIGN_QUAD );
            pTmpAddr->lpAddress = (LPBYTE) ( pBufferStart - lpServiceInfo );
            pTmpAddr->dwAddressLength = pAddr->dwAddressLength;
            memcpy( pBufferStart, pAddr->lpAddress, pAddr->dwAddressLength );
            pBufferStart += pAddr->dwAddressLength;

            //
            // setup Principal
            //
            pBufferStart = ROUND_UP_POINTER( pBufferStart, ALIGN_QUAD );
            pTmpAddr->lpPrincipal = (LPBYTE) ( pBufferStart - lpServiceInfo );
            pTmpAddr->dwPrincipalLength = pAddr->dwPrincipalLength;
            memcpy(pBufferStart, pAddr->lpPrincipal, pAddr->dwPrincipalLength );
            pBufferStart += pAddr->dwPrincipalLength;
        }

        pSvcInfo->lpServiceAddress = (LPSERVICE_ADDRESSES)
            ((LPBYTE) pSvcInfo->lpServiceAddress - lpServiceInfo);
    }

    if (( dwProperties == PROP_ALL ) || ( dwProperties & PROP_SD ))
    {
        pBufferStart = ROUND_UP_POINTER( pBufferStart, ALIGN_QUAD );
        pSvcInfo->ServiceSpecificInfo.cbSize =
            pSvc->pServiceInfo->ServiceSpecificInfo.cbSize;
        pSvcInfo->ServiceSpecificInfo.pBlobData = pBufferStart;
        RtlCopyMemory( pSvcInfo->ServiceSpecificInfo.pBlobData,
                       pSvc->pServiceInfo->ServiceSpecificInfo.pBlobData,
                       pSvcInfo->ServiceSpecificInfo.cbSize );
        pSvcInfo->ServiceSpecificInfo.pBlobData =
            (LPBYTE) ( pSvcInfo->ServiceSpecificInfo.pBlobData - lpServiceInfo);
    }

    return NO_ERROR;
}

DWORD
NwInitializeSocket(
    IN HANDLE hEventHandle
    )
/*++

Routine Description:

    This routine initializes the socket needed for us to do the
    SAP advertise ourselves.

Arguments:

    hEventHandle - A handle to the NwDoneEvent if this code is running in
                   the context of a service. Otherwise this code is running
                   in the context of a regular executable.

Return Value:

    Win32 error.

--*/
{
    DWORD err = NO_ERROR;
    WSADATA wsaData;
    SOCKADDR_IPX socketAddr;
    INT nValue;
    HANDLE hThread;
    DWORD dwThreadId;

    if ( fInitSocket )
        return NO_ERROR;

    //
    // Initialize the socket interface
    //
//    err = WSAStartup( WSOCK_VER_REQD, &wsaData );
//    if ( err )
//        return err;

    //
    // Open an IPX datagram socket
    //
    socketSap = socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
    if ( socketSap == INVALID_SOCKET )
        return WSAGetLastError();

    //
    // Allow sending of broadcasts
    //
    nValue = 1;
    if ( setsockopt( socketSap,
                     SOL_SOCKET,
                     SO_BROADCAST,
                     (PVOID) &nValue,
                     sizeof(INT)) == SOCKET_ERROR )
    {
        err = WSAGetLastError();
        goto CleanExit;
    }

    //
    // Bind the socket
    //
    memset( &socketAddr, 0, sizeof( SOCKADDR_IPX));
    socketAddr.sa_family = AF_IPX;
    socketAddr.sa_socket = 0;     // no specific port

    if ( bind( socketSap,
               (PSOCKADDR) &socketAddr,
               sizeof( SOCKADDR_IPX)) == SOCKET_ERROR )
    {
        err = WSAGetLastError();
        goto CleanExit;
    }

    //
    // Set the extended address option
    //
    nValue = 1;
    if ( setsockopt( socketSap,                     // Socket Handle
                     NSPROTO_IPX,                   // Option Level
                     IPX_EXTENDED_ADDRESS,          // Option Name
                     (PUCHAR)&nValue,               // Ptr to on/off flag
                     sizeof(INT)) == SOCKET_ERROR ) // Length of flag
    {

        err = WSAGetLastError();
        goto CleanExit;
    }

    //
    // tommye - MS bug 98946 
    // Load ourselves to increment the ref count.  This is a fix 
    // for a bug where we would exit, then the SapFunc would wake 
    // up and AV because we were no more.
    //

    hThisDll = LoadLibrary(L"nwprovau.dll");

    //
    // Create the thread that loops through the registered service
    // link list and send out SAP advertise packets for each one of them
    //

    hThread = CreateThread( NULL,          // no security attributes
                            0,             // default stack size
                            SapFunc,       // thread function
                            hEventHandle,  // argument to SapFunc
                            0,             // default creation flags
                            &dwThreadId );

    if ( hThread == NULL )
    {
        err = GetLastError();
        goto CleanExit;
    }

    fInitSocket = TRUE;

CleanExit:

    if ( err )
        closesocket( socketSap );

    return err;
}

DWORD
NwAdvertiseService(
    IN LPWSTR lpServiceName,
    IN WORD nSapType,
    IN LPSOCKADDR_IPX pAddr,
    IN HANDLE hEventHandle
    )
/*++

Routine Description:

    This routine sends out SAP identification packets for the
    given service name and type.

Arguments:

    lpServiceName - unique string representing the service name

    nSapType - SAP type

    pAddr - address of the service

    hEventHandle - A handle to the NwDoneEvent if this code is running in
                   the context of a service. Otherwise this code is running
                   in the context of a regular executable.

Return Value:

    Win32 error.

--*/
{
    NTSTATUS ntstatus;

    UNICODE_STRING uServiceName;
    OEM_STRING oemServiceName;

    SAP_IDENT_HEADER_EX sapIdent;
    UCHAR destAddr[SAP_ADDRESS_LENGTH];
    PSOCKADDR_IPX pAddrTmp = pAddr;
    SOCKADDR_IPX newAddr;
    SOCKADDR_IPX bindAddr;
    DWORD len = sizeof( SOCKADDR_IPX );
    DWORD getsockname_rc ;

    if ( !fInitSocket )
    {
        DWORD err = NwInitializeSocket( hEventHandle );
        if  ( err )
             return err;
    }

    //
    // get local addressing info. we are only interested in the net number.
    //
    getsockname_rc = getsockname( socketSap,
                                 (PSOCKADDR) &bindAddr,
                                 &len );

    //
    // Convert the service name to OEM string
    //
    RtlInitUnicodeString( &uServiceName, lpServiceName );
    ntstatus = RtlUnicodeStringToOemString( &oemServiceName,
                                            &uServiceName,
                                            TRUE );
    if ( !NT_SUCCESS( ntstatus ))
        return RtlNtStatusToDosError( ntstatus );

    _strupr( (LPSTR) oemServiceName.Buffer );

    if ( !memcmp( pAddr->sa_netnum,
                  "\x00\x00\x00\x00",
                  IPX_ADDRESS_NETNUM_LENGTH ))
    {
        if ( getsockname_rc != SOCKET_ERROR )
        {
            // copy the ipx address to advertise
            memcpy( &newAddr,
                    pAddr,
                    sizeof( SOCKADDR_IPX));

            // replace the net number with the correct one
            memcpy( &(newAddr.sa_netnum),
                    &(bindAddr.sa_netnum),
                    IPX_ADDRESS_NETNUM_LENGTH );

            pAddrTmp = &newAddr;
        }
    }

    //
    // Format the SAP identification packet
    //

    sapIdent.ResponseType = htons( 2 );
    sapIdent.ServerType   = htons( nSapType );
    memset( sapIdent.ServerName, '\0', SAP_OBJECT_NAME_MAX_LENGTH );
    strcpy( sapIdent.ServerName, oemServiceName.Buffer );
    RtlCopyMemory( sapIdent.Address, pAddrTmp->sa_netnum, IPX_ADDRESS_LENGTH );
    sapIdent.HopCount = htons( 1 );

    RtlFreeOemString( &oemServiceName );

    //
    // Set the address to send to
    //
    memcpy( destAddr, SapBroadcastAddress, SAP_ADDRESS_LENGTH );
    if ( getsockname_rc != SOCKET_ERROR )
    {
        LPSOCKADDR_IPX newDestAddr = (LPSOCKADDR_IPX)destAddr ;

        //
        // replace the net number with the correct one
        //
        memcpy( &(newDestAddr->sa_netnum),
                &(bindAddr.sa_netnum),
                IPX_ADDRESS_NETNUM_LENGTH );

    }

    //
    // Send the packet out
    //
    if ( sendto( socketSap,
                 (PVOID) &sapIdent,
                 sizeof( sapIdent ),
                 0,
                 (PSOCKADDR) destAddr,
                 SAP_ADDRESS_LENGTH ) == SOCKET_ERROR )
    {
        return WSAGetLastError();
    }

    return NO_ERROR;
}

DWORD
AddServiceToList(
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD nSapType,
    IN BOOL fAdvertiseBySap,
    IN INT  nIndexIPXAddress
    )
/*++

Routine Description:

    This routine adds the service to the link list of services
    we advertised.

Arguments:

    lpServiceInfo - service information

    nSapType - SAP type

    fAdvertiseBySap - TRUE if this service is advertised by SAP service,
                      FALSE if we are advertising ourselves.

    nIndexIPXAddress - index of the ipx address

Return Value:

    Win32 error.

--*/
{
    PREGISTERED_SERVICE pSvcNew;
    PSERVICE_INFO pSI;
    LPBYTE pBufferStart;
    DWORD nSize = 0;

    //
    // Allocate a new entry for the service list
    //

    pSvcNew = LocalAlloc( LMEM_ZEROINIT, sizeof( REGISTERED_SERVICE ));
    if ( pSvcNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    //
    // Calculate the size needed for the SERVICE_INFO structure
    //
    nSize = sizeof( *lpServiceInfo)
            + sizeof( *(lpServiceInfo->lpServiceType));

    if ( lpServiceInfo->lpServiceName != NULL )
        nSize += ( wcslen( lpServiceInfo->lpServiceName) + 1) * sizeof(WCHAR);
    if ( lpServiceInfo->lpComment != NULL )
        nSize += ( wcslen( lpServiceInfo->lpComment) + 1) * sizeof(WCHAR);
    if ( lpServiceInfo->lpLocale != NULL )
        nSize += ( wcslen( lpServiceInfo->lpLocale) + 1) * sizeof(WCHAR);
    if ( lpServiceInfo->lpMachineName != NULL )
        nSize += ( wcslen( lpServiceInfo->lpMachineName) + 1) * sizeof(WCHAR);

    nSize = ROUND_UP_COUNT( nSize, ALIGN_QUAD );

    if ( lpServiceInfo->lpServiceAddress != NULL )
    {
        nSize += sizeof( SERVICE_ADDRESSES );
        nSize = ROUND_UP_COUNT( nSize, ALIGN_QUAD );

        nSize += lpServiceInfo->lpServiceAddress->Addresses[nIndexIPXAddress].dwAddressLength;
        nSize = ROUND_UP_COUNT( nSize, ALIGN_QUAD );

        nSize += lpServiceInfo->lpServiceAddress->Addresses[nIndexIPXAddress].dwPrincipalLength;
        nSize = ROUND_UP_COUNT( nSize, ALIGN_QUAD );
    }

    nSize += lpServiceInfo->ServiceSpecificInfo.cbSize ;

    //
    // Allocate a SERVICE_INFO structure for the new list entry
    //
    pSI = LocalAlloc( LMEM_ZEROINIT, nSize );
    if ( pSI == NULL )
    {
        LocalFree( pSvcNew );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the information of SERVICE_INFO into list entry
    //
    *pSI = *lpServiceInfo;

    pBufferStart = (( (LPBYTE) pSI) + sizeof( *lpServiceInfo ));

    pSI->lpServiceType = (LPGUID) pBufferStart;
    *(pSI->lpServiceType) = *(lpServiceInfo->lpServiceType);
    pBufferStart += sizeof( *(lpServiceInfo->lpServiceType) );

    if ( lpServiceInfo->lpServiceName != NULL )
    {
        pSI->lpServiceName = (LPWSTR) pBufferStart;
        wcscpy( pSI->lpServiceName, lpServiceInfo->lpServiceName );
        _wcsupr( pSI->lpServiceName );
        pBufferStart += ( wcslen( lpServiceInfo->lpServiceName ) + 1 )
                        * sizeof(WCHAR);
    }

    if ( lpServiceInfo->lpComment != NULL )
    {
        pSI->lpComment = (LPWSTR) pBufferStart;
        wcscpy( pSI->lpComment, lpServiceInfo->lpComment );
        pBufferStart += ( wcslen( lpServiceInfo->lpComment ) + 1 )
                        * sizeof(WCHAR);
    }

    if ( lpServiceInfo->lpLocale != NULL )
    {
        pSI->lpLocale = (LPWSTR) pBufferStart;
        wcscpy( pSI->lpLocale, lpServiceInfo->lpLocale );
        pBufferStart += ( wcslen( lpServiceInfo->lpLocale ) + 1 )
                        * sizeof(WCHAR);
    }

    if ( lpServiceInfo->lpMachineName != NULL )
    {
        pSI->lpMachineName = (LPWSTR) pBufferStart;
        wcscpy( pSI->lpMachineName, lpServiceInfo->lpMachineName );
        pBufferStart += (wcslen( lpServiceInfo->lpMachineName ) + 1)
                        * sizeof(WCHAR);
    }

    pBufferStart = ROUND_UP_POINTER( pBufferStart, ALIGN_QUAD) ;

    if ( lpServiceInfo->lpServiceAddress != NULL )
    {
        DWORD nSize;

        pSI->lpServiceAddress = (LPSERVICE_ADDRESSES) pBufferStart;
        pSI->lpServiceAddress->dwAddressCount = 1;  // Just 1 IPX address

        memcpy( &(pSI->lpServiceAddress->Addresses[0]),
                &(lpServiceInfo->lpServiceAddress->Addresses[nIndexIPXAddress]),
                sizeof( SERVICE_ADDRESS) );
        pBufferStart += sizeof( SERVICE_ADDRESSES);

        pBufferStart = ROUND_UP_POINTER( pBufferStart, ALIGN_QUAD) ;
        nSize = pSI->lpServiceAddress->Addresses[0].dwAddressLength;
        pSI->lpServiceAddress->Addresses[0].lpAddress = pBufferStart;
        memcpy( pBufferStart,
                lpServiceInfo->lpServiceAddress->Addresses[nIndexIPXAddress].lpAddress,
                nSize );
        pBufferStart += nSize;

        pBufferStart = ROUND_UP_POINTER( pBufferStart, ALIGN_QUAD) ;
        nSize = pSI->lpServiceAddress->Addresses[0].dwPrincipalLength;
        pSI->lpServiceAddress->Addresses[0].lpPrincipal = pBufferStart;
        memcpy( pBufferStart,
                lpServiceInfo->lpServiceAddress->Addresses[nIndexIPXAddress].lpPrincipal,
                nSize );
        pBufferStart += nSize;
        pBufferStart = ROUND_UP_POINTER( pBufferStart, ALIGN_QUAD) ;
    }

    pSI->ServiceSpecificInfo.pBlobData = pBufferStart;
    RtlCopyMemory( pSI->ServiceSpecificInfo.pBlobData,
                   lpServiceInfo->ServiceSpecificInfo.pBlobData,
                   pSI->ServiceSpecificInfo.cbSize );

    //
    // Fill in the data in the list entry
    //
    pSvcNew->nSapType = nSapType;
    pSvcNew->fAdvertiseBySap = fAdvertiseBySap;
    pSvcNew->Next = NULL;
    pSvcNew->pServiceInfo = pSI;

    //
    // Add the newly created list entry into the service list
    //
    EnterCriticalSection( &NwServiceListCriticalSection );

    if ( pServiceListHead == NULL )
        pServiceListHead = pSvcNew;
    else
        pServiceListTail->Next = pSvcNew;

    pServiceListTail = pSvcNew;

    LeaveCriticalSection( &NwServiceListCriticalSection );

    return NO_ERROR;
}

VOID
RemoveServiceFromList(
    PREGISTERED_SERVICE pSvc
    )
/*++

Routine Description:

    This routine removes the service from the link list of services
    we advertised.

Arguments:

    pSvc - the registered service node to remove

Return Value:

    None.

--*/
{
    PREGISTERED_SERVICE pCur, pPrev;

    EnterCriticalSection( &NwServiceListCriticalSection );

    for ( pCur = pServiceListHead, pPrev = NULL ; pCur != NULL;
          pPrev = pCur, pCur = pCur->Next )
    {
        if ( pCur == pSvc )
        {
            if ( pPrev == NULL )  // i.e. pCur == pSvc == pServiceListHead
            {
                pServiceListHead = pSvc->Next;
                if ( pServiceListTail == pSvc )
                    pServiceListTail = NULL;
            }
            else
            {
                pPrev->Next = pSvc->Next;
                if ( pServiceListTail == pSvc )
                    pServiceListTail = pPrev;
            }

            (VOID) LocalFree( pCur->pServiceInfo );
            (VOID) LocalFree( pCur );
            break;
        }
    }

    LeaveCriticalSection( &NwServiceListCriticalSection );
}

PREGISTERED_SERVICE
GetServiceItemFromList(
    IN WORD   nSapType,
    IN LPWSTR pServiceName
    )
/*++

Routine Description:

    This routine returns the registered service node with the given
    service name and type.

Arguments:

    nSapType - SAP type

    pServiceName - service name

Return Value:

    Returns the pointer to the registered service node,
    NULL if we cannot find the service type/name.

--*/
{
    PREGISTERED_SERVICE pSvc;

    EnterCriticalSection( &NwServiceListCriticalSection );

    for ( pSvc = pServiceListHead; pSvc != NULL; pSvc = pSvc->Next )
    {
        if (  ( pSvc->nSapType == nSapType )
           && ( _wcsicmp( pSvc->pServiceInfo->lpServiceName, pServiceName ) == 0)
           )
        {
            LeaveCriticalSection( &NwServiceListCriticalSection );

            return pSvc;
        }
    }

    LeaveCriticalSection( &NwServiceListCriticalSection );
    return NULL;
}

DWORD
SapFunc(
    HANDLE hEventHandle
    )
/*++

Routine Description:

    This routine is a separate thread that wakes up every 60 seconds
    and advertise all the service contained in the service link list
    that are not advertised by the SAP service.

Arguments:

    hEventHandle - used to notify thread that server is stopping

Return Value:

    Win32 error.

--*/
{
    DWORD err = NO_ERROR;

    //
    // This thread loops until the service is shut down or when some error
    // occurred in WaitForSingleObject
    //

    while ( TRUE )
    {
        DWORD rc;

        if ( hEventHandle != NULL )
        {
            rc = WaitForSingleObject( hEventHandle, SAP_ADVERTISE_FREQUENCY );
        }
        else
        {
            // Sleep( SAP_ADVERTISE_FREQUENCY );
            // rc = WAIT_TIMEOUT;

            return ERROR_INVALID_PARAMETER;
        }

        if ( rc == WAIT_FAILED )
        {
            err = GetLastError();
            break;
        }
        else if ( rc == WAIT_OBJECT_0 )
        {
            //
            // The service is stopping, break out of the loop and
            // return, thus terminating the thread
            //
            break;
        }
        else if ( rc == WAIT_TIMEOUT )
        {
            PREGISTERED_SERVICE pSvc;
            SOCKADDR_IPX bindAddr;
            DWORD fGetAddr;

            fGetAddr = FALSE;

            //
            // Time out occurred, time to send the SAP advertise packets
            //

            EnterCriticalSection( &NwServiceListCriticalSection );

            if ( pServiceListHead == NULL )
            {
                LeaveCriticalSection( &NwServiceListCriticalSection );

                //
                // Clean up the SAP interface
                //
                (VOID) SapLibShutdown();

                //
                // Clean up the socket interface
                //
                if ( fInitSocket )
                {
                    closesocket( socketSap );
//                    (VOID) WSACleanup();
                }

                break;
            }

            for ( pSvc = pServiceListHead; pSvc != NULL; pSvc = pSvc->Next )
            {
                 if ( !pSvc->fAdvertiseBySap )
                 {
                     //
                     // Ignore the error since we can't return
                     // nor pop up the error
                     //

                     SOCKADDR_IPX *pAddr = (SOCKADDR_IPX *)
                         pSvc->pServiceInfo->lpServiceAddress->Addresses[0].lpAddress;
                     SOCKADDR_IPX *pAddrToAdvertise = pAddr;
                     SOCKADDR_IPX newAddr;

                     if ( !memcmp( pAddr->sa_netnum,
                                  "\x00\x00\x00\x00",
                                  IPX_ADDRESS_NETNUM_LENGTH ))
                     {

                         if ( !fGetAddr )
                         {
                             DWORD len = sizeof( SOCKADDR_IPX );

                             rc = getsockname( socketSap,
                                               (PSOCKADDR) &bindAddr,
                                               &len );

                             if ( rc != SOCKET_ERROR )
                                 fGetAddr = TRUE;
                         }

                         if ( fGetAddr )
                         {
                             // copy the ipx address to advertise
                             memcpy( &newAddr,
                                     pAddr,
                                     sizeof( SOCKADDR_IPX));

                             // replace the net number with the correct one
                             memcpy( &(newAddr.sa_netnum),
                                     &(bindAddr.sa_netnum),
                                     IPX_ADDRESS_NETNUM_LENGTH );

                             pAddr = &newAddr;
                         }
                     }

                     (VOID) NwAdvertiseService(
                                pSvc->pServiceInfo->lpServiceName,
                                pSvc->nSapType,
                                pAddr,
                                hEventHandle );
                 }
            }

            LeaveCriticalSection( &NwServiceListCriticalSection );
        }
    }

    //
    // tommye - Part of the bug fix above in NwInitializeSocket.
    // This will deref the DLL that we loaded so that we don't 
    // unload out from under ourselves.
    //

    FreeLibraryAndExitThread(hThisDll, err);

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwclsid.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwclsid.h

Abstract:

    Contain the class IDs used in the shell extensions.

Author:

    Yi-Hsin Sung       (yihsins)    20-Oct-1995   

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NWCLSID_H_
#define _NWCLSID_H_

DEFINE_GUID( CLSID_NetWareObjectExt,  0x8e9d6600, 0xf84a, 0x11ce, 0x8d, 0xaa, 0x00, 0xaa, 0x00, 0x4a, 0x56, 0x91 );

DEFINE_GUID( CLSID_NetWareFolderMenuExt, 0xe3f2bac0, 0x099f, 0x11cf, 0x8d, 0xaa, 0x00, 0xaa, 0x00, 0x4a, 0x56, 0x91 );

DEFINE_GUID( CLSID_NetworkNeighborhoodMenuExt, 0x52c68510, 0x09a0, 0x11cf, 0x8d, 0xaa, 0x00, 0xaa, 0x00, 0x4a, 0x56, 0x91 );


#endif // _NWCLSID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwapi.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    api.c

Abstract:

    This module contains exposed APIs that is used by the
    NetWare Control Panel Applet.

Author:

    Yi-Hsin Sung   15-Jul-1993

Revision History:

    ChuckC         23-Jul-93        Completed the stubs

--*/

#include <nwclient.h>
#include <nwcanon.h>
#include <validc.h>
#include <nwdlg.h>
#include <nwreg.h>
#include <nwapi.h>
#include <ntddnwfs.h>

//Multi-User code merge
DWORD
NwpCitrixGetUserInfo(
    LPWSTR  *ppszUserSid
);
//
// forward declare
//

DWORD
NwpGetCurrentUserRegKey(
    IN  DWORD DesiredAccess,
    OUT HKEY  *phKeyCurrentUser
    );



DWORD
NwQueryInfo(
    OUT PDWORD pnPrintOptions,
    OUT LPWSTR *ppszPreferredSrv  
    )
/*++

Routine Description:
    This routine gets the user's preferred server and print options from
    the registry.

Arguments:

    pnPrintOptions - Receives the user's print option

    ppszPreferredSrv - Receives the user's preferred server
    

Return Value:

    Returns the appropriate Win32 error.

--*/
{
  
    HKEY hKeyCurrentUser = NULL;
    DWORD BufferSize;
    DWORD BytesNeeded;
    DWORD PrintOption;
    DWORD ValueType;
    LPWSTR PreferredServer ;
    DWORD err ;

    //
    // get to right place in registry and allocate dthe buffer
    //
    if (err = NwpGetCurrentUserRegKey( KEY_READ, &hKeyCurrentUser))
    {
        //
        // If somebody mess around with the registry and we can't find
        // the registry, just use the defaults.
        //
        *ppszPreferredSrv = NULL;
        *pnPrintOptions = NW_PRINT_OPTION_DEFAULT; 
        return NO_ERROR;
    }

    BufferSize = sizeof(WCHAR) * (MAX_PATH + 2) ;
    PreferredServer = (LPWSTR) LocalAlloc(LPTR, BufferSize) ;
    if (!PreferredServer)
        return (GetLastError()) ;
    
    //
    // Read PreferredServer value into Buffer.
    //
    BytesNeeded = BufferSize ;

    err = RegQueryValueExW( hKeyCurrentUser,
                            NW_SERVER_VALUENAME,
                            NULL,
                            &ValueType,
                            (LPBYTE) PreferredServer,
                            &BytesNeeded );

    if (err != NO_ERROR) 
    {
        //
        // set to empty and carry on
        //
        PreferredServer[0] = 0;  
    }

    //
    // Read PrintOption value into PrintOption.
    //
    BytesNeeded = sizeof(PrintOption);

    err = RegQueryValueExW( hKeyCurrentUser,
                            NW_PRINTOPTION_VALUENAME,
                            NULL,
                            &ValueType,
                            (LPBYTE) &PrintOption,
                            &BytesNeeded );

    if (err != NO_ERROR) 
    {
        //
        // set to default and carry on
        //
        PrintOption = NW_PRINT_OPTION_DEFAULT; 
    }

    if (hKeyCurrentUser != NULL)
        (void) RegCloseKey(hKeyCurrentUser) ;
    *ppszPreferredSrv = PreferredServer ;
    *pnPrintOptions = PrintOption ;
    return NO_ERROR ;
}



DWORD
NwSetInfoInRegistry(
    IN DWORD  nPrintOptions, 
    IN LPWSTR pszPreferredSrv 
    )
/*++

Routine Description:

    This routine set the user's print option and preferred server into
    the registry.

Arguments:
    
    nPrintOptions - Supplies the print option.

    pszPreferredSrv - Supplies the preferred server.
    
Return Value:

    Returns the appropriate Win32 error.

--*/
{

    HKEY hKeyCurrentUser = NULL;

    DWORD err = NwpGetCurrentUserRegKey( KEY_SET_VALUE,
                                         &hKeyCurrentUser );
    if (err != NO_ERROR)
        return err;

    err = RegSetValueEx(hKeyCurrentUser,
                        NW_SERVER_VALUENAME,
                        0,
                        REG_SZ,
                        (CONST BYTE *)pszPreferredSrv,
                        (wcslen(pszPreferredSrv)+1) * sizeof(WCHAR)) ;
                        
    if (err != NO_ERROR) 
    {
        if (hKeyCurrentUser != NULL)
            (void) RegCloseKey(hKeyCurrentUser) ;
        return err;
    }

    err = RegSetValueEx(hKeyCurrentUser,
                        NW_PRINTOPTION_VALUENAME,
                        0,
                        REG_DWORD,
                        (CONST BYTE *)&nPrintOptions,
                        sizeof(nPrintOptions)) ;

    if (hKeyCurrentUser != NULL)
        (void) RegCloseKey(hKeyCurrentUser) ;
    return err;
}
DWORD
NwQueryLogonOptions(
    OUT PDWORD  pnLogonScriptOptions
    )
/*++

Routine Description:
    This routine gets the user's Logon script options from the registry.

Arguments:

    pnLogonScriptOptions - Receives the user's Logon script options


Return Value:

    Returns the appropriate Win32 error.

--*/
{
  
    HKEY hKeyCurrentUser;
    DWORD BytesNeeded;
    DWORD LogonScriptOption;
    DWORD ValueType;
    DWORD err ;

    //
    // get to right place in registry and allocate the buffer
    //
    if (err = NwpGetCurrentUserRegKey( KEY_READ, &hKeyCurrentUser))
    {
        //
        // If somebody mess around with the registry and we can't find
        // the registry, assume no.
        //
        *pnLogonScriptOptions = NW_LOGONSCRIPT_DEFAULT ; 
        return NO_ERROR;
    }

    //
    // Read LogonScriptOption value into LogonScriptOption.
    //
    BytesNeeded = sizeof(LogonScriptOption);

    err = RegQueryValueExW( hKeyCurrentUser,
                            NW_LOGONSCRIPT_VALUENAME,
                            NULL,
                            &ValueType,
                            (LPBYTE) &LogonScriptOption,
                            &BytesNeeded );

    if (err != NO_ERROR) 
    {
        //
        // default to nothing and carry on
        //
        LogonScriptOption = NW_LOGONSCRIPT_DEFAULT; 
    }

    *pnLogonScriptOptions = LogonScriptOption ;
    return NO_ERROR ;
}

DWORD
NwSetLogonOptionsInRegistry(
    IN DWORD  nLogonScriptOptions
    )
/*++

Routine Description:

    This routine set the logon script options in the registry.

Arguments:
    
    nLogonScriptOptions - Supplies the logon options

Return Value:

    Returns the appropriate Win32 error.

--*/
{

    HKEY hKeyCurrentUser;

    DWORD err = NwpGetCurrentUserRegKey( KEY_SET_VALUE,
                                         &hKeyCurrentUser );
    if (err != NO_ERROR)
        return err;

    err = RegSetValueEx(hKeyCurrentUser,
                        NW_LOGONSCRIPT_VALUENAME,
                        0,
                        REG_DWORD,
                        (CONST BYTE *)&nLogonScriptOptions,
                        sizeof(nLogonScriptOptions)) ;
                        
    (void) RegCloseKey( hKeyCurrentUser );
    return err;
}


DWORD
NwSetInfoInWksta(
    IN DWORD  nPrintOption,
    IN LPWSTR pszPreferredSrv
)
/*++

Routine Description:

    This routine notifies the workstation service and the redirector 
    about the user's new print option and preferred server.

Arguments:

    nPrintOptions - Supplies the print option.

    pszPreferredSrv - Supplies the preferred server.

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD err;

    RpcTryExcept {

        err = NwrSetInfo( NULL, nPrintOption, pszPreferredSrv );

    }
    RpcExcept(1) {

        err = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    return err;

}

DWORD
NwSetLogonScript(
    IN DWORD  ScriptOptions
)
/*++

Routine Description:

    This routine notifies the workstation service of login script
    options.

Arguments:

    ScriptOptions - Supplies the options.

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD err;

    RpcTryExcept {

        err = NwrSetLogonScript( NULL, ScriptOptions );

    }
    RpcExcept(1) {

        err = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    return err;

}


DWORD
NwValidateUser(
    IN LPWSTR pszPreferredSrv
)
/*++

Routine Description:

    This routine checks to see if the user can be authenticated on the
    chosen preferred server.

Arguments:

    pszPreferredSrv - Supplies the preferred server name.

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD err;

    //
    // Don't need to validate if the preferred server is NULL or empty string
    //
    if (  ( pszPreferredSrv == NULL ) 
       || ( *pszPreferredSrv == 0 )
       )
    {
        return NO_ERROR;
    }

    //
    // See if the name contains any invalid characters
    // 
    if ( !IS_VALID_SERVER_TOKEN( pszPreferredSrv, wcslen( pszPreferredSrv )))
        return ERROR_INVALID_NAME;

    RpcTryExcept {

        err = NwrValidateUser( NULL, pszPreferredSrv );

    }
    RpcExcept(1) {

        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}


DWORD
NwpGetCurrentUserRegKey(
    IN  DWORD DesiredAccess,
    OUT HKEY  *phKeyCurrentUser
    )
/*++

Routine Description:

    This routine opens the current user's registry key under
    \HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NWCWorkstation\Parameters

Arguments:

    DesiredAccess - The access mask to open the key with

    phKeyCurrentUser - Receives the opened key handle

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD err;
    HKEY hkeyWksta;
    LPWSTR CurrentUser;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    err = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &hkeyWksta
                   );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open Parameters key unexpected error %lu!\n", err));
        return err;
    }

        // -- MultiUser code merge ----
        //  Get the current user's SID string
        //  DON'T look in the registry.  This thread should be owned by the
        //  user.
        //
        CurrentUser = NULL;
        err = NwpCitrixGetUserInfo( &CurrentUser );
        if ( err ) {
            KdPrint(("NWPROVAU: NwGetCurrentUserRegKey get CurrentUser SID unexpected error %lu!\n", err));
            (void) RegCloseKey( hkeyWksta );
            return err;
        }
        //
        // Get the current user's SID string.
        //
        //err = NwReadRegValue(
        //                    hkeyWksta,
        //                    NW_CURRENTUSER_VALUENAME,
        //                    &CurrentUser
        //                    );


    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey read CurrentUser value unexpected error %lu!\n", err));
        (void) RegCloseKey( hkeyWksta );
        return err;
    }

    (void) RegCloseKey( hkeyWksta );

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\Option
    //
    err = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_OPTION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &hkeyWksta
                   );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open Parameters\\Option key unexpected error %lu!\n", err));
        return err;
    }

    //
    // Open current user's key
    //
    err = RegOpenKeyExW(
              hkeyWksta,
              CurrentUser,
              REG_OPTION_NON_VOLATILE,
              DesiredAccess,
              phKeyCurrentUser
              );

    if ( err == ERROR_FILE_NOT_FOUND) 
    {
        DWORD Disposition;

        //
        // Create <NewUser> key under NWCWorkstation\Parameters\Option
        //
        err = RegCreateKeyExW(
                  hkeyWksta,
                  CurrentUser,
                  0,
                  WIN31_CLASS,
                  REG_OPTION_NON_VOLATILE,
                  DesiredAccess,
                  NULL,                      // security attr
                  phKeyCurrentUser,
                  &Disposition
                  );

        if ( err == NO_ERROR )
        {
            err = NwLibSetEverybodyPermission( *phKeyCurrentUser,
                                               KEY_SET_VALUE );

            if ( err != NO_ERROR )
            {
                KdPrint(("NWPROVAU: NwpSaveLogonCredential set security on Option\\%ws key unexpected error %lu!\n", CurrentUser, err));
            }
        }
    }

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open or create of Parameters\\Option\\%ws key failed %lu\n", CurrentUser, err));
    }

    (void) RegCloseKey( hkeyWksta );
    (void) LocalFree((HLOCAL)CurrentUser) ;
    return err;
}

NTSTATUS
NwGetUserNameForServer(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING UserName
    )
/*++

Routine Description:

    Calls the redir to get the User Name used to connect to the server
    in question.

Arguments:

    ServerName - the server in question

    UserName -   used to return the user name

Return Value:

    Returns the appropriate NTSTATUS

--*/
{
    NTSTATUS Status;
    WCHAR LocalUserName[NW_MAX_USERNAME_LEN];
    ULONG UserNameLen = sizeof(LocalUserName);

    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING DriverName;
    HANDLE RdrHandle = NULL;
    IO_STATUS_BLOCK IoStatus;

    //
    // Initialize variables
    //

    RtlInitUnicodeString( &DriverName, DD_NWFS_DEVICE_NAME_U );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &DriverName,
        0,
        NULL,
        NULL
        );

    //
    // open handle to the redir
    //

    Status = NtOpenFile(
                &RdrHandle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ,
                0                   // open options
                );

    if (!NT_SUCCESS(Status) ||
        !NT_SUCCESS(IoStatus.Status) ) 
    {
        return( Status );
    }


    //
    // Call the driver to get use the user name
    //

    Status = NtFsControlFile(
                RdrHandle,
                NULL,
                NULL,
                NULL,
                &IoStatus,
                FSCTL_NWR_GET_USERNAME,
                ServerName->Buffer,
                ServerName->Length,
                LocalUserName,
                UserNameLen
                );

    NtClose(RdrHandle);

    if (!NT_SUCCESS(Status)) 
    {
        return(Status);
    }

    //
    // copy the info if it fits. set size required and fail otherwise.
    //

    if (UserName->MaximumLength >= IoStatus.Information) 
    {
        UserName->Length = (USHORT) IoStatus.Information;

        RtlCopyMemory( UserName->Buffer,
                       LocalUserName,
                       UserNameLen );
        Status = STATUS_SUCCESS;
    }
    else 
    {
        UserName->Length = (USHORT) IoStatus.Information;
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    return(Status);
}


NTSTATUS
NwEncryptChallenge(
    IN PUCHAR Challenge,
    IN ULONG ObjectId,
    IN OPTIONAL PUNICODE_STRING ServerName,
    IN OPTIONAL PUNICODE_STRING Password,
    OUT PUCHAR ChallengeResponse,
    OUT OPTIONAL PUCHAR SessionKey
    )
/*++

Routine Description:

    Calls the redir to encrypt a challenge

Arguments:

    Challenge -         Challenge key

    ObjectId -          User's object ID

    ServerName -        The server to authenticate against

    Password -          Password supplied

    ChallengeResponse - Used to return the challenge response

    SessionKey -        Used to return the session key

Return Value:

    Returns the appropriate NTSTATUS

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING DriverName;
    HANDLE RdrHandle = NULL;
    IO_STATUS_BLOCK IoStatus;
    PNWR_GET_CHALLENGE_REQUEST ChallengeRequest = NULL;
    NWR_GET_CHALLENGE_REPLY ChallengeReply;
    ULONG ChallengeRequestSize;

    //
    // Initialize variables
    //

    RtlInitUnicodeString( &DriverName, DD_NWFS_DEVICE_NAME_U );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DriverName,
        0,
        NULL,
        NULL
        );

    //
    // open handle to redirector
    //

    Status = NtOpenFile(
                &RdrHandle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ,
                0                   // open options
                );

    if (!NT_SUCCESS(Status) ||
        !NT_SUCCESS(IoStatus.Status) ) 
    {
        return( Status );
    }



    ChallengeRequestSize = sizeof(NWR_GET_CHALLENGE_REQUEST) +
                            ((Password != NULL) ? Password->Length : 0) +
                            ((ServerName != NULL) ? ServerName->Length : 0);

    ChallengeRequest = (PNWR_GET_CHALLENGE_REQUEST) RtlAllocateHeap(
                                                        RtlProcessHeap(),
                                                        0,
                                                        ChallengeRequestSize
                                                        );

    if (ChallengeRequest == NULL ) 
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Marshall the challenge request structure.  Only send servername if
    // password has not been specified.
    //

    ChallengeRequest->ObjectId = ObjectId;
    ChallengeRequest->Flags = 0;

    //
    // If both password and servername are present, use the password.
    //

    if ((Password != NULL) && (Password->Length != 0)) 
    {

        ChallengeRequest->ServerNameorPasswordLength = Password->Length;
        RtlCopyMemory(
            ChallengeRequest->ServerNameorPassword,
            Password->Buffer,
            Password->Length
            );
        ChallengeRequest->Flags = CHALLENGE_FLAGS_PASSWORD;

    }
    else if ((ServerName != NULL) && (ServerName->Length != 0)) 
    {

        ChallengeRequest->ServerNameorPasswordLength = ServerName->Length;

        RtlCopyMemory(
            ChallengeRequest->ServerNameorPassword,
            ServerName->Buffer,
            ServerName->Length
            );

        ChallengeRequest->Flags = CHALLENGE_FLAGS_SERVERNAME;
    }

    RtlCopyMemory(
        ChallengeRequest->Challenge,
        Challenge,
        8
        );

    //
    // Issue FS control to redir to get challenge response
    //

    Status = NtFsControlFile(
                RdrHandle,
                NULL,
                NULL,
                NULL,
                &IoStatus,
                FSCTL_NWR_CHALLENGE,
                ChallengeRequest,
                ChallengeRequestSize,
                &ChallengeReply,
                sizeof(ChallengeReply)
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(IoStatus.Status)) {
        goto Cleanup;
    }


    RtlCopyMemory(
        ChallengeResponse,
        ChallengeReply.Challenge,
        8
        );

    if (SessionKey != NULL) 
    {
        RtlCopyMemory(
            ChallengeResponse,
            ChallengeReply.Challenge,
            8
            );
    }

Cleanup:

    if (RdrHandle != NULL) 
    {
        NtClose(RdrHandle);
    }

    if (ChallengeRequest != NULL) 
    {
        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            ChallengeRequest
            );
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwclient.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwclient.h

Abstract:

    Common header for Workstation client-side code.

Author:

    Rita Wong      (ritaw)      25-Feb-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NWCLIENT_INCLUDED_
#define _NWCLIENT_INCLUDED_

#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <npapi.h>

#include <nwwks.h>

//
// Debug trace level bits for turning on/off trace statements in the
// Workstation service
//

//
// Initialization and reading info from registry
//
#define NW_DEBUG_INIT         0x00000001

//
// Connection APIs
//
#define NW_DEBUG_CONNECT      0x00000002

//
// Logon APIs
//
#define NW_DEBUG_LOGON        0x00000004

//
// Enum APIs
//
#define NW_DEBUG_ENUM         0x00000008

//
// Other APIs
//
#define NW_DEBUG_OTHER        0x00000010

//
// Print APIs
//
#define NW_DEBUG_PRINT        0x00000020

//
// hInstance of the dll ( nwprovau.dll )
//
extern HMODULE hmodNW;   
extern BOOL    fIsWinnt;

//
// Debug stuff
//

#if DBG

extern DWORD NwProviderTrace;

#define IF_DEBUG(DebugCode) if (NwProviderTrace & NW_DEBUG_ ## DebugCode)

#define STATIC

#else

#define IF_DEBUG(DebugCode) if (FALSE)

#define STATIC static

#endif // DBG

DWORD
NwpMapRpcError(
    IN DWORD RpcError
    );

DWORD
NwpConvertSid(
    IN PSID    Sid,
    OUT LPWSTR *UserSidString
    );

DWORD
NwpCacheCredentials(
    IN LPWSTR RemoteName,
    IN LPWSTR UserName,
    IN LPWSTR Password
    );
    
BOOL 
NwpRetrieveCachedCredentials(
    IN  LPWSTR RemoteName,
    OUT LPWSTR *UserName,
    OUT LPWSTR *Password
    );

#ifndef NT1057
VOID
NwCleanupShellExtensions(
    VOID
    );
#endif

#endif // _NWCLIENT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwshcmn.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshcmn.h

Abstract:

    Common header file for shell extensions

Author:

    Yi-Hsin Sung      (yihsins)     20-Oct-1995

Revision History:

--*/

#ifndef _NWSHCMN_H_
#define _NWSHCMN_H_

#if 0
#define ODS(sz) OutputDebugString(sz)
#else
#define ODS(sz) 
#endif

#define TREECHAR   L'*'

#define MAX_ONE_NETRES_SIZE  1024

extern "C" 
{
extern HINSTANCE hmodNW;
}
extern LONG g_cRefThisDll;         // Reference count of this DLL.

typedef UINT
(WINAPI *SHELLGETNETRESOURCE)( HNRES hnres, 
                               UINT iItem, 
                               LPNETRESOURCE pnres, 
                               UINT cbMax );

typedef UINT
(WINAPI *SHELLDRAGQUERYFILE)( HDROP  hdrop,
                              UINT   iItem,
                              LPWSTR pszItem,
                              UINT   cbMax);

typedef VOID 
(WINAPI *SHELLCHANGENOTIFY)( LONG wEventId,
                             UINT uFlags,
                             LPCVOID dwItem1, 
                             LPCVOID dwItem2 );

typedef BOOL
(WINAPI *SHELLEXECUTEEX)( LPSHELLEXECUTEINFOW lpExecInfo );
    

extern SHELLGETNETRESOURCE g_pFuncSHGetNetResource;
extern SHELLDRAGQUERYFILE  g_pFuncSHDragQueryFile;
extern SHELLCHANGENOTIFY   g_pFuncSHChangeNotify;
extern SHELLEXECUTEEX      g_pFuncSHExecuteEx;
extern WCHAR               g_szProviderName[];

VOID  HideControl( HWND hwndDlg, WORD wID );
VOID  UnHideControl( HWND hwndDlg, WORD wID );
VOID  EnableDlgItem( HWND hwndDlg, WORD wID, BOOL fEnable);

DWORD MsgBoxPrintf( HWND hwnd, UINT uiMsg, UINT uiTitle, UINT uiFlags,...);
DWORD MsgBoxErrorPrintf( HWND hwnd, UINT uiMsg, UINT uiTitle, UINT uiFlags, DWORD errNum, LPWSTR pszInsertStr );
DWORD LoadMsgPrintf( LPWSTR *ppszMessage, UINT uiMsg, ...);
DWORD LoadMsgErrorPrintf( LPWSTR *ppszMessage, UINT uiMsg, DWORD errNum );

#if 0
HRESULT
NWUISetDefaultContext( 
    HWND hParent, 
    LPNETRESOURCE pNetRes
);
#endif

HRESULT
NWUIWhoAmI( 
    HWND hParent, 
    LPNETRESOURCE pNetRes
);

HRESULT
NWUILogOut( 
    HWND hParent, 
    LPNETRESOURCE pNetRes,
    PBOOL pfDisconnected
);

HRESULT
NWUIAttachAs( 
    HWND hParent, 
    LPNETRESOURCE pNetRes
);

HRESULT
NWUIMapNetworkDrive( 
    HWND hParent, 
    LPNETRESOURCE pNetRes
);

HRESULT
NWUIGlobalWhoAmI( 
    HWND hParent 
);

#endif // _NWSHCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwdlg.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwdlg.h

Abstract:

    Dialog ID header for NetWare login dialog.

Author:

    Rita Wong      (ritaw)      17-Mar-1993

Revision History:

--*/

#ifndef _NWDLG_INCLUDED_
#define _NWDLG_INCLUDED_

#include "nwapi.h"
#include "nwshrc.h"
#include <windows.h>

typedef struct _LOGIN_DLG_PARAMETERS
{
    LPWSTR  UserName;
    LPWSTR  ServerName;
    LPWSTR  Password;
    LPWSTR  NewUserSid;
    PLUID   pLogonId;
    DWORD   ServerNameSize;
    DWORD   PasswordSize;
    DWORD   LogonScriptOptions;
    DWORD   PrintOption;

} LOGINDLGPARAM, *PLOGINDLGPARAM;

typedef struct _PASSWD_DLG_PARAMETERS
{
    LPWSTR  UserName;
    LPWSTR  ServerName;
    DWORD   UserNameSize;
    DWORD   ServerNameSize;

} PASSWDDLGPARAM, *PPASSWDDLGPARAM;

typedef struct _CHANGE_PW_DLG_PARAM
{
    PWCHAR UserName;
    PWCHAR OldPassword;
    PWCHAR NewPassword;
    LPWSTR *TreeList;
    LPWSTR *UserList;
    DWORD Entries;
    BOOL ChangedOne;

} CHANGE_PW_DLG_PARAM, *PCHANGE_PW_DLG_PARAM;

typedef struct _OLD_PW_DLG_PARAM
{
    PWCHAR OldPassword;
    PWCHAR FailedServer;

} OLD_PW_DLG_PARAM, *POLD_PW_DLG_PARAM;

typedef struct _ALT_UN_DLG_PARAM
{
    PWCHAR UserName;
    PWCHAR TreeServerName;

} USERNAME_DLG_PARAM, *PUSERNAME_DLG_PARAM;

typedef struct _PROMPT_DLG_PARAMETERS
{
    LPWSTR  UserName;
    LPWSTR  ServerName;
    LPWSTR  Password;
    DWORD   PasswordSize;

} PROMPTDLGPARAM, *PPROMPTDLGPARAM;

typedef struct _CONNECT_DLG_PARAMETERS
{
    LPWSTR  UncPath;
    LPWSTR  ConnectAsUserName;
    LPWSTR  UserName;
    LPWSTR  Password;
    DWORD   UserNameSize;
    DWORD   PasswordSize;
    DWORD   LastConnectionError;

} CONNECTDLGPARAM, *PCONNECTDLGPARAM;

typedef struct _CHANGE_PASS_DLG_PARAM
{
    PWCHAR UserName;
    PWCHAR TreeName;
    PWCHAR OldPassword;
    PWCHAR NewPassword;

} CHANGE_PASS_DLG_PARAM, *PCHANGE_PASS_DLG_PARAM;



#define NW_INVALID_SERVER_CHAR L'.'

INT_PTR
CALLBACK
NwpLoginDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM Parameter1,
    LPARAM Parameter2
    );

INT_PTR
CALLBACK
NwpSelectServersDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    );

INT_PTR
CALLBACK
NwpChangePasswdDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM Parameter1,
    LPARAM Parameter2
    );

INT_PTR
CALLBACK
NwpPasswdPromptDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM Parameter1,
    LPARAM Parameter2
    );

INT_PTR
CALLBACK
NwpChangePasswordDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM Parameter1,
    LPARAM Parameter2
    );

INT_PTR
CALLBACK
NwpHelpDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM Parameter1,
    LPARAM Parameter2
    );

INT_PTR
CALLBACK
NwpChangePasswordSuccessDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    );

INT
NwpMessageBoxError(
    IN HWND   hwndParent,
    IN DWORD  nTitleId,
    IN DWORD  nBodyId, 
    IN DWORD  nParameterId,
    IN LPWSTR szParameter2,
    IN UINT   nStyle
    );

INT
NwpMessageBoxIns(
    IN HWND   hwndParent,
    IN DWORD  TitleId,
    IN DWORD  MessageId, 
    IN LPWSTR *InsertStrings,
    IN UINT   nStyle
    );

DWORD
NwpGetUserCredential(
    IN HWND   hwndOwner,
    IN LPWSTR Unc,
    IN DWORD  LastConnectionError,
    IN LPWSTR pszConnectAsUserName,
    OUT LPWSTR *UserName,
    OUT LPWSTR *Password
    );

VOID
NwpSaveLogonCredential(
    IN LPWSTR NewUser,
    IN PLUID LogonId OPTIONAL,
    IN LPWSTR UserName,
    IN LPWSTR Password,
    IN LPWSTR PreferredServer OPTIONAL
    );

DWORD
NwpSaveLogonScriptOptions(
    IN LPWSTR CurrentUserSid,
    IN DWORD LogonScriptOptions
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwdlg.c ===
/*++

Copyright (c) 1993, 1994  Microsoft Corporation

Module Name:

    nwdlg.c

Abstract:

    This module contains NetWare Network Provider Dialog code.
    It contains all functions used in handling the dialogs
    shown by the provider.


Author:

    Yi-Hsin Sung (yihsins)  5-July-1993
        Split from provider.c

Revision History:

    Rita Wong    (ritaw)    10-Apr-1994
        Added change password functionality.

--*/

#include <nwclient.h>
#include <nwsnames.h>
#include <nwcanon.h>
#include <validc.h>
#include <nwevent.h>
#include <ntmsv1_0.h>
#include <nwdlg.h>
#include <tstr.h>
#include <align.h>
#include <nwpkstr.h>

#include <nwreg.h>
#include <nwmisc.h>
#include <nwauth.h>
#include <nwutil.h>
#include <ntddnwfs.h>
#include <nds.h>

#define NW_ENUM_EXTRA_BYTES    256

#define IS_TREE(p)             (*p == TREE_CHAR)

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

VOID
NwpAddToComboBox(
    IN HWND DialogHandle,
    IN INT  ControlId,
    IN LPWSTR pszNone OPTIONAL,
    IN BOOL AllowNone
    );

INT_PTR
CALLBACK
NwpConnectDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    );

VOID
NwpCenterDialog(
    IN HWND hwnd
    );

HWND
NwpGetParentHwnd(
    VOID
    );

VOID
NwpGetNoneString(
    LPWSTR pszNone,
    DWORD  cBufferSize
    );

VOID
NwpAddNetWareTreeConnectionsToList(
    IN HWND    DialogHandle,
    IN LPWSTR  NtUserName,
    IN LPDWORD lpdwUserLuid,
    IN INT     ControlId
    );

VOID
NwpAddServersToControl(
    IN HWND DialogHandle,
    IN INT  ControlId,
    IN UINT Message,
    IN INT  ControlIdMatch OPTIONAL,
    IN UINT FindMessage
    );

VOID
NwpAddTreeNamesToControl(
    IN HWND DialogHandle,
    IN INT  ControlId,
    IN UINT Message,
    IN INT  ControlIdMatch OPTIONAL,
    IN UINT FindMessage
    );

DWORD
NwpGetTreesAndChangePw(
    IN HWND   DialogHandle,
    IN LPWSTR ServerBuf,
    IN DWORD  UserLuid,
    IN PCHANGE_PW_DLG_PARAM Credential
    );

INT_PTR
CALLBACK
NwpOldPasswordDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    );

INT_PTR
CALLBACK
NwpAltUserNameDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    );

VOID
EnableAddRemove(
    IN HWND DialogHandle
    );


INT_PTR
CALLBACK
NwpLoginDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
/*++

Routine Description:

    This function is the window management message handler which
    initializes, and reads user input from the login dialog.  It also
    checks that the preferred server name is valid, notifies the user
    if not, and dismisses the dialog when done.

Arguments:

    DialogHandle - Supplies a handle to the login dialog.

    Message - Supplies the window management message.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    static PLOGINDLGPARAM pLoginParam;
    static WCHAR OrigPassword[NW_MAX_SERVER_LEN + 1];
    static WCHAR pszNone[64];

    DWORD status = NO_ERROR;
    LPARAM dwNoneIndex = 0;
    BOOL  enableServer = TRUE ;

    switch (Message)
    {
        case WM_QUERYENDSESSION:

            //
            // Clear the password buffer
            //

            RtlZeroMemory( OrigPassword, sizeof( OrigPassword));
            EndDialog(DialogHandle, 0);

            return FALSE;

        case WM_INITDIALOG:

            pLoginParam = (PLOGINDLGPARAM) LParam;

            //
            // Store the original password
            //
            wcscpy( OrigPassword, pLoginParam->Password );

            //
            // Position dialog
            //
            NwpCenterDialog(DialogHandle);

            //
            // Handle logon script button
            //
            if ( pLoginParam->LogonScriptOptions & NW_LOGONSCRIPT_ENABLED )
                CheckDlgButton( DialogHandle, ID_LOGONSCRIPT, 1 );
            else
                CheckDlgButton( DialogHandle, ID_LOGONSCRIPT, 0 );

            //
            // Username.  Just display the original.
            //
            SetDlgItemTextW(DialogHandle, ID_USERNAME, pLoginParam->UserName);

            //
            // Initialize the <None> string.
            //
            NwpGetNoneString( pszNone, sizeof( pszNone) );

            //
            // Set the values in combo-box list.
            //
            NwpAddToComboBox(DialogHandle, ID_SERVER, pszNone, TRUE);
            NwpAddTreeNamesToControl(DialogHandle, ID_DEFAULTTREE, CB_ADDSTRING, 0, 0);


            //
            // Initially, select the last entry in server list, which should
            // be the <None> entry.
            //
            dwNoneIndex = SendDlgItemMessageW(
                            DialogHandle,
                            ID_SERVER,
                            CB_GETCOUNT,
                            0,
                            0 );

            if ( dwNoneIndex != CB_ERR && dwNoneIndex > 0 )
                dwNoneIndex -= 1;

            (void) SendDlgItemMessageW(
                            DialogHandle,
                            ID_SERVER,
                            CB_SETCURSEL,
                            dwNoneIndex == CB_ERR ? 0 : dwNoneIndex, 
                            0 );

            //
            // Display the previously saved preferred server or context.
            // Also set appropriate radio button
            //
            if ( *(pLoginParam->ServerName) != NW_INVALID_SERVER_CHAR )
            {
                if ( !IS_TREE(pLoginParam->ServerName) )
                {
                    //
                    // regular server
                    //
                    if (SendDlgItemMessageW(
                            DialogHandle,
                            ID_SERVER,
                            CB_SELECTSTRING,
                            0,
                            (LPARAM) pLoginParam->ServerName
                            ) == CB_ERR) {

                        //
                        // Did not find preferred server in the combo-box,
                        // just set the old value in the edit item.
                        //
                        SetDlgItemTextW( DialogHandle, ID_SERVER,
                                         pLoginParam->ServerName);
                    }
                }
                else
                {
                    //
                    // we are dealing with *tree\context. break it into
                    // tree and context
                    //

                    WCHAR *pszTmp = wcschr(pLoginParam->ServerName + 1, L'\\') ;

                    if (pszTmp)
                        *pszTmp = 0 ;

                    if (SendDlgItemMessageW(
                            DialogHandle,
                            ID_DEFAULTTREE,
                            CB_SELECTSTRING,
                            0,
                            (LPARAM) (pLoginParam->ServerName + 1)
                            ) == CB_ERR) {

                        //
                        // Did not find preferred server in the combo-box,
                        // just set the old value in the edit item.
                        //
                        SetDlgItemTextW( DialogHandle, ID_DEFAULTTREE,
                                         pLoginParam->ServerName + 1);
                    }

                    SetDlgItemTextW( DialogHandle, ID_DEFAULTCONTEXT,
                                     pszTmp ? (pszTmp + 1) : L"");

                    if (pszTmp)
                        *pszTmp = L'\\' ;              // restore the '\'

                    enableServer = FALSE ;

                }
            }

 
            //
            // enable appropriate buttons
            //
            CheckRadioButton( DialogHandle,
                              ID_PREFERREDSERVER_RB,
                              ID_DEFAULTCONTEXT_RB,
                              enableServer ? 
                                  ID_PREFERREDSERVER_RB : 
                                  ID_DEFAULTCONTEXT_RB) ;
            EnableWindow ( GetDlgItem ( DialogHandle,
                                ID_SERVER ),
                                enableServer ) ;
            EnableWindow ( GetDlgItem ( DialogHandle,
                                ID_DEFAULTTREE ),
                                !enableServer ) ;
            EnableWindow ( GetDlgItem ( DialogHandle,
                                ID_DEFAULTCONTEXT ),
                                !enableServer ) ;
            SetFocus ( GetDlgItem ( DialogHandle, 
                           enableServer ? ID_SERVER : ID_DEFAULTTREE ) ) ;
 
            //
            // Preferred server name is limited to 48 characters.
            // Tree is limited to 32. We limit context to 256 - MAXTREE - 3
            //
            SendDlgItemMessageW(
                DialogHandle,
                ID_SERVER,
                CB_LIMITTEXT,
                NW_MAX_SERVER_LEN - 1, 
                0
                );
            SendDlgItemMessageW(
                DialogHandle,
                ID_DEFAULTTREE,
                CB_LIMITTEXT,
                NW_MAX_TREE_LEN - 1,  
                0
                );
            SendDlgItemMessageW(
                DialogHandle,
                ID_DEFAULTCONTEXT,
                EM_LIMITTEXT,
                (256 - NW_MAX_TREE_LEN) - 4,   // -4 for backslashes unc style 
                0
                );

            return TRUE;


        case WM_COMMAND:

            switch (LOWORD(WParam)) {

                case ID_DEFAULTCONTEXT_RB :
                    if (  (HIWORD(WParam) == BN_CLICKED )
                       || (HIWORD(WParam) == BN_DOUBLECLICKED )
                       )
                    {
                        CheckRadioButton( DialogHandle,
                                          ID_PREFERREDSERVER_RB,
                                          ID_DEFAULTCONTEXT_RB,
                                          ID_DEFAULTCONTEXT_RB) ;
                        EnableWindow ( GetDlgItem ( DialogHandle,
                                            ID_SERVER ),
                                            FALSE ) ;
                        EnableWindow ( GetDlgItem ( DialogHandle,
                                            ID_DEFAULTTREE ),
                                            TRUE ) ;
                        EnableWindow ( GetDlgItem ( DialogHandle,
                                            ID_DEFAULTCONTEXT ),
                                            TRUE ) ;
                        SetFocus ( GetDlgItem ( DialogHandle,
                                            ID_DEFAULTTREE ) ) ;
                    }
                    break ;

                case ID_PREFERREDSERVER_RB :
                    if (  (HIWORD(WParam) == BN_CLICKED )
                       || (HIWORD(WParam) == BN_DOUBLECLICKED )
                       )
                    {
                        CheckRadioButton( DialogHandle,
                                          ID_PREFERREDSERVER_RB,
                                          ID_DEFAULTCONTEXT_RB,
                                          ID_PREFERREDSERVER_RB) ;
                        EnableWindow ( GetDlgItem ( DialogHandle,
                                            ID_SERVER ),
                                            TRUE ) ;
                        EnableWindow ( GetDlgItem ( DialogHandle,
                                            ID_DEFAULTTREE ),
                                            FALSE ) ;
                        EnableWindow ( GetDlgItem ( DialogHandle,
                                            ID_DEFAULTCONTEXT ),
                                            FALSE ) ;
                        SetFocus ( GetDlgItem ( DialogHandle, ID_SERVER ) ) ;
                    }
                    break ;

                //
                // Use the user's original password when
                // the user types in or selects a new server or context
                //
                case ID_DEFAULTTREE:
                    if (  (HIWORD(WParam) == CBN_EDITCHANGE )
                       || (HIWORD(WParam) == CBN_SELCHANGE )
                       )
                    {
                        wcscpy( pLoginParam->Password, OrigPassword );
                    }
                    break;
                case ID_DEFAULTCONTEXT:
                    if ( HIWORD(WParam) == EN_CHANGE )
                    {
                        wcscpy( pLoginParam->Password, OrigPassword );
                    }
                    break;
                case ID_SERVER:
                    if (  (HIWORD(WParam) == CBN_EDITCHANGE )
                       || (HIWORD(WParam) == CBN_SELCHANGE )
                       )
                    {
                        wcscpy( pLoginParam->Password, OrigPassword );
                    }
                    break;

                case IDOK: {

                    LPWSTR pszLocation = NULL;

                    ASSERT(pLoginParam->ServerNameSize >= MAX_PATH) ;

                    //
                    // Allocate a buffer big enough to hold the Preferred
                    // Server name or the NDS Tree and context in the form:
                    // *Tree(Context). Therefore we allocate twice the space
                    // needed for a UNICODE Server name.
                    //
                    if ((pszLocation = 
                            LocalAlloc(LMEM_ZEROINIT,
                              (pLoginParam->ServerNameSize * sizeof(WCHAR) * 2))
                                ) == NULL )
                    {
                        break;
                    }

                    //
                    // Read the server or tree/context and validate its value.
                    //
                    //Handle extra buttons for Multi-User

                    if ( (BOOL)(IsDlgButtonChecked (DialogHandle,
                                    ID_LOGONSCRIPT) ) )
                    {
                        pLoginParam->LogonScriptOptions =
                         NW_LOGONSCRIPT_ENABLED | NW_LOGONSCRIPT_4X_ENABLED;
                    }
                    else
                    {
                        pLoginParam->LogonScriptOptions =
                            NW_LOGONSCRIPT_DISABLED;
                    }

                    if ( !enableServer ||
                       (IsDlgButtonChecked(DialogHandle, ID_DEFAULTCONTEXT_RB)))
                    {
                                               //
                        // We are dealing with TREE/CONTEXT. Synthesize string
                        // in "*TREE\CONTEXT" format.
                        //
                        WCHAR *pTmp ;
                        *pszLocation = TREE_CHAR ;

                        if (!GetDlgItemTextW(            
                                DialogHandle,
                                ID_DEFAULTTREE,
                                pszLocation + 1,
                                pLoginParam->ServerNameSize - 1
                                ))
                        {
                            //
                            // The tree name field was blank!
                            // Prompt user to provide a NDS tree name.
                            //
                            LocalFree( pszLocation );

                            (void) NwpMessageBoxError(
                                       DialogHandle,
                                       IDS_AUTH_FAILURE_TITLE,
                                       IDS_TREE_NAME_MISSING,
                                       0,
                                       NULL,
                                       MB_OK | MB_ICONSTOP
                                       );

                            //
                            // Put the focus where the user can fix the
                            // invalid tree name.
                            //
                           SetFocus(GetDlgItem(DialogHandle,ID_DEFAULTTREE));

                            SendDlgItemMessageW(
                                DialogHandle,
                                ID_DEFAULTTREE,
                                EM_SETSEL,
                                0,
                                MAKELPARAM(0, -1)
                                );

                            return TRUE;
                        }

                        pTmp = pszLocation + wcslen( pszLocation );
                        *pTmp++ = L'\\' ;

                        if (!GetDlgItemTextW(
                                DialogHandle,
                                ID_DEFAULTCONTEXT,
                                pTmp,
                                pLoginParam->ServerNameSize - (DWORD)(pTmp-pszLocation)
                                ))
                        {
                            //
                            // The context name field was blank!
                            // Prompt user to provide a NDS context name.
                            //
                            LocalFree( pszLocation );

                            (void) NwpMessageBoxError(
                                       DialogHandle,
                                       IDS_AUTH_FAILURE_TITLE,
                                       IDS_CONTEXT_MISSING,
                                       0,
                                       NULL,
                                       MB_OK | MB_ICONSTOP
                                       );

                            //
                            // Put the focus where the user can fix the
                            // invalid context name.
                            //
                           SetFocus(GetDlgItem(DialogHandle,ID_DEFAULTCONTEXT));

                            SendDlgItemMessageW(
                                DialogHandle,
                                ID_DEFAULTCONTEXT,
                                EM_SETSEL,
                                0,
                                MAKELPARAM(0, -1)
                                );

                            return TRUE;
                        }
                    }
                    else
                    {
                        //
                        // Straight server. Just read it in. If we cant get it 
                        // or is empty, use <None>.
                        //
                        if (GetDlgItemTextW( 
                                DialogHandle,
                                ID_SERVER,
                                pszLocation,
                                pLoginParam->ServerNameSize
                                ) == 0)
                        {
                            wcscpy( pszLocation, pszNone );
                                goto CANCEL_PREFERRED_SERVER;
                        }
                    }

                    if (( lstrcmpi( pszLocation, pszNone ) != 0) &&
                        ( !IS_TREE( pszLocation )) &&
                        ( !IS_VALID_TOKEN( pszLocation,wcslen( pszLocation ))))
                    {
                        //
                        // Put up message box complaining about the bad
                        // server name.
                        //
                        LocalFree( pszLocation );

                        (void) NwpMessageBoxError(
                                   DialogHandle,
                                   IDS_AUTH_FAILURE_TITLE,
                                   IDS_INVALID_SERVER,
                                   0,
                                   NULL,
                                   MB_OK | MB_ICONSTOP
                                   );

                        //
                        // Put the focus where the user can fix the
                        // invalid name.
                        //
                        SetFocus(GetDlgItem(DialogHandle, ID_SERVER));

                        SendDlgItemMessageW(
                            DialogHandle,
                            ID_SERVER,
                            EM_SETSEL,
                            0,
                            MAKELPARAM(0, -1)
                            );

                        return TRUE;
                    }

                    //
                    // If the user select <NONE>,
                    // change it to empty string.
                    //
                    if (lstrcmpi( pszLocation, pszNone) == 0) {

                        wcscpy( pszLocation, L"" );
                    }

#if DBG
                    IF_DEBUG(LOGON) {
                        KdPrint(("\n\t[OK] was pressed\n"));
                        KdPrint(("\tNwrLogonUser\n"));
                        KdPrint(("\tPassword   : %ws\n",pLoginParam->Password));
                        KdPrint(("\tServer     : %ws\n",pszLocation ));
                    }
#endif


                    while(1)
                    {
                        PROMPTDLGPARAM PasswdPromptParam;
                        INT_PTR Result ;

                        //
                        // make sure this user is logged off
                        //
                        (void) NwrLogoffUser(
                                       NULL,
                                       pLoginParam->pLogonId
                                       );

                        status = NwrLogonUser(
                                     NULL,
                                     pLoginParam->pLogonId,
                                     pLoginParam->UserName,
                                     pLoginParam->Password,
                                     pszLocation,
                                     NULL,
                                     NULL,
                                     0,
                                     pLoginParam->PrintOption
                                     );


                        //
                        // tommye 
                        //
                        // If the error is NO_SUCH_USER, see if the user name has any 
                        // periods in it - if so, then we need to escape them (\.) and 
                        // try the login again.
                        //

                        if (status == ERROR_NO_SUCH_USER) {
                            WCHAR   EscapedName[NW_MAX_USERNAME_LEN * 2];
                            PWSTR   pChar = pLoginParam->UserName;
                            int     i = 0;
                            BOOL    bEscaped = FALSE;

                            RtlZeroMemory(EscapedName, sizeof(EscapedName));

                            do {
                                if (*pChar == L'.') {
                                    EscapedName[i++] = '\\';
                                    bEscaped = TRUE;
                                }
                                EscapedName[i++] = *pChar;
                            } while (*pChar++);

                            // Try the login again

                            if (bEscaped) {

                                status = NwrLogonUser(
                                             NULL,
                                             pLoginParam->pLogonId,
                                             EscapedName,
                                             pLoginParam->Password,
                                             pszLocation,
                                             NULL,
                				             NULL,
                                             0,
                                             pLoginParam->PrintOption
                                             );
                                if (status != ERROR_NO_SUCH_USER) { // if we matched a username, copy that name into buffer
                                    //
                                    // check for max length to avoid overflowing.
                                    //
                                    if (i < (sizeof(pLoginParam->UserName))) {
                                        wcsncpy(
                                            pLoginParam->UserName,
                                            EscapedName,
                                            i
                                            );
                                    }
                                }
                            }
                        }

                        if (status != ERROR_INVALID_PASSWORD)
                            break ;

                        PasswdPromptParam.UserName =
                            pLoginParam->UserName,
                        PasswdPromptParam.ServerName =
                            pszLocation;
                        PasswdPromptParam.Password  =
                            pLoginParam->Password;
                        PasswdPromptParam.PasswordSize =
                            pLoginParam->PasswordSize ;

                        Result = DialogBoxParamW(
                                     hmodNW,
                                     MAKEINTRESOURCEW(DLG_PASSWORD_PROMPT),
                                     (HWND) DialogHandle,
                                     NwpPasswdPromptDlgProc,
                                     (LPARAM) &PasswdPromptParam
                                     );

                        if (Result == -1 || Result == IDCANCEL)
                        {
                            status = ERROR_INVALID_PASSWORD ;
                            break ;
                        }
                    }

                    if (status == NW_PASSWORD_HAS_EXPIRED)
                    {
                        WCHAR  szNumber[16] ;
                        DWORD  dwMsgId, dwGraceLogins = 0 ;
                        LPWSTR apszInsertStrings[3] ;

                        //
                        // get the grace login count
                        //
                        if (!IS_TREE(pszLocation))
                        {
                            DWORD  status1 ;
                            status1 = NwGetGraceLoginCount(
                                          pszLocation,
                                          pLoginParam->UserName,
                                          &dwGraceLogins) ;
                            //
                            // if hit error, just dont use the number
                            //
                            if (status1 == NO_ERROR)
                            {
                                //
                                // tommye - MCS bug 251 - changed from SETPASS
                                // message (IDS_PASSWORD_EXPIRED) to 
                                // Ctrl+Alt+Del message.
                                //

                                dwMsgId = IDS_PASSWORD_HAS_EXPIRED0 ; 
                                wsprintfW(szNumber, L"%ld", dwGraceLogins) ;
                            }
                            else
                            {
                                //
                                // tommye - MCS bug 251 - changed from SETPASS
                                // message (IDS_PASSWORD_EXPIRED1) to 
                                // Ctrl+Alt+Del message.
                                //

                                dwMsgId = IDS_PASSWORD_HAS_EXPIRED2 ; 
                            }
                        }
                        else
                        {
                            dwMsgId = IDS_PASSWORD_HAS_EXPIRED2 ; 
                        }

                        apszInsertStrings[0] = pszLocation ;
                        apszInsertStrings[1] = szNumber ;
                        apszInsertStrings[2] = NULL ;

                        //
                        // put up message on password expiry
                        //
                        (void) NwpMessageBoxIns(
                                       (HWND) DialogHandle,
                                       IDS_NETWARE_TITLE,
                                       dwMsgId,
                                       apszInsertStrings,
                                       MB_OK | MB_SETFOREGROUND |
                                           MB_ICONINFORMATION );

                        status = NO_ERROR ;
                    }

                    //
                    // Check the LogonScript check box.
                    //
                    if (IsDlgButtonChecked(DialogHandle, ID_LOGONSCRIPT))
                    {
                        pLoginParam->LogonScriptOptions =
                            NW_LOGONSCRIPT_ENABLED | NW_LOGONSCRIPT_4X_ENABLED ;
                    }
                    else
                    {
                        pLoginParam->LogonScriptOptions =
                            NW_LOGONSCRIPT_DISABLED ;
                    }

                    if (status == NO_ERROR)
                    {
                        //
                        // Save the logon credential to the registry
                        //
                        NwpSaveLogonCredential(
                            pLoginParam->NewUserSid,
                            pLoginParam->pLogonId,
                            pLoginParam->UserName,
                            pLoginParam->Password,
                            pszLocation
                            );

                        // Clear the password buffer
                        RtlZeroMemory( OrigPassword, sizeof( OrigPassword));
                        NwpSaveLogonScriptOptions( pLoginParam->NewUserSid, pLoginParam->LogonScriptOptions );

                        EndDialog(DialogHandle, 0);
                    }
                    else
                    {
                        INT nResult;
                        DWORD dwMsgId = IDS_AUTH_FAILURE_WARNING;
                        WCHAR *pszErrorLocation = pszLocation ;

                        if (status == ERROR_ACCOUNT_RESTRICTION)
                        {
                            dwMsgId = IDS_AUTH_ACC_RESTRICTION;
                        }
                        if (status == ERROR_SHARING_PAUSED)
                        {
                            status = IDS_LOGIN_DISABLED;
                        }

                        if (IS_TREE(pszLocation))
                        {
                            //
                            // Format into nicer string for user
                            //
                            WCHAR *pszTmp = LocalAlloc(LMEM_ZEROINIT,
                                                       (wcslen(pszLocation)+2) *
                                                           sizeof(WCHAR)) ;
                            if (pszTmp)
                            {

                                pszErrorLocation = pszTmp ;
                                
                                //
                                // This code formats the NDS
                                // tree UNC to: Tree(Context)
                                //
                                wcscpy(pszErrorLocation, pszLocation+1) ;

                                if (pszTmp = wcschr(pszErrorLocation, L'\\'))
                                {
                                    *pszTmp = L'(' ;
                                    wcscat(pszErrorLocation, L")") ;
                                }
                            }
                        }

                        nResult = NwpMessageBoxError(
                                      DialogHandle,
                                      IDS_AUTH_FAILURE_TITLE,
                                      dwMsgId,
                                      status,
                                      pszErrorLocation, 
                                      MB_YESNO | MB_DEFBUTTON2
                                      | MB_ICONEXCLAMATION
                                      );

                        if (pszErrorLocation != pszLocation)
                        {
                            (void) LocalFree(pszErrorLocation) ;
                        }

                        if ( nResult == IDYES )
                        {
                            //
                            // Save the logon credential to the registry
                            //
                            NwpSaveLogonCredential(
                                pLoginParam->NewUserSid,
                                pLoginParam->pLogonId,
                                pLoginParam->UserName,
                                pLoginParam->Password,
                                pszLocation
                                );

                            // Clear the password buffer
                            RtlZeroMemory( OrigPassword, sizeof( OrigPassword));
                            NwpSaveLogonScriptOptions( pLoginParam->NewUserSid, pLoginParam->LogonScriptOptions );

                            EndDialog(DialogHandle, 0);
                        }
                        else
                        {
                            //
                            // Put the focus where the user can fix the
                            // invalid name.
                            //
                            DWORD controlId = 
                                IsDlgButtonChecked(DialogHandle,
                                                   ID_DEFAULTCONTEXT_RB) ? 
                                                       ID_DEFAULTTREE :
                                                       ID_SERVER ;

                            SetFocus(GetDlgItem(DialogHandle, controlId));

                            SendDlgItemMessageW(
                                DialogHandle,
                                controlId,
                                EM_SETSEL,
                                0,
                                MAKELPARAM(0, -1)
                                );
                        }
                    }

                    LocalFree( pszLocation );
                    return TRUE;
                }


                case IDCANCEL:
CANCEL_PREFERRED_SERVER:

#if DBG
                    IF_DEBUG(LOGON) {
                        KdPrint(("\n\t[CANCEL] was pressed\n"));
                        KdPrint(("\tLast Preferred Server: %ws\n",
                                 pLoginParam->ServerName));
                        KdPrint(("\tLast Password: %ws\n",
                                 pLoginParam->Password ));
                    }
#endif

                    if ( *(pLoginParam->ServerName) == NW_INVALID_SERVER_CHAR )
                    {
                        // No preferred server has been set.
                        // Pop up a warning to the user.

                        INT nResult = NwpMessageBoxError(
                                          DialogHandle,
                                          IDS_NETWARE_TITLE,
                                          IDS_NO_PREFERRED,
                                          0,
                                          NULL,
                                          MB_YESNO | MB_ICONEXCLAMATION
                                          );

                        //
                        // The user chose NO, return to the dialog.
                        //
                        if ( nResult == IDNO )
                        {
                            //
                            // Put the focus where the user can fix the
                            // invalid name.
                            //
                            DWORD controlId = 
                                IsDlgButtonChecked(DialogHandle,
                                                   ID_DEFAULTCONTEXT_RB) ? 
                                                       ID_DEFAULTTREE :
                                                       ID_SERVER ;

                            SetFocus(GetDlgItem(DialogHandle, controlId));

                            SendDlgItemMessageW(
                                DialogHandle,
                                controlId,
                                EM_SETSEL,
                                0,
                                MAKELPARAM(0, -1)
                                );

                            return TRUE;
                        }

                        //
                        // Save the preferred server as empty string
                        //

                        NwpSaveLogonCredential(
                            pLoginParam->NewUserSid,
                            pLoginParam->pLogonId,
                            pLoginParam->UserName,
                            pLoginParam->Password,
                            L""
                            );
                        pLoginParam->LogonScriptOptions = NW_LOGONSCRIPT_DISABLED;
                        NwpSaveLogonScriptOptions( pLoginParam->NewUserSid, pLoginParam->LogonScriptOptions );

                    }

                    // The user has not logged on to any server.
                    // Logged the user on using NULL as preferred server.

                    NwrLogonUser(
                        NULL,
                        pLoginParam->pLogonId,
                        pLoginParam->UserName,
                        pLoginParam->Password,
                        NULL,
                        NULL,
            NULL,
                        0,
                        pLoginParam->PrintOption
                    );

                    //
                    // Clear the password buffer
                    RtlZeroMemory( OrigPassword, sizeof( OrigPassword));
                    EndDialog(DialogHandle, 0);

                    return TRUE;


                case IDHELP:
                {
                    INT_PTR Result ;

                    Result = DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_PREFERRED_SERVER_HELP),
                                 (HWND) DialogHandle,
                                 NwpHelpDlgProc,
                                 (LPARAM) 0
                                 );

                    // ignore any errors. should not fail, and if does,
                    // nothing we can do.

                    return TRUE ;

                }


        }

    }

    //
    // We didn't process this message
    //
    return FALSE;
}


INT
NwpMessageBoxError(
    IN HWND  hwndParent,
    IN DWORD TitleId,
    IN DWORD BodyId,
    IN DWORD Error,
    IN LPWSTR pszParameter,
    IN UINT  Style
    )
/*++

Routine Description:

    This routine puts up a message box error.

Arguments:

    hwndParent - Supplies the handle of the parent window.

    TitleId - Supplies the ID of the title.  ( LoadString )

    BodyId  - Supplies the ID of the message. ( LoadString )

    Error - If BodyId != 0, then this supplies the ID of the
            substitution string that will be substituted into
            the string indicated by BodyId.
            If BodyId == 0, then this will be the error message.
            This id is a system error that we will get from FormatMessage
            using FORMAT_MESSAGE_FROM_SYSTEM.

    pszParameter - A substitution string that will be used as %2 or if
                   Error == 0, this string will be substituted as %1 into
                   the string indicated by BodyId.

    Style - Supplies the style of the MessageBox.


Return Value:

    The return value from the MessageBox, 0 if any error is encountered.

--*/
{
    DWORD nResult = 0;
    DWORD nLength;

    WCHAR  szTitle[MAX_PATH];
    WCHAR  szBody[MAX_PATH];
    LPWSTR pszError = NULL;
    LPWSTR pszBuffer = NULL;

    szTitle[0] = 0;
    szBody[0]  = 0;

    //
    // Get the Title string
    //
    nLength = LoadStringW(
                  hmodNW,
                  TitleId,
                  szTitle,
                  sizeof(szTitle) / sizeof(WCHAR)
                  );

    if ( nLength == 0) {
        KdPrint(("NWPROVAU: LoadStringW of Title failed with %lu\n",
                 GetLastError()));
        return 0;
    }

    //
    // Get the body string, if BodyId != 0
    //
    if ( BodyId != 0 )
    {
        nLength = LoadStringW(
                      hmodNW,
                      BodyId,
                      szBody,
                      sizeof(szBody) / sizeof(WCHAR)
                      );

        if ( nLength == 0) {
            KdPrint(("NWPROVAU: LoadStringW of Body failed with %lu\n",
                    GetLastError()));
            return 0;
        }
    }

    if ( (Error >= IDS_START) && (Error <= IDS_END) ) {

        pszError = (WCHAR *) LocalAlloc( 
                                 LPTR, 
                                 256 * sizeof(WCHAR)) ;
        if (!pszError)
            return 0 ;

        nLength = LoadStringW(
                      hmodNW,
                      Error,
                      pszError,
                      256
                      );
        
        if  ( nLength == 0 ) {

             KdPrint(("NWPROVAU: LoadStringW of Error failed with %lu\n",
                      GetLastError()));
             (void) LocalFree( (HLOCAL)pszError) ;
             return 0;
        }
    }
    else if ( Error != 0 ) {

        if (  ( Error == WN_NO_MORE_ENTRIES )
           || ( Error == ERROR_MR_MID_NOT_FOUND )) {

            //
            // Handle bogus error from the redirector
            //

            KdPrint(("NWPROVAU: The NetwareRedirector returned a bogus error as the reason for failure to authenticate. (See Kernel Debugger)\n"));
        }

        nLength = FormatMessageW(
                      FORMAT_MESSAGE_FROM_SYSTEM
                      | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      NULL,
                      Error,
                      0,
                      (LPWSTR) &pszError,
                      MAX_PATH,
                      NULL
                      );


        if  ( nLength == 0 ) {

             KdPrint(("NWPROVAU: FormatMessageW of Error failed with %lu\n",
                      GetLastError()));
             return 0;
        }
    }

    if (  ( *szBody != 0 )
       && ( ( pszError != NULL ) || ( pszParameter != NULL) )) {

         LPWSTR aInsertStrings[2];
         aInsertStrings[0] = pszError? pszError : pszParameter;
         aInsertStrings[1] = pszError? pszParameter : NULL;

         nLength = FormatMessageW(
                       FORMAT_MESSAGE_FROM_STRING
                       | FORMAT_MESSAGE_ALLOCATE_BUFFER
                       | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       szBody,
                       0,  // Ignored
                       0,  // Ignored
                       (LPWSTR) &pszBuffer,
                       MAX_PATH,
                       (va_list *) aInsertStrings
                       );

         if ( nLength == 0 ) {

             KdPrint(("NWPROVAU:FormatMessageW(insertstring) failed with %lu\n",
                     GetLastError()));

             if ( pszError != NULL )
                 (void) LocalFree( (HLOCAL) pszError );
             return 0;
         }

    }
    else if ( *szBody != 0 ) {

        pszBuffer = szBody;
    }
    else if ( pszError != NULL ) {

        pszBuffer = pszError;
    }
    else {

        // We have neither the body nor the error string.
        // Hence, don't popup the messagebox
        return 0;
    }

    if ( pszBuffer != NULL )
    {
        nResult = MessageBoxW(
                      hwndParent,
                      pszBuffer,
                      szTitle,
                      Style
                      );
    }

    if (  ( pszBuffer != NULL )
       && ( pszBuffer != szBody )
       && ( pszBuffer != pszError ))
    {
        (void) LocalFree( (HLOCAL) pszBuffer );
    }

    if ( pszError != NULL )
        (void) LocalFree( (HLOCAL) pszError );

    return nResult;
}


INT
NwpMessageBoxIns(
    IN HWND   hwndParent,
    IN DWORD  TitleId,
    IN DWORD  MessageId,
    IN LPWSTR *InsertStrings,
    IN UINT   Style
    )
/*++

Routine Description:

    This routine puts up a message box error with array of insert strings

Arguments:

    hwndParent - Supplies the handle of the parent window.

    TitleId - Supplies the ID of the title.  ( LoadString )

    MessageId  - Supplies the ID of the message. ( LoadString )

    InsertStrings - Array of insert strings for FormatMessage.

    Style - Supplies the style of the MessageBox.


Return Value:

    The return value from the MessageBox, 0 if any error is encountered.

--*/
{
    DWORD nResult = 0;
    DWORD nLength;

    WCHAR  szTitle[MAX_PATH];
    WCHAR  szBody[MAX_PATH];
    LPWSTR pszBuffer = NULL;

    szTitle[0] = 0;
    szBody[0] = 0;

    //
    // Get the Title string
    //
    nLength = LoadStringW(
                  hmodNW,
                  TitleId,
                  szTitle,
                  sizeof(szTitle) / sizeof(szTitle[0])
                  );

    if ( nLength == 0) {
        return 0;
    }

    //
    // Get the message string
    //
    nLength = LoadStringW(
                  hmodNW,
                  MessageId,
                  szBody,
                  sizeof(szBody) / sizeof(szBody[0])
                  );

    if ( nLength == 0) {
        return 0;
    }

    nLength = FormatMessageW(
                       FORMAT_MESSAGE_FROM_STRING
                           | FORMAT_MESSAGE_ALLOCATE_BUFFER
                           | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       szBody,
                       0,  // Ignored
                       0,  // Ignored
                       (LPWSTR) &pszBuffer,
                       MAX_PATH,
                       (va_list *) InsertStrings
                       );

    if ( nLength == 0 ) {
        return 0;
    }

    if ( pszBuffer != NULL )
    {
        nResult = MessageBoxW(
                      hwndParent,
                      pszBuffer,
                      szTitle,
                      Style
                      );

        (void) LocalFree( (HLOCAL) pszBuffer );
    }

    return nResult;
}

VOID
NwpAddServersToControl(
    IN HWND DialogHandle,
    IN INT  ControlId,
    IN UINT Message,
    IN INT  ControlIdMatch OPTIONAL,
    IN UINT FindMessage
    )
/*++

Routine Description:

    This function enumerates the servers on the network and adds each
    server name to the specified Windows control.

    If ControlIdMatch is specified (i.e. non 0), only servers that are
    not found in ControlIdMatch list are added to the list specified
    by ControlId.

Arguments:

    DialogHandle - Supplies a handle to the Windows dialog.

    ControlId - Supplies id which specifies the control.

    Message - Supplies the window management message to add string.

    ControlIdMatch - Supplies the control ID which contains server
        names that should not be in ControlId.

    FindMessage - Supplies the window management message to find
        string.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    DWORD status = ERROR_NO_NETWORK;
    HANDLE EnumHandle = (HANDLE) NULL;

    LPNETRESOURCE NetR = NULL;
    LPNETRESOURCEW SavePtr;
    WCHAR FormattedNameBuf[MAX_NDS_NAME_CHARS];

    LPWSTR lpFormattedName;
    DWORD dwLength;

    DWORD BytesNeeded = 512;
    DWORD EntriesRead;
    DWORD i;

    //
    // Retrieve the list of servers on the network
    //
    status = NPOpenEnum(
                   RESOURCE_GLOBALNET,
                   0,
                   0,
                   NULL,
                   &EnumHandle
                   );

    if (status != NO_ERROR) {
        EnumHandle = (HANDLE) NULL;
        goto CleanExit;
    }

    //
    // Allocate buffer to get servers on the net.
    //
    if ((NetR = (LPVOID) LocalAlloc(
                             0,
                             BytesNeeded
                             )) == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        EntriesRead = 0xFFFFFFFF;          // Read as many as possible

        status = NPEnumResource(
                     EnumHandle,
                     &EntriesRead,
                     (LPVOID) NetR,
                     &BytesNeeded
                     );


        if (status == WN_SUCCESS) {

            SavePtr = NetR;

            for (i = 0; i < EntriesRead; i++, NetR++)
            {
                if ( NetR->dwDisplayType == RESOURCEDISPLAYTYPE_TREE)
                {
                    continue;
                }
                else
                {
                    lpFormattedName = FormattedNameBuf;
                }

                dwLength = NW_MAX_SERVER_LEN + 1;

                status = NPFormatNetworkName( NetR->lpRemoteName,
                                              lpFormattedName,
                                              &dwLength,
                                              WNFMT_INENUM,
                                              0 );

                lpFormattedName = FormattedNameBuf;

                if ( status != WN_SUCCESS )
                {
                    continue;
                }

                if ( dwLength > NW_MAX_SERVER_LEN + 1 )
                {
                    continue;
                }

                if (ControlIdMatch != 0) {

                    LRESULT Result;

                    //
                    // Add the server to list only if it's not found
                    // in the alternate list specified by ControlIdMatch.
                    //
                    Result = SendDlgItemMessageW(
                                 DialogHandle,
                                 ControlIdMatch,
                                 FindMessage,
                                 (WPARAM) -1,
                                 (LPARAM) lpFormattedName
                                 );

                    if (Result == LB_ERR) {

                        //
                        // Server name not found.  Add to list.
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            ControlId,
                            Message,
                            0,
                            (LPARAM) lpFormattedName
                            );
                    }
                }
                else {

                    //
                    // No alternate list.  Just add all servers.
                    //
                    SendDlgItemMessageW(
                        DialogHandle,
                        ControlId,
                        Message,
                        0,
                        (LPARAM) lpFormattedName
                        );
                }

            }

            NetR = SavePtr;

        }
        else if (status != WN_NO_MORE_ENTRIES) {

            status = GetLastError();

            if (status == WN_MORE_DATA) {

                //
                // Original buffer was too small.  Free it and allocate
                // the recommended size and then some to get as many
                // entries as possible.
                //

                (void) LocalFree((HLOCAL) NetR);

                BytesNeeded += NW_ENUM_EXTRA_BYTES;

                if ((NetR = (LPVOID) LocalAlloc(
                                         0,
                                         BytesNeeded
                                         )) == NULL) {

                    status = ERROR_NOT_ENOUGH_MEMORY;
                    goto CleanExit;
                }
            }
            else {
                goto CleanExit;
            }
        }

    } while (status != WN_NO_MORE_ENTRIES);

    if (status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

CleanExit:

    if (EnumHandle != (HANDLE) NULL) {
        (void) NPCloseEnum(EnumHandle);
    }

    if (NetR != NULL) {
        (void) LocalFree((HLOCAL) NetR);
    }
}

VOID
NwpAddTreeNamesToControl(
    IN HWND DialogHandle,
    IN INT  ControlId,
    IN UINT Message,
    IN INT  ControlIdMatch OPTIONAL,
    IN UINT FindMessage
    )
/*++

Routine Description:

    This function enumerates the NDS tree on the network and adds each
    tree name to the specified Windows control.

    If ControlIdMatch is specified (i.e. non 0), only trees that are
    not found in ControlIdMatch list are added to the list specified
    by ControlId.

Arguments:

    DialogHandle - Supplies a handle to the Windows dialog.

    ControlId - Supplies id which specifies the control.

    Message - Supplies the window management message to add string.

    ControlIdMatch - Supplies the control ID which contains server
        names that should not be in ControlId.

    FindMessage - Supplies the window management message to find
        string.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    DWORD status = ERROR_NO_NETWORK;
    HANDLE EnumHandle = (HANDLE) NULL;

    LPNETRESOURCE NetR = NULL;
    LPNETRESOURCEW SavePtr;
    WCHAR FormattedNameBuf[MAX_NDS_NAME_CHARS];

    LPWSTR lpFormattedName;
    DWORD dwLength;

    DWORD BytesNeeded = 512;
    DWORD EntriesRead;
    DWORD i;

    //
    // Retrieve the list of trees on the network
    //
    status = NPOpenEnum(
                   RESOURCE_GLOBALNET,
                   0,
                   0,
                   NULL,
                   &EnumHandle
                   );

    if (status != NO_ERROR) {
        EnumHandle = (HANDLE) NULL;
        goto CleanExit;
    }

    //
    // Allocate buffer to get trees on the net.
    //
    if ((NetR = (LPVOID) LocalAlloc(
                             0,
                             BytesNeeded
                             )) == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        EntriesRead = 0xFFFFFFFF;          // Read as many as possible

        status = NPEnumResource(
                     EnumHandle,
                     &EntriesRead,
                     (LPVOID) NetR,
                     &BytesNeeded
                     );


        if (status == WN_SUCCESS) {

            SavePtr = NetR;

            for (i = 0; i < EntriesRead; i++, NetR++)
            {
                if ( NetR->dwDisplayType == RESOURCEDISPLAYTYPE_TREE)
                {
                    lpFormattedName = (LPWSTR) FormattedNameBuf;
                }
                else
                {
                    continue;
                }

                dwLength = NW_MAX_SERVER_LEN + 1;

                status = NPFormatNetworkName( NetR->lpRemoteName,
                                              lpFormattedName,
                                              &dwLength,
                                              WNFMT_INENUM,
                                              0 );

                lpFormattedName = FormattedNameBuf;

                if ( status != WN_SUCCESS )
                {
                    continue;
                }

                if ( dwLength > NW_MAX_SERVER_LEN + 1 )
                {
                    continue;
                }

                if (ControlIdMatch != 0) {

                    LRESULT Result;

                    //
                    // Add the server to list only if it's not found
                    // in the alternate list specified by ControlIdMatch.
                    //
                    Result = SendDlgItemMessageW(
                                 DialogHandle,
                                 ControlIdMatch,
                                 FindMessage,
                                 (WPARAM) -1,
                                 (LPARAM) lpFormattedName
                                 );

                    if (Result == LB_ERR) {

                        //
                        // Server name not found.  Add to list.
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            ControlId,
                            Message,
                            0,
                            (LPARAM) lpFormattedName
                            );
                    }
                }
                else {

                    //
                    // No alternate list.  Just add all servers.
                    //
                    SendDlgItemMessageW(
                        DialogHandle,
                        ControlId,
                        Message,
                        0,
                        (LPARAM) lpFormattedName
                        );
                }

            }

            NetR = SavePtr;

        }
        else if (status != WN_NO_MORE_ENTRIES) {

            status = GetLastError();

            if (status == WN_MORE_DATA) {

                //
                // Original buffer was too small.  Free it and allocate
                // the recommended size and then some to get as many
                // entries as possible.
                //

                (void) LocalFree((HLOCAL) NetR);

                BytesNeeded += NW_ENUM_EXTRA_BYTES;

                if ((NetR = (LPVOID) LocalAlloc(
                                         0,
                                         BytesNeeded
                                         )) == NULL) {

                    status = ERROR_NOT_ENOUGH_MEMORY;
                    goto CleanExit;
                }
            }
            else {
                goto CleanExit;
            }
        }

    } while (status != WN_NO_MORE_ENTRIES);

    if (status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

CleanExit:

    if (EnumHandle != (HANDLE) NULL) {
        (void) NPCloseEnum(EnumHandle);
    }

    if (NetR != NULL) {
        (void) LocalFree((HLOCAL) NetR);
    }
}


VOID
NwpAddToComboBox(
    IN HWND DialogHandle,
    IN INT  ControlId,
    IN LPWSTR pszNone OPTIONAL,
    IN BOOL AllowNone
    )
{

    NwpAddServersToControl(DialogHandle, ControlId, CB_ADDSTRING, 0, 0);

    //
    // Combo-box will contain at least the <NONE> entry in its list.
    //

    if ( ARGUMENT_PRESENT(pszNone) && AllowNone) {

        SendDlgItemMessageW(
            DialogHandle,
            ControlId,
            CB_INSERTSTRING,
            (WPARAM) -1,
            (LPARAM) pszNone
            );
    }
}


DWORD
NwpGetUserCredential(
    IN HWND    hParent,
    IN LPWSTR  Unc,
    IN DWORD   err,
    IN LPWSTR  pszConnectAsUserName,
    OUT LPWSTR *UserName,
    OUT LPWSTR *Password
    )
/*++

Routine Description:

    This function puts up a popup dialog for the user, whose default
    credential denied browse directory access, to enter the correct
    credential.  If this function returns successful, the pointers
    to memory allocated for the user entered username and password
    are returned.

Arguments:

    Unc - Supplies the container name in \\Server\Volume format
        under which the user wants to browse directories.

    UserName - Receives the pointer to memory allocated for the
        username gotten from the dialog.  This pointer must be freed
        with LocalFree when done.

    Password - Receives the pointer to memory allocated for the
        password gotten from the dialog.  This pointer must be freed
        with LocalFree when done.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    INT_PTR Result;
    HWND DialogHandle = hParent? hParent : NwpGetParentHwnd();
    DWORD UserNameSize = NW_MAX_USERNAME_LEN + 1;
    DWORD PasswordSize = NW_MAX_PASSWORD_LEN + 1;
    CONNECTDLGPARAM ConnectParam;

    *UserName = NULL;
    *Password = NULL;

    /*  Removing this test allows WFP to call with a NULL parent window to use the desktop as the parent
    if (DialogHandle == NULL) {
        return ERROR_WINDOW_NOT_DIALOG;
    }
    */

    //
    // Allocate memory to return UserName and Password
    //
    if ((*UserName = (LPVOID) LocalAlloc(
                                  0,
                                  UserNameSize * sizeof(WCHAR)
                                  )) == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Allocate memory to return UserName and Password
    //
    if ((*Password = (LPVOID) LocalAlloc(
                                  0,
                                  PasswordSize * sizeof(WCHAR)
                                  )) == NULL)
    {

        (void) LocalFree( *UserName );
        *UserName = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ConnectParam.UncPath  = Unc;
    ConnectParam.ConnectAsUserName = pszConnectAsUserName;
    ConnectParam.UserName = *UserName;
    ConnectParam.Password = *Password;
    ConnectParam.UserNameSize = UserNameSize;
    ConnectParam.PasswordSize = PasswordSize;
    ConnectParam.LastConnectionError = err;

    Result = DialogBoxParamW(
                 hmodNW,
                 MAKEINTRESOURCEW(DLG_NETWORK_CREDENTIAL),
                 DialogHandle,
                 NwpConnectDlgProc,
                 (LPARAM) &ConnectParam
                 );

    if ( Result == -1 )
    {
        status = GetLastError();
        KdPrint(("NWPROVAU: NwpGetUserCredential: DialogBox failed %lu\n",
                status));
        goto ErrorExit;
    }
    else if ( Result == IDCANCEL )
    {
        //
        // Cancel was pressed.
        //
        status = WN_CANCEL;
        goto ErrorExit;
    }

    return NO_ERROR;

ErrorExit:
    (void) LocalFree((HLOCAL) *UserName);
    (void) LocalFree((HLOCAL) *Password);
    *UserName = NULL;
    *Password = NULL;

    return status;
}


INT_PTR
CALLBACK
NwpConnectDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
/*++

Routine Description:

    This function is the window management message handler which
    initializes, and reads user input from the dialog put up when the
    user fails to browse a directory on the default credential.

Arguments:

    DialogHandle - Supplies a handle to display the dialog.

    Message - Supplies the window management message.

    LParam - Supplies the pointer to a buffer which on input
        contains the \\Server\Volume string under which the user
        needs to type in a new credential before browsing.  On
        output, this pointer contains the username and password
        strings entered to the dialog box.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    static PCONNECTDLGPARAM pConnectParam;

    switch (Message) {

        case WM_INITDIALOG:

            pConnectParam = (PCONNECTDLGPARAM) LParam;

            //
            // Position dialog
            //
            // NwpCenterDialog(DialogHandle);


            //
            // Display the \\Server\Volume string.
            //
            SetDlgItemTextW( DialogHandle,
                             ID_VOLUME_PATH,
                             pConnectParam->UncPath );

            if ( pConnectParam->LastConnectionError == NO_ERROR )
            {
                WCHAR szTemp[256];

                if ( LoadString( hmodNW, IDS_CONNECT_NO_ERROR_TEXT,
                                 szTemp, sizeof( szTemp )/sizeof(WCHAR)))
                {
                    SetDlgItemTextW( DialogHandle,
                                     ID_CONNECT_TEXT,
                                     szTemp );
                }
            }

            //
            // Username is limited to 256 characters.
            //
            SendDlgItemMessageW(
                DialogHandle,
                ID_CONNECT_AS,
                EM_LIMITTEXT,
                pConnectParam->UserNameSize - 1, // minus the space for '\0'
                0
                );

            //
            // Password is limited to 256 characters.
            //
            SendDlgItemMessageW(
                DialogHandle,
                ID_CONNECT_PASSWORD,
                EM_LIMITTEXT,
                pConnectParam->PasswordSize - 1, // minus the space for '\0'
                0
                );

            //
            // Display the User name string.
            //
            if ( pConnectParam->ConnectAsUserName )
            {
                SetDlgItemTextW( DialogHandle,
                                 ID_CONNECT_AS,
                                 pConnectParam->ConnectAsUserName );
            }

            return TRUE;


        case WM_COMMAND:

            switch (LOWORD(WParam)) {

                case IDOK:

                    GetDlgItemTextW(
                        DialogHandle,
                        ID_CONNECT_AS,
                        pConnectParam->UserName,
                        pConnectParam->UserNameSize
                        );

                    GetDlgItemTextW(
                        DialogHandle,
                        ID_CONNECT_PASSWORD,
                        pConnectParam->Password,
                        pConnectParam->PasswordSize
                        );

#if DBG
                    IF_DEBUG(LOGON) {
                        KdPrint(("\n\t[OK] was pressed\n"));
                        KdPrint(("\tUserName   : %ws\n",
                                  pConnectParam->UserName));
                        KdPrint(("\tPassword   : %ws\n",
                                  pConnectParam->Password));
                    }
#endif

                    EndDialog(DialogHandle, (INT) IDOK);  // OK

                    return TRUE;


                case IDCANCEL:

#if DBG
                    IF_DEBUG(LOGON) {
                        KdPrint(("\n\t[CANCEL] was pressed\n"));
                    }
#endif

                    EndDialog(DialogHandle, (INT) IDCANCEL);  // CANCEL

                    return TRUE;
 
                case IDHELP:

                    WinHelp( DialogHandle, 
                             NW_HELP_FILE,
                             HELP_CONTEXT,
                             IDH_DLG_NETWORK_CREDENTIAL_HELP );

                    return TRUE;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}



VOID
NwpCenterDialog(
    HWND hwnd
    )
/*++

Routine Description:

    This routine positions the dialog centered horizontally and 1/3
    down the screen vertically. It should be called by the dlg proc
    when processing the WM_INITDIALOG message.  This code is stolen
    from Visual Basic written by GustavJ.

                              Screen
                  -----------------------------
                  |         1/3 Above         |
                  |      ---------------      |
                  |      |   Dialog    |      |
                  |      |             |      |
                  |      ---------------      |
                  |         2/3 Below         |
                  |                           |
                  -----------------------------

Arguments:

    hwnd - Supplies the handle to the dialog.

Return Value:

    None.

--*/
{
    RECT    rect;
    LONG    nx;     // New x
    LONG    ny;     // New y
    LONG    width;
    LONG    height;

    GetWindowRect( hwnd, &rect );

    width = rect.right - rect.left;
    height = rect.bottom - rect.top;

    nx = (GetSystemMetrics(SM_CXSCREEN) - width) / 2;
    ny = (GetSystemMetrics(SM_CYSCREEN) - height) / 3;

    MoveWindow( hwnd, nx, ny, width, height, FALSE );
}



HWND
NwpGetParentHwnd(
    VOID
    )
/*++

Routine Description:

    This function gets the parent window handle so that a
    dialog can be displayed in the current context.

Arguments:

    None.

Return Value:

    Returns the parent window handle if successful; NULL otherwise.

--*/
{
    HWND hwnd;
    LONG lWinStyle;


    //
    // Get the current focus.  This is presumably the button
    // that was last clicked.
    //
    hwnd = GetFocus();

    //
    // We must make sure that we don't return the window handle
    // for a child window.  Hence, we traverse up the ancestors
    // of this window handle until we find a non-child window.
    // Then, we return that handle.  If we ever find a NULL window
    // handle before finding a non-child window, we are unsuccessful
    // and will return NULL.
    //
    // Note on the bit manipulation below.  A window is either
    // an overlapped window, a popup window or a child window.
    // Hence, we OR together the possible bit combinations of these
    // possibilities.  This should tell us which bits are used in
    // the window style dword (although we know this becomes 0xC000
    // today, we don't know if these will ever change later).  Then,
    // we AND the bit combination we with the given window style
    // dword, and compare the result with WS_CHILD.  This tells us
    // whether or not the given window is a child window.
    //
    while (hwnd) {

        lWinStyle = GetWindowLong (hwnd, GWL_STYLE);

        if ((lWinStyle & (WS_OVERLAPPED | WS_POPUP | WS_CHILD)) != WS_CHILD) {
            return hwnd;
        }

        hwnd = GetParent(hwnd);
    }

    return NULL;
}


INT_PTR
CALLBACK
NwpPasswdPromptDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
/*++

Routine Description:

    This function is the window management message handler for
    the change password dialog.

Arguments:

    DialogHandle - Supplies a handle to display the dialog.

    Message - Supplies the window management message.

    LParam - Supplies the pointer to a buffer which on input
        contains the Server string under which the user
        needs to type in a new credential before browsing.  On
        output, this pointer contains the username and server
        strings entered to the dialog box.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    LPWSTR UserName;
    LPWSTR ServerName;
    static LPWSTR Password;
    static DWORD  PasswordSize ;
    INT           Result ;
    PPROMPTDLGPARAM DlgParams ;
    DWORD           nLength;

    WCHAR  szLocation[MAX_PATH];

    szLocation[0] = 0;


    switch (Message) {

        case WM_INITDIALOG:

            DlgParams = (PPROMPTDLGPARAM) LParam;
            UserName = DlgParams->UserName ;
            ServerName =  DlgParams->ServerName ;
            Password = DlgParams->Password ;
            PasswordSize =  DlgParams->PasswordSize ;

            ASSERT(ServerName) ;

            //
            // Position dialog
            //
            NwpCenterDialog(DialogHandle);

            //
            // Get the string "Server" or "Context".
            //
            nLength = LoadStringW(
                          hmodNW,
                          IS_TREE(ServerName) ? IDS_CONTEXT : IDS_SERVER,
                          szLocation,
                          sizeof(szLocation) / sizeof(szLocation[0])
                          );

            if ( nLength == 0) {
                szLocation[0] = 0; // missing text, but still works
            }
            SetDlgItemTextW(DialogHandle, ID_LOCATION, szLocation);

            //
            // Format the server/context string. Note we reuse the 
            // location buffer.
            //
            RtlZeroMemory(szLocation, sizeof(szLocation)) ;
            nLength = wcslen(ServerName)  ;

            if ( IS_TREE(ServerName)  && 
                 (nLength+1  < (sizeof(szLocation)/sizeof(szLocation[0]))))
            {
                //
                // NDS tree & context
                //
                WCHAR *pszTmp ;

                wcscpy(szLocation, ServerName+1) ; // skip the * if tree\context

                if (pszTmp = wcschr(szLocation, L'\\'))
                {
                    *pszTmp = L'(' ;
                    wcscat(szLocation, L")") ;
                }
            }
            else
            {
                wcsncpy(szLocation, ServerName, nLength) ;
            }

            //
            //  show the user and server names. 
            //
            SetDlgItemTextW(DialogHandle, ID_SERVER, szLocation);
            SetDlgItemTextW(DialogHandle, ID_USERNAME, UserName);

            //
            // set limits
            //
            SendDlgItemMessageW( DialogHandle,
                                 ID_PASSWORD,
                                 EM_LIMITTEXT,
                                 PasswordSize - 1,  // minus space for '\0'
                                 0 );

            return TRUE;


        case WM_COMMAND:

            switch (LOWORD(WParam)) {


                case IDHELP:

                    DialogBoxParamW(
                        hmodNW,
                        MAKEINTRESOURCEW(DLG_ENTER_PASSWORD_HELP),
                        (HWND) DialogHandle,
                        NwpHelpDlgProc,
                        (LPARAM) 0
                        );

                    return TRUE;

                case IDOK:

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_PASSWORD,
                                              Password,
                                              PasswordSize
                                              );

                    EndDialog(DialogHandle, (INT) IDOK);  // OK

                    return TRUE;


                case IDCANCEL:


                    EndDialog(DialogHandle, (INT) IDCANCEL);  // CANCEL

                    return TRUE;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}



INT_PTR
CALLBACK
NwpChangePasswordDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
/*++

Routine Description:

    This function is the window management message handler for
    the change password dialog.

Arguments:

    DialogHandle - Supplies a handle to display the dialog.

    Message - Supplies the window management message.

    LParam - Supplies the pointer to a buffer which on input
        contains the Server string under which the user
        needs to type in a new credential before browsing.  On
        output, this pointer contains the username and server
        strings entered to the dialog box.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    static PCHANGE_PASS_DLG_PARAM pChangePassParam ;

    switch (Message)
    {
      case WM_INITDIALOG:

        pChangePassParam = (PCHANGE_PASS_DLG_PARAM) LParam;

        NwpCenterDialog(DialogHandle);


        SetDlgItemTextW(DialogHandle, ID_SERVER, pChangePassParam->TreeName);
        SetDlgItemTextW(DialogHandle, ID_USERNAME, pChangePassParam->UserName);

        //
        // set limits
        //
        SendDlgItemMessageW( DialogHandle,
                             ID_OLD_PASSWORD,
                             EM_LIMITTEXT,
                             NW_MAX_PASSWORD_LEN,  // minus space for '\0'
                             0 );

        SendDlgItemMessageW( DialogHandle,
                             ID_NEW_PASSWORD,
                             EM_LIMITTEXT,
                             NW_MAX_PASSWORD_LEN,  // minus space for '\0'
                             0 );

        SendDlgItemMessageW( DialogHandle,
                             ID_CONFIRM_PASSWORD,
                             EM_LIMITTEXT,
                             NW_MAX_PASSWORD_LEN,  // minus space for '\0'
                             0 );

        return TRUE;


      case WM_COMMAND:

        switch (LOWORD(WParam))
        {
            case IDHELP:

                DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_CHANGE_PASSWORD_HELP),
                                 (HWND) DialogHandle,
                                 NwpHelpDlgProc,
                                 (LPARAM) 0
                               );

                return TRUE;

            case IDOK:
                {
                    INT    Result;
                    WCHAR  szConfirmPassword[NW_MAX_PASSWORD_LEN + 1];
                    UNICODE_STRING OldPasswordStr;
                    UNICODE_STRING NewPasswordStr;
                    UCHAR EncodeSeed = NW_ENCODE_SEED2;

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_OLD_PASSWORD,
                                              pChangePassParam->OldPassword,
                                              NW_MAX_PASSWORD_LEN
                                            );

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_NEW_PASSWORD,
                                              pChangePassParam->NewPassword,
                                              NW_MAX_PASSWORD_LEN
                                            );

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_CONFIRM_PASSWORD,
                                              szConfirmPassword,
                                              NW_MAX_PASSWORD_LEN
                                            );

                    if ( wcscmp( pChangePassParam->NewPassword,
                                 szConfirmPassword ) )
                    {
                        //
                        // New and Confirm passwords don't match!
                        //
                        (void) NwpMessageBoxError(
                                   DialogHandle,
                                   IDS_CHANGE_PASSWORD_TITLE,
                                   IDS_CHANGE_PASSWORD_CONFLICT,
                                   0,
                                   NULL,
                                   MB_OK | MB_ICONSTOP );

                        SetDlgItemText( DialogHandle,
                                        ID_NEW_PASSWORD,
                                        L"" );

                        SetDlgItemText( DialogHandle,
                                        ID_CONFIRM_PASSWORD,
                                        L"" );

                        SetFocus( GetDlgItem( DialogHandle,
                                              ID_NEW_PASSWORD ));

                        return TRUE;
                    }

                    RtlInitUnicodeString( &OldPasswordStr,
                                          pChangePassParam->OldPassword );
                    RtlInitUnicodeString( &NewPasswordStr,
                                          pChangePassParam->NewPassword );
                    RtlRunEncodeUnicodeString(&EncodeSeed, &OldPasswordStr);
                    RtlRunEncodeUnicodeString(&EncodeSeed, &NewPasswordStr);

                    EndDialog(DialogHandle, (INT) IDOK);  // OK

                    return TRUE;
                }

            case IDCANCEL:

                EndDialog(DialogHandle, (INT) IDCANCEL);  // CANCEL

                return TRUE;

            default:
                return FALSE;
        }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}



INT_PTR
CALLBACK
NwpHelpDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
//
// This dialog is used for both Help and Question dialogs.
//
{
    switch (Message) {

        case WM_INITDIALOG:

            NwpCenterDialog(DialogHandle);
            return TRUE;

        case WM_COMMAND:

            switch (LOWORD(WParam))
            {

                case IDOK:
                case IDCANCEL:
                    EndDialog(DialogHandle, IDOK);
                    return TRUE;

                case IDYES:
                    EndDialog(DialogHandle, IDYES);
                    return TRUE;

                case IDNO:
                    EndDialog(DialogHandle, IDNO);
                    return TRUE;

                default:
                    return FALSE ;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}



VOID
NwpGetNoneString(
    LPWSTR pszNone,
    DWORD  cBufferSize
    )
/*++

Routine Description:

    This function gets the <NONE> string from the resource.

Arguments:

    pszNone - Supplies the buffer to store the string.

    cBufferSize - Supplies the buffer size in bytes.

Return Value:

    None.
--*/
{
    INT TextLength;


    TextLength = LoadStringW( hmodNW,
                              IDS_NONE,
                              pszNone,
                              cBufferSize / sizeof( WCHAR) );

    if ( TextLength == 0 )
        *pszNone = 0;
}



VOID
NwpAddNetWareTreeConnectionsToList(
    IN HWND    DialogHandle,
    IN LPWSTR  NtUserName,
    IN LPDWORD lpdwUserLuid,
    IN INT     ControlId
    )
{
    DWORD  status = NO_ERROR;
    DWORD  BufferSize = 2048; // 2KB Buffer
    BYTE   pBuffer[2048];
    DWORD  EntriesRead;
    LRESULT    Result ;

    status = NwGetConnectedTrees( NtUserName,
                                  pBuffer,
                                  BufferSize,
                                  &EntriesRead,
                                  lpdwUserLuid );

    // NwGetConnectedTrees doesn't return ERR_NO_SUCH_USER, so we check for no EntriesRead
    // Bug 624023 - It looks like NwGetConnectedTrees DOES return ERR_NO_SUCH_USER
    // If none found, check for dotted name (fred.flintstone) or UPN (fred@flintstones.com)
    if ( EntriesRead == 0 )
    {
        // escape any dots in the user name and try again
        WCHAR   EscapedName[NW_MAX_USERNAME_LEN * 2];
        PWSTR   pChar = NtUserName;
        int     i = 0;
        BOOL    bEscaped = FALSE;

        RtlZeroMemory(EscapedName, sizeof(EscapedName));

        do
        {
            if (*pChar == L'.')
            {
                EscapedName[i++] = '\\';
                bEscaped = TRUE;
            }
            // also handle UPN names
            else if (*pChar == L'@') { 
                EscapedName[i] = 0;
                bEscaped = TRUE;
                break;
            }
            EscapedName[i++] = *pChar;
        } while (*pChar++);

        if (bEscaped)
        {
            status = NwGetConnectedTrees( EscapedName,
                                          pBuffer,
                                          BufferSize,
                                          &EntriesRead,
                                          lpdwUserLuid );
        }
    }
    if ( status == NO_ERROR  && EntriesRead > 0 )
    {
        PCONN_INFORMATION pConnInfo = (PCONN_INFORMATION) pBuffer;
        WCHAR             tempTreeName[NW_MAX_TREE_LEN + 1];
        DWORD             dwSize;

        while ( EntriesRead-- )
        {
            dwSize = sizeof( CONN_INFORMATION );
            dwSize += pConnInfo->HostServerLength;
            dwSize += pConnInfo->UserNameLength;

            RtlZeroMemory( tempTreeName,
                           ( NW_MAX_TREE_LEN + 1 ) * sizeof(WCHAR) );

            wcsncpy( tempTreeName,
                     pConnInfo->HostServer,
                     pConnInfo->HostServerLength / sizeof(WCHAR) );

            CharUpperW( tempTreeName );

            //
            // Add the tree name to the list only
            // if it's not added already.
            //
            Result = SendDlgItemMessageW( DialogHandle,
                                          ControlId,
                                          LB_FINDSTRING,
                                          (WPARAM) -1,
                                          (LPARAM) tempTreeName );

            if (Result == LB_ERR)
            {
                Result = SendDlgItemMessageW( DialogHandle,
                                     ControlId,
                                     LB_ADDSTRING,
                                     0,
                                     (LPARAM) tempTreeName );

                if (Result != LB_ERR)
                {
                    LPWSTR lpNdsUserName = NULL;

                    lpNdsUserName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                                pConnInfo->UserNameLength +
                                                sizeof(WCHAR) );

                    if ( lpNdsUserName )
                    {
                        wcsncpy( lpNdsUserName,
                                 pConnInfo->UserName,
                                 pConnInfo->UserNameLength  / sizeof(WCHAR) );

                        SendDlgItemMessageW( DialogHandle,
                                             ControlId,
                                             LB_SETITEMDATA,
                                             (WPARAM) Result, // index of entry
                                             (LPARAM) lpNdsUserName );
                    }
                }
            }

            pConnInfo = (PCONN_INFORMATION) ( ((BYTE *)pConnInfo) + dwSize );
        }
    }
    else
    {
        *lpdwUserLuid = 0;
    }
}



INT_PTR
CALLBACK
NwpChangePasswdDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
/*++

Routine Description:

    This function is the window management message handler for
    the change password dialog.

Arguments:

    DialogHandle - Supplies a handle to display the dialog.

    Message - Supplies the window management message.

    LParam - Supplies the pointer to a buffer which on input
        contains the Server string under which the user
        needs to type in a new credential before browsing.  On
        output, this pointer contains the username and server
        strings entered to the dialog box.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    static LPWSTR UserName;
    static LPWSTR ServerName;
    static DWORD  UserNameSize ;
    static DWORD  ServerNameSize ;
    INT           Result ;
    PPASSWDDLGPARAM DlgParams ;

    switch (Message) {

        case WM_INITDIALOG:

            DlgParams = (PPASSWDDLGPARAM) LParam;
            UserName = DlgParams->UserName ;
            ServerName =  DlgParams->ServerName ;
            UserNameSize = DlgParams->UserNameSize ;
            ServerNameSize =  DlgParams->ServerNameSize ;

            //
            // Position dialog
            //
            NwpCenterDialog(DialogHandle);


            //
            //  setup the default user and server names
            //
            SetDlgItemTextW(DialogHandle, ID_SERVER, ServerName);
            SetDlgItemTextW(DialogHandle, ID_USERNAME, UserName);

            //
            // Username is limited to 256 characters.
            //
            SendDlgItemMessageW(DialogHandle,
                                ID_USERNAME,
                                EM_LIMITTEXT,
                                UserNameSize - 1, // minus space for '\0'
                                0 );

            //
            // Server is limited to 256 characters.
            //
            SendDlgItemMessageW( DialogHandle,
                                 ID_SERVER,
                                 EM_LIMITTEXT,
                                 ServerNameSize - 1, // minus space for '\0'
                                 0 );

            //
            // Add trees to list
            //
            NwpAddToComboBox( DialogHandle,
                              ID_SERVER,
                              NULL,
                              FALSE ) ;

            return TRUE;


        case WM_COMMAND:

            switch (LOWORD(WParam)) {

                case IDOK:

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_USERNAME,
                                              UserName,
                                              UserNameSize );

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_SERVER,
                                              ServerName,
                                              ServerNameSize );

                    EndDialog(DialogHandle, (INT) IDOK);  // OK

                    return TRUE;


                case IDCANCEL:

                    EndDialog(DialogHandle, (INT) IDCANCEL);  // CANCEL

                    return TRUE;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}



INT_PTR
CALLBACK
NwpOldPasswordDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
//
// This dialog lets the user retype the old password for a specific
// server/tree.
//
{
    static POLD_PW_DLG_PARAM OldPwParam;


    switch (Message) {

        case WM_INITDIALOG:

            OldPwParam = (POLD_PW_DLG_PARAM) LParam;

            NwpCenterDialog(DialogHandle);

            SetDlgItemTextW(DialogHandle, ID_SERVER, OldPwParam->FailedServer);

            SendDlgItemMessageW(
                DialogHandle,
                ID_PASSWORD,
                EM_LIMITTEXT,
                NW_MAX_PASSWORD_LEN,
                0
                );

            return TRUE;

        case WM_COMMAND:

            switch (LOWORD(WParam))
            {

                case IDCANCEL:
                    EndDialog(DialogHandle, IDCANCEL);
                    return TRUE;

                case IDOK:
                {
                    UCHAR EncodeSeed = NW_ENCODE_SEED2;
                    UNICODE_STRING PasswordStr;


                    RtlZeroMemory(
                        OldPwParam->OldPassword,
                        NW_MAX_PASSWORD_LEN * sizeof(WCHAR)
                        );

                    GetDlgItemTextW(
                        DialogHandle,
                        ID_PASSWORD,
                        OldPwParam->OldPassword,
                        NW_MAX_PASSWORD_LEN
                        );

#if DBG
                    IF_DEBUG(LOGON) {
                        KdPrint(("NWPROVAU: Retyped password %ws\n",
                                 OldPwParam->OldPassword));
                    }
#endif
                    RtlInitUnicodeString(&PasswordStr, OldPwParam->OldPassword);
                    RtlRunEncodeUnicodeString(&EncodeSeed, &PasswordStr);

                    EndDialog(DialogHandle, IDOK);
                    return TRUE;
                }

                case IDHELP:

                    DialogBoxParamW(
                        hmodNW,
                        MAKEINTRESOURCEW(DLG_ENTER_OLD_PW_HELP),
                        (HWND) DialogHandle,
                        NwpHelpDlgProc,
                        (LPARAM) 0
                        );
                    return TRUE;

                default:
                    return FALSE;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}



INT_PTR
CALLBACK
NwpAltUserNameDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
//
// This dialog lets the user retype an alternate username for a specific
// server/tree.
//
{
    static PUSERNAME_DLG_PARAM UserNameParam;

    switch (Message)
    {
        case WM_INITDIALOG:

            UserNameParam = (PUSERNAME_DLG_PARAM) LParam;

            NwpCenterDialog(DialogHandle);

            //
            // Display the server/tree.
            //
            SetDlgItemTextW(
                DialogHandle,
                ID_SERVER,
                UserNameParam->TreeServerName
                );

            //
            // Username is limited to 256 characters.
            //
            SendDlgItemMessageW(
                DialogHandle,
                ID_USERNAME,
                EM_LIMITTEXT,
                256, 
                0
                );

            SetDlgItemTextW(
                DialogHandle,
                ID_USERNAME,
                UserNameParam->UserName
                );

            return TRUE;

        case WM_COMMAND:

            switch (LOWORD(WParam))
            {

                case IDCANCEL:
                    EndDialog(DialogHandle, IDCANCEL);
                    return TRUE;

                case IDOK:
                {
                    RtlZeroMemory(
                        UserNameParam->UserName,
                        256 * sizeof(WCHAR)
                        );

                    GetDlgItemTextW(
                        DialogHandle,
                        ID_USERNAME,
                        UserNameParam->UserName,
                        256
                        );

#if DBG
                    IF_DEBUG(LOGON) {
                        KdPrint(("NWPROVAU: Retyped username %ws\n",
                                 UserNameParam->UserName));
                    }
#endif

                    EndDialog(DialogHandle, IDOK);
                    return TRUE;
                }

                case IDHELP:

                    DialogBoxParamW(
                        hmodNW,
                        MAKEINTRESOURCEW(DLG_ENTER_ALT_UN_HELP),
                        (HWND) DialogHandle,
                        NwpHelpDlgProc,
                        (LPARAM) 0
                        );
                    return TRUE;

                default:
                    return FALSE;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}


VOID
EnableAddRemove(
    IN HWND DialogHandle
    )
/*++

Routine Description:

    This function enables and disables Add and Remove buttons
    based on list box selections.

Arguments:

    DialogHandle - Supplies a handle to the windows dialog.

Return Value:

    None.

--*/
{
    LRESULT cSel;


    cSel = SendDlgItemMessageW(
               DialogHandle,
               ID_INACTIVE_LIST,
               LB_GETSELCOUNT,
               0,
               0
               );
    EnableWindow(GetDlgItem(DialogHandle, ID_ADD), cSel != 0);

    cSel = SendDlgItemMessageW(
               DialogHandle,
               ID_ACTIVE_LIST,
               LB_GETSELCOUNT,
               0,
               0
               );
    EnableWindow(GetDlgItem(DialogHandle, ID_REMOVE), cSel != 0);
}




INT_PTR
CALLBACK
NwpSelectServersDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
/*++

Routine Description:

    This routine displays two listboxes--an active list which includes
    the trees which the user is currently attached to, and an inactive
    list which displays the rest of the trees on the net.  The user
    can select trees and move them back and forth between the list
    boxes.  When OK is selected, the password is changed on the trees
    in the active listbox.

Arguments:

    DialogHandle - Supplies a handle to the login dialog.

    Message - Supplies the window management message.

    LParam - Supplies the user credential: username, old password and
        new password.  The list of trees from the active listbox
        and the number of entries are returned.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    WCHAR szServer[NW_MAX_SERVER_LEN + 1];
    static PCHANGE_PW_DLG_PARAM Credential;
    DWORD status;
    DWORD UserLuid = 0;
    LRESULT ActiveListBoxCount;
    LRESULT InactiveListBoxCount;

    switch (Message) {

        case WM_INITDIALOG:

            //
            // Get the user credential passed in.
            //
            Credential = (PCHANGE_PW_DLG_PARAM) LParam;

            //
            // Position dialog
            //
            NwpCenterDialog(DialogHandle);

            //
            // Display the username.
            //
            SetDlgItemTextW(
                DialogHandle,
                ID_USERNAME,
                Credential->UserName
                );

            //
            // Display current NetWare tree connections in the active box.
            //
            NwpAddNetWareTreeConnectionsToList(
                DialogHandle,
                Credential->UserName,
                &UserLuid,
                ID_ACTIVE_LIST
                );

            //
            // Display all trees in inactive list box.
            //
            NwpAddTreeNamesToControl(
                DialogHandle,
                ID_INACTIVE_LIST,
                LB_ADDSTRING,
                ID_ACTIVE_LIST,
                LB_FINDSTRING
                );

            //
            // Highlight the first entry of the inactive list.
            //
            SetFocus(GetDlgItem(DialogHandle, ID_INACTIVE_LIST));
            SendDlgItemMessageW(
                DialogHandle,
                ID_INACTIVE_LIST,
                LB_SETSEL,
                TRUE,
                0
                );

            EnableAddRemove(DialogHandle);

            ActiveListBoxCount = SendDlgItemMessageW( DialogHandle,
                                                      ID_ACTIVE_LIST,
                                                      LB_GETCOUNT,
                                                      0,
                                                      0 );

            InactiveListBoxCount = SendDlgItemMessageW( DialogHandle,
                                                        ID_INACTIVE_LIST,
                                                        LB_GETCOUNT,
                                                        0,
                                                        0 );

            if ( ActiveListBoxCount == 0 &&
                 InactiveListBoxCount == 0 )
            {
                    (void) NwpMessageBoxError( DialogHandle,
                                               IDS_NETWARE_TITLE,
                                               IDS_NO_TREES_DETECTED,
                                               0,
                                               NULL,
                                               MB_OK );

                    EndDialog(DialogHandle, (INT) IDOK);
            }

            return TRUE;

        case WM_COMMAND:

            switch (LOWORD(WParam))
            {
                case IDOK:
                {
                    if ((status = NwpGetTreesAndChangePw(
                                      DialogHandle,
                                      szServer,
                                      UserLuid,
                                      Credential
                                      ) != NO_ERROR))
                    {
                        //
                        // System error: e.g. out of memory error.
                        //
                        (void) NwpMessageBoxError(
                                   DialogHandle,
                                   IDS_CHANGE_PASSWORD_TITLE,
                                   0,
                                   status,
                                   NULL,
                                   MB_OK | MB_ICONSTOP );

                        EndDialog(DialogHandle, (INT) -1);
                        return TRUE;
                    }

                    EndDialog(DialogHandle, (INT) IDOK);
                    return TRUE;
                }

                case IDCANCEL:

                    EndDialog(DialogHandle, (INT) IDCANCEL);
                    return TRUE;


                case IDHELP:

                    DialogBoxParamW(
                        hmodNW,
                        MAKEINTRESOURCEW(DLG_PW_SELECT_SERVERS_HELP),
                        (HWND) DialogHandle,
                        NwpHelpDlgProc,
                        (LPARAM) 0
                        );

                    return TRUE;



                case ID_ACTIVE_LIST:
                    //
                    // When Remove is pressed the highlights follows
                    // the selected entries over to the other
                    // list box.
                    //
                    if (HIWORD(WParam) == LBN_SELCHANGE) {
                        //
                        // Unselect the other listbox
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            ID_INACTIVE_LIST,
                            LB_SETSEL,
                            FALSE,
                            (LPARAM) -1
                            );

                        EnableAddRemove(DialogHandle);
                    }

                    return TRUE;

                case ID_INACTIVE_LIST:

                    //
                    // When Add is pressed the highlights follows
                    // the selected entries over to the other
                    // list box.
                    //
                    if (HIWORD(WParam) == LBN_SELCHANGE) {
                        //
                        // Unselect the other listbox
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            ID_ACTIVE_LIST,
                            LB_SETSEL,
                            FALSE,
                            (LPARAM) -1
                            );

                        EnableAddRemove(DialogHandle);
                    }

                    return TRUE;

                case ID_ADD:
                case ID_REMOVE:
                {
                    INT idFrom;
                    INT idTo;
                    LRESULT cSel;
                    INT SelItem;
                    LRESULT iNew;
                    HWND hwndActiveList;
                    HWND hwndInactiveList;

                    hwndActiveList = GetDlgItem(DialogHandle, ID_ACTIVE_LIST);
                    hwndInactiveList = GetDlgItem(DialogHandle, ID_INACTIVE_LIST);

                    //
                    // Set to NOREDRAW to TRUE
                    //
                    SetWindowLong(hwndActiveList, GWL_STYLE,
                    GetWindowLong(hwndActiveList, GWL_STYLE) | LBS_NOREDRAW);
                    SetWindowLong(hwndInactiveList, GWL_STYLE,
                    GetWindowLong(hwndInactiveList, GWL_STYLE) | LBS_NOREDRAW);

                    if (LOWORD(WParam) == ID_ADD)
                    {
                      idFrom = ID_INACTIVE_LIST;
                      idTo = ID_ACTIVE_LIST;
                    }
                    else
                    {
                      idFrom = ID_ACTIVE_LIST;
                      idTo = ID_INACTIVE_LIST;
                    }

                    //
                    // Move current selection from idFrom to idTo
                    //

                    //
                    // Loop terminates when selection count is zero
                    //
                    for (;;) {
                        //
                        // Get count of selected strings
                        //
                        cSel = SendDlgItemMessageW(
                                   DialogHandle,
                                   idFrom,
                                   LB_GETSELCOUNT,
                                   0,
                                   0
                                   );

                        if (cSel == 0) {
                            //
                            // No more selection
                            //
                            break;
                        }

                        //
                        // To avoid flickering as strings are added and
                        // removed from listboxes, no redraw is set for
                        // both listboxes until we are transfering the
                        // last entry, in which case we reenable redraw
                        // so that both listboxes are updated once.
                        //
                        if (cSel == 1) {

                            SetWindowLong(
                                hwndActiveList,
                                GWL_STYLE,
                                GetWindowLong(hwndActiveList, GWL_STYLE) & ~LBS_NOREDRAW
                                );

                            SetWindowLong(
                                hwndInactiveList,
                                GWL_STYLE,
                                GetWindowLong(hwndInactiveList, GWL_STYLE) & ~LBS_NOREDRAW
                                );
                        }

                        //
                        // Get index of first selected item
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            idFrom,
                            LB_GETSELITEMS,
                            1,
                            (LPARAM) &SelItem
                            );

                        //
                        // Get server name from list
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            idFrom,
                            LB_GETTEXT,
                            (WPARAM) SelItem,
                            (LPARAM) (LPWSTR) szServer
                            );

                        //
                        // Remove entry from list
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            idFrom,
                            LB_DELETESTRING,
                            (WPARAM) SelItem,
                            0
                            );

                        //
                        // Add entry to list
                        //
                        iNew = SendDlgItemMessageW(
                                   DialogHandle,
                                   idTo,
                                   LB_ADDSTRING,
                                   0,
                                   (LPARAM) (LPWSTR) szServer
                                   );

                        //
                        // Select the new item
                        //
                        if (iNew != LB_ERR) {
                                SendDlgItemMessageW(
                                    DialogHandle,
                                    idTo,
                                    LB_SETSEL,
                                    TRUE,
                                    iNew
                                    );
                        }

                    } // for

                    EnableAddRemove(DialogHandle);

                } // ID_ADD or ID_REMOVE
            }

    }

    //
    // We didn't process this message
    //
    return FALSE;
}

DWORD
NwpGetTreesAndChangePw(
    IN HWND   DialogHandle,
    IN LPWSTR ServerBuf,
    IN DWORD  UserLuid,
    IN PCHANGE_PW_DLG_PARAM Credential
    )
/*++

Routine Description:

    This routine gets the selected trees from the active list box
    and asks the redirector to change password on them.  If a failure
    is encountered when changing password on a tree, we pop up appropriate
    dialogs to see if user can fix problem.

Arguments:

    DialogHandle - Supplies a handle to the login dialog.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    DWORD status;
    HCURSOR Cursor;
    WCHAR tempOldPassword[NW_MAX_PASSWORD_LEN + 1];
    WCHAR tempNewPassword[NW_MAX_PASSWORD_LEN + 1];
    WCHAR tempUserName[MAX_NDS_NAME_CHARS];

    //
    // Turn cursor into hourglass
    //
    Cursor = LoadCursor(NULL, IDC_WAIT);
    if (Cursor != NULL) {
        SetCursor(Cursor);
        ShowCursor(TRUE);
    }

    Credential->ChangedOne = FALSE;
    Credential->TreeList = NULL;
    Credential->UserList = NULL;

    //
    // Get the number of trees we have to change password on.
    //
    Credential->Entries = (DWORD) SendDlgItemMessageW(
                                                      DialogHandle,
                                                      ID_ACTIVE_LIST,
                                                      LB_GETCOUNT,
                                                      0,
                                                      0 );

    if (Credential->Entries != 0) {

        DWORD Entries;        // Number of entries in remaining list
        DWORD FullIndex;      // Index to the whole tree list
        DWORD i;
        DWORD BytesNeeded = sizeof(LPWSTR) * Credential->Entries +
                            (NW_MAX_SERVER_LEN + 1) * sizeof(WCHAR) * Credential->Entries;
        LPBYTE FixedPortion;
        LPWSTR EndOfVariableData;
        LRESULT Result;

        Entries = Credential->Entries;
        Credential->TreeList = LocalAlloc(0, BytesNeeded);
        Credential->UserList = LocalAlloc(0,
                                          sizeof(LPWSTR) * Credential->Entries);

        if (Credential->TreeList == NULL)
        {
            KdPrint(("NWPROVAU: No memory to change password\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (Credential->UserList == NULL)
        {
            KdPrint(("NWPROVAU: No memory to change password\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        FixedPortion = (LPBYTE) Credential->TreeList;
        EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                             ROUND_DOWN_COUNT(BytesNeeded, ALIGN_DWORD));

        for (i = 0; i < Entries; i++)
        {
            //
            // Read the user selected list of servers from the dialog.
            //

            SendDlgItemMessageW(
                DialogHandle,
                ID_ACTIVE_LIST,
                LB_GETTEXT,
                (WPARAM) i,
                (LPARAM) (LPWSTR) ServerBuf );

            NwlibCopyStringToBuffer(
                ServerBuf,
                wcslen(ServerBuf),
                (LPCWSTR) FixedPortion,
                &EndOfVariableData,
                &(Credential->TreeList)[i] );

            Result = SendDlgItemMessageW( DialogHandle,
                                          ID_ACTIVE_LIST,
                                          LB_GETITEMDATA,
                                          (WPARAM) i,
                                          0 );

            if ( Result != LB_ERR )
            {
                (Credential->UserList)[i] = (LPWSTR) Result;
            }
            else
            {
                (Credential->UserList)[i] = NULL;
            }

            FixedPortion += sizeof(LPWSTR);
        }

        FullIndex = 0;

        do
        {
            RtlZeroMemory( tempUserName, sizeof(tempUserName) );
            RtlZeroMemory( tempOldPassword, sizeof(tempOldPassword) );
            RtlZeroMemory( tempNewPassword, sizeof(tempNewPassword) );
            RtlCopyMemory( tempOldPassword,
                           Credential->OldPassword,
                           sizeof(tempOldPassword) );
            RtlCopyMemory( tempNewPassword,
                           Credential->NewPassword,
                           sizeof(tempNewPassword) );

            if ( (Credential->UserList)[FullIndex] == NULL )
            {
                // We don't have any connections to tree <current entry>
                // Prompt user to supply a user name for which account
                // we are to change password, or skip . . .

                USERNAME_DLG_PARAM UserNameParam;
                CHANGE_PASS_DLG_PARAM ChangePassParam;

                UserNameParam.UserName = tempUserName;
                UserNameParam.TreeServerName = (Credential->TreeList)[FullIndex];

                SetCursor(Cursor);
                ShowCursor(FALSE);

                Result = DialogBoxParamW(
                             hmodNW,
                             MAKEINTRESOURCEW(DLG_ENTER_ALT_USERNAME),
                             (HWND) DialogHandle,
                             NwpAltUserNameDlgProc,
                             (LPARAM) &UserNameParam );

                Cursor = LoadCursor(NULL, IDC_WAIT);

                if (Cursor != NULL)
                {
                    SetCursor(Cursor);
                    ShowCursor(TRUE);
                }

                if ( Result != IDOK )
                {
                    *((Credential->TreeList)[FullIndex]) = L'\0';
                    goto SkipEntry;
                }

                // Now go reverify the credentials for the user name
                // entered by user.

                ChangePassParam.UserName = tempUserName;
                ChangePassParam.TreeName = (Credential->TreeList)[FullIndex];
                ChangePassParam.OldPassword = tempOldPassword;
                ChangePassParam.NewPassword = tempNewPassword;

                SetCursor(Cursor);
                ShowCursor(FALSE);

                Result = DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_CHANGE_PASSWORD3),
                                 (HWND) DialogHandle,
                                 NwpChangePasswordDlgProc,
                                 (LPARAM) &ChangePassParam );

                Cursor = LoadCursor(NULL, IDC_WAIT);

                if (Cursor != NULL)
                {
                    SetCursor(Cursor);
                    ShowCursor(TRUE);
                }

                if ( Result != IDOK )
                {
                    *((Credential->TreeList)[FullIndex]) = L'\0';
                    goto SkipEntry;
                }

                goto Next;
            }
            else
            {
                wcscpy( tempUserName, (Credential->UserList)[FullIndex] );
                LocalFree( (Credential->UserList)[FullIndex] );
                (Credential->UserList)[FullIndex] = NULL;
            }

            // Test tempUserName with the user name in Credential->UserName
            // to see if they are similar (i.e. The first part of the
            // NDS distinguish name matches).

            if ( _wcsnicmp( tempUserName + 3,
                            Credential->UserName,
                            wcslen( Credential->UserName ) ) )
            {
                // The names are not similar!
                // Prompt user to ask if they really want to change
                // passwords for dis-similar user on tree <current entry>
                // or skip . . .

                USERNAME_DLG_PARAM UserNameParam;
                CHANGE_PASS_DLG_PARAM ChangePassParam;
                // escape any dots in the user name and try again
                WCHAR   EscapedName[NW_MAX_USERNAME_LEN * 2];
                PWSTR   pChar = Credential->UserName;
                int     i = 0;
                BOOL    bEscaped = FALSE;

                RtlZeroMemory(EscapedName, sizeof(EscapedName));

                do
                {
                    if (*pChar == L'.')
                    {
                        EscapedName[i++] = '\\';
                        bEscaped = TRUE;
                    }
                    // also handle UPN names
                    else if (*pChar == L'@') { 
                        EscapedName[i] = 0;
                        bEscaped = TRUE;
                        break;
                    }
                    EscapedName[i++] = *pChar;
                } while (*pChar++);

                if (bEscaped)
                {
                    if ( !_wcsnicmp( tempUserName + 3,
                                    EscapedName,
                                    wcslen( EscapedName ) ) )
                        goto Next;
                }

                UserNameParam.UserName = tempUserName;
                UserNameParam.TreeServerName = (Credential->TreeList)[FullIndex];

                SetCursor(Cursor);
                ShowCursor(FALSE);

                Result = DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_ENTER_ALT_USERNAME),
                                 (HWND) DialogHandle,
                                 NwpAltUserNameDlgProc,
                                 (LPARAM) &UserNameParam );

                Cursor = LoadCursor(NULL, IDC_WAIT);

                if (Cursor != NULL)
                {
                    SetCursor(Cursor);
                    ShowCursor(TRUE);
                }

                if ( Result != IDOK )
                {
                    *((Credential->TreeList)[FullIndex]) = L'\0';
                    goto SkipEntry;
                }

                // Now go reverify the credentials for the user name
                // entered by user.

                ChangePassParam.UserName = tempUserName;
                ChangePassParam.TreeName = (Credential->TreeList)[FullIndex];
                ChangePassParam.OldPassword = tempOldPassword;
                ChangePassParam.NewPassword = tempNewPassword;

                SetCursor(Cursor);
                ShowCursor(FALSE);

                Result = DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_CHANGE_PASSWORD3),
                                 (HWND) DialogHandle,
                                 NwpChangePasswordDlgProc,
                                 (LPARAM) &ChangePassParam );

                Cursor = LoadCursor(NULL, IDC_WAIT);

                if (Cursor != NULL)
                {
                    SetCursor(Cursor);
                    ShowCursor(TRUE);
                }

                if ( Result != IDOK )
                {
                    *((Credential->TreeList)[FullIndex]) = L'\0';
                    goto SkipEntry;
                }
            }

Next:
            status = NwrChangePassword(
                           NULL,                    // Reserved
                           UserLuid,
                           tempUserName,
                           tempOldPassword, // Encoded passwords
                           tempNewPassword,
                           (LPWSTR) (Credential->TreeList)[FullIndex] );

            if (status == ERROR_INVALID_PASSWORD)
            {
                OLD_PW_DLG_PARAM OldPasswordParam;

#if DBG
                IF_DEBUG(LOGON)
                {
                    KdPrint(("NWPROVAU: First attempt: wrong password on %ws\n",
                             (Credential->TreeList)[FullIndex]));
                }
#endif

                //
                // Display dialog to let user type in an alternate
                // old password.
                //

                //
                // Set up old password buffer to receive from dialog.
                //
                OldPasswordParam.OldPassword = tempOldPassword;

                OldPasswordParam.FailedServer = (Credential->TreeList)[FullIndex];

                SetCursor(Cursor);
                ShowCursor(FALSE);

                Result = DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_ENTER_OLD_PASSWORD),
                                 (HWND) DialogHandle,
                                 NwpOldPasswordDlgProc,
                                 (LPARAM) &OldPasswordParam );

                Cursor = LoadCursor(NULL, IDC_WAIT);

                if (Cursor != NULL)
                {
                    SetCursor(Cursor);
                    ShowCursor(TRUE);
                }

                if (Result == IDOK)
                {
                    //
                    // Retry change password with alternate old password on
                    // the failed server.
                    //
                    status = NwrChangePassword(
                                    NULL,            // Reserved
                                    UserLuid,
                                    tempUserName,
                                    tempOldPassword, // Alternate old password
                                    tempNewPassword,
                                    (LPWSTR) (Credential->TreeList)[FullIndex] );
                }
            }

            if (status != NO_ERROR)
            {
                //
                // Either unrecoverable failure or user failed to change
                // password on second attempt.
                //
#if DBG
                IF_DEBUG(LOGON)
                {
                    KdPrint(("NWPROVAU: Failed to change password on %ws %lu\n",
                             (Credential->TreeList)[FullIndex], status));
                }
#endif

                // Pop up error dialog to let user know that password
                // could not be changed.

                (void) NwpMessageBoxError(
                               DialogHandle,
                               IDS_CHANGE_PASSWORD_TITLE,
                               IDS_CP_FAILURE_WARNING,
                               status,
                               (LPWSTR) (Credential->TreeList)[FullIndex], 
                               MB_OK | MB_ICONSTOP );

                *((Credential->TreeList)[FullIndex]) = L'\0';

                if (status == ERROR_NOT_ENOUGH_MEMORY)
                    return status;
            }

SkipEntry:
            //
            // Continue to change password on the rest of the entries
            //
            FullIndex++;
            Entries = Credential->Entries - FullIndex;

        } while (Entries);

        //
        // Caller is responsible for freeing TreeList
        //
    }

    SetCursor(Cursor);
    ShowCursor(FALSE);

    return NO_ERROR;
}


INT_PTR
CALLBACK
NwpChangePasswordSuccessDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
/*++

Routine Description:

Arguments:

    DialogHandle - Supplies a handle to the login dialog.

    Message - Supplies the window management message.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    static PCHANGE_PW_DLG_PARAM Credential;
    DWORD_PTR  Count;
    DWORD  i;

    switch (Message)
    {
        case WM_INITDIALOG:

            //
            // Get the user credential passed in.
            //
            Credential = (PCHANGE_PW_DLG_PARAM) LParam;

            //
            // Position dialog
            //
            NwpCenterDialog(DialogHandle);

            //
            // Put list of NetWare trees that we changed password on in the
            // list box.
            //                                       ID_SERVER );
            for ( i = 0; i < Credential->Entries; i++ )
            {
                if ( *((Credential->TreeList)[i]) != L'\0' )
                {
                    SendDlgItemMessageW( DialogHandle,
                                         ID_SERVER,
                                         LB_ADDSTRING,
                                         0,
                                         (LPARAM) (Credential->TreeList)[i] );
                }
            }

            Count = SendDlgItemMessageW( DialogHandle,
                                         ID_SERVER,
                                         LB_GETCOUNT,
                                         0,
                                         0 );

            if ( Count == 0 )
                EndDialog(DialogHandle, 0);

            return TRUE;


        case WM_COMMAND:

            switch (LOWORD(WParam))
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(DialogHandle, 0);
                    return TRUE;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwshext.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshext.cxx

Abstract:

    This module implements the basics of shell extension classes.
    It includes AddRef(), Release(), QueryInterface() of the
    following classes.
        CNWObjContextMenuClassFactory, CNWObjContextMenu
        CNWFldContextMenuClassFactory, CNWFldContextMenu
        CNWHoodContextMenuClassFactory, CNWHoodContextMenu


Author:

    Yi-Hsin Sung (yihsins)  25-Oct-1995

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <shellapi.h>
#include <shlobj.h>
#include <stdio.h>
#define DONT_WANT_SHELLDEBUG
#include <shlobjp.h>

#include <nwreg.h>

#include "nwshcmn.h"
#include "nwshext.h"

//
// Initialize GUIDs (should be done only and at-least once per DLL/EXE)
//

#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <shlguid.h>
#include "nwclsid.h"
#pragma data_seg()

//
// Global variables
//
LONG  g_cRefThisDll = 0;      // Reference count of this DLL.
WCHAR g_szProviderName[256];  // Store the provider name

HINSTANCE           g_hShellLibrary = NULL;
SHELLGETNETRESOURCE g_pFuncSHGetNetResource = NULL;
SHELLDRAGQUERYFILE  g_pFuncSHDragQueryFile = NULL;
SHELLCHANGENOTIFY   g_pFuncSHChangeNotify  = NULL;
SHELLEXECUTEEX      g_pFuncSHExecuteEx = NULL;


#if DBG
WCHAR     szDebugStr[256];      // For Debug Output
#endif

BOOL LoadShellDllEntries( VOID );

extern "C"
{
//---------------------------------------------------------------------------
// NwCleanupShellExtension
//---------------------------------------------------------------------------

VOID NwCleanupShellExtensions( VOID )
{
    if ( g_hShellLibrary )
    {
        FreeLibrary( g_hShellLibrary );
        g_hShellLibrary = NULL;
    }
}
}

//---------------------------------------------------------------------------
// DllCanUnloadNow
//---------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
{
#if DBG
	wsprintf( szDebugStr,L"In DLLCanUnloadNow: g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif

    return ResultFromScode((g_cRefThisDll == 0) ? S_OK : S_FALSE);
}

//---------------------------------------------------------------------------
// DllGetClassObject
//---------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvOut)
{
    *ppvOut = NULL;

    if ( !LoadShellDllEntries() )
        return ResultFromScode(CLASS_E_CLASSNOTAVAILABLE);

    if (IsEqualIID(rclsid, CLSID_NetWareObjectExt))
    {
        CNWObjContextMenuClassFactory *pcf = new CNWObjContextMenuClassFactory;

		if ( pcf == NULL )
			return ResultFromScode(E_OUTOFMEMORY);

		HRESULT hr = pcf->QueryInterface(riid, ppvOut);

        if ( FAILED(hr) )
            delete pcf;

        return hr;
    }
    else if (IsEqualIID(rclsid, CLSID_NetWareFolderMenuExt))
    {
        CNWFldContextMenuClassFactory *pcf = new CNWFldContextMenuClassFactory;

		if ( pcf == NULL )
			return ResultFromScode(E_OUTOFMEMORY);

		HRESULT hr = pcf->QueryInterface(riid, ppvOut);

        if ( FAILED(hr) )
            delete pcf;

        return hr;
    }
    else if (IsEqualIID(rclsid, CLSID_NetworkNeighborhoodMenuExt))
    {
        CNWHoodContextMenuClassFactory *pcf= new CNWHoodContextMenuClassFactory;

		if ( pcf == NULL )
			return ResultFromScode(E_OUTOFMEMORY);

		HRESULT hr = pcf->QueryInterface(riid, ppvOut);

        if ( FAILED(hr) )
            delete pcf;

        return hr;
    }


    return ResultFromScode(CLASS_E_CLASSNOTAVAILABLE);
}

BOOL LoadShellDllEntries( VOID )
{
    static BOOL s_fLoaded = FALSE;

    if ( !s_fLoaded )
    {
        DWORD err;
        HKEY  hkey;

        g_hShellLibrary = LoadLibrary( L"shell32.dll");
        if ( g_hShellLibrary != NULL )
        {
            s_fLoaded = TRUE;

            g_pFuncSHGetNetResource =
                (SHELLGETNETRESOURCE) GetProcAddress( g_hShellLibrary,
                            (LPCSTR)(MAKELONG(SHGetNetResourceORD, 0)) );

            g_pFuncSHDragQueryFile =
                (SHELLDRAGQUERYFILE) GetProcAddress( g_hShellLibrary,
                                                    (LPCSTR) "DragQueryFileW");
            g_pFuncSHChangeNotify =
                (SHELLCHANGENOTIFY) GetProcAddress( g_hShellLibrary,
                                                    (LPCSTR) "SHChangeNotify");
            g_pFuncSHExecuteEx =
                (SHELLEXECUTEEX) GetProcAddress( g_hShellLibrary,
                                                 (LPCSTR) "ShellExecuteExW");
        }

        // Set the default provider name in case we fail to read
        // it from the registry.
        wcscpy( g_szProviderName, L"NetWare or Compatible Network");

        //
        // Read the Network Provider Name.
        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
        // \NWCWorkstation\networkprovider
        //
        err = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  NW_WORKSTATION_PROVIDER_PATH,
                  REG_OPTION_NON_VOLATILE,   // options
                  KEY_READ,                  // desired access
                  &hkey
                  );

        if ( err == NO_ERROR )
        {
            LPWSTR pszProviderName = NULL;

            //
            // ignore the return code. if fail, pszProviderName is NULL
            //
            err =  NwReadRegValue(
                      hkey,
                      NW_PROVIDER_VALUENAME,
                      &pszProviderName          // free with LocalFree
                      );

            if ( err == NO_ERROR && pszProviderName != NULL )
            {
                wcscpy( g_szProviderName, pszProviderName );
                LocalFree( pszProviderName );
            }

            RegCloseKey( hkey );
        }
    }

    return s_fLoaded;
}

//---------------------------------------------------------------------------
// CNWObjContextMenuClassFactory
//---------------------------------------------------------------------------

CNWObjContextMenuClassFactory::CNWObjContextMenuClassFactory()
{
    _cRef = 0L;
    InterlockedIncrement( &g_cRefThisDll );
	
#if DBG
	wsprintf( szDebugStr,L"CNWObjContextMenuClassFactory::CNWObjContextMenuClassFactory(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}
																
CNWObjContextMenuClassFactory::~CNWObjContextMenuClassFactory()				
{
    InterlockedDecrement( &g_cRefThisDll );
	
#if DBG
	wsprintf( szDebugStr,L"CNWObjContextMenuClassFactory::~CNWObjContextMenuClassFactory(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}

STDMETHODIMP CNWObjContextMenuClassFactory::QueryInterface(REFIID riid,
                                                   LPVOID FAR *ppv)
{
    *ppv = NULL;

    // Any interface on this object is the object pointer

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}	

STDMETHODIMP_(ULONG) CNWObjContextMenuClassFactory::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CNWObjContextMenuClassFactory::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;

    return 0L;
}

STDMETHODIMP CNWObjContextMenuClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                                   REFIID riid,
                                                   LPVOID *ppvObj)
{
    *ppvObj = NULL;

    // Shell extensions typically don't support aggregation (inheritance)

    if (pUnkOuter)
    	return ResultFromScode(CLASS_E_NOAGGREGATION);

    // Create the main shell extension object.  The shell will then call
    // QueryInterface with IID_IShellExtInit--this is how shell extensions are
    // initialized.

    LPCNWOBJCONTEXTMENU pShellExt = new CNWObjContextMenu();  // Create the CNWObjContextMenu object

    if (NULL == pShellExt)
    	return ResultFromScode(E_OUTOFMEMORY);

    //
    // We set the reference count of CNWObjContextMenu to one at initialization.
    // Hence, we can call Release() after QueryInterface.
    // So, if QueryInterface failed, Release will free the object.
    //

    HRESULT hr = pShellExt->QueryInterface(riid, ppvObj);
    pShellExt->Release();

    return hr;
}

STDMETHODIMP CNWObjContextMenuClassFactory::LockServer(BOOL fLock)
{
    return NOERROR;
}

//---------------------------------------------------------------------------
// CNWObjContextMenu
//---------------------------------------------------------------------------

CNWObjContextMenu::CNWObjContextMenu()
{
    _cRef = 1L;
    _pDataObj = NULL;

    _fGotClusterInfo = FALSE;
    _dwTotal = 0;
    _dwFree = 0;

    InterlockedIncrement( &g_cRefThisDll );

#if DBG
	wsprintf( szDebugStr,L"CNWObjContextMenu::CNWObjContextMenu(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}

CNWObjContextMenu::~CNWObjContextMenu()
{
    if (_pDataObj)
        _pDataObj->Release();

    InterlockedDecrement( &g_cRefThisDll );

#if DBG
 	wsprintf( szDebugStr,L"CNWObjContextMenu::~CNWObjContextMenu(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}

STDMETHODIMP CNWObjContextMenu::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellExtInit) || IsEqualIID(riid, IID_IUnknown))
    {
    	*ppv = (LPSHELLEXTINIT)this;
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        *ppv = (LPCONTEXTMENU)this;
    }
    else if (IsEqualIID(riid, IID_IShellPropSheetExt))
    {
        *ppv = (LPSHELLPROPSHEETEXT)this;
    }

    if (*ppv)
    {
        AddRef();

        return NOERROR;
    }

	return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CNWObjContextMenu::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CNWObjContextMenu::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;

    return 0L;
}

//
//  FUNCTION: CNWObjContextMenu::Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY)
//
//  PURPOSE: Called by the shell when initializing a context menu or property
//           sheet extension.
//
//  PARAMETERS:
//    pIDFolder - Specifies the parent folder
//    pDataObj  - Spefifies the set of items selected in that folder.
//    hRegKey   - Specifies the type of the focused item in the selection.
//
//  RETURN VALUE:
//
//    NOERROR in all cases.
//
//  COMMENTS:   Note that at the time this function is called, we don't know
//              (or care) what type of shell extension is being initialized.
//              It could be a context menu or a property sheet.
//

STDMETHODIMP CNWObjContextMenu::Initialize( LPCITEMIDLIST pIDFolder,
                                            LPDATAOBJECT pDataObj,
                                            HKEY hRegKey)
{
    // We do not need the registry handle so ignore it.

    // Initialize can be called more than once

    if (_pDataObj)
    	_pDataObj->Release();

    // Duplicate the object pointer

    if (pDataObj)
    {
    	_pDataObj = pDataObj;
    	pDataObj->AddRef();
    }

    return NOERROR;
}

//---------------------------------------------------------------------------
// CNWFldContextMenuClassFactory
//---------------------------------------------------------------------------

CNWFldContextMenuClassFactory::CNWFldContextMenuClassFactory()
{
    _cRef = 0L;
    InterlockedIncrement( &g_cRefThisDll );
	
#if DBG
	wsprintf( szDebugStr,L"CNWFldContextMenuClassFactory::CNWFldContextMenuClassFactory(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}
																
CNWFldContextMenuClassFactory::~CNWFldContextMenuClassFactory()				
{
    InterlockedDecrement( &g_cRefThisDll );
	
#if DBG
	wsprintf( szDebugStr,L"CNWFldContextMenuClassFactory::~CNWFldContextMenuClassFactory(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}

STDMETHODIMP CNWFldContextMenuClassFactory::QueryInterface(REFIID riid,
                                                   LPVOID FAR *ppv)
{
    *ppv = NULL;

    // Any interface on this object is the object pointer

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}	

STDMETHODIMP_(ULONG) CNWFldContextMenuClassFactory::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CNWFldContextMenuClassFactory::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;

    return 0L;
}

STDMETHODIMP CNWFldContextMenuClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                                   REFIID riid,
                                                   LPVOID *ppvObj)
{
    *ppvObj = NULL;

    // Shell extensions typically don't support aggregation (inheritance)

    if (pUnkOuter)
    	return ResultFromScode(CLASS_E_NOAGGREGATION);

    // Create the main shell extension object.  The shell will then call
    // QueryInterface with IID_IShellExtInit--this is how shell extensions are
    // initialized.

    LPCNWFLDCONTEXTMENU pShellExt = new CNWFldContextMenu();  // Create the CNWFldContextMenu object

    if (NULL == pShellExt)
    	return ResultFromScode(E_OUTOFMEMORY);

    //
    // We set the reference count of CNWFldContextMenu to one at initialization.
    // Hence, we can call Release() after QueryInterface.
    // So, if QueryInterface failed, Release will free the object.
    //

    HRESULT hr = pShellExt->QueryInterface(riid, ppvObj);
    pShellExt->Release();

    return hr;
}

STDMETHODIMP CNWFldContextMenuClassFactory::LockServer(BOOL fLock)
{
    return NOERROR;
}

//---------------------------------------------------------------------------
// CNWFldContextMenu
//---------------------------------------------------------------------------

CNWFldContextMenu::CNWFldContextMenu()
{
    _cRef = 1L;
    _pDataObj = NULL;

    InterlockedIncrement( &g_cRefThisDll );

#if DBG
	wsprintf( szDebugStr,L"CNWFldContextMenu::CNWFldContextMenu(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}

CNWFldContextMenu::~CNWFldContextMenu()
{
    if (_pDataObj)
        _pDataObj->Release();

    InterlockedDecrement( &g_cRefThisDll );

#if DBG
	wsprintf( szDebugStr,L"CNWFldContextMenu::~CNWFldContextMenu(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}

STDMETHODIMP CNWFldContextMenu::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellExtInit) || IsEqualIID(riid, IID_IUnknown))
    {
    	*ppv = (LPSHELLEXTINIT)this;
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        *ppv = (LPCONTEXTMENU)this;
    }

    if (*ppv)
    {
        AddRef();

        return NOERROR;
    }

	return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CNWFldContextMenu::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CNWFldContextMenu::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;

    return 0L;
}

//
//  FUNCTION: CNWFldContextMenu::Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY)
//
//  PURPOSE: Called by the shell when initializing a context menu or property
//           sheet extension.
//
//  PARAMETERS:
//    pIDFolder - Specifies the parent folder
//    pDataObj  - Spefifies the set of items selected in that folder.
//    hRegKey   - Specifies the type of the focused item in the selection.
//
//  RETURN VALUE:
//
//    NOERROR in all cases.
//
//  COMMENTS:   Note that at the time this function is called, we don't know
//              (or care) what type of shell extension is being initialized.
//              It could be a context menu or a property sheet.
//

STDMETHODIMP CNWFldContextMenu::Initialize( LPCITEMIDLIST pIDFolder,
                                            LPDATAOBJECT pDataObj,
                                            HKEY hRegKey)
{
    // We do not need the registry handle so ignore it.

    // Initialize can be called more than once

    if (_pDataObj)
    	_pDataObj->Release();

    // Duplicate the object pointer

    if (pDataObj)
    {
    	_pDataObj = pDataObj;
    	pDataObj->AddRef();
    }

    return NOERROR;
}

//---------------------------------------------------------------------------
// CNWHoodContextMenuClassFactory
//---------------------------------------------------------------------------

CNWHoodContextMenuClassFactory::CNWHoodContextMenuClassFactory()
{
    _cRef = 0L;
    InterlockedIncrement( &g_cRefThisDll );
	
#if DBG
	wsprintf( szDebugStr,L"CNWHoodContextMenuClassFactory::CNWHoodContextMenuClassFactory(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}
																
CNWHoodContextMenuClassFactory::~CNWHoodContextMenuClassFactory()				
{
    InterlockedDecrement( &g_cRefThisDll );
	
#if DBG
	wsprintf( szDebugStr,L"CNWHoodContextMenuClassFactory::~CNWHoodContextMenuClassFactory(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}

STDMETHODIMP CNWHoodContextMenuClassFactory::QueryInterface(REFIID riid,
                                                   LPVOID FAR *ppv)
{
    *ppv = NULL;

    // Any interface on this object is the object pointer

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}	

STDMETHODIMP_(ULONG) CNWHoodContextMenuClassFactory::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CNWHoodContextMenuClassFactory::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;

    return 0L;
}

STDMETHODIMP CNWHoodContextMenuClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                                   REFIID riid,
                                                   LPVOID *ppvObj)
{
    *ppvObj = NULL;

    // Shell extensions typically don't support aggregation (inheritance)

    if (pUnkOuter)
    	return ResultFromScode(CLASS_E_NOAGGREGATION);

    // Create the main shell extension object.  The shell will then call
    // QueryInterface with IID_IShellExtInit--this is how shell extensions are
    // initialized.

    LPCNWHOODCONTEXTMENU pShellExt = new CNWHoodContextMenu();  // Create the CNWHoodContextMenu object

    if (NULL == pShellExt)
    	return ResultFromScode(E_OUTOFMEMORY);

    //
    // We set the reference count of CNWHoodContextMenu to one at initialization.
    // Hence, we can call Release() after QueryInterface.
    // So, if QueryInterface failed, Release will free the object.
    //

    HRESULT hr = pShellExt->QueryInterface(riid, ppvObj);
    pShellExt->Release();

    return hr;
}

STDMETHODIMP CNWHoodContextMenuClassFactory::LockServer(BOOL fLock)
{
    return NOERROR;
}

//---------------------------------------------------------------------------
// CNWHoodContextMenu
//---------------------------------------------------------------------------

CNWHoodContextMenu::CNWHoodContextMenu()
{
    _cRef = 1L;
    _pDataObj = NULL;

    InterlockedIncrement( &g_cRefThisDll );

#if DBG
	wsprintf( szDebugStr,L"CNWHoodContextMenu::CNWHoodContextMenu(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}

CNWHoodContextMenu::~CNWHoodContextMenu()
{
    if (_pDataObj)
        _pDataObj->Release();

    InterlockedDecrement( &g_cRefThisDll );

#if DBG
	wsprintf( szDebugStr,L"CNWHoodContextMenu::~CNWHoodContextMenu(), g_cRefThisDll = %d\r\n", g_cRefThisDll);
	ODS( szDebugStr );
#endif
}

STDMETHODIMP CNWHoodContextMenu::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellExtInit) || IsEqualIID(riid, IID_IUnknown))
    {
    	*ppv = (LPSHELLEXTINIT)this;
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        *ppv = (LPCONTEXTMENU)this;
    }

    if (*ppv)
    {
        AddRef();

        return NOERROR;
    }

	return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CNWHoodContextMenu::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CNWHoodContextMenu::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;

    return 0L;
}

//
//  FUNCTION: CNWHoodContextMenu::Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY)
//
//  PURPOSE: Called by the shell when initializing a context menu or property
//           sheet extension.
//
//  PARAMETERS:
//    pIDFolder - Specifies the parent folder
//    pDataObj  - Spefifies the set of items selected in that folder.
//    hRegKey   - Specifies the type of the focused item in the selection.
//
//  RETURN VALUE:
//
//    NOERROR in all cases.
//
//  COMMENTS:   Note that at the time this function is called, we don't know
//              (or care) what type of shell extension is being initialized.
//              It could be a context menu or a property sheet.
//

STDMETHODIMP CNWHoodContextMenu::Initialize( LPCITEMIDLIST pIDFolder,
                                             LPDATAOBJECT pDataObj,
                                             HKEY hRegKey)
{
    // We do not need the registry handle so ignore it.

    // Initialize can be called more than once

    if (_pDataObj)
    	_pDataObj->Release();

    // Duplicate the object pointer

    if (pDataObj)
    {
    	_pDataObj = pDataObj;
    	pDataObj->AddRef();
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwshext.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshext.h

Abstract:

    All C++ classes used in implementing shell extensions.

Author:

    Yi-Hsin Sung      (yihsins)     20-Oct-1995

Revision History:

--*/

#ifndef _NWSHEXT_H_
#define _NWSHEXT_H_

BOOL
GetNetResourceFromShell(
    LPDATAOBJECT  pDataObj,
    LPNETRESOURCE pBuffer,
    UINT          dwBufferSize
);

/******************************************************************************/

// this class factory object creates context menu handlers for netware objects
class CNWObjContextMenuClassFactory : public IClassFactory
{
protected:
    ULONG   _cRef;

public:
    CNWObjContextMenuClassFactory();
    ~CNWObjContextMenuClassFactory();

    // IUnknown members

    STDMETHODIMP          QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)  AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // IClassFactory members

    STDMETHODIMP          CreateInstance( LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP          LockServer( BOOL);

};

typedef CNWObjContextMenuClassFactory *LPCNWOBJCONTEXTMENUCLASSFACTORY;

typedef struct _NWMENUITEM
{
    UINT idResourceString;
    UINT idCommand;
} NWMENUITEM, *LPNWMENUITEM;

// this is the actual context menu handler for netware objects
class CNWObjContextMenu : public IContextMenu,
                                 IShellExtInit,
                                 IShellPropSheetExt
{
protected:
    ULONG        _cRef;
    LPDATAOBJECT _pDataObj;
    NWMENUITEM  *_pIdTable;
    BYTE         _buffer[MAX_ONE_NETRES_SIZE];

public:
    BOOL         _fGotClusterInfo;
    DWORD        _dwTotal;
    DWORD        _dwFree;

    DWORD       *_paHelpIds;

    CNWObjContextMenu();
    ~CNWObjContextMenu();

    // IUnknown members

    STDMETHODIMP            QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IShellContextMenu members

    STDMETHODIMP            QueryContextMenu( HMENU hMenu,
                                              UINT indexMenu,
                                              UINT idCmdFirst,
                                              UINT idCmdLast,
                                              UINT uFlags);

    STDMETHODIMP            InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi);

    STDMETHODIMP            GetCommandString( UINT_PTR idCmd,
                                              UINT uFlags,
                                              UINT FAR *reserved,
                                              LPSTR pszName,
                                              UINT cchMax);

    // IShellExtInit methods

    STDMETHODIMP            Initialize( LPCITEMIDLIST pIDFolder,
                                        LPDATAOBJECT pDataObj,
                                        HKEY hKeyID);

    // IShellPropSheetExt methods

    STDMETHODIMP            AddPages( LPFNADDPROPSHEETPAGE lpfnAddPage,
                                      LPARAM lParam);

    STDMETHODIMP            ReplacePage( UINT uPageID,
                                         LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                         LPARAM lParam);

    VOID                    FillAndAddPage( LPFNADDPROPSHEETPAGE lpfnAddPage,
                                            LPARAM  lParam,
                                            DLGPROC pfnDlgProc,
                                            LPWSTR  pszTemplate );

    // Other misc methods

    LPNETRESOURCE QueryNetResource()
    {  return ( LPNETRESOURCE ) _buffer; }

};
typedef CNWObjContextMenu *LPCNWOBJCONTEXTMENU;

/******************************************************************************/

// this class factory object creates context menu handlers for netware folders
class CNWFldContextMenuClassFactory : public IClassFactory
{
protected:
    ULONG   _cRef;

public:
    CNWFldContextMenuClassFactory();
    ~CNWFldContextMenuClassFactory();

    // IUnknown members

    STDMETHODIMP          QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)  AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // IClassFactory members

    STDMETHODIMP          CreateInstance( LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP          LockServer( BOOL);

};

typedef CNWFldContextMenuClassFactory *LPCNWFLDCONTEXTMENUCLASSFACTORY;

// this is the actual context menu handler for netware objects
class CNWFldContextMenu : public IContextMenu,
                                 IShellExtInit
{
protected:
    ULONG        _cRef;
    LPDATAOBJECT _pDataObj;
    BYTE         _buffer[MAX_ONE_NETRES_SIZE];

public:
    CNWFldContextMenu();
    ~CNWFldContextMenu();

    // IUnknown members

    STDMETHODIMP            QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IShellContextMenu members

    STDMETHODIMP            QueryContextMenu( HMENU hMenu,
                                              UINT indexMenu,
                                              UINT idCmdFirst,
                                              UINT idCmdLast,
                                              UINT uFlags);

    STDMETHODIMP            InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi);

    STDMETHODIMP            GetCommandString( UINT_PTR idCmd,
                                              UINT uFlags,
                                              UINT FAR *reserved,
                                              LPSTR pszName,
                                              UINT cchMax);

    // IShellExtInit methods

    STDMETHODIMP            Initialize( LPCITEMIDLIST pIDFolder,
                                        LPDATAOBJECT pDataObj,
                                        HKEY hKeyID);

    BOOL                    IsNetWareObject( VOID );
    HRESULT                 GetFSObject( LPWSTR pszPath, UINT cbMaxPath );

};
typedef CNWFldContextMenu *LPCNWFLDCONTEXTMENU;

// this class factory object creates context menu handlers
// for Network Neighborhood

class CNWHoodContextMenuClassFactory : public IClassFactory
{
protected:
    ULONG   _cRef;

public:
    CNWHoodContextMenuClassFactory();
    ~CNWHoodContextMenuClassFactory();

    // IUnknown members

    STDMETHODIMP          QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)  AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // IClassFactory members

    STDMETHODIMP          CreateInstance( LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP          LockServer( BOOL);

};

typedef CNWHoodContextMenuClassFactory *LPCNWHOODCONTEXTMENUCLASSFACTORY;

// this is the actual context menu handler for network neighborhood
class CNWHoodContextMenu : public IContextMenu,
                                  IShellExtInit
{
protected:
    ULONG        _cRef;
    LPDATAOBJECT _pDataObj;

public:
    CNWHoodContextMenu();
    ~CNWHoodContextMenu();

    // IUnknown members

    STDMETHODIMP            QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IShellContextMenu members

    STDMETHODIMP            QueryContextMenu( HMENU hMenu,
                                              UINT indexMenu,
                                              UINT idCmdFirst,
                                              UINT idCmdLast,
                                              UINT uFlags);

    STDMETHODIMP            InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi);

    STDMETHODIMP            GetCommandString( UINT_PTR idCmd,
                                              UINT uFlags,
                                              UINT FAR *reserved,
                                              LPSTR pszName,
                                              UINT cchMax);

    // IShellExtInit methods

    STDMETHODIMP            Initialize( LPCITEMIDLIST pIDFolder,
                                        LPDATAOBJECT pDataObj,
                                        HKEY hKeyID);

};
typedef CNWHoodContextMenu *LPCNWHOODCONTEXTMENU;


#endif // _NWSHEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwshmenu.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshmenu.cxx

Abstract:

    This module implements the IContextMenu member functions necessary to support
    the context menu of NetWare shell extension.

Author:

    Yi-Hsin Sung (yihsins)  25-Oct-1995

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#define  DONT_WANT_SHELLDEBUG
#include <shlobjp.h>
#include <winnetwk.h>
#include <ntddnwfs.h>
//extern "C"
//{
#include "nwshrc.h"
#include "nwwks.h"
#include "nwutil.h"
//}

#include "nwshcmn.h"
#include "nwshext.h"

#define MAX_VERB_SIZE          128
#define MAX_SHELL_IDLIST_SIZE  512

BOOL g_cfNetResource = 0;  // Clipboard format
BOOL g_cfIDList = 0;

NWMENUITEM aServerVerbs[]    = { { IDO_VERB_WHOAMI, 0 },
                                 { IDO_VERB_LOGOUT, 0 },
                                 { IDO_VERB_ATTACHAS, 0 },
                                 { 0, 0 } };

NWMENUITEM aDSVerbs[]        = { { IDO_VERB_TREEWHOAMI, 0 },
                                 // { IDO_VERB_SETDEFAULTCONTEXT, 0 },
                                 { 0, 0 } };

NWMENUITEM aDSTreeVerbs[]    = { { IDO_VERB_TREEWHOAMI, 0 },
                                 { 0, 0 } };

NWMENUITEM aGlobalVerbs[]    = { { IDO_VERB_GLOBALWHOAMI, 0 },
                                 { 0, 0 } };

NWMENUITEM aDirectoryVerbs[] = { { IDO_VERB_MAPNETWORKDRIVE, 0 },
                                 { 0, 0 } };


NWMENUITEM aHoodVerbs[]      = { { IDO_VERB_GLOBALWHOAMI, 0 },
                                 { 0, 0 } };


HRESULT
InsertCommandsArray( HMENU hMenu,
                     UINT indexMenu,
                     UINT idCmdFirst,
                     LPNWMENUITEM aVerbs );

UINT
LookupCommand( LPNWMENUITEM aVerbs,
               LPCSTR pszCmd );

UINT
LookupResource( LPNWMENUITEM aVerbs,
                UINT uiResourceOffset );

UINT WINAPI
HIDA_GetIDList( LPIDA hida,
                UINT i,
                LPITEMIDLIST pidlOut,
                UINT cbMax);

//
//  FUNCTION: CNWObjContextMenu::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT)
//
//  PURPOSE: Called by the shell just before the context menu is displayed.
//           This is where you add your specific menu items.
//
//  PARAMETERS:
//    hMenu      - Handle to the context menu
//    indexMenu  - Index of where to begin inserting menu items
//    idCmdFirst - Lowest value for new menu ID's
//    idCmtLast  - Highest value for new menu ID's
//    uFlags     - Specifies the context of the menu event
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWObjContextMenu::QueryContextMenu( HMENU hMenu,
                                                  UINT indexMenu,
                                                  UINT idCmdFirst,
                                                  UINT idCmdLast,
                                                  UINT uFlags )
{
    HRESULT hres;
    LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;

    if ( !::GetNetResourceFromShell( _pDataObj,
                                     pNetRes,
                                     sizeof( _buffer )))
    {
        // We cannot get the net resource of the selected object.

        // Must return number of menu items we added.
        // Nothing added here.
        return ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 0 ));
    }

    // First, add a menu separator
    if ( InsertMenu( hMenu, indexMenu, MF_SEPARATOR | MF_BYPOSITION, 0, NULL))
        indexMenu++;

    // Next, add menu items depending on display types
    switch ( pNetRes->dwDisplayType )
    {
        case RESOURCEDISPLAYTYPE_ROOT:
        case RESOURCEDISPLAYTYPE_NETWORK:
            hres = InsertCommandsArray( hMenu, indexMenu,
                                        idCmdFirst, _pIdTable = aGlobalVerbs );

            break;

        case RESOURCEDISPLAYTYPE_TREE:
            hres = InsertCommandsArray( hMenu, indexMenu,
                                        idCmdFirst, _pIdTable = aDSTreeVerbs );
            break;

        case RESOURCEDISPLAYTYPE_NDSCONTAINER:
            hres = InsertCommandsArray( hMenu, indexMenu,
                                        idCmdFirst, _pIdTable = aDSVerbs );
            break;

        case RESOURCEDISPLAYTYPE_SERVER:
        {
            // Do we need to check if the server name is local
            // and disallow operation???

            hres = InsertCommandsArray( hMenu, indexMenu,
                                        idCmdFirst, _pIdTable = aServerVerbs );

            if (!SUCCEEDED(hres))
                break;

            LPBYTE pBuffer = NULL;
            DWORD  EntriesRead = 0;
            DWORD_PTR  ResumeKey = 0;
            WCHAR  szServerName[MAX_PATH + 1];

            NwExtractServerName( pNetRes->lpRemoteName, szServerName );

            // See if we are connected.
            DWORD err = NwGetConnectionStatus( szServerName,
                                               &ResumeKey,
                                               &pBuffer,
                                               &EntriesRead );

            if ( err == NO_ERROR && EntriesRead > 0 )
            {
                PCONN_STATUS pConnStatus = (PCONN_STATUS) pBuffer;

                ASSERT( EntriesRead == 1 );

                if ( pConnStatus->fPreferred )
                {
                    // This is a implicit preferred server connection
                    // so, don't show the connection and don't let the user
                    // logout of it since rdr doesn't allow it.
                    ::EnableMenuItem( hMenu,
                                      LookupResource( aServerVerbs,
                                                      IDO_VERB_LOGOUT),
                                      MF_GRAYED | MF_BYCOMMAND);

                }
                else if ( pConnStatus->fNds )
                {
                    BOOL fInDefaultTree = FALSE;

                    err = NwIsServerInDefaultTree( pNetRes->lpRemoteName, &fInDefaultTree );

                    if ( (err == NO_ERROR) && fInDefaultTree )
                    {
                        // NDS connection and in the default tree, disable the Attach As button
                        ::EnableMenuItem( hMenu,
                                          LookupResource( aServerVerbs,
                                                          IDO_VERB_ATTACHAS),
                                          MF_GRAYED | MF_BYCOMMAND );
                    }
                }
            }
            else
            {
                // If we are not attached or if error occurred when getting
                // connection status, then disable the Logout button.
                ::EnableMenuItem( hMenu,
                                  LookupResource( aServerVerbs,
                                                  IDO_VERB_LOGOUT),
                                  MF_GRAYED | MF_BYCOMMAND);
            }

            if ( pBuffer != NULL )
            {
                LocalFree( pBuffer );
                pBuffer = NULL;
            }
            break;
        }

        default:
            // Must return number of menu items we added.
            // Nothing added here.
            hres = ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 0 ));
            break;

    }

    return hres;
}

//
//  FUNCTION: CNWObjContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWObjContextMenu::InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi )
{
    HRESULT hres = ResultFromScode(E_INVALIDARG);
    UINT idCmd = LookupCommand( _pIdTable , lpcmi->lpVerb );

    if ( !idCmd )
        return hres;

    LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;

    switch ( idCmd )
    {
        case IDO_VERB_GLOBALWHOAMI:
            hres = NWUIGlobalWhoAmI( lpcmi->hwnd );
            break;

        case IDO_VERB_TREEWHOAMI:
            hres = NWUIWhoAmI( lpcmi->hwnd, pNetRes );
            break;

#if 0
        case IDO_VERB_SETDEFAULTCONTEXT:
            hres = NWUISetDefaultContext( lpcmi->hwnd, pNetRes );
            break;
#endif

        case IDO_VERB_WHOAMI:
            hres = NWUIWhoAmI( lpcmi->hwnd, pNetRes );
            break;

        case IDO_VERB_LOGOUT:
        {
            BOOL fDisconnected = FALSE;
            hres = NWUILogOut( lpcmi->hwnd, pNetRes, &fDisconnected );
            if ( hres == NOERROR && fDisconnected )
            {
                // Logout is successful, need to notify shell

                FORMATETC fmte = { g_cfIDList ? g_cfIDList
                                   : (g_cfIDList=RegisterClipboardFormat( CFSTR_SHELLIDLIST)),
                                   (DVTARGETDEVICE FAR *)NULL,
                                   DVASPECT_CONTENT,
                                   -1,
                                   TYMED_HGLOBAL };
                STGMEDIUM medium;

                hres = _pDataObj->GetData( &fmte, &medium);

                if (SUCCEEDED(hres))
                {
                    // We got pointer to IDList
                    LPIDA pida = (LPIDA)GlobalLock(medium.hGlobal);

                    if ( pida )
                    {
                        BYTE  BufIDList[MAX_SHELL_IDLIST_SIZE];
                        LPITEMIDLIST pidl = (LPITEMIDLIST) BufIDList;

                        if ( pidl )
                        {
                            // Convert IDA to IDList for this call
                            HIDA_GetIDList( pida,
                                            0,              // One object should present
                                            pidl ,
                                            MAX_SHELL_IDLIST_SIZE);

                            // Call SHchangeNotify
                            g_pFuncSHChangeNotify( SHCNE_SERVERDISCONNECT,
                                                   SHCNF_IDLIST,
                                                   pidl,
                                                   NULL);
                        }

                        GlobalUnlock(medium.hGlobal);
                    }
                }

            }
            break;
        }

        case IDO_VERB_ATTACHAS:
            hres = NWUIAttachAs( lpcmi->hwnd, pNetRes );
            break;
    }

    return hres;
}


//
//  FUNCTION: CNWObjContextMenu::GetCommandString( UINT, UINT, UINT FAR *, LPSTR, UINT )
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWObjContextMenu::GetCommandString( UINT_PTR idCmd,
                                                  UINT uFlags,
                                                  UINT FAR *reserved,
                                                  LPSTR pszName,
                                                  UINT cchMax )
{
    if ( uFlags == GCS_HELPTEXT && _pIdTable != NULL )
    {
        ::LoadString( ::hmodNW,
                      IDS_VERBS_HELP_BASE + _pIdTable[idCmd].idResourceString,
                      (LPWSTR) pszName,
                      cchMax );

        return NOERROR;
    }

    return E_NOTIMPL;
}

//
//  FUNCTION: CNWFldContextMenu::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT)
//
//  PURPOSE: Called by the shell just before the context menu is displayed.
//           This is where you add your specific menu items.
//
//  PARAMETERS:
//    hMenu      - Handle to the context menu
//    indexMenu  - Index of where to begin inserting menu items
//    idCmdFirst - Lowest value for new menu ID's
//    idCmtLast  - Highest value for new menu ID's
//    uFlags     - Specifies the context of the menu event
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWFldContextMenu::QueryContextMenu( HMENU hMenu,
                                                  UINT indexMenu,
                                                  UINT idCmdFirst,
                                                  UINT idCmdLast,
                                                  UINT uFlags )
{
    UINT idCmd = idCmdFirst;

    if ( IsNetWareObject() )
    {
        WCHAR szFullPath[MAX_PATH+1];

        if ( GetFSObject( szFullPath, sizeof( szFullPath )) == NOERROR )
        {
            BOOL fUNC = FALSE;

            // Check if the name at least contains the "\\server\share\dir"
            // We need to add "Map Network Drive" menu in this case.
            if (( szFullPath[0] == L'\\') && ( szFullPath[1] == L'\\'))
            {
                LPWSTR pszLastSlash = wcschr( szFullPath + 2, L'\\');
                if ( pszLastSlash )
                    pszLastSlash = wcschr( pszLastSlash+1, L'\\');

                if ( pszLastSlash != NULL )
                    fUNC = TRUE;
            }

            if ( fUNC )
            {
                LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;
                WCHAR szProvider[MAX_PATH+1];

                // Build a net resource that can be used to connect

                // store the provider name first
                wcscpy( szProvider, pNetRes->lpProvider );

                // zero out the memory cause it is filled by IsNetWareObject
                RtlZeroMemory( pNetRes, sizeof(NETRESOURCE));

                pNetRes->dwType = RESOURCETYPE_DISK;
                pNetRes->lpRemoteName = (LPWSTR) ((DWORD_PTR)pNetRes + sizeof(NETRESOURCE));
                wcscpy( pNetRes->lpRemoteName, szFullPath );

                pNetRes->lpProvider = (LPWSTR) ((DWORD_PTR)pNetRes->lpRemoteName + (wcslen(szFullPath)+1)*sizeof(WCHAR));
                wcscpy( pNetRes->lpProvider, szProvider );

                if ( InsertMenu(hMenu, indexMenu, MF_SEPARATOR | MF_BYPOSITION, 0, NULL))
                {
                    indexMenu++;
                }

                return InsertCommandsArray( hMenu, indexMenu,
                                            idCmdFirst, aDirectoryVerbs );
            }
        }
    }

    // Must return number of menu items we added.
    // Nothing added here.
    return ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 0 ));

}

//
//  FUNCTION: CNWFldContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWFldContextMenu::InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi )
{
    HRESULT hres = ResultFromScode(E_INVALIDARG);
    UINT idCmd = LookupCommand( aDirectoryVerbs , lpcmi->lpVerb );

    if ( !idCmd )
        return hres;

    LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;

    switch ( idCmd )
    {
        case IDO_VERB_MAPNETWORKDRIVE:
            hres = NWUIMapNetworkDrive( lpcmi->hwnd, pNetRes );
            break;
    }

    return hres;
}


//
//  FUNCTION: CNWFldContextMenu::GetCommandString( UINT, UINT, UINT FAR *, LPSTR, UINT )
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWFldContextMenu::GetCommandString( UINT_PTR idCmd,
                                                  UINT uFlags,
                                                  UINT FAR *reserved,
                                                  LPSTR pszName,
                                                  UINT cchMax )
{
    if ( uFlags == GCS_HELPTEXT )
    {
        ::LoadString( ::hmodNW,
                      IDS_VERBS_HELP_BASE + IDO_VERB_MAPNETWORKDRIVE,
                      (LPWSTR) pszName,
                      cchMax );

        return NOERROR;
    }

    return E_NOTIMPL;
}

//
// Method checks if the selected object belongs the netware provider
//
BOOL CNWFldContextMenu::IsNetWareObject( VOID )
{
    LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;

    if ( !::GetNetResourceFromShell( _pDataObj,
                                     pNetRes,
                                     sizeof(_buffer)))
    {
        // Cannot get the NETRESOURCE of the selected object,
        // hence assume that the object is not a NetWare object.
        return FALSE;
    }

    if (  ( pNetRes->lpProvider != NULL )
       && ( _wcsicmp( pNetRes->lpProvider, g_szProviderName ) == 0 )
       )
    {
        return TRUE;
    }

    return FALSE;
}

//
// Method obtains file system name associated with selected shell object
//
HRESULT CNWFldContextMenu::GetFSObject( LPWSTR pszPath, UINT cbMaxPath )
{
    FORMATETC fmte = { CF_HDROP,
                       (DVTARGETDEVICE FAR *) NULL,
                       DVASPECT_CONTENT,
                       -1,
                       TYMED_HGLOBAL };

    STGMEDIUM medium;
    HRESULT hres = _pDataObj->GetData( &fmte, &medium);

    if (SUCCEEDED(hres))
    {
        if ( g_pFuncSHDragQueryFile )
        {
            HDROP hdrop = (HDROP) medium.hGlobal;
            UINT cFiles = (*g_pFuncSHDragQueryFile)( hdrop, (UINT)-1, NULL, 0 );

            (*g_pFuncSHDragQueryFile)( hdrop, 0, pszPath, cbMaxPath );

            ODS(L"CNWFldContextMenu::GetFSObject()\n");
            ODS( pszPath );
            ODS(L"\n");
        }

        //
        // HACK: We are supposed to call ReleaseStgMedium. This is a temporary
        //  hack until OLE 2.01 for Chicago is released.
        //
        if (medium.pUnkForRelease)
        {
            medium.pUnkForRelease->Release();
        }
        else
        {
            GlobalFree(medium.hGlobal);
        }
    }

    return hres;
}


//  FUNCTION: CNWHoodContextMenu::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT)
//
//  PURPOSE: Called by the shell just before the context menu is displayed.
//           This is where you add your specific menu items.
//
//  PARAMETERS:
//    hMenu      - Handle to the context menu
//    indexMenu  - Index of where to begin inserting menu items
//    idCmdFirst - Lowest value for new menu ID's
//    idCmtLast  - Highest value for new menu ID's
//    uFlags     - Specifies the context of the menu event
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWHoodContextMenu::QueryContextMenu( HMENU hMenu,
                                                   UINT indexMenu,
                                                   UINT idCmdFirst,
                                                   UINT idCmdLast,
                                                   UINT uFlags )
{
    // First, insert a menu separator
    if ( InsertMenu(hMenu, indexMenu, MF_SEPARATOR | MF_BYPOSITION, 0, NULL))
    {
        indexMenu++;
    }

    // Then, insert the verbs
    return InsertCommandsArray( hMenu, indexMenu,
                                idCmdFirst, aHoodVerbs );
}

//
//  FUNCTION: CNWHoodContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWHoodContextMenu::InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi )
{
    HRESULT hres = ResultFromScode(E_INVALIDARG);
    UINT idCmd = LookupCommand( aHoodVerbs , lpcmi->lpVerb );

    if ( !idCmd )
        return hres;

    switch ( idCmd )
    {
        case IDO_VERB_GLOBALWHOAMI:
            hres = NWUIGlobalWhoAmI( lpcmi->hwnd );
            break;
    }

    return hres;
}


//
//  FUNCTION: CNWHoodContextMenu::GetCommandString( UINT, UINT, UINT FAR *, LPSTR, UINT)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWHoodContextMenu::GetCommandString( UINT_PTR idCmd,
                                                   UINT uFlags,
                                                   UINT FAR *reserved,
                                                   LPSTR pszName,
                                                   UINT cchMax )
{
    if ( uFlags == GCS_HELPTEXT )
    {
        ::LoadString( ::hmodNW,
                      IDS_VERBS_HELP_BASE + IDO_VERB_GLOBALWHOAMI,
                      (LPWSTR) pszName,
                      cchMax );

        return NOERROR;
    }

    return E_NOTIMPL;
}

//
// Method gets the NETRESOURCE of the selected object
//
BOOL GetNetResourceFromShell( LPDATAOBJECT  pDataObj,
                              LPNETRESOURCE pNetRes,
                              UINT          dwBufferSize )
{
    FORMATETC fmte = { g_cfNetResource ? g_cfNetResource
                       : (g_cfNetResource=RegisterClipboardFormat(CFSTR_NETRESOURCES)),
                       (DVTARGETDEVICE FAR *) NULL,
                       DVASPECT_CONTENT,
                       -1,
                       TYMED_HGLOBAL };

    STGMEDIUM medium;
    UINT      cItems;

    if ( pNetRes == NULL )
        return FALSE;

    memset( pNetRes, 0, dwBufferSize );

    if ( !g_pFuncSHGetNetResource )   // Not loaded
        return FALSE;

    HRESULT hres = pDataObj->GetData( &fmte, &medium );

    if (!SUCCEEDED(hres))
        return FALSE;

    HNRES hnres = medium.hGlobal;

    // Get the number of selected items
    cItems = (*g_pFuncSHGetNetResource)( hnres, (UINT)-1, NULL, 0);

    if ( cItems == 0 )   // Nothing selected
        return FALSE;

    // Get the NETRESOURCE of the first item
    (*g_pFuncSHGetNetResource)( hnres, 0, pNetRes, dwBufferSize);

#if DBG
    WCHAR szTemp[32];
    wsprintf(szTemp, L"DisplayType = %d\n", pNetRes->dwDisplayType );

    ODS(L"\n**** GetNetResourceFromShell ***\n");
    ODS(pNetRes->lpProvider );
    ODS(L"\n");
    ODS(pNetRes->lpRemoteName );
    ODS(L"\n");
    ODS(szTemp );
    ODS(L"\n\n");
#endif

    //
    // HACK: We are supposed to call ReleaseStgMedium. This is a temporary
    //  hack until OLE 2.01 for Chicago is released.
    //
    if (medium.pUnkForRelease)
    {
        medium.pUnkForRelease->Release();
    }
    else
    {
        GlobalFree(medium.hGlobal);
    }

    return TRUE;
}

//-------------------------------------------------------------------//

HRESULT InsertCommandsArray( HMENU hMenu,
                             UINT  indexMenu,
                             UINT  idCmdFirst,
                             LPNWMENUITEM aVerbs )
{
    UINT    idNewCmdFirst = idCmdFirst;
    WCHAR   szVerb[MAX_VERB_SIZE];

    for ( int i = 0; aVerbs[i].idResourceString ; i++)
    {
        if ( ::LoadString( ::hmodNW,
                           aVerbs[i].idResourceString + IDS_VERBS_BASE,
                           szVerb,
                           sizeof(szVerb)/sizeof(szVerb[0])))
        {
            if (::InsertMenu( hMenu,
                              indexMenu,
                              MF_STRING | MF_BYPOSITION,
                              idNewCmdFirst,
                              szVerb))
            {
                // Add command id to the array
                aVerbs[i].idCommand = idNewCmdFirst;

                // Update command id and index
                idNewCmdFirst++;
                if (indexMenu != (UINT)-1)
                    indexMenu++;
            }
        }
    }

    return ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS,
                           FACILITY_NULL,
                           (USHORT)(idNewCmdFirst-idCmdFirst)));
}

UINT LookupCommand( LPNWMENUITEM aVerbs, LPCSTR pszCmd )
{
    if ((UINT_PTR)pszCmd > 0xFFFF)
    {
        // Possible that shell will use string commands, but unlikely

        WCHAR szVerb[MAX_VERB_SIZE];
        for ( int i=0; aVerbs[i].idResourceString; i++)
        {
            if ( ::LoadString( ::hmodNW,
                               aVerbs[i].idResourceString + IDS_VERBS_BASE,
                               szVerb,
                               sizeof(szVerb)/sizeof(szVerb[0])))
            {
                if( ::lstrcmpi( (LPCWSTR) pszCmd, szVerb) == 0)
                    return( aVerbs[i].idResourceString);
            }
        }

        return 0;
    }
    else
    {
        return( aVerbs[LOWORD(pszCmd)].idResourceString);
    }
}

UINT LookupResource( LPNWMENUITEM aVerbs, UINT uiResourceOffset )
{
    for ( int i = 0; aVerbs[i].idResourceString; i++ )
    {
        if ( aVerbs[i].idResourceString == uiResourceOffset )
            return aVerbs[i].idCommand;
    }

    return 0;
}

//-------------------------------------------------------------------//

#define _ILSkip(pidl, cb)   ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)       _ILSkip(pidl, (pidl)->mkid.cb)

#define HIDA_GetPIDLFolder(pida)    (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])
#define HIDA_GetPIDLItem(pida, i)   (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])

static
UINT WINAPI MyILGetSize(LPCITEMIDLIST pidl)
{
    UINT cbTotal = 0;
    if (pidl)
    {
        cbTotal += sizeof(pidl->mkid.cb);   // Null terminator
        while (pidl->mkid.cb)
        {
            cbTotal += pidl->mkid.cb;
            pidl = _ILNext(pidl);
        }
    }

    return cbTotal;
}

UINT WINAPI HIDA_GetIDList( LPIDA hida, UINT i, LPITEMIDLIST pidlOut, UINT cbMax)
{
    LPCITEMIDLIST pidlFolder = HIDA_GetPIDLFolder((LPIDA)hida);
    LPCITEMIDLIST pidlItem   = HIDA_GetPIDLItem((LPIDA)hida, i);

    UINT cbFolder  = MyILGetSize(pidlFolder)-sizeof(USHORT);
    UINT cbItem = MyILGetSize(pidlItem);

    if (cbMax < cbFolder+cbItem)
    {
        if (pidlOut)
            pidlOut->mkid.cb = 0;
    }
    else
    {
        memmove(pidlOut, pidlFolder, cbFolder);
        memmove(((LPBYTE)pidlOut)+cbFolder, pidlItem, cbItem);
    }

    return (cbFolder+cbItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwshmisc.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshmisc.cxx

Abstract:

    This module implements misc methods used in the shell extension classes.

Author:

    Yi-Hsin Sung (yihsins)  25-Oct-1995

--*/

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#define  DONT_WANT_SHELLDEBUG
#include <shlobjp.h>

#include "nwshcmn.h"

#define MAX_RESOURCE_STRING_LENGTH  256

VOID HideControl( HWND hwndDlg, WORD wID )
{
    HWND hwndTmp = ::GetDlgItem( hwndDlg, wID );
    ::EnableWindow( hwndTmp, FALSE );
    ::ShowWindow( hwndTmp, FALSE );
}

VOID UnHideControl( HWND hwndDlg, WORD wID )
{
    HWND hwndTmp = ::GetDlgItem( hwndDlg, wID );
    ::EnableWindow( hwndTmp, TRUE );
    ::ShowWindow( hwndTmp, TRUE );
}

VOID EnableDlgItem( HWND hwndDlg, WORD wID, BOOL fEnable)
{
    HWND hwndTmp = ::GetDlgItem( hwndDlg, wID );

    ::EnableWindow( hwndTmp, fEnable);
}

/*
 * LoadErrorPrintf
 * -------------
 *
 * Uses normal printf style format string
 */
DWORD
LoadMsgErrorPrintf(
    LPWSTR *ppszMessage,
    UINT   uiMsg,
    DWORD  errNum
)
{
    DWORD  nLen = 0;
    DWORD  err = NO_ERROR;
    LPWSTR pszError = NULL;
    WCHAR  szError[20];

    *ppszMessage = NULL;

    //
    // Try to get the error string associated with the given number
    // from the system. If we cannot find the string, then
    // just show the number.
    //

    nLen = ::FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM
                            | FORMAT_MESSAGE_IGNORE_INSERTS
                            | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,        // ignored
                            errNum,      // Message resource id
                            0,           // Language id
                            (LPWSTR) &pszError,
                                         // Return pointer to formatted text
                            256,         // Min.length
                            NULL );

    if ( nLen == 0 || pszError == NULL )
    {
        wsprintf( szError, L"%d", errNum );
    }

    err = LoadMsgPrintf( ppszMessage, uiMsg, pszError? pszError : szError );

    if ( pszError )
        ::LocalFree( pszError );

    return err;
}

/*
 * LoadMsgPrintf
 * -------------
 *
 * Uses normal printf style format string
 */
DWORD
LoadMsgPrintf(
    LPWSTR *ppszMessage,
    UINT    uiMsg,
    ...
    )
{
    WCHAR    szMessage[512];
    DWORD    err = NO_ERROR;
    DWORD    nLen = 0;
    va_list  start;

    va_start( start, uiMsg );

    *ppszMessage = NULL;

    if ( ::LoadString( ::hmodNW, uiMsg, szMessage,
                       sizeof(szMessage)/sizeof(szMessage[0])))
    {
        nLen = ::FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                szMessage,
                                0,           // Message resource id, ignored
                                0,           // Language id
                                (LPWSTR) ppszMessage,
                                             // Return pointer to formatted text
                                256,         // Min.length
                                &start );

        if ( nLen == 0 || *ppszMessage == NULL )
            err = GetLastError();

    }

    va_end(start);

    return err;
}

/*
 * MsgBoxErrorPrintf
 * ------------
 *
 * Message box routine
 *
 */
DWORD
MsgBoxErrorPrintf(
    HWND   hwnd,
    UINT   uiMsg,
    UINT   uiTitle,
    UINT   uiFlags,
    DWORD  errNum,
    LPWSTR pszInsertStr
    )
{
    DWORD  nLen = 0;
    DWORD  err = NO_ERROR;
    LPWSTR pszError = NULL;
    WCHAR  szError[20];

    nLen = ::FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM
                            | FORMAT_MESSAGE_IGNORE_INSERTS
                            | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,        // ignored
                            errNum,      // Message resource id
                            0,           // Language id
                            (LPWSTR) &pszError,
                                         // Return pointer to formatted text
                            256,         // Min.length
                            NULL );

    if ( nLen == 0 || pszError == NULL )
        wsprintf( szError, L"%d", errNum );

    if ( pszInsertStr )
    {
        err = MsgBoxPrintf( hwnd, uiMsg, uiTitle, uiFlags,
                            pszError? pszError : szError, pszInsertStr );
    }
    else
    {
        err = MsgBoxPrintf( hwnd, uiMsg, uiTitle, uiFlags,
                            pszError? pszError : szError );
    }

    if ( pszError )
        ::LocalFree( pszError );

    return err;

}


/*
 * MsgBoxPrintf
 * ------------
 *
 * Message box routine
 *
 */
DWORD
MsgBoxPrintf(
    HWND hwnd,
    UINT uiMsg,
    UINT uiTitle,
    UINT uiFlags,
    ...
    )
{
    WCHAR  szTitle[MAX_RESOURCE_STRING_LENGTH];
    WCHAR  szMessage[MAX_RESOURCE_STRING_LENGTH];
    LPWSTR lpFormattedMessage = NULL;
    DWORD  err = NO_ERROR;
    va_list start;

    va_start(start,uiFlags);

    if (  ::LoadString( ::hmodNW, uiMsg, szMessage, sizeof(szMessage)/sizeof(szMessage[0]))
       && ::LoadString( ::hmodNW, uiTitle, szTitle, sizeof(szTitle)/sizeof(szTitle[0]))
       )
    {
        DWORD nLen = ::FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                      | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                      szMessage,
                                      0,       // Resource Id, ignored
                                      NULL,    // Language Id, ignored
                                      (LPWSTR) &lpFormattedMessage,
                                               // Return pointer to formatted text
                                      256,     // Min.length
                                      &start );

        if ( nLen == 0 || lpFormattedMessage == NULL )
        {
            err  = GetLastError();
            goto CleanExit;
        }

        err = ::MessageBox( hwnd,
                            lpFormattedMessage,
                            szTitle,
                            uiFlags );

        ::LocalFree( lpFormattedMessage );
    }

CleanExit:

    va_end(start);

    return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwshhelp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshhelp.h

Abstract:

    All help ids used in nwprovau.dll

Author:

    Yi-Hsin Sung      (yihsins)     20-Oct-1995

Revision History:

--*/

#ifndef _NWSHHELP_H_
#define _NWSHHELP_H_

#define NO_HELP                ((DWORD) -1)  // Disables Help on a control

#define IDH_DLG_NETWORK_CREDENTIAL_HELP  3001

#ifndef NT1057

// Global WhoAmI dialog
#define IDH_GLOBAL_SERVERLIST  3005
#define IDH_GLOBAL_CONTEXT     3006
#define	IDH_GLOBAL_DETACH	   3007
#define IDH_GLOBAL_CHGPWD      3008

// Server summary sheet
#define IDH_SERVERNAME         3020
#define IDH_COMMENT            3021
#define IDH_VERSION            3022
#define IDH_REVISION           3023
#define IDH_CONNINUSE          3024
#define IDH_MAXCONNS           3025

// Share summary sheet
#define IDH_SHARE_NAME         3030
#define IDH_SHARE_SERVER       3031
#define IDH_SHARE_PATH         3032
#define IDH_SHARE_USED_SPC     3034
#define IDH_SHARE_FREE_SPC     3035
#define IDH_SHARE_MAX_SPC      3036
#define IDH_SHARE_LFN_TXT      3037
#define IDH_SHARE_PIE          3038

// NDS sheet
#define IDH_NDS_NAME           3061
#define IDH_NDS_CLASS          3062
#define IDH_NDS_COMMENT        3063

// Printer summary sheet
#define IDH_PRINTER_NAME       3070
#define IDH_PRINTER_QUEUE      3071

#if 0
// Wkgrp summary sheet
#define IDH_WKGRP_NAME         3040
#define IDH_WKGRP_TYPE         3041

// NDS Admin page
#define IDH_ENABLE_SYSPOL	   3100
#define IDH_VOLUME_LABEL	   3101
#define IDH_VOLUME             3102
#define IDH_DIRECTORY_LABEL    3103
#define IDH_DIRECTORY          3104

#endif
#endif

#endif // _NWSHHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwshui.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshui.cxx

Abstract:

    This module implements the context menu actions of shell extension classes.

Author:

    Yi-Hsin Sung (yihsins)  25-Oct-1995

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shlobj.h>
#define  DONT_WANT_SHELLDEBUG
#include <shlobjp.h>
#include <winnetwk.h>
#include <npapi.h>
#include <ntddnwfs.h>
#include <ndsapi32.h>
#include <nwapi.h>
#include <nwwks.h>
#include <nwmisc.h>
//extern "C"
//{
#include "nwutil.h"
//}

#include "nwshcmn.h"
#include "nwshrc.h"

extern "C"
{
NTSTATUS
NwNdsOpenRdrHandle(
    OUT PHANDLE  phandleRdr );
}

#define MAX_ONE_CONN_INFORMATION_SIZE  512
#define NW_ENUM_EXTRA_BYTES            256
#define GLOBAL_WHOAMI_REFRESH_INTERVAL 30000   // in milliseconds, Win95 uses 10000

DWORD
LogoutFromServer(
    LPWSTR pszServer,
    PBOOL  pfDisconnected
);

INT_PTR
CALLBACK
GlobalWhoAmIDlgProc(
    HWND       hwndDlg,
    UINT       msg,
    WPARAM  wParam,
    LPARAM  lParam );

VOID
GetConnectionStatusString(
    PCONN_STATUS pConnStatus,
    LPBYTE       Buffer,
    DWORD        nSize
);

HRESULT
NWUIWhoAmI(
    HWND hParent,
    LPNETRESOURCE pNetRes
)
{
    DWORD  err = NO_ERROR;
    DWORD_PTR  ResumeKey = 0;
    LPBYTE pBuffer = NULL;
    DWORD  EntriesRead = 0;
    DWORD  dwMessageId;
    WCHAR  szUserName[MAX_PATH+1] = L"";
    WCHAR  szConnType[128];
    WCHAR  szRemoteName[MAX_PATH + 1];

    szConnType[0] = 0;

    if ( pNetRes->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER )
    {
        // Need to extract the server name from full UNC path
        NwExtractServerName( pNetRes->lpRemoteName, szRemoteName );
        dwMessageId = IDS_MESSAGE_NOT_ATTACHED;
    }
    else  // NDS container name
    {
        // Need to extract the tree name from the full UNC path
        szRemoteName[0] = TREECHAR;
        NwExtractTreeName( pNetRes->lpRemoteName, szRemoteName+1);
        dwMessageId = IDS_MESSAGE_NOT_ATTACHED_TO_TREE;
    }

    err = NwGetConnectionStatus( szRemoteName,
                                 &ResumeKey,
                                 &pBuffer,
                                 &EntriesRead );

    if ( err == NO_ERROR  && EntriesRead > 0 )
        // For trees, we'll get more than one entry
    {
        PCONN_STATUS pConnStatus = (PCONN_STATUS) pBuffer;
        LPWSTR pszStart = szConnType;
        DWORD  nSize = sizeof(szConnType)/sizeof(WCHAR);

        if ( EntriesRead > 1 && szRemoteName[0] == TREECHAR )
        {
            // If there is more than one entry for trees,
            // then we need to find one entry where username is not null
            // and the login type is NDS.
            // If we cannot find one, then just use the first one.

            DWORD i;
            PCONN_STATUS pConnStatusTmp = pConnStatus;
            PCONN_STATUS pConnStatusUser = NULL;
            PCONN_STATUS pConnStatusNoUser = NULL;

            for ( i = 0; i < EntriesRead ; i++ )
            {
                 if ( pConnStatusTmp->fNds )
                 {
                     pConnStatusNoUser = pConnStatusTmp;

                     if (  ( pConnStatusTmp->pszUserName != NULL )
                        && (  ( pConnStatusTmp->dwConnType == NW_CONN_NDS_AUTHENTICATED_NO_LICENSE )
                           || ( pConnStatusTmp->dwConnType == NW_CONN_NDS_AUTHENTICATED_LICENSED )
                           )
                        )
                     {
                         // Found it
                         pConnStatusUser = pConnStatusTmp;
                         break;
                     }
                 }

                 // Continue with the next item
                 pConnStatusTmp = (PCONN_STATUS) ( (DWORD_PTR) pConnStatusTmp
                                         + pConnStatusTmp->dwTotalLength);
            }

            if ( pConnStatusUser )  // found one nds entry with a user name
                pConnStatus = pConnStatusUser;
            else if ( pConnStatusNoUser ) // use an nds entry with no user name
                pConnStatus = pConnStatusNoUser;
            // else use the first entry

        }

        if (  szRemoteName[0] == TREECHAR    // A tree
           || !pConnStatus->fPreferred       // A server but not preferred
           )
        {
            // Show this conneciton only if this is a tree or if this is
            // not a implicit connection to the preferred server.

            dwMessageId = pNetRes->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER ?
                          IDS_MESSAGE_ATTACHED : IDS_MESSAGE_ATTACHED_TO_TREE;

            if ( pConnStatus->pszUserName )
            {
                wcscpy( szUserName, pConnStatus->pszUserName );
            }

            if ( pConnStatus->fNds )  // NDS
            {
                LoadString( ::hmodNW, IDS_LOGIN_TYPE_NDS, pszStart, nSize );
                nSize -= wcslen( pszStart );
                pszStart += wcslen( pszStart);

            }
            else  // Bindery
            {
                LoadString( ::hmodNW, IDS_LOGIN_TYPE_BINDERY, pszStart, nSize );
                nSize -= wcslen( pszStart );
                pszStart += wcslen( pszStart);
            }

            LoadString( ::hmodNW, IDS_LOGIN_STATUS_SEPARATOR, pszStart, nSize );
            nSize -= wcslen( pszStart );
            pszStart += wcslen( pszStart);

            GetConnectionStatusString( pConnStatus, (LPBYTE) pszStart, nSize );
        }
    }

    if ( err == NO_ERROR )
    {
        // Popup the message now.
        ::MsgBoxPrintf( hParent,
                        dwMessageId,
                        IDS_TITLE_WHOAMI,
                        MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION,
                        szRemoteName[0] == TREECHAR? szRemoteName + 1 : szRemoteName,
                        szUserName,
                        szConnType );
    }
    else  // error occurred
    {
        ::MsgBoxErrorPrintf( hParent,
                             IDS_MESSAGE_CONNINFO_ERROR,
                             IDS_TITLE_WHOAMI,
                             MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                             err,
                             NULL );
    }

    if ( pBuffer != NULL )
    {
        LocalFree( pBuffer );
        pBuffer = NULL;
    }

    return NOERROR;
}

VOID
GetConnectionStatusString(
    PCONN_STATUS pConnStatus,
    LPBYTE       Buffer,
    DWORD        nSize
)
{
    LPWSTR pszStart = (LPWSTR) Buffer;
    DWORD  dwMessageId = 0;

    if ( pConnStatus->fNds )  // NDS
    {
        if ( pConnStatus->dwConnType == NW_CONN_NOT_AUTHENTICATED )
        {
            dwMessageId = IDS_LOGIN_STATUS_NOT_AUTHENTICATED;
        }
        else if ( pConnStatus->dwConnType == NW_CONN_DISCONNECTED )
        {
            dwMessageId = IDS_LOGIN_STATUS_NOT_ATTACHED;
        }
        else  // authenticated, licensed or unlicensed
        {
            LoadString( ::hmodNW, IDS_LOGIN_STATUS_AUTHENTICATED,
                        pszStart, nSize );
            nSize -= wcslen( pszStart );
            pszStart += wcslen( pszStart);

            if ( pConnStatus->dwConnType == NW_CONN_NDS_AUTHENTICATED_LICENSED )
                dwMessageId = IDS_LOGIN_STATUS_LICENSED;
            else  // NW_CONN_NDS_AUTHENTICATED_NO_LICENSE
                dwMessageId = IDS_LOGIN_STATUS_NOT_LICENSED;
        }
    }
    else  // Bindery
    {
        if ( pConnStatus->dwConnType == NW_CONN_BINDERY_LOGIN )
            dwMessageId = IDS_LOGIN_STATUS_LOGGED_IN;
        else if ( pConnStatus->dwConnType == NW_CONN_DISCONNECTED )
            dwMessageId = IDS_LOGIN_STATUS_NOT_ATTACHED;
        else
            dwMessageId = IDS_LOGIN_STATUS_ATTACHED_ONLY;
    }

    LoadString( ::hmodNW, dwMessageId, pszStart, nSize );
}

HRESULT
NWUIGlobalWhoAmI(
    HWND hParent
)
{
    ::DialogBoxParam( ::hmodNW,
                      MAKEINTRESOURCE(DLG_GLOBAL_WHOAMI),
                      hParent,
                      ::GlobalWhoAmIDlgProc,
                      NULL );

    return NOERROR;
}

HRESULT
NWUILogOut(
    HWND hParent,
    LPNETRESOURCE pNetRes,
    PBOOL pfDisconnected
)
{
    DWORD err = NO_ERROR;
    WCHAR szServer[MAX_PATH+1];
    BOOL  fAttached;
    BOOL  fAuthenticated;
    DWORD dwMessageId;

    *pfDisconnected = FALSE;

    // Need to extract the server name from full UNC path
    NwExtractServerName( pNetRes->lpRemoteName, szServer );

    err = NwIsServerOrTreeAttached( szServer, &fAttached, &fAuthenticated );

    if ( err == NO_ERROR && !fAttached )
    {
        dwMessageId = IDS_MESSAGE_NOT_ATTACHED;
    }
    else if ( err == NO_ERROR ) // attached
    {
        int nRet = ::MsgBoxPrintf( hParent,
                                   IDS_MESSAGE_LOGOUT_CONFIRM,
                                   IDS_TITLE_LOGOUT,
                                   MB_YESNO | MB_SETFOREGROUND | MB_ICONQUESTION);

        if ( nRet != IDYES )
            return NOERROR;

        err = LogoutFromServer( szServer, pfDisconnected );

        if ( err == NO_ERROR )
            dwMessageId = IDS_MESSAGE_DETACHED;
        else
            dwMessageId = IDS_MESSAGE_LOGOUT_FAILED;
    }
    else // error occurred
    {
        ::MsgBoxErrorPrintf( hParent,
                             IDS_MESSAGE_CONNINFO_ERROR,
                             IDS_TITLE_LOGOUT,
                             MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                             err,
                             NULL );

        return NOERROR;
    }

    ::MsgBoxPrintf( hParent,
                    dwMessageId,
                    IDS_TITLE_LOGOUT,
                    MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION );

    return NOERROR;
}

DWORD
LogoutFromServer(
    LPWSTR pszServer,
    PBOOL  pfDisconnected
)
{
    DWORD  err = NO_ERROR;
    HANDLE EnumHandle = (HANDLE) NULL;

    LPNETRESOURCE  NetR = NULL;
    LPNETRESOURCEW SavePtr;

    DWORD BytesNeeded = MAX_ONE_NETRES_SIZE;
    DWORD EntriesRead = 0;
    DWORD i;

    *pfDisconnected = FALSE;

    err = NPOpenEnum( RESOURCE_CONNECTED,
                      0,
                      0,
                      NULL,
                      &EnumHandle );

    if ( err != NO_ERROR)
    {
        EnumHandle = (HANDLE) NULL;
        goto CleanExit;
    }

    //
    // Allocate buffer to get server list.
    //
    if ((NetR = (LPNETRESOURCE) LocalAlloc( 0, BytesNeeded )) == NULL)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        EntriesRead = 0xFFFFFFFF;          // Read as many as possible

        err = NwEnumConnections( EnumHandle,
                                 &EntriesRead,
                                 (LPVOID) NetR,
                                 &BytesNeeded,
                                 TRUE );


        if ( err == WN_SUCCESS)
        {
            SavePtr = NetR;

            for (i = 0; i < EntriesRead; i++, NetR++)
            {
                BYTE Buffer[MAX_ONE_CONN_INFORMATION_SIZE];
                BOOL fImplicit;
                LPWSTR pszCurrentServer;

                fImplicit = FALSE;

                if ( NwIsNdsSyntax( NetR->lpRemoteName))
                {
                    // For Nds name, the server name might not be in the full UNC name.
                    // Hence we need to get the server name from the Rdr.

                    DWORD err1 = NwGetConnectionInformation(
                                     NetR->lpLocalName? NetR->lpLocalName : NetR->lpRemoteName,
                                     Buffer,
                                     sizeof(Buffer));

                    if ( err1 != NO_ERROR )
                        continue;   // continue with the next entry if error occurred

                    pszCurrentServer = ((PCONN_INFORMATION) Buffer)->HostServer;

                    // Need to NULL terminate the server name, this will probably used the space
                    // occupied by UserName but since we are not using it, it is probably ok.
                    LPWSTR pszTemp = (LPWSTR) ((DWORD_PTR) pszCurrentServer
                                              + ((PCONN_INFORMATION) Buffer)->HostServerLength );
                    *pszTemp = 0;

                }
                else   // in the form \\server\sys
                {
                    LPWSTR pszTemp;
                    wcscpy( (LPWSTR) Buffer, NetR->lpRemoteName + 2 );  // go past two backslashes

                    if ( pszTemp = wcschr( (LPWSTR) Buffer, L'\\' ))
                        *pszTemp = 0;
                    else
                    {
                        // The remote name contains only \\server, hence if the local name
                        // is null, this is a implicit connection
                        if ( NetR->lpLocalName == NULL )
                            fImplicit = TRUE;
                    }

                    pszCurrentServer = (LPWSTR) Buffer;
                }


                if ( _wcsicmp( pszCurrentServer, pszServer ) == 0 )
                {

                    do {

                        // for implicit connections, we need to try and disconnect until
                        // we deleted all the implicit connections, i.e. until we
                        // get the invalid handle error

                        // NOTE: If we don't pass in CONNECT_UPDATE_PROFILE, shell won't update
                        // the windows that got disconnected. What do we want to do here?
                        err = WNetCancelConnection2(
                                  NetR->lpLocalName? NetR->lpLocalName : NetR->lpRemoteName,
                                  0, // CONNECT_UPDATE_PROFILE,
                                  TRUE );

                        if ( err == NO_ERROR )
                            *pfDisconnected = TRUE;

                    } while ( fImplicit && ( err == NO_ERROR));

                    if ( err == ERROR_INVALID_HANDLE )
                    {
                        // implicit connection will sometimes return this if the explicit connection
                        // is already disconnected
                        err =  NO_ERROR;
                    }

                    if ( err != NO_ERROR )
                    {
                        NetR = SavePtr;
                        goto CleanExit;
                    }
                }
            }

            NetR = SavePtr;
        }
        else if ( err != WN_NO_MORE_ENTRIES)
        {
            if ( err == WN_MORE_DATA)
            {

                //
                // Original buffer was too small.  Free it and allocate
                // the recommended size and then some to get as many
                // entries as possible.
                //

                (void) LocalFree((HLOCAL) NetR);

                BytesNeeded += NW_ENUM_EXTRA_BYTES;

                if ((NetR = (LPNETRESOURCE) LocalAlloc( 0, BytesNeeded )) == NULL)
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    goto CleanExit;
                }
            }
            else
            {
                goto CleanExit;
            }
        }

    } while (err != WN_NO_MORE_ENTRIES);

    if ( err == WN_NO_MORE_ENTRIES)
        err = NO_ERROR;

CleanExit:

    if (EnumHandle != (HANDLE) NULL)
        (void) NPCloseEnum( EnumHandle);

    if (NetR != NULL)
    {
        (void) LocalFree( (HLOCAL) NetR);
        NetR = NULL;
    }

    return err;
}

HRESULT
NWUIAttachAs(
    HWND hParent,
    LPNETRESOURCE pNetRes
)
{
    DWORD err = NO_ERROR;
    WCHAR szServerName[MAX_PATH+1];
    BOOL  fAttached;
    BOOL  fAuthenticated;

    // First, see if we are attached to the server.
    // Note, Attach as menu will be disabled on the NDS servers that we are already logged into.

    // Need to extract the server name from full UNC path
    szServerName[0] = szServerName[1] = L'\\';
    NwExtractServerName( pNetRes->lpRemoteName, szServerName + 2 );

    err = NwIsServerOrTreeAttached( szServerName + 2, &fAttached, &fAuthenticated );

    if ( err == NO_ERROR && fAttached && fAuthenticated )
    {
        // Already attached and authenticated to the server.
        // So, ask the user if he wants to log out first.

        int nRet = ::MsgBoxPrintf( hParent,
                                   IDS_MESSAGE_LOGOUT_QUESTION,
                                   IDS_TITLE_LOGOUT,
                                   MB_YESNO | MB_SETFOREGROUND | MB_ICONQUESTION );

        if ( nRet != IDYES )
            return NOERROR;

        BOOL fDisconnected = FALSE;  // can be used to refresh the shell if needed
        err = LogoutFromServer( szServerName + 2, &fDisconnected );

        if ( err != NO_ERROR )
        {
            ::MsgBoxPrintf( hParent,
                            IDS_MESSAGE_LOGOUT_FAILED,
                            IDS_TITLE_LOGOUT,
                            MB_OK | MB_SETFOREGROUND | MB_ICONSTOP );

            return NOERROR;
        }
    }

    // If error occurred, just assume we are not attached to the server and continue on
    // to login to the server.

    DWORD dwConnFlags = CONNECT_INTERACTIVE | CONNECT_PROMPT;

    // See if the server is in the default context tree.
    // If yes, then we don't need to prompt the password first before connecting
    // in WNetAddConnection3.

    BOOL  fInDefaultTree = FALSE;
    err = NwIsServerInDefaultTree( pNetRes->lpRemoteName, &fInDefaultTree );

    if ( (err == NO_ERROR ) && fInDefaultTree )
        dwConnFlags = CONNECT_INTERACTIVE;

    //
    // Now call WNetAddConnection3
    //

    // NOTE: net use \\mars_srv0 will succeed
    // but net use \\marsdev\cn=mars_srv0... will failed
    // Hence, just use the server name to connect.
    LPWSTR pszSave = pNetRes->lpRemoteName;
    pNetRes->lpRemoteName = szServerName;

    err = WNetAddConnection3( hParent,
                              pNetRes,
                              NULL,
                              NULL,
                              dwConnFlags );

    if ( err != WN_SUCCESS && err != WN_CANCEL )
    {
        ::MsgBoxErrorPrintf( hParent,
                             IDS_MESSAGE_ADDCONN_ERROR,
                             IDS_NETWARE_TITLE,
                             MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                             err,
                             pNetRes->lpRemoteName );
    }

    pNetRes->lpRemoteName = pszSave;   // restore the original remote name just in case

    return NOERROR;
}


#if 0
HRESULT
NWUISetDefaultContext(
    HWND hParent,
    LPNETRESOURCE pNetRes
)
{
    DWORD  dwPrintOptions;
    LPWSTR pszCurrentContext = NULL;
    WCHAR  szNewContext[MAX_PATH+1];

    DWORD  err = NO_ERROR;
    HANDLE handleRdr = NULL;

    UNICODE_STRING uTree;
    UNICODE_STRING uContext;
    LPWSTR pszContext = NULL;

    // Open a handle to the redirector
    err = RtlNtStatusToDosError( ::NwNdsOpenRdrHandle( &handleRdr ));

    if ( err != NO_ERROR )
        goto CleanExit;

    // Get the print option so that we can use it later
    err = ::NwQueryInfo( &dwPrintOptions, &pszCurrentContext );

    if ( err != NO_ERROR )
        goto CleanExit;

    wcscpy( szNewContext, pNetRes->lpRemoteName + 1 );  // get past 1st '\\'
    szNewContext[0] = TREECHAR;   //  in the format "*TREE\CONTEXT"

    if ( (pszContext = wcschr( szNewContext, L'\\' )) != NULL )
    {
        *pszContext = 0;
        RtlInitUnicodeString( &uContext, pszContext + 1 );
    }
    else
        RtlInitUnicodeString( &uContext, L"");

    RtlInitUnicodeString( &uTree, szNewContext+1 );

    if ( (err = RtlNtStatusToDosError( ::NwNdsSetTreeContext( handleRdr, &uTree, &uContext)))
       == NO_ERROR )
    {
        *pszContext = L'\\';

        if ((err = ::NwSetInfoInRegistry( dwPrintOptions, szNewContext )) == NO_ERROR )
        {
            ::MsgBoxPrintf( hParent,
                            IDS_MESSAGE_CONTEXT_CHANGED,
                            IDS_NETWARE_TITLE,
                            MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION,
                            pszCurrentContext
                              ? (   *pszCurrentContext == TREECHAR
                                  ? pszCurrentContext + 1
                                  : pszCurrentContext )
                              : L"",
                            szNewContext+1 );
        }
    }

CleanExit:

    if ( err != NO_ERROR )
    {
        ::MsgBoxErrorPrintf( hParent,
                             IDS_MESSAGE_CONTEXT_ERROR,
                             IDS_NETWARE_TITLE,
                             MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                             err,
                             szNewContext+1);
    }

    if ( pszCurrentContext != NULL )
    {
        LocalFree( pszCurrentContext );
        pszCurrentContext = NULL;
    }

    if ( handleRdr != NULL )
    {
        ::NtClose( handleRdr );
        handleRdr = NULL;
    }

    return NOERROR;
}
#endif

HRESULT
NWUIMapNetworkDrive(
    HWND hParent,
    LPNETRESOURCE pNetRes
)
{
    HRESULT hres;
    CONNECTDLGSTRUCT cds;

    cds.cbStructure = sizeof(cds);
    cds.hwndOwner   = hParent;
    cds.lpConnRes   = pNetRes;
    cds.dwFlags     = CONNDLG_RO_PATH;

    if (  (( hres = WNetConnectionDialog1( &cds )) == WN_SUCCESS )
       && ( g_pFuncSHChangeNotify )
       )
    {
        WCHAR szPath[4];

        szPath[0] = ((USHORT) cds.dwDevNum) - 1 + L'A';
        szPath[1] = L':';
        szPath[2] = L'\\';
        szPath[3] = 0;

        // Notify shell about added redirection
        (*g_pFuncSHChangeNotify)( SHCNE_DRIVEADD,
                                  SHCNF_FLUSH | SHCNF_PATH | SHCNF_FLUSHNOWAIT,
                                  szPath,
                                  NULL );

        Sleep(1000); // short delay to make sure Shell has updated drive table

        // And we need to open shell window on this path
        if (g_pFuncSHExecuteEx)
        {
            SHELLEXECUTEINFO ExecInfo;

            ::memset(&ExecInfo,0,sizeof(ExecInfo));

            ExecInfo.hwnd         = hParent;
            ExecInfo.lpVerb       = 0;
            ExecInfo.lpFile       = szPath;
            ExecInfo.lpParameters = NULL;
            ExecInfo.lpDirectory  = NULL;
            ExecInfo.nShow        = SW_NORMAL | SW_SHOW;
            ExecInfo.fMask        = SEE_MASK_CLASSNAME;
            ExecInfo.cbSize       = sizeof(SHELLEXECUTEINFO);
            ExecInfo.lpClass      = (LPWSTR) L"Folder";
            ExecInfo.hkeyClass    = NULL;

            (*g_pFuncSHExecuteEx)(&ExecInfo);
        }
    }

    return hres;
}



#define     LB_PCT_NAME     25
#define     LB_PCT_TYPE     11
#define     LB_PCT_CONN     11
#define     LB_PCT_USER     25
#define     LB_PCT_STATUS   27

#define     BITMAP_WIDTH    16
#define     BITMAP_HEIGHT   16

#define     MAPCOLOR        RGB(0, 255, 0)

static UINT uiNDSIconIndex = 0;
static UINT uiServerIconIndex = 0;

/*
 * FillConnectionsListView
 * -----------------------
 *
 * Fill list box with information on active connections
 */
VOID
FillConnectionsListView(
     HWND   hwndDlg
)
{
    HWND      hwndLV = ::GetDlgItem(hwndDlg,IDD_GLOBAL_SERVERLIST);
    LV_ITEM   lvI;
    WCHAR     szSubItemText[MAX_PATH+1];
    UINT      uiInsertedIndex;

    DWORD_PTR     ResumeKey = 0;
    LPBYTE    pConnBuffer = NULL;
    DWORD     EntriesRead = 0;
    DWORD     err = NO_ERROR;

    // Prepare ListView structure
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;

    do {

        if ( pConnBuffer != NULL )
        {
            LocalFree( pConnBuffer );
            pConnBuffer = NULL;
        }

        err = NwGetConnectionStatus( NULL,
                                     &ResumeKey,
                                     &pConnBuffer,
                                     &EntriesRead );


        if (  ( err != NO_ERROR )
           || ( EntriesRead == 0 )
           )
        {
            goto CleanExit;
        }

        PCONN_STATUS pConnStatus = (PCONN_STATUS) pConnBuffer;

        for ( DWORD i = 0; i < EntriesRead; i++)
        {
            // Allocate and initialize new item structure for use in the listbox

            DWORD dwSize;

            //
            // Don't need to show preferred server with only implicit
            // connections since we can't disconnect from it.
            //
            if ( pConnStatus->fPreferred )
            {
                // Continue with the next item
                pConnStatus = (PCONN_STATUS) ( (DWORD_PTR) pConnStatus
                                             + pConnStatus->dwTotalLength);
                continue;
            }

            //
            // Allocate and copy the connection information to be store with
            // the listbox
            //
            PCONN_STATUS pConnStatusKeep =
                (PCONN_STATUS) LocalAlloc( LMEM_ZEROINIT, pConnStatus->dwTotalLength );
            if ( pConnStatusKeep == NULL )
            {
                err  = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }

            memcpy( pConnStatusKeep, pConnStatus, pConnStatus->dwTotalLength );

            dwSize = sizeof(CONN_STATUS);

            if ( pConnStatus->pszServerName )
            {
                pConnStatusKeep->pszServerName =
                    (LPWSTR) ((DWORD_PTR)pConnStatusKeep + dwSize );

                NwMakePrettyDisplayName( pConnStatusKeep->pszServerName );

                dwSize += (wcslen(pConnStatus->pszServerName)+1)*sizeof(WCHAR);
            }

            if ( pConnStatus->pszUserName )
            {
                pConnStatusKeep->pszUserName =
                    (LPWSTR) ((DWORD_PTR)pConnStatusKeep + dwSize );

                dwSize += (wcslen(pConnStatus->pszUserName)+1) * sizeof(WCHAR);

                NwAbbreviateUserName( pConnStatus->pszUserName,
                                      pConnStatusKeep->pszUserName );

                NwMakePrettyDisplayName( pConnStatusKeep->pszUserName );
            }

            if ( pConnStatus->pszTreeName )
            {
                pConnStatusKeep->pszTreeName =
                    (LPWSTR) ((DWORD_PTR)pConnStatusKeep + dwSize );
            }

            //
            // Construct the item to add to the listbox
            //
            lvI.iItem    = i;
            lvI.iSubItem = 0;
            lvI.pszText  = szSubItemText;
            lvI.cchTextMax = sizeof(szSubItemText);

            // Select proper icon
            lvI.iImage = pConnStatusKeep->fNds? uiNDSIconIndex
                                              : uiServerIconIndex;

            lvI.lParam = (LPARAM) pConnStatusKeep;

            wcscpy( szSubItemText, pConnStatusKeep->pszServerName );

            // Insert the item
            uiInsertedIndex = ListView_InsertItem( hwndLV, &lvI);

            if ( uiInsertedIndex != -1 )
            {
                // Added item itself - now for specific columns

                // First, add the column indicating bindery or nds connection
                if ( pConnStatusKeep->fNds )
                {
                    LoadString( ::hmodNW, IDS_LOGIN_TYPE_NDS, szSubItemText,
                                sizeof(szSubItemText)/sizeof(szSubItemText[0]));
                }
                else
                {
                    LoadString( ::hmodNW, IDS_LOGIN_TYPE_BINDERY, szSubItemText,
                                sizeof(szSubItemText)/sizeof(szSubItemText[0]));
                }

                ListView_SetItemText( hwndLV,
                                      uiInsertedIndex,
                                      1,    // SubItem id
                                      szSubItemText );

                // Next, Add the column indicating the connection number

                if (  ( pConnStatusKeep->pszServerName[0] != TREECHAR )
                   && ( pConnStatusKeep->dwConnType != NW_CONN_DISCONNECTED )
                   )
                {
                    // Add connection number only if it is a connection
                    // to a server and not a tree.
                    // A connection number only makes sense when not disconnected
                    ::wsprintf(szSubItemText,L"%4d",pConnStatusKeep->nConnNum );
                    ListView_SetItemText( hwndLV,
                                          uiInsertedIndex,
                                          2,    // SubItem id
                                          szSubItemText );
                }

                // Then, add the column indicating the user name

                *szSubItemText = L'\0';
                if ( pConnStatusKeep->pszUserName )
                {
                    wcscpy( szSubItemText, pConnStatusKeep->pszUserName );

                    ListView_SetItemText( hwndLV,
                                          uiInsertedIndex,
                                          3, // SubItem id
                                          szSubItemText );
                }

                // Last of all, add the column indicating the connection status

                *szSubItemText = L'\0';
                GetConnectionStatusString( pConnStatusKeep,
                                           (LPBYTE) szSubItemText,
                                           sizeof(szSubItemText)/sizeof(szSubItemText[0]));

                ListView_SetItemText( hwndLV,
                                      uiInsertedIndex,
                                      4, // SubItem id
                                      szSubItemText );

            }
            else
            {
                // Failed inserting item in the list,
                // need to delete the allocated CONN_STATUS
                ASSERT( FALSE );
                LocalFree( pConnStatusKeep );
                pConnStatusKeep = NULL;
            }

            // Continue with the next item
            pConnStatus = (PCONN_STATUS) ( (DWORD_PTR) pConnStatus
                                         + pConnStatus->dwTotalLength);
        }

    } while ( ResumeKey != 0 );

CleanExit:

    if ( pConnBuffer != NULL )
    {
        LocalFree( pConnBuffer );
        pConnBuffer = NULL;
    }

    if ( err != NO_ERROR )
    {
        // If error occurred, we will end the dialog

        ::MsgBoxErrorPrintf( hwndDlg,
                             IDS_MESSAGE_CONNINFO_ERROR,
                             IDS_NETWARE_TITLE,
                             MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                             err,
                             NULL );

        ::EndDialog( hwndDlg, FALSE);
    }
}


/*
 * CreateConnectionsListView
 * -------------------------
 *
 * Initialize the column headers of the list box
 */
VOID
CreateConnectionsListView(
    HWND    hwndDlg
)
{
    HWND    hwndLV;
    HIMAGELIST  hSmall;
    UINT    uiLBoxWidth;

    InitCommonControls();

    // Get the handle of the listbox
    hwndLV = ::GetDlgItem(hwndDlg,IDD_GLOBAL_SERVERLIST);

    RECT rc;
    ::GetWindowRect( ::GetDlgItem( hwndDlg, IDD_GLOBAL_SERVERLIST ), &rc );
    uiLBoxWidth = rc.right - rc.left;

    // Load image list
    hSmall = ::ImageList_Create(BITMAP_WIDTH,BITMAP_HEIGHT,ILC_MASK,4,0);

    // Load bitmap of the tree/server icon
    HBITMAP hbm;
    hbm = ::LoadBitmap(::hmodNW,MAKEINTRESOURCE(IDB_TREE_ICON));

    if ((uiNDSIconIndex = ImageList_AddMasked(hSmall,hbm,MAPCOLOR)) == -1) {

        ASSERT(FALSE);
    }

    hbm = ::LoadBitmap(::hmodNW,MAKEINTRESOURCE(IDB_SERVER_ICON));

    if ((uiServerIconIndex = ImageList_AddMasked(hSmall,hbm,MAPCOLOR)) == -1) {

        ASSERT(FALSE);
    }

    ImageList_SetBkColor(hSmall, CLR_NONE);

    // Associate image list with list view control
    ListView_SetImageList(hwndLV,hSmall,LVSIL_SMALL);

    // Initialize columns in header
    LV_COLUMN   lvC;
    UINT        uiColumnIndex = 0;
    WCHAR       szColumnName[128];

    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt = LVCFMT_LEFT;
    lvC.cx = (uiLBoxWidth*LB_PCT_NAME)/100;
    lvC.pszText = szColumnName;

    // Add the column header representing the server name
    *szColumnName = L'\0';
    ::LoadString( ::hmodNW,
                  IDS_COLUMN_NAME,
                  szColumnName,
                  sizeof(szColumnName)/sizeof(szColumnName[0]));
    if ( ListView_InsertColumn(hwndLV,uiColumnIndex++,&lvC) == -1) {
        ASSERT(FALSE);
    }

    // Add the column header representing the conneciton type
    *szColumnName = L'\0';
    lvC.cx = (uiLBoxWidth*LB_PCT_TYPE)/100;
    ::LoadString( ::hmodNW,
                  IDS_COLUMN_CONN_TYPE,
                  szColumnName,
                  sizeof(szColumnName)/sizeof(szColumnName[0]));
    if ( ListView_InsertColumn(hwndLV,uiColumnIndex++,&lvC) == -1) {
        ASSERT(FALSE);
    }

    // Add the column header representing the connection number
    *szColumnName = L'\0';
    lvC.cx = (uiLBoxWidth*LB_PCT_CONN)/100;
    lvC.fmt = LVCFMT_RIGHT;

    ::LoadString( ::hmodNW,
                  IDS_COLUMN_CONN_NUMBER,
                  szColumnName,
                  sizeof(szColumnName)/sizeof(szColumnName[0]));
    if ( ListView_InsertColumn(hwndLV,uiColumnIndex++,&lvC) == -1) {
        ASSERT(FALSE);
    }

    // Add the column header representing the name of the user
    *szColumnName = L'\0';
    lvC.cx = (uiLBoxWidth*LB_PCT_USER)/100;
    lvC.fmt = LVCFMT_LEFT;

    ::LoadString( ::hmodNW,
                  IDS_COLUMN_USER,
                  szColumnName,
                  sizeof(szColumnName)/sizeof(szColumnName[0]));

    if ( ListView_InsertColumn(hwndLV,uiColumnIndex++,&lvC) == -1) {
        ASSERT(FALSE);
    }

    // Add the column header representing the status of the connection
    *szColumnName = L'\0';
    lvC.cx = (uiLBoxWidth*LB_PCT_STATUS)/100;
    lvC.fmt = LVCFMT_LEFT;

    ::LoadString( ::hmodNW,
                  IDS_COLUMN_STATUS,
                  szColumnName,
                  sizeof(szColumnName)/sizeof(szColumnName[0]));

    if ( ListView_InsertColumn(hwndLV,uiColumnIndex++,&lvC) == -1) {
        ASSERT(FALSE);
    }

    // Now fill list view window with connection information
    FillConnectionsListView( hwndDlg );

} /* endproc CreateConnectionsListView */


/*
 * GlobalWhoAmI_ListViewCompareProc
 * --------------------------------
 *
 */
LRESULT CALLBACK
GlobalWhoAmI_ListViewCompareProc(
    LPARAM  lParam1,
    LPARAM  lParam2,
    LPARAM  lParamSort
)
{
    PCONN_STATUS    pConnItem1 = (PCONN_STATUS)lParam1;
    PCONN_STATUS    pConnItem2 = (PCONN_STATUS)lParam2;

    int iResult = 0;

    if ( pConnItem1 && pConnItem2 )
    {
        switch(lParamSort)
        {
            case 0:
                iResult = ::_wcsicmp( pConnItem1->pszServerName,
                                      pConnItem2->pszServerName);
                break;

            case 1:
                iResult = pConnItem1->fNds - pConnItem2->fNds;
                break;

            case 2:
                iResult = pConnItem1->nConnNum - pConnItem2->nConnNum;
                break;

            case 3:
            {
                // pszUserName might be NULL, so we need to be careful when
                // comparing them.
                if ( pConnItem1->pszUserName )
                {
                    if ( pConnItem2->pszUserName )
                    {
                        iResult = ::_wcsicmp( pConnItem1->pszUserName,
                                              pConnItem2->pszUserName);
                    }
                    else
                    {
                        iResult = 1;
                    }
                }
                else
                {
                    iResult = -1;
                }
                break;
            }

            case 4:
                iResult = pConnItem1->dwConnType - pConnItem2->dwConnType;
                break;

            default:
                iResult = 0;
                break;
        }
    }

    return (iResult);

}

LRESULT
NotifyHandler(
    HWND   hwndDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    NM_LISTVIEW *lpNm  = (NM_LISTVIEW *)lParam;
    NMHDR       *lphdr = &lpNm->hdr;

    HWND        hwndLV = ::GetDlgItem(hwndDlg,IDD_GLOBAL_SERVERLIST);

    switch(lphdr->code)
    {
        case LVN_ITEMCHANGED:
            // Check for change in item state, make sure item has received focus
            if (lpNm->uChanged & LVIF_STATE)
            {
                UINT uiSelectedItems = 0;

                uiSelectedItems = ListView_GetSelectedCount(hwndLV);

                EnableWindow( GetDlgItem(hwndDlg, IDD_DETACH),
                              uiSelectedItems? TRUE : FALSE);

                return TRUE;
            }
            break;

        case LVN_COLUMNCLICK:
            ListView_SortItems( hwndLV,
                                GlobalWhoAmI_ListViewCompareProc,
                                (LPARAM)(lpNm->iSubItem));
            return TRUE;        /* we processed a message */

        case LVN_DELETEITEM:
            // Free memory
            LocalFree( (HLOCAL) lpNm->lParam );
            lpNm->lParam = NULL;
            break;

        default:
            break;
    }

    return FALSE;
}


BOOL
DetachResourceProc(
    HWND hwndDlg
)
{
    BOOL          fDetached = FALSE;
    LV_ITEM       lvitem;
    int           index;
    DWORD         err;

    HWND          hwndLV = ::GetDlgItem( hwndDlg, IDD_GLOBAL_SERVERLIST);

    index = -1;  // Start at beginning of item list.

    while ((index = ListView_GetNextItem(hwndLV, index, LVNI_SELECTED)) != -1)
    {
        lvitem.iItem    = index;
        lvitem.mask     = LVIF_PARAM;
        lvitem.iSubItem = 0;

        if ( ListView_GetItem( hwndLV, &lvitem ))
        {
            PCONN_STATUS pConnStatus = (PCONN_STATUS) lvitem.lParam;
            BOOL fDisconnected = FALSE;   // Can be used to refresh
                                          // the shell if needed

            err = LogoutFromServer( pConnStatus->pszServerName,
                                    &fDisconnected );

            if ( err == NO_ERROR )
            {
                fDetached = TRUE;
            }
            else
            {
                NwMakePrettyDisplayName(pConnStatus->pszServerName);
                ::MsgBoxPrintf( hwndDlg,
                                IDS_MESSAGE_LOGOUT_FROM_SERVER_FAILED,
                                IDS_TITLE_LOGOUT,
                                MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION,
                                pConnStatus->pszServerName );
            }
        }
    }

    return fDetached;
}

static DWORD aWhoAmIIds[] = { IDC_LOGOFRAME,          NO_HELP,
                              IDD_GLOBAL_SERVERLIST_T,IDH_GLOBAL_SERVERLIST,
                              IDD_GLOBAL_SERVERLIST,  IDH_GLOBAL_SERVERLIST,
                              IDD_DETACH,             IDH_GLOBAL_DETACH,
                              IDD_GLOBAL_SVRLIST_DESC,IDH_GLOBAL_SERVERLIST,
                              0, 0 };

/*
 * GlobalWhoAmIDlgProc
 * -------------------
 *
 * WhoAmI information for list of attached servers
 */
INT_PTR
CALLBACK
GlobalWhoAmIDlgProc(
    HWND    hwndDlg,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            LPWSTR pszCurrentContext = NULL;
            DWORD dwPrintOptions;

            // Get the current default tree or server name
            DWORD err = ::NwQueryInfo( &dwPrintOptions, &pszCurrentContext );
            if ( err == NO_ERROR )
            {
                LPWSTR pszName;
                WCHAR  szUserName[MAX_PATH+1] = L"";
                WCHAR  szNoName[2] = L"";
                DWORD_PTR  ResumeKey = 0;
                LPBYTE pBuffer = NULL;
                DWORD  EntriesRead = 0;

                DWORD  dwMessageId;

                UNICODE_STRING uContext;
                WCHAR  szContext[MAX_PATH+1];

                szContext[0] = 0;
                uContext.Buffer = szContext;
                uContext.Length = uContext.MaximumLength
                                = sizeof(szContext)/sizeof(szContext[0]);

                if ( pszCurrentContext )
                {
                    pszName = pszCurrentContext;
                }
                else
                {
                    pszName = szNoName;
                }

                if ( pszName[0] == TREECHAR )
                {
                    // Get the tree name from the full name *TREE\CONTEXT

                    LPWSTR pszTemp;
                    if ( pszTemp = wcschr( pszName, L'\\' ))
                        *pszTemp = 0;

                    dwMessageId = IDS_MESSAGE_NOT_LOGGED_IN_TREE;
                }
                else
                {
                    dwMessageId = IDS_MESSAGE_NOT_LOGGED_IN_SERVER;
                }

                if ( pszName[0] != 0 )  // there is preferred server/tree
                {
                    err = NwGetConnectionStatus( pszName,
                                                 &ResumeKey,
                                                 &pBuffer,
                                                 &EntriesRead );
                }

                if ( err == NO_ERROR  && EntriesRead > 0 )
                    // For trees, we'll get more than one entry
                {
                    PCONN_STATUS pConnStatus = (PCONN_STATUS) pBuffer;

                    if ( EntriesRead > 1 && pszName[0] == TREECHAR )
                    {
                        // If there is more than one entry for trees,
                        // then we need to find one entry where username is not null.
                        // If we cannot find one, then just use the first one.

                        DWORD i;
                        PCONN_STATUS pConnStatusTmp = pConnStatus;
                        PCONN_STATUS pConnStatusUser = NULL;
                        PCONN_STATUS pConnStatusNoUser = NULL;

                        for ( i = 0; i < EntriesRead ; i++ )
                        {
                             if ( pConnStatusTmp->fNds )
                             {
                                 pConnStatusNoUser = pConnStatusTmp;

                                 if (  ( pConnStatusTmp->pszUserName != NULL )
                                    && (  ( pConnStatusTmp->dwConnType
                                          == NW_CONN_NDS_AUTHENTICATED_NO_LICENSE )
                                       || ( pConnStatusTmp->dwConnType
                                          == NW_CONN_NDS_AUTHENTICATED_LICENSED )
                                       )
                                    )
                                 {
                                     // Found it
                                     pConnStatusUser = pConnStatusTmp;
                                     break;
                                 }
                             }

                             // Continue with the next item
                             pConnStatusTmp = (PCONN_STATUS)
                                              ( (DWORD_PTR) pConnStatusTmp
                                              + pConnStatusTmp->dwTotalLength);
                        }

                        if ( pConnStatusUser )
                        {
                            // found one nds entry with a user name
                            pConnStatus = pConnStatusUser;
                        }
                        else if ( pConnStatusNoUser )
                        {
                            // use an nds entry with no user name
                            pConnStatus = pConnStatusNoUser;
                        }
                        // else use the first entry
                    }

                    if (  ( pConnStatus->pszUserName )
                       && ( pConnStatus->pszUserName[0] != 0 )
                       )
                    {
                        NwAbbreviateUserName( pConnStatus->pszUserName,
                                              szUserName);

                        NwMakePrettyDisplayName( szUserName );

                        if ( pszName[0] != TREECHAR )
                        {
                            dwMessageId = IDS_MESSAGE_LOGGED_IN_SERVER;
                        }
                        else
                        {
                            dwMessageId = IDS_MESSAGE_LOGGED_IN_TREE;
                        }
                    }

                    if ( pszName[0] == TREECHAR )
                    {
                        // For trees, we need to get the current context

                        // Open a handle to the redirector
                        HANDLE handleRdr = NULL;
                        err = RtlNtStatusToDosError(
                                  ::NwNdsOpenRdrHandle( &handleRdr ));

                        if ( err == NO_ERROR )
                        {
                            UNICODE_STRING uTree;
                            RtlInitUnicodeString( &uTree, pszName+1 ); // get past '*'

                            // Get the current context in the default tree
                            err = RtlNtStatusToDosError(
                                      ::NwNdsGetTreeContext( handleRdr,
                                                             &uTree,
                                                             &uContext));
                        }

                        if ( handleRdr != NULL )
                            ::NtClose( handleRdr );
                    }
                }

                if ( !err )
                {
                    LPWSTR pszText = NULL;
                    err = ::LoadMsgPrintf( &pszText,
                                           dwMessageId,
                                           pszName[0] == TREECHAR?
                                               pszName + 1 : pszName,
                                           szUserName,
                                           szContext );

                    if ( err == NO_ERROR )
                    {
                        ::SetDlgItemText( hwndDlg, IDD_GLOBAL_SERVERLIST_T,
                                          pszText);
                        ::LocalFree( pszText );
                    }
                }

                if ( pBuffer != NULL )
                {
                    LocalFree( pBuffer );
                    pBuffer = NULL;
                }
            }

            if ( pszCurrentContext != NULL )
            {
                LocalFree( pszCurrentContext );
                pszCurrentContext = NULL;
            }

            if ( err != NO_ERROR )
            {
                ::MsgBoxErrorPrintf( hwndDlg,
                                     IDS_MESSAGE_CONNINFO_ERROR,
                                     IDS_NETWARE_TITLE,
                                     MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                                     err,
                                     NULL );
                ::EndDialog( hwndDlg, FALSE);
                return TRUE;
            }

            // Fill listview control with connection parameters
            CreateConnectionsListView(hwndDlg);

            UnHideControl( hwndDlg, IDD_DETACH);

            // List view fill defaults to no selected server, disable Detach.
            EnableWindow( GetDlgItem( hwndDlg, IDD_DETACH), FALSE);

            // Set up timer for automatic refresh interval
            ::SetTimer( hwndDlg, 1, GLOBAL_WHOAMI_REFRESH_INTERVAL, NULL);

            // Set focus to list box
            ::SetFocus( ::GetDlgItem( hwndDlg, IDD_GLOBAL_SERVERLIST));

            return FALSE;           /* we set the focus */
        }

        case WM_DESTROY:
            ::KillTimer( hwndDlg, 1);
            break;

        case WM_COMMAND:

            switch (wParam)
            {
                case IDOK:
                case IDCANCEL:
                    ::EndDialog( hwndDlg, FALSE);
                    return TRUE;        /* we processed a message */

                case IDD_DETACH:
                    // Attempt to detach server connection currently selected
                    if ( DetachResourceProc( hwndDlg ))
                    {
                        // If succeeded - refresh window
                        ::SendMessage(hwndDlg,WM_COMMAND,IDD_REFRESH,0L);
                    }

                    return TRUE;        /* we processed a message */

                case IDD_REFRESH:
                {
                    // Refresh connection listbox

                    HWND hwndLV = ::GetDlgItem( hwndDlg, IDD_GLOBAL_SERVERLIST);

                    ::SetFocus( hwndLV );

                    // Clear list
                    ListView_DeleteAllItems( hwndLV );

                    // Now refill list view window
                    FillConnectionsListView( hwndDlg );

                    // List view refill unsets selected server focus, disable Detach.
                    EnableWindow( GetDlgItem( hwndDlg, IDD_DETACH ), FALSE );

                    return TRUE;        /* we processed a message */
                }

                default:
                    break;
            }
            break;

        case WM_NOTIFY:
            // Handle notifications
            if ( NotifyHandler( hwndDlg, msg, wParam, lParam))
                return TRUE;        /* we processed a message */
            break;

        case WM_TIMER:
            ::SendMessage( hwndDlg, WM_COMMAND, IDD_REFRESH, 0L);
            break;

        case WM_HELP:
            ::WinHelp( (HWND) ((LPHELPINFO)lParam)->hItemHandle,
                       NW_HELP_FILE,
                       HELP_WM_HELP,
                       (DWORD_PTR) (LPVOID) aWhoAmIIds );
            return TRUE;

        case WM_CONTEXTMENU:
            ::WinHelp( (HWND) wParam,
                       NW_HELP_FILE,
                       HELP_CONTEXTMENU,
                       (DWORD_PTR) (LPVOID) aWhoAmIIds );
            return TRUE;

    }

    return FALSE;               /* we didn't process the message */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwshprop.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshprop.cxx

Abstract:

    This module implements the property pages of shell extension classes.

Author:

    Yi-Hsin Sung (yihsins)  25-Oct-1995

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <commctrl.h>
#include <shellapi.h>
#include <shlobj.h>
#define DONT_WANT_SHELLDEBUG
#include <shlobjp.h>

#include <nwapi32.h>
#include <ndsapi32.h>
#include <nwmisc.h>
#include  <nds.h>
//extern "C"
//{
#include "nwshrc.h"
#include "nwutil.h"
#include "drawpie.h"
//}

#include "nwshcmn.h"
#include "nwshext.h"


LPWSTR WINAPI AddCommas( DWORD dw, LPWSTR pszResult, DWORD dwSize );
LPWSTR WINAPI ShortSizeFormat64( ULONGLONG dw64, LPWSTR szBuf );

#define NAMESPACE_DOS       0
#define NAMESPACE_MAC       1
#define NAMESPACE_UNIX      2
#define NAMESPACE_FTAM      3
#define NAMESPACE_OS2       4


INT_PTR
CALLBACK
NDSPage_DlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam ,
    LPARAM lParam
);

INT_PTR
CALLBACK
NWPage_DlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam ,
    LPARAM lParam
);

//
//  FUNCTION: CNWObjContextMenu::AddPages(LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell just before the property sheet is displayed.
//
//  PARAMETERS:
//    lpfnAddPage -  Pointer to the Shell's AddPage function
//    lParam      -  Passed as second parameter to lpfnAddPage
//
//  RETURN VALUE:
//
//    NOERROR in all cases.  If for some reason our pages don't get added,
//    the Shell still needs to bring up the Properties... sheet.
//
//  COMMENTS:
//

STDMETHODIMP CNWObjContextMenu::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;

    if ( !::GetNetResourceFromShell( _pDataObj, pNetRes, sizeof( _buffer )))
    {
        // We could not get the net resource of the current object,
        // hence we could not add the property pages
        return NOERROR;
    }

    DWORD dwDialogId = 0;
    BOOL  fIsNds = NwIsNdsSyntax( pNetRes->lpRemoteName );

    switch ( pNetRes->dwDisplayType )
    {
        case RESOURCEDISPLAYTYPE_SERVER:
            dwDialogId = DLG_SERVER_SUMMARYINFO;
            break;

        case RESOURCEDISPLAYTYPE_NDSCONTAINER:
            break;

        case RESOURCEDISPLAYTYPE_TREE:
            // We need to set fIsNds to TRUE since a tree name "\\tree"
            // does not look like a NDS name
            // and hence NwIsNDsSyntax will return FALSE.
            fIsNds = TRUE;
            break;

        case RESOURCEDISPLAYTYPE_SHARE:
            if ( pNetRes->dwType == RESOURCETYPE_PRINT )
                dwDialogId = DLG_PRINTER_SUMMARYINFO;
            else
                dwDialogId = DLG_SHARE_SUMMARYINFO;
            break;

        case RESOURCEDISPLAYTYPE_ROOT:
        case RESOURCEDISPLAYTYPE_NETWORK:
        default:
            // No property page need to be added here. Just return success.
            return NOERROR;
    }

    if ( dwDialogId != 0 )
    {
        FillAndAddPage( lpfnAddPage, lParam,
                        ::NWPage_DlgProc,
                        MAKEINTRESOURCE( dwDialogId ));
    }

    // NOTE: Do we need to add another property page contain admin tools
    // for chicago peer servers? Probably not!

    if ( fIsNds )
    {
        FillAndAddPage( lpfnAddPage, lParam,
                        ::NDSPage_DlgProc,
                        pNetRes->dwDisplayType == RESOURCEDISPLAYTYPE_TREE ?
                            MAKEINTRESOURCE( DLG_NDS_SUMMARYINFO) :
                            MAKEINTRESOURCE( DLG_NDSCONT_SUMMARYINFO));

        // NOTE: Need to add a page for system policy here if the user has admin privileges
        // in the NDS tree.
    }

    return NOERROR;
}

//
//  FUNCTION: CNWObjContextMenu::ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell only for Control Panel property sheet
//           extensions
//
//  PARAMETERS:
//    uPageID         -  ID of page to be replaced
//    lpfnReplaceWith -  Pointer to the Shell's Replace function
//    lParam          -  Passed as second parameter to lpfnReplaceWith
//
//  RETURN VALUE:
//
//    E_NOTIMPL, since we don't support this function.  It should never be
//    called.

//  COMMENTS:
//

STDMETHODIMP CNWObjContextMenu::ReplacePage(UINT uPageID,
                                    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                    LPARAM lParam)
{
    return E_NOTIMPL;
}

VOID CNWObjContextMenu::FillAndAddPage( LPFNADDPROPSHEETPAGE lpfnAddPage,
                                        LPARAM  lParam,
                                        DLGPROC pfnDlgProc,
                                        LPWSTR  pszTemplate )
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);  // no extra data.
    psp.dwFlags     = PSP_USEREFPARENT;
    psp.hInstance   = ::hmodNW;
    psp.pfnDlgProc  = pfnDlgProc;
    psp.pcRefParent = (UINT *) &g_cRefThisDll;
    psp.pszTemplate = pszTemplate;
    psp.hIcon       = 0;
    psp.pszTitle    = NULL;
    psp.pfnCallback = NULL;

    psp.lParam      = (LPARAM) this;
    this->AddRef();

    hpage = CreatePropertySheetPage(&psp);

    if (hpage)
    {
        if (!lpfnAddPage(hpage, lParam))
            DestroyPropertySheetPage(hpage);
    }

}

// The following are arrays of help contexts for the property dialogs

static DWORD aServerIds[] = { IDD_SERVER_NAME        ,IDH_SERVERNAME,
                              IDD_SERVER_COMMENT_TXT ,IDH_COMMENT,
                              IDD_SERVER_COMMENT     ,IDH_COMMENT,
                              IDD_SERVER_VERSION_TXT ,IDH_VERSION,
                              IDD_SERVER_VERSION     ,IDH_VERSION,
                              IDD_SERVER_REVISION_TXT,IDH_REVISION,
                              IDD_SERVER_REVISION    ,IDH_REVISION,
                              IDD_SERVER_CONNECT_TXT ,IDH_CONNINUSE,
                              IDD_SERVER_CONNECT     ,IDH_CONNINUSE,
                              IDD_SERVER_MAXCON_TXT  ,IDH_MAXCONNS,
                              IDD_SERVER_MAXCON      ,IDH_MAXCONNS,
                              0, 0 };

static DWORD aPrinterIds[] = { IDD_PRINTER_NAME,       IDH_PRINTER_NAME,
                               IDD_PRINTER_QUEUE_TXT,  IDH_PRINTER_QUEUE,
                               IDD_PRINTER_QUEUE,      IDH_PRINTER_QUEUE,
                               0, 0 };

static DWORD aNDSIds[] = { IDD_NDS_NAME_TXT,    IDH_NDS_NAME,
                           IDD_NDS_NAME,        IDH_NDS_NAME,
                           IDD_NDS_CLASS_TXT,   IDH_NDS_CLASS,
                           IDD_NDS_CLASS,       IDH_NDS_CLASS,
                           IDD_NDS_COMMENT_TXT, IDH_NDS_COMMENT,
                           IDD_NDS_COMMENT,     IDH_NDS_COMMENT,
                           0, 0 };

static DWORD aShareIds[] = { IDD_SHARE_NAME,        IDH_SHARE_NAME,
                             IDD_SHARE_SERVER_TXT,  IDH_SHARE_SERVER,
                             IDD_SHARE_SERVER,      IDH_SHARE_SERVER,
                             IDD_SHARE_PATH_TXT,    IDH_SHARE_PATH,
                             IDD_SHARE_PATH,        IDH_SHARE_PATH,
                             IDD_SHARE_USED_SPC_CLR,IDH_SHARE_USED_SPC,
                             IDD_SHARE_USED_SPC_TXT,IDH_SHARE_USED_SPC,
                             IDD_SHARE_USED_SPC,    IDH_SHARE_USED_SPC,
                             IDD_SHARE_USED_SPC_MB, IDH_SHARE_USED_SPC,
                             IDD_SHARE_FREE_SPC_CLR,IDH_SHARE_FREE_SPC,
                             IDD_SHARE_FREE_SPC_TXT,IDH_SHARE_FREE_SPC,
                             IDD_SHARE_FREE_SPC,    IDH_SHARE_FREE_SPC,
                             IDD_SHARE_FREE_SPC_MB, IDH_SHARE_FREE_SPC,
                             IDD_SHARE_MAX_SPC_TXT, IDH_SHARE_MAX_SPC,
                             IDD_SHARE_MAX_SPC,     IDH_SHARE_MAX_SPC,
                             IDD_SHARE_MAX_SPC_MB,  IDH_SHARE_MAX_SPC,
                             IDD_SHARE_PIE,         IDH_SHARE_PIE,
                             IDD_SHARE_LFN_TXT,     IDH_SHARE_LFN_TXT,
                             0,0 };


#if 0
static DWORD aWGIds[] = { IDD_WRKGRP_NAME,       IDH_WRKGRP_NAME,
                          IDD_WRKGRP_TYPE_TXT,   IDH_WRKGRP_TYPE,
                          IDD_WRKGRP_TYPE,       IDH_WRKGRP_TYPE,
                          0, 0 };

static DWORD aNDSAdminIds[] = { IDD_ENABLE_SYSPOL,  IDH_ENABLE_SYSPOL,
                                IDD_VOLUME_LABEL,   IDH_VOLUME_LABEL,
                                IDD_VOLUME,         IDH_VOLUME,
                                IDD_DIRECTORY_LABEL,IDH_DIRECTORY_LABEL,
                                IDD_DIRECTORY,      IDH_DIRECTORY,
                                0, 0 };
#endif


void NDSPage_InitDialog(
    HWND hDlg,
    LPPROPSHEETPAGE psp
    )
{
    CNWObjContextMenu*  pPSClass = (CNWObjContextMenu*)psp->lParam;
    LPNETRESOURCE       pnr = NULL;
    DWORD               err = NO_ERROR;
    NTSTATUS            ntstatus = STATUS_SUCCESS;
    HANDLE              hTreeConn = NULL;

    if ( pPSClass )
        pnr = pPSClass->QueryNetResource();

    if ( pnr == NULL )
    {
        ASSERT(FALSE);

        // This should not happen. We can always get the net resource which is queried
        // during AddPages.
        return;
    }

    do {  // not a loop, just wanted to break on error

        LPWSTR pszRemoteName = pnr->lpRemoteName;

        if ( pszRemoteName[0] == L' ')   // tree names have a space in front " \\mardev"
            pszRemoteName++;

        if ( pnr->dwDisplayType == RESOURCEDISPLAYTYPE_TREE )
        {
            SetDlgItemText( hDlg, IDD_NDS_NAME, pszRemoteName + 2); // get past backslashes
        }
        else
        {

            //
            //  tommye - fix for bug 5005 - if this is a root server, then 
            //  there is no more \\ past the first, and the wcschr was returning
            //  NULL, causing an AV.  So, if this is a root object, then we'll
            //  just use that object name.
            //

            LPWSTR pName;

            pName = wcschr( pszRemoteName + 2, L'\\');
            if (pName) {
                ++pName;
            }
            else {
                pName = pszRemoteName + 2;
            }

            SetDlgItemText( hDlg, IDD_NDS_NAME, pName);
        }

        DWORD dwOid;

        err = NwOpenAndGetTreeInfo( pszRemoteName,
                                    &hTreeConn,
                                    &dwOid );

        if ( err != NO_ERROR )
        {
            break;
        }

        BYTE  RawResponse[TWO_KB];
        DWORD RawResponseSize = sizeof(RawResponse);

        ntstatus = NwNdsReadObjectInfo( hTreeConn,
                                        dwOid,
                                        RawResponse,
                                        RawResponseSize );

        if ( !NT_SUCCESS( ntstatus ))
        {
            err = RtlNtStatusToDosError(ntstatus);
            break;
        }

        LPBYTE pObjectClass = RawResponse;

        pObjectClass += sizeof( NDS_RESPONSE_GET_OBJECT_INFO ) + sizeof(DWORD);

        ::SetDlgItemText( hDlg, IDD_NDS_CLASS, (LPWSTR) pObjectClass );

        // NOTE: The description can only be read successfully with administrative privilege

        DWORD iterHandle = (DWORD) -1;
        UNICODE_STRING uAttrName;
        PNDS_RESPONSE_READ_ATTRIBUTE pReadAttrResponse = (PNDS_RESPONSE_READ_ATTRIBUTE) RawResponse;

        RtlInitUnicodeString( &uAttrName, L"Description");

        ntstatus = NwNdsReadAttribute( hTreeConn,
                                       dwOid,
                                       &iterHandle,
                                       &uAttrName,
                                       RawResponse,
                                       sizeof(RawResponse));

        if (  !NT_SUCCESS( ntstatus )
           || ( pReadAttrResponse->CompletionCode != 0 )
           || ( pReadAttrResponse->NumAttributes == 0 )
           )
        {
            // we don't need to set the error since this attribute can only be read by admins and
            // we might get an error indicating this.
            break;
        }

        PNDS_ATTRIBUTE pNdsAttribute = (PNDS_ATTRIBUTE)((DWORD_PTR) RawResponse+sizeof(NDS_RESPONSE_READ_ATTRIBUTE));

        LPWSTR pszComment = (LPWSTR) ((DWORD_PTR) pNdsAttribute + 3*sizeof(DWORD)
                                      + pNdsAttribute->AttribNameLength + sizeof(DWORD));
        ::SetDlgItemText(hDlg,IDD_NDS_COMMENT, pszComment);

    } while (FALSE);


    if ( hTreeConn )
        CloseHandle( hTreeConn );

    if ( err != NO_ERROR )
    {
        LPWSTR pszMessage = NULL;

        if ( ::LoadMsgErrorPrintf( &pszMessage,
                                   IDS_MESSAGE_GETINFO_ERROR,
                                   err ) == NO_ERROR )
        {
            UnHideControl( hDlg, IDD_ERROR );
            SetDlgItemText( hDlg, IDD_ERROR, pszMessage);
            ::LocalFree( pszMessage );
        }
    }

    return;
}

INT_PTR
CALLBACK
NDSPage_DlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam ,
    LPARAM lParam)
{

    LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)GetWindowLong(hDlg, DWLP_USER);

    switch (uMessage)
    {
        //
        //  When the shell creates a dialog box for a property sheet page,
        // it passes the pointer to the PROPSHEETPAGE data structure as
        // lParam. The dialog procedures of extensions typically store it
        // in the DWL_USER of the dialog box window.
        //
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            psp = (LPPROPSHEETPAGE)lParam;

            NDSPage_InitDialog( hDlg, psp);

            break;

        case WM_DESTROY:
        {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)(psp->lParam);

            if (pPSClass)
                pPSClass->Release();

            SetWindowLong(hDlg, DWLP_USER, NULL);
            break;
        }

        case WM_COMMAND:
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    CNWObjContextMenu *pPSClass =
                        (CNWObjContextMenu *)(psp->lParam);

                    pPSClass->_paHelpIds = aNDSIds;
                    break;
                }

                default:
                    break;
            }
            break;
        }

        case WM_HELP:
        {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)(psp->lParam);

            if ( pPSClass && pPSClass->_paHelpIds )
            {
                WinHelp( (HWND) ((LPHELPINFO)lParam)->hItemHandle,
                         NW_HELP_FILE,
                         HELP_WM_HELP,
                         (DWORD_PTR)(LPVOID)pPSClass->_paHelpIds );
            }
            break;
        }


        case WM_CONTEXTMENU:
        {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu*)(psp->lParam);

            if (pPSClass && pPSClass->_paHelpIds)
            {
                WinHelp( (HWND)wParam,
                         NW_HELP_FILE,
                         HELP_CONTEXTMENU,
                         (DWORD_PTR)(LPVOID)pPSClass->_paHelpIds );
            }
            break;
        }

        default:
            return FALSE;
    }

    return TRUE;

}

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)

void  Share_InitDialog(HWND hDlg, LPPROPSHEETPAGE psp)
{
    CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)psp->lParam;
    LPNETRESOURCE       pnr;
    DWORD               err = NO_ERROR;
    BOOL                fDirectoryMap = FALSE;

    if (pPSClass == NULL) {
        return;
    }

    pnr = pPSClass->QueryNetResource();

    if ( pnr == NULL )
    {
        ASSERT(FALSE);

        // This should not happen. We can always get the net resource which is queried
        // during AddPages.
        return;
    }

    do {  // not a loop, just wanted to break out if error occurred

        WCHAR szShare[MAX_PATH+1];
        WCHAR szServer[MAX_PATH+1] = L"";

        // Get the share name
        NwExtractShareName( pnr->lpRemoteName, szShare );
        SetDlgItemText( hDlg, IDD_SHARE_NAME, szShare );

        HideControl( hDlg, IDD_SHARE_PATH_TXT);
        HideControl( hDlg, IDD_SHARE_PATH);
        HideControl( hDlg, IDD_SHARE_LFN_TXT);

        // Get the server name
        if ( NwIsNdsSyntax( pnr->lpRemoteName ))
        {
            NTSTATUS ntstatus = STATUS_SUCCESS;
            HANDLE hTreeConn = NULL;
            DWORD dwOid;

            err = NwOpenAndGetTreeInfo( pnr->lpRemoteName,
                                        &hTreeConn,
                                        &dwOid );

            if ( err != NO_ERROR )
                break;

            BYTE  RawResponse[TWO_KB];
            DWORD RawResponseSize = sizeof(RawResponse);

            DWORD iterHandle = (DWORD) -1;
            UNICODE_STRING uAttrName;
            PNDS_RESPONSE_READ_ATTRIBUTE pReadAttrResponse = (PNDS_RESPONSE_READ_ATTRIBUTE) RawResponse;

            RtlInitUnicodeString( &uAttrName, L"Path");

            ntstatus = NwNdsReadAttribute( hTreeConn,
                                           dwOid,
                                           &iterHandle,
                                           &uAttrName,
                                           RawResponse,
                                           sizeof(RawResponse));

            CloseHandle( hTreeConn );
            hTreeConn = NULL;

            if (  NT_SUCCESS( ntstatus )
               && ( pReadAttrResponse->CompletionCode == 0 )
               && ( pReadAttrResponse->NumAttributes != 0 )
               )
            {
                // We are successful in reading the attribute. Hence this is a directory map.
                fDirectoryMap = TRUE;

                PNDS_ATTRIBUTE pNdsAttribute = (PNDS_ATTRIBUTE)((DWORD_PTR) RawResponse+sizeof(NDS_RESPONSE_READ_ATTRIBUTE));

                PDWORD pdwNameSpace = (PDWORD) ((DWORD_PTR) pNdsAttribute + 3*sizeof(DWORD)
                                                + pNdsAttribute->AttribNameLength
                                                + sizeof(WORD)   // need this due to bug in return value???
                                                + sizeof(DWORD));

                // See if the directory supports long file name
                // Only on directory map will Win95 show LFN support or not.
                if ( *pdwNameSpace == NAMESPACE_OS2 )
                {
                    UnHideControl( hDlg, IDD_SHARE_LFN_TXT );
                }

                // Now, try to get the volume the directory map is on
                PDWORD pdwVolumeLen = (PDWORD) ((DWORD_PTR) pdwNameSpace + sizeof(DWORD));
                LPWSTR pszVolume = (LPWSTR) ((DWORD_PTR) pdwNameSpace + 2*sizeof(DWORD));
                LPWSTR pszPath = (LPWSTR) ((DWORD_PTR) pszVolume + *pdwVolumeLen
                                           + sizeof(WORD)    // need this due to bug in return value???
                                           + sizeof(DWORD));


                WCHAR szFullPath[MAX_PATH+1];
                LPWSTR pszTemp;
                wcscpy( szFullPath, pnr->lpRemoteName );
                if ( pszTemp = wcschr( szFullPath + 2, L'\\'))
                    *(pszTemp + 1) = 0;

                wcscat( szFullPath, pszVolume );

                err = NwGetNdsVolumeInfo( szFullPath, szServer, sizeof(szServer), szShare, sizeof(szShare));


                // Now, display the path of the directory map
                if ( err == NO_ERROR )
                {
                    wcscpy( szFullPath, szShare );
                    wcscat( szFullPath, L"\\");
                    wcscat( szFullPath, pszPath );

                    UnHideControl(hDlg, IDD_SHARE_PATH_TXT);
                    UnHideControl(hDlg, IDD_SHARE_PATH);
                    SetDlgItemText( hDlg, IDD_SHARE_PATH, szFullPath );
                }
            }
            else  // this is a volume
            {

                // For NDS names, the unc path might not contain the server name.
                // So, we need to get the server name that this share is on.
                // Also, we need the original volume name like "SYS" instead of "MARS_SRV0_SYS"
                err = NwGetNdsVolumeInfo( pnr->lpRemoteName, szServer, sizeof(szServer), szShare, sizeof(szShare));
            }

            if ( err != NO_ERROR )
                break;
        }
        else  // in the form \\server\sys
        {
            NwExtractServerName( pnr->lpRemoteName, szServer );
        }

        SetDlgItemText( hDlg, IDD_SHARE_SERVER, szServer);

        NWCONN_HANDLE hConn = NULL;
        if ( NWCAttachToFileServerW( szServer, 0, &hConn ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        NWVOL_NUM nVolNum;
        char szAnsiShare[MAX_PATH+1];

        ::CharToOem( szShare, szAnsiShare );
        if ( NWCGetVolumeNumber( hConn, szAnsiShare, &nVolNum ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        DWORD           dwSectorSize = 0x200;

        DWORD           dwTotalBlocks = 0;
        DWORD           dwFreeBlocks = 0;
        DWORD           dwPurgeable = 0;
        DWORD           dwNotYetPurged = 0;
        DWORD           dwSectors= 0;
        DWORD           dwTotalDir= 0;
        DWORD           dwAvailDir= 0;

        ULONGLONG       qwTot = 0;
        ULONGLONG       qwFree = 0;

        WCHAR           szFormat[30];
        WCHAR           szTemp[80];
        WCHAR           szTemp2[30];


        // NOTE: 2.x servers does not support NWCGetVolumeUsage.
        // Hence, for 2.x servers, an error will always be shown

        if ( NWCGetVolumeUsage( hConn,
                                nVolNum,
                                &dwTotalBlocks,
                                &dwFreeBlocks,
                                &dwPurgeable,
                                &dwNotYetPurged,
                                &dwTotalDir,
                                &dwAvailDir,
                                (LPBYTE) &dwSectors ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        dwFreeBlocks += dwPurgeable;

        qwTot =  (ULONGLONG) dwSectorSize * (ULONGLONG) dwSectors * (ULONGLONG) dwTotalBlocks;

        qwFree = (ULONGLONG) dwSectorSize * (ULONGLONG) dwSectors * (ULONGLONG) dwFreeBlocks;

        if (::LoadString(::hmodNW, IDS_BYTES, szFormat, sizeof(szFormat)/sizeof(szFormat[0])))
        {
            if (!HIDWORD(qwTot-qwFree))
            {
                wsprintf(szTemp, szFormat, AddCommas(LODWORD(qwTot) - LODWORD(qwFree), szTemp2, sizeof(szTemp2)/sizeof(szTemp2[0])));
                SetDlgItemText(hDlg,IDD_SHARE_USED_SPC, szTemp);
            }

            if (!HIDWORD(qwFree))
            {
                wsprintf(szTemp, szFormat, AddCommas(LODWORD(qwFree), szTemp2, sizeof(szTemp2)/sizeof(szTemp2[0])));
                SetDlgItemText(hDlg, IDD_SHARE_FREE_SPC, szTemp);
            }

            if (!HIDWORD(qwTot))
            {
                wsprintf(szTemp, szFormat, AddCommas(LODWORD(qwTot), szTemp2, sizeof(szTemp2)/sizeof(szTemp2[0])));
                SetDlgItemText(hDlg, IDD_SHARE_MAX_SPC, szTemp);
            }
        }

        ShortSizeFormat64(qwTot-qwFree, szTemp);
        SetDlgItemText(hDlg, IDD_SHARE_USED_SPC_MB, szTemp);

        ShortSizeFormat64(qwFree, szTemp);
        SetDlgItemText(hDlg, IDD_SHARE_FREE_SPC_MB, szTemp);

        ShortSizeFormat64(qwTot, szTemp);
        SetDlgItemText(hDlg, IDD_SHARE_MAX_SPC_MB, szTemp);

        pPSClass->_fGotClusterInfo = TRUE;
        pPSClass->_dwTotal = dwTotalBlocks;
        pPSClass->_dwFree  = dwFreeBlocks;

        (VOID) NWCDetachFromFileServer( hConn );

    } while (FALSE);

    if ( err != NO_ERROR )
    {
        LPWSTR pszMessage = NULL;

        HideControl(hDlg, IDD_SHARE_USED_SPC_CLR);
        HideControl(hDlg, IDD_SHARE_USED_SPC_TXT);
        HideControl(hDlg, IDD_SHARE_USED_SPC);
        HideControl(hDlg, IDD_SHARE_USED_SPC_MB);

        HideControl(hDlg, IDD_SHARE_FREE_SPC_CLR);
        HideControl(hDlg, IDD_SHARE_FREE_SPC_TXT);
        HideControl(hDlg, IDD_SHARE_FREE_SPC);
        HideControl(hDlg, IDD_SHARE_FREE_SPC_MB);

        HideControl(hDlg, IDD_SHARE_MAX_SPC_TXT);
        HideControl(hDlg, IDD_SHARE_MAX_SPC);
        HideControl(hDlg, IDD_SHARE_MAX_SPC_MB);

        HideControl(hDlg, IDD_SHARE_PIE);

        if ( ::LoadMsgErrorPrintf( &pszMessage,
                                   IDS_MESSAGE_GETINFO_ERROR,
                                   err ) == NO_ERROR )
        {
            UnHideControl( hDlg, IDD_ERROR );
            SetDlgItemText( hDlg, IDD_ERROR, pszMessage);
            ::LocalFree( pszMessage );
        }
    }


} /* endproc Share_InitDialog */

void  Printer_InitDialog(HWND hDlg, LPPROPSHEETPAGE psp)
{
    CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)psp->lParam;
    LPNETRESOURCE       pnr;
    DWORD               err = NO_ERROR;

    if (pPSClass == NULL) {
        return;
    }
    pnr = pPSClass->QueryNetResource();

    if ( pnr == NULL )
    {
        ASSERT(FALSE);

        // This should not happen. We can always get the net resource which is queried
        // during AddPages.
        return;
    }

    do {  // not a loop, just wanted to break out if error occurred

        WCHAR szShare[MAX_PATH];
        NwExtractShareName( pnr->lpRemoteName, szShare );


        SetDlgItemText(hDlg,IDD_PRINTER_NAME, szShare);

        if ( NwIsNdsSyntax( pnr->lpRemoteName))
        {
            NTSTATUS ntstatus = STATUS_SUCCESS;
            HANDLE hTreeConn = NULL;
            DWORD dwOid;

            err = NwOpenAndGetTreeInfo( pnr->lpRemoteName,
                                        &hTreeConn,
                                        &dwOid );

            if ( err != NO_ERROR )
                break;

            BYTE  RawResponse[TWO_KB];
            DWORD RawResponseSize = sizeof(RawResponse);

            DWORD iterHandle = (DWORD) -1;
            UNICODE_STRING uAttrName;
            PNDS_RESPONSE_READ_ATTRIBUTE pReadAttrResponse = (PNDS_RESPONSE_READ_ATTRIBUTE) RawResponse;

            RtlInitUnicodeString( &uAttrName, L"Queue Directory");

            ntstatus = NwNdsReadAttribute( hTreeConn,
                                           dwOid,
                                           &iterHandle,
                                           &uAttrName,
                                           RawResponse,
                                           sizeof(RawResponse));

            CloseHandle( hTreeConn );
            hTreeConn = NULL;

            if (  !NT_SUCCESS( ntstatus )
               || ( pReadAttrResponse->CompletionCode != 0 )
               || ( pReadAttrResponse->NumAttributes == 0 )
               )
            {
                // we don't need to set the error since this attribute can only be read by admins and
                // we might get an error indicating this.
                break;
            }

            PNDS_ATTRIBUTE pNdsAttribute = (PNDS_ATTRIBUTE)((DWORD_PTR) RawResponse+sizeof(NDS_RESPONSE_READ_ATTRIBUTE));

            LPWSTR pszQueueFile = (LPWSTR) ((DWORD_PTR) pNdsAttribute + 3*sizeof(DWORD)
                                            + pNdsAttribute->AttribNameLength + sizeof(DWORD));
            ::SetDlgItemText( hDlg, IDD_PRINTER_QUEUE, pszQueueFile);
        }
        else  // bindery server
        {
            NWCONN_HANDLE hConn = NULL;
            WCHAR szServer[MAX_PATH+1];

            NwExtractServerName( pnr->lpRemoteName, szServer );

            if ( NWCAttachToFileServerW( szServer, 0, &hConn ) != SUCCESSFUL )
                err = GetLastError();

            if ( err == NO_ERROR )
            {
                char szAnsiShare[MAX_PATH+1];
                char Buffer[NW_DATA_SIZE];
                NWFLAGS ucMoreFlag, ucPropertyFlag;

                memset( Buffer, 0, sizeof(Buffer));
                ::CharToOem( szShare, szAnsiShare );

                if ( NWCReadPropertyValue( hConn,
                                           szAnsiShare,
                                           OT_PRINT_QUEUE,
                                           "Q_DIRECTORY",
                                           1,
                                           Buffer,
                                           &ucMoreFlag,
                                           &ucPropertyFlag ) != SUCCESSFUL )
                {
                    err = GetLastError();
                }

                if ( err == NO_ERROR )
                {
                    WCHAR uBuffer[NW_DATA_SIZE];

                    ::OemToCharBuff( Buffer, uBuffer, NW_DATA_SIZE );
                    uBuffer[NW_DATA_SIZE - 1] = '\0'; // make sure string is terminated

                    ::SetDlgItemText( hDlg, IDD_PRINTER_QUEUE, (LPWSTR) uBuffer);
                }
                else
                {
                    err = NO_ERROR;  // Only supervisor has read/write so don't show the error.
                }

                (VOID) NWCDetachFromFileServer( hConn );
            }
        }

    } while (FALSE);

    if ( err != NO_ERROR )
    {
        LPWSTR pszMessage = NULL;

        if ( ::LoadMsgErrorPrintf( &pszMessage,
                                   IDS_MESSAGE_GETINFO_ERROR,
                                   err ) == NO_ERROR )
        {
            UnHideControl( hDlg, IDD_ERROR );
            SetDlgItemText( hDlg, IDD_ERROR, pszMessage);
            ::LocalFree( pszMessage );
        }
    }

} /* endproc Printer_InitDialog */

void  Server_InitDialog(HWND hDlg, LPPROPSHEETPAGE psp)
{
    CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)psp->lParam;
    LPNETRESOURCE       pnr;
    DWORD               err = NO_ERROR;

    if (pPSClass == NULL) {
        return;
    }
    pnr = pPSClass->QueryNetResource();

    if ( pnr == NULL )
    {
        ASSERT(FALSE);

        // This should not happen. We can always get the net resource which is queried
        // during AddPages.
        return;
    }

    do {  // not a loop, just wanted to break out if error occurred

        WCHAR szServer[MAX_PATH];
        NwExtractServerName( pnr->lpRemoteName, szServer );

        SetDlgItemText( hDlg, IDD_SERVER_NAME, szServer );

        //
        // Get some server information
        //

        NWCONN_HANDLE hConn = NULL;
        if ( NWCAttachToFileServerW( szServer, 0, &hConn ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        VERSION_INFO vInfo;

        if ( NWCGetFileServerVersionInfo( hConn, &vInfo ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        WCHAR szTemp[512];
        char  szAnsiCompany[512];
        char  szAnsiVersion[512];
        char  szAnsiRevision[512];

        if ( NWCGetFileServerDescription( hConn, szAnsiCompany, szAnsiVersion,
                                          szAnsiRevision ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        // OemToChar( szAnsiCompany, szTemp );
        // wcscat( szTemp, L" " );
        // OemToChar( szAnsiVersion, szTemp + wcslen( szTemp ));

        OemToCharBuff( szAnsiVersion, szTemp, 512 );
        szTemp[511] = L'\0'; // make sure string is terminated

        ::SetDlgItemText( hDlg, IDD_SERVER_VERSION, szTemp);

        OemToCharBuff( szAnsiRevision, szTemp, 512 );
        szTemp[511] = L'\0'; // make sure string is terminated
        ::SetDlgItemText( hDlg, IDD_SERVER_REVISION, szTemp );

        WCHAR szNumber[12];

        ::wsprintf(szNumber,L"%d", vInfo.connsInUse );
        ::SetDlgItemText( hDlg, IDD_SERVER_CONNECT, szNumber);

        ::wsprintf(szNumber,L"%4d", vInfo.ConnsSupported);
        ::SetDlgItemText( hDlg, IDD_SERVER_MAXCON, szNumber);

        (VOID) NWCDetachFromFileServer( hConn );

#if 0
        // Now deal with Chicago specific fields
        if (pPSClass->_fIsPeerServer) {

            pXNCPResp pxresp = (pXNCPResp) pPSClass->_bufServerExInfo.QueryPtr(); ;
            pXGetServerInfoResp lpInfoPtr = (pXGetServerInfoResp)(pxresp+1);
            CHAR    szString[128];
            STRING  *pNWString;

            // Next field is workgroup name
            pNWString = (STRING *)(lpInfoPtr->passThruServer.str+lpInfoPtr->passThruServer.len);
            pNWString = (STRING *)(pNWString->str+pNWString->len);

            // And next after that is comment

            ::OemToCharBuff((LPCSTR)pNWString->str,szString,pNWString->len);
            szString[pNWString->len] = '\0';

            UnHideControl( hDlg, IDD_SERVER_COMMENT_TXT );
            UnHideControl( hDlg, IDD_SERVER_COMMENT );
            ::SetDlgItemText(hDlg,IDD_SERVER_COMMENT,szString);

        } else
#endif

    } while (FALSE);

    if ( err != NO_ERROR )
    {
        LPWSTR pszMessage = NULL;

        if ( ::LoadMsgErrorPrintf( &pszMessage,
                                   IDS_MESSAGE_GETINFO_ERROR,
                                   err ) == NO_ERROR )
        {
            UnHideControl( hDlg, IDD_ERROR );
            SetDlgItemText( hDlg, IDD_ERROR, pszMessage);
            ::LocalFree( pszMessage );
        }
    }

} /* endproc Server_InitDialog */

#if 0
void  Wrkgrp_InitDialog(HWND hDlg, LPPROPSHEETPAGE psp)
{

    CNWObjContextMenu  *pPSClass = (CNWObjContextMenu *)psp->lParam;
    LPNETRESOURCE       pnr;

    if ( pPSClass )
        pnr = (LPNETRESOURCE)pPSClass->_bufNR.QueryPtr();

    if ( pnr )
    {
        // Set name static control
        SetDlgItemText(hDlg,IDD_WRKGRP_NAME, pnr->lpRemoteName);
    }

}
#endif

COLORREF c_crPieColors[] =
{
    RGB(  0,   0, 255),  // Blue
    RGB(255,   0, 255),  // Red-Blue
    RGB(  0,   0, 128),  // 1/2 Blue
    RGB(128,   0, 128),  // 1/2 Red-Blue
} ;

void _DrvPrshtDrawItem(HWND hDlg, LPPROPSHEETPAGE psp, const DRAWITEMSTRUCT * lpdi)
{
    COLORREF crDraw;
    RECT     rcItem = lpdi->rcItem;
    HBRUSH   hbDraw, hbOld;
    SIZE     size;
    HDC      hDC;
    CNWObjContextMenu*    pPSClass = (CNWObjContextMenu *)psp->lParam;

    if (pPSClass->_fGotClusterInfo == FALSE)
        return;

    switch (lpdi->CtlID)
    {
    case IDD_SHARE_PIE:

        hDC = GetDC(hDlg);
        GetTextExtentPoint(hDC, L"W", 1, &size);
        ReleaseDC(hDlg, hDC);

        DrawPie(lpdi->hDC, &lpdi->rcItem,
            pPSClass->_dwTotal ? 1000*(pPSClass->_dwTotal-pPSClass->_dwFree)/pPSClass->_dwTotal : 1000,
            pPSClass->_dwFree==0 || pPSClass->_dwFree==pPSClass->_dwTotal,
            size.cy*2/3, c_crPieColors);

        break;

    case IDD_SHARE_USED_SPC_CLR:
        crDraw = c_crPieColors[DP_USEDCOLOR];
        goto DrawColor;

    case IDD_SHARE_FREE_SPC_CLR:
        crDraw = c_crPieColors[DP_FREECOLOR];
        goto DrawColor;

DrawColor:
        hbDraw = CreateSolidBrush(crDraw);
        if (hbDraw)
        {
            hbOld = (HBRUSH) SelectObject(lpdi->hDC, hbDraw);
            if (hbOld)
            {
                PatBlt(lpdi->hDC, rcItem.left, rcItem.top,
                    rcItem.right-rcItem.left,
                    rcItem.bottom-rcItem.top,
                    PATCOPY);

                SelectObject(lpdi->hDC, hbOld);
            }

            DeleteObject(hbDraw);
        }
        break;

    default:
        break;
    }
}


INT_PTR CALLBACK NWPage_DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam , LPARAM lParam)
{
   LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)GetWindowLong(hDlg, DWLP_USER);

   switch (uMessage)
   {
      //
      //  When the shell creates a dialog box for a property sheet page,
      // it passes the pointer to the PROPSHEETPAGE data structure as
      // lParam. The dialog procedures of extensions typically store it
      // in the DWLP_USER of the dialog box window.
      //
      case WM_INITDIALOG:
         SetWindowLongPtr(hDlg, DWLP_USER, lParam);
         psp = (LPPROPSHEETPAGE)lParam;

         if (psp->pszTemplate == MAKEINTRESOURCE(DLG_SERVER_SUMMARYINFO))
             Server_InitDialog(hDlg, psp);
         else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_SHARE_SUMMARYINFO))
             Share_InitDialog(hDlg, psp);
         else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_PRINTER_SUMMARYINFO))
             Printer_InitDialog(hDlg, psp);
#if 0
         else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_WRKGRP_SUMMARYINFO))
             Wrkgrp_InitDialog(hDlg, psp);
#endif

         break;

      case WM_DRAWITEM:
         _DrvPrshtDrawItem(hDlg, psp, (DRAWITEMSTRUCT *)lParam);
         break;

      case WM_DESTROY:
         {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)(psp->lParam);

            if (pPSClass) {
                pPSClass->Release();
            }

            SetWindowLong(hDlg, DWLP_USER, NULL);
         }
         break;

      case WM_COMMAND:
         break;

      case WM_NOTIFY:
         switch (((NMHDR *)lParam)->code) {
             case PSN_SETACTIVE:
             {
                 CNWObjContextMenu *pPSClass = (CNWObjContextMenu *)(psp->lParam);

                 if (psp->pszTemplate == MAKEINTRESOURCE(DLG_SERVER_SUMMARYINFO))
                     pPSClass->_paHelpIds = aServerIds;
                 else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_SHARE_SUMMARYINFO))
                     pPSClass->_paHelpIds = aShareIds;
                 else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_PRINTER_SUMMARYINFO))
                     pPSClass->_paHelpIds = aPrinterIds;
#if 0
                 else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_WRKGRP_SUMMARYINFO))
                     pPSClass->_paHelpIds = aWGIds;
#endif

                 break;
             }

             default:
                 break;
         }

         break;

      case WM_HELP:
        {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)(psp->lParam);

            if (pPSClass && pPSClass->_paHelpIds)
            {
                WinHelp( (HWND) ((LPHELPINFO)lParam)->hItemHandle,
                         NW_HELP_FILE,
                         HELP_WM_HELP,
                        (DWORD_PTR)(LPVOID)pPSClass->_paHelpIds );
            }
        }

        break;

      case WM_CONTEXTMENU:
        {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu*)(psp->lParam);

            if (pPSClass && pPSClass->_paHelpIds)
            {
                WinHelp( (HWND)wParam,
                         NW_HELP_FILE,
                         HELP_CONTEXTMENU,
                         (DWORD_PTR)(LPVOID)pPSClass->_paHelpIds );
            }
            break;
        }

      default:
        return(FALSE);
   }

   return(TRUE);

}

// Regular StrToInt; stops at first non-digit.
int WINAPI MyStrToInt(LPWSTR lpSrc) // atoi()
{

#define ISDIGIT(c)  ((c) >= '0' && (c) <= '9')

    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == L'-') {
        bNeg = TRUE;
    lpSrc++;
    }

    while (ISDIGIT(*lpSrc)) {
    n *= 10;
    n += *lpSrc - L'0';
    lpSrc++;
    }
    return bNeg ? -n : n;
}

// The following functions are stolen from win\core\shell\shelldll
// takes a DWORD add commas etc to it and puts the result in the buffer
LPWSTR WINAPI AddCommas( DWORD dw, LPWSTR pszResult, DWORD dwSize )
{
    WCHAR  szTemp[30];
    WCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, sizeof(szSep)/sizeof(szSep[0]));
    nfmt.Grouping = MyStrToInt(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, sizeof(szSep)/sizeof(szSep[0]));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

#pragma data_seg(".text", "CODE")
    wsprintf(szTemp, L"%lu", dw);
#pragma data_seg()

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, dwSize) == 0)
        lstrcpy(pszResult, szTemp);

    return pszResult;
}

const short pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB, IDS_ORDERGB, IDS_ORDERTB};

LPWSTR WINAPI ShortSizeFormat64(ULONGLONG dw64, LPWSTR szBuf)
{
    int i;
    UINT wInt, wLen, wDec;
    WCHAR szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000) {
#pragma data_seg(".text", "CODE")
        wsprintf(szTemp, L"%d", LODWORD(dw64));
#pragma data_seg()
        i = 0;
        goto AddOrder;
    }

    for (i = 1; i< sizeof(pwOrders)/sizeof(pwOrders[0])-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    AddCommas(wInt, szTemp, sizeof(szTemp)/sizeof(szTemp[0]));
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - (ULONGLONG)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
#pragma data_seg(".text", "CODE")
        lstrcpy(szFormat, L"%02d");
#pragma data_seg()

        szFormat[2] = L'0' + 3 - wLen;
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, sizeof(szTemp)/sizeof(szTemp[0])-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
    }

AddOrder:
    ::LoadString(::hmodNW, pwOrders[i], szOrder, sizeof(szOrder)/sizeof(szOrder[0]));
    wsprintf(szBuf, szOrder, (LPSTR)szTemp);

    return szBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwspl.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwspl.c

Abstract:

    This module contains the Netware print provider.

Author:

    Yi-Hsin Sung    (yihsins)   15-Apr-1993

Revision History:
    Yi-Hsin Sung    (yihsins)   15-May-1993
        Moved most of the functionality to the server side

    Ram Viswanathan (ramv)      09-Aug-1995
        Added functionality to Add and Delete Printer.


--*/

#include <stdio.h>

#include <nwclient.h>
#include <winspool.h>
#include <winsplp.h>
#include <ntlsa.h>

#include <nwpkstr.h>
#include <splutil.h>
#include <nwreg.h>
#include <nwspl.h>
#include <nwmisc.h>
#include <winsta.h>
#include  <nds.h>
#include <ndsapi32.h>
#include "nwutil.h"

#include <overflow.h>

//------------------------------------------------------------------
//
// Local Functions
//
//------------------------------------------------------------------
// now all SKUs have TerminalServer flag.  If App Server is enabled, SingleUserTS flag is cleared
#define IsTerminalServer() (BOOLEAN)(!(USER_SHARED_DATA->SuiteMask & (1 << SingleUserTS))) //user mode
DWORD
InitializePortNames(
    VOID
);

VOID
NwpGetUserInfo(
    LPWSTR *ppszUser
);

DWORD
NwpGetThreadUserInfo(
    LPWSTR  *ppszUser,
    LPWSTR  *ppszUserSid
);

DWORD
NwpGetUserNameFromSid(
    PSID pUserSid,
    LPWSTR *ppszUserName
);



DWORD
NwpGetLogonUserInfo(
    LPWSTR  *ppszUserSid
);


DWORD
ThreadIsInteractive(
    VOID
);

VOID
pFreeAllContexts();

//------------------------------------------------------------------
//
// Global Variables
//
//------------------------------------------------------------------

HMODULE hmodNW = NULL;
BOOL    fIsWinnt = FALSE ;

BOOL  bEnableAddPrinterConnection = FALSE;
BOOL  bRestrictToInboxDrivers = FALSE;
BOOL  bNeedAddPrinterConnCleanup = FALSE;

WCHAR *pszRegistryPath = NULL;
WCHAR *pszRegistryPortNames=L"PortNames";
WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 3];
PNWPORT pNwFirstPort = NULL;
CRITICAL_SECTION NwSplSem;
CRITICAL_SECTION NwServiceListCriticalSection; // Used to protect linked
                                               // list of registered services
HANDLE           NwServiceListDoneEvent = NULL;// Used to stop local advertise
                                               // threads.
STATIC HANDLE handleDummy;  // This is a dummy handle used to
                            // return to the clients if we have previously
                            // opened the given printer successfully
                            // and the netware workstation service is not
                            // currently available.

STATIC
PRINTPROVIDOR PrintProvidor = { OpenPrinter,
                                SetJob,
                                GetJob,
                                EnumJobs,
                                AddPrinter,                 // NOT SUPPORTED
                                DeletePrinter,              // NOT SUPPORTED
                                SetPrinter,
                                GetPrinter,
                                EnumPrinters,
                                AddPrinterDriver,           // NOT SUPPORTED
                                EnumPrinterDrivers,         // NOT SUPPORTED
                                GetPrinterDriverW,          // NOT SUPPORTED
                                GetPrinterDriverDirectory,  // NOT SUPPORTED
                                DeletePrinterDriver,        // NOT SUPPORTED
                                AddPrintProcessor,          // NOT SUPPORTED
                                EnumPrintProcessors,        // NOT SUPPORTED
                                GetPrintProcessorDirectory, // NOT SUPPORTED
                                DeletePrintProcessor,       // NOT SUPPORTED
                                EnumPrintProcessorDatatypes,// NOT SUPPORTED
                                StartDocPrinter,
                                StartPagePrinter,           // NOT SUPPORTED
                                WritePrinter,
                                EndPagePrinter,             // NOT SUPPORTED
                                AbortPrinter,
                                ReadPrinter,                // NOT SUPPORTED
                                EndDocPrinter,
                                AddJob,
                                ScheduleJob,
                                GetPrinterData,             // NOT SUPPORTED
                                SetPrinterData,             // NOT SUPPORTED
                                WaitForPrinterChange,
                                ClosePrinter,
                                AddForm,                    // NOT SUPPORTED
                                DeleteForm,                 // NOT SUPPORTED
                                GetForm,                    // NOT SUPPORTED
                                SetForm,                    // NOT SUPPORTED
                                EnumForms,                  // NOT SUPPORTED
                                EnumMonitors,               // NOT SUPPORTED
                                EnumPorts,
                                AddPort,                    // NOT SUPPORTED
                                ConfigurePort,
                                DeletePort,
                                CreatePrinterIC,            // NOT SUPPORTED
                                PlayGdiScriptOnPrinterIC,   // NOT SUPPORTED
                                DeletePrinterIC,            // NOT SUPPORTED
                                AddPrinterConnection,
                                DeletePrinterConnection,    // NOT SUPPORTED
                                PrinterMessageBox,          // NOT SUPPORTED
                                AddMonitor,                 // NOT SUPPORTED
                                DeleteMonitor               // NOT SUPPORTED
};


//------------------------------------------------------------------
//
//  Initialization Functions
//
//------------------------------------------------------------------


BOOL InitializeDll(
    HINSTANCE hdll,
    DWORD     dwReason,
    LPVOID    lpReserved
)
{
    NT_PRODUCT_TYPE ProductType ;

    UNREFERENCED_PARAMETER( lpReserved );

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        DisableThreadLibraryCalls( hdll );

        hmodNW = hdll;

        //
        // are we a winnt machine?
        //
        fIsWinnt = RtlGetNtProductType(&ProductType) ? 
                       (ProductType == NtProductWinNt) :
                       FALSE ;

        //
        // Initialize the critical section for maintaining the registered
        // service list
        //
        InitializeCriticalSection( &NwServiceListCriticalSection );
        NwServiceListDoneEvent = CreateEventA( NULL, TRUE, FALSE, NULL );
    }
    else if ( dwReason == DLL_PROCESS_DETACH )
    {
        //
        // Free up memories used by the port link list
        //
        DeleteAllPortEntries();

        //
        // Get rid of Service List and Shutdown SAP library
        //
        NwTerminateServiceProvider();

#ifndef NT1057
        //
        // Clean up shell extensions
        //
        NwCleanupShellExtensions();
#endif
        pFreeAllContexts();          // clean up RNR stuff
        DeleteCriticalSection( &NwServiceListCriticalSection );
        if ( NwServiceListDoneEvent )
        {
            CloseHandle( NwServiceListDoneEvent );
            NwServiceListDoneEvent = NULL;
        }
    }

    return TRUE;
}



DWORD
InitializePortNames(
    VOID
)
/*++

Routine Description:

    This is called by the InitializePrintProvidor to initialize the ports
    names used in this providor.

Arguments:

    None.

Return Value:

    Returns NO_ERROR or the error that occurred.

--*/
{
    DWORD err;
    HKEY  hkeyPath;
    HKEY  hkeyPortNames;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        pszRegistryPath,
                        0,
                        KEY_READ,
                        &hkeyPath );

    if ( !err )
    {
        DWORD BytesNeeded = sizeof( BOOL );

        err = RegQueryValueExW( hkeyPath,
                                L"EnableUserAddPrinter",
                                NULL,
                                NULL,
                                (LPBYTE) &bEnableAddPrinterConnection,
                                &BytesNeeded );
        if ( err ) // just default to not allowed
            bEnableAddPrinterConnection = FALSE;

        err = RegQueryValueExW( hkeyPath,
                                L"RestrictToInboxDrivers",
                                NULL,
                                NULL,
                                (LPBYTE) &bRestrictToInboxDrivers,
                                &BytesNeeded );
        if ( err ) // just default to not restricted
            bRestrictToInboxDrivers = FALSE;

        err = RegOpenKeyEx( hkeyPath,
                            pszRegistryPortNames,
                            0,
                            KEY_READ,
                            &hkeyPortNames );

        if ( !err )
        {
            DWORD i = 0;
            WCHAR Buffer[MAX_PATH];
            DWORD BufferSize;

            while ( !err )
            {
                BufferSize = sizeof(Buffer) / sizeof(WCHAR);

                err = RegEnumValue( hkeyPortNames,
                                    i,
                                    Buffer,
                                    &BufferSize,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL );

                if ( !err )
                    CreatePortEntry( Buffer );

                i++;
            }

            /* We expect RegEnumKeyEx to return ERROR_NO_MORE_ITEMS
             * when it gets to the end of the keys, so reset the status:
             */
            if( err == ERROR_NO_MORE_ITEMS )
                err = NO_ERROR;

            RegCloseKey( hkeyPortNames );
        }
#if DBG
        else
        {
            IF_DEBUG(PRINT)
                KdPrint(("NWSPL [RegOpenKeyEx] (%ws) failed: Error = %d\n",
                         pszRegistryPortNames, err ));
        }
#endif

        RegCloseKey( hkeyPath );
    }
#if DBG
    else
    {
        IF_DEBUG(PRINT)
            KdPrint(("NWSPL [RegOpenKeyEx] (%ws) failed: Error = %d\n",
                      pszRegistryPath, err ));
    }
#endif

    return err;
}

//------------------------------------------------------------------
//
// Print Provider Functions supported by NetWare provider
//
//------------------------------------------------------------------


BOOL
InitializePrintProvidor(
    LPPRINTPROVIDOR pPrintProvidor,
    DWORD           cbPrintProvidor,
    LPWSTR          pszFullRegistryPath
)
/*++

Routine Description:

    This is called by the spooler subsystem to initialize the print
    providor.

Arguments:

    pPrintProvidor      -  Pointer to the print providor structure to be
                           filled in by this function
    cbPrintProvidor     -  Count of bytes of the print providor structure
    pszFullRegistryPath -  Full path to the registry key of this print providor

Return Value:

    Always TRUE.

--*/
{
    //
    //  dfergus 20 Apr 2001 #323700
    //  Prevent Multiple CS Initialization
    //
    static int iCSInit = 0;

    DWORD dwLen;

    if ( !pPrintProvidor || !pszFullRegistryPath || !*pszFullRegistryPath )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    memcpy( pPrintProvidor,
            &PrintProvidor,
            min( sizeof(PRINTPROVIDOR), cbPrintProvidor) );

    //
    // Store the registry path for this print providor
    //
    if ( !(pszRegistryPath = AllocNwSplStr(pszFullRegistryPath)) )
        return FALSE;

    //
    // Store the local machine name
    //
    szMachineName[0] = szMachineName[1] = L'\\';
    dwLen = MAX_COMPUTERNAME_LENGTH;
    GetComputerName( szMachineName + 2, &dwLen );

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(("NWSPL [InitializePrintProvidor] "));
        KdPrint(("RegistryPath = %ws, ComputerName = %ws\n",
                 pszRegistryPath, szMachineName ));
    }
#endif

    //
    //  dfergus 20 Apr 2001 #323700
    //  Prevent Multiple CS Initialization
    //
    if( !iCSInit )
    {
        InitializeCriticalSection( &NwSplSem );
        iCSInit = 1;
    }
    //
    // Ignore the error returned from InitializePortNames.
    // The provider can still function if we cannot get all the port
    // names.
    //
    InitializePortNames();

    return TRUE;
}



BOOL
OpenPrinterW(
    LPWSTR             pszPrinterName,
    LPHANDLE           phPrinter,
    LPPRINTER_DEFAULTS pDefault
)
/*++

Routine Description:

    This routine retrieves a handle identifying the specified printer.

Arguments:

    pszPrinterName -  Name of the printer
    phPrinter      -  Receives the handle that identifies the given printer
    pDefault       -  Points to a PRINTER_DEFAULTS structure. Can be NULL.

Return Value:

    TRUE if the function succeeds, FALSE otherwise. Use GetLastError() for
    extended error information.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [OpenPrinter] Name = %ws\n", pszPrinterName ));
#endif

    UNREFERENCED_PARAMETER( pDefault );

    if ( !pszPrinterName )
    {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }

    RpcTryExcept
    {
        err = NwrOpenPrinter( NULL,
                              pszPrinterName,
                              PortKnown( pszPrinterName ),
                              (LPNWWKSTA_PRINTER_CONTEXT) phPrinter );

        //
        // Make sure there is a port of this name so that
        // EnumPorts will return it.
        //

        if ( !err )
        {

            if ( !PortExists( pszPrinterName, &err ) && !err )
            {
                //
                // We will ignore the errors since it is
                // still OK if we can't add the port.
                // Cannot delete once created, don't create
                // We should not create port entry and registry entry
               
                if ( CreatePortEntry( pszPrinterName ) )
                    CreateRegistryEntry( pszPrinterName );

            }

        }
        
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
        {
            if ( PortKnown( pszPrinterName ))
            {
                *phPrinter = &handleDummy;
                err = NO_ERROR;
            }
            else
            {
                err = ERROR_INVALID_NAME;
            }
        }
        else
        {
            err = NwpMapRpcError( code );
        }
    }
    RpcEndExcept

    if ( err )
    {
        SetLastError( err );

#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("NWSPL [OpenPrinter] err = %d\n", err));
#endif
    }

    return ( err == NO_ERROR );

}



BOOL
ClosePrinter(
    HANDLE  hPrinter
)
/*++

Routine Description:

    This routine closes the given printer object.

Arguments:

    hPrinter -  Handle of the printer object

Return Value:

    TRUE if the function succeeds, FALSE otherwise. Use GetLastError() for
    extended error information.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [ClosePrinter]\n"));
#endif

    //
    // Just return success if the handle is a dummy one
    //
    if ( hPrinter == &handleDummy )
        return TRUE;

    // Clean up any registry stuff left behind by AddPrinterConnection
    if ( bEnableAddPrinterConnection 
        && bNeedAddPrinterConnCleanup )
    {
        DWORD err;
        HKEY  hkey;
        HKEY  hSubKey;
        WCHAR * szConnKey = L"Printers\\Connections";
#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(("Cleaning up registry key %ws ...\n", szConnKey ));
    }
#endif
        err = RegOpenCurrentUser( KEY_ALL_ACCESS, &hkey );

        if ( err == ERROR_SUCCESS )
        {
            err = RegOpenKeyExW( hkey, szConnKey, 0, KEY_ALL_ACCESS, &hSubKey );
            if ( err == ERROR_SUCCESS )
            {
                WCHAR szKeyName[256];
                DWORD dwIndex = 0;
                DWORD dwSize;
                FILETIME keyModTime;
                HKEY hConnKey;
                WCHAR szProvider[64];

                dwSize = 256;
                err = RegEnumKeyEx(hSubKey, dwIndex,
                    szKeyName, &dwSize, NULL, NULL, NULL, &keyModTime);
                while (!err)
                {
                    dwIndex++;
                    err = RegOpenKeyExW( hSubKey, szKeyName, 
                        0, KEY_ALL_ACCESS, &hConnKey);
                    if (err)
                        break;
                    dwSize = 64 * sizeof(WCHAR);
                    err = RegQueryValueExW(hConnKey, L"Provider", NULL,
                        NULL, (LPBYTE) szProvider, &dwSize);
                    if (err)
                        szProvider[0] = 0;

                    if (lstrcmpi(szProvider, L"nwprovau.dll") == 0)
                    {
                        RegDeleteValueW( hConnKey, L"Provider" );
                        RegDeleteValueW( hConnKey, L"Server" );
                        RegCloseKey(hConnKey);
                        err = RegDeleteKeyW(hSubKey, szKeyName);
                        if (err == ERROR_SUCCESS)
                            bNeedAddPrinterConnCleanup = FALSE;
#if DBG
                        IF_DEBUG(PRINT)
                        {
                            if (err == ERROR_SUCCESS)
                                KdPrint(("    Deleted %ws\n", szKeyName));
                        }
#endif
                    }
                    else
                        RegCloseKey(hConnKey);
                    dwSize = 256;
                    err = RegEnumKeyEx(hSubKey, dwIndex,
                        szKeyName, &dwSize, NULL, NULL, NULL,  &keyModTime);
                }
                RegCloseKey( hSubKey );
            }
            RegCloseKey( hkey );
        }
    }

    RpcTryExcept
    {
        err = NwrClosePrinter( (LPNWWKSTA_PRINTER_CONTEXT) &hPrinter );
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
GetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
/*++

Routine Description:

    The routine retrieves information about the given printer.

Arguments:

    hPrinter  -  Handle of the printer
    dwLevel   -  Specifies the level of the structure to which pbPrinter points.
    pbPrinter -  Points to a buffer that receives the PRINTER_INFO object.
    cbBuf     -  Size, in bytes of the array pbPrinter points to.
    pcbNeeded -  Points to a value which specifies the number of bytes copied
                 if the function succeeds or the number of bytes required if
                 cbBuf was too small.

Return Value:

    TRUE if the function succeeds and FALSE otherwise.  GetLastError() can be
    used to retrieve extended error information.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [GetPrinter] Level = %d\n", dwLevel ));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if ( ( dwLevel != 1 ) && ( dwLevel != 2 ) && (dwLevel != 3 ))
    {
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    RpcTryExcept
    {
        err = NwrGetPrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                             dwLevel,
                             pbPrinter,
                             cbBuf,
                             pcbNeeded );

        if ( !err )
        {
            if ( dwLevel == 1 )
                MarshallUpStructure( pbPrinter, PrinterInfo1Offsets, pbPrinter);
            else
                MarshallUpStructure( pbPrinter, PrinterInfo2Offsets, pbPrinter);
        }

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
SetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbPrinter,
    DWORD   dwCommand
)
/*++

Routine Description:

    The routine sets the specified by pausing printing, resuming printing, or
    clearing all print jobs.

Arguments:

    hPrinter  -  Handle of the printer
    dwLevel   -  Specifies the level of the structure to which pbPrinter points.
    pbPrinter -  Points to a buffer that supplies the PRINTER_INFO object.
    dwCommand -  Specifies the new printer state.

Return Value:

    TRUE if the function succeeds and FALSE otherwise.  GetLastError() can be
    used to retrieve extended error information.

--*/
{
    DWORD err = NO_ERROR;

    UNREFERENCED_PARAMETER( pbPrinter );

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(( "NWSPL [SetPrinter] Level = %d Command = %d\n",
                  dwLevel, dwCommand ));
    }
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }

    switch ( dwLevel )
    {
        case 0:
        case 1:
        case 2:
        case 3:
            break;

        default:
            SetLastError( ERROR_INVALID_LEVEL );
            return FALSE;
    }

    RpcTryExcept
    {
        err = NwrSetPrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                             dwCommand );

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
EnumPrintersW(
    DWORD   dwFlags,
    LPWSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
/*++

Routine Description:

    This routine enumerates the available providers, servers, printers
    depending on the given pszName.

Arguments:

    dwFlags    -  Printer type requested
    pszName    -  The name of the container object
    dwLevel    -  The structure level requested
    pbPrinter  -  Points to the array to receive the PRINTER_INFO objects
    cbBuf      -  Size, in bytes of pbPrinter
    pcbNeeded  -  Count of bytes needed
    pcReturned -  Count of PRINTER_INFO objects

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD  err = NO_ERROR;

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(("NWSPL [EnumPrinters] Flags = %d Level = %d",dwFlags,dwLevel));
        if ( pszName )
            KdPrint((" PrinterName = %ws\n", pszName ));
        else
            KdPrint(("\n"));
    }
#endif

    if ( (dwLevel != 1) && (dwLevel != 2) )
    {
        SetLastError( ERROR_INVALID_NAME );  // should be level, but winspool
                                             // is silly.
        return FALSE;
    }
    else if ( !pcbNeeded || !pcReturned )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    RpcTryExcept
    {
        *pcReturned = 0;
        *pcbNeeded = 0;

        if (  ( dwFlags & PRINTER_ENUM_NAME )
           && ( dwLevel == 1 )
           )
        {
            err = NwrEnumPrinters( NULL,
                                   pszName,
                                   pbPrinter,
                                   cbBuf,
                                   pcbNeeded,
                                   pcReturned );

            if ( !err )
            {
                DWORD i;
                for ( i = 0; i < *pcReturned; i++ )
                     MarshallUpStructure( pbPrinter + i*sizeof(PRINTER_INFO_1W),
                                          PrinterInfo1Offsets,
                                          pbPrinter );
            }
        }
        else
        {
            err = ERROR_INVALID_NAME;
        }
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_NAME;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}


//
//  Handle structure
//  This structure was copied from \nw\svcdlls\nwwks\server\spool.c
//           to fix NT bug # 366632.
//
typedef struct _NWSPOOL {
    DWORD      nSignature;             // Signature
    DWORD      errOpenPrinter;         // OpenPrinter API will always return
                                       // success on known printers. This will
                                       // contain the error that we get
                                       // if something went wrong in the API.
    PVOID      pPrinter;               // Points to the corresponding printer
    HANDLE     hServer;                // Opened handle to the server
    struct _NWSPOOL  *pNextSpool;      // Points to the next handle
    DWORD      nStatus;                // Status
    DWORD      nJobNumber;             // StartDocPrinter/AddJob: Job Number
    HANDLE     hChangeEvent;           // WaitForPrinterChange: event to wait on
    DWORD      nWaitFlags;             // WaitForPrinterChange: flags to wait on
    DWORD      nChangeFlags;           // Changes that occurred to the printer
} NWSPOOL, *PNWSPOOL;



DWORD
StartDocPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  lpbDocInfo
)
/*++

Routine Description:

    This routine informs the print spooler that a document is to be spooled
    for printing.

Arguments:

    hPrinter   -  Handle of the printer
    dwLevel    -  Level of the structure pointed to by lpbDocInfo. Must be 1.
    lpbDocInfo -  Points to the DOC_INFO_1 object

Return Value:

    TRUE if the function succeeds, FALSE otherwise. The extended error
    can be retrieved through GetLastError().

--*/
{
    DWORD err;
    DOC_INFO_1 *pDocInfo1 = (DOC_INFO_1 *) lpbDocInfo;
    LPWSTR pszUser = NULL;

    DWORD PrintOption = NW_PRINT_OPTION_DEFAULT;
    LPWSTR pszPreferredSrv = NULL;  

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(( "NWSPL [StartDocPrinter] " ));
        if ( pDocInfo1 )
        {
            if ( pDocInfo1->pDocName )
                KdPrint(("Document %ws", pDocInfo1->pDocName ));
            if ( pDocInfo1->pOutputFile )
                KdPrint(("OutputFile %ws", pDocInfo1->pOutputFile ));
            if ( pDocInfo1->pDatatype )
                KdPrint(("Datatype %ws", pDocInfo1->pDatatype ));
        }
        KdPrint(("\n"));
    }
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if ( dwLevel != 1 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // ignore the error, just use default value
    NwpGetUserInfo( &pszUser );
    NwQueryInfo( &PrintOption, &pszPreferredSrv );  
    if (pszPreferredSrv) {
        LocalFree( pszPreferredSrv );
    }
    RpcTryExcept
    {
        err = NwrStartDocPrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                                  pDocInfo1? pDocInfo1->pDocName : NULL,
                                  pszUser, PrintOption);

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    LocalFree( pszUser );

    if ( err )
        SetLastError( err );
    //
    // Can't do this, seems to break GSWN printing on multi-homed machines
    // Commenting out code change that tries to return the job id.
    //
    // else
    //    return ((PNWSPOOL) hPrinter)->nJobNumber;

    return err == NO_ERROR;
}



BOOL
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcbWritten
)
/*++

Routine Description:

    This routine informs the print spooler that the specified data should be
    written to the given printer.

Arguments:

    hPrinter   -  Handle of the printer object
    pBuf       -  Address of array that contains printer data
    cbBuf      -  Size, in bytes of pBuf
    pcbWritten -  Receives the number of bytes actually written to the printer

Return Value:

    TRUE if it succeeds, FALSE otherwise. Use GetLastError() to get extended
    error.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [WritePrinter]\n"));

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
#endif

    RpcTryExcept
    {
        err = NwrWritePrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                               pBuf,
                               cbBuf,
                               pcbWritten );
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
AbortPrinter(
    HANDLE  hPrinter
)
/*++

Routine Description:

    This routine deletes a printer's spool file if the printer is configured
    for spooling.

Arguments:

    hPrinter - Handle of the printer object

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [AbortPrinter]\n"));

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
#endif

    RpcTryExcept
    {
        err = NwrAbortPrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter );
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
EndDocPrinter(
    HANDLE   hPrinter
)
/*++

Routine Description:

    This routine ends the print job for the given printer.

Arguments:

    hPrinter -  Handle of the printer object

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [EndDocPrinter]\n"));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }

    RpcTryExcept
    {
        err = NwrEndDocPrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter );
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
GetJob(
    HANDLE   hPrinter,
    DWORD    dwJobId,
    DWORD    dwLevel,
    LPBYTE   pbJob,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
/*++

Routine Description:

    This routine retrieves print-job data for the given printer.

Arguments:

    hPrinter  -  Handle of the printer
    dwJobId   -  Job identifition number
    dwLevel   -  Data structure level of pbJob
    pbJob     -  Address of data-structure array
    cbBuf     -  Count of bytes in array
    pcbNeeded -  Count of bytes retrieved or required

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetJob] JobId = %d Level = %d\n", dwJobId, dwLevel));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if (( dwLevel != 1 ) && ( dwLevel != 2 ))
    {
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    RpcTryExcept
    {
        err = NwrGetJob( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                         dwJobId,
                         dwLevel,
                         pbJob,
                         cbBuf,
                         pcbNeeded );

        if ( !err )
        {
            if ( dwLevel == 1 )
                MarshallUpStructure( pbJob, JobInfo1Offsets, pbJob );
            else
                MarshallUpStructure( pbJob, JobInfo2Offsets, pbJob );
        }
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
EnumJobs(
    HANDLE  hPrinter,
    DWORD   dwFirstJob,
    DWORD   dwNoJobs,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
/*++

Routine Description:

    This routine initializes the array of JOB_INFO_1 or JOB_INFO_2 structures
    with data describing the specified print jobs for the given printer.

Arguments:

    hPrinter    -  Handle of the printer
    dwFirstJob  -  Location of first job in the printer
    dwNoJobs    -  Number of jobs to enumerate
    dwLevel     -  Data structure level
    pbJob       -  Address of structure array
    cbBuf       -  Size of pbJob, in bytes
    pcbNeeded   -  Receives the number of bytes copied or required
    pcReturned  -  Receives the number of jobs copied

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumJobs] Level = %d FirstJob = %d NoJobs = %d\n",
                 dwLevel, dwFirstJob, dwNoJobs));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if ( ( dwLevel != 1 ) && ( dwLevel != 2 ) )
    {
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    RpcTryExcept
    {
        *pcReturned = 0;
        *pcbNeeded = 0;

        err = NwrEnumJobs( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                           dwFirstJob,
                           dwNoJobs,
                           dwLevel,
                           pbJob,
                           cbBuf,
                           pcbNeeded,
                           pcReturned );

        if ( !err )
        {
            DWORD i;
            DWORD cbStruct;
            DWORD_PTR *pOffsets;

            if ( dwLevel == 1 )
            {
                cbStruct = sizeof( JOB_INFO_1W );
                pOffsets = JobInfo1Offsets;
            }
            else  // dwLevel == 2
            {
                cbStruct = sizeof( JOB_INFO_2W );
                pOffsets = JobInfo2Offsets;
            }

            for ( i = 0; i < *pcReturned; i++ )
                 MarshallUpStructure( pbJob + i * cbStruct, pOffsets, pbJob );
        }

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
SetJob(
    HANDLE  hPrinter,
    DWORD   dwJobId,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   dwCommand
)
/*++

Routine Description:

    This routine pauses, cancels, resumes, restarts the specified print job
    in the given printer. The function can also be used to set print job
    parameters such as job position, and so on.

Arguments:

    hPrinter  -  Handle of the printer
    dwJobId   -  Job indentification number
    dwLevel   -  Data structure level
    pbJob     -  Address of data structure
    dwCommand -  Specify the operation to be performed

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(("NWSPL [SetJob] Level = %d JobId = %d Command = %d\n",
                 dwLevel, dwJobId, dwCommand));
    }
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if ( ( dwLevel != 0 ) && ( dwLevel != 1 ) && ( dwLevel != 2 ) )
    {
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }
    else if ( ( dwLevel == 0 ) && ( pbJob != NULL ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    RpcTryExcept
    {
        NW_JOB_INFO NwJobInfo;

        if ( dwLevel == 1 )
        {
            NwJobInfo.nPosition = ((LPJOB_INFO_1W) pbJob)->Position;
            NwJobInfo.pUserName = ((LPJOB_INFO_1W) pbJob)->pUserName;
            NwJobInfo.pDocument = ((LPJOB_INFO_1W) pbJob)->pDocument;
        }
        else if ( dwLevel == 2 )
        {
            NwJobInfo.nPosition = ((LPJOB_INFO_2W) pbJob)->Position;
            NwJobInfo.pUserName = ((LPJOB_INFO_2W) pbJob)->pUserName;
            NwJobInfo.pDocument = ((LPJOB_INFO_2W) pbJob)->pDocument;
        }

        err = NwrSetJob( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                         dwJobId,
                         dwLevel,
                         dwLevel == 0 ? NULL : &NwJobInfo,
                         dwCommand );

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
AddJob(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbAddJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
/*++

Routine Description:

    This routine returns a full path and filename of a file that can be used
    to store a print job.

Arguments:

    hPrinter  -  Handle of the printer
    dwLevel   -  Data structure level
    pbAddJob  -  Points to a ADD_INFO_1 structure
    cbBuf     -  Size of pbAddJob, in bytes
    pcbNeeded -  Receives the bytes copied or required

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

    ADDJOB_INFO_1W TempBuffer;
    PADDJOB_INFO_1W OutputBuffer;
    DWORD OutputBufferSize;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [AddJob]\n"));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if ( dwLevel != 1 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // The output buffer size must be at least the size of the fixed
    // portion of the structure marshalled by RPC or RPC will not
    // call the server-side to get the pcbNeeded.  Use our own temporary
    // buffer to force RPC to call the server-side if output buffer
    // specified by the caller is too small.
    //
    if (cbBuf < sizeof(ADDJOB_INFO_1W)) {
        OutputBuffer = &TempBuffer;
        OutputBufferSize = sizeof(ADDJOB_INFO_1W);
    }
    else {
        OutputBuffer = (LPADDJOB_INFO_1W) pbAddJob;
        OutputBufferSize = cbBuf;
    }

    RpcTryExcept
    {
        err = NwrAddJob( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                         OutputBuffer,
                         OutputBufferSize,
                         pcbNeeded );

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
ScheduleJob(
    HANDLE  hPrinter,
    DWORD   dwJobId
)
/*++

Routine Description:

    This routine informs the print spooler that the specified job can be
    scheduled for spooling.

Arguments:

    hPrinter -  Handle of the printer
    dwJobId  -  Job number that can be scheduled

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [ScheduleJob] JobId = %d\n", dwJobId ));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }

    RpcTryExcept
    {
        err = NwrScheduleJob( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                              dwJobId );

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



DWORD
WaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   dwFlags
)
/*++

Routine Description:

    This function returns when one or more requested changes occur on a
    print server or if the function times out.

Arguments:

    hPrinter -  Handle of the printer to wait on
    dwFlags  -  A bitmask that specifies the changes that the application
                wishes to be notified of.

Return Value:

    Return a bitmask that indicates the changes that occurred.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [WaitForPrinterChange] Flags = %d\n", dwFlags));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return 0;
    }

    RpcTryExcept
    {
        err = NwrWaitForPrinterChange( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                                       &dwFlags );

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
    {
        SetLastError( err );
        return 0;
    }

    return dwFlags;
}



BOOL
EnumPortsW(
    LPWSTR   pszName,
    DWORD    dwLevel,
    LPBYTE   pbPort,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
/*++

Routine Description:

    This function enumerates the ports available for printing on a
    specified server.

Arguments:

    pszName - Name of the server to enumerate on
    dwLevel - Structure level
    pbPort  - Address of array to receive the port information
    cbBuf   - Size, in bytes, of pbPort
    pcbNeeded  - Address to store the number of bytes needed or copied
    pcReturned - Address to store the number of entries copied

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err = NO_ERROR;
    DWORD cb = 0;
    PNWPORT pNwPort;
    LPPORT_INFO_1W pPortInfo1;
    LPBYTE pEnd = pbPort + cbBuf;
    LPBYTE pFixedDataEnd = pbPort;
    BOOL FitInBuffer;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumPorts]\n"));
#endif

    if ( dwLevel != 1 )
    {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }
    else if ( !IsLocalMachine( pszName ) )
    {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }

    EnterCriticalSection( &NwSplSem );

    pNwPort = pNwFirstPort;
    while ( pNwPort )
    {
        cb += sizeof(PORT_INFO_1W) + ( wcslen( pNwPort->pName)+1)*sizeof(WCHAR);
        pNwPort = pNwPort->pNext;
    }

    *pcbNeeded = cb;
    *pcReturned = 0;

    if ( cb <= cbBuf )
    {
        pEnd = pbPort + cbBuf;

        pNwPort = pNwFirstPort;
        while ( pNwPort )
        {
            pPortInfo1 = (LPPORT_INFO_1W) pFixedDataEnd;
            pFixedDataEnd += sizeof( PORT_INFO_1W );

            FitInBuffer = NwlibCopyStringToBuffer( pNwPort->pName,
                                                   wcslen( pNwPort->pName),
                                                   (LPCWSTR) pFixedDataEnd,
                                                   (LPWSTR *) &pEnd,
                                                   &pPortInfo1->pName );
            ASSERT( FitInBuffer );

            pNwPort = pNwPort->pNext;
            (*pcReturned)++;
        }
    }
    else
    {
        err = ERROR_INSUFFICIENT_BUFFER;
    }

    LeaveCriticalSection( &NwSplSem );

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
DeletePortW(
    LPWSTR  pszName,
    HWND    hWnd,
    LPWSTR  pszPortName
)
/*++

Routine Description:

    This routine deletes the port given on the server. A dialog can
    be displayed if needed.

Arguments:

    pszName - Name of the server for which the port should be deleted
    hWnd    - Parent window
    pszPortName - The name of the port to delete

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;
    BOOL fPortDeleted;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePort]\n"));
#endif

    if ( !IsLocalMachine( pszName ) )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    fPortDeleted = DeletePortEntry( pszPortName );

    if ( fPortDeleted )
    {
        err = DeleteRegistryEntry( pszPortName );
    }
    else
    {
        err = ERROR_UNKNOWN_PORT;
    }

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
ConfigurePortW(
    LPWSTR  pszName,
    HWND    hWnd,
    LPWSTR  pszPortName
)
/*++

Routine Description:

    This routine displays the port configuration dialog box
    for the given port on the given server.

Arguments:

    pszName - Name of the server on which the given port exist
    hWnd    - Parent window
    pszPortName - The name of the port to be configured

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD nCurrentThreadId;
    DWORD nWindowThreadId;
    WCHAR szCaption[MAX_PATH];
    WCHAR szMessage[MAX_PATH];

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [ConfigurePort] PortName = %ws\n", pszPortName));
#endif

    if ( !IsLocalMachine( pszName ) )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }
    else if ( !PortKnown( pszPortName ) )
    {
        SetLastError( ERROR_UNKNOWN_PORT );
        return FALSE;
    }

    nCurrentThreadId = GetCurrentThreadId();
    nWindowThreadId  = GetWindowThreadProcessId( hWnd, NULL );

    if ( !AttachThreadInput( nCurrentThreadId, nWindowThreadId, TRUE ))
        KdPrint(("[NWSPL] AttachThreadInput failed with %d.\n",GetLastError()));

    if ( LoadStringW( hmodNW,
                      IDS_NETWARE_PRINT_CAPTION,
                      szCaption,
                      sizeof( szCaption ) / sizeof( WCHAR )))
    {
        if ( LoadStringW( hmodNW,
                          IDS_NOTHING_TO_CONFIGURE,
                          szMessage,
                          sizeof( szMessage ) / sizeof( WCHAR )))
        {
            MessageBox( hWnd, szMessage, szCaption,
                        MB_OK | MB_ICONINFORMATION );
        }
        else
        {
            KdPrint(("[NWSPL] LoadString failed with %d.\n",GetLastError()));
        }
    }
    else
    {
        KdPrint(("[NWSPL] LoadString failed with %d.\n",GetLastError()));
    }

    if ( !AttachThreadInput( nCurrentThreadId, nWindowThreadId, FALSE ))
        KdPrint(("[NWSPL] DetachThreadInput failed with %d.\n",GetLastError()));

    return TRUE;
}

BOOL
AddPrinterConnectionW(
    LPWSTR  pszPrinterName
)
{
    DWORD err=0;
    LPHANDLE           phPrinter = NULL;
    LPPRINTER_DEFAULTS pDefault = NULL;
    LPTSTR pszDriverPrefix = L"PnP Driver:";
    HANDLE             hTreeConn = NULL;
    BYTE                RawResponse[4096];
    DWORD               RawResponseSize = sizeof(RawResponse);
    LPWSTR pszDescription = NULL;
    LPWSTR pszCurrPtr = NULL;
    BOOL bValidString = FALSE;

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(("NWSPL [AddPrinterConnection] PrinterName = %ws\n",
                pszPrinterName));
    }
#endif

    if ( !pszPrinterName )
    {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }

    // check registry for permission to add printers
    if ( !bEnableAddPrinterConnection )
    {
        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }
    else
    {
        // Read first value of Description attribute for "PnP Driver:Driver Name"
        DWORD               dwOid;
        NTSTATUS            ntstatus = STATUS_SUCCESS;
        LPBYTE              pObjectClass = RawResponse;
        DWORD               iterHandle = (DWORD) -1;
        UNICODE_STRING      uAttrName;
        PNDS_RESPONSE_READ_ATTRIBUTE pReadAttrResponse = (PNDS_RESPONSE_READ_ATTRIBUTE) RawResponse;
        PNDS_ATTRIBUTE pNdsAttribute = NULL;

        err = NwOpenAndGetTreeInfo( pszPrinterName,
                                    &hTreeConn,
                                    &dwOid );

        if ( err != NO_ERROR )
        {
            goto NDSExit;
        }

        RtlInitUnicodeString( &uAttrName, L"Description");

        ntstatus = NwNdsReadAttribute( hTreeConn,
                                       dwOid,
                                       &iterHandle,
                                       &uAttrName,
                                       RawResponse,
                                       sizeof(RawResponse));

        if (  !NT_SUCCESS( ntstatus )
           || ( pReadAttrResponse->CompletionCode != 0 )
           || ( pReadAttrResponse->NumAttributes == 0 )
           )
        {
            // we don't need to set the error since this attribute might be empty and
            // we might get an error indicating this.
            goto NDSExit;
        }

        pNdsAttribute = (PNDS_ATTRIBUTE)((DWORD_PTR) RawResponse+sizeof(NDS_RESPONSE_READ_ATTRIBUTE));

        pszDescription = (LPWSTR) ((DWORD_PTR) pNdsAttribute + 3*sizeof(DWORD)
                                      + pNdsAttribute->AttribNameLength + sizeof(DWORD));
        // NOTE: we only look at the first value
    }

NDSExit:

    if ( hTreeConn )
        CloseHandle( hTreeConn );

    if ( (pszDescription == NULL) || (*pszDescription == 0) )
    {
        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }

    // make sure Description is NULL terminated
    pszCurrPtr = pszDescription;
    while (pszCurrPtr < (WCHAR *)(RawResponse + RawResponseSize))
    {
        if (*pszCurrPtr == 0)
        {
            bValidString = TRUE;
            break;
        }
        pszCurrPtr++;
    }
    if (!bValidString)
    {
        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(("NWSPL [AddPrinterConnection] description=%ws\n", pszDescription));
    }
#endif
    if ( _wcsnicmp ( pszDriverPrefix, pszDescription, wcslen(pszDriverPrefix)) != 0 )
    {
        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }

    pszDescription += wcslen(pszDriverPrefix);
    if ( bRestrictToInboxDrivers )
    {
        LPWSTR pszSeparator = wcschr( pszDescription, L'@' );
        if ( pszSeparator )
            *pszSeparator = 0;
    }


    RpcTryExcept
    {
        err = NwrAddPrinterConnection(NULL, pszPrinterName, pszDescription);
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
        {
            err = ERROR_INVALID_NAME;
        }
        else
        {
            err = NwpMapRpcError( code );
        }
    }
    RpcEndExcept

    if ( err )
    {
        SetLastError( err );
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("NWSPL [AddPrinterConnection] err = %d\n", err));
#endif
        return FALSE;
    }
    bNeedAddPrinterConnCleanup = TRUE;

    return TRUE;
}

//------------------------------------------------------------------
//
// Print Provider Functions not supported by NetWare provider
//
//------------------------------------------------------------------

BOOL
EnumMonitorsW(
    LPWSTR   pszName,
    DWORD    dwLevel,
    LPBYTE   pbMonitor,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumMonitors]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}


BOOL
AddPortW(
    LPWSTR  pszName,
    HWND    hWnd,
    LPWSTR  pszMonitorName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddPort]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


HANDLE
AddPrinterW(
    LPWSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbPrinter
)

// Creates a print queue on the netware server and returns a handle to it
{
#ifdef NOT_USED

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddPrinterW]\n"));
#endif

    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
#else

   LPTSTR     pszPrinterName = NULL;
   LPTSTR     pszPServer = NULL;
   LPTSTR     pszQueue  =  NULL;
   HANDLE     hPrinter = NULL;
   DWORD      err;
   PPRINTER_INFO_2 pPrinterInfo;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddPrinterW]\n"));
#endif

   pPrinterInfo = (PPRINTER_INFO_2)pbPrinter;  

   
   if (dwLevel != 2)
      {
        err = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
      }


   if (!(pszPrinterName = (LPTSTR)LocalAlloc(LPTR, (wcslen(((PRINTER_INFO_2 *)pbPrinter)->pPrinterName)+1)* sizeof(WCHAR))))
      {
         err = ERROR_NOT_ENOUGH_MEMORY; 
         goto ErrorExit;
      }

      wcscpy(pszPrinterName,pPrinterInfo->pPrinterName);

   // PrinterName is the name represented as \\server\share
  //The pszPServer parameter could have multiple fields separated by semicolons

   
       if (  ( !ValidateUNCName( pszPrinterName ) )
       || ( (pszQueue = wcschr( pszPrinterName + 2, L'\\')) == NULL )
       || ( pszQueue == (pszPrinterName + 2) )
       || ( *(pszQueue + 1) == L'\0' )
       )
          {
             err =  ERROR_INVALID_NAME;
             goto ErrorExit;
          }
      


#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [AddPrinter] Name = %ws\n",pszPServer));
#endif

   if ( pszPrinterName == NULL  ) 
//PrinterName is a mandatory field but not the list of PServers
    {
#if DBG
            IF_DEBUG(PRINT)
            KdPrint(( "NWSPL [AddPrinter] Printername  not supplied\n" ));
#endif

        SetLastError( ERROR_INVALID_NAME );
        goto ErrorExit;
    }

   //Check to see if there is a port of the same name
   // If so, abort the addprinter operation. 
   // This code was commented earlier 

      if (PortExists(pszPrinterName, &err ) && !err )
         {
#if DBG
            IF_DEBUG(PRINT)
            KdPrint(( "NWSPL [AddPrinter], = %ws; Port exists with same name\n", pszPrinterName ));
#endif
            SetLastError(ERROR_ALREADY_ASSIGNED);
            goto ErrorExit;
         }
         

   // Put all the relevant information into the PRINTER_INFO_2 structure

    RpcTryExcept
    {
       err = NwrAddPrinter   ( NULL, 
                               (LPPRINTER_INFO_2W) pPrinterInfo,
                               (LPNWWKSTA_PRINTER_CONTEXT) &hPrinter
                             );
       if (!err)
       {
#if DBG
         IF_DEBUG(PRINT)
          KdPrint(( "NWSPL [AddPrinter] Name = %ws\n", pszPrinterName ));
#endif
    goto ErrorExit;
       }
    }
   RpcExcept(1)
   {
      DWORD code = RpcExceptionCode();
      err = NwpMapRpcError( code );
      goto ErrorExit;
   }
   RpcEndExcept
   if ( !pszPrinterName) 
      (void)  LocalFree((HLOCAL)pszPrinterName);
   
   return hPrinter;

ErrorExit:
    if ( !pszPrinterName) 
    (void)  LocalFree((HLOCAL)pszPrinterName);

         SetLastError( err);
    return (HANDLE)0x0;      
 
#endif // #ifdef NOT_USED
}

BOOL
DeletePrinter(
    HANDLE  hPrinter
)
{
#ifdef NOT_USED

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrinter]\n"));
#endif

    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
#else
   LPWSTR pszPrinterName = NULL ; // Used to delete entry from registry
   DWORD err = NO_ERROR;
   DWORD DoesPortExist;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrinter]\n"));
#endif

    pszPrinterName = (LPWSTR)LocalAlloc(LPTR,sizeof(WCHAR)*MAX_PATH);

   if(pszPrinterName == NULL)
      {
         err = ERROR_NOT_ENOUGH_MEMORY;
         return FALSE;
      }
   //
   // Just return success if the handle is a dummy one
   //
   if ( hPrinter == &handleDummy )
       {
#if DBG
          IF_DEBUG(PRINT)
          KdPrint(("NWSPL [DeletePrinter] Dummy handle \n"));
#endif
          SetLastError(ERROR_NO_NETWORK);
          return FALSE;
       }
    RpcTryExcept
    {  


        err = NwrDeletePrinter( NULL,
           // pszPrinterName,
                    (LPNWWKSTA_PRINTER_CONTEXT) &hPrinter );
        
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept
 
        if (!err && PortExists(pszPrinterName, &DoesPortExist) && DoesPortExist)
           {  
              
              if ( DeleteRegistryEntry (pszPrinterName))
                  (void) DeletePortEntry(pszPrinterName);
                  
           }
          
 
    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

#endif // #ifdef NOT_USED
}


BOOL
DeletePrinterConnectionW(
    LPWSTR  pszName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrinterConnection]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}


BOOL
AddPrinterDriverW(
    LPWSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbPrinter
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddPrinterDriver]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
EnumPrinterDriversW(
    LPWSTR   pszName,
    LPWSTR   pszEnvironment,
    DWORD    dwLevel,
    LPBYTE   pbDriverInfo,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumPrinterDrivers]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
GetPrinterDriverW(
    HANDLE   hPrinter,
    LPWSTR   pszEnvironment,
    DWORD    dwLevel,
    LPBYTE   pbDriverInfo,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetPrinterDriver]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
GetPrinterDriverDirectoryW(
    LPWSTR   pszName,
    LPWSTR   pszEnvironment,
    DWORD    dwLevel,
    LPBYTE   pbDriverDirectory,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetPrinterDriverDirectory]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
DeletePrinterDriverW(
    LPWSTR  pszName,
    LPWSTR  pszEnvironment,
    LPWSTR  pszDriverName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrinterDriver]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
AddPrintProcessorW(
    LPWSTR  pszName,
    LPWSTR  pszEnvironment,
    LPWSTR  pszPathName,
    LPWSTR  pszPrintProcessorName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddPrintProcessor]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
EnumPrintProcessorsW(
    LPWSTR   pszName,
    LPWSTR   pszEnvironment,
    DWORD    dwLevel,
    LPBYTE   pbPrintProcessorInfo,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumPrintProcessors]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
EnumPrintProcessorDatatypesW(
    LPWSTR   pszName,
    LPWSTR   pszPrintProcessorName,
    DWORD    dwLevel,
    LPBYTE   pbDatatypes,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumPrintProcessorDatatypes]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
GetPrintProcessorDirectoryW(
    LPWSTR   pszName,
    LPWSTR   pszEnvironment,
    DWORD    dwLevel,
    LPBYTE   pbPrintProcessorDirectory,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetPrintProcessorDirectory]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
StartPagePrinter(
    HANDLE  hPrinter
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [StartPagePrinter]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
EndPagePrinter(
    HANDLE  hPrinter
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EndPagePrinter]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
ReadPrinter(
    HANDLE   hPrinter,
    LPVOID   pBuf,
    DWORD    cbBuf,
    LPDWORD  pcbRead
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [ReadPrinter]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

DWORD
GetPrinterDataW(
    HANDLE   hPrinter,
    LPWSTR   pszValueName,
    LPDWORD  pdwType,
    LPBYTE   pbData,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetPrinterData]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

DWORD
SetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pszValueName,
    DWORD   dwType,
    LPBYTE  pbData,
    DWORD   cbData
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [SetPrinterData]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
AddForm(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbForm
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddForm]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
DeleteFormW(
    HANDLE  hPrinter,
    LPWSTR  pszFormName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeleteForm]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
GetFormW(
    HANDLE   hPrinter,
    LPWSTR   pszFormName,
    DWORD    dwLevel,
    LPBYTE   pbForm,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetForm]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
SetFormW(
    HANDLE  hPrinter,
    LPWSTR  pszFormName,
    DWORD   dwLevel,
    LPBYTE  pbForm
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [SetForm]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
EnumForms(
    HANDLE   hPrinter,
    DWORD    dwLevel,
    LPBYTE   pbForm,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumForms]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


HANDLE
CreatePrinterIC(
    HANDLE     hPrinter,
    LPDEVMODE  pDevMode
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [CreatePrinterIC]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
PlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pbIn,
    DWORD   cbIn,
    LPBYTE  pbOut,
    DWORD   cbOut,
    DWORD   ul
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [PlayGdiScriptOnPrinterIC]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
DeletePrinterIC(
    HANDLE  hPrinterIC
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrinterIC]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

DWORD
PrinterMessageBoxW(
    HANDLE  hPrinter,
    DWORD   dwError,
    HWND    hWnd,
    LPWSTR  pszText,
    LPWSTR  pszCaption,
    DWORD   dwType
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [PrinterMessageBox]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
AddMonitorW(
    LPWSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbMonitorInfo
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddMonitor]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
DeleteMonitorW(
    LPWSTR  pszName,
    LPWSTR  pszEnvironment,
    LPWSTR  pszMonitorName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeleteMonitor]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
DeletePrintProcessorW(
    LPWSTR  pszName,
    LPWSTR  pszEnvironment,
    LPWSTR  pszPrintProcessorName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrintProcessor]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

//------------------------------------------------------------------
//
// Print Provider Miscellaneous Functions
//
//------------------------------------------------------------------

VOID
NwpGetUserInfo(
    LPWSTR *ppszUser
)
/*++

Routine Description:

    Get the user information of the impersonating client. 

Arguments:

    ppszUser - A pointer to buffer to store the Unicode string if 
               the impersonated client's user name can be looked up
               successfully. If the conversion was unsuccessful, it points 
               to NULL.

Return Value:

    None.

--*/
{
    DWORD err;
    LPWSTR pszUserSid = NULL;
 //   LPWSTR pszLogonUserSid = NULL;    //Removed for Multi-user code merge
                                        //Terminal Server doesn't user this varible
                                        //There is no single "Logon User" in Terminal Server

    //
    // If any error occurs while trying to get the username, just
    // assume no user name and not gateway printing.
    //
    *ppszUser = NULL;

    if (  ((err = NwpGetThreadUserInfo( ppszUser, &pszUserSid )) == NO_ERROR)
//          && ((err = NwpGetLogonUserInfo( &pszLogonUserSid ))) == NO_ERROR) //Removed from Multi-user code merge
       ) {

#if DBG
            IF_DEBUG(PRINT)
            KdPrint(("NwpGetUserInfo: Thread User= %ws, Thread SID = %ws,\n",
                     *ppszUser, pszUserSid ));
#endif

//        } else {
//            if ( _wcsicmp( pszUserSid, pszLogonUserSid ) == 0 ) {
//            }

//#if DBG
//            IF_DEBUG(PRINT)
//            KdPrint(("NwpGetUserInfo: Thread User= %ws, Thread SID = %ws,\nCurrent SID = %ws\n",
//                     *ppszUser, pszUserSid, pszLogonUserSid ));
//#endif
//        }

        LocalFree( pszUserSid );
    }

}

#define SIZE_OF_TOKEN_INFORMATION   \
     sizeof( TOKEN_USER )               \
     + sizeof( SID )                    \
     + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

DWORD
NwpGetThreadUserInfo(
    LPWSTR  *ppszUser,
    LPWSTR  *ppszUserSid
)
/*++

Routine Description:

    Get the user name and user sid string of the impersonating client.

Arguments:

    ppszUser - A pointer to buffer to store the Unicode string 
               if the impersonated client's can be looked up. If the
               lookup was unsuccessful, it points to NULL.

    ppszUserSid - A pointer to buffer to store the string if the impersonated
               client's SID can be expanded successfully into unicode string.
               If the conversion was unsuccessful, it points to NULL.

Return Value:

    The error code.

--*/
{
    DWORD       err;
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG       ReturnLength;

    *ppszUser = NULL;
    *ppszUserSid = NULL;

    // We can use OpenThreadToken because this server thread
    // is impersonating a client

    if ( !OpenThreadToken( GetCurrentThread(),
                           TOKEN_READ,
                           TRUE,  /* Open as self */
                           &TokenHandle ))
    {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("NwpGetThreadUserInfo: OpenThreadToken failed: Error %d\n",
                      GetLastError()));
#endif
        return(GetLastError());
    }

    // notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure


    if ( !GetTokenInformation( TokenHandle,
                               TokenUser,
                               TokenInformation,
                               sizeof( TokenInformation ),
                               &ReturnLength ))
    {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("NwpGetThreadUserInfo: GetTokenInformation failed: Error %d\n",
                      GetLastError()));
#endif
        return(GetLastError());
    }

    CloseHandle( TokenHandle );

    // convert the Sid (pointed to by pSid) to its
    // equivalent Unicode string representation.

    err = NwpGetUserNameFromSid( ((PTOKEN_USER)TokenInformation)->User.Sid,
                                  ppszUser );
    err = err? err : NwpConvertSid( ((PTOKEN_USER)TokenInformation)->User.Sid,
                                    ppszUserSid );

    if ( err )
    {
        if ( *ppszUser )
            LocalFree( *ppszUser );

        if ( *ppszUserSid )
            LocalFree( *ppszUserSid );
    }

    return err;
}

DWORD
NwpGetUserNameFromSid(
    PSID pUserSid,
    LPWSTR *ppszUserName
)
/*++

Routine Description:

    Lookup the user name given the user SID.

Arguments:

    pUserSid - Points to the user sid to be looked up

    ppszUserName - A pointer to buffer to store the string if the impersonated
               client's SID can be expanded successfully into unicode string.
               If the conversion was unsuccessful, it points to NULL.

Return Value:

    The error code.

--*/
{
    NTSTATUS ntstatus;

    LSA_HANDLE hlsa;
    OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    PLSA_REFERENCED_DOMAIN_LIST plsardl = NULL;
    PLSA_TRANSLATED_NAME plsatn = NULL;

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;
    InitializeObjectAttributes( &oa, NULL, 0L, NULL, NULL );
    oa.SecurityQualityOfService = &sqos;

    ntstatus = LsaOpenPolicy( NULL,
                              &oa,
                              POLICY_LOOKUP_NAMES,
                              &hlsa );

    if ( NT_SUCCESS( ntstatus ))
    {
        ntstatus = LsaLookupSids( hlsa,
                                  1,
                                  &pUserSid,
                                  &plsardl,
                                  &plsatn );

        if ( NT_SUCCESS( ntstatus ))
        {
            UNICODE_STRING *pUnicodeStr = &((*plsatn).Name);

            *ppszUserName = LocalAlloc( LMEM_ZEROINIT, 
                                        pUnicodeStr->Length+sizeof(WCHAR));

            if ( *ppszUserName != NULL )
            {
                memcpy( *ppszUserName, pUnicodeStr->Buffer, pUnicodeStr->Length );
            }
            else
            {
                ntstatus = STATUS_NO_MEMORY;
            }

            LsaFreeMemory( plsardl );
            LsaFreeMemory( plsatn );
        }
#if DBG
        else
        {
            KdPrint(("NwpGetUserNameFromSid: LsaLookupSids failed: Error = %d\n",
                    GetLastError()));
        }
#endif

        LsaClose( hlsa );
     }
#if DBG
     else
     {
        KdPrint(("NwpGetUserNameFromSid: LsaOpenPolicy failed: Error = %d\n",
                GetLastError()));
     }
#endif

    return RtlNtStatusToDosError( ntstatus );

}

DWORD
NwpGetLogonUserInfo(
    LPWSTR  *ppszUserSid
)
/*++

Routine Description:

    Get the logon user sid string from the registry.

Arguments:

    ppszUserSid - On return, this points to the current logon user
                  sid string. 

Return Value:

    The error code.

--*/
{
    DWORD err;
    HKEY WkstaKey;

    LPWSTR CurrentUser = NULL;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters to get the sid of the CurrentUser
    //
    err = RegOpenKeyExW(
              HKEY_LOCAL_MACHINE,
              NW_WORKSTATION_REGKEY,
              REG_OPTION_NON_VOLATILE,
              KEY_READ,
              &WkstaKey
              );

    if ( err == NO_ERROR) {

        //
        // Read the current user SID string so that we
        // know which key is the current user key to open.
        //
        err = NwReadRegValue(
                  WkstaKey,
                  NW_CURRENTUSER_VALUENAME,
                  &CurrentUser
                  );

        RegCloseKey( WkstaKey );

        if ( err == NO_ERROR) {
           *ppszUserSid = CurrentUser;
        }
    }

    return(err);
}


#define SIZE_OF_STATISTICS_TOKEN_INFORMATION    \
     sizeof( TOKEN_STATISTICS ) 

DWORD
ThreadIsInteractive(
    VOID
)
/*++

Routine Description:

    Determines if this is an "Interactive" logon thread

Arguments:

    none

Return Value:

    TRUE - Thread is interactive
    FALSE - Thread is not interactive

--*/
{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_STATISTICS_TOKEN_INFORMATION ];
    WCHAR       LogonIdKeyName[NW_MAX_LOGON_ID_LEN];

    ULONG       ReturnLength;
    LUID        LogonId;
    LONG        RegError;
    HKEY        InteractiveLogonKey;
    HKEY        OneLogonKey;


    // We can use OpenThreadToken because this server thread
    // is impersonating a client

    if ( !OpenThreadToken( GetCurrentThread(),
                           TOKEN_READ,
                           TRUE,  /* Open as self */
                           &TokenHandle ))
    {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("ThreadIsInteractive: OpenThreadToken failed: Error %d\n",
                      GetLastError()));
#endif
        return FALSE;
    }

    // notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure


    if ( !GetTokenInformation( TokenHandle,
                               TokenStatistics,
                               TokenInformation,
                               sizeof( TokenInformation ),
                               &ReturnLength ))
    {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("ThreadIsInteractive: GetTokenInformation failed: Error %d\n",
                      GetLastError()));
#endif
        return FALSE;
    }

    CloseHandle( TokenHandle );

    LogonId = ((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId;

    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_INTERACTIVE_LOGON_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &InteractiveLogonKey
                   );

    if (RegError != ERROR_SUCCESS) {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("ThreadIsInteractive: RegOpenKeyExW failed: Error %d\n",
                      GetLastError()));
#endif
        return FALSE;
    }

    NwLuidToWStr(&LogonId, LogonIdKeyName);

    //
    // Open the <LogonIdKeyName> key under Logon
    //
    RegError = RegOpenKeyExW(
                   InteractiveLogonKey,
                   LogonIdKeyName,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &OneLogonKey
                   );

    if ( RegError == ERROR_SUCCESS ) {
        (void) RegCloseKey(OneLogonKey);
        (void) RegCloseKey(InteractiveLogonKey);
        return TRUE;  /* We found it */
    }
    else {
        (void) RegCloseKey(InteractiveLogonKey);
        return FALSE;  /* We did not find it */
    }

}

DWORD
NwpCitrixGetUserInfo(
    LPWSTR  *ppszUserSid
)
/*++

Routine Description:

    Get the user sid string of the client.

Arguments:

    ppszUserSid - A pointer to buffer to store the string.

Return Value:

    The error code.

--*/
{
    DWORD       err;
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG       ReturnLength;

    *ppszUserSid = NULL;

    // We can use OpenThreadToken because this server thread
    // is impersonating a client

    if ( !OpenThreadToken( GetCurrentThread(),
                           TOKEN_READ,
                           TRUE,  /* Open as self */
                           &TokenHandle ))
    {
        err = GetLastError();
    if ( err == ERROR_NO_TOKEN ) {
            if ( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_READ,
                           &TokenHandle )) {
#if DBG
               IF_DEBUG(PRINT)
               KdPrint(("NwpGetThreadUserInfo: OpenThreadToken failed: Error %d\n",
                      GetLastError()));
#endif

               return(GetLastError());
            }
        }
    else
           return( err );
    }

    // notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure


    if ( !GetTokenInformation( TokenHandle,
                               TokenUser,
                               TokenInformation,
                               sizeof( TokenInformation ),
                               &ReturnLength ))
    {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("NwpGetThreadUserInfo: GetTokenInformation failed: Error %d\n",
                      GetLastError()));
#endif
        return(GetLastError());
    }

    CloseHandle( TokenHandle );

    // convert the Sid (pointed to by pSid) to its
    // equivalent Unicode string representation.

    err = NwpConvertSid( ((PTOKEN_USER)TokenInformation)->User.Sid,
                                    ppszUserSid );

    if ( err )
    {
        if ( *ppszUserSid )
            LocalFree( *ppszUserSid );
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwspl.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwspl.h

Abstract:

    Common header for print provider client-side code.

Author:

    Yi-Hsin Sung (yihsins)  15-May-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NWSPL_INCLUDED_
#define _NWSPL_INCLUDED_

#include "nwdlg.h"

typedef struct _NWPORT {
    DWORD   cb;
    struct  _NWPORT *pNext;
    LPWSTR  pName;
} NWPORT, *PNWPORT;

extern LPWSTR   pszRegistryPath;
extern LPWSTR   pszRegistryPortNames;
extern WCHAR    szMachineName[];
extern PNWPORT  pNwFirstPort;
extern CRITICAL_SECTION NwSplSem;

BOOL IsLocalMachine(
    LPWSTR pszName
);

BOOL PortExists(
    LPWSTR  pszPortName,
    LPDWORD pError
);

BOOL PortKnown(
    LPWSTR  pszPortName
);

PNWPORT CreatePortEntry(
    LPWSTR pszPortName
);

BOOL DeletePortEntry(
    LPWSTR pszPortName
);
 
VOID DeleteAllPortEntries(
    VOID
);

DWORD CreateRegistryEntry(
    LPWSTR pszPortName
);

DWORD DeleteRegistryEntry(
    LPWSTR pszPortName
);


#endif // _NWSPL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwshrc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshrc.h

Abstract:

    All resource ids used in nwprovau.dll

Author:

    Yi-Hsin Sung      (yihsins)     20-Oct-1995

Revision History:

--*/

#ifndef _NWSHRC_H_
#define _NWSHRC_H_

#include "nwshhelp.h"

#define IDC_STATIC                  -1
#define IDC_LOGOFRAME               599

//
// Icon Ids
//

#define IDI_TREE_ICON               600 
#define IDI_SERVER_ICON             601 
#define IDI_FOLDER_ICON             602 
#define IDI_PRINTER_ICON            603 
#define IDI_NDSCONT_ICON            604 

// Bitmap Ids
#define IDB_SERVER_ICON             701
#define IDB_TREE_ICON               702

//
// Dialog Ids
//

#define DLG_NETWARE_LOGIN           1000
#define DLG_NETWORK_CREDENTIAL      1001
#define DLG_CHANGE_PASSWORD         1002
#define DLG_CHANGE_PASSWORD2        1003
#define DLG_PASSWORD_CHANGE         1004
#define DLG_PASSWORD_PROMPT         1005
#define DLG_PREFERRED_SERVER_HELP   1006
#define DLG_ENTER_PASSWORD_HELP     1007
#define DLG_ENTER_OLD_PASSWORD      1009
#define DLG_PW_SELECT_SERVERS       1010
#define DLG_PW_CHANGED              1011
#define DLG_ENTER_OLD_PW_HELP       1012
#define DLG_PW_SELECT_SERVERS_HELP  1013
#define DLG_ENTER_ALT_USERNAME      1014
#define DLG_ENTER_ALT_UN_HELP       1015
#define DLG_CHANGE_PASSWORD3        1016
#define DLG_CHANGE_PASSWORD_HELP    1017

//
// Dialog Ids for Shell Extension
//
#define DLG_NDS_SUMMARYINFO         1100
#define DLG_SERVER_SUMMARYINFO      1101
#define DLG_SHARE_SUMMARYINFO       1102
#define DLG_PRINTER_SUMMARYINFO     1103
#define DLG_GLOBAL_WHOAMI           1104
#define DLG_NDSCONT_SUMMARYINFO     1105

//
// Help File names, IDs, and macro
//
#define NW_HELP_FILE                TEXT("nwdoc.hlp")

//
// Control Ids used by all dialogs
//
#ifdef  NT1057
#define IDHELP                      100
#endif

//
// Control Ids used in both the login dialog and the
// change password dialog
//
#define ID_USERNAME                 101
#define ID_SERVER                   102
#define ID_LOCATION                 103
#define ID_PREFERREDSERVER_RB       104
#define ID_DEFAULTCONTEXT_RB        105
#define ID_DEFAULTTREE              106
#define ID_DEFAULTCONTEXT           107

//
// Control Ids used in the login dialog
//
#define ID_PASSWORD                 200

//
// Control Ids used in the change password dialog
//
#define ID_OLD_PASSWORD             300
#define ID_NEW_PASSWORD             301
#define ID_CONFIRM_PASSWORD         302

#define ID_ADD                      304
#define ID_REMOVE                   305
#define ID_ACTIVE_LIST              306
#define ID_INACTIVE_LIST            307
#define ID_ACTIVE_LIST_TITLE        308
#define ID_INACTIVE_LIST_TITLE      309

//
// Control Ids used in the network credential dialog
//
#define ID_VOLUME_PATH              400
#define ID_CONNECT_AS               401
#define ID_CONNECT_PASSWORD         402
#define ID_CONNECT_TEXT             403

//
// Login script
//
#define ID_LOGONSCRIPT              501

//
// Controls common to summaryinfo dialogs
//

#define IDD_ERROR                   200

//
// Controls Ids in DLG_NDS_SUMMARYINFO
//
#define IDD_NDS_NAME_TXT            101
#define IDD_NDS_NAME                102
#define IDD_NDS_CLASS_TXT           103
#define IDD_NDS_CLASS               104
#define IDD_NDS_COMMENT_TXT         105
#define IDD_NDS_COMMENT             106

//
// Controls Ids in DLG_SERVER_SUMMARYINFO
//
#define IDD_SERVER_NAME             101
#define IDD_SERVER_VERSION_TXT      102
#define IDD_SERVER_VERSION          103
#define IDD_SERVER_REVISION_TXT     104
#define IDD_SERVER_REVISION         105
#define IDD_SERVER_COMMENT_TXT      106
#define IDD_SERVER_COMMENT          107
#define IDD_SERVER_CONNECT_TXT      108
#define IDD_SERVER_CONNECT          109
#define IDD_SERVER_MAXCON_TXT       110
#define IDD_SERVER_MAXCON           111

//
// Controls Ids in DLG_SHARE_SUMMARYINFO
//
#define IDD_SHARE_NAME              101
#define IDD_SHARE_SERVER_TXT        102
#define IDD_SHARE_SERVER            103
#define IDD_SHARE_PATH_TXT          104
#define IDD_SHARE_PATH              105
#define IDD_SHARE_USED_SPC_CLR      106
#define IDD_SHARE_USED_SPC_TXT      107
#define IDD_SHARE_USED_SPC          108
#define IDD_SHARE_USED_SPC_MB       109
#define IDD_SHARE_FREE_SPC_CLR      110
#define IDD_SHARE_FREE_SPC_TXT      111
#define IDD_SHARE_FREE_SPC          112
#define IDD_SHARE_FREE_SPC_MB       113
#define IDD_SHARE_MAX_SPC_TXT       114
#define IDD_SHARE_MAX_SPC           115
#define IDD_SHARE_MAX_SPC_MB        116
#define IDD_SHARE_PIE               117
#define IDD_SHARE_LFN_TXT           118

//
// Controls Ids in DLG_PRINTER_SUMMARYINFO
//
#define IDD_PRINTER_NAME            101
#define IDD_PRINTER_QUEUE_TXT       102
#define IDD_PRINTER_QUEUE           103

//
// Controls Ids in DLG_GLOBAL_WHOAMI
//
#define IDD_GLOBAL_SERVERLIST_T     101
#define IDD_GLOBAL_SERVERLIST       102
#define IDD_GLOBAL_SVRLIST_DESC     103
#define IDD_DETACH                  104
#define IDD_REFRESH                 105

// 
// String Ids
//
#define IDS_START                         20000
#define IDS_NONE                          (IDS_START + 0)
#define IDS_NETWARE_PRINT_CAPTION         (IDS_START + 1)
#define IDS_NOTHING_TO_CONFIGURE          (IDS_START + 2)
#define IDS_NETWARE_TITLE                 (IDS_START + 3)
#define IDS_AUTH_FAILURE_TITLE            (IDS_START + 4)
#define IDS_NO_PREFERRED                  (IDS_START + 5)
#define IDS_LOGIN_FAILURE_WARNING         (IDS_START + 6)
#define IDS_AUTH_FAILURE_WARNING          (IDS_START + 7)
#define IDS_CHANGE_PASSWORD_INFO          (IDS_START + 8)
#define IDS_INVALID_SERVER                (IDS_START + 9)
#define IDS_PASSWORD_HAS_EXPIRED          (IDS_START + 10)
#define IDS_AUTH_ACC_RESTRICTION          (IDS_START + 11)
#define IDS_LOGIN_ACC_RESTRICTION         (IDS_START + 12)
#define IDS_PASSWORD_HAS_EXPIRED1         (IDS_START + 13)
#define IDS_BAD_PASSWORDS                 (IDS_START + 14)
#define IDS_CHANGE_PASSWORD_TITLE         (IDS_START + 15)
#define IDS_START_WORKSTATION_FIRST       (IDS_START + 16)
#define IDS_PASSWORD_HAS_EXPIRED0         (IDS_START + 17)
#define IDS_PASSWORD_HAS_EXPIRED2         (IDS_START + 18)
#define IDS_LOGIN_DISABLED                (IDS_START + 19)
#define IDS_SERVER                        (IDS_START + 21)
#define IDS_CONTEXT                       (IDS_START + 22)
#define IDS_CONNECT_NO_ERROR_TEXT         (IDS_START + 23)
#define IDS_TITLE_LOGOUT                  (IDS_START + 24)
#define IDS_MESSAGE_LOGOUT_QUESTION       (IDS_START + 25)
#define IDS_MESSAGE_LOGOUT_FAILED         (IDS_START + 26)
#define IDS_MESSAGE_NOT_ATTACHED          (IDS_START + 27)
#define IDS_MESSAGE_DETACHED              (IDS_START + 28)
#define IDS_MESSAGE_LOGOUT_CONFIRM        (IDS_START + 29)
#define IDS_TITLE_WHOAMI                  (IDS_START + 30)
#define IDS_MESSAGE_ATTACHED              (IDS_START + 31)
#define IDS_BYTES                         (IDS_START + 32)
#define IDS_ORDERKB                       (IDS_START + 33)
#define IDS_ORDERMB                       (IDS_START + 34)
#define IDS_ORDERGB                       (IDS_START + 35)
#define IDS_ORDERTB                       (IDS_START + 36)
#define IDS_STATE_NOT_LOGGED_IN           (IDS_START + 37)
#define IDS_MESSAGE_NOT_ATTACHED_TO_TREE  (IDS_START + 38)
#define IDS_MESSAGE_ATTACHED_TO_TREE      (IDS_START + 39)
#define IDS_LOGIN_TYPE_NDS                (IDS_START + 40)
#define IDS_LOGIN_TYPE_BINDERY            (IDS_START + 41)
#define IDS_LOGIN_STATUS_SEPARATOR        (IDS_START + 42)
#define IDS_LOGIN_STATUS_AUTHENTICATED    (IDS_START + 43)
#define IDS_LOGIN_STATUS_NOT_AUTHENTICATED (IDS_START + 44)
#define IDS_LOGIN_STATUS_LICENSED         (IDS_START + 45)
#define IDS_LOGIN_STATUS_NOT_LICENSED     (IDS_START + 46)
#define IDS_LOGIN_STATUS_LOGGED_IN        (IDS_START + 47)
#define IDS_LOGIN_STATUS_ATTACHED_ONLY    (IDS_START + 48)
#define IDS_LOGIN_STATUS_NOT_ATTACHED     (IDS_START + 49)
#define IDS_MESSAGE_CONNINFO_ERROR        (IDS_START + 50)
#define IDS_MESSAGE_ADDCONN_ERROR         (IDS_START + 51)
#define IDS_MESSAGE_CONTEXT_ERROR         (IDS_START + 52)
#define IDS_MESSAGE_LOGGED_IN_TREE        (IDS_START + 53)
#define IDS_MESSAGE_NOT_LOGGED_IN_TREE    (IDS_START + 54)
#define IDS_MESSAGE_LOGGED_IN_SERVER      (IDS_START + 55)
#define IDS_MESSAGE_NOT_LOGGED_IN_SERVER  (IDS_START + 56)
#define IDS_MESSAGE_PROPERTIES_ERROR      (IDS_START + 57)
#define IDS_TREE_NAME_MISSING             (IDS_START + 58)
#define IDS_CONTEXT_MISSING               (IDS_START + 59)
#define IDS_SERVER_MISSING                (IDS_START + 60)
#define IDS_CONTEXT_AUTH_FAILURE_WARNING  (IDS_START + 61)
#define IDS_COLUMN_NAME                   (IDS_START + 62)
#define IDS_COLUMN_CONN_TYPE              (IDS_START + 63)
#define IDS_COLUMN_CONN_NUMBER            (IDS_START + 64)
#define IDS_COLUMN_USER                   (IDS_START + 65)
#define IDS_COLUMN_STATUS                 (IDS_START + 66)
#define IDS_MESSAGE_GETINFO_ERROR         (IDS_START + 67)
#define IDS_CP_FAILURE_WARNING            (IDS_START + 68)
#define IDS_CHANGE_PASSWORD_CONFLICT      (IDS_START + 69)
#define IDS_NO_TREES_DETECTED             (IDS_START + 70)
#define IDS_MESSAGE_LOGOUT_FROM_SERVER_FAILED  (IDS_START + 71)

//
// String Ids for Shell Extension
//
#define IDS_MESSAGE_CONTEXT_CHANGED       (IDS_START + 100)

#define IDS_VERBS_BASE                    (IDS_START + 150)
#define IDS_VERBS_HELP_BASE               (IDS_START + 200)

#define IDO_VERB_WHOAMI                   1
#define IDO_VERB_LOGOUT                   2
#define IDO_VERB_ATTACHAS                 3
#define IDO_VERB_GLOBALWHOAMI             4
#define IDO_VERB_SETDEFAULTCONTEXT        5
#define IDO_VERB_MAPNETWORKDRIVE          6
#define IDO_VERB_TREEWHOAMI               7


#define IDS_END                           (IDS_START + 1000)

#endif // _NWSHRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwwks_c_stub.c ===
#include "nwwks_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwtest.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nwtest.c

Abstract:

    Main program.

Author:

    Glenn Curtis (glennc)     June, 1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nwclient.h>
#include <ntmsv1_0.h>
#include <nwsnames.h>
#include <nwcanon.h>
#include <validc.h>
#include <nwevent.h>

#include <nwdlg.h>

#include <nwreg.h>
#include <nwauth.h>
#include <nwapi.h>
#include <nwmisc.h>
#include <ndsapi32.h>

#include <stdlib.h>
#include <stdio.h>      //  printf()
#include <string.h>     //  strtoul()


__cdecl
main(
    int Argc,
    char **Argv
    )
{
    DWORD Status = NO_ERROR;
    WCHAR Domain[256];
    WCHAR UserName[256];
    WCHAR Password[256];
    WCHAR OldPassword[256];
    MSV1_0_INTERACTIVE_LOGON AuthentInfo;
    MSV1_0_INTERACTIVE_LOGON PreviousAuthentInfoType;

    memset( &AuthentInfo, 0, sizeof( MSV1_0_INTERACTIVE_LOGON ));
    memset( &PreviousAuthentInfoType, 0, sizeof( MSV1_0_INTERACTIVE_LOGON ));

    AuthentInfo.LogonDomainName.Length = wcslen( L"NTDEV" ) * sizeof( WCHAR );
    AuthentInfo.LogonDomainName.MaximumLength = 256 * sizeof( WCHAR );
    AuthentInfo.LogonDomainName.Buffer = Domain;
    wcscpy( AuthentInfo.LogonDomainName.Buffer, L"NTDEV" );

    AuthentInfo.UserName.Length = wcslen( L"glennc" ) * sizeof( WCHAR );
    AuthentInfo.UserName.MaximumLength = 256 * sizeof( WCHAR );
    AuthentInfo.UserName.Buffer = UserName;
    wcscpy( AuthentInfo.UserName.Buffer, L"glennc" );

    AuthentInfo.Password.Length = wcslen( L"VWbug01" ) * sizeof( WCHAR );
    AuthentInfo.Password.MaximumLength = 256 * sizeof( WCHAR );
    AuthentInfo.Password.Buffer = Password;
    wcscpy( AuthentInfo.Password.Buffer, L"VWbug01" );

    PreviousAuthentInfoType.LogonDomainName.Length = wcslen( L"NTDEV" ) * sizeof( WCHAR );
    PreviousAuthentInfoType.LogonDomainName.MaximumLength = 256 * sizeof( WCHAR );
    PreviousAuthentInfoType.LogonDomainName.Buffer = Domain;

    PreviousAuthentInfoType.UserName.Length = wcslen( L"glennc" ) * sizeof( WCHAR );
    PreviousAuthentInfoType.UserName.MaximumLength = 256 * sizeof( WCHAR );
    PreviousAuthentInfoType.UserName.Buffer = UserName;

    PreviousAuthentInfoType.Password.Length = wcslen( L"VWbug08" ) * sizeof( WCHAR );
    PreviousAuthentInfoType.Password.MaximumLength = 256 * sizeof( WCHAR );
    PreviousAuthentInfoType.Password.Buffer = OldPassword;
    wcscpy( PreviousAuthentInfoType.Password.Buffer, L"VWbug08" );
    

    Status = NPPasswordChangeNotify( L"MSV1_0:Interactive",
                                     (LPVOID) &AuthentInfo,
                                     NULL,
                                     (LPVOID) &PreviousAuthentInfoType,
                                     L"WinSta0",
                                     NULL,
                                     0 );

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\nwutil.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwutil.c

Abstract:

    Contains some misc functions used by shell extensions

Author:

    Yi-Hsin Sung    (yihsins)      25-Oct-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddnwfs.h>
#include <ndsapi32.h>
#include <nwmisc.h>
#include "nwclient.h"
#include "nwapi.h"
#include "nwutil.h"

#define  EXTRA_BYTES  256

BOOL
NwIsNdsSyntax(
    IN LPWSTR lpstrUnc
)
{
    HANDLE hTreeConn;
    DWORD  dwOid;
    DWORD  status = NO_ERROR;

    if ( lpstrUnc == NULL )
        return FALSE;

    status = NwOpenAndGetTreeInfo( lpstrUnc, &hTreeConn, &dwOid );

    if ( status != NO_ERROR )
    {
        return FALSE;
    }

    CloseHandle( hTreeConn );

    return TRUE;
}

VOID
NwAbbreviateUserName(
    IN  LPWSTR pszFullName,
    OUT LPWSTR pszUserName
)
{
    if ( pszUserName == NULL )
        return;

    if ( NwIsNdsSyntax( pszFullName ))
    {
        //
        // TRACKING - This part of the code never gets called due to the
        // change in how NwIsNdsSyntax works. Post NT 4.0, get rid of the
        // NwIsNdsSyntax test and run this section of code no matter what.
        // This bug was not fixed in NT4.0 due to the extremely close time
        // to the ship date.
        //
        LPWSTR pszTemp = pszFullName;
        LPWSTR pszLast = pszTemp;

        *pszUserName = 0;

        while ( pszTemp = wcschr( pszTemp, L'='))
        {
            WCHAR NextChar;

            NextChar = *(++pszTemp);

            while ( NextChar != 0 && NextChar != L'.' )
            {     
                *(pszUserName++) = *pszTemp;
                NextChar = *(++pszTemp);
            }

            if ( NextChar == 0 )
            {
                pszLast = NULL;
                break;
            }

            *(pszUserName++) = *pszTemp;   // put back the '.' 
            pszLast = ++pszTemp;
        }

        if ( pszLast != NULL )
        {
            while ( *pszLast != 0 )
                *(pszUserName++) = *(pszLast++);
        }

        *pszUserName = 0;
    }
    else
    {
        wcscpy( pszUserName, pszFullName );
    }
}

VOID 
NwMakePrettyDisplayName(
    IN  LPWSTR pszName 
)
{
    if ( pszName )
    {
        CharLower( pszName );
        CharUpperBuff( pszName, 1);
    }
}

VOID
NwExtractTreeName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszTreeName
)
{
    LPWSTR pszTemp = NULL;

    if ( pszTreeName == NULL )
        return;

    pszTreeName[0] = 0;

    if ( pszUNCPath == NULL )
        return;

    if ( pszUNCPath[0] == L' ')
        pszUNCPath++;

    if (  ( pszUNCPath[0] != L'\\') || ( pszUNCPath[1] != L'\\') )
        return;

    wcscpy( pszTreeName, pszUNCPath + 2 );      // get past "\\"

    if ( pszTemp = wcschr( pszTreeName, L'\\' )) 
        *pszTemp = 0;
}

VOID
NwExtractServerName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszServerName
)
{
    LPWSTR pszTemp = NULL;

    if ( pszServerName == NULL ) {
        return;
    }

    pszServerName[0] = 0;

    if ( pszUNCPath == NULL ) {
        return;
    }

    if ( pszUNCPath[0] == L' ') {
        pszUNCPath++;
    }

    if ( ( pszUNCPath[0] != L'\\') || ( pszUNCPath[1] != L'\\') ) {
        return;
    }

    //
    //  tommye - fix for bug 5005 - if there is a NW server having
    //  the same name as a NDS Tree, then NwIsNdsSyntax will return 
    //  TRUE even though the path points to the server (not the tree).
    //  This was blowing up becuase the wschr was returning NULL, and
    //  wasn't being checked.  If this returns NULL, then we'll make 
    //  the assumption that we've got a server name after all.
    //

    if ( NwIsNdsSyntax( pszUNCPath ))
    {
        pszTemp = wcschr( pszUNCPath + 2, L'\\' );  // get past "\\"

        if (pszTemp) {
            wcscpy( pszServerName, pszTemp + 1 );       // get past "\"

            if ( pszTemp = wcschr( pszServerName, L'.' )) {
                *pszTemp = 0;
            }

            return;
        }

    }

    //
    // tommye
    // Fall through - this must be a server name only
    //

    wcscpy( pszServerName, pszUNCPath + 2 );    // get past "\\"

    if ( pszTemp = wcschr( pszServerName, L'\\' )) {
        *pszTemp = 0;
    }
}

VOID
NwExtractShareName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszShareName
)
{
    LPWSTR pszTemp = NULL;

    if ( pszShareName == NULL ) {
        return;
    }

    pszShareName[0] = 0;

    if (  ( pszUNCPath == NULL )
       || ( pszUNCPath[0] != L'\\')
       || ( pszUNCPath[1] != L'\\')
       )
    {
        return;
    }

    //
    //  tommye - fix for bug 5005 - if there is a NW server having
    //  the same name as a NDS Tree, then NwIsNdsSyntax will return 
    //  TRUE even though the path points to the server (not the tree).
    //  This was blowing up becuase the wschr was returning NULL, and
    //  wasn't being checked.  If this returns NULL, then we'll make 
    //  the assumption that we've got a server name after all.
    //

    if ( NwIsNdsSyntax( pszUNCPath ))
    {
        pszTemp = wcschr( pszUNCPath + 2, L'\\' );  // get past "\\"

        if (pszTemp) {
            wcscpy( pszShareName, pszTemp + 1 );        // get past "\"

            if ( pszTemp = wcschr( pszShareName, L'.' )) {
                *pszTemp = 0;
            }

            return;
        }
    }

    //
    // tommye
    // Fall through - this must be a server name only
    //

    pszTemp = wcschr( pszUNCPath + 2, L'\\' );  // get past "\\"
    wcscpy( pszShareName, pszTemp + 1);         // get past "\"

    if ( pszTemp = wcschr( pszShareName, L'\\' )) {
        *pszTemp = 0;
    }
}

DWORD
NwIsServerInDefaultTree(
    IN  LPWSTR  pszFullServerName,
    OUT BOOL   *pfInDefaultTree
)
{
    DWORD  err = NO_ERROR;
    LPWSTR pszCurrentContext = NULL;
    DWORD  dwPrintOptions;
    WCHAR  szTreeName[MAX_PATH + 1];

    *pfInDefaultTree = FALSE;

    if ( !NwIsNdsSyntax( pszFullServerName ))
    {
        // The full server name does not contain any NDS information
        // In this case, assume the server is not in the tree.
        // If a server belongs the default tree, we would get the full 
        // NDS information.
        return NO_ERROR;
    }

    // Get the current default tree or server name
    err = NwQueryInfo( &dwPrintOptions, &pszCurrentContext );

    if ( (err == NO_ERROR) && ( *pszCurrentContext == TREECHAR))
    {
        // Yes, there is a default tree. 
        // So, get the tree name out of *TREE\CONTEXT
        LPWSTR pszTemp = wcschr( pszCurrentContext, L'\\');
        if ( pszTemp )
            *pszTemp = 0;

        // Need to extract the tree name from full UNC path
        NwExtractTreeName( pszFullServerName, szTreeName );

        if ( _wcsicmp( szTreeName,
                      pszCurrentContext + 1) == 0 ) // get past the tree char
        {
            *pfInDefaultTree = TRUE;
        }
    }

    if ( pszCurrentContext != NULL )
        LocalFree( pszCurrentContext );

    return err;
}

DWORD
NwIsServerOrTreeAttached(
    IN  LPWSTR  pszName,
    OUT BOOL   *pfAttached,
    OUT BOOL   *pfAuthenticated
)
{
    DWORD  err = NO_ERROR;
    DWORD  EntriesRead = 0;
    DWORD_PTR  ResumeKey = 0;
    LPBYTE Buffer = NULL;

    err = NwGetConnectionStatus(
              pszName,
              &ResumeKey,
              &Buffer,
              &EntriesRead );

    *pfAttached = FALSE;
    *pfAuthenticated = FALSE;

    if (( err == NO_ERROR ) && ( EntriesRead > 0 ))
    {
        // For trees, we might get more than one entries back.

        PCONN_STATUS pConnStatus = (PCONN_STATUS) Buffer;

        if ( !pConnStatus->fPreferred )
        {
            // We only need to return as attached if this is not a preferred
            // server implicit connection since we don't want the user to know
            // about this connection ( which rdr does not allow user to delete)

            *pfAttached = TRUE;
            *pfAuthenticated = (pConnStatus->dwConnType != NW_CONN_NOT_AUTHENTICATED);
        }
    }

    if ( Buffer != NULL )
    {
        LocalFree( Buffer );
        Buffer = NULL;
    }

    return err;
}

DWORD
NwGetConnectionInformation(
    IN  LPWSTR  pszName,
    OUT LPBYTE  Buffer,
    IN  DWORD   BufferSize
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE            handleRdr = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    uRdrName;
    WCHAR             RdrPrefix[] = L"\\Device\\NwRdr\\*";
     
    PNWR_REQUEST_PACKET RequestPacket = NULL;
    DWORD             RequestPacketSize = 0;
    DWORD             dwNameLen = 0;

    if ( pszName == NULL )
        return ERROR_INVALID_PARAMETER;

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &uRdrName, RdrPrefix );

    InitializeObjectAttributes( &ObjectAttributes,
                                &uRdrName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &handleRdr,
                           SYNCHRONIZE | FILE_LIST_DIRECTORY,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        goto CleanExit;

    dwNameLen = wcslen(pszName) * sizeof(WCHAR);

    RequestPacketSize = sizeof( NWR_REQUEST_PACKET ) + dwNameLen;

    RequestPacket = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT, 
                                                      RequestPacketSize );

    if ( RequestPacket == NULL )
    {
        ntstatus = STATUS_NO_MEMORY;
        goto CleanExit;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_INFO.
    //

    RequestPacket->Version = REQUEST_PACKET_VERSION;
    RequestPacket->Parameters.GetConnInfo.ConnectionNameLength = dwNameLen;

    RtlCopyMemory( &(RequestPacket->Parameters.GetConnInfo.ConnectionName[0]),
                   pszName,
                   dwNameLen );

    ntstatus = NtFsControlFile( handleRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_INFO,
                                (PVOID) RequestPacket,
                                RequestPacketSize,
                                (PVOID) Buffer,
                                BufferSize );
 
    if ( NT_SUCCESS( ntstatus ))
        ntstatus = IoStatusBlock.Status;

CleanExit:

    if ( handleRdr != NULL )
        NtClose( handleRdr );

    if ( RequestPacket != NULL )
        LocalFree( RequestPacket );

    return RtlNtStatusToDosError( ntstatus );
}

DWORD
NWPGetConnectionStatus(
    IN     LPWSTR  pszRemoteName,
    IN OUT PDWORD_PTR  ResumeKey,
    OUT    LPBYTE  Buffer,
    IN     DWORD   BufferSize,
    OUT    PDWORD  BytesNeeded,
    OUT    PDWORD  EntriesRead
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE            handleRdr = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    uRdrName;
    WCHAR             RdrPrefix[] = L"\\Device\\NwRdr\\*";
     
    PNWR_REQUEST_PACKET RequestPacket = NULL;
    DWORD             RequestPacketSize = 0;
    DWORD             dwRemoteNameLen = 0;

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &uRdrName, RdrPrefix );

    InitializeObjectAttributes( &ObjectAttributes,
                                &uRdrName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &handleRdr,
                           SYNCHRONIZE | FILE_LIST_DIRECTORY,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        goto CleanExit;

    dwRemoteNameLen = pszRemoteName? wcslen(pszRemoteName)*sizeof(WCHAR) : 0;

    RequestPacketSize = sizeof( NWR_REQUEST_PACKET ) + dwRemoteNameLen;

    RequestPacket = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT, 
                                                      RequestPacketSize );

    if ( RequestPacket == NULL )
    {
        ntstatus = STATUS_NO_MEMORY;
        goto CleanExit;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_STATUS.
    //

    RequestPacket->Parameters.GetConnStatus.ResumeKey = *ResumeKey;

    RequestPacket->Version = REQUEST_PACKET_VERSION;
    RequestPacket->Parameters.GetConnStatus.ConnectionNameLength = dwRemoteNameLen;

    RtlCopyMemory( &(RequestPacket->Parameters.GetConnStatus.ConnectionName[0]),
                   pszRemoteName,
                   dwRemoteNameLen );

    ntstatus = NtFsControlFile( handleRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_STATUS,
                                (PVOID) RequestPacket,
                                RequestPacketSize,
                                (PVOID) Buffer,
                                BufferSize );
 
    if ( NT_SUCCESS( ntstatus ))
        ntstatus = IoStatusBlock.Status;

    *EntriesRead = RequestPacket->Parameters.GetConnStatus.EntriesReturned;
    *ResumeKey   = RequestPacket->Parameters.GetConnStatus.ResumeKey;
    *BytesNeeded = RequestPacket->Parameters.GetConnStatus.BytesNeeded;

CleanExit:

    if ( handleRdr != NULL )
        NtClose( handleRdr );

    if ( RequestPacket != NULL )
        LocalFree( RequestPacket );

    return RtlNtStatusToDosError( ntstatus );
}


DWORD
NwGetConnectionStatus(
    IN  LPWSTR  pszRemoteName,
    OUT PDWORD_PTR  ResumeKey,
    OUT LPBYTE  *Buffer,
    OUT PDWORD  EntriesRead
)
{
    DWORD err = NO_ERROR;
    DWORD dwBytesNeeded = 0;
    DWORD dwBufferSize  = TWO_KB;

    *Buffer = NULL;
    *EntriesRead = 0;
 
    do { 

        *Buffer = (LPBYTE) LocalAlloc( LMEM_ZEROINIT, dwBufferSize );

        if ( *Buffer == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        err = NWPGetConnectionStatus( pszRemoteName,
                                      ResumeKey,
                                      *Buffer,
                                      dwBufferSize,
                                      &dwBytesNeeded,
                                      EntriesRead );

        if ( err == ERROR_INSUFFICIENT_BUFFER )
        {
            dwBufferSize = dwBytesNeeded + EXTRA_BYTES;
            LocalFree( *Buffer );
            *Buffer = NULL;
        }

    } while ( err == ERROR_INSUFFICIENT_BUFFER );

    if ( err == ERROR_INVALID_PARAMETER )  // not attached
    { 
        err = NO_ERROR;
        *EntriesRead = 0;
    }

    return err;
}

DWORD
NwGetNdsVolumeInfo(
    IN  LPWSTR pszName,
    OUT LPWSTR pszServerBuffer,
    IN  WORD   wServerBufferSize,    // in bytes
    OUT LPWSTR pszVolumeBuffer,
    IN WORD   wVolumeBufferSize     // in bytes
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE   handleNdsTree;

    LPWSTR   pszTree, pszVolume, pszTemp;    
    UNICODE_STRING uTree, uVolume;

    UNICODE_STRING uHostServer, uHostVolume;
    WCHAR HostVolumeBuffer[256];

    pszTree = pszName + 2;  // get past two backslashes

    pszTemp = wcschr( pszTree, L'\\' );
    if ( pszTemp ) 
        *pszTemp = 0;
    else
        return ERROR_INVALID_PARAMETER; 
   
    pszVolume = pszTemp + 1;

    RtlInitUnicodeString( &uTree, pszTree );
    RtlInitUnicodeString( &uVolume, pszVolume );
    
    //
    // Open up a handle to the tree.
    //

    ntstatus = NwNdsOpenTreeHandle( &uTree,
                                    &handleNdsTree );

    if ( !NT_SUCCESS( ntstatus )) 
        goto CleanExit;

    //
    // Set up the reply strings.
    //

    uHostServer.Length = 0;
    uHostServer.MaximumLength = wServerBufferSize;
    uHostServer.Buffer = pszServerBuffer;

    RtlZeroMemory( pszServerBuffer, wServerBufferSize );

    if ( pszVolumeBuffer != NULL )
    {
        uHostVolume.Length = 0;
        uHostVolume.MaximumLength = wVolumeBufferSize;
        uHostVolume.Buffer = pszVolumeBuffer;

        RtlZeroMemory( pszVolumeBuffer, wVolumeBufferSize );
    }
    else
    {
        uHostVolume.Length = 0;
        uHostVolume.MaximumLength = sizeof( HostVolumeBuffer );
        uHostVolume.Buffer = HostVolumeBuffer;
    }

    ntstatus = NwNdsGetVolumeInformation( handleNdsTree,
                                          &uVolume,
                                          &uHostServer,
                                          &uHostVolume );

    CloseHandle( handleNdsTree );

CleanExit:

    //
    // Note: This change added to fix NT bug 338991 on Win2000
    //
    if ( ntstatus == STATUS_BAD_NETWORK_PATH )
    {
        ntstatus = STATUS_ACCESS_DENIED;
    }

    if ( pszTemp )
        *pszTemp = L'\\';

    return RtlNtStatusToDosError( ntstatus );
}

DWORD
NwOpenAndGetTreeInfo(
    LPWSTR pszNdsUNCPath,
    HANDLE *phTreeConn,
    DWORD  *pdwOid
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    WCHAR          lpServerName[NW_MAX_SERVER_LEN];
    UNICODE_STRING ServerName;

    UNICODE_STRING ObjectName;
   
    *phTreeConn = NULL;

    ServerName.Length = 0;
    ServerName.MaximumLength = sizeof( lpServerName );
    ServerName.Buffer = lpServerName;

    ObjectName.Buffer = NULL;
    ObjectName.MaximumLength = ( wcslen( pszNdsUNCPath) + 1 ) * sizeof( WCHAR );

    ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                           pszNdsUNCPath,
                                           PARSE_NDS_GET_TREE_NAME );

    if ( ObjectName.Length == 0 || ObjectName.Buffer == NULL )
    {
        return ERROR_PATH_NOT_FOUND;
    }

    //
    // Open a NDS tree connection handle to \\treename
    //
    ntstatus = NwNdsOpenTreeHandle( &ObjectName, phTreeConn );

    if ( !NT_SUCCESS( ntstatus ))
    {
        return RtlNtStatusToDosError( ntstatus );
    }

    //
    // Get the path to the container to open.
    //
    ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                           pszNdsUNCPath,
                                           PARSE_NDS_GET_PATH_NAME );

    if ( ObjectName.Length == 0 )
    {
        UNICODE_STRING Root;

        RtlInitUnicodeString(&Root, L"[Root]");

        //
        // Resolve the path to get a NDS object id.
        //
        ntstatus =  NwNdsResolveName( *phTreeConn,
                                      &Root,
                                      pdwOid,
                                      &ServerName,
                                      NULL,
                                      0 );

    }
    else
    {
        //
        // Resolve the path to get a NDS object id.
        //
        ntstatus =  NwNdsResolveName( *phTreeConn,
                                      &ObjectName,
                                      pdwOid,
                                      &ServerName,
                                      NULL,
                                      0 );

    }

    if ( ntstatus == STATUS_SUCCESS && ServerName.Length )
    {
        DWORD    dwHandleType;

        //
        // NwNdsResolveName succeeded, but we were referred to
        // another server, though pdwOid is still valid.

        if ( *phTreeConn )
            CloseHandle( *phTreeConn );

        *phTreeConn = NULL;

        //
        // Open a NDS generic connection handle to \\ServerName
        //
        ntstatus = NwNdsOpenGenericHandle( &ServerName,
                                           &dwHandleType,
                                           phTreeConn );

        if ( ntstatus != STATUS_SUCCESS )
        {
            return RtlNtStatusToDosError(ntstatus);
        }

        ASSERT( dwHandleType != HANDLE_TYPE_NCP_SERVER );
    }

    if ( !NT_SUCCESS( ntstatus ))
    {
    
        if ( *phTreeConn != NULL )
        {
            CloseHandle( *phTreeConn );
            *phTreeConn = NULL;
        }
        return RtlNtStatusToDosError(ntstatus);
    }

    return NO_ERROR;

}

DWORD
NwGetConnectedTrees(
    IN  LPWSTR  pszNtUserName,
    OUT LPBYTE  Buffer,
    IN  DWORD   BufferSize,
    OUT LPDWORD lpEntriesRead,
    OUT LPDWORD lpUserLUID
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE            handleRdr = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    WCHAR             RdrPrefix[] = L"\\Device\\NwRdr\\*";
    UNICODE_STRING    uRdrName;
    UNICODE_STRING    uNtUserName;

    PNWR_NDS_REQUEST_PACKET Request = NULL;
    BYTE                    RequestBuffer[2048];
    DWORD                   RequestSize = 0;

    *lpEntriesRead = 0;

    //
    // Convert the user name to unicode.
    //

    RtlInitUnicodeString( &uNtUserName, pszNtUserName );

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &uRdrName, RdrPrefix );

    InitializeObjectAttributes( &ObjectAttributes,
                                &uRdrName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &handleRdr,
                           SYNCHRONIZE | FILE_LIST_DIRECTORY,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        goto CleanExit;

    //
    // Fill out the request packet for FSCTL_NWR_NDS_LIST_TREES;
    //

    Request = ( PNWR_NDS_REQUEST_PACKET ) RequestBuffer;

    Request->Parameters.ListTrees.NtUserNameLength = uNtUserName.Length;

    RtlCopyMemory( &(Request->Parameters.ListTrees.NtUserName[0]),
                   uNtUserName.Buffer,
                   uNtUserName.Length );

    RequestSize = sizeof( Request->Parameters.ListTrees ) +
                  uNtUserName.Length +
                  sizeof( DWORD );

    ntstatus = NtFsControlFile( handleRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_NDS_LIST_TREES,
                                (PVOID) Request,
                                RequestSize,
                                (PVOID) Buffer,
                                BufferSize );

    if ( NT_SUCCESS( ntstatus ))
    {
        ntstatus = IoStatusBlock.Status;
        *lpEntriesRead = Request->Parameters.ListTrees.TreesReturned;
        *lpUserLUID = Request->Parameters.ListTrees.UserLuid.LowPart;
    }

CleanExit:

    if ( handleRdr != NULL )
        NtClose( handleRdr );

    return RtlNtStatusToDosError( ntstatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\port.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This module contains the code for port handling

Author:

    Yi-Hsin Sung (yihsins) 15-May-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#include <wingdi.h>
#include <winspool.h>

#include <splutil.h>
#include <nwspl.h>

//------------------------------------------------------------------
//
// Local Functions
//
//------------------------------------------------------------------

HMODULE hSpoolssDll = NULL;
FARPROC pfnSpoolssEnumPorts = NULL;

HANDLE
RevertToPrinterSelf(
    VOID
);

BOOL
ImpersonatePrinterClient(
    HANDLE  hToken
);



BOOL
IsLocalMachine(
    LPWSTR pszName
)
{
    if ( !pszName || !*pszName )
        return TRUE;

    if ( *pszName == L'\\' && *(pszName+1) == L'\\')
        if ( !lstrcmpi( pszName, szMachineName) )
            return TRUE;

    return FALSE;

}


BOOL
PortExists(
    LPWSTR  pPortName,
    LPDWORD pError
)
/* PortExists
 *
 * Calls EnumPorts to check whether the port name already exists.
 * This asks every monitor, rather than just this one.
 * The function will return TRUE if the specified port is in the list.
 * If an error occurs, the return is FALSE and the variable pointed
 * to by pError contains the return from GetLastError().
 * The caller must therefore always check that *pError == NO_ERROR.
 */
{
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD cbPorts;
    LPPORT_INFO_1W pPorts;
    DWORD i;
    BOOL  Found = FALSE;

    *pError = NO_ERROR;

    if ( !hSpoolssDll )
    {
        if ( hSpoolssDll = LoadLibrary( L"SPOOLSS.DLL" ))
        {
            pfnSpoolssEnumPorts = GetProcAddress(hSpoolssDll, "EnumPortsW");
            if ( !pfnSpoolssEnumPorts )
            {
                *pError = GetLastError();
                FreeLibrary( hSpoolssDll );
                hSpoolssDll = NULL;
            }
        }
        else
        {
            *pError = GetLastError();
        }
    }

    if ( !pfnSpoolssEnumPorts )
        return FALSE;

    if ( !(*pfnSpoolssEnumPorts)( NULL, 1, NULL, 0, &cbNeeded, &cReturned) )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            cbPorts = cbNeeded;

            EnterCriticalSection( &NwSplSem );

            pPorts = AllocNwSplMem( LMEM_ZEROINIT, cbPorts );
            if ( pPorts )
            {
                if ( (*pfnSpoolssEnumPorts)( NULL, 1, (LPBYTE)pPorts, cbPorts,
                                             &cbNeeded, &cReturned))
                {
                    for ( i = 0; i < cReturned; i++)
                    {
                        if ( !lstrcmpi( pPorts[i].pName, pPortName) )
                            Found = TRUE;
                    }
                }
                else
                {
                    *pError = GetLastError();
                }

                FreeNwSplMem( pPorts, cbPorts );
            }
            else
            {
                *pError = ERROR_NOT_ENOUGH_MEMORY;
            }

            LeaveCriticalSection( &NwSplSem );

        }
        else
        {
            *pError = GetLastError();
        }
    }

    return Found;
}



BOOL
PortKnown(
    LPWSTR   pPortName
)
{
    PNWPORT pNwPort;

    EnterCriticalSection( &NwSplSem );

    pNwPort = pNwFirstPort;

    while ( pNwPort )
    {
        if ( !lstrcmpi( pNwPort->pName, pPortName ) )
        {
            LeaveCriticalSection( &NwSplSem );
            return TRUE;
        }

        pNwPort = pNwPort->pNext;
    }

    LeaveCriticalSection( &NwSplSem );
    return FALSE;

}



PNWPORT
CreatePortEntry(
    LPWSTR   pPortName
)
{
    PNWPORT pNwPort, pPort;
    DWORD cb = sizeof(NWPORT) + (wcslen(pPortName) + 1) * sizeof(WCHAR);

    if ( pNwPort = AllocNwSplMem( LMEM_ZEROINIT, cb))
    {
        pNwPort->pName = wcscpy((LPWSTR)(pNwPort+1), pPortName);
        pNwPort->cb = cb;
        pNwPort->pNext = NULL;

        EnterCriticalSection( &NwSplSem );

        if ( pPort = pNwFirstPort )
        {
            while ( pPort->pNext )
                pPort = pPort->pNext;

            pPort->pNext = pNwPort;
        }
        else
        {
            pNwFirstPort = pNwPort;
        }

        LeaveCriticalSection( &NwSplSem );
    }

    return pNwPort;
}



BOOL
DeletePortEntry(
    LPWSTR   pPortName
)
/*
    Return TRUE when the port name is found and deleted. FALSE otherwise.
*/
{
    BOOL fRetVal;
    PNWPORT pPort, pPrevPort;

    EnterCriticalSection( &NwSplSem );

    pPort = pNwFirstPort;
    while ( pPort && lstrcmpi(pPort->pName, pPortName))
    {
        pPrevPort = pPort;
        pPort = pPort->pNext;
    }

    if (pPort)
    {
        if (pPort == pNwFirstPort)
        {
            pNwFirstPort = pPort->pNext;
        }
        else
        {
            pPrevPort->pNext = pPort->pNext;
        }

        FreeNwSplMem( pPort, pPort->cb );
        fRetVal = TRUE;
    }
    else
    {
        fRetVal = FALSE;
    }

    LeaveCriticalSection( &NwSplSem );

    return fRetVal;
}



VOID
DeleteAllPortEntries(
    VOID
)
{
    PNWPORT pPort, pNextPort;

    for ( pPort = pNwFirstPort; pPort; pPort = pNextPort ) 
    {
        pNextPort = pPort->pNext;
        FreeNwSplMem( pPort, pPort->cb );
    }
}



DWORD
CreateRegistryEntry(
    LPWSTR pPortName
)
{
    DWORD  err;
    HANDLE hToken;
    HKEY   hkeyPath;
    HKEY   hkeyPortNames;

    hToken = RevertToPrinterSelf();

    err = RegCreateKeyEx( HKEY_LOCAL_MACHINE, pszRegistryPath, 0,
                          NULL, 0, KEY_WRITE, NULL, &hkeyPath, NULL );

    if ( !err )
    {
        err = RegCreateKeyEx( hkeyPath, pszRegistryPortNames, 0,
                              NULL, 0, KEY_WRITE, NULL, &hkeyPortNames, NULL );

        if ( !err )
        {
            err = RegSetValueEx( hkeyPortNames,
                                 pPortName,
                                 0,
                                 REG_SZ,
                                 (LPBYTE) L"",
                                 0 );

            RegCloseKey( hkeyPortNames );
        }
        else
        {
            KdPrint(("RegCreateKeyEx (%ws) failed: Error = %d\n",
                      pszRegistryPortNames, err ) );
        }

        RegCloseKey( hkeyPath );
    }
    else
    {
        KdPrint(("RegCreateKeyEx (%ws) failed: Error = %d\n",
                  pszRegistryPath, err ) );
    }

    if ( hToken )
        (void)ImpersonatePrinterClient(hToken);

    return err;
}



DWORD
DeleteRegistryEntry(
    LPWSTR pPortName
)
{
    DWORD  err;
    HANDLE hToken;
    HKEY   hkeyPath;
    HKEY   hkeyPortNames;

    hToken = RevertToPrinterSelf();

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszRegistryPath, 0,
                        KEY_WRITE, &hkeyPath );

    if ( !err )
    {

        err = RegOpenKeyEx( hkeyPath, pszRegistryPortNames, 0,
                            KEY_WRITE, &hkeyPortNames );

        if ( !err )
        {
            err = RegDeleteValue( hkeyPortNames, pPortName );
            RegCloseKey( hkeyPortNames );
        }
        else
        {
            KdPrint(("RegOpenKeyEx (%ws) failed: Error = %d\n",
                      pszRegistryPortNames, err ) );
        }

        RegCloseKey( hkeyPath );

    }
    else
    {
        KdPrint(("RegOpenKeyEx (%ws) failed: Error = %d\n",
                  pszRegistryPath, err ) );
    }

    if ( hToken )
        (void)ImpersonatePrinterClient(hToken);

    return err;
}



HANDLE
RevertToPrinterSelf(
    VOID
)
{
    HANDLE NewToken = NULL;
    HANDLE OldToken;
    NTSTATUS ntstatus;

    ntstatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_IMPERSONATE,
                   TRUE,
                   &OldToken
                   );

    if ( !NT_SUCCESS(ntstatus) ) {
        SetLastError(ntstatus);
        return FALSE;
    }

    ntstatus = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&NewToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(ntstatus) ) {
        SetLastError(ntstatus);
        return FALSE;
    }

    return OldToken;
}



BOOL
ImpersonatePrinterClient(
    HANDLE  hToken
)
{
    NTSTATUS ntstatus = NtSetInformationThread(
                            NtCurrentThread(),
                            ThreadImpersonationToken,
                            (PVOID) &hToken,
                            (ULONG) sizeof(HANDLE));

    if ( !NT_SUCCESS(ntstatus) ) {
        SetLastError( ntstatus );
        return FALSE;
    }

    (VOID) NtClose(hToken);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\tconn.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    tconnect.c

Abstract:

    Test for workstation connection APIs.

Author:

    Rita Wong (ritaw) 17-Feb-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef UNICODE
#define UNICODE
#endif


#include <stdio.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winnetwk.h>
#include <npapi.h>

#define REDIR_NOT_READY

DWORD
TestCreateConnection(
    IN  LPWSTR LocalName OPTIONAL,
    IN  LPWSTR RemoteName,
    IN  LPWSTR Password OPTIONAL,
    IN  LPWSTR UserName OPTIONAL,
    IN  DWORD ExpectedError
    );

DWORD
TestDeleteConnection(
    IN  LPWSTR ConnectionName,
    IN  BOOL ForceFlag,
    IN  DWORD ExpectedError
    );

DWORD
TestOpenEnum(
    IN DWORD Scope,
    IN LPNETRESOURCEW NetR OPTIONAL,
    OUT LPHANDLE EnumHandle,
    IN  DWORD ExpectedError
    );

DWORD
TestEnum(
    IN HANDLE EnumHandle,
    IN DWORD EntriesRequested,
    IN LPVOID Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    IN DWORD ExpectedError
    );

VOID
PrintNetResource(
    LPNETRESOURCE NetR
    );


BYTE WorkBuffer[1024];
BYTE WorkBuffer2[1024];

void __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD status;

    LPWSTR LocalName;
    LPWSTR RemoteName;
    LPWSTR Password;
    LPWSTR UserName;

    NETRESOURCEW NetR;
    HANDLE EnumHandle;
    DWORD BytesNeeded;


    LocalName = L"E:";
    RemoteName = L"\\\\MyServerName\\A_Volume\\A_Directory";
    Password = L"MyPassword";
    UserName = L"MyUserName";


    TestCreateConnection(
        LocalName,
        RemoteName,
        Password,
        UserName,
        WN_SUCCESS
        );

    TestDeleteConnection(
        LocalName,
        TRUE,
        WN_SUCCESS
        );

    //-------------------------//

    TestCreateConnection(
        NULL,
        RemoteName,
        NULL,
        NULL,
        WN_SUCCESS
        );

    TestDeleteConnection(
        RemoteName,
        TRUE,
        WN_SUCCESS
        );

    //-------------------------//

    TestCreateConnection(
        L"LPT1",
        RemoteName,
        NULL,
        NULL,
        ERROR_INVALID_PARAMETER
        );

    //-------------------------//

    TestCreateConnection(
        LocalName,
        L"\\\\Server",
        NULL,
        NULL,
        ERROR_INVALID_NAME
        );

    //-------------------------//

    printf("\n");

    //-------------------------//

#ifdef REDIR_NOT_READY

    if (argc == 2) {

        ANSI_STRING AStr;
        UNICODE_STRING UStr;


        RtlZeroMemory(WorkBuffer2, sizeof(WorkBuffer2));
        UStr.Buffer = WorkBuffer2;
        UStr.MaximumLength = sizeof(WorkBuffer2);

        RtlInitString(&AStr, argv[1]);

        RtlAnsiStringToUnicodeString(
            &UStr,
            &AStr,
            FALSE
            );

        NetR.lpRemoteName = UStr.Buffer;
    }
    else {
        NetR.lpRemoteName = L"lanman";
    }

    //-------------------------//

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        sizeof(WorkBuffer),
        &BytesNeeded,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        sizeof(WorkBuffer),
        &BytesNeeded,
        WN_NO_MORE_ENTRIES
        );

    (void) NPCloseEnum(EnumHandle);

    //-------------------------//

    printf("\n");

    //-------------------------//

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        200,
        &BytesNeeded,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        sizeof(NETRESOURCEW) + 5,
        &BytesNeeded,
        WN_MORE_DATA
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        BytesNeeded,
        &BytesNeeded,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        sizeof(WorkBuffer),
        &BytesNeeded,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        0,
        &BytesNeeded,
        WN_NO_MORE_ENTRIES
        );

    (void) NPCloseEnum(EnumHandle);

#else

    NetR.lpRemoteName = L"\\\\S";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

    //-------------------------//

    NetR.lpRemoteName = L"\\\\A Long Server Name";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

    //-------------------------//

    NetR.lpRemoteName = L"\\\\S\\";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        ERROR_INVALID_NAME
        );

    //-------------------------//

    NetR.lpRemoteName = L"lanman";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        ERROR_INVALID_NAME
        );

    //-------------------------//

    NetR.lpRemoteName = L"\\\\S\\Y";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

    //-------------------------//

    NetR.lpRemoteName = L"\\\\Server\\Volume\\Dir";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

#endif

}


DWORD
TestCreateConnection(
    IN  LPWSTR LocalName OPTIONAL,
    IN  LPWSTR RemoteName,
    IN  LPWSTR Password OPTIONAL,
    IN  LPWSTR UserName OPTIONAL,
    IN  DWORD ExpectedError
    )
{
    DWORD status;
    NETRESOURCEW NetR;


    printf("\nTestCreateConnection: Local %ws, Remote %ws", LocalName, RemoteName);

    if (ARGUMENT_PRESENT(UserName)) {
        printf(" UserName %ws", UserName);
    }

    if (ARGUMENT_PRESENT(Password)) {
        printf(" Password %ws", Password);

    }

    printf("\n");

    NetR.lpLocalName = LocalName;
    NetR.lpRemoteName = RemoteName;

    NetR.dwType = RESOURCETYPE_ANY;

    status = NPAddConnection(
                &NetR,
                Password,
                UserName
                );

    if (status != WN_SUCCESS) {
        status = GetLastError();
    }

    if (status != ExpectedError) {
        printf("    FAILED: expected %lu got %lu\n", ExpectedError, status);
    }
    else {
        printf("    SUCCESS: got %lu as expected\n", status);
    }

    return status;

}

DWORD
TestDeleteConnection(
    IN  LPWSTR ConnectionName,
    IN  BOOL ForceFlag,
    IN  DWORD ExpectedError
    )
{
    DWORD status;


    printf("\nTestDeleteConnection: Connection %ws, ForceFlag %u\n",
           ConnectionName, ForceFlag);

    status = NPCancelConnection(
                 ConnectionName,
                 ForceFlag
                 );

    if (status != WN_SUCCESS) {
        status = GetLastError();
    }

    if (status != ExpectedError) {
        printf("    FAILED: expected %lu got %lu\n", ExpectedError, status);
    }
    else {
        printf("    SUCCESS: got %lu as expected\n", status);
    }

    return status;
}

DWORD
TestOpenEnum(
    IN DWORD Scope,
    IN LPNETRESOURCEW NetR OPTIONAL,
    OUT LPHANDLE EnumHandle,
    IN  DWORD ExpectedError
    )
{
    DWORD status;


    if (NetR != NULL) {
        printf("\nTestOpenEnum: Remote %ws\n", NetR->lpRemoteName);
    }

    status = NPOpenEnum(
                   Scope,
                   0,
                   0,
                   NetR,
                   EnumHandle
                   );


    if (status != WN_SUCCESS) {
        status = GetLastError();
    }

    if (status != ExpectedError) {
        printf("    FAILED: expected %lu got %lu\n", ExpectedError, status);
    }
    else {
        printf("    SUCCESS: got %lu as expected\n", status);
    }

    return status;
}

DWORD
TestEnum(
    IN HANDLE EnumHandle,
    IN DWORD EntriesRequested,
    IN LPVOID Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    IN DWORD ExpectedError
    )
{
    DWORD status;
    DWORD EntriesRead = EntriesRequested;

    DWORD i;
    LPNETRESOURCE NetR = Buffer;


    *BytesNeeded = BufferSize;

    printf("\nTestEnum: EntriesRequested x%08lx, BufferSize %lu\n",
           EntriesRead, *BytesNeeded);

    status = NPEnumResource(
                 EnumHandle,
                 &EntriesRead,
                 Buffer,
                 BytesNeeded
                 );

    if (status == WN_SUCCESS) {

        printf("         EntriesRead is %lu\n", EntriesRead);

        for (i = 0; i < EntriesRead; i++, NetR++) {
            PrintNetResource(NetR);
        }

    }
    else if (status != WN_NO_MORE_ENTRIES) {

        status = GetLastError();

        if (status == WN_MORE_DATA) {
            printf("         BytesNeeded is %lu\n", *BytesNeeded);
        }
    }

    if (status != ExpectedError) {
        printf("    FAILED: expected %lu got %lu\n", ExpectedError, status);
    }
    else {
        printf("    SUCCESS: got %lu as expected\n", status);
    }

    return status;
}

VOID
PrintNetResource(
    LPNETRESOURCE NetR
    )
{
    if (NetR->lpLocalName != NULL) {
        printf("%-7ws", NetR->lpLocalName);
    }

    printf(" %-ws\n", NetR->lpRemoteName);

    if (NetR->lpComment != NULL) {
        printf(" %-ws\n", NetR->lpComment);
    }

    if (NetR->lpProvider != NULL) {
        printf(" %-ws\n", NetR->lpProvider);
    }

    printf("Scope: x%lx", NetR->dwScope);
    printf(" Type: x%lx", NetR->dwType);
    printf(" DisplayType: x%lx", NetR->dwDisplayType);
    printf(" Usage: x%lx\n", NetR->dwUsage);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\idl\imports.h ===
#include <windef.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define PSECURITY_DESCRIPTOR DWORD
#endif

#include <stdarg.h>
#include <winbase.h>
#include <wingdi.h>
#include <winspool.h>
#define _INC_WINDOWS
#include <winsock2.h>
#include <wsipx.h>
#include <nspapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\client\provider.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    provider.c

Abstract:

    This module contains NetWare Network Provider code.  It is the
    client-side wrapper for APIs supported by the Workstation service.

Author:

    Rita Wong  (ritaw)   15-Feb-1993

Revision History:

    Yi-Hsin Sung (yihsins) 10-July-1993
        Moved all dialog handling to nwdlg.c

--*/

#include <nwclient.h>
#include <nwsnames.h>
#include <nwcanon.h>
#include <validc.h>
#include <nwevent.h>
#include <ntmsv1_0.h>
#include <nwdlg.h>
#include <nwreg.h>
#include <nwauth.h>
#include <mpr.h>    // WNFMT_ manifests
#include <nwmisc.h>

#ifndef NT1057
#include <nwutil.h>
#endif

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
BOOL
NwpWorkstationStarted(
    VOID
    );

STATIC
DWORD
NwpMapNameToUNC(
    IN LPWSTR pszName,
    OUT LPWSTR *ppszUNC
    );

STATIC
VOID
NwpGetUncInfo(
    IN LPWSTR lpstrUnc,
    OUT WORD * slashCount,
    OUT BOOL * isNdsUnc
    );

STATIC
LPWSTR
NwpGetUncObjectName(
    IN LPWSTR ContainerName
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

#if DBG
DWORD NwProviderTrace = 0;
#endif


DWORD
APIENTRY
NPGetCaps(
    IN DWORD QueryVal
    )
/*++

Routine Description:

    This function returns the functionality supported by this network
    provider.

Arguments:

    QueryVal - Supplies a value which determines the type of information
        queried regarding the network provider's support in this area.

Return Value:

    Returns a value which indicates the level of support given by this
    provider.

--*/
{

#if DBG
    IF_DEBUG(INIT) {
        KdPrint(("\nNWPROVAU: NPGetCaps %lu\n", QueryVal));
    }
#endif

    switch (QueryVal) {

        case WNNC_SPEC_VERSION:
            return 0x00040000;

        case WNNC_NET_TYPE:
            return WNNC_NET_NETWARE ; 

        case WNNC_USER:
            return WNNC_USR_GETUSER;

        case WNNC_CONNECTION:
            return (WNNC_CON_ADDCONNECTION |
                    WNNC_CON_ADDCONNECTION3 |
                    WNNC_CON_CANCELCONNECTION |
                    WNNC_CON_GETPERFORMANCE |
                    WNNC_CON_GETCONNECTIONS);

        case WNNC_ENUMERATION:
            return ( WNNC_ENUM_GLOBAL |
                     WNNC_ENUM_CONTEXT |
                     WNNC_ENUM_LOCAL );

        case WNNC_START:
            if (NwpWorkstationStarted()) {
                return 1;
            }
            else {
                return 0xffffffff;   // don't know
            }

        case WNNC_DIALOG:
            return WNNC_DLG_FORMATNETWORKNAME
#ifdef NT1057
                 ;
#else
                 | WNNC_DLG_GETRESOURCEPARENT | WNNC_DLG_GETRESOURCEINFORMATION;
#endif

        //
        // The rest are not supported by the NetWare provider
        //
        default:
            return 0;
    }

}

#define NW_EVENT_MESSAGE_FILE          L"nwevent.dll"



DWORD
APIENTRY
NPGetUser(
    LPWSTR  lpName,
    LPWSTR  lpUserName,
    LPDWORD lpUserNameLen
    )
/*++

Routine Description:

    This is used to determine either the current default username, or the
    username used to establish a network connection.

Arguments:

    lpName - Contains the name of the local device the caller is interested
        in, or a network name that the user has made a connection to. This
        may be NULL or the empty string if the caller is interested in the
        name of the user currently logged on to the system. If a network
        name is passed in, and the user is connected to that resource using
        different names, it is possible that a provider cannont resolve 
        which username to return. In this case the provider may make an
        arbitrary choice amonst the possible usernames.

    lpUserName - Points to a buffer to receive the user name. this should
        be a name that can be passed into the NPAddConnection or
        NPAddConnection3 function to re-establish the connection with the
        same user name.

    lpBufferSize - This is used to specify the size (in characters) of the
        buffer passed in. If the call fails because the buffer is not big
        enough, this location will be used to return the required buffer size.

Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, an error code is,
        returned, which may include:

    WN_NOT_CONNECTED - lpName not a redirected device nor a connected network
        name.

    WN_MORE_DATA - The buffer is too small.

    WN_NO_NETWORK - Network not present.

--*/
{
    DWORD  status;
    DWORD  dwUserNameBufferSize = *lpUserNameLen * sizeof(WCHAR);
    DWORD  CharsRequired = 0;

    if (lpName == NULL)
    {
        return WN_NOT_CONNECTED;
    }

    RtlZeroMemory( lpUserName, dwUserNameBufferSize );

#if DBG
    IF_DEBUG(CONNECT)
    {
        KdPrint(("\nNWPROVAU: NPGetUser %ws\n", lpName));
    }
#endif

    RpcTryExcept
    {
            status = NwrGetUser(
                        NULL,
                        lpName,
                        (LPBYTE) lpUserName,
                        dwUserNameBufferSize,
                        &CharsRequired
                        );

            if (status == WN_MORE_DATA)
            {
                //
                // Output buffer too small.
                //
                *lpUserNameLen = CharsRequired;
            }
    }
    RpcExcept(1)
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {
        SetLastError(status);
    }

    return status;
}


DWORD
APIENTRY
NPAddConnection(
    LPNETRESOURCEW lpNetResource,
    LPWSTR lpPassword,
    LPWSTR lpUserName
    )
/*++

Routine Description:

    This function creates a remote connection.

Arguments:

    lpNetResource - Supplies the NETRESOURCE structure which specifies
        the local DOS device to map, the remote resource to connect to
        and other attributes related to the connection.

    lpPassword - Supplies the password to connect with.

    lpUserName - Supplies the username to connect with.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_VALUE - Invalid value specifed in lpNetResource.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_BAD_LOCALNAME - Invalid local DOS device name.

    WN_BAD_PASSWORD - Invalid password.

    WN_ALREADY_CONNECTED - Local DOS device name is already in use.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;
    LPWSTR pszRemoteName = NULL;

    UCHAR EncodeSeed = NW_ENCODE_SEED3;
    UNICODE_STRING PasswordStr;

    LPWSTR CachedUserName = NULL ;
    LPWSTR CachedPassword = NULL ;

    PasswordStr.Length = 0;

    status = NwpMapNameToUNC(
                 lpNetResource->lpRemoteName,
                 &pszRemoteName );

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return status;
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWPROVAU: NPAddConnection %ws\n", pszRemoteName));
    }
#endif

    RpcTryExcept
    {
        if (lpNetResource->dwType != RESOURCETYPE_ANY &&
            lpNetResource->dwType != RESOURCETYPE_DISK &&
            lpNetResource->dwType != RESOURCETYPE_PRINT)
        {
            status = WN_BAD_VALUE;
        }
        else
        {
#ifdef NT1057
            //
            // no credentials specified, see if we have cached credentials
            //
            if (!lpPassword && !lpUserName) 
            {
                 (void) NwpRetrieveCachedCredentials(
                            pszRemoteName,
                            &CachedUserName,
                            &CachedPassword) ;

                 //
                 // these values will be NULL still if nothing found
                 //
                 lpPassword = CachedPassword ;
                 lpUserName = CachedUserName ;
            }
#endif

            //
            // Encode password.
            //
            RtlInitUnicodeString(&PasswordStr, lpPassword);
            RtlRunEncodeUnicodeString(&EncodeSeed, &PasswordStr);

            status = NwrCreateConnection(
                        NULL,
                        lpNetResource->lpLocalName,
                        pszRemoteName,
                        lpNetResource->dwType,
                        lpPassword,
                        lpUserName
                        );

            if (CachedUserName)
            {
                (void)LocalFree((HLOCAL)CachedUserName);
            }

            if (CachedPassword)
            {
                RtlZeroMemory(CachedPassword,
                              wcslen(CachedPassword) *
                              sizeof(WCHAR)) ;
                (void)LocalFree((HLOCAL)CachedPassword);
            }
        }
    }
    RpcExcept(1)
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (PasswordStr.Length != 0 && !CachedPassword)
    {
        //
        // Restore password to original state
        //
        RtlRunDecodeUnicodeString(NW_ENCODE_SEED3, &PasswordStr);
    }

    if (status == ERROR_SHARING_PAUSED)
    {
        HMODULE MessageDll;
        WCHAR Buffer[1024];
        DWORD MessageLength;
        DWORD err;
        HKEY  hkey;
        LPWSTR pszProviderName = NULL;
    
        //
        // Load the netware message file DLL
        //
        MessageDll = LoadLibraryW(NW_EVENT_MESSAGE_FILE);
    
        if (MessageDll == NULL)
        {
            goto ExitPoint ;
        }

        //
        // Read the Network Provider Name.
        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
        // \NWCWorkstation\networkprovider
        //
        err = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  NW_WORKSTATION_PROVIDER_PATH,
                  REG_OPTION_NON_VOLATILE,   // options
                  KEY_READ,                  // desired access
                  &hkey
                  );
    
        if ( !err )
        {
            //
            // ignore the return code. if fail, pszProviderName is NULL
            //
            err =  NwReadRegValue(
                      hkey,
                      NW_PROVIDER_VALUENAME,
                      &pszProviderName          // free with LocalFree
                      );
    
            RegCloseKey( hkey );
        }

        if (err)
        {
            (void) FreeLibrary(MessageDll);
            goto ExitPoint ;
        }

        RtlZeroMemory(Buffer, sizeof(Buffer)) ;

        //
        // Get string from message file 
        //
        MessageLength = FormatMessageW(
                            FORMAT_MESSAGE_FROM_HMODULE,
                            (LPVOID) MessageDll,
                            NW_LOGIN_DISABLED,
                            0,
                            Buffer,
                            sizeof(Buffer) / sizeof(WCHAR),
                            NULL
                            );

        if (MessageLength != 0)
        {
            status = WN_EXTENDED_ERROR ;
            WNetSetLastErrorW(NW_LOGIN_DISABLED, 
                              Buffer,
                              pszProviderName) ;
        }

        (void) LocalFree( (HLOCAL) pszProviderName );
        (void) FreeLibrary(MessageDll);

    }

ExitPoint: 

    if (status != NO_ERROR)
    {
        SetLastError(status);
    }
    
    LocalFree( (HLOCAL) pszRemoteName );
    return status;
}


DWORD
APIENTRY
NPAddConnection3(
    HWND   hwndOwner,
    LPNETRESOURCEW lpNetResource,
    LPWSTR lpPassword,
    LPWSTR lpUserName,
    DWORD  dwConnFlags
    )
/*++

Routine Description:

    This function creates a remote connection.

Arguments:

    hwndOwner - Owner window handle for dialog boxes

    lpNetResource - Supplies the NETRESOURCE structure which specifies
        the local DOS device to map, the remote resource to connect to
        and other attributes related to the connection.

    lpPassword - Supplies the password to connect with.

    lpUserName - Supplies the username to connect with.

    dwConnFlags -  CONNECT_UPDATE_PROFILE...

Return Value:

    NO_ERROR - Successful.

    WN_BAD_VALUE - Invalid value specifed in lpNetResource.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_BAD_LOCALNAME - Invalid local DOS device name.

    WN_BAD_PASSWORD - Invalid password.

    WN_ALREADY_CONNECTED - Local DOS device name is already in use.

    Other network errors.

--*/
{
    DWORD err = NO_ERROR;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

    if (   ( dwConnFlags & CONNECT_PROMPT )
       && !( dwConnFlags & CONNECT_INTERACTIVE )
       )
    {
        return WN_BAD_VALUE;
    }

    if ( !(dwConnFlags & CONNECT_PROMPT ))
    {
        err = NPAddConnection( lpNetResource,
                               lpPassword, 
                               lpUserName );

        if (  ( err == NO_ERROR ) 
           || !( dwConnFlags & CONNECT_INTERACTIVE )  // Cannot popup dialog
           )
        {
            return err;
        }
    }

    for (;;)
    {
        if (  ( err != NO_ERROR )             // CONNECT_PROMPT
           && ( err != WN_BAD_PASSWORD )
           && ( err != WN_ACCESS_DENIED )
           && ( err != ERROR_NO_SUCH_USER )
           )
        {
            // Errors not related to access problems
            break;
        }

        if ( UserName )
        {
            (void) LocalFree( UserName );
            UserName = NULL;
        }
 
        if ( Password )
        {
            memset( Password, 0, wcslen(Password) * sizeof(WCHAR));
            (void) LocalFree( Password );
            Password = NULL;
        }

        //
        // Put up dialog to get username
        // and password.
        //
        err = NwpGetUserCredential( hwndOwner,
                                    lpNetResource->lpRemoteName,
                                    err,
                                    lpUserName,
                                    &UserName,
                                    &Password );

        if ( err != NO_ERROR )
            break;

        err = NPAddConnection( lpNetResource,
                               Password, 
                               UserName );

        if ( err == NO_ERROR )
        {
#if 0
            if ( (UserName != NULL) && (Password != NULL))
            {
                // Checking UserName and Password is to make sure that
                // we have prompted for password
                (VOID) NwpCacheCredentials( lpNetResource->lpRemoteName,
                                            UserName,
                                            Password ) ;
            }
#endif
            break;
        }
    }

    if ( UserName )
        (void) LocalFree( UserName );
 
    if ( Password )
    {
        memset( Password, 0, wcslen(Password) * sizeof(WCHAR));
        (void) LocalFree( Password );
    }

    return err;
}



DWORD
APIENTRY
NPCancelConnection(
    LPWSTR lpName,
    BOOL fForce
    )
/*++

Routine Description:

    This function deletes a remote connection.

Arguments:

    lpName - Supplies the local DOS device, or the remote resource name
        if it is a UNC connection to delete.

    fForce - Supplies the force level to break the connection.  TRUE means
        to forcefully delete the connection, FALSE means end the connection
        only if there are no opened files.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_OPEN_FILES - fForce is FALSE and there are opened files on the
        connection.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;
    LPWSTR pszName = NULL;

    // 
    // We only need to map remote resource name  
    //

    if ( NwLibValidateLocalName( lpName ) != NO_ERROR )
    {
        status = NwpMapNameToUNC(
                     lpName,
                     &pszName 
                     );

        if (status != NO_ERROR) {
            SetLastError(status);
            return status;
        }
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWPROVAU: NPCancelConnection %ws, Force %u\n",
                 pszName? pszName : lpName, fForce));
    }
#endif

    RpcTryExcept {

        status = NwrDeleteConnection(
                    NULL,
                    pszName? pszName : lpName,
                    (DWORD) fForce
                    );

    }
    RpcExcept(1) {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
    }

    LocalFree( (HLOCAL) pszName );
    return status;

}



DWORD
APIENTRY
NPGetConnection(
    LPWSTR lpLocalName,
    LPWSTR lpRemoteName,
    LPDWORD lpnBufferLen
    )
/*++

Routine Description:

    This function returns the remote resource name for a given local
    DOS device.

Arguments:

    lpLocalName - Supplies the local DOS device to look up.

    lpRemoteName - Output buffer to receive the remote resource name
        mapped to lpLocalName.

    lpnBufferLen - On input, supplies length of the lpRemoteName buffer
        in number of characters.  On output, if error returned is
        WN_MORE_DATA, receives the number of characters required of
        the output buffer to hold the output string.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_LOCALNAME - Invalid local DOS device.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_MORE_DATA - Output buffer is too small.

    Other network errors.

--*/
{

    DWORD status = NO_ERROR;
    DWORD CharsRequired;

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWPROVAU: NPGetConnection %ws\n", lpLocalName));
    }
#endif

    RpcTryExcept {

        if (lpRemoteName && *lpnBufferLen)
            *lpRemoteName = 0 ;

        status = NwrQueryServerResource(
                    NULL,
                    lpLocalName,
                    (*lpnBufferLen == 0? NULL : lpRemoteName),
                    *lpnBufferLen,
                    &CharsRequired
                    );
         
         if (status == ERROR_INSUFFICIENT_BUFFER)
             status = WN_MORE_DATA;

        if (status == WN_MORE_DATA) {
            *lpnBufferLen = CharsRequired;
        }

    }
    RpcExcept(1) {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWPROVAU: NPGetConnection returns %lu\n", status));
        if (status == NO_ERROR) {
            KdPrint(("                                  %ws, BufferLen %lu, CharsRequired %lu\n", lpRemoteName, *lpnBufferLen, CharsRequired));

        }
    }
#endif

    return status;
}


DWORD
APIENTRY
NPGetConnectionPerformance(
    LPCWSTR lpRemoteName,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    )
/*++

Routine Description:

    This function returns information about the expected performance of a
    connection used to access a network resource. The request can only be
    for a network resource to which there is currently a connection.

Arguments:

    lpRemoteName - Contains the local name or remote name for a resource
                   for which a connection exists.

    lpNetConnectInfo - This is a pointer to a NETCONNECTINFOSTRUCT structure
                       which is to be filled if the connection performance
                       of connection lpRemoteName can be determined.

Return Value:

    NO_ERROR - Successful.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_NONETWORK - Network is not present.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;
    LPWSTR pszRemoteName;

    if ( lpNetConnectInfo == NULL )
    {
            status = ERROR_INVALID_PARAMETER;
            SetLastError(status);
            return status;
    }

    pszRemoteName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                         ( wcslen(lpRemoteName) + 1 ) *
                                         sizeof(WCHAR) );

    if ( pszRemoteName == NULL )
    {
            status = ERROR_NOT_ENOUGH_MEMORY;
            SetLastError(status);
            return status;
    }

    wcscpy( pszRemoteName, lpRemoteName );
    _wcsupr( pszRemoteName );

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWPROVAU: NPGetConnectionPerformance %ws\n", pszRemoteName));
    }
#endif

    RpcTryExcept {

        status = NwrGetConnectionPerformance(
                    NULL,
                    pszRemoteName,
                    (LPBYTE) lpNetConnectInfo,
                    sizeof(NETCONNECTINFOSTRUCT) );

    }
    RpcExcept(1)
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {
        SetLastError(status);
    }

    LocalFree( (HLOCAL) pszRemoteName );
    return status;
}



DWORD
APIENTRY
NPGetUniversalName(
#ifdef NT1057
    LPWSTR  lpLocalPath,
#else
    LPCWSTR lpLocalPath,
#endif
    DWORD  dwInfoLevel,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function returns the universal resource name for a given local
    path.

Arguments:

    lpLocalPath - Supplies the local DOS Path to look up.

    dwInfoLevel - Info level requested.

    lpBuffer - Output buffer to receive the appropruatye structure.

    lpBufferLen - On input, supplies length of the buffer in number of 
        bytes.  On output, if error returned is WN_MORE_DATA, receives 
        the number of bytes required of the output buffer.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_LOCALNAME - Invalid local DOS device.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_MORE_DATA - Output buffer is too small.

    Other network errors.

--*/
{

    DWORD status = NO_ERROR;
    DWORD dwCharsRequired = MAX_PATH + 1 ;
    DWORD dwBytesNeeded ;
    DWORD dwLocalLength ;
    LPWSTR lpRemoteBuffer ;
    WCHAR  szDrive[3] ;

    //
    // check for bad info level
    //
    if ((dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL) &&
        (dwInfoLevel != REMOTE_NAME_INFO_LEVEL))
    {
        return WN_BAD_VALUE ;
    }

    //
    // check for bad pointers
    //
    if (!lpLocalPath || !lpBuffer || !lpBufferSize)
    {
        return WN_BAD_POINTER ;
    }
 
    //
    // local path must at least have "X:"
    //
    if (((dwLocalLength = wcslen(lpLocalPath)) < 2) ||
        (lpLocalPath[1] != L':') ||
        ((dwLocalLength > 2) && (lpLocalPath[2] != L'\\')))
    {
        return WN_BAD_VALUE ;
    }

    //
    // preallocate some memory
    //
    if (!(lpRemoteBuffer = (LPWSTR) LocalAlloc(
                                        LPTR, 
                                        dwCharsRequired * sizeof(WCHAR))))
    {
        status = GetLastError() ;
        goto ErrorExit ;
    }
    
    szDrive[2] = 0 ;
    wcsncpy(szDrive, lpLocalPath, 2) ;

    //
    // get the remote path by calling the existing API
    //
    status = NPGetConnection(
                 szDrive,
                 lpRemoteBuffer, 
                 &dwCharsRequired) ;

    if (status == WN_MORE_DATA)
    {
        //
        // reallocate the correct size
        //
        LPWSTR lpNewBuffer; 

        if (!(lpNewBuffer = (LPWSTR) LocalReAlloc(
                                            (HLOCAL) lpRemoteBuffer, 
                                            dwCharsRequired * sizeof(WCHAR),
                                            LMEM_MOVEABLE)))
        {
            status = GetLastError() ;
            LocalFree(lpRemoteBuffer);
            lpRemoteBuffer = NULL;
            goto ErrorExit ;
        }
        lpRemoteBuffer = lpNewBuffer;

        status = NPGetConnection(
                     szDrive,
                     lpRemoteBuffer, 
                     &dwCharsRequired) ;
    }

    if (status != WN_SUCCESS)
    {
        goto ErrorExit ;
    }
    
    //
    // at minimum we will need this size of the UNC name
    // the -2 is because we loose the drive letter & colon.
    //
    dwBytesNeeded = (wcslen(lpRemoteBuffer) +
                     dwLocalLength - 2 + 1) * sizeof(WCHAR) ;

    switch (dwInfoLevel)
    {
        case UNIVERSAL_NAME_INFO_LEVEL:
        {
            LPUNIVERSAL_NAME_INFO lpUniversalNameInfo ;

            //
            // calculate how many bytes we really need
            //
            dwBytesNeeded += sizeof(UNIVERSAL_NAME_INFO) ;

            if (*lpBufferSize < dwBytesNeeded)
            {
                *lpBufferSize = dwBytesNeeded ;
                status = WN_MORE_DATA ;
                break ;
            }
 
            //
            // now we are all set. just stick the data in the buffer
            //
            lpUniversalNameInfo = (LPUNIVERSAL_NAME_INFO) lpBuffer ;

            lpUniversalNameInfo->lpUniversalName = (LPWSTR)
                (((LPBYTE)lpBuffer) + sizeof(UNIVERSAL_NAME_INFO)) ;
            wcscpy(lpUniversalNameInfo->lpUniversalName,
                   lpRemoteBuffer) ;
            wcscat(lpUniversalNameInfo->lpUniversalName,
                   lpLocalPath+2) ;

            break ;
        }

        case REMOTE_NAME_INFO_LEVEL :
        {
            LPREMOTE_NAME_INFO lpRemoteNameInfo ;

            //
            // calculate how many bytes we really need
            //
            dwBytesNeeded *= 2 ;  // essentially twice the info + terminator 
            dwBytesNeeded += (sizeof(REMOTE_NAME_INFO) + sizeof(WCHAR)) ;

            if (*lpBufferSize < dwBytesNeeded)
            {
                *lpBufferSize = dwBytesNeeded ;
                status = WN_MORE_DATA ;
                break ;
            }

            //
            // now we are all set. just stick the data in the buffer
            //
            lpRemoteNameInfo = (LPREMOTE_NAME_INFO) lpBuffer ;

            lpRemoteNameInfo->lpUniversalName = (LPWSTR)
                (((LPBYTE)lpBuffer) + sizeof(REMOTE_NAME_INFO)) ;
            wcscpy(lpRemoteNameInfo->lpUniversalName,
                   lpRemoteBuffer) ;
            wcscat(lpRemoteNameInfo->lpUniversalName,
                   lpLocalPath+2) ;

            lpRemoteNameInfo->lpConnectionName = 
                lpRemoteNameInfo->lpUniversalName + 
                wcslen(lpRemoteNameInfo->lpUniversalName) + 1 ;
            wcscpy(lpRemoteNameInfo->lpConnectionName,
                   lpRemoteBuffer) ;

            lpRemoteNameInfo->lpRemainingPath = 
                lpRemoteNameInfo->lpConnectionName + 
                wcslen(lpRemoteNameInfo->lpConnectionName) + 1 ;
            wcscpy(lpRemoteNameInfo->lpRemainingPath,
                   lpLocalPath+2) ;

            break ;
        }

        default:
            //
            // yikes!
            //
            status = WN_BAD_VALUE ;
            ASSERT(FALSE);
    }

ErrorExit: 

    if (lpRemoteBuffer)
    {
        (void) LocalFree((HLOCAL)lpRemoteBuffer) ;
    }
    return status;
}



DWORD
APIENTRY
NPOpenEnum(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCEW lpNetResource,
    LPHANDLE lphEnum
    )
/*++

Routine Description:

    This function initiates an enumeration of either connections, or
    browsing of network resource.

Arguments:

    dwScope - Supplies the category of enumeration to do--either
        connection or network browsing.

    dwType - Supplies the type of resource to get--either disk,
        print, or it does not matter.

    dwUsage - Supplies the object type to get--either container,
        or connectable usage.

    lpNetResource - Supplies, in the lpRemoteName field, the container
        name to enumerate under.

    lphEnum - Receives the resumable context handle to be used on all
        subsequent calls to get the list of objects under the container.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_VALUE - Either the dwScope, dwType, or the dwUsage specified
        is not acceptable.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_NOT_CONTAINER - Remote resource name is not a container.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;

#if DBG
    IF_DEBUG(ENUM)
    {
        KdPrint(("\nNWPROVAU: NPOpenEnum\n"));
    }
#endif


    RpcTryExcept
    {
        if ( ( dwType & RESOURCETYPE_DISK ) ||
             ( dwType & RESOURCETYPE_PRINT ) ||
             ( dwType == RESOURCETYPE_ANY ) )
        {
            switch ( dwScope )
            {
                case RESOURCE_CONNECTED:

                    status = NwrOpenEnumConnections( NULL,
                                                     dwType,
                                                     (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                    break;

                case RESOURCE_CONTEXT:

                    status = NwrOpenEnumContextInfo( NULL,
                                                     dwType,
                                                     (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                    break;

                case RESOURCE_GLOBALNET:

                    if ( lpNetResource == NULL )
                    {
                        //
                        // Enumerating servers and NDS trees
                        //
                        if ( dwUsage & RESOURCEUSAGE_CONTAINER || dwUsage == 0 )
                        {
                            status = NwrOpenEnumServersAndNdsTrees( NULL,
                                                         (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                        }
                        else
                        {
                            //
                            // There is no such thing as a connectable server
                            // object.
                            //
                            status = WN_BAD_VALUE;
                        }
                    }
                    else
                    {
                        BOOL IsEnumVolumes = TRUE;
                        LPWSTR pszRemoteName = NULL;
                        WORD slashCount;
                        BOOL isNdsUnc;

                        NwpGetUncInfo( lpNetResource->lpRemoteName,
                                       &slashCount,
                                       &isNdsUnc );

                        //
                        // Either enumerating volumes, directories, or NDS subtrees
                        //

                        if ( dwUsage & RESOURCEUSAGE_CONNECTABLE ||
                             dwUsage & RESOURCEUSAGE_CONTAINER ||
                             dwUsage == 0 )
                        {
                            LPWSTR tempStrPtr = lpNetResource->lpRemoteName;
                            DWORD dwClassType = 0;

                            //
                            // Get rid of the <space> if a NDS tree name ...
                            //
                            if ( tempStrPtr[0] == L' ' &&
                                 tempStrPtr[1] == L'\\' &&
                                 tempStrPtr[2] == L'\\' )
                                tempStrPtr = &tempStrPtr[1];

                            if ( lpNetResource->dwDisplayType == RESOURCEDISPLAYTYPE_TREE )
                            {
                                if ( ( dwType == RESOURCETYPE_ANY ) ||
                                     ( ( dwType & RESOURCETYPE_DISK ) &&
                                       ( dwType & RESOURCETYPE_PRINT ) ) )
                                { 
                                    status = NwrOpenEnumNdsSubTrees_Any( NULL,
                                                                         tempStrPtr,
                                                                         NULL,
                                                              (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                }
                                else if ( dwType & RESOURCETYPE_DISK ) 
                                {
                                    status = NwrOpenEnumNdsSubTrees_Disk( NULL,
                                                                          tempStrPtr,
                                                                          NULL,
                                                              (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                }
                                else if ( dwType & RESOURCETYPE_PRINT )
                                { 
                                    status = NwrOpenEnumNdsSubTrees_Print( NULL,
                                                                           tempStrPtr,
                                                                           NULL,
                                                              (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                }
                                else
                                {
                                    KdPrint(("NWOpenEnum: Unhandled dwType %lu\n", dwType));
                                }
                            }
                            else if (
                                      ( slashCount < 4 ) &&
                                      ( ( dwType == RESOURCETYPE_ANY ) ||
                                        ( ( dwType & RESOURCETYPE_DISK ) &&
                                          ( dwType & RESOURCETYPE_PRINT ) ) ) &&
                                      ( ( status = NwrOpenEnumNdsSubTrees_Any( NULL,
                                                                               tempStrPtr,
                                                                               &dwClassType,
                                                            (LPNWWKSTA_CONTEXT_HANDLE) lphEnum ) )
                                        ==NO_ERROR )
                                    )
                            {
                                status = NO_ERROR;
                            }
                            else if (
                                      ( slashCount < 4 ) &&
                                      ( dwType & RESOURCETYPE_DISK ) &&
                                      ( ( status = NwrOpenEnumNdsSubTrees_Disk( NULL,
                                                                                tempStrPtr,
                                                                                &dwClassType,
                                                            (LPNWWKSTA_CONTEXT_HANDLE) lphEnum ) )
                                        ==NO_ERROR )
                                    )
                            {
                                status = NO_ERROR;
                            }
                            else if (
                                      ( slashCount < 4 ) &&
                                      ( dwType & RESOURCETYPE_PRINT ) &&
                                      ( ( status = NwrOpenEnumNdsSubTrees_Print( NULL,
                                                                                 tempStrPtr,
                                                                                 &dwClassType,
                                                            (LPNWWKSTA_CONTEXT_HANDLE) lphEnum ) )
                                        ==NO_ERROR )
                                    )
                            {
                                status = NO_ERROR;
                            }
                            else if (
                                     (slashCount < 4
                                      &&
                                      (status == ERROR_NETWORK_ACCESS_DENIED
                                       ||
                                       status == ERROR_GEN_FAILURE
                                       ||
                                       status == ERROR_ACCESS_DENIED
                                       ||
                                       status == ERROR_BAD_NETPATH
                                       ||
                                       status == WN_BAD_NETNAME
                                       ||
                                       status == ERROR_INVALID_NAME))
                                     ||
                                     ( slashCount > 3 && status == NO_ERROR )
                                    )
                            {
                                if (( status == ERROR_NETWORK_ACCESS_DENIED ) &&
                                    ( dwClassType == CLASS_TYPE_NCP_SERVER ))
                                {
                                    status = NO_ERROR;
                                    isNdsUnc = TRUE;
                                    IsEnumVolumes = TRUE;
                                }
                                else if ( ( status == ERROR_NETWORK_ACCESS_DENIED ) &&
                                          ( ( dwClassType == CLASS_TYPE_VOLUME ) ||
                                            ( dwClassType == CLASS_TYPE_DIRECTORY_MAP ) ) )
                                {
                                    status = NO_ERROR;
                                    isNdsUnc = TRUE;
                                    IsEnumVolumes = FALSE;
                                }
                                else
                                {
                                    //
                                    // A third backslash means that we want to
                                    // enumerate the directories.
                                    //

                                    if ( isNdsUnc && slashCount > 3 )
                                        IsEnumVolumes = FALSE;

                                    if ( !isNdsUnc && slashCount > 2 )
                                        IsEnumVolumes = FALSE;

                                    if ( lpNetResource->dwDisplayType == RESOURCEDISPLAYTYPE_SHARE )
                                        IsEnumVolumes = FALSE;
                                }

                                status = NwpMapNameToUNC( tempStrPtr,
                                                          &pszRemoteName );
 
                                if ( status == NO_ERROR )
                                {
                                    if ( IsEnumVolumes ) 
                                    {
                                        LPWSTR pszServerName = pszRemoteName;

                                        // The following 10 lines are a hack to 
                                        // allow the provider to browse past the CN=<server>
                                        // object in an NDS tree.
                                        if ( slashCount == 3 && isNdsUnc == TRUE )
                                        {
                                            pszServerName = (LPWSTR)
                                                          NwpGetUncObjectName( pszRemoteName );

                                            if ( pszServerName == NULL )
                                                pszServerName = pszRemoteName;
                                        }
                                        else if ( dwUsage & RESOURCEUSAGE_ATTACHED )
                                        {
#ifndef NT1057
                                            // This is a bindery server.
                                            // Return WN_NOT_AUTHENTICATED if
                                            // we are not already attached so
                                            // that clients ( explorer ) will
                                            // do NPAddConnection3 to make
                                            // a connection to the server.
                                            BOOL  fAttached;
                                            BOOL  fAuthenticated;

                                            status = NwIsServerOrTreeAttached(
                                                         pszServerName + 2,
                                                         &fAttached,
                                                         &fAuthenticated );

                                            if ( status != NO_ERROR )
                                                break;

                                            if ( !fAttached || !fAuthenticated)
                                            {
                                                // See if the server belongs to
                                                // our provider.
                                                status = NwrOpenEnumVolumes(
                                                             NULL,
                                                             pszServerName,
                                                             (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );

                                                if ( status == NO_ERROR )
                                                {
                                                    // The server belongs to us.
                                                    // Close the handle and
                                                    // return not attached if
                                                    // callee passed in dwUsage
                                                    // flag:
                                                    // RESOURCEUSAGE_ATTACHED.
                                                    // Note: handle will be null
                                                    // after return from 
                                                    // NwrCloseEnum

                                                    NwrCloseEnum( (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );

                                                    status = WN_NOT_AUTHENTICATED;
                                                }
                                                else
                                                {
                                                    // else the server does not 
                                                    // belong to us.
                                                    status = WN_BAD_NETNAME;
                                                }
                                                break;
                                            }
#endif
                                        } // else, this is a bindery server and
                                          // client does not care whether we
                                          // are bindery authenticated.

                                        if ( ( dwType == RESOURCETYPE_ANY ) ||
                                             ( ( dwType & RESOURCETYPE_DISK ) &&
                                               ( dwType & RESOURCETYPE_PRINT ) ) )
                                        { 
                                            status = NwrOpenEnumVolumesQueues(
                                                           NULL,
                                                           pszServerName,
                                                           (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                        }
                                        else if ( dwType & RESOURCETYPE_DISK ) 
                                        {
                                            status = NwrOpenEnumVolumes(
                                                             NULL,
                                                             pszServerName,
                                                             (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                        } 
                                        else if ( dwType & RESOURCETYPE_PRINT )
                                        {
                                            status = NwrOpenEnumQueues(
                                                             NULL,
                                                             pszServerName,
                                                             (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                        }
                                    }
                                    else
                                    {
                                        LPWSTR CachedUserName = NULL ;
                                        LPWSTR CachedPassword = NULL ;

#ifdef NT1057  // Make OpenEnum not interactive on SUR
                                        (void) NwpRetrieveCachedCredentials( pszRemoteName,
                                                                             &CachedUserName,
                                                                             &CachedPassword );

#endif
                                        status = NwrOpenEnumDirectories( 
                                                             NULL,
                                                             pszRemoteName,
                                                             CachedUserName,
                                                             CachedPassword,
                                                             (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );

#ifndef NT1057  // Make OpenEnum not interactive on SUR
                                        if (  (status == ERROR_INVALID_PASSWORD)
                                           || (status == ERROR_NO_SUCH_USER )
                                           )
                                        {
                                            status = WN_NOT_AUTHENTICATED;
                                            break;
                                        }

#else
                                        if ( CachedUserName )
                                        {
                                            (void) LocalFree( (HLOCAL) CachedUserName );
                                        }

                                        if ( CachedPassword )
                                        {
                                            RtlZeroMemory( CachedPassword,
                                                           wcslen(CachedPassword) *
                                                           sizeof( WCHAR ) );

                                            (void) LocalFree( ( HLOCAL ) CachedPassword );
                                        }

                                        if ( ( status == ERROR_INVALID_PASSWORD ) ||
                                             ( status == ERROR_NO_SUCH_USER ) )
                                        {
                                            LPWSTR UserName;
                                            LPWSTR Password;
                                            LPWSTR TmpPtr;

                                            //
                                            // Put up dialog to get username
                                            // and password.
                                            //
                                            status = NwpGetUserCredential( NULL,
                                                                     tempStrPtr,
                                                                     status,
                                                                     NULL,
                                                                     &UserName,
                                                                     &Password);

                                            if ( status == NO_ERROR )
                                            {
                                                status = NwrOpenEnumDirectories(
                                                             NULL,
                                                             pszRemoteName,
                                                             UserName,
                                                             Password,
                                                             (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );

                                                if ( status == NO_ERROR )
                                                {
                                                    status = NwpCacheCredentials(
                                                                 pszRemoteName,
                                                                 UserName,
                                                                 Password ) ;
                                                }

                                                (void) LocalFree( UserName );
                                       
                                                //
                                                // Clear the password
                                                //
                                                TmpPtr = Password;
                                                while ( *TmpPtr != 0 )
                                                    *TmpPtr++ = 0;

                                                (void) LocalFree( Password );
                                            }
                                            else if ( status == ERROR_WINDOW_NOT_DIALOG )
                                            {
                                                //
                                                // Caller is not a GUI app.
                                                //
                                                status = ERROR_INVALID_PASSWORD;
                                            }
                                            else if ( status == WN_CANCEL )
                                            {
                                                //
                                                // Cancel was pressed but we still
                                                // have to return success or MPR
                                                // will popup the error.  Return
                                                // a bogus enum handle.
                                                //
                                                *lphEnum = (HANDLE) 0xFFFFFFFF;
                                                status = NO_ERROR;
                                            }
                                        }
#endif
                                    }
                                }
                                else
                                {
                                    status = WN_BAD_NETNAME;
                                }
                            }
                        }
                        else
                        {
                            status = WN_BAD_VALUE;
                        }

                        if ( pszRemoteName != NULL )
                            LocalFree( (HLOCAL) pszRemoteName );
                    }

                    break;

                default:
                    KdPrint(("NWPROVIDER: Invalid dwScope %lu\n", dwScope));
                    status = WN_BAD_VALUE;
            } // end switch
        }
        else
        {
             status = WN_BAD_VALUE;
        }
    }
    RpcExcept( 1 )
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if ( status == ERROR_FILE_NOT_FOUND )
        status = WN_BAD_NETNAME;

    if ( status != NO_ERROR )
    {
        SetLastError( status );
    }

    return status;
}


DWORD
APIENTRY
NPEnumResource(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function returns a lists of objects within the container
    specified by the enumeration context handle.

Arguments:

    hEnum - Supplies the resumable enumeration context handle.

        NOTE: If this value is 0xFFFFFFFF, it is not a context
              handle and this routine is required to return
              WN_NO_MORE_ENTRIES.  This hack is to handle the
              case where the user cancelled out of the network
              credential dialog on NwrOpenEnumDirectories and we
              cannot return an error there or we generate an error
              popup.

    lpcCount - On input, supplies the number of entries to get.
      On output, if NO_ERROR is returned, receives the number
      of entries NETRESOURCE returned in lpBuffer.

    lpBuffer - Receives an array of NETRESOURCE entries, each
        entry describes an object within the container.

    lpBufferSize - On input, supplies the size of lpBuffer in
        bytes.  On output, if WN_MORE_DATA is returned, receives
        the number of bytes needed in the buffer to get the
        next entry.

Return Value:


    NO_ERROR - Successfully returned at least one entry.

    WN_NO_MORE_ENTRIES - Reached the end of enumeration and nothing
        is returned.

    WN_MORE_DATA - lpBuffer is too small to even get one entry.

    WN_BAD_HANDLE - The enumeration handle is invalid.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;
    DWORD BytesNeeded = 0;
    DWORD EntriesRead = 0;

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWPROVAU: NPEnumResource\n"));
    }
#endif

    RpcTryExcept {

        if (hEnum == (HANDLE) 0xFFFFFFFF) {
            status = WN_NO_MORE_ENTRIES;
            goto EndOfTry;
        }

        status = NwrEnum(
                     (NWWKSTA_CONTEXT_HANDLE) hEnum,
                     *lpcCount,
                     (LPBYTE) lpBuffer,
                     *lpBufferSize,
                     &BytesNeeded,
                     &EntriesRead
                     );

        if (status == WN_MORE_DATA) {

            //
            // Output buffer too small to fit a single entry.
            //
            *lpBufferSize = BytesNeeded;
        }
        else if (status == NO_ERROR) {
            *lpcCount = EntriesRead;
        }

EndOfTry: ;

    }
    RpcExcept(1) {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR && status != WN_NO_MORE_ENTRIES) {
        SetLastError(status);
    }
    else 
    {

        //
        // Convert offsets of strings to pointers
        //
        if (EntriesRead > 0) {
    
            DWORD i;
            LPNETRESOURCEW NetR;


            NetR = lpBuffer;

            for (i = 0; i < EntriesRead; i++, NetR++) {

                if (NetR->lpLocalName != NULL) {
                    NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                                  (DWORD_PTR) NetR->lpLocalName);
                }

                NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                               (DWORD_PTR) NetR->lpRemoteName);

                if (NetR->lpComment != NULL) {
                    NetR->lpComment = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                                (DWORD_PTR) NetR->lpComment);
                }

                if (NetR->lpProvider != NULL) {
                    NetR->lpProvider = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                                 (DWORD_PTR) NetR->lpProvider);
                }
            }
        }
    }

    return status;
}


DWORD
APIENTRY
NPGetResourceInformation(
    LPNETRESOURCEW lpNetResource,
    LPVOID         lpBuffer,
    LPDWORD        cbBuffer,
    LPWSTR       * lplpSystem
    )
/*++

Routine Description:

    This function returns an object which details information
    about a specified network resource.

Arguments:

    lpNetResource - This specifies the network resource for which the
        information is required. The lpRemoteName field of the NETRESOURCE
        specifies the remote name of the network resource whose information
        is required. If the calling program knows the values for the 
        lpProvider and dwType fields, then it should fill them in, otherwise,
        it should set them to NULL. All other fields in the NETRESOURCE are
        ignored and are not initialized.

    lpBuffer - A pointer to the buffer to receive the result, which is
        returned as a single NETRESOURCE entry representing the parent
        resource. The lpRemoteName, lpProvider, dwType, and dwUsage fields
        are returned, all other fields being set to NULL. The remote name
        returned should be in the same syntax as that returned from an 
        enumeration, so that the caller can do a case sensitive string 
        compare to determine whether an enumerated resource is this resource.
        If the provider owns a parent of the network resource, (in other
        words is known to be the correct network to respond to this request),
        then lpProvider should be filled in with a non-null entry. If it is
        known that a network owns a parent of the resource, but that the 
        resource itself is not valid, then lpProvider is returned as a 
        non-null value together with a return status of WN_BAD_VALUE. dwScope
        is returned as RESOURCE_CONTEXT if the network resource is part of
        the user's network context, otherwise it is returned as zero.

    cbBuffer - This specifies the size in bytes of the buffer passed to the
        function call. If the result is WN_MORE_DATA, this will contain the
        buffer size required (in bytes) to hold the NETRESOURCE information.

    lplpSystem - Returned pointer to a string in the buffer pointed to by
        lpBuffer that specifies the part of the resource that is accessed
        through resource type specific system APIs rather than WNet APIs.
        For example, if the input remote resource name was
        "\\server\share\dir", then lpRemoteName is returned pointing to 
        "\\server\share" and lplpSystem points to "\dir", both strings
        being stored in the buffer pointed to by lpBuffer.

Return Value:


    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.

    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType, or bad combination
        of parameters is specified (e.g. lpRemoteName does not correspond 
        to dwType).

    WN_BAD_NETNAME - The resource is not recognized by this provider.

--*/
{
    DWORD  status;
    LPWSTR pszRemoteName = NULL;
    DWORD  BytesNeeded = 0;
    DWORD  SystemOffset = 0;

    *lplpSystem = NULL;

    status = NwpMapNameToUNC( lpNetResource->lpRemoteName, &pszRemoteName );

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return status;
    }

#if DBG
    IF_DEBUG(CONNECT)
    {
        KdPrint(("\nNWPROVAU: NPGetResourceInformation %ws\n", pszRemoteName));
    }
#endif

    RpcTryExcept
    {
        if (lpNetResource->dwType != RESOURCETYPE_ANY &&
            lpNetResource->dwType != RESOURCETYPE_DISK &&
            lpNetResource->dwType != RESOURCETYPE_PRINT)
        {
            status = WN_BAD_VALUE;
        }
        else
        {
            status = NwrGetResourceInformation(
                        NULL,
                        pszRemoteName,
                        lpNetResource->dwType,
                        (LPBYTE) lpBuffer,
                        *cbBuffer,
                        &BytesNeeded,
                        &SystemOffset
                        );

            if (status == WN_MORE_DATA)
            {
                //
                // Output buffer too small.
                //
                *cbBuffer = BytesNeeded;
            }
        }
    }
    RpcExcept(1)
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept
    if ( pszRemoteName )
        LocalFree( (HLOCAL) pszRemoteName );

    if (status != NO_ERROR)
    {
        SetLastError(status);
    }
    else 
    {
        //
        // Convert offsets of strings to pointers
        //
        DWORD i;
        LPNETRESOURCEW NetR = lpBuffer;

        if (NetR->lpLocalName != NULL)
        {
            NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                          (DWORD_PTR) NetR->lpLocalName);
        }

        NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                       (DWORD_PTR) NetR->lpRemoteName);

        if (NetR->lpComment != NULL)
        {
            NetR->lpComment = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                        (DWORD_PTR) NetR->lpComment);
        }

        if (NetR->lpProvider != NULL)
        {
            NetR->lpProvider = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                         (DWORD_PTR) NetR->lpProvider);
        }

        if (SystemOffset != 0)
        {
            *lplpSystem = (LPWSTR) ((DWORD_PTR) lpBuffer + SystemOffset);
        }
    }

    return status;
}



DWORD
APIENTRY
NPGetResourceParent(
    LPNETRESOURCEW lpNetResource,
    LPVOID         lpBuffer,
    LPDWORD        cbBuffer
    )
/*++

Routine Description:

    This function returns an object which details information
    about the parent of a specified network resource.

Arguments:

    lpNetResource - This specifies the network resource for which the
        parent name is required. The NETRESOURCE could have been obtained via 
        previous NPEnumResource, or constructed by the caller. The lpRemoteName
        field of the NETRESOURCE specifies the remote name of the network 
        resouce whose parent name is required. If the calling program knows
        the values for the lpProvider and dwType fields, then it can fill
        them in, otherwise, they are set to NULL. If the lpProvider field is
        not NULL, then the network provider DLL can assume that the resource
        is owned by its network, but if it is NULL, then it must assume
        that the resource could be for some other network and do whatever
        checking is neccessary to ensure that the result returned is accurate.
        For example, if being asked for the parent of a server, and the server
        is not part of a workgroup, the the network provider DLL should check
        to ensure that the server is part of its network and, if so, return
        its provider name. All other fields in the NETRESOURCE are ignored and
        are not initialized.

    lpBuffer - A pointer to the buffer to receive the result, which is 
        returned as a single NETRESOURCE entry representing the parent
        resource. The lpRemoteName, lpProvider, dwType, and dwUsage fields
        are returned, all other fields being set to NULL. lpProvider should
        be set to NULL if the provider has only done a syntactic check (i.e.
        does not know that the resource is specific to its network). If the
        provider owns a parent of the network resource, (in other words is
        known to be the correct network to respond to this request), then
        lpProvider should be filled in with a non-null entry, even if the
        return is WN_BAD_VALUE. The remote name returned should be in the
        same syntax as that returned from an enumeration, so that the caller
        can do a case sensitive string compare to determine whether an
        enumerated resource is this resource. If a resource has no browse
        parent on the network, the lpRemoteName is returned as NULL. The
        RESOURCEUSAGE_CONNECTABLE value in the dwUsage field does not
        indicate that the resource can currently be connected to, but that
        the resource is connectable when it is available on the network.

    cbBuffer - This specifies the size in bytes of the buffer passed to the
        function call. If the result is WN_MORE_DATA, this will contain the
        buffer size required (in bytes) to hold the NETRESOURCE information.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.

    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType, or bad combination
        of parameters is specified (e.g. lpRemoteName does not correspond 
        to dwType).

--*/
{
    DWORD  status;
    LPWSTR pszRemoteName = NULL;
    DWORD  BytesNeeded = 0;

    status = NwpMapNameToUNC( lpNetResource->lpRemoteName, &pszRemoteName );

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return status;
    }

#if DBG
    IF_DEBUG(CONNECT)
    {
        KdPrint(("\nNWPROVAU: NPGetResourceParent %ws\n", pszRemoteName));
    }
#endif

    RpcTryExcept
    {
        if (lpNetResource->dwType != RESOURCETYPE_ANY &&
            lpNetResource->dwType != RESOURCETYPE_DISK &&
            lpNetResource->dwType != RESOURCETYPE_PRINT)
        {
            status = WN_BAD_VALUE;
        }
        else
        {
            status = NwrGetResourceParent(
                        NULL,
                        pszRemoteName,
                        lpNetResource->dwType,
                        (LPBYTE) lpBuffer,
                        *cbBuffer,
                        &BytesNeeded
                        );

            if (status == WN_MORE_DATA)
            {
                //
                // Output buffer too small.
                //
                *cbBuffer = BytesNeeded;
            }
        }
    }
    RpcExcept(1)
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept
    if ( pszRemoteName )
        LocalFree( (HLOCAL) pszRemoteName );


    if (status != NO_ERROR)
    {
        SetLastError(status);
    }
    else 
    {
        //
        // Convert offsets of strings to pointers
        //
        DWORD i;
        LPNETRESOURCEW NetR = lpBuffer;

        if (NetR->lpLocalName != NULL)
        {
            NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                          (DWORD_PTR) NetR->lpLocalName);
        }

        NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                       (DWORD_PTR) NetR->lpRemoteName);

        if (NetR->lpComment != NULL)
        {
            NetR->lpComment = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                        (DWORD_PTR) NetR->lpComment);
        }

        if (NetR->lpProvider != NULL)
        {
            NetR->lpProvider = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                         (DWORD_PTR) NetR->lpProvider);
        }
    }

    return status;
}



DWORD
APIENTRY
NwEnumConnections(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize,
    BOOL    fImplicitConnections
    )
/*++

Routine Description:

    This function returns a lists of connections.

Arguments:

    hEnum - Supplies the resumable enumeration context handle.

        NOTE: If this value is 0xFFFFFFFF, it is not a context
              handle and this routine is required to return
              WN_NO_MORE_ENTRIES.  This hack is to handle the
              case where the user cancelled out of the network
              credential dialog on NwrOpenEnumDirectories and we
              cannot return an error there or we generate an error
              popup.

    lpcCount - On input, supplies the number of entries to get.
      On output, if NO_ERROR is returned, receives the number
      of entries NETRESOURCE returned in lpBuffer.

    lpBuffer - Receives an array of NETRESOURCE entries, each
        entry describes an object within the container.

    lpBufferSize - On input, supplies the size of lpBuffer in
        bytes.  On output, if WN_MORE_DATA is returned, receives
        the number of bytes needed in the buffer to get the
        next entry.

    fImplicitConnections - TRUE is we also want all implicit connections,
        FALSE otherwise.

Return Value:


    NO_ERROR - Successfully returned at least one entry.

    WN_NO_MORE_ENTRIES - Reached the end of enumeration and nothing
        is returned.

    WN_MORE_DATA - lpBuffer is too small to even get one entry.

    WN_BAD_HANDLE - The enumeration handle is invalid.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;
    DWORD BytesNeeded = 0;
    DWORD EntriesRead = 0;

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWPROVAU: NPEnumResource\n"));
    }
#endif

    RpcTryExcept {

        if (hEnum == (HANDLE) 0xFFFFFFFF) {
            status = WN_NO_MORE_ENTRIES;
            goto EndOfTry;
        }

        status = NwrEnumConnections(
                     (NWWKSTA_CONTEXT_HANDLE) hEnum,
                     *lpcCount,
                     (LPBYTE) lpBuffer,
                     *lpBufferSize,
                     &BytesNeeded,
                     &EntriesRead,
                     fImplicitConnections
                     );

        if (status == WN_MORE_DATA) {

            //
            // Output buffer too small to fit a single entry.
            //
            *lpBufferSize = BytesNeeded;
        }
        else if (status == NO_ERROR) {
            *lpcCount = EntriesRead;
        }

EndOfTry: ;

    }
    RpcExcept(1) {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR && status != WN_NO_MORE_ENTRIES) {
        SetLastError(status);
    }

    //
    // Convert offsets of strings to pointers
    //
    if (EntriesRead > 0) {

        DWORD i;
        LPNETRESOURCEW NetR;


        NetR = lpBuffer;

        for (i = 0; i < EntriesRead; i++, NetR++) {

            if (NetR->lpLocalName != NULL) {
                NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                              (DWORD_PTR) NetR->lpLocalName);
            }

            NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                           (DWORD_PTR) NetR->lpRemoteName);

            if (NetR->lpComment != NULL) {
                NetR->lpComment = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                            (DWORD_PTR) NetR->lpComment);
            }

            if (NetR->lpProvider != NULL) {
                NetR->lpProvider = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                             (DWORD_PTR) NetR->lpProvider);
            }
        }
    }

    return status;
}


DWORD
APIENTRY
NPCloseEnum(
    HANDLE hEnum
    )
/*++

Routine Description:

    This function closes the enumeration context handle.

Arguments:

    hEnum - Supplies the enumeration context handle.

        NOTE: If this value is 0xFFFFFFFF, it is not a context
              handle.  Just return success.

Return Value:

    NO_ERROR - Successfully returned at least one entry.

    WN_BAD_HANDLE - The enumeration handle is invalid.

--*/
{
    DWORD status = NO_ERROR;

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWPROVAU: NPCloseEnum\n"));
    }
#endif

    RpcTryExcept
    {
        if (hEnum == (HANDLE) 0xFFFFFFFF) {
            status = NO_ERROR;
        }
        else {
            status = NwrCloseEnum(
                        (LPNWWKSTA_CONTEXT_HANDLE) &hEnum
                        );
        }
    }
    RpcExcept(1) {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
    }
    return status;
}


DWORD
APIENTRY
NPFormatNetworkName(
    LPWSTR lpRemoteName,
    LPWSTR lpFormattedName,
    LPDWORD lpnLength,
    DWORD dwFlags,
    DWORD dwAveCharPerLine
    )
/*++

Routine Description:

    This function takes a fully-qualified UNC name and formats it
    into a shorter form for display.  Only the name of the object
    within the container is returned for display.

    We only support formatting of the remote resource name to the
    abbreviated form for display during enumeration where the container
    name is displayed prior to the object within it.

Arguments:

    lpRemoteName - Supplies the fully-qualified UNC name.

    lpFormatedName - Output buffer to receive the formatted name.

    lpnLength - On input, supplies the length of the lpFormattedName
        buffer in characters.  On output, if WN_MORE_DATA is returned,
        receives the length in number of characters required of the
        output buffer to hold the formatted name.

    dwFlags - Supplies a bitwise set of flags indicating the type
        of formatting required on lpRemoteName.

    dwAveCharPerLine - Ignored.

Return Value:

    NO_ERROR - Successfully returned at least one entry.

    WN_MORE_DATA - lpFormattedName buffer is too small.

    WN_BAD_VALUE - lpRemoteName is NULL.

    ERROR_NOT_SUPPORTED - dwFlags that does not contain the
        WNFMT_INENUM bit.

--*/
{
    DWORD status = NO_ERROR;

    LPWSTR NextBackSlash;
    LPWSTR Source;
    DWORD SourceLen;

#if DBG
    IF_DEBUG(OTHER) 
        KdPrint(("\nNWPROVAU: NPFormatNetworkName\n"));
#endif

    if (lpRemoteName == NULL) 
    {
        status = WN_BAD_VALUE;
        goto CleanExit;
    }

    if (dwFlags & WNFMT_INENUM) 
    {
        WORD   i;
        WORD   length     = (WORD) wcslen( lpRemoteName );
        WORD   slashCount = 0;
        WORD   dotCount   = 0;
        WORD   Start      = 0;
        WORD   End        = length;
        BOOL   isNdsUnc   = FALSE;
        BOOL   couldBeNdsUnc = FALSE;

        if ( lpRemoteName[0] == L' ' )
            couldBeNdsUnc = TRUE;

        for ( i = 0; i < length; i++ )
        {
            if ( lpRemoteName[i] == L'\\' )
            {
                slashCount++;
                if ( i + 1 < length )
                {
                    Start = i + 1;
                }
            }

            if ( couldBeNdsUnc &&
                 ( ( lpRemoteName[i] == L'.' ) ||
                   ( lpRemoteName[i] == L'=' ) ) )
                isNdsUnc = TRUE;

            if ( dotCount < 1 && isNdsUnc && lpRemoteName[i] == L'.' )
            {
                End = i - 1;
                dotCount++;
            }
        }

        if ( i > length )
            End = length - 1;

        if ( slashCount > 3 || ( isNdsUnc != TRUE && slashCount != 3 && dotCount == 0 ) )
            End = i - 1;

        Source = &lpRemoteName[Start];
        SourceLen = End - Start + 1;

        if ( SourceLen + 1 > *lpnLength ) 
        {
            *lpnLength = SourceLen + 1;
            status = WN_MORE_DATA;
        }
        else 
        {
            wcsncpy( lpFormattedName, Source, SourceLen );
            lpFormattedName[SourceLen] = 0x00000000;
            status = NO_ERROR;
        }
    }
    else if ( dwFlags & WNFMT_MULTILINE ) 
    {

        DWORD i, j, k = 0; 
        DWORD nLastBackSlash = 0;
        DWORD BytesNeeded = ( wcslen( lpRemoteName ) + 1 +
                              2 * wcslen( lpRemoteName ) / dwAveCharPerLine
                            ) * sizeof( WCHAR); 

        if ( *lpnLength < (BytesNeeded/sizeof(WCHAR)) )
        {
            *lpnLength = BytesNeeded/sizeof(WCHAR);
            status = WN_MORE_DATA;
            goto CleanExit;
        }

        for ( i = 0, j = 0; lpRemoteName[i] != 0; i++, j++ )
        {
            if ( lpRemoteName[i] == L'\\' )
                nLastBackSlash = i;

            if ( k == dwAveCharPerLine )
            {
                if ( lpRemoteName[i] != L'\\' )
                {
                    DWORD m, n;
                    for ( n = nLastBackSlash, m = ++j ; n <= i ; n++, m-- )  
                    {
                        lpFormattedName[m] = lpFormattedName[m-1];
                    }
                    lpFormattedName[m] = L'\n';
                    k = i - nLastBackSlash - 1;
                }
                else
                {
                    lpFormattedName[j++] = L'\n';
                    k = 0;
                }
            }

            lpFormattedName[j] = lpRemoteName[i];
            k++;
        }

        lpFormattedName[j] = 0;

    }
    else if ( dwFlags & WNFMT_ABBREVIATED )
    {
        //
        // we dont support abbreviated form for now because we look bad
        // in comdlg (fileopen) if we do.
        //

        DWORD nLength;
        nLength = wcslen( lpRemoteName ) + 1 ;
        if (nLength >  *lpnLength)
        {
            *lpnLength = nLength;
            status = WN_MORE_DATA;
            goto CleanExit;
        }
        else
        {
            wcscpy( lpFormattedName, lpRemoteName ); 
        }

#if 0
        DWORD i, j, k;
        DWORD BytesNeeded = dwAveCharPerLine * sizeof( WCHAR); 
        DWORD nLength;

        if ( *lpnLength < BytesNeeded )
        {
            *lpnLength = BytesNeeded;
            status = WN_MORE_DATA;
            goto CleanExit;
        }

        nLength = wcslen( lpRemoteName );
        if ( ( nLength + 1) <= dwAveCharPerLine )
        {
            wcscpy( lpFormattedName, lpRemoteName ); 
        }
        else
        {
            lpFormattedName[0] = lpRemoteName[0];
            lpFormattedName[1] = lpRemoteName[1];

            for ( i = 2; lpRemoteName[i] != L'\\'; i++ )
                lpFormattedName[i] = lpRemoteName[i];

            for ( j = dwAveCharPerLine-1, k = nLength; j >= (i+3); j--, k-- )
            {
                lpFormattedName[j] = lpRemoteName[k];
                if ( lpRemoteName[k] == L'\\' )
                {
                    j--;
                    break;
                }
            }

            lpFormattedName[j] = lpFormattedName[j-1] = lpFormattedName[j-2] = L'.';
        
            for ( k = i; k < (j-2); k++ )
                lpFormattedName[k] = lpRemoteName[k];
            
        }

#endif 

    }     
    else   // some unknown flags
    {
        status = ERROR_NOT_SUPPORTED;
    }

CleanExit:

    if (status != NO_ERROR) 
        SetLastError(status);

    return status;
}


STATIC
BOOL
NwpWorkstationStarted(
    VOID
    )
/*++

Routine Description:

    This function queries the service controller to see if the
    NetWare workstation service has started.  If in doubt, it returns
    FALSE.

Arguments:

    None.

Return Value:

    Returns TRUE if the NetWare workstation service has started,
    FALSE otherwise.

--*/
{
    SC_HANDLE ScManager;
    SC_HANDLE Service;
    SERVICE_STATUS ServiceStatus;
    BOOL IsStarted = FALSE;

    ScManager = OpenSCManagerW(
                    NULL,
                    NULL,
                    SC_MANAGER_CONNECT
                    );

    if (ScManager == NULL) {
        return FALSE;
    }

    Service = OpenServiceW(
                  ScManager,
                  NW_WORKSTATION_SERVICE,
                  SERVICE_QUERY_STATUS
                  );

    if (Service == NULL) {
        CloseServiceHandle(ScManager);
        return FALSE;
    }

    if (! QueryServiceStatus(Service, &ServiceStatus)) {
        CloseServiceHandle(ScManager);
        CloseServiceHandle(Service);
        return FALSE;
    }


    if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
         (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
         (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
         (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {

        IsStarted = TRUE;
    }

    CloseServiceHandle(ScManager);
    CloseServiceHandle(Service);

    return IsStarted;
}



DWORD
NwpMapNameToUNC(
    IN  LPWSTR pszName,
    OUT LPWSTR *ppszUNC 
    )
/*++

Routine Description:

    This routine validates the given name as a netwarepath or UNC path. 
    If it is a netware path, this routine will convert the 
    Netware path name to UNC name. 

Arguments:

    pszName - Supplies the netware name or UNC name
    ppszUNC - Points to the converted UNC name

Return Value:

    NO_ERROR or the error that occurred.

--*/
{
    DWORD err = NO_ERROR;

    LPWSTR pszSrc = pszName;
    LPWSTR pszDest;

    BOOL fSlash = FALSE;
    BOOL fColon = FALSE;
    DWORD nServerLen = 0;
    DWORD nVolLen = 0;
    BOOL fFirstToken = TRUE;

    *ppszUNC = NULL;
                               
    //
    // The name cannot be NULL or empty string
    //
    if ( pszName == NULL || *pszName == 0) 
        return WN_BAD_NETNAME;

#if DBG
    IF_DEBUG(CONNECT) 
        KdPrint(("NwpMapNameToUNC: Source = %ws\n", pszName ));
#endif

    //
    // Get rid of the <space> if a NDS tree name ...
    //
    if ( pszName[0] == L' ' &&
         pszName[1] == L'\\' &&
         pszName[2] == L'\\' )
        pszName = &pszName[1];

    //
    // Check if the given name is a valid UNC name
    //
    err = NwLibCanonRemoteName( NULL,     // "\\Server" is valid UNC path
                                pszName,
                                ppszUNC,
                                NULL );

    //
    // The given name is a valid UNC name, so return success!
    //
    if ( err == NO_ERROR )
        return err;

    //
    // Allocate the buffer to store the mapped UNC name
    // We allocate 3 extra characters, two for the backslashes in front
    // and one for the ease of parsing below.
    //
    if ((*ppszUNC = (LPVOID) LocalAlloc( 
                                 LMEM_ZEROINIT,
                                 (wcslen( pszName) + 4) * sizeof( WCHAR)
                                 )) == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy( *ppszUNC, L"\\\\" );
    pszDest = *ppszUNC + 2;   // Skip past two backslashes

    //
    // Parse the given string and put the converted string into *ppszUNC
    // In the converted string, we will substitute 0 for all slashes
    // for the time being.
    //
    for ( ; *pszSrc != 0; pszSrc++ )
    { 
        if (  ( *pszSrc == L'/' )
           || ( *pszSrc == L'\\' )
           )
        {
            //
            // Two consecutive backslashes are bad
            //
            if ( (*(pszSrc+1) ==  L'/') ||  (*(pszSrc+1) == L'\\'))
            {
                LocalFree( *ppszUNC );
                *ppszUNC = NULL;
                return WN_BAD_NETNAME;
            }

            if ( !fSlash )
                fSlash = TRUE;

            *pszDest++ = 0;
        }
        else if ( (*pszSrc == L':') && fSlash && !fColon )
        {
            fColon = TRUE;
            if ( *(pszSrc+1) != 0 )
                *pszDest++ = 0;
 
        }
        else
        {
            *pszDest++ = *pszSrc;
            if (( fSlash ) && ( !fColon))
                nVolLen++; 
            else if ( !fSlash )
                nServerLen++; 
        }
    }

    //
    // Note: *ppszUNC is already terminated with two '\0' because we initialized
    //       the whole buffer to zero.
    // 

    if (  ( nServerLen == 0 )
       || ( fSlash && nVolLen == 0 )
       || ( fSlash && nVolLen != 0 && !fColon )
       )
    {
        LocalFree( *ppszUNC );
        *ppszUNC = NULL;
        return WN_BAD_NETNAME;
    }

    //
    // At this point, we know the name is a valid Netware syntax
    //     i.e. SERVER[/VOL:/dir]
    // We now need to validate that all the characters used in the
    // servername, volume, directory are valid characters
    //

    pszDest = *ppszUNC + 2;   // Skip past the first two backslashes
    while ( *pszDest != 0 )
    {
         DWORD nLen = wcslen( pszDest );
         
         if (  ( fFirstToken &&  !IS_VALID_SERVER_TOKEN( pszDest, nLen )) 
            || ( !fFirstToken && !IS_VALID_TOKEN( pszDest, nLen )) 
            )
         { 
             LocalFree( *ppszUNC );
             *ppszUNC = NULL;
             return WN_BAD_NETNAME;
         }
     
         fFirstToken = FALSE;
         pszDest += nLen + 1;
    }

    //
    // The netware name is valid! Convert 0 back to backslash in 
    // converted string.
    //

    pszDest = *ppszUNC + 2;   // Skip past the first two backslashes
    while ( *pszDest != 0 )
    {
        if ( (*(pszDest+1) == 0 ) && (*(pszDest+2) != 0 ) )
        {
            *(pszDest+1) = L'\\';
        }
        pszDest++;
    }
                  
#if DBG
    IF_DEBUG(CONNECT) 
        KdPrint(("NwpMapNameToUNC: Destination = %ws\n", *ppszUNC ));
#endif
    return NO_ERROR;
}


STATIC
VOID
NwpGetUncInfo(
    IN LPWSTR lpstrUnc,
    OUT WORD * slashCount,
    OUT BOOL * isNdsUnc
    )
{
    WORD   i;
    WORD   length = (WORD) wcslen( lpstrUnc );

    *isNdsUnc = FALSE;
    *slashCount = 0;

    for ( i = 0; i < length; i++ )
    {
        if ( ( lpstrUnc[i] == L'.' ) && ( *slashCount == 3 ) )
        {
            *isNdsUnc = TRUE;
        }

        if ( lpstrUnc[i] == L'\\' )
        {
            *slashCount += 1;
        }
    }
}


STATIC
LPWSTR
NwpGetUncObjectName(
    IN LPWSTR ContainerName
)
{
    WORD length = 2;
    WORD totalLength = (WORD) wcslen( ContainerName );

    if ( totalLength < 2 )
        return 0;

    while ( length < totalLength )
    {
        if ( ContainerName[length] == L'.' )
            ContainerName[length] = L'\0';

        length++;
    }

    length = 2;

    while ( length < totalLength && ContainerName[length] != L'\\' )
    {
        length++;
    }

    if ( ( ContainerName[length + 1] == L'C' ||
           ContainerName[length + 1] == L'c' ) &&
         ( ContainerName[length + 2] == L'N' ||
           ContainerName[length + 2] == L'n' ) &&
         ContainerName[length + 3] == L'=' )
    {
        ContainerName[length + 2] = L'\\';
        ContainerName[length + 3] = L'\\';

        return (ContainerName + length + 2);
    }

    ContainerName[length - 1] = L'\\';

    return (ContainerName + length - 1);
}
    

STATIC
WORD
NwpGetSlashCount(
    IN LPWSTR lpstrUnc
    )
{
    WORD   count = 0;
    WORD   i;
    WORD   length = (WORD) wcslen( lpstrUnc );

    for ( i = 0; i < length; i++ )
    {
        if ( lpstrUnc[i] == L'\\' )
        {
            count++;
        }
    }

    return count;
}


DWORD
NwpMapRpcError(
    IN DWORD RpcError
    )
/*++

Routine Description:

    This routine maps the RPC error into a more meaningful windows
    error for the caller.

Arguments:

    RpcError - Supplies the exception error raised by RPC

Return Value:

    Returns the mapped error.

--*/
{

    switch (RpcError) {

        case RPC_S_UNKNOWN_IF:
        case RPC_S_SERVER_UNAVAILABLE:
            return WN_NO_NETWORK;

        case RPC_S_INVALID_BINDING:
        case RPC_X_SS_IN_NULL_CONTEXT:
        case RPC_X_SS_CONTEXT_DAMAGED:
        case RPC_X_SS_HANDLES_MISMATCH:
        case ERROR_INVALID_HANDLE:
            return ERROR_INVALID_HANDLE;

        case RPC_X_NULL_REF_POINTER:
            return ERROR_INVALID_PARAMETER;

        case EXCEPTION_ACCESS_VIOLATION:
            return ERROR_INVALID_ADDRESS;

        default:
            return RpcError;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\inc\nwauth.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:  

    nwauth.h

Abstract:

    Header for data structures provided by the NetWare
    authentication package.

Author:

    Rita Wong      (ritaw)      4-Feb-1994

Revision History:

--*/

#ifndef _NWAUTH_INCLUDED_
#define _NWAUTH_INCLUDED_

#include <nwcons.h>

//
// Name of the authentication package.
//
#define NW_AUTH_PACKAGE_NAME  "NETWARE_AUTHENTICATION_PACKAGE_V1_0"

//
//  LsaCallAuthenticationPackage() submission and response
//  message types.
//

typedef enum _NWAUTH_MESSAGE_TYPE {
    NwAuth_GetCredential = 0,
    NwAuth_SetCredential
} NWAUTH_MESSAGE_TYPE, *PNWAUTH_MESSAGE_TYPE;

//
// NwAuth_GetCredential submit buffer and response
//
typedef struct _NWAUTH_GET_CREDENTIAL_REQUEST {
    NWAUTH_MESSAGE_TYPE MessageType;
    LUID LogonId;
} NWAUTH_GET_CREDENTIAL_REQUEST, *PNWAUTH_GET_CREDENTIAL_REQUEST;

typedef struct _NWAUTH_GET_CREDENTIAL_RESPONSE {
    WCHAR UserName[NW_MAX_USERNAME_LEN + 1];
    WCHAR Password[NW_MAX_PASSWORD_LEN + 1];
} NWAUTH_GET_CREDENTIAL_RESPONSE, *PNWAUTH_GET_CREDENTIAL_RESPONSE;


//
// NwAuth_SetCredential submit buffer
//
typedef struct _NWAUTH_SET_CREDENTIAL_REQUEST {
    NWAUTH_MESSAGE_TYPE MessageType;
    LUID LogonId;
    WCHAR UserName[NW_MAX_USERNAME_LEN + 1];
    WCHAR Password[NW_MAX_PASSWORD_LEN + 1];
} NWAUTH_SET_CREDENTIAL_REQUEST, *PNWAUTH_SET_CREDENTIAL_REQUEST;

#define NW_ENCODE_SEED   0x5C
#define NW_ENCODE_SEED2  0xA9
#define NW_ENCODE_SEED3  0x83

#endif // _NWAUTH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\inc\nwreg.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nwreg.h

Abstract:

    Header which specifies the misc registry parameters and helper
    routines used by the workstation service.

Author:

    Rita Wong      (ritaw)      22-Mar-1993

Revision History:

    ChuckC        11-Dec-93     Split off the registry names to nwrnames.h

--*/

#ifndef _NWREG_INCLUDED_
#define _NWREG_INCLUDED_

#include <nwrnames.h>

//
// Default print option
//
#define NW_PRINT_OPTION_DEFAULT 0x98

#define NW_DOMAIN_USER_SEPARATOR     L'*'
#define NW_DOMAIN_USER_SEPARATOR_STR L"*"

#define NW_MAX_LOGON_ID_LEN 17

#ifdef __cplusplus
extern "C" {
#endif

DWORD
NwReadRegValue(
    IN HKEY Key,
    IN LPWSTR ValueName,
    OUT LPWSTR *Value
    );

VOID
NwLuidToWStr(
    IN PLUID LogonId,
    OUT LPWSTR LogonIdStr
    );

VOID
NwWStrToLuid(
    IN LPWSTR LogonIdStr,
    OUT PLUID LogonId
    );


DWORD                              // Terminal Server
NwDeleteInteractiveLogon(
    IN PLUID Id OPTIONAL
    );

VOID
NwDeleteCurrentUser(
    VOID
    );

DWORD
NwDeleteServiceLogon(
    IN PLUID Id OPTIONAL
    );

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _NWREG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\inc\nwmisc.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nwmisc.h

Abstract:

    Header which specifies the misc routines used by the workstation service.

Author:

    Chuck Y Chan   (chuckc)     2-Mar-1994

Revision History:

    Glenn A Curtis (glennc)     18-Jul-1995

--*/

#ifndef _NWMISC_INCLUDED_
#define _NWMISC_INCLUDED_

#include <winsock2.h>
#include <basetyps.h>
#include <nspapi.h>
#include "sapcmn.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// RPC pipe name
//
#define NWWKS_INTERFACE_NAME   TEXT("nwwks")


DWORD
NwGetGraceLoginCount(
    LPWSTR  Server,
    LPWSTR  UserName,
    LPDWORD lpResult
    );

//
// Commonly reference value for NCP Server name length
//
#define NW_MAX_SERVER_LEN      48


//
// Flags used for the function NwParseNdsUncPath()
//
#define  PARSE_NDS_GET_TREE_NAME    0
#define  PARSE_NDS_GET_PATH_NAME    1
#define  PARSE_NDS_GET_OBJECT_NAME  2


WORD
NwParseNdsUncPath(
    IN OUT LPWSTR * Result,
    IN LPWSTR ContainerName,
    IN ULONG flag
    );

//
// NDS Object class type identifiers
//
#define CLASS_TYPE_ALIAS                1
#define CLASS_TYPE_AFP_SERVER           2
#define CLASS_TYPE_BINDERY_OBJECT       3
#define CLASS_TYPE_BINDERY_QUEUE        4
#define CLASS_TYPE_COMPUTER             5
#define CLASS_TYPE_COUNTRY              6
#define CLASS_TYPE_DIRECTORY_MAP        7
#define CLASS_TYPE_GROUP                8
#define CLASS_TYPE_LOCALITY             9
#define CLASS_TYPE_NCP_SERVER          10
#define CLASS_TYPE_ORGANIZATION        11
#define CLASS_TYPE_ORGANIZATIONAL_ROLE 12
#define CLASS_TYPE_ORGANIZATIONAL_UNIT 13
#define CLASS_TYPE_PRINTER             14
#define CLASS_TYPE_PRINT_SERVER        15
#define CLASS_TYPE_PROFILE             16
#define CLASS_TYPE_QUEUE               17
#define CLASS_TYPE_TOP                 18
#define CLASS_TYPE_UNKNOWN             19
#define CLASS_TYPE_USER                20
#define CLASS_TYPE_VOLUME              21

#define CLASS_NAME_ALIAS               L"Alias"
#define CLASS_NAME_AFP_SERVER          L"AFP Server"
#define CLASS_NAME_BINDERY_OBJECT      L"Bindery Object"
#define CLASS_NAME_BINDERY_QUEUE       L"Bindery Queue"
#define CLASS_NAME_COMPUTER            L"Computer"
#define CLASS_NAME_COUNTRY             L"Country"
#define CLASS_NAME_DIRECTORY_MAP       L"Directory Map"
#define CLASS_NAME_GROUP               L"Group"
#define CLASS_NAME_LOCALITY            L"Locality"
#define CLASS_NAME_NCP_SERVER          L"NCP Server"
#define CLASS_NAME_ORGANIZATION        L"Organization"
#define CLASS_NAME_ORGANIZATIONAL_ROLE L"Organizational Role"
#define CLASS_NAME_ORGANIZATIONAL_UNIT L"Organizational Unit"
#define CLASS_NAME_PRINTER             L"Printer"
#define CLASS_NAME_PRINT_SERVER        L"Print Server"
#define CLASS_NAME_PROFILE             L"Profile"
#define CLASS_NAME_QUEUE               L"Queue"
#define CLASS_NAME_TOP                 L"Top"
#define CLASS_NAME_UNKNOWN             L"Unknown"
#define CLASS_NAME_USER                L"User"
#define CLASS_NAME_VOLUME              L"Volume"


//
// Node structure in the registered service link list and
// functions to add/remove items from the link list
//

typedef struct _REGISTERED_SERVICE {
    WORD nSapType;                      // SAP Type
    BOOL fAdvertiseBySap;               // TRUE if advertise by SAP agent
    LPSERVICE_INFO pServiceInfo;        // Info about this service
    struct _REGISTERED_SERVICE *Next;   // Points to the next service node
} REGISTERED_SERVICE, *PREGISTERED_SERVICE;


PREGISTERED_SERVICE
GetServiceItemFromList(
    IN WORD   nSapType,
    IN LPWSTR pServiceName
);

DWORD
NwRegisterService(
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD nSapType,
    IN HANDLE hEventHandle
);

DWORD
NwDeregisterService(
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD nSapType
);

DWORD
NwGetService(
    IN  LPWSTR  Reserved,
    IN  WORD    nSapType,
    IN  LPWSTR  lpServiceName,
    IN  DWORD   dwProperties,
    OUT LPBYTE  lpServiceInfo,
    IN  DWORD   dwBufferLength,
    OUT LPDWORD lpdwBytesNeeded
);

VOID
NwInitializeServiceProvider(
    VOID
    );

VOID
NwTerminateServiceProvider(
    VOID
    );

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _NWMISC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\inc\rnrdefs.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nwmisc.h

Abstract:

    Header which specifies the misc routines used by the workstation service.

Author:

    Arnold Miller (arnoldm)     15-Feb-1996

Revision History:


--*/
#ifndef __RNRDEFS_H__
#define __RNRDEFS_H__

#include "sapcmn.h"

//
// Bit defs for the protocols
//

#define IPX_BIT            1
#define SPX_BIT            2
#define SPXII_BIT          4

//
// forwards\
//

struct _SAP_RNR_CONTEXT;
//
// Bindery control
//

typedef struct _BinderyControl
{
    LONG lIndex;
} BINDERYCONTROL, *PBINDERYCONTROL;

//
// SAP RnR context information. This is linked off of the
// SAP_BCAST_CONTROL defined ahead
//

typedef struct _SAP_DATA
{
    struct _SAP_DATA *  sapNext;
                                     // save everything except hop count
    WORD         sapid;              // for a sanity check
    CHAR         sapname[48];        // what we don't know
    BYTE         socketAddr[IPX_ADDRESS_LENGTH];         // and what we seek
} SAP_DATA, *PSAP_DATA;
    
//
//
// Sap bcast control
// An important note. fFlags is set only by the thread executing
// a LookupServiceBegin or a LookupServiceNext. It may be tested by
// any thread. Its counterpart, dwControlFlags in SAP_RNR_CONTEXT
// is reserved for setting by LookupServiceBegin and LookupServiceEnd. Once
// again any thread may look at it. This insures no loss of data on an
// MP machine without needing a critical section.
//

typedef struct _SAP_BCAST_CONTROL
{
    DWORD dwIndex;                 // loop control
    DWORD dwTickCount;             // tick count of last send
    DWORD fFlags;                  // various flags
    PVOID pvArg;
    SOCKET s;
    CRITICAL_SECTION csMonitor;    // This is to keep
                                   // out internal structures sane. Note
                                   // it does not provide rational
                                   // serialization. In particular,  if
                                   // multiple threads use the same
                                   // handle simultaneously, there is no
                                   // guaranteed serialization.
    PSAP_DATA psdNext1;            // next to return
    PSAP_DATA psdHead;             // list head
    PSAP_DATA psdTail;
    struct _SAP_RNR_CONTEXT * psrc;  // need this   
    DWORD (*Func)(PVOID pvArg1, PSAP_IDENT_HEADER pSap, PDWORD pdwErr);
    BOOL  (*fCheckCancel)(PVOID pvArg1);
    WORD    wQueryType;
} SAP_BCAST_CONTROL, *PSAP_BCAST_CONTROL;

//
// Flags for above

#define SBC_FLAG_NOMORE  0x1

//
// Structure used by the old RnR Sap lookup as the pvArg value in
// SAP_BCAST control
//

#ifndef _NTDEF_
typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength), length_is(Length) ]
#endif // MIDL_PASS
    PCHAR Buffer;
} OEM_STRING;
#endif

typedef struct _OldRnRSap
{
    OEM_STRING * poem;
    HANDLE hCancel;
    LPVOID lpCsAddrBuffer;
    LPDWORD lpdwBufferLength;
    DWORD   nProt;
    LPDWORD lpcAddress;
} OLDRNRSAP, *POLDRNRSAP;

//
// Return codes from the coroutine
//

#define dwrcDone      1       // all done, return success
#define dwrcCancel    2       // all done, return cancelled
#define dwrcNoWait    3       // keep going, but never wait.
#define dwrcNil       4       // do whatever you want

//
// Sap service query packet format
//

typedef struct _SAP_REQUEST {
    USHORT QueryType;
    USHORT ServerType;
} SAP_REQUEST, *PSAP_REQUEST; 

#define QT_GENERAL_QUERY 1
#define QT_NEAREST_QUERY 3

// The context information we put inside of an RNRNSHANDLE structure
// to keep track of what we are doing
// N.B. See comment on SAP_BCAST_CONTROL about the use of dwControlFlags.
//

typedef struct _SAP_RNR_CONTEXT
{
    struct _SAP_RNR_CONTEXT * pNextContext;
    LONG      lSig;
    LONG      lInUse;
    DWORD     dwCount;                // count of queries made
    DWORD     fFlags;                 // always nice to have
    DWORD     dwControlFlags;
    DWORD     fConnectionOriented;
    WORD      wSapId;                // the type desired
    HANDLE    Handle;                 // the corresponding RnR handle
    DWORD     nProt;
    GUID      gdType;                // the type we are seeking
    GUID      gdProvider;
    HANDLE    hServer;
    WCHAR     wszContext[48];
    WCHAR     chwName[48];            // the name, if any 
    CHAR      chName[48];             // OEM form of the name for SAP
    DWORD     dwUnionType;            // type of lookup, once we know
    union
    {
        SAP_BCAST_CONTROL sbc;
        BINDERYCONTROL    bc;
    } u_type;
    PVOID     pvVersion;              // a trick to get the version here.
} SAP_RNR_CONTEXT, *PSAP_RNR_CONTEXT;

#define RNR_SIG 0xaabbccdd
//
// union types
//

#define LOOKUP_TYPE_NIL     0
#define LOOKUP_TYPE_SAP     1
#define LOOKUP_TYPE_BINDERY 2

      
#define SAP_F_END_CALLED  0x1             // generic  cancel


//
// Defs for the bindery Class info
// This defines the format of each ClassInfo property segement. It looks
// somewhat like an actual ClassInfo, but considerably compressed. Note
// due to marshalling problems, any complex value, such as a GUID,
// should be stored as a string and then imported. Hence, we define
// types for what we can anticipate.
// 

typedef struct _BinderyClasses
{
    BYTE     bType;
    BYTE     bSizeOfType;
    BYTE     bSizeOfString;
    BYTE     bOffset;              // where the data area begins
    BYTE     bFlags;
    BYTE     bFiller;
    WORD     wNameSpace;           // the applicable namespace
    CHAR     cDataArea[120];       // where the type and string are placed
} BINDERYCLASSES, *PBINDERYCLASSES;

#define BT_DWORD  1           // DWORD
#define BT_WORD   2           // WORD
#define BT_GUID   3           // a string GUID (ASCII)
#define BT_STR    3           // an OEM string
#define BT_OID    4           // an object ID (TBD)
#define BT_BSTR   5           // a binary string (very dangerous)
#define BT_WSTR   6           // UNICODE string. Unmarshalled!


#define RNRTYPE "RNR_TYPE"    // prop containing the GUID
#define RNRCLASSES "RNR_CLASSES" // the other property
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\inc\sapcmn.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    sapcmn.h.h

Abstract:

    Header containing the most basic common SAP definitions. This
    was derived from the larger file, nwmisc.h in order to
    be available to either the old RNR or the new RNR routines.

Author:

    Arnold Miller (ArnoldM)     8-Dec-95

Revision History:

    ArnoldM 8-Dec-95 Created from pieces of nwmisc.h
--*/

#ifndef __SAPCMN_H__
#define __SAPCMN_H__
//
// Definitions common to client and server side files (getaddr.c and service.c)
//

#define IPX_ADDRESS_LENGTH         12
#define IPX_ADDRESS_NETNUM_LENGTH  4
#define SAP_ADDRESS_LENGTH         15
#define SAP_ADVERTISE_FREQUENCY    60000  // 60 seconds
#define SAP_MAXRECV_LENGTH         544
#define SAP_OBJECT_NAME_MAX_LENGTH 48

//
// N.B. Keep the following defines in synch.
//
#define NW_RDR_PREFERRED_SERVER   L"\\Device\\Nwrdr\\*"
#define NW_RDR_NAME               L"\\Device\\Nwrdr\\"
#define NW_RDR_PREFERRED_SUFFIX    L"*"
//
// Sap server identification packet format
//

typedef struct _SAP_IDENT_HEADER {
    USHORT ServerType;
    UCHAR  ServerName[48];
    UCHAR  Address[IPX_ADDRESS_LENGTH];
    USHORT HopCount;
} SAP_IDENT_HEADER, *PSAP_IDENT_HEADER;


//
// Sap server identification packet format - Extended
//

typedef struct _SAP_IDENT_HEADER_EX {
    USHORT ResponseType;
    USHORT ServerType;
    UCHAR  ServerName[SAP_OBJECT_NAME_MAX_LENGTH];
    UCHAR  Address[IPX_ADDRESS_LENGTH];
    USHORT HopCount;
} SAP_IDENT_HEADER_EX, *PSAP_IDENT_HEADER_EX;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\inc\splutil.h ===
/*++

Copyright (c) 1992-1993 Microsoft Corporation

Module Name:

    splutil.h

Abstract:

    Header file for utilities used in Novell Print Provider

Author:

    Yi-Hsin Sung (yihsins) 12-Apr-1993

Revision History:

--*/

#ifndef _SPLUTIL_H_
#define _SPLUTIL_H_

#define offsetof(type, identifier) (DWORD_PTR)(&(((type)0)->identifier))

#ifdef __cplusplus
extern "C" {
#endif

extern DWORD_PTR PrinterInfo1Offsets[];
extern DWORD_PTR PrinterInfo2Offsets[];
extern DWORD_PTR PrinterInfo3Offsets[];
extern DWORD_PTR JobInfo1Offsets[];
extern DWORD_PTR JobInfo2Offsets[];
extern DWORD_PTR AddJobInfo1Offsets[];

VOID
MarshallUpStructure(
   LPBYTE      lpStructure,
   PDWORD_PTR  lpOffsets,
   LPBYTE      lpBufferStart
);

VOID
MarshallDownStructure(
   LPBYTE      lpStructure,
   PDWORD_PTR  lpOffsets,
   LPBYTE      lpBufferStart
);

LPVOID
AllocNwSplMem(
    IN DWORD flags,
    IN DWORD cb
    );

VOID
FreeNwSplMem(
    IN LPVOID pMem,
    IN DWORD  cb
    );

LPWSTR
AllocNwSplStr(
    IN LPWSTR pStr
    );

VOID
FreeNwSplStr(
    IN LPWSTR pStr
);

BOOL
ValidateUNCName(
    IN LPWSTR pName
);

LPWSTR
GetNextElement(
               OUT LPWSTR *pPtr,
               IN  WCHAR token
);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _SPLUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\address.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    address.c

Abstract:

    This module contains the code to support NPGetAddressByName.

Author:

    Yi-Hsin Sung (yihsins)    18-Apr-94

Revision History:

    yihsins      Created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <nwxchg.h>
#include <ntddnwfs.h>
#include <rpc.h>
#include <rpcdce.h>
#include "handle.h"
#include "rnrdefs.h"
#include "sapcmn.h"
#include <time.h>

VOID
DummyRoutine()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\lib\misc.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    api.c

Abstract:

    This module contains misc APIs that are used by the
    NWC wksta.

Author:

    ChuckC         2-Mar-94        Created


Revision History:

--*/


#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <nwcons.h>
#include <nwmisc.h>
#include <nwapi32.h>
#include "nwstatus.h"
#include "nwevent.h"

DWORD
NwMapStatus(
    IN  NTSTATUS NtStatus
    );

DWORD
NwOpenPreferredServer(
    PHANDLE ServerHandle
    );

NTSTATUS
NwOpenHandle(
    IN PUNICODE_STRING ObjectName,
    IN BOOL ValidateFlag,
    OUT PHANDLE ObjectHandle
    );

NTSTATUS
NwCallNtOpenFile(
    OUT PHANDLE ObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING ObjectName,
    IN ULONG OpenOptions
   );


//
// list of error mappings known for E3H calls. we do not have a single list
// because Netware reuses the numbers depending on call.
//

typedef struct _ERROR_MAP_ENTRY
{
    UCHAR NetError;
    NTSTATUS ResultingStatus;
}  ERROR_MAP_ENTRY ;

ERROR_MAP_ENTRY Error_Map_Bindery[] =
{

    //
    //  NetWare specific error mappings. Specific to E3H.
    //
    {  1, STATUS_DISK_FULL },
    {128, STATUS_SHARING_VIOLATION },
    {129, STATUS_INSUFF_SERVER_RESOURCES },
    {130, STATUS_ACCESS_DENIED },
    {131, STATUS_DATA_ERROR },
    {132, STATUS_ACCESS_DENIED },
    {133, STATUS_ACCESS_DENIED },
    {134, STATUS_ACCESS_DENIED },
    {135, STATUS_OBJECT_NAME_INVALID },
    {136, STATUS_INVALID_HANDLE },
    {137, STATUS_ACCESS_DENIED },
    {138, STATUS_ACCESS_DENIED },
    {139, STATUS_ACCESS_DENIED },
    {140, STATUS_ACCESS_DENIED },
    {141, STATUS_SHARING_VIOLATION },
    {142, STATUS_SHARING_VIOLATION },
    {143, STATUS_ACCESS_DENIED },
    {144, STATUS_ACCESS_DENIED },
    {145, STATUS_OBJECT_NAME_COLLISION },
    {146, STATUS_OBJECT_NAME_COLLISION },
    {147, STATUS_ACCESS_DENIED },
    {148, STATUS_ACCESS_DENIED },
    {150, STATUS_INSUFF_SERVER_RESOURCES },
    {151, STATUS_NO_SPOOL_SPACE },
    {152, STATUS_NO_SUCH_DEVICE },
    {153, STATUS_DISK_FULL },
    {154, STATUS_NOT_SAME_DEVICE },
    {155, STATUS_INVALID_HANDLE },
    {156, STATUS_OBJECT_PATH_NOT_FOUND },
    {157, STATUS_INSUFF_SERVER_RESOURCES },
    {158, STATUS_OBJECT_PATH_INVALID },
    {159, STATUS_SHARING_VIOLATION },
    {160, STATUS_DIRECTORY_NOT_EMPTY },
    {161, STATUS_DATA_ERROR },
    {162, STATUS_SHARING_VIOLATION },
    {192, STATUS_ACCESS_DENIED },
    {198, STATUS_ACCESS_DENIED },
    {211, STATUS_ACCESS_DENIED },
    {212, STATUS_PRINT_QUEUE_FULL },
    {213, STATUS_PRINT_CANCELLED },
    {214, STATUS_ACCESS_DENIED },
    {215, STATUS_PASSWORD_RESTRICTION },
    {216, STATUS_PASSWORD_RESTRICTION },
    {220, STATUS_ACCOUNT_DISABLED },
    {222, STATUS_PASSWORD_EXPIRED },
    {223, STATUS_PASSWORD_EXPIRED },
    {239, STATUS_OBJECT_NAME_INVALID },
    {240, STATUS_OBJECT_NAME_INVALID },
    {251, STATUS_INVALID_PARAMETER },
    {252, STATUS_NO_MORE_ENTRIES },
    {253, STATUS_FILE_LOCK_CONFLICT },
    {254, STATUS_FILE_LOCK_CONFLICT },
    {255, STATUS_UNSUCCESSFUL}
};


ERROR_MAP_ENTRY Error_Map_General[] =
{
    {  1, STATUS_DISK_FULL },
    {128, STATUS_SHARING_VIOLATION },
    {129, STATUS_INSUFF_SERVER_RESOURCES },
    {130, STATUS_ACCESS_DENIED },
    {131, STATUS_DATA_ERROR },
    {132, STATUS_ACCESS_DENIED },
    {133, STATUS_ACCESS_DENIED },
    {134, STATUS_ACCESS_DENIED },
    {135, STATUS_OBJECT_NAME_INVALID },
    {136, STATUS_INVALID_HANDLE },
    {137, STATUS_ACCESS_DENIED },
    {138, STATUS_ACCESS_DENIED },
    {139, STATUS_ACCESS_DENIED },
    {140, STATUS_ACCESS_DENIED },
    {141, STATUS_SHARING_VIOLATION },
    {142, STATUS_SHARING_VIOLATION },
    {143, STATUS_ACCESS_DENIED },
    {144, STATUS_ACCESS_DENIED },
    {145, STATUS_OBJECT_NAME_COLLISION },
    {146, STATUS_OBJECT_NAME_COLLISION },
    {147, STATUS_ACCESS_DENIED },
    {148, STATUS_ACCESS_DENIED },
    {150, STATUS_INSUFF_SERVER_RESOURCES },
    {151, STATUS_NO_SPOOL_SPACE },
    {152, STATUS_NO_SUCH_DEVICE },
    {153, STATUS_DISK_FULL },
    {154, STATUS_NOT_SAME_DEVICE },
    {155, STATUS_INVALID_HANDLE },
    {156, STATUS_OBJECT_PATH_NOT_FOUND },
    {157, STATUS_INSUFF_SERVER_RESOURCES },
    {158, STATUS_OBJECT_PATH_INVALID },
    {159, STATUS_SHARING_VIOLATION },
    {160, STATUS_DIRECTORY_NOT_EMPTY },
    {161, STATUS_DATA_ERROR },
    {162, STATUS_SHARING_VIOLATION },
    {192, STATUS_ACCESS_DENIED },
    {198, STATUS_ACCESS_DENIED },
    {211, STATUS_ACCESS_DENIED },
    {212, STATUS_PRINT_QUEUE_FULL },
    {213, STATUS_PRINT_CANCELLED },
    {214, STATUS_ACCESS_DENIED },
    {215, STATUS_DEVICE_BUSY },
    {216, STATUS_DEVICE_DOES_NOT_EXIST },
    {220, STATUS_ACCOUNT_DISABLED },
    {222, STATUS_PASSWORD_EXPIRED },
    {223, STATUS_PASSWORD_EXPIRED },
    {239, STATUS_OBJECT_NAME_INVALID },
    {240, STATUS_OBJECT_NAME_INVALID },
    {251, STATUS_INVALID_PARAMETER },
    {252, STATUS_NO_MORE_ENTRIES },
    {253, STATUS_FILE_LOCK_CONFLICT },
    {254, STATUS_FILE_LOCK_CONFLICT },
    {255, STATUS_UNSUCCESSFUL}
};

#define NUM_ERRORS(x)  (sizeof(x)/sizeof(x[0]))

DWORD
NwMapBinderyCompletionCode(
    IN  NTSTATUS NtStatus
    )
/*++

Routine Description:

    This function takes a bindery completion code embedded in an NT status
    code and maps it to the appropriate Win32 error code. Used specifically
    for E3H operations.

Arguments:

    NtStatus - Supplies the NT status (that contains the code in low 16 bits)

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD i; UCHAR code ;

    //
    // A small optimization for the most common case.
    //
    if (NtStatus == STATUS_SUCCESS)
        return NO_ERROR;

    //
    // Map connection errors specially.
    //

    if ( ( (NtStatus & 0xFFFF0000) == 0xC0010000) &&
         ( (NtStatus & 0xFF00) != 0 ) )
    {
        return ERROR_UNEXP_NET_ERR;
    }

    //
    // if facility code not set, assume it is NT Status
    //
    if ( (NtStatus & 0xFFFF0000) != 0xC0010000)
        return RtlNtStatusToDosError(NtStatus);

    code = (UCHAR)(NtStatus & 0x000000FF);
    for (i = 0; i < NUM_ERRORS(Error_Map_Bindery); i++)
    {
        if (Error_Map_Bindery[i].NetError == code)
            return( NwMapStatus(Error_Map_Bindery[i].ResultingStatus));
    }

    //
    // if cannot find let NwMapStatus do its best
    //
    return NwMapStatus(NtStatus);
}



DWORD
NwMapStatus(
    IN  NTSTATUS NtStatus
    )
/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    Win32 error code. If facility code is set, assume it is NW specific

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD i; UCHAR code ;

    //
    // A small optimization for the most common case.
    //
    if (NtStatus == STATUS_SUCCESS)
        return NO_ERROR;

    //
    // Map connection errors specially.
    //

    if ( ( (NtStatus & 0xFFFF0000) == 0xC0010000) &&
         ( (NtStatus & 0xFF00) != 0 ) )
    {
        return ERROR_UNEXP_NET_ERR;
    }

    //
    // if facility code set, assume it is NW Completion code
    //
    if ( (NtStatus & 0xFFFF0000) == 0xC0010000)
    {
        code = (UCHAR)(NtStatus & 0x000000FF);
        for (i = 0; i < NUM_ERRORS(Error_Map_General); i++)
        {
            if (Error_Map_General[i].NetError == code)
            {
                //
                // map it to NTSTATUS and then drop thru to map to Win32
                //
                NtStatus = Error_Map_General[i].ResultingStatus ;
                break ;
            }
        }
    }

    switch (NtStatus) {
        case STATUS_OBJECT_NAME_COLLISION:
            return ERROR_ALREADY_ASSIGNED;

        case STATUS_OBJECT_NAME_NOT_FOUND:
            return ERROR_NOT_CONNECTED;

        case STATUS_IMAGE_ALREADY_LOADED:
        case STATUS_REDIRECTOR_STARTED:
            return ERROR_SERVICE_ALREADY_RUNNING;

        case STATUS_REDIRECTOR_HAS_OPEN_HANDLES:
            return ERROR_REDIRECTOR_HAS_OPEN_HANDLES;

        case STATUS_NO_MORE_FILES:
        case STATUS_NO_MORE_ENTRIES:
            return WN_NO_MORE_ENTRIES;

        case STATUS_MORE_ENTRIES:
            return WN_MORE_DATA;

        case STATUS_CONNECTION_IN_USE:
            return ERROR_DEVICE_IN_USE;

        case NWRDR_PASSWORD_HAS_EXPIRED:
            return NW_PASSWORD_HAS_EXPIRED;

        case STATUS_INVALID_DEVICE_REQUEST:
            return ERROR_CONNECTION_INVALID;

        default:
            return RtlNtStatusToDosError(NtStatus);
    }
}

DWORD
NwGetGraceLoginCount(
    LPWSTR  Server,
    LPWSTR  UserName,
    LPDWORD lpResult
    )
/*++

Routine Description:

    Get the number grace logins for a user.

Arguments:

    Server - the server to authenticate against

    UserName - the user account

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD status ;
    HANDLE hConn ;
    CHAR UserNameO[NW_MAX_USERNAME_LEN+1] ;
    BYTE LoginControl[128] ;
    BYTE MoreFlags, PropFlags ;

    //
    // skip the backslashes if present
    //
    if (*Server == L'\\')
        Server += 2 ;

    //
    // attach to the NW server
    //
    if (status = NWAttachToFileServerW(Server,
                                       0,
                                       &hConn))
    {
        return status ;
    }

    //
    // convert unicode UserName to OEM, and then call the NCP
    //
    if ( !WideCharToMultiByte(CP_OEMCP,
                              0,
                              UserName,
                              -1,
                              UserNameO,
                              sizeof(UserNameO),
                              NULL,
                              NULL))
    {
        status = GetLastError() ;
    }
    else
    {
        status = NWReadPropertyValue( hConn,
                                      UserNameO,
                                      OT_USER,
                                      "LOGIN_CONTROL",
                                      1,
                                      LoginControl,
                                      &MoreFlags,
                                      &PropFlags) ;
    }

    //
    // dont need these anymore. if any error, bag out
    //
    (void) NWDetachFromFileServer(hConn) ;


    if (status == NO_ERROR)
        *lpResult = (DWORD) LoginControl[7] ;

    return status ;
}


WORD
NwParseNdsUncPath(
    IN OUT LPWSTR * Result,
    IN LPWSTR ContainerName,
    IN ULONG flag
)
/*++

Routine Description:

    This function is used to extract either the tree name, fully distinguished
    name path to an object, or object name, out of a complete NDS UNC path.

Arguments:

    Result - parsed result buffer.
    ContainerName - Complete NDS UNC path that is to be parsed.
    flag - Flag indicating operation to be performed:

         PARSE_NDS_GET_TREE_NAME
         PARSE_NDS_GET_PATH_NAME
         PARSE_NDS_GET_OBJECT_NAME


Return Value:

    Length of string in result buffer. If error occured, 0 is returned.

--*/ // NwParseNdsUncPath
{
    unsigned short length = 2;
    unsigned short totalLength = (USHORT) wcslen( ContainerName );

    if ( totalLength < 2 )
        return 0;

    //
    // First get length to indicate the character in the string that indicates the
    // "\" in between the tree name and the rest of the UNC path.
    //
    // Example:  \\<tree name>\<path to object>[\|.]<object>
    //                        ^
    //                        |
    //
    while ( length < totalLength && ContainerName[length] != L'\\' )
    {
        length++;
    }

    if ( flag == PARSE_NDS_GET_TREE_NAME )
    {
        *Result = (LPWSTR) ( ContainerName + 2 );

        return ( length - 2 ) * sizeof( WCHAR ); // Take off 2 for the two \\'s
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME && length == totalLength )
    {
        *Result = ContainerName;

        return 0;
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME )
    {
        *Result = ContainerName + length + 1;

        return ( totalLength - length - 1 ) * sizeof( WCHAR );
    }

    *Result = ContainerName + totalLength - 1;
    length = 1;

    while ( **Result != L'\\' )
    {
        *Result--;
        length++;
    }

    *Result++;
    length--;

    return length * sizeof( WCHAR );
}


DWORD
NwOpenAServer(
    PWCHAR pwszServName,
    PHANDLE ServerHandle,
    BOOL    fVerify
    )
/*++

Routine Description:

    This routine opens a handle to a server.

Arguments:

    ServerHandle - Receives an opened handle to the preferred or
        nearest server.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    UNICODE_STRING AServer;
    WCHAR wszName[sizeof(NW_RDR_NAME) + (48 * sizeof(WCHAR))];
    DWORD wLen;


    if(!pwszServName)
    {
        pwszServName = NW_RDR_PREFERRED_SERVER;
        RtlInitUnicodeString(&AServer, wszName);
    }
    else
    {
        wLen = wcslen(pwszServName);
        if(wLen > 47)
        {
            return(WSAEFAULT);
        }
        wcscpy(wszName, NW_RDR_NAME);
        wcscat(wszName, pwszServName);
        RtlInitUnicodeString(&AServer, wszName);
    }

    return RtlNtStatusToDosError(
               NwOpenHandle(&AServer, fVerify, ServerHandle)
               );

}


DWORD
NwOpenPreferredServer(
    PHANDLE ServerHandle
    )
/*++

Routine Description:

    This routine opens a handle to the preferred server.  If the
    preferred server has not been specified, a handle to the
    nearest server is opened instead.

Arguments:

    ServerHandle - Receives an opened handle to the preferred or
        nearest server.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    UNICODE_STRING PreferredServer;


    //
    // The NetWare redirector recognizes "*" to mean the preferred
    // or nearest server.
    //
    RtlInitUnicodeString(&PreferredServer, NW_RDR_PREFERRED_SERVER);

    return RtlNtStatusToDosError(
               NwOpenHandle(&PreferredServer, FALSE, ServerHandle)
               );

}


NTSTATUS
NwOpenHandle(
    IN PUNICODE_STRING ObjectName,
    IN BOOL ValidateFlag,
    OUT PHANDLE ObjectHandle
    )
/*++

Routine Description:

    This function opens a handle to \Device\Nwrdr\<ObjectName>.

Arguments:

    ObjectName - Supplies the name of the redirector object to open.

    ValidateFlag - Supplies a flag which if TRUE, opens the handle to
        the object by validating the default user account.

    ObjectHandle - Receives a pointer to the opened object handle.

Return Value:

    STATUS_SUCCESS or reason for failure.

--*/
{
    ACCESS_MASK DesiredAccess = SYNCHRONIZE;


    if (ValidateFlag) {

        //
        // The redirector only authenticates the default user credential
        // if the remote resource is opened with write access.
        //
        DesiredAccess |= FILE_WRITE_DATA;
    }


    *ObjectHandle = NULL;

    return NwCallNtOpenFile(
               ObjectHandle,
               DesiredAccess,
               ObjectName,
               FILE_SYNCHRONOUS_IO_NONALERT
               );

}


NTSTATUS
NwCallNtOpenFile(
    OUT PHANDLE ObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING ObjectName,
    IN ULONG OpenOptions
    )
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;



    InitializeObjectAttributes(
        &ObjectAttributes,
        ObjectName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   ObjectHandle,
                   DesiredAccess,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   OpenOptions
                   );

    if (!NT_ERROR(ntstatus) &&
        !NT_INFORMATION(ntstatus) &&
        !NT_WARNING(ntstatus))  {

        ntstatus = IoStatusBlock.Status;

    }

    return ntstatus;
}


BOOL
NwConvertToUnicode(
    OUT LPWSTR *UnicodeOut,
    IN LPSTR  OemIn
    )
/*++

Routine Description:

    This function converts the given OEM string to a Unicode string.
    The Unicode string is returned in a buffer allocated by this
    function and must be freed with LocalFree.

Arguments:

    UnicodeOut - Receives a pointer to the Unicode string.

    OemIn - This is a pointer to an ansi string that is to be converted.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.  In this case a buffer for
        the unicode string was not allocated.

--*/
{
    NTSTATUS ntstatus;
    DWORD BufSize;
    UNICODE_STRING UnicodeString;
    OEM_STRING OemString;


    //
    // Allocate a buffer for the unicode string.
    //

    BufSize = (strlen(OemIn) + 1) * sizeof(WCHAR);

    *UnicodeOut = LocalAlloc(LMEM_ZEROINIT, BufSize);

    if (*UnicodeOut == NULL) {
        KdPrint(("NWWORKSTATION: NwConvertToUnicode:LocalAlloc failed %lu\n",
                 GetLastError()));
        return FALSE;
    }

    //
    // Initialize the string structures
    //
    RtlInitAnsiString((PANSI_STRING) &OemString, OemIn);

    UnicodeString.Buffer = *UnicodeOut;
    UnicodeString.MaximumLength = (USHORT) BufSize;
    UnicodeString.Length = 0;

    //
    // Call the conversion function.
    //
    ntstatus = RtlOemStringToUnicodeString(
                   &UnicodeString,     // Destination
                   &OemString,         // Source
                   FALSE               // Allocate the destination
                   );

    if (ntstatus != STATUS_SUCCESS) {

        KdPrint(("NWWORKSTATION: NwConvertToUnicode: RtlOemStringToUnicodeString failure x%08lx\n",
                 ntstatus));

        (void) LocalFree((HLOCAL) *UnicodeOut);
        *UnicodeOut = NULL;
        return FALSE;
    }

    *UnicodeOut = UnicodeString.Buffer;

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\lib\reg.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    reg.c

Abstract:

    This module provides helpers to call the registry used by both
    the client and server sides of the workstation.

Author:

    Rita Wong (ritaw)     22-Apr-1993

--*/


#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <winreg.h>
#include <winsvc.h>

#include <nwsnames.h>
#include <nwreg.h>
#include <nwapi.h>
#include <lmcons.h>
#include <lmerr.h>

#define LMSERVER_LINKAGE_REGKEY   L"System\\CurrentControlSet\\Services\\LanmanServer\\Linkage"
#define OTHERDEPS_VALUENAME       L"OtherDependencies"
#define LANMAN_SERVER             L"LanmanServer"

//
// Forward Declare
//

static
DWORD
NwRegQueryValueExW(
    IN      HKEY    hKey,
    IN      LPWSTR  lpValueName,
    OUT     LPDWORD lpReserved,
    OUT     LPDWORD lpType,
    OUT     LPBYTE  lpData,
    IN OUT  LPDWORD lpcbData
    );

DWORD 
CalcNullNullSize(
    WCHAR *pszNullNull
    )  ;

WCHAR *
FindStringInNullNull(
    WCHAR *pszNullNull,
    WCHAR *pszString
    ) ;

VOID
RemoveNWCFromNullNullList(
    WCHAR *OtherDeps
    ) ;

DWORD RemoveNwcDependency(
    VOID
    ) ;



DWORD
NwReadRegValue(
    IN HKEY Key,
    IN LPWSTR ValueName,
    OUT LPWSTR *Value
    )
/*++

Routine Description:

    This function allocates the output buffer and reads the requested
    value from the registry into it.

Arguments:

    Key - Supplies opened handle to the key to read from.

    ValueName - Supplies name of the value to retrieve data.

    Value - Returns a pointer to the output buffer which points to
        the memory allocated and contains the data read in from the
        registry.  This pointer must be freed with LocalFree when done.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - Failed to create buffer to read value into.

    Error from registry call.

--*/
{
    LONG    RegError;
    DWORD   NumRequired = 0;
    DWORD   ValueType;
    

    //
    // Set returned buffer pointer to NULL.
    //
    *Value = NULL;

    RegError = NwRegQueryValueExW(
                   Key,
                   ValueName,
                   NULL,
                   &ValueType,
                   (LPBYTE) NULL,
                   &NumRequired
                   );

    if (RegError != ERROR_SUCCESS && NumRequired > 0) {

        if ((*Value = (LPWSTR) LocalAlloc(
                                      LMEM_ZEROINIT,
                                      (UINT) NumRequired
                                      )) == NULL) {

            KdPrint(("NWWORKSTATION: NwReadRegValue: LocalAlloc of size %lu failed %lu\n",
                     NumRequired, GetLastError()));

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RegError = NwRegQueryValueExW(
                       Key,
                       ValueName,
                       NULL,
                       &ValueType,
                       (LPBYTE) *Value,
                       &NumRequired
                       );
    }
    else if (RegError == ERROR_SUCCESS) {
        KdPrint(("NWWORKSTATION: NwReadRegValue got SUCCESS with NULL buffer."));
        return ERROR_FILE_NOT_FOUND;
    }

    if (RegError != ERROR_SUCCESS) {

        if (*Value != NULL) {
            (void) LocalFree((HLOCAL) *Value);
            *Value = NULL;
        }

        return (DWORD) RegError;
    }

    return NO_ERROR;
}


static
DWORD
NwRegQueryValueExW(
    IN HKEY hKey,
    IN LPWSTR lpValueName,
    OUT LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE  lpData,
    IN OUT LPDWORD lpcbData
    )
/*++

Routine Description:

    This routine supports the same functionality as Win32 RegQueryValueEx
    API, except that it works.  It returns the correct lpcbData value when
    a NULL output buffer is specified.

    This code is stolen from the service controller.

Arguments:

    same as RegQueryValueEx

Return Value:

    NO_ERROR or reason for failure.

--*/
{    
    NTSTATUS ntstatus;
    UNICODE_STRING ValueName;
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
    DWORD BufSize;


    UNREFERENCED_PARAMETER(lpReserved);

    //
    // Make sure we have a buffer size if the buffer is present.
    //
    if ((ARGUMENT_PRESENT(lpData)) && (! ARGUMENT_PRESENT(lpcbData))) {
        return ERROR_INVALID_PARAMETER;
    }

    RtlInitUnicodeString(&ValueName, lpValueName);

    //
    // Allocate memory for the ValueKeyInfo
    //
    BufSize = *lpcbData + sizeof(KEY_VALUE_FULL_INFORMATION) +
              ValueName.Length
              - sizeof(WCHAR);  // subtract memory for 1 char because it's included
                                // in the sizeof(KEY_VALUE_FULL_INFORMATION).

    KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION) LocalAlloc(
                                                     LMEM_ZEROINIT,
                                                     (UINT) BufSize
                                                     );

    if (KeyValueInfo == NULL) {
        KdPrint(("NWWORKSTATION: NwRegQueryValueExW: LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ntstatus = NtQueryValueKey(
                   hKey,
                   &ValueName,
                   KeyValueFullInformation,
                   (PVOID) KeyValueInfo,
                   (ULONG) BufSize,
                   (PULONG) &BufSize
                   );

    if ((NT_SUCCESS(ntstatus) || (ntstatus == STATUS_BUFFER_OVERFLOW))
          && ARGUMENT_PRESENT(lpcbData)) {

        *lpcbData = KeyValueInfo->DataLength;
    }

    if (NT_SUCCESS(ntstatus)) {

        if (ARGUMENT_PRESENT(lpType)) {
            *lpType = KeyValueInfo->Type;
        }


        if (ARGUMENT_PRESENT(lpData)) {
            memcpy(
                lpData,
                (LPBYTE)KeyValueInfo + KeyValueInfo->DataOffset,
                KeyValueInfo->DataLength
                );
        }
    }

    (void) LocalFree((HLOCAL) KeyValueInfo);

    return RtlNtStatusToDosError(ntstatus);

}

VOID
NwLuidToWStr(
    IN PLUID LogonId,
    OUT LPWSTR LogonIdStr
    )
/*++

Routine Description:

    This routine converts a LUID into a string in hex value format so
    that it can be used as a registry key.

Arguments:

    LogonId - Supplies the LUID.

    LogonIdStr - Receives the string.  This routine assumes that this
        buffer is large enough to fit 17 characters.

Return Value:

    None.

--*/
{
    swprintf(LogonIdStr, L"%08lx%08lx", LogonId->HighPart, LogonId->LowPart);
}

VOID
NwWStrToLuid(
    IN LPWSTR LogonIdStr,
    OUT PLUID LogonId
    )
/*++

Routine Description:

    This routine converts a string in hex value format into a LUID.

Arguments:

    LogonIdStr - Supplies the string.

    LogonId - Receives the LUID.

Return Value:

    None.

--*/
{
    swscanf(LogonIdStr, L"%08lx%08lx", &LogonId->HighPart, &LogonId->LowPart);
}


DWORD
NwDeleteInteractiveLogon(
    IN PLUID Id OPTIONAL
    )
/*++

Routine Description:

    This routine deletes a specific interactive logon ID key in the registry
    if a logon ID is specified, otherwise it deletes all interactive logon
    ID keys.

Arguments:

    Id - Supplies the logon ID to delete.  NULL means delete all.

Return Status:

    None.

--*/
{
    LONG RegError;
    LONG DelError = ERROR_SUCCESS;
    HKEY InteractiveLogonKey;

    WCHAR LogonIdKey[NW_MAX_LOGON_ID_LEN];


    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_INTERACTIVE_LOGON_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ | KEY_WRITE | DELETE,
                   &InteractiveLogonKey
                   );

    if (RegError != ERROR_SUCCESS) {
        return RegError;
    }

    if (ARGUMENT_PRESENT(Id)) {

        //
        // Delete the key specified.
        //
        NwLuidToWStr(Id, LogonIdKey);

        DelError = RegDeleteKeyW(InteractiveLogonKey, LogonIdKey);

        if ( DelError )
            KdPrint(("     NwDeleteInteractiveLogon: failed to delete logon %lu\n", DelError));

    }
    else {

        //
        // Delete all interactive logon ID keys.
        //

        do {

            RegError = RegEnumKeyW(
                           InteractiveLogonKey,
                           0,
                           LogonIdKey,
                           sizeof(LogonIdKey) / sizeof(WCHAR)
                           );

            if (RegError == ERROR_SUCCESS) {

                //
                // Got a logon id key, delete it.
                //

                DelError = RegDeleteKeyW(InteractiveLogonKey, LogonIdKey);
            }
            else if (RegError != ERROR_NO_MORE_ITEMS) {
                KdPrint(("     NwDeleteInteractiveLogon: failed to enum logon IDs %lu\n", RegError));
            }

        } while (RegError == ERROR_SUCCESS);
    }

    (void) RegCloseKey(InteractiveLogonKey);

    return ((DWORD) DelError);
}

VOID
NwDeleteCurrentUser(
    VOID
    )
/*++

Routine Description:

    This routine deletes the current user value under the parameters key.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LONG RegError;
    HKEY WkstaKey;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ | KEY_WRITE | DELETE,
                   &WkstaKey
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpInitializeRegistry open NWCWorkstation\\Parameters key unexpected error %lu!\n",
                 RegError));
        return;
    }

    //
    // Delete CurrentUser value first so that the workstation won't be
    // reading this stale value. Ignore error since it may not exist.
    //
    (void) RegDeleteValueW(
               WkstaKey,
               NW_CURRENTUSER_VALUENAME
               );

    (void) RegCloseKey(WkstaKey);
}

DWORD
NwDeleteServiceLogon(
    IN PLUID Id OPTIONAL
    )
/*++

Routine Description:

    This routine deletes a specific service logon ID key in the registry
    if a logon ID is specified, otherwise it deletes all service logon
    ID keys.

Arguments:

    Id - Supplies the logon ID to delete.  NULL means delete all.

Return Status:

    None.

--*/
{
    LONG RegError;
    LONG DelError = STATUS_SUCCESS;
    HKEY ServiceLogonKey;

    WCHAR LogonIdKey[NW_MAX_LOGON_ID_LEN];


    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_SERVICE_LOGON_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ | KEY_WRITE | DELETE,
                   &ServiceLogonKey
                   );

    if (RegError != ERROR_SUCCESS) {
        return RegError;
    }

    if (ARGUMENT_PRESENT(Id)) {

        //
        // Delete the key specified.
        //
        NwLuidToWStr(Id, LogonIdKey);

        DelError = RegDeleteKeyW(ServiceLogonKey, LogonIdKey);

    }
    else {

        //
        // Delete all service logon ID keys.
        //

        do {

            RegError = RegEnumKeyW(
                           ServiceLogonKey,
                           0,
                           LogonIdKey,
                           sizeof(LogonIdKey) / sizeof(WCHAR)
                           );

            if (RegError == ERROR_SUCCESS) {

                //
                // Got a logon id key, delete it.
                //

                DelError = RegDeleteKeyW(ServiceLogonKey, LogonIdKey);
            }
            else if (RegError != ERROR_NO_MORE_ITEMS) {
                KdPrint(("     NwDeleteServiceLogon: failed to enum logon IDs %lu\n", RegError));
            }

        } while (RegError == ERROR_SUCCESS);
    }

    (void) RegCloseKey(ServiceLogonKey);

    return ((DWORD) DelError);
}

    
DWORD 
CalcNullNullSize(
    WCHAR *pszNullNull
    ) 
/*++

Routine Description:

        Walk thru a NULL NULL string, counting the number of
        characters, including the 2 nulls at the end.

Arguments:

        Pointer to a NULL NULL string

Return Status:
        
        Count of number of *characters*. See description.

--*/
{

    DWORD dwSize = 0 ;
    WCHAR *pszTmp = pszNullNull ;

    if (!pszNullNull)
        return 0 ;

    while (*pszTmp) 
    {
        DWORD dwLen = wcslen(pszTmp) + 1 ;

        dwSize +=  dwLen ;
        pszTmp += dwLen ;
    }

    return (dwSize+1) ;
}

WCHAR *
FindStringInNullNull(
    WCHAR *pszNullNull,
    WCHAR *pszString
)
/*++

Routine Description:

    Walk thru a NULL NULL string, looking for the search string

Arguments:

    pszNullNull: the string list we will search.
    pszString:   what we are searching for.

Return Status:

    The start of the string if found. Null, otherwise.

--*/
{
    WCHAR *pszTmp = pszNullNull ;

    if (!pszNullNull || !*pszNullNull)
        return NULL ;
   
    do {

        if  (_wcsicmp(pszTmp,pszString)==0)
            return pszTmp ;
 
        pszTmp +=  wcslen(pszTmp) + 1 ;

    } while (*pszTmp) ;

    return NULL ;
}

VOID
RemoveNWCFromNullNullList(
    WCHAR *OtherDeps
    )
/*++

Routine Description:

    Remove the NWCWorkstation string from a null null string.

Arguments:

    OtherDeps: the string list we will munge.

Return Status:

    None.

--*/
{
    LPWSTR pszTmp0, pszTmp1 ;

    //
    // find the NWCWorkstation string
    //
    pszTmp0 = FindStringInNullNull(OtherDeps, NW_WORKSTATION_SERVICE) ;

    if (!pszTmp0)
        return ;

    pszTmp1 = pszTmp0 + wcslen(pszTmp0) + 1 ;  // skip past it

    //
    // shift the rest up
    //
    memmove(pszTmp0, pszTmp1, CalcNullNullSize(pszTmp1)*sizeof(WCHAR)) ;
}

DWORD RemoveNwcDependency(
    VOID
    )
{
    SC_HANDLE ScManager = NULL;
    SC_HANDLE Service = NULL;
    LPQUERY_SERVICE_CONFIGW lpServiceConfig = NULL;
    DWORD err = NO_ERROR, dwBufferSize = 4096, dwBytesNeeded = 0;
    LPWSTR Deps = NULL ;

    lpServiceConfig = (LPQUERY_SERVICE_CONFIGW) LocalAlloc(LPTR, dwBufferSize) ;

    if (lpServiceConfig ==  NULL) {
        err = GetLastError();
        goto ExitPoint ;
    }

    ScManager = OpenSCManagerW(
                    NULL,
                    NULL,
                    SC_MANAGER_CONNECT
                    );

    if (ScManager == NULL) {

        err = GetLastError();
        goto ExitPoint ;
    }

    Service = OpenServiceW(
                  ScManager,
                  LANMAN_SERVER,
                  (SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG)
                  );

    if (Service == NULL) {
        err = GetLastError();
        goto ExitPoint ;
    }

    if (!QueryServiceConfigW(
             Service, 
             lpServiceConfig,   // address of service config. structure  
             dwBufferSize,      // size of service configuration buffer 
             &dwBytesNeeded     // address of variable for bytes needed  
             )) {

        err = GetLastError();

        if (err == ERROR_INSUFFICIENT_BUFFER) {

            err = NO_ERROR ;
            dwBufferSize = dwBytesNeeded ;
            lpServiceConfig = (LPQUERY_SERVICE_CONFIGW) 
                                  LocalAlloc(LPTR, dwBufferSize) ;

            if (lpServiceConfig ==  NULL) {
                err = GetLastError();
                goto ExitPoint ;
            }

            if (!QueryServiceConfigW(
                     Service,
                     lpServiceConfig,   // address of service config. structure
                     dwBufferSize,      // size of service configuration buffer
                     &dwBytesNeeded     // address of variable for bytes needed
                     )) {

                err = GetLastError();
            }
        }

        if (err != NO_ERROR) {
            
            goto ExitPoint ;
        }
    }

    Deps = lpServiceConfig->lpDependencies ;

    RemoveNWCFromNullNullList(Deps) ;
 
    if (!ChangeServiceConfigW(
           Service,
           SERVICE_NO_CHANGE,     // service type       (no change)
           SERVICE_NO_CHANGE,     // start type         (no change)
           SERVICE_NO_CHANGE,     // error control      (no change)
           NULL,                  // binary path name   (NULL for no change)
           NULL,                  // load order group   (NULL for no change)
           NULL,                  // tag id             (NULL for no change)
           Deps,                
           NULL,                  // service start name (NULL for no change)
           NULL,                  // password           (NULL for no change)
           NULL                   // display name       (NULL for no change)
           )) {

        err = GetLastError();
        goto ExitPoint ;
    }


ExitPoint:

    if (ScManager) {

        CloseServiceHandle(ScManager);
    }

    if (Service) {

        CloseServiceHandle(Service);
    }

    if (lpServiceConfig) {

        (void) LocalFree(lpServiceConfig) ;
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\lib\splutil.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    splutil.c

Abstract:

    This module provides all the utility functions for the netware print 
    provider.
 
Author:

    Yi-Hsin Sung    (yihsins)   15-Apr-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winspool.h>
#include <splutil.h>

DWORD_PTR PrinterInfo1Offsets[]={offsetof(LPPRINTER_INFO_1W, pDescription),
                             offsetof(LPPRINTER_INFO_1W, pName),
                             offsetof(LPPRINTER_INFO_1W, pComment),
                             0xFFFFFFFF};

DWORD_PTR PrinterInfo2Offsets[]={offsetof(LPPRINTER_INFO_2W, pServerName),
                             offsetof(LPPRINTER_INFO_2W, pPrinterName),
                             offsetof(LPPRINTER_INFO_2W, pShareName),
                             offsetof(LPPRINTER_INFO_2W, pPortName),
                             offsetof(LPPRINTER_INFO_2W, pDriverName),
                             offsetof(LPPRINTER_INFO_2W, pComment),
                             offsetof(LPPRINTER_INFO_2W, pLocation),
                             offsetof(LPPRINTER_INFO_2W, pDevMode),
                             offsetof(LPPRINTER_INFO_2W, pSepFile),
                             offsetof(LPPRINTER_INFO_2W, pPrintProcessor),
                             offsetof(LPPRINTER_INFO_2W, pDatatype),
                             offsetof(LPPRINTER_INFO_2W, pParameters),
                             offsetof(LPPRINTER_INFO_2W, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD_PTR PrinterInfo3Offsets[]={offsetof(LPPRINTER_INFO_3, pSecurityDescriptor),
                             0xFFFFFFFF};      

DWORD_PTR JobInfo1Offsets[]={offsetof(LPJOB_INFO_1W, pPrinterName),
                         offsetof(LPJOB_INFO_1W, pMachineName),
                         offsetof(LPJOB_INFO_1W, pUserName),
                         offsetof(LPJOB_INFO_1W, pDocument),
                         offsetof(LPJOB_INFO_1W, pDatatype),
                         offsetof(LPJOB_INFO_1W, pStatus),
                         0xFFFFFFFF};

DWORD_PTR JobInfo2Offsets[]={offsetof(LPJOB_INFO_2W, pPrinterName),
                         offsetof(LPJOB_INFO_2W, pMachineName),
                         offsetof(LPJOB_INFO_2W, pUserName),
                         offsetof(LPJOB_INFO_2W, pDocument),
                         offsetof(LPJOB_INFO_2W, pNotifyName),
                         offsetof(LPJOB_INFO_2W, pDatatype),
                         offsetof(LPJOB_INFO_2W, pPrintProcessor),
                         offsetof(LPJOB_INFO_2W, pParameters),
                         offsetof(LPJOB_INFO_2W, pDriverName),
                         offsetof(LPJOB_INFO_2W, pDevMode),
                         offsetof(LPJOB_INFO_2W, pStatus),
                         offsetof(LPJOB_INFO_2W, pSecurityDescriptor),
                         0xFFFFFFFF};

DWORD_PTR AddJobInfo1Offsets[]={offsetof(LPADDJOB_INFO_1W, Path),
                         0xFFFFFFFF};


VOID
MarshallUpStructure(
   LPBYTE  lpStructure,
   PDWORD_PTR lpOffsets,
   LPBYTE  lpBufferStart
)
{
   register DWORD i=0;

   while (lpOffsets[i] != -1) {

      if ((*(LPBYTE *)(lpStructure+lpOffsets[i]))) {
         (*(LPBYTE *)(lpStructure+lpOffsets[i]))+=(DWORD_PTR)lpBufferStart;
      }

      i++;
   }
}



VOID
MarshallDownStructure(
   LPBYTE  lpStructure,
   PDWORD_PTR lpOffsets,
   LPBYTE  lpBufferStart
)
{
    register DWORD i=0;

    if (!lpStructure)
        return;

    while (lpOffsets[i] != -1) {

        if ((*(LPBYTE*)(lpStructure+lpOffsets[i]))) {
            (*(LPBYTE*)(lpStructure+lpOffsets[i]))-=(DWORD_PTR)lpBufferStart;
        }

        i++;
    }
}



LPVOID
AllocNwSplMem(
    DWORD flags,
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    flags - Flags to be passed to LocalAlloc

    cb    - The amount of memory to allocate in bytes

Return Value:

    NON-NULL   - A pointer to the allocated memory

--*/
{
    LPDWORD  pMem;
    DWORD    cbNew;

#if DBG
    cbNew = cb + 2*sizeof(DWORD);
    if (cbNew & 3)
        cbNew += sizeof(DWORD) - (cbNew & 3);
#else
    cbNew = cb;
#endif

    pMem = (LPDWORD) LocalAlloc( flags, cbNew );

    if ( !pMem ) 
    {
        KdPrint(("Memory Allocation in AllocNwSplMem failed for %d bytes\n", cbNew));
        return NULL;
    }

#if DBG
    *pMem = cb;
    *(LPDWORD)((LPBYTE)pMem+cbNew-sizeof(DWORD)) = 0xdeadbeef;
    return (LPVOID) (pMem + 1);
#else
    return (LPVOID) pMem;
#endif

}



VOID
FreeNwSplMem(
   LPVOID pMem,
   DWORD  cb
)
/*++

Routine Description:

    This function will frees the local memory allocated by AllocSplMem.
    Extra checking will be performed in the debug version to ensure that
    the size to be freed is indeed the size we allocated through AllocSplMem.

Arguments:

    pMem - A pointer to the allocated memory
    cb   - The amount of memory to free 

Return Value:

--*/
{
    DWORD   cbNew;
    LPDWORD pNewMem;

    if ( !pMem )
        return;

    pNewMem = pMem;
#if DBG
    pNewMem--;
    cbNew = cb + 2*sizeof(DWORD);
    if ( cbNew & 3 )
        cbNew += sizeof(DWORD) - (cbNew & 3);

    if (  ( *pNewMem != cb )
       || (*(LPDWORD)((LPBYTE)pNewMem + cbNew - sizeof(DWORD)) != 0xdeadbeef)
       )
    {
        KdPrint(("Corrupt Memory in FreeNwSplMem : %0lx\n", pNewMem ));
        return;
    }
#else
    cbNew = cb;
#endif

    LocalFree( (LPVOID) pNewMem );
}



LPWSTR
AllocNwSplStr(
    LPWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL   - A pointer to the allocated memory containing the string

--*/
{
   LPWSTR pMem;

   if ( !pStr )
      return NULL;

   if ( pMem = AllocNwSplMem(0, (wcslen(pStr) + 1) * sizeof(WCHAR)))
      wcscpy(pMem, pStr);

   return pMem;
}



VOID
FreeNwSplStr(
   LPWSTR pStr
)
/*++

Routine Description:

    This function will frees the string allocated by AllocSplStr.
    Extra checking will be performed in the debug version to ensure that
    the size to be freed is indeed the size we allocated through AllocSplStr.

Arguments:

    pStr - A pointer to the allocated string 

Return Value:

--*/
{
   if ( pStr ) 
       FreeNwSplMem(pStr, (wcslen(pStr) + 1) * sizeof(WCHAR));
}



BOOL
ValidateUNCName(
   LPWSTR pName
)    
/*++

Routine Description:

    This function will checks whether the given name is a valid UNC 
    name ( in the form \\server\name) or not. 

Arguments:

    pName - The supplied name

Return Value:

    TRUE  - The name given is a valid UNC name 
    FALSE - Otherwise 

--*/
{
   if (   pName 
      && (*pName++ == L'\\') 
      && (*pName++ == L'\\') 
      && (wcschr(pName, L'\\'))
      )
   {
      return TRUE;
   }

   return FALSE;
}

#ifndef NOT_USED

LPWSTR 
GetNextElement(LPWSTR *pPtr, WCHAR token)
{
    LPWSTR pszRestOfString = *pPtr;
    LPWSTR pszRetval = NULL;
    LPWSTR pszStr    = NULL;

    if ( *pszRestOfString == L'\0') 
        return NULL;

    if ((pszStr = wcschr (pszRestOfString, token))== NULL )
    {
        pszRetval = *pPtr;
        *pPtr += wcslen(*pPtr);
        return pszRetval;
    }
    else
    {
        *pszStr = L'\0';
        pszRetval =  *pPtr ;
        *pPtr = ++pszStr ;
        return pszRetval ;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\credentl.c ===
/*++

Copyright (c) 1993, 1994  Microsoft Corporation

Module Name:

    credentl.c

Abstract:

    This module contains credential management routines supported by
    NetWare Workstation service.

Author:

    Rita Wong  (ritaw)   15-Feb-1993

Revision History:

    13-Apr-1994   Added change password code written by ColinW, AndyHe,
                  TerenceS, and RitaW.

--*/

#include <nw.h>
#include <nwreg.h>
#include <nwauth.h>
#include <nwxchg.h>
#include <nwapi.h>
#include <ntlsa.h>


//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Variables to coordinate reading of user logon credential from the
// registry if the user logged on before the workstation is started.
//
STATIC BOOL NwLogonNotifiedRdr;


STATIC
DWORD
NwpRegisterLogonProcess(
    OUT PHANDLE LsaHandle,
    OUT PULONG AuthPackageId
    );

STATIC
VOID
NwpGetServiceCredentials(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId
    );

STATIC
DWORD
NwpGetCredentialInLsa(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId,
    IN PLUID LogonId,
    OUT LPWSTR *UserName,
    OUT LPWSTR *Password
    );

STATIC
VOID
NwpGetInteractiveCredentials(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId
    );

DWORD
NwrLogonUser(
    IN LPWSTR Reserved OPTIONAL,
    IN PLUID LogonId,
    IN LPWSTR UserName,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR PreferredServerName OPTIONAL,
    IN LPWSTR NdsPreferredServerName OPTIONAL,
    OUT LPWSTR LogonCommand OPTIONAL,
    IN DWORD LogonCommandLength,
    IN DWORD PrintOption
    )
/*++

Routine Description:

    This function logs on the user to NetWare network.  It passes the
    user logon credential to the redirector to be used as the default
    credential when attaching to any server.

Arguments:

    Reserved - Must be NULL.

    UserName - Specifies the name of the user who logged on.

    Password - Specifies the password of the user who logged on.

    PreferredServerName - Specifies the user's preferred server.

    LogonCommand - Receives the string which is the command to execute
        on the command prompt for the user if logon is successful.

Return Value:

    NO_ERROR or error from redirector.

--*/
{
    DWORD status;

    UNREFERENCED_PARAMETER(Reserved);

    EnterCriticalSection(&NwLoggedOnCritSec);

    status = NwRdrLogonUser(
                 LogonId,
                 UserName,
                 wcslen(UserName) * sizeof(WCHAR),
                 Password,
                 (ARGUMENT_PRESENT(Password) ?
                     wcslen(Password) * sizeof(WCHAR) :
                     0),
                 PreferredServerName,
                 (ARGUMENT_PRESENT(PreferredServerName) ?
                     wcslen(PreferredServerName) * sizeof(WCHAR) :
                     0),
                 NdsPreferredServerName,
                 (ARGUMENT_PRESENT(NdsPreferredServerName) ?
                     wcslen(NdsPreferredServerName) * sizeof(WCHAR) :
                     0),
                 PrintOption
                 );

    if (status == NO_ERROR || status == NW_PASSWORD_HAS_EXPIRED) {
        NwLogonNotifiedRdr = TRUE;
    }

    LeaveCriticalSection(&NwLoggedOnCritSec);


    if (ARGUMENT_PRESENT(LogonCommand) && (LogonCommandLength >= sizeof(WCHAR))) {
        LogonCommand[0] = 0;
    }

    return status;
}


DWORD
NwrLogoffUser(
    IN LPWSTR Reserved OPTIONAL,
    IN PLUID LogonId
    )
/*++

Routine Description:

    This function tells the redirector to log off the interactive
    user.

Arguments:

    Reserved - Must be NULL.
   
    LogonId  - PLUID identifying the logged on process. 

Return Value:


--*/
{
    DWORD status = NO_ERROR ;

    UNREFERENCED_PARAMETER(Reserved);

    EnterCriticalSection(&NwLoggedOnCritSec);

    status = NwRdrLogoffUser(LogonId);

    LeaveCriticalSection(&NwLoggedOnCritSec);

    return status ;
}


DWORD
NwrSetInfo(
    IN LPWSTR Reserved OPTIONAL,
    IN DWORD  PrintOption,
    IN LPWSTR PreferredServerName OPTIONAL
    )
/*++

Routine Description:

    This function sets the preferred server and print option in
    the redirector for the interactive user.

Arguments:

    Reserved - Must be NULL.

    PreferredServerName - Specifies the user's preferred server.

    PrintOption - Specifies the user's print option flag

Return Value:

    NO_ERROR or error from redirector.

--*/
{
    DWORD err;

    UNREFERENCED_PARAMETER(Reserved);

    err = NwRdrSetInfo(
              PrintOption,
              NwPacketBurstSize,  // just reset to current
              PreferredServerName,
              (PreferredServerName != NULL ?
                  wcslen( PreferredServerName) * sizeof( WCHAR ) : 0 ),
              NwProviderName,    // just reset to current
              wcslen( NwProviderName ) * sizeof( WCHAR ) 
              );

    return err;
}

DWORD
NwrSetLogonScript(
    IN LPWSTR Reserved OPTIONAL,
    IN DWORD  ScriptOptions
    )
/*++

Routine Description:

    This function sets logon script related info. Currently, all that is
    supported is to turn the Run Logon Scripts Synchronously flag on and off.
    We do this using the global flag and not per user because at NPLogonNotify
    time we dont have per user registry yet. And rather than turn on & leave
    on, we turn on as need so that users that dont run NW scripts dont need 
    wait.

Arguments:

    Reserved - Must be NULL.

    ScriptOptions - options for logon scripts.

Return Value:

    Win32 error from calls made.

--*/
{
    DWORD dwSync, err = NO_ERROR ;
    HKEY hKeyWinLogon = NULL, hKeyNWC = NULL ;
    UNREFERENCED_PARAMETER(Reserved);


    if (!IsTerminalServer()) {

        // Setting global flags isn't multi-user, see userinit.c for multi-user implementation

        //
        // ***  Note that in this function we intentionally do not impersonate  ***
        // ***  since we are modifying registry under \SOFTWARE & \SYSTEM.      ***
        //

        //
        // Check the parameters. 
        //
        if (ScriptOptions ==  SYNC_LOGONSCRIPT) {
            dwSync = 1 ;   // this is value WinLogon needs to sync login scripts.
        } else if (ScriptOptions ==  RESET_SYNC_LOGONSCRIPT) {
            dwSync = 0 ;
        } else {
            return(ERROR_INVALID_PARAMETER) ;
        }

        //
        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentVersion\Services\NwcWorkstation
        // \Parameters.  We use this location to record the fact we temporarily
        // turned on the Sync Scripts Flag.
        //
        err  = RegOpenKeyExW(
                            HKEY_LOCAL_MACHINE,
                            NW_WORKSTATION_REGKEY,
                            0, 
                            KEY_READ | KEY_WRITE,               // desired access
                            &hKeyNWC) ;
        if ( err ) {
            return err ;
        }

        //
        // We are resetting. Check if we turned the flag on. If no, then leave
        // it be.
        //
        if (ScriptOptions ==  RESET_SYNC_LOGONSCRIPT) {
            DWORD dwType, dwValue = 0 ;
            DWORD dwSize = sizeof(dwValue) ;

            err = RegQueryValueExW(
                                  hKeyNWC,
                                  NW_SYNCLOGONSCRIPT_VALUENAME,
                                  NULL,
                                  &dwType,                             // ignored
                                  (LPBYTE) &dwValue,
                                  &dwSize) ;

            if ((err != NO_ERROR) || (dwValue == 0)) {
                //
                // value not there or zero. ie. assume we didnt set. quit now.
                //
                goto ExitPoint ;
            }
        }

        //
        //
        // Open HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion
        // \WinLogon.
        //
        err  = RegOpenKeyExW(
                            HKEY_LOCAL_MACHINE,
                            WINLOGON_REGKEY,
                            0, 
                            KEY_READ | KEY_WRITE,            // desired access
                            &hKeyWinLogon) ;
        if ( err ) {
            goto ExitPoint ;
        }

        //
        // We are setting. Check if flag is already on. If yes, then leave
        // it be.
        //
        if (ScriptOptions ==  SYNC_LOGONSCRIPT) {
            DWORD dwType, dwValue = 0 ;
            DWORD dwSize = sizeof(dwValue) ;

            err = RegQueryValueExW(
                                  hKeyWinLogon,
                                  SYNCLOGONSCRIPT_VALUENAME,
                                  NULL,
                                  &dwType,                     // ignored
                                  (LPBYTE) &dwValue,
                                  &dwSize) ;

            if ((err == NO_ERROR) && (dwValue == 1)) {
                //
                // already on. nothing to do. just return.
                //
                goto ExitPoint ;
            }
        }
        //
        // Write out value to make logon scripts synchronous. Or to reset it.
        //
        err = RegSetValueExW(
                            hKeyWinLogon,
                            SYNCLOGONSCRIPT_VALUENAME,
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwSync,          // either 1 or 0.
                            sizeof(dwSync)) ;

        if (err == NO_ERROR) {
            DWORD dwValue = (ScriptOptions == SYNC_LOGONSCRIPT) ? 1 : 0 ;
            //
            // We have successfully set WinLogon flag. Record (or clear) 
            // our own flag.
            //
            err = RegSetValueExW(
                                hKeyNWC,
                                NW_SYNCLOGONSCRIPT_VALUENAME,
                                0,
                                REG_DWORD,
                                (LPBYTE) &dwValue,   
                                sizeof(dwValue)) ;
        }

    } //if IsTerminalServer()
ExitPoint: 

    if (hKeyWinLogon) 
        (void) RegCloseKey( hKeyWinLogon );
    if (hKeyNWC) 
        (void) RegCloseKey( hKeyNWC );

    return err;
}


DWORD
NwrValidateUser(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR PreferredServerName 
    )
/*++

Routine Description:

    This function checks whether the user can be authenticated
    successfully on the given server.

Arguments:

    Reserved - Must be NULL.

    PreferredServerName - Specifies the user's preferred server.

Return Value:

    NO_ERROR or error that occurred during authentication.

--*/
{
    DWORD status ;
    UNREFERENCED_PARAMETER(Reserved);


    if (  ( PreferredServerName != NULL ) 
       && ( *PreferredServerName != 0 )
       )
    {
        //
        // Impersonate the client
        //
        if ((status = NwImpersonateClient()) != NO_ERROR)
        {
           return status ;
        }

        status = NwConnectToServer( PreferredServerName ) ;

        (void) NwRevertToSelf() ;

        return status ;

    }

    return NO_ERROR;
}


VOID
NwInitializeLogon(
    VOID
    )
/*++

Routine Description:

    This function initializes the data in the workstation which handles
    user logon.  It is called by the initialization thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Initialize logon flag.  When the redirector LOGON FsCtl has been
    // called, this flag will be set to TRUE.  Initialize the
    // critical section to serialize access to NwLogonNotifiedRdr flag.
    //
    NwLogonNotifiedRdr = FALSE;


}



VOID
NwGetLogonCredential(
    VOID
    )
/*++

Routine Description:

    This function reads the user and service logon IDs from the registry so
    that it can get the credentials from LSA.

    It handles the case where the user has logged on before the workstation
    is started.  This function is called by the initialization thread
    after opening up the RPC interface so that if user logon is happening
    concurrently, the provider is given a chance to call the NwrLogonUser API
    first, making it no longer necessary for the workstation to also
    retrieve the credential from the registry.

Arguments:

    None.

Return Value:

    None.

--*/
{

    DWORD status;

    HANDLE LsaHandle;
    ULONG AuthPackageId = 0;


    EnterCriticalSection(&NwLoggedOnCritSec);

    if (NwLogonNotifiedRdr) {
        //
        // Logon credential's already made known to the redirector by
        // the provider calling the NwrLogonUser API.
        //
#if DBG
        IF_DEBUG(LOGON) {
            KdPrint(("\nNWWORKSTATION: Redirector already has logon credential\n"));
        }
#endif
        LeaveCriticalSection(&NwLoggedOnCritSec);
        return;
    }

#if DBG
    IF_DEBUG(LOGON) {
        KdPrint(("NWWORKSTATION: Main init--NwGetLogonCredential\n"));
    }
#endif

    status = NwpRegisterLogonProcess(&LsaHandle, &AuthPackageId);

    if (status != NO_ERROR) {
        LeaveCriticalSection(&NwLoggedOnCritSec);
        return;
    }

    //
    // Tell the redirector about service credentials
    //
    NwpGetServiceCredentials(LsaHandle, AuthPackageId);
    //
    // Tell the redirector about interactive credentials
    //
    NwpGetInteractiveCredentials(LsaHandle, AuthPackageId);

    (void) LsaDeregisterLogonProcess(LsaHandle);

    LeaveCriticalSection(&NwLoggedOnCritSec);
}

STATIC
VOID
NwpGetServiceCredentials(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId
    )
/*++

Routine Description:

    This function reads the service logon IDs from the registry
    so that it can get the service credentials from LSA.  It then
    notifies the redirector of the service logons.

Arguments:

    LsaHandle - Supplies the handle to LSA.

    AuthPackageId - Supplies the NetWare authentication package ID.

Return Value:

    None.

--*/
{
    DWORD status;
    LONG RegError;

    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

    HKEY ServiceLogonKey;
    DWORD Index = 0;
    WCHAR LogonIdKey[NW_MAX_LOGON_ID_LEN];
    LUID LogonId;


    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_SERVICE_LOGON_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &ServiceLogonKey
                   );

    if (RegError == ERROR_SUCCESS) {

        do {

            RegError = RegEnumKeyW(
                           ServiceLogonKey,
                           Index,
                           LogonIdKey,
                           sizeof(LogonIdKey) / sizeof(WCHAR)
                           );

            if (RegError == ERROR_SUCCESS) {

                //
                // Got a logon id key.
                //

                NwWStrToLuid(LogonIdKey, &LogonId);

                status = NwpGetCredentialInLsa(
                             LsaHandle,
                             AuthPackageId,
                             &LogonId,
                             &UserName,
                             &Password
                             );

                if (status == NO_ERROR) {

                    (void) NwRdrLogonUser(
                               &LogonId,
                               UserName,
                               wcslen(UserName) * sizeof(WCHAR),
                               Password,
                               wcslen(Password) * sizeof(WCHAR),
                               NULL,
                               0,
                               NULL,
                               0,
                               NW_PRINT_OPTION_DEFAULT                 
                               );

                    //
                    // Freeing the UserName pointer frees both the
                    // username and password buffers.
                    //
                    (void) LsaFreeReturnBuffer((PVOID) UserName);

                }

            }
            else if (RegError != ERROR_NO_MORE_ITEMS) {
                KdPrint(("NWWORKSTATION: NwpGetServiceCredentials failed to enum logon IDs RegError=%lu\n",
                         RegError));
            }

            Index++;

        } while (RegError == ERROR_SUCCESS);

        (void) RegCloseKey(ServiceLogonKey);
    }
}


STATIC
VOID
NwpGetInteractiveCredentials(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId
    )
/*++

Routine Description:

    This function reads the interactive logon IDs from the registry
    so that it can get the interactive credentials from LSA.  It then
    notifies the redirector of the interactive logons.

Arguments:

    LsaHandle - Supplies the handle to LSA.

    AuthPackageId - Supplies the NetWare authentication package ID.

Return Value:

    None.

--*/
{
    DWORD status;
    LONG RegError;

    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

    HKEY InteractiveLogonKey;
    DWORD Index = 0;
    WCHAR LogonIdName[NW_MAX_LOGON_ID_LEN];
    LUID LogonId;
    DWORD PrintOption;
    HKEY WkstaOptionKey = NULL;
    HKEY CurrentUserOptionKey = NULL;
    HKEY  OneLogonKey;
    LPWSTR UserSid = NULL;
    PDWORD pPrintOption = NULL;
    LPWSTR PreferredServer = NULL;
    LPWSTR NdsPreferredServer = NULL;


    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_INTERACTIVE_LOGON_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &InteractiveLogonKey
                   );

    if (RegError == ERROR_SUCCESS) {

        do {

            RegError = RegEnumKeyW(
                           InteractiveLogonKey,
                           Index,
                           LogonIdName,
                           sizeof(LogonIdName) / sizeof(WCHAR)
                           );

            if (RegError == ERROR_SUCCESS) {

                //
                // Got a logon id key.
                //

                NwWStrToLuid(LogonIdName, &LogonId);

                status = NwpGetCredentialInLsa(
                             LsaHandle,
                             AuthPackageId,
                             &LogonId,
                             &UserName,
                             &Password
                             );

                if (status == NO_ERROR) {

            UserSid = NULL;

                    //
                    // Open the <LogonIdName> key under Logon
                    //
                    RegError = RegOpenKeyExW(
                        InteractiveLogonKey,
                        LogonIdName,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        &OneLogonKey
                    );

                    if ( RegError != ERROR_SUCCESS ) {
                        KdPrint(("NWWORKSTATION: NwpGetInteractiveLogonCredential: RegOpenKeyExW failed, Not interactive Logon: Error %d\n", GetLastError()));
                    }
            else {

                        //
                        // Read the SID value.
                        //
                        status = NwReadRegValue(
                            OneLogonKey,
                            NW_SID_VALUENAME,
                            (LPWSTR *) &UserSid
                        );

                        (void) RegCloseKey(OneLogonKey);

            if ( status != NO_ERROR ) {
                            KdPrint(("NWWORKSTATION: NwpGetInteractiveLogonCredential: Could not read SID from reg %lu\n", status));
                            UserSid = NULL;
                        }
                     }
             
             if ( UserSid ) {

                        PrintOption = NW_PRINT_OPTION_DEFAULT;
                        PreferredServer = NULL;

                        //
                        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet
            // \Services\NWCWorkstation\Parameters\Option
                        //
                        RegError = RegOpenKeyExW(
                            HKEY_LOCAL_MACHINE,
                            NW_WORKSTATION_OPTION_REGKEY,
                            REG_OPTION_NON_VOLATILE,   // options
                            KEY_READ,                  // desired access
                            &WkstaOptionKey
                        );

                        if (RegError != ERROR_SUCCESS) {
                            KdPrint(("NWWORKSTATION: NwpGetInteractiveCredentials: RegOpenKeyExW Parameter\\Option returns unexpected error %lu!!\n",
                            RegError));
                            goto NoOption;
                        }

                        //
                        // Open the <UserSid> key under Option
                        //
                        RegError = RegOpenKeyExW(
                            WkstaOptionKey,
                            UserSid,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            &CurrentUserOptionKey
                        );

                        if (RegError != ERROR_SUCCESS) {
                            KdPrint(("NWWORKSTATION: NwpGetInteractiveCredentials: RegOpenKeyExW Parameter\\Option\\SID returns unexpected error %lu!!\n",
                            RegError));
                            (void) RegCloseKey(WkstaOptionKey);
                            goto NoOption;
                        }

                        //
                        // Read the preferred server value.
                        //
                        status = NwReadRegValue(
                            CurrentUserOptionKey,
                            NW_SERVER_VALUENAME,
                            &PreferredServer
                        );

                        if (status != NO_ERROR) {
                           KdPrint(("NWWORKSTATION: NwpGetInteractiveCredentials: Could not read preferred server from reg %lu\n", status));
                           PreferredServer = NULL;
                        }

                        //
                        // Read the preferred NDS server value (if one exists).
                        //

                        status = NwReadRegValue(
                                               CurrentUserOptionKey,
                                               NW_NDS_SERVER_VALUENAME,
                                               &NdsPreferredServer
                                               );

                        if (status != NO_ERROR) {

#if DBG
                            IF_DEBUG(LOGON) {
                                KdPrint(("NWWORKSTATION: NwGetLogonCredential: Could not read preferred NDS server from reg %lu\n", status));
                            }
#endif

                            NdsPreferredServer = NULL;
                        }
                        //
                        // Read the print option value.
                        //
                        status = NwReadRegValue(
                            CurrentUserOptionKey,
                            NW_PRINTOPTION_VALUENAME,
                            (LPWSTR *) &pPrintOption
                        );
                        if (status != NO_ERROR) {
#if DBG
                            IF_DEBUG(LOGON) {
                                 KdPrint(("NWWORKSTATION: NwGetLogonCredential: Could not read print option from reg %lu\n", status));
                            }
#endif
                            PrintOption = NW_PRINT_OPTION_DEFAULT;
                        }
            else {
                           if ( pPrintOption != NULL ) {
                   PrintOption = *pPrintOption;
                               (void) LocalFree((HLOCAL) pPrintOption);
                   pPrintOption = NULL;
                           }
               else {
                               PrintOption = NW_PRINT_OPTION_DEFAULT;
               }
            }

                        (void) RegCloseKey(CurrentUserOptionKey);
                        (void) RegCloseKey(WkstaOptionKey);

NoOption:
                        (void) NwRdrLogonUser(
                                   &LogonId,
                                   UserName,
                                   wcslen(UserName) * sizeof(WCHAR),
                                   Password,
                                   wcslen(Password) * sizeof(WCHAR),
                                   PreferredServer,
                                   ((PreferredServer != NULL) ?
                                      wcslen(PreferredServer) * sizeof(WCHAR) :
                                      0),

                                   NdsPreferredServer,
                                   ((NdsPreferredServer != NULL) ?
                                   wcslen(NdsPreferredServer) * sizeof(WCHAR) :
                                   0),
                                   PrintOption
                                   );

                        //
                        // Freeing the UserName pointer frees both the
                        // username and password buffers.
                        //
                        (void) LsaFreeReturnBuffer((PVOID) UserName);

                        if (UserSid != NULL) {
                            (void) LocalFree((HLOCAL) UserSid);
                UserSid = NULL;
                        }

                        if (PreferredServer != NULL) {
                            (void) LocalFree((HLOCAL) PreferredServer);
                PreferredServer = NULL;
                        }
                    }

                }

            }
            else if (RegError != ERROR_NO_MORE_ITEMS) {
                KdPrint(("NWWORKSTATION: NwpGetInteractiveCredentials failed to enum logon IDs RegError=%lu\n",
                         RegError));
            }

            Index++;

        } while (RegError == ERROR_SUCCESS);

        (void) RegCloseKey(InteractiveLogonKey);
    }
}

STATIC
DWORD
NwpRegisterLogonProcess(
    OUT PHANDLE LsaHandle,
    OUT PULONG AuthPackageId
    )
/*++

Routine Description:

    This function registers the workstation service as a logon process
    so that it can call LSA to retrieve user credentials.

Arguments:

    LsaHandle - Receives the handle to LSA.

    AuthPackageId - Receives the NetWare authentication package ID.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus;
    STRING InputString;
    LSA_OPERATIONAL_MODE SecurityMode = 0;

    //
    // Register this process as a logon process so that we can call
    // NetWare authentication package.
    //
    RtlInitString(&InputString, "Client Service for NetWare");

    ntstatus = LsaRegisterLogonProcess(
                   &InputString,
                   LsaHandle,
                   &SecurityMode
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: NwInitializeLogon: LsaRegisterLogonProcess returns x%08lx\n",
                 ntstatus));
        return RtlNtStatusToDosError(ntstatus);
    }

    //
    // Look up the Netware authentication package
    //
    RtlInitString(&InputString, NW_AUTH_PACKAGE_NAME);

    ntstatus = LsaLookupAuthenticationPackage(
                   *LsaHandle,
                   &InputString,
                   AuthPackageId
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: NwpSetCredential: LsaLookupAuthenticationPackage returns x%08lx\n",
                 ntstatus));

        (void) LsaDeregisterLogonProcess(*LsaHandle);
    }

    status = RtlNtStatusToDosError(ntstatus);

    return status;
}

STATIC
DWORD
NwpGetCredentialInLsa(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId,
    IN PLUID LogonId,
    OUT LPWSTR *UserName,
    OUT LPWSTR *Password
    )
/*++

Routine Description:

    This function retrieves the username and password information
    from LSA given the logon ID.

Arguments:

    LsaHandle - Supplies the handle to LSA.

    AuthPackageId - Supplies the NetWare authentication package ID.

    LogonId - Supplies the logon ID.

    UserName - Receives a pointer to the username.

    Password - Receives a pointer to the password.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    NTSTATUS AuthPackageStatus;

    NWAUTH_GET_CREDENTIAL_REQUEST GetCredRequest;
    PNWAUTH_GET_CREDENTIAL_RESPONSE GetCredResponse;
    ULONG ResponseLength;

    UNICODE_STRING PasswordStr;

    //
    // Ask authentication package for credential.
    //
    GetCredRequest.MessageType = NwAuth_GetCredential;
    RtlCopyLuid(&GetCredRequest.LogonId, LogonId);

    ntstatus = LsaCallAuthenticationPackage(
                   LsaHandle,
                   AuthPackageId,
                   &GetCredRequest,
                   sizeof(GetCredRequest),
                   (PVOID *) &GetCredResponse,
                   &ResponseLength,
                   &AuthPackageStatus
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = AuthPackageStatus;
    }
    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: NwpGetCredentialInLsa: LsaCallAuthenticationPackage returns x%08lx\n",
                 ntstatus));
        status = RtlNtStatusToDosError(ntstatus);
    }
    else {

        *UserName = GetCredResponse->UserName;
        *Password = GetCredResponse->Password;

        //
        // Decode the password.
        //
        RtlInitUnicodeString(&PasswordStr, GetCredResponse->Password);
        RtlRunDecodeUnicodeString(NW_ENCODE_SEED, &PasswordStr);

        status = NO_ERROR;
    }

    return status;
}

DWORD
NwrChangePassword(
    IN LPWSTR Reserved OPTIONAL,
    IN DWORD  UserLuid,
    IN LPWSTR UserName,
    IN LPWSTR OldPassword,
    IN LPWSTR NewPassword,
    IN LPWSTR TreeName
    )
/*++

Routine Description:

    This function changes the password for the specified user on
    the list of servers.  If we encounter a failure on changing
    password for a particular server, we:

        1) Send the new password over to the server to verify if it is
           already the current password.

        2) If not, return ERROR_INVALID_PASSWORD and the index into
           the Servers array indicating the server which failed so that
           we can prompt the user to enter an alternate old password.

    When the password has been changed successfully on a server, we
    notify the redirector so that the cached credential can be updated.

    NOTE: All errors returned from this routine, except for the fatal
          ERROR_NOT_ENOUGH_MEMORY error, indicates that the password
          could not be changed on a particular server indexed by
          LastProcessed.  The client-side continues to call us with
          the remaining list of servers.

          If you add to this routine to return other fatal errors,
          please make sure the client-side code aborts from calling
          us with the rest of the servers on getting those errors.

Arguments:

    Reserved - Must be NULL.


Return Value:

    ERROR_BAD_NETPATH - Could not connect to the server indexed by
        LastProcessed.

    ERROR_BAD_USERNAME - The username could not be found on the server
        indexed by LastProcessed.

    ERROR_INVALID_PASSWORD - The change password operation failed on
        the server indexed by LastProcessed.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory error.  This fatal error
        will terminate the client-side from trying to process password
        change request on the remaining servers.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    HANDLE hNwRdr = NULL;
    UNICODE_STRING UserNameStr;
    UNICODE_STRING OldPasswordStr;
    UNICODE_STRING NewPasswordStr;
    UNICODE_STRING TreeNameStr;
    BOOL fImpersonateClient = FALSE;

    UNREFERENCED_PARAMETER( Reserved ) ;
    UNREFERENCED_PARAMETER( UserLuid ) ;

    RtlInitUnicodeString( &UserNameStr, UserName );

    RtlInitUnicodeString( &OldPasswordStr, OldPassword );
    RtlRunDecodeUnicodeString( NW_ENCODE_SEED2, &OldPasswordStr );

    RtlInitUnicodeString( &NewPasswordStr, NewPassword );
    RtlRunDecodeUnicodeString( NW_ENCODE_SEED2, &NewPasswordStr );

    RtlInitUnicodeString( &TreeNameStr, TreeName );

    //
    // Impersonate the client
    //
    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto ErrorExit;
    }

    fImpersonateClient = TRUE;

    //
    // Open a NDS tree connection handle to \\treename
    //
    ntstatus = NwNdsOpenTreeHandle( &TreeNameStr, &hNwRdr );

    if ( ntstatus != STATUS_SUCCESS )
    {
        status = RtlNtStatusToDosError(ntstatus);
        goto ErrorExit;
    }
 
    (void) NwRevertToSelf() ;
    fImpersonateClient = FALSE;

    ntstatus = NwNdsChangePassword( hNwRdr,
                                    &TreeNameStr,
                                    &UserNameStr,
                                    &OldPasswordStr,
                                    &NewPasswordStr );

    if ( ntstatus != NO_ERROR )
    {
        status = RtlNtStatusToDosError(ntstatus);
        goto ErrorExit;
    }

    CloseHandle( hNwRdr );
    hNwRdr = NULL;

    return NO_ERROR ;

ErrorExit:

    if ( fImpersonateClient )
        (void) NwRevertToSelf() ;

    if ( hNwRdr )
        CloseHandle( hNwRdr );

    hNwRdr = NULL;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\connect.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    connect.c

Abstract:

    This module contains tree connections routines supported by
    NetWare Workstation service.

Author:

    Rita Wong  (ritaw)   15-Feb-1993

Revision History:

--*/

#include <nw.h>
#include <handle.h>
#include <nwauth.h>
#include <nwcanon.h>
#include <nwreg.h>
#include <winbasep.h>


#define NW_ENUM_EXTRA_BYTES    256

extern BOOL NwLUIDDeviceMapsEnabled;

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
NwAllocAndGetUncName(
    IN LPWSTR LocalName,
    IN DWORD LocalNameLength,
    OUT LPWSTR *UncName
    );

DWORD
NwDeleteAllInRegistry(
    VOID
    );

DWORD
NwDeleteUidSymLinks(
    IN LUID Uid,
    IN ULONG WinStationId
    );


LPTSTR
NwReturnSessionPath(
                    IN  LPTSTR LocalDeviceName
                   );

//-------------------------------------------------------------------//



DWORD
NwrCreateConnection(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD Type,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UserName OPTIONAL
    )
/*++

Routine Description:

    This function creates a tree connection to the specified RemoteName
    (UNC name) and maps it to the LocalName (local device name), if
    it is specified.  The password and user name are the credentials
    used to create the connection, if specified; otherwise, the
    interactive logged on user's credentials are used by default.

    NOTE: This code now calls a helper routine to do the work, this helper
    routine (NwCreateConnection) is identical to the code that used to be
    here with the exception that the helper does call ImpersonateClient(). 
    We now do the client impersonation outside of the helper routine.

Arguments:

    Reserved - Must be NULL.

    LocalName - Supplies the local device name to map to the created tree
        connection.  Only drive letter device names are accepted.  (No
        LPT or COM).

    RemoteName - Supplies the UNC name of the remote resource in the format
        of Server\Volume\Directory.  It must be a disk resource.

    Type - Supplies the connection type.

    Password - Supplies the password to use to make the connection to the
        server.

    UserName - Supplies the user name to use to make the connection.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating internal work buffers.

    WN_BAD_NETNAME - Remote resource name is invalid.

    WN_BAD_LOCALNAME - Local DOS device name is invalid.

    ERROR_BAD_NETPATH - The UNC name does not exist on the network.

    ERROR_INVALID_PARAMETER - LPT or COM LocalName was specified.

    Other errors from the redirector.

--*/
{
    DWORD status;
    BOOL Impersonate = FALSE ;

    UNREFERENCED_PARAMETER(Reserved);

    //
    // Impersonate the client
    //
    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto CleanExit;
    }

    Impersonate = TRUE ;

    status = NwCreateConnection( LocalName,
                                 RemoteName,
                                 Type,
                                 Password,
                                 UserName );

CleanExit:
 
    if (Impersonate) {
        (void) NwRevertToSelf();
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwrCreateConnection returns %lu\n", status));
    }
#endif

    return status;
}


DWORD
NwrDeleteConnection(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ConnectionName,
    IN DWORD UseForce
    )
/*++

Routine Description:

    This function deletes an existing connection.

Arguments:

    Reserved - Must be NULL.

    ConnectionName - Supplies the local device name or UNC name which
        specifies the connection to delete.  If UNC name is specified,
        the UNC connection must exist.


    UseForce - Supplies a flag which if TRUE specifies to tear down
        the connection eventhough files are opened.  If FALSE, the
        connection is deleted only if there are no opened files.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating internal work buffers.

    WN_BAD_NETNAME - ConnectionName is invalid.

    ERROR_BAD_NETPATH - The UNC name does not exist on the network.

    ERROR_INVALID_PARAMETER - LPT or COM LocalName was specified.

    Other errors from the redirector.

--*/
{
    DWORD status;

    LPWSTR ConnectName = NULL;
    DWORD ConnectLength;

    LPWSTR LocalName;
    LPWSTR UncName = NULL;

    BOOL Impersonate = FALSE ;

    UNREFERENCED_PARAMETER(Reserved);

    if (*ConnectionName == 0) {
        return ERROR_INVALID_PARAMETER;
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWWORKSTATION: NwrDeleteConnection: ConnectionName %ws, Force %lu\n",
                 ConnectionName, UseForce));
    }
#endif

    if ((status = NwLibCanonLocalName(
                      ConnectionName,
                      &ConnectName,
                      &ConnectLength
                      )) == NO_ERROR) {

        //
        // Get the UNC name mapped to this drive letter so that we can
        // open a handle to it for deletion.
        //
    // ----Multi-user---------
    // Need to impersonate the client
        if ((status = NwImpersonateClient()) != NO_ERROR) {
                goto CleanExit;
        }
        Impersonate = TRUE ;

        if ((status = NwAllocAndGetUncName(
                          ConnectName,
                          ConnectLength,
                          &UncName
                          )) != NO_ERROR) {

            (void) LocalFree((HLOCAL) ConnectName);

            if (Impersonate) {
                (void) NwRevertToSelf();
            }

            return status;
        }

        LocalName = ConnectName;

    }
    else {

        //
        // Not a device name.  See if it is a UNC name.
        //
        if ((status = NwLibCanonRemoteName(
                          NULL,
                          ConnectionName,
                          &ConnectName,
                          NULL
                          )) != NO_ERROR) {

            return status;
        }

        UncName = ConnectName;
        LocalName = NULL;

    }


    if ( !Impersonate ) {
        if ((status = NwImpersonateClient()) != NO_ERROR) {
            goto CleanExit;
        }
        Impersonate = TRUE ;
    }
    //
    // To delete a connection, a tree connection handle must be opened to
    // it so that the handle can be specified to the redirector to delete
    // the connection.
    //
    status = NwOpenHandleToDeleteConn(
                 UncName,
                 LocalName,
                 UseForce,
                 FALSE,
                 TRUE
                 );

    if ( status == ERROR_FILE_NOT_FOUND )
        status = ERROR_BAD_NETPATH;

CleanExit:

    if (Impersonate) {
        (void) NwRevertToSelf();
    }
    if (UncName != NULL && UncName != ConnectName) {
        (void) LocalFree((HLOCAL) UncName);
    }

    if (ConnectName != NULL) {
        (void) LocalFree((HLOCAL) ConnectName);
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwrDeleteConnection returns %lu\n", status));
    }
#endif

    return status;
}


DWORD
NwrQueryServerResource(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR LocalName,
    OUT LPWSTR RemoteName,
    IN DWORD RemoteNameLen,
    OUT LPDWORD CharsRequired
    )
/*++

Routine Description:

    This function looks up the UNC name associated with the given DOS
    device name.

Arguments:

    Reserved - Must be NULL.

    LocalName - Supplies the local device name to look up.

    RemoteName - Receives the UNC name mapped to the LocalName.

    RemoteNameLen - Supplies the length of the RemoteName buffer.

    CharsRequired - Receives the length required of the RemoteName buffer
        to get the UNC name.  This value is only returned if the return
        code is ERROR_MORE_DATA.

Return Value:

    NO_ERROR - Operation was successful.

    WN_BAD_LOCALNAME - LocalName was invalid.

    ERROR_INVALID_PARAMETER - LPT or COM LocalName was specified.

    ERROR_MORE_DATA - RemoteName buffer was too small.

    ERROR_NOT_CONNECTED - LocalName does not map to any server resource.

--*/
{
    DWORD status;

    LPWSTR Local;
    DWORD LocalLength;

    BOOL Impersonate = FALSE ;

    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWWORKSTATION: NwrQueryServerResource: LocalName %ws, RemoteNameLen %lu\n",
                 LocalName, RemoteNameLen));
    }
#endif

    //
    // Canonicalize the LocalName
    //
    if ((status = NwLibCanonLocalName(
                      LocalName,
                      &Local,
                      &LocalLength
                      )) != NO_ERROR) {

        return WN_BAD_LOCALNAME;
    }

    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto CleanExit;
    }

    Impersonate = TRUE ;

    status = NwGetServerResource(
                 Local,
                 LocalLength,
                 RemoteName,
                 RemoteNameLen,
                 CharsRequired
                 );

CleanExit:

    if (Impersonate) {
        (void) NwRevertToSelf();
    }

    (void) LocalFree((HLOCAL) Local);

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwrQueryServerResource returns %lu\n", status));

        if (status == NO_ERROR) {
            KdPrint(("              RemoteName is %ws\n", RemoteName));
        }
        else if (status == ERROR_MORE_DATA) {
            KdPrint(("              RemoteNameLen %lu too small.  Need %lu\n",
                     RemoteNameLen, *CharsRequired));
        }
    }
#endif

    return status;
}


DWORD
NwrOpenEnumConnections(
    IN LPWSTR Reserved OPTIONAL,
    IN DWORD ConnectionType,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function creates a new context handle and initializes it
    for enumerating the connections.

Arguments:

    Reserved - Unused.

    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

--*/
{
    LPNW_ENUM_CONTEXT ContextHandle;


    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(CONNECT) {
       KdPrint(("\nNWWORKSTATION: NwrOpenEnumConnections\n"));
    }
#endif

    //
    // Allocate memory for the context handle structure.
    //
    ContextHandle = (PVOID) LocalAlloc(
                                LMEM_ZEROINIT,
                                sizeof(NW_ENUM_CONTEXT)
                                );

    if (ContextHandle == NULL) {
        KdPrint(("NWWORKSTATION: NwrOpenEnumConnections LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure.
    //
    ContextHandle->Signature = NW_HANDLE_SIGNATURE;
    ContextHandle->HandleType = NwsHandleListConnections;
    ContextHandle->ResumeId = 0;
    ContextHandle->ConnectionType = 0;

    if ( ConnectionType == RESOURCETYPE_ANY ) {
        ContextHandle->ConnectionType = CONNTYPE_ANY;
    }
    else {
        
        if ( ConnectionType & RESOURCETYPE_DISK ) 
            ContextHandle->ConnectionType |= CONNTYPE_DISK;

        if ( ConnectionType & RESOURCETYPE_PRINT ) 
            ContextHandle->ConnectionType |= CONNTYPE_PRINT;
    }
         
         

    //
    // Return the newly created context.
    //
    *EnumHandle = (LPNWWKSTA_CONTEXT_HANDLE) ContextHandle;

    return NO_ERROR;
}


DWORD
NwrGetConnectionPerformance(
    IN  LPWSTR Reserved OPTIONAL,
    IN  LPWSTR lpRemoteName,
    OUT LPBYTE lpNetConnectInfo,
    IN  DWORD  dwBufferSize
    )
/*++

Routine Description:

    This function returns information about the expected performance of a
    connection used to access a network resource. The request can only be
    for a network resource to which there is currently a connection.

Arguments:

    Reserved - Unused.

    lpRemoteName - Contains the local name or remote name for a resource
                   for which a connection exists.

    lpNetConnectInfo - This is a pointer to a NETCONNECTINFOSTRUCT structure
                       which is to be filled if the connection performance
                       of connection lpRemoteName can be determined.

Return Value:

    NO_ERROR - Successful.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_NONETWORK - Network is not present.

    Other network errors.

--*/
{
    DWORD             status = NO_ERROR;
    LPNETCONNECTINFOSTRUCT lpNetConnInfo =
                       (LPNETCONNECTINFOSTRUCT) lpNetConnectInfo;
    NTSTATUS          ntstatus;
    IO_STATUS_BLOCK   IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK       DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    //
    //  dfergus 19 Apr 2001 - #333280
    //  Init hRdr so test for null is valid
    HANDLE            hRdr = NULL;

    WCHAR OpenString[] = L"\\Device\\Nwrdr\\*";
    UNICODE_STRING OpenName;
    UNICODE_STRING ConnectionName;

    PNWR_REQUEST_PACKET Request = NULL;
    ULONG BufferSize = 0;
    ULONG RequestSize;
    BOOL  Impersonate = FALSE ;

    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(dwBufferSize);

    if (lpRemoteName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    BufferSize = sizeof(NWR_REQUEST_PACKET) +
        ( ( wcslen(lpRemoteName) + 1 ) * sizeof(WCHAR) );

    //
    // Impersonate the client
    //
    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto ExitWithClose;
    }

    Impersonate = TRUE;

    //
    // Allocate buffer space.
    //
    Request = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT, BufferSize );

    if ( Request == NULL )
    {
        KdPrint(("NWWORKSTATION: NwrGetConnectionPerformance LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlInitUnicodeString( &OpenName, OpenString );

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
    {
        status = RtlNtStatusToDosError(ntstatus);
        goto ExitWithClose;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_PERFORMANCE.
    //
    RtlInitUnicodeString( &ConnectionName, lpRemoteName );

    Request->Parameters.GetConnPerformance.RemoteNameLength =
        ConnectionName.Length;
    RtlCopyMemory( Request->Parameters.GetConnPerformance.RemoteName,
                   ConnectionName.Buffer,
                   ConnectionName.Length );

    RequestSize = sizeof( NWR_REQUEST_PACKET ) + ConnectionName.Length;

    ntstatus = NtFsControlFile( hRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_PERFORMANCE,
                                (PVOID) Request,
                                RequestSize,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( ntstatus ) )
    {
        status = RtlNtStatusToDosError(ntstatus);
        goto ExitWithClose;
    }

    lpNetConnInfo->cbStructure = sizeof(NETCONNECTINFOSTRUCT);
    lpNetConnInfo->dwFlags = Request->Parameters.GetConnPerformance.dwFlags;
    lpNetConnInfo->dwSpeed = Request->Parameters.GetConnPerformance.dwSpeed;
    lpNetConnInfo->dwDelay = Request->Parameters.GetConnPerformance.dwDelay;
    lpNetConnInfo->dwOptDataSize =
        Request->Parameters.GetConnPerformance.dwOptDataSize;

ExitWithClose:
    if ( Request )
        LocalFree( Request );
 
    if ( Impersonate )
    {
        (void) NwRevertToSelf();
    }

    if ( hRdr )
       NtClose( hRdr );

    return status;
}



DWORD
NwAllocAndGetUncName(
    IN LPWSTR LocalName,
    IN DWORD LocalNameLength,
    OUT LPWSTR *UncName
    )
/*++

Routine Description:

    This function calls an internal routine to ask the redirector for the
    UNC name of a given DOS device name.  It also allocates the output
    buffer to hold the UNC name.

Arguments:

    LocalName - Supplies the DOS device name.

    LocalNameLength - Supplies the length of the DOS device name (chars).

    UncName - Receives a pointer to the output buffer allocated by this
        routine which contains the UNC name of the DOS device.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

    Other errors from the redirector.
--*/
{
    DWORD status;
    DWORD UncNameLength;



    *UncName = (PVOID) LocalAlloc(
                           LMEM_ZEROINIT,
                           (MAX_PATH + 1) * sizeof(WCHAR)
                           );

    if (*UncName == NULL) {
        KdPrint(("NWWORKSTATION: NwAllocAndGetUncName LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    status = NwGetServerResource(
                 LocalName,
                 LocalNameLength,
                 *UncName,
                 MAX_PATH + 1,
                 &UncNameLength
                 );

    if ((status == ERROR_MORE_DATA) || (status == ERROR_INSUFFICIENT_BUFFER)) {

        //
        // Our output buffer was too small.  Try again.
        //
        (void) LocalFree((HLOCAL) *UncName);

        *UncName = (PVOID) LocalAlloc(
                               LMEM_ZEROINIT,
                               UncNameLength * sizeof(WCHAR)
                               );

        if (*UncName == NULL) {
            KdPrint(("NWWORKSTATION: NwAllocAndGetUncName LocalAlloc Failed %lu\n",
                     GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        status = NwGetServerResource(
                     LocalName,
                     LocalNameLength,
                     *UncName,
                     UncNameLength,
                     &UncNameLength
                     );

    }

    //
    // callers will only free this if success.
    //
    if (status != NO_ERROR) 
    {
        (void) LocalFree((HLOCAL) *UncName);
        *UncName = NULL ;
    }

    return status;
}


DWORD
NwOpenHandleToDeleteConn(
    IN LPWSTR UncName,
    IN LPWSTR LocalName OPTIONAL,
    IN DWORD UseForce,
    IN BOOL IsStopWksta,
    IN BOOL ImpersonatingClient
    )
/*++

Routine Description:

    This function deletes an active connection by opening a tree connection
    handle to the connection first, and specifying this handle to the
    redirector to delete.  This is because the workstation service does
    not keep any connection information.

Arguments:

    UncName - Supplies the UNC name of the connection to delete.

    LocalName - Supplies the DOS device name of the connection, if any.

    UseForce - Supplies a flag which if TRUE specifies to tear down
        the connection eventhough files are opened.  If FALSE, the
        connection is deleted only if there are no opened files.

    IsStopWksta - Supplies a flag which if TRUE indicates that we must
        delete the symbolic link, even when we have failed to delete the
        connection in the redirector.  As much as possible must be cleaned
        up because the workstation service is stopping.  A value of FALSE,
        indicates that the delete is aborted if we cannot delete it in
        the redirector.

    ImpersonatingClient - Flag that indicates whether the thread has
        called NwImpersonateClient. The gateway service functions don't
        impersonate, where as the client service operations do.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

    Other errors from the redirector.
--*/
{
    DWORD status;
    NTSTATUS ntstatus ;

    UNICODE_STRING TreeConnectStr;
    HANDLE TreeConnection = NULL;



    TreeConnectStr.Buffer = NULL;

    //
    // Create an NT-style tree connection name, either: \Device\Nwrdr\Server\Vol
    // or \Device\Nwrdr\X:\Server\Vol, if LocalName is specified.
    //
    if ((status = NwCreateTreeConnectName(
                      UncName,
                      LocalName,
                      &TreeConnectStr
                      )) != NO_ERROR) {
        return status;
    }

    ntstatus = NwCallNtOpenFile( &TreeConnection, 
                                 SYNCHRONIZE | DELETE, 
                                 &TreeConnectStr, 
                                 FILE_CREATE_TREE_CONNECTION  
                                   | FILE_SYNCHRONOUS_IO_NONALERT
                                   | FILE_DELETE_ON_CLOSE
                                 );
    //
    // treat the 2 as the same in order to return nicer error to user
    //
    if (ntstatus == STATUS_OBJECT_NAME_INVALID)
        ntstatus = STATUS_OBJECT_NAME_NOT_FOUND ; 
    status = NwMapStatus(ntstatus) ;

    if (status == NO_ERROR) {

        //
        // Ask the redirector to delete the tree connection.
        //
        status = NwNukeConnection(
                     TreeConnection,
                     UseForce
                     );

        (void) CloseHandle(TreeConnection);
    }

    if (ARGUMENT_PRESENT(LocalName) &&
        (status == NO_ERROR || IsStopWksta))
    {
        //
        // Delete the symbolic link we created.
        //
        NwDeleteSymbolicLink(
            LocalName,
            TreeConnectStr.Buffer,
            NULL,
            ImpersonatingClient
            );
    }

    if (TreeConnectStr.Buffer != NULL) {
        (void) LocalFree((HLOCAL) TreeConnectStr.Buffer);
    }

    return status;
}


VOID
DeleteAllConnections(
    VOID
    )
/*++

Routine Description:

    This function deletes all active connections returned by the
    redirector ENUMERATE_CONNECTIONS fsctl on workstation termination.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD status;
    NWWKSTA_CONTEXT_HANDLE EnumHandle;
    LPNETRESOURCEW NetR = NULL;

    DWORD BytesNeeded = 256;
    DWORD EntriesRead;


    status = NwrOpenEnumConnections(NULL, RESOURCETYPE_ANY, &EnumHandle);
    if ( status != NO_ERROR )
        return;

    //
    // Allocate buffer to get connection list.
    //
    if ((NetR = (LPVOID) LocalAlloc(
                             0,
                             BytesNeeded
                             )) == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        status = NwEnumerateConnections(
                     &((LPNW_ENUM_CONTEXT) EnumHandle)->ResumeId,
                     (DWORD) -1,
                     (LPBYTE) NetR,
                     BytesNeeded,
                     &BytesNeeded,
                     &EntriesRead,
                     CONNTYPE_ANY,
                     NULL
                     );

        if (status == NO_ERROR) {

            DWORD i;
            LPNETRESOURCEW SavePtr = NetR;
            LPWSTR Local;


            for (i = 0; i < EntriesRead; i++, NetR++) {

                Local = NetR->lpLocalName;

                if (NetR->lpLocalName && *(NetR->lpLocalName) == 0) {
                    Local = NULL;
                }

                (void) NwOpenHandleToDeleteConn(
                           NetR->lpRemoteName,
                           Local,
                           TRUE,
                           TRUE,
                           FALSE
                           );
            }

            NetR = SavePtr;

        }
        else if (status == WN_MORE_DATA) {

            //
            // Original buffer was too small.  Free it and allocate
            // the recommended size and then some to get as many
            // entries as possible.
            //

            (void) LocalFree((HLOCAL) NetR);

            BytesNeeded += NW_ENUM_EXTRA_BYTES;

            if ((NetR = (LPVOID) LocalAlloc(
                                     0,
                                     BytesNeeded
                                     )) == NULL) {

                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }
        }
        else {
            // give up if see any other return code
            break ;
        }

    } while (status != WN_NO_MORE_ENTRIES);

CleanExit:
    (void) NwrCloseEnum(&EnumHandle);

    if (NetR != NULL) {
        (void) LocalFree((HLOCAL) NetR);
    }
    (void) NwDeleteAllInRegistry();
}



DWORD
NwCreateSymbolicLink(
    IN  LPWSTR Local,
    IN  LPWSTR TreeConnectStr,
    IN  BOOL   ImpersonatingClient
    )
/*++

Routine Description:

    This function creates a symbolic link object for the specified local
    device name which is linked to the tree connection name that has a
    format of \Device\NwRdr\Device:\Server\Volume\Directory.

Arguments:

    Local - Supplies the local device name.

    TreeConnectStr - Supplies the tree connection name string which is
        the link target of the symbolick link object.

    ImpersonatingClient - Flag that indicates whether the thread has
        called NwImpersonateClient. The gateway service functions don't
        impersonate, where as the client service operations do.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    WCHAR    TempBuf[64];
    LPWSTR   Session = NULL;                       //Terminal Server Addition
    NTSTATUS Status = NO_ERROR;                 
    BOOL     ResetToClient = FALSE;
    DWORD    LocalLength = wcslen(Local);

    Session = NwReturnSessionPath(Local);
    if (Session == 0)
    {
        Status = GetLastError();
        goto Exit;
    }

    if ( (NwLUIDDeviceMapsEnabled == FALSE) && ImpersonatingClient )
    {
        (void) NwRevertToSelf();
        ResetToClient = TRUE;
    }

    if (LocalLength > 2)
    {
        LPWSTR UncName;

        //
        // Local device is LPTn:
        //

        //
        // Check to see if we already have this UNC name mapped.
        //
        if (NwAllocAndGetUncName(
                Local,
                LocalLength,
                &UncName
                ) == NO_ERROR)
        {
            LocalFree((HLOCAL) UncName);
            Status = ERROR_ALREADY_ASSIGNED;
            goto Exit;
        }
    }
    else
    {
        //
        // Local device is X:
        //

        if (! QueryDosDeviceW( Session,
                               TempBuf,
                               sizeof(TempBuf) / sizeof(WCHAR) ))
        {
            if (GetLastError() != ERROR_FILE_NOT_FOUND)
            {
                //
                // Most likely failure occurred because our output
                // buffer is too small.  It still means someone already
                // has an existing symbolic link for this device.
                //
                Status = ERROR_ALREADY_ASSIGNED;
                goto Exit;
            }
        }
        else
        {
            //
            // QueryDosDevice successfully an existing symbolic link--
            // somebody is already using this device.
            //
            Status = ERROR_ALREADY_ASSIGNED;
            goto Exit;
        }
    }

    //
    // Create a symbolic link object to the device we are redirecting
    //
    if (! DefineDosDeviceW(
              DDD_RAW_TARGET_PATH | DDD_NO_BROADCAST_SYSTEM,
              Session,
              TreeConnectStr
              ))
    {
        Status = GetLastError();
        goto Exit;
    }

Exit:

    if ( ResetToClient )
    {
        (void) NwImpersonateClient();
    }

    if (Session)
    {
        LocalFree(Session);
    }
    return Status;
}



VOID
NwDeleteSymbolicLink(
    IN  LPWSTR LocalDeviceName,
    IN  LPWSTR TreeConnectStr,
    IN  LPWSTR SessionDeviceName, //Terminal Server Addition
                                  // This parameter is required because 
                                  // the device created is per session
    IN  BOOL   ImpersonatingClient
    )
/*++

Routine Description:

    This function deletes the symbolic link we had created earlier for
    the device.

Arguments:

    LocalDeviceName - Supplies the local device name string of which the
        symbolic link object is created.

    TreeConnectStr - Supplies a pointer to the Unicode string which
        contains the link target string we want to match and delete.

    ImpersonatingClient - Flag that indicates whether the thread has
        called NwImpersonateClient. The gateway service functions don't
        impersonate, where as the client service operations do.

Return Value:

    None.

--*/
{
    BOOLEAN DeleteSession = FALSE;
    BOOL    ResetToClient = FALSE;

    if (LocalDeviceName != NULL ||
        SessionDeviceName != NULL) {

        if (SessionDeviceName == NULL) {
            SessionDeviceName = NwReturnSessionPath(LocalDeviceName);
            if ( SessionDeviceName == NULL ) return;
            DeleteSession = TRUE;
        }

        if ( (NwLUIDDeviceMapsEnabled == FALSE) && ImpersonatingClient )
        {
            (void) NwRevertToSelf();
            ResetToClient = TRUE;
        }

        if (! DefineDosDeviceW(
                              DDD_REMOVE_DEFINITION  | 
                              DDD_RAW_TARGET_PATH |
                              DDD_EXACT_MATCH_ON_REMOVE | 
                              DDD_NO_BROADCAST_SYSTEM,
                              //                  LocalDeviceName,
                              SessionDeviceName,
                              TreeConnectStr
                              ))
        {
#if DBG
            IF_DEBUG(CONNECT) {
                KdPrint(("NWWORKSTATION: DefineDosDevice DEL of %ws %ws returned %lu\n",
                         LocalDeviceName, TreeConnectStr, GetLastError()));
            }
#endif
        }
#if DBG
        else {
            IF_DEBUG(CONNECT) {
                KdPrint(("NWWORKSTATION: DefineDosDevice DEL of %ws %ws returned successful\n",
                         LocalDeviceName, TreeConnectStr));
            }

        }
#endif

    }

    if ( SessionDeviceName && DeleteSession) {
        LocalFree( SessionDeviceName );
    }

    if ( ResetToClient )
    {
        (void) NwImpersonateClient();
    }
}

DWORD
NwCreateConnection(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD Type,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UserName OPTIONAL
    )
/*++

Routine Description:

    This function creates a tree connection to the specified RemoteName
    (UNC name) and maps it to the LocalName (local device name), if
    it is specified.  The password and user name are the credentials
    used to create the connection, if specified; otherwise, the
    interactive logged on user's credentials are used by default.

    NOTE: This code used to be NwrCreateConnection, except that it used
    to have the ImpersonateClient() call in it. Now this code is here, and
    NwrCreateConnection calls this function and handles the client
    impersonation there. The reason for this is to allow the print spooler
    code to call this helper routine without calling Impersonate client a
    second time, thus reverting the credentials to that of services.exe.

    4/15/99 - GlennC - Assumption is that this routine is currently only
    called while impersonating the client (NwImpersonateClient == TRUE)!!!

Arguments:

    LocalName - Supplies the local device name to map to the created tree
        connection.  Only drive letter device names are accepted.  (No
        LPT or COM).

    RemoteName - Supplies the UNC name of the remote resource in the format
        of Server\Volume\Directory.  It must be a disk resource.

    Type - Supplies the connection type.

    Password - Supplies the password to use to make the connection to the
        server.

    UserName - Supplies the user name to use to make the connection.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating internal work buffers.

    WN_BAD_NETNAME - Remote resource name is invalid.

    WN_BAD_LOCALNAME - Local DOS device name is invalid.

    ERROR_BAD_NETPATH - The UNC name does not exist on the network.

    ERROR_INVALID_PARAMETER - LPT or COM LocalName was specified.

    Other errors from the redirector.

--*/
{
    DWORD status;

    DWORD LocalLength;

    LPWSTR Local = NULL;
    LPWSTR Unc = NULL;
    LPWSTR User = NULL;

    UNICODE_STRING TreeConnectStr;
    UNICODE_STRING EncodedPassword;
    HANDLE TreeConnection;

    TreeConnectStr.Buffer = NULL;

    EncodedPassword.Length = 0;

    //
    // If local device is an empty string, it will be treated as a pointer to
    // NULL.
    //
    if (LocalName != NULL && *LocalName != 0) {

        //
        // Local device name is not NULL, canonicalize it
        //
#if DBG
        IF_DEBUG(CONNECT) {
            KdPrint(("\nNWWORKSTATION: NwCreateConnection: LocalName %ws\n", LocalName));
        }
#endif

        if ((status = NwLibCanonLocalName(
                          LocalName,
                          &Local,     // Must be freed with LocalFree when done.
                          &LocalLength
                          )) != NO_ERROR) {

            return WN_BAD_LOCALNAME;
        }
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwCreateConnection: RemoteName %ws\n", RemoteName));
    }
#endif

    //
    // Canonicalize the remote name, if it is not \\Server.
    //
    status = NwLibCanonRemoteName(
                      Local,
                      RemoteName,
                      &Unc,           // Must be freed with LocalFree when done.
                      NULL
                      );

    if (status != NO_ERROR)
    {
        status = WN_BAD_NETNAME;
        goto CleanExit;
    }

    //
    // Canonicalize user name.
    //
    if (UserName != NULL) {

        //
        // Canonicalize username
        //
#if DBG
        IF_DEBUG(CONNECT) {
            KdPrint(("NWWORKSTATION: NwCreateConnection: UserName %ws\n",
                     UserName));
        }
#endif

        if ((status = NwLibCanonUserName(
                          UserName,
                          &User,     // Must be freed with LocalFree when done.
                          NULL
                          )) != NO_ERROR) {

#ifdef QFE_BUILD
            //
            // if not valid, just ignore the username. this works
            // around MPR bug where if you pass say domain\user to NWRDR
            // as first provider, and he throws it out, then the next one
            // doesnt get a chance.
            //
            // TRACKING - this should be removed when MPR bug #4051 is fixed
            // and all platforms we ship NWRDR have that fix.
            //
            UserName = NULL ;
            status = NO_ERROR;
#else
            status = WN_BAD_VALUE;
            goto CleanExit;
#endif
        }
    }

    //
    // For password any syntax or length is accepted.
    //
    if (Password != NULL) {

#if DBG
        IF_DEBUG(CONNECT) {
            KdPrint(("NWWORKSTATION: NwCreateConnection: Password %ws\n",
                     Password));
        }
#endif
        //
        // Decode the password
        //
        RtlInitUnicodeString(&EncodedPassword, Password);
        RtlRunDecodeUnicodeString(NW_ENCODE_SEED3, &EncodedPassword);
    }

    //
    // Create an NT-style tree connection name
    //
    if ((status = NwCreateTreeConnectName(
                      Unc,
                      Local,
                      &TreeConnectStr
                      )) != NO_ERROR) {
        goto CleanExit;
    }

    if (Local != NULL) {

        //
        // Create symbolic link for local device name.
        //

        if ((status = NwCreateSymbolicLink(
                          Local,
                          TreeConnectStr.Buffer,
                          TRUE          // We are impersonating the client!
                          )) != NO_ERROR)
        {
            goto CleanExit;
        }
    }

    //
    // Create the tree connection while impersonating the client so
    // that redirector can get to caller's logon id.
    //

    status = NwOpenCreateConnection(
                 &TreeConnectStr,
                 User,
                 Password,
                 Unc,
                 SYNCHRONIZE | GENERIC_WRITE,
                 FILE_CREATE,          // Fail if already exist
                 FILE_CREATE_TREE_CONNECTION |
                     FILE_SYNCHRONOUS_IO_NONALERT,
                 Type,
                 &TreeConnection,
                 NULL
                 );

    //
    // If there's a problem creating the tree connection, remove symbolic
    // link if any.
    //
    if (status != NO_ERROR) {

        if ( (status == ERROR_NOT_CONNECTED) ||
             (status == ERROR_FILE_NOT_FOUND) ||
             (status == ERROR_INVALID_NAME) )
        {
            status = ERROR_BAD_NETPATH;
        }

        if ( status == ERROR_CONNECTION_INVALID )
        {
            status = WN_BAD_NETNAME;
        }

        //
        // Delete the symbolic link we created.
        //
        NwDeleteSymbolicLink(
            Local,
            TreeConnectStr.Buffer,
            NULL,
            TRUE          // We are impersonating the client!
            );
    }
    else {

        //
        // Just close the connection handle.
        //
        (void) NtClose(TreeConnection);
    }

CleanExit:
    if (Local != NULL) {
        (void) LocalFree((HLOCAL) Local);
    }

    if (Unc != NULL) {
        (void) LocalFree((HLOCAL) Unc);
    }

    if (User != NULL) {
        (void) LocalFree((HLOCAL) User);
    }

    if (TreeConnectStr.Buffer != NULL) {
        (void) LocalFree((HLOCAL) TreeConnectStr.Buffer);
    }

    //
    // Put the password back the way we found it.
    //
    if (EncodedPassword.Length != 0) {

        UCHAR Seed = NW_ENCODE_SEED3;

        RtlRunEncodeUnicodeString(&Seed, &EncodedPassword);
    }


#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwCreateConnection returns %lu\n", status));
    }
#endif

    return status;
}

//Terminal Server
DWORD
NwDeleteAllInRegistry(
                      VOID
                     )
/*++

Routine Description:

    This function spins through the registry deleting the symbolic
    links and closing all connections for all logons.

    This is neccessary since the the users are not neccessarily in the
    system context.

Arguments:

    none

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    LONG RegError;


    HKEY InteractiveLogonKey;
    DWORD Index = 0;
    WCHAR LogonIdName[NW_MAX_LOGON_ID_LEN];
    LUID LogonId;
    HKEY  OneLogonKey;
    ULONG WinStationId = 0L;
    PULONG pWinId = NULL;


    RegError = RegOpenKeyExW(
                            HKEY_LOCAL_MACHINE,
                            NW_INTERACTIVE_LOGON_REGKEY,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            &InteractiveLogonKey
                            );

    if (RegError == ERROR_SUCCESS) {

        do {

            RegError = RegEnumKeyW(
                                  InteractiveLogonKey,
                                  Index,
                                  LogonIdName,
                                  sizeof(LogonIdName) / sizeof(WCHAR)
                                  );

            if (RegError == ERROR_SUCCESS) {

                //
                // Got a logon id key.
                //

                NwWStrToLuid(LogonIdName, &LogonId);

                //
                // Open the <LogonIdName> key under Logon
                //
                RegError = RegOpenKeyExW(
                                        InteractiveLogonKey,
                                        LogonIdName,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        &OneLogonKey
                                        );

                if ( RegError != ERROR_SUCCESS ) {
                    KdPrint(("NWWORKSTATION: NwDeleteAllInRegistry: RegOpenKeyExW failed, Not interactive Logon: Error %d\n", GetLastError()));
                } else {

                    //
                    // Read the WinStation value.
                    //
                    RegError = NwReadRegValue(
                                             OneLogonKey,
                                             NW_WINSTATION_VALUENAME,
                                             (LPWSTR *) &pWinId
                                             );

                    (void) RegCloseKey(OneLogonKey);

                    if ( RegError != NO_ERROR ) {
                        KdPrint(("NWWORKSTATION: NwDeleteAllInRegistry: Could not read SID from reg %lu\n", RegError));
                        continue;
                    } else {
                        if (pWinId != NULL) {
                            WinStationId = *pWinId;
                            (void) LocalFree((HLOCAL) pWinId);
                        }
                        NwDeleteUidSymLinks( LogonId, WinStationId );
                    }
                }

            } else if (RegError != ERROR_NO_MORE_ITEMS) {
                KdPrint(("NWWORKSTATION: NwDeleteAllInRegistry failed to enum logon IDs RegError=%lu\n",
                         RegError));
            }

            Index++;

        } while (RegError == ERROR_SUCCESS);

        (void) RegCloseKey(InteractiveLogonKey);
    }

    NwCloseAllConnections();  

    return NO_ERROR;
}

DWORD
    NwDeleteUidSymLinks(
                       IN LUID Uid,
                       IN ULONG WinStationId
                       )
/*++

Routine Description:

    This function deletes all symbolic links for a given UID/Winstation.

Arguments:

    None.

Return Value:

    NO_ERROR 

--*/
{
    DWORD status= NO_ERROR;
    NWWKSTA_CONTEXT_HANDLE EnumHandle;
    LPNETRESOURCEW NetR = NULL;

    DWORD BytesNeeded = 256;
    DWORD EntriesRead;
    WCHAR LocalUidCombo[256];
    UNICODE_STRING TreeConnectStr;


    status = NwrOpenEnumConnections(NULL, RESOURCETYPE_ANY, &EnumHandle);
    if ( status != NO_ERROR )
        return status;

    //
    // Allocate buffer to get connection list.
    //
    if ((NetR = (LPVOID) LocalAlloc(
                                   0,
                                   BytesNeeded
                                   )) == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        status = NwEnumerateConnections(
                                       &((LPNW_ENUM_CONTEXT) EnumHandle)->ResumeId,
                                       0xFFFFFFFF,
                                       (LPBYTE) NetR,
                                       BytesNeeded,
                                       &BytesNeeded,
                                       &EntriesRead,
                                       CONNTYPE_ANY | CONNTYPE_UID,
                                       &Uid
                                       );

        if (status == NO_ERROR) {

            DWORD i;
            LPNETRESOURCEW SavePtr = NetR;
            LPWSTR Local;


            for (i = 0; i < EntriesRead; i++, NetR++) {

                Local = NetR->lpLocalName;
                TreeConnectStr.Buffer = NULL;

                if (NetR->lpLocalName && *(NetR->lpLocalName) == 0) {
                    Local = NULL;
                } else if ((status = NwCreateTreeConnectName(
                                                            NetR->lpRemoteName,
                                                            Local,
                                                            &TreeConnectStr
                                                            )) != NO_ERROR) {
                    Local = NULL;
                }

                if ( Local != NULL ) {
                    swprintf(LocalUidCombo, L"%ws:%x", Local, WinStationId);
                    //
                    // Delete the symbolic link we created.
                    //
                    if (! DefineDosDeviceW(
                                          DDD_REMOVE_DEFINITION  |
                                          DDD_RAW_TARGET_PATH |
                                          DDD_EXACT_MATCH_ON_REMOVE |
                                          0x80000000,
                                          LocalUidCombo,
                                          TreeConnectStr.Buffer
                                          )) {

#if DBG
                        IF_DEBUG(CONNECT) {
                            KdPrint(("NWWORKSTATION: DefineDosDevice DEL of %ws %ws returned %lu\n",
                                     LocalUidCombo, TreeConnectStr.Buffer, GetLastError()));
                        }
#endif
                    }
#if DBG
                    else {
                        IF_DEBUG(CONNECT) {
                            KdPrint(("NWWORKSTATION: DefineDosDevice DEL of %ws %ws returned successful\n",
                                     LocalUidCombo, TreeConnectStr.Buffer));
                        }
                    }
#endif
                    if (TreeConnectStr.Buffer != NULL) {
                        (void) LocalFree((HLOCAL) TreeConnectStr.Buffer);
                        TreeConnectStr.Buffer = NULL;
                    }
                }

            }

            NetR = SavePtr;

        } else if (status == WN_MORE_DATA) {

            //
            // Original buffer was too small.  Free it and allocate
            // the recommended size and then some to get as many
            // entries as possible.
            //

            (void) LocalFree((HLOCAL) NetR);

            BytesNeeded += NW_ENUM_EXTRA_BYTES;

            if ((NetR = (LPVOID) LocalAlloc(
                                           0,
                                           BytesNeeded
                                           )) == NULL) {

                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }
        } else {
            // give up if see any other return code
            break ;
        }

    } while (status != WN_NO_MORE_ENTRIES);

    CleanExit:
    (void) NwrCloseEnum(&EnumHandle);

    if (NetR != NULL) {
        (void) LocalFree((HLOCAL) NetR);
    }
    return NO_ERROR;
}
//
// Terminal Server Addition
//

LPTSTR
NwReturnSessionPath(
                    IN  LPTSTR LocalDeviceName
                   )
/*++

Routine Description:

    This function returns the per session path to access the
    specific dos device for multiple session support.


Arguments:

    LocalDeviceName - Supplies the local device name specified by the API
        caller.

Return Value:

    LPTSTR - Pointer to per session path in newly allocated memory
             by LocalAlloc().

--*/
{
    BOOL  rc;
    DWORD SessionId;
    CLIENT_ID ClientId;
    LPTSTR SessionDeviceName = NULL;
    NTSTATUS status;

    if ((status = NwGetSessionId(&SessionId)) != NO_ERROR) {
        return NULL;
    }

    rc = DosPathToSessionPath(
                             SessionId,
                             LocalDeviceName,
                             &SessionDeviceName
                             );

    if ( !rc ) {
        return NULL;
    }

    return SessionDeviceName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\device.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    device.c

Abstract:

    This module contains the support routines for the APIs that call
    into the NetWare redirector

Author:

    Rita Wong       (ritaw)     20-Feb-1991
    Colin Watson    (colinw)    30-Dec-1992

Revision History:

--*/

#include <nw.h>
#include <nwcons.h>
#include <nwxchg.h>
#include <nwapi32.h>
#include <nwstatus.h>
#include <nwmisc.h>
#include <nwcons.h>
#include <nds.h>
#include <svcguid.h>
#include <tdi.h>
#include <nwreg.h>

#define NW_LINKAGE_REGISTRY_PATH  L"NWCWorkstation\\Linkage"
#define NW_BIND_VALUENAME         L"Bind"

#define TWO_KB                  2048
#define EIGHT_KB                8192
#define EXTRA_BYTES              256

#define TREECHAR                L'*'
#define BUFFSIZE                1024

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//


STATIC
NTSTATUS
BindToEachTransport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

DWORD
NwBindTransport(
    IN  LPWSTR TransportName,
    IN  DWORD QualityOfService
    );

DWORD
GetConnectedBinderyServers(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    );

DWORD
GetTreeEntriesFromBindery(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    );

DWORD
NwGetConnectionStatus(
    IN     LPWSTR  pszServerName,
    IN OUT PDWORD_PTR  ResumeKey,
    OUT    LPBYTE  *Buffer,
    OUT    PDWORD  EntriesRead
    );


VOID
GetLuid(
    IN OUT PLUID plogonid
    );

VOID
GetNearestDirServer(
    IN  LPWSTR  TreeName,
    OUT LPDWORD lpdwReplicaAddressSize,
    OUT LPBYTE  lpReplicaAddress
    );

VOID
GetPreferredServerAddress(
    IN  LPWSTR  PreferredServerName,
    OUT LPDWORD lpdwReplicaAddressSize,
    OUT LPBYTE  lpReplicaAddress
    );

BOOL
NwpCompareTreeNames(
    LPWSTR lpServiceInstanceName,
    LPWSTR lpTreeName
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Handle to the Redirector FSD
//
STATIC HANDLE RedirDeviceHandle = NULL;

//
// Redirector name in NT string format
//
STATIC UNICODE_STRING RedirDeviceName;

extern BOOL NwLUIDDeviceMapsEnabled;


DWORD
NwInitializeRedirector(
    VOID
    )
/*++

Routine Description:

    This routine initializes the NetWare redirector FSD.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD error;
    NWR_REQUEST_PACKET Rrp;


    //
    // Initialize global handles
    //
    RedirDeviceHandle = NULL;

    //
    // Initialize the global NT-style redirector device name string.
    //
    RtlInitUnicodeString(&RedirDeviceName, DD_NWFS_DEVICE_NAME_U);

    //
    // Load driver
    //
    /* error = NwLoadOrUnloadDriver(TRUE);
    // JimTh - 3/5/02 - Driver loading turned over to SCM via service dependency on NwRdr

    if (error != NO_ERROR && error != ERROR_SERVICE_ALREADY_RUNNING) {
        return error;
    }
    */

    if ((error = NwOpenRedirector()) != NO_ERROR) {

        //
        // Unload the redirector driver
        //
        // (void) NwLoadOrUnloadDriver(FALSE);
        // JimTh - 3/5/02 - Driver loading turned over to SCM
        return error;
    }

    //
    // Send the start FSCTL to the redirector
    //
    Rrp.Version = REQUEST_PACKET_VERSION;

    return NwRedirFsControl(
                RedirDeviceHandle,
                FSCTL_NWR_START,
                &Rrp,
                sizeof(NWR_REQUEST_PACKET),
                NULL,
                0,
                NULL
                );
}



DWORD
NwOpenRedirector(
    VOID
    )
/*++

Routine Description:

    This routine opens the NT NetWare redirector FSD.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    return RtlNtStatusToDosError(
               NwOpenHandle(&RedirDeviceName, FALSE, &RedirDeviceHandle)
               );
}



DWORD
NwShutdownRedirector(
    VOID
    )
/*++

Routine Description:

    This routine stops the NetWare Redirector FSD and unloads it if
    possible.

Arguments:

    None.

Return Value:

    NO_ERROR or ERROR_REDIRECTOR_HAS_OPEN_HANDLES

--*/
{
    NWR_REQUEST_PACKET Rrp;
    DWORD error;


    Rrp.Version = REQUEST_PACKET_VERSION;

    error = NwRedirFsControl(
                RedirDeviceHandle,
                FSCTL_NWR_STOP,
                &Rrp,
                sizeof(NWR_REQUEST_PACKET),
                NULL,
                0,
                NULL
                );

    (void) NtClose(RedirDeviceHandle);

    RedirDeviceHandle = NULL;

    if (error != ERROR_REDIRECTOR_HAS_OPEN_HANDLES) {

        //
        // Unload the redirector only if all its open handles are closed.
        //
        // (void) NwLoadOrUnloadDriver(FALSE);
        // JimTh - 3/5/02 - Driver loading turned over to SCM
    }

    return error;
}


/*
// JimTh - 3/5/02 - Driver loading turned over to SCM via service dependency on NwRdr
DWORD
NwLoadOrUnloadDriver(
    BOOL Load
    )
/*++

Routine Description:

    This routine loads or unloads the NetWare redirector driver.

Arguments:

    Load - Supplies the flag which if TRUE load the driver; otherwise
        unloads the driver.

Return Value:

    NO_ERROR or reason for failure.

--* / 
{

    LPWSTR DriverRegistryName;
    UNICODE_STRING DriverRegistryString;
    NTSTATUS ntstatus;
    BOOLEAN WasEnabled;


    DriverRegistryName = (LPWSTR) LocalAlloc(
                                      LMEM_FIXED,
                                      (UINT) (sizeof(SERVICE_REGISTRY_KEY) +
                                              (wcslen(NW_DRIVER_NAME) *
                                               sizeof(WCHAR)))
                                      );

    if (DriverRegistryName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ntstatus = RtlAdjustPrivilege(
                   SE_LOAD_DRIVER_PRIVILEGE,
                   TRUE,
                   FALSE,
                   &WasEnabled
                   );

    if (! NT_SUCCESS(ntstatus)) {
        (void) LocalFree(DriverRegistryName);
        return RtlNtStatusToDosError(ntstatus);
    }

    wcscpy(DriverRegistryName, SERVICE_REGISTRY_KEY);
    wcscat(DriverRegistryName, NW_DRIVER_NAME);

    RtlInitUnicodeString(&DriverRegistryString, DriverRegistryName);

    if (Load) {
        ntstatus = NtLoadDriver(&DriverRegistryString);
    }
    else {
        ntstatus = NtUnloadDriver(&DriverRegistryString);
    }

    (void) RtlAdjustPrivilege(
               SE_LOAD_DRIVER_PRIVILEGE,
               WasEnabled,
               FALSE,
               &WasEnabled
               );

    (void) LocalFree(DriverRegistryName);

    if (Load) {
        if (ntstatus != STATUS_SUCCESS && ntstatus != STATUS_IMAGE_ALREADY_LOADED) {
            LPWSTR SubString[1];

            KdPrint(("NWWORKSTATION: NtLoadDriver returned %08lx\n", ntstatus));

            SubString[0] = NW_DRIVER_NAME;

            NwLogEvent(
                EVENT_NWWKSTA_CANT_CREATE_REDIRECTOR,
                1,
                SubString,
                ntstatus
                );
        }
    }

    if (ntstatus == STATUS_OBJECT_NAME_NOT_FOUND) {
        return ERROR_FILE_NOT_FOUND;
    }

    return NwMapStatus(ntstatus);
}
*/


DWORD
NwRedirFsControl(
    IN  HANDLE FileHandle,
    IN  ULONG RedirControlCode,
    IN  PNWR_REQUEST_PACKET Rrp,
    IN  ULONG RrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

Arguments:

    FileHandle - Supplies a handle to the file or device on which the service
        is being performed.

    RedirControlCode - Supplies the NtFsControlFile function code given to
        the redirector.

    Rrp - Supplies the redirector request packet.

    RrpLength - Supplies the length of the redirector request packet.

    SecondBuffer - Supplies the second buffer in call to NtFsControlFile.

    SecondBufferLength - Supplies the length of the second buffer.

    Information - Returns the information field of the I/O status block.

Return Value:

    NO_ERROR or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    if (FileHandle == NULL)
        return ERROR_INVALID_PARAMETER;


    //
    // Send the request to the Redirector FSD.
    //
    ntstatus = NtFsControlFile(
                   FileHandle,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   RedirControlCode,
                   (PVOID) Rrp,
                   RrpLength,
                   SecondBuffer,
                   SecondBufferLength
                   );

    if (ntstatus == STATUS_SUCCESS) {
        ntstatus = IoStatusBlock.Status;
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = (ULONG) IoStatusBlock.Information;
    }

#if DBG
    if (ntstatus != STATUS_SUCCESS) {
        IF_DEBUG(DEVICE) {
            KdPrint(("NWWORKSTATION: fsctl to redir returns %08lx\n", ntstatus));
        }
    }
#endif

    return NwMapStatus(ntstatus);
}


DWORD
NwBindToTransports(
    VOID
    )

/*++

Routine Description:

    This routine binds to every transport specified under the linkage
    key of the NetWare Workstation service.

Arguments:

    None.

Return Value:

    NET_API_STATUS - success/failure of the operation.

--*/

{
    NTSTATUS ntstatus;
    PRTL_QUERY_REGISTRY_TABLE QueryTable;
    ULONG NumberOfBindings = 0;


    //
    // Ask the RTL to call us back for each subvalue in the MULTI_SZ
    // value \NWCWorkstation\Linkage\Bind.
    //

    if ((QueryTable = (PVOID) LocalAlloc(
                                  LMEM_ZEROINIT,
                                  sizeof(RTL_QUERY_REGISTRY_TABLE) * 2
                                  )) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    QueryTable[0].QueryRoutine = (PRTL_QUERY_REGISTRY_ROUTINE) BindToEachTransport;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = NW_BIND_VALUENAME;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntstatus = RtlQueryRegistryValues(
                   RTL_REGISTRY_SERVICES,
                   NW_LINKAGE_REGISTRY_PATH,
                   QueryTable,
                   &NumberOfBindings,
                   NULL
                   );

    (void) LocalFree((HLOCAL) QueryTable);

    //
    // If failed to bind to any transports, the workstation will
    // not start.
    //

    if (! NT_SUCCESS(ntstatus)) {
#if DBG
        IF_DEBUG(INIT) {
            KdPrint(("NwBindToTransports: RtlQueryRegistryValues failed: "
                      "%lx\n", ntstatus));
        }
#endif
        return RtlNtStatusToDosError(ntstatus);
    }

    if (NumberOfBindings == 0) {

#if 0
    //
    // tommye - MS  24187 / MCS 255 
    //

    //
    // We don't want to log an event unnecessarily and panic the user that
    // G/CSNW could not bind. This could have been caused by the user unbinding
    // G/CSNW and rebooting.
    //

        NwLogEvent(
            EVENT_NWWKSTA_NO_TRANSPORTS,
            0,
            NULL,
            NO_ERROR
            );
#endif

        KdPrint(("NWWORKSTATION: NwBindToTransports: could not bind "
                 "to any transport\n"));

        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}


STATIC
NTSTATUS
BindToEachTransport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    DWORD error;
    LPDWORD NumberOfBindings = Context;
    LPWSTR SubStrings[2];
    static DWORD QualityOfService = 65536;


    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueLength);
    UNREFERENCED_PARAMETER(EntryContext);

    //
    // The value type must be REG_SZ (translated from REG_MULTI_SZ by
    // the RTL).
    //
    if (ValueType != REG_SZ) {

        SubStrings[0] = ValueName;
        SubStrings[1] = NW_LINKAGE_REGISTRY_PATH;

        NwLogEvent(
            EVENT_NWWKSTA_INVALID_REGISTRY_VALUE,
            2,
            SubStrings,
            NO_ERROR
            );

            KdPrint(("NWWORKSTATION: Skipping invalid value %ws\n", ValueName));

        return STATUS_SUCCESS;
    }

    //
    // The value data is the name of the transport device object.
    //

    //
    // Bind to the transport.
    //

#if DBG
    IF_DEBUG(INIT) {
        KdPrint(("NWWORKSTATION: Binding to transport %ws with QOS %lu\n",
                ValueData, QualityOfService));
    }
#endif

    error = NwBindTransport(ValueData, QualityOfService--);

    if (error != NO_ERROR) {

        //
        // If failed to bind to one transport, don't fail starting yet.
        // Try other transports.
        //
        SubStrings[0] = ValueData;

        NwLogEvent(
            EVENT_NWWKSTA_CANT_BIND_TO_TRANSPORT,
            1,
            SubStrings,
            error
            );
    }
    else {
        (*NumberOfBindings)++;
    }

    return STATUS_SUCCESS;
}


DWORD
NwBindTransport(
    IN  LPWSTR TransportName,
    IN  DWORD QualityOfService
    )
/*++

Routine D