set);

	return pIndex[dwIndex];
}

// HanjaToHangul
// 
// lookup Hanja reading
//
// Parameters:
//  pLexMap      -> (MAPFILE*) ptr to lexicon map struct
//
// Result:
//  (NULL if error, otherwise matched Hangul)
//
// 02FEB2000  bhshin  began
WCHAR HanjaToHangul(MAPFILE *pLexMap, WCHAR wchHanja)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	DWORD dwOffset;
	int nIndex;
	WCHAR *pwchReading;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	dwOffset = pLexHeader->rgnReading;

	nIndex = LookupHanjaIndex(pLexMap, wchHanja);
	if (nIndex == -1)
	{
		return NULL; // not found;
	}

	pwchReading = (WCHAR*)(pLex + dwOffset);

	return pwchReading[nIndex];
}

// LookupHangulOfHanja
// 
// lookup hangul of input hanja string 
//
// Parameters:
//  pLexMap      -> (MAPFILE*) ptr to lexicon map struct
//  lpcwszHanja  -> (LPCWSTR) input hanja string
//  cchHanja     -> (int) length of input hanja
//  wzHangul     -> (LPWSTR) output hangul string
//  cchHangul    -> (int) output buffer size
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 02FEB2000  bhshin  began
BOOL LookupHangulOfHanja(MAPFILE *pLexMap, LPCWSTR lpcwszHanja, int cchHanja,
						 LPWSTR wzHangul, int cchHangul)
{
	WCHAR wchHangul;
	
	if (cchHangul < cchHanja)
		return FALSE; // output buffer is too small

	for (int i = 0; i < cchHanja; i++)
	{
		wchHangul = HanjaToHangul(pLexMap, lpcwszHanja[i]);

		if (wchHangul == NULL)
			return FALSE; // unknown hanja included

		wzHangul[i] = wchHangul;
	}
	wzHangul[i] = L'\0';
	
	return TRUE;
}

// LookupMeaning
// 
// lookup hanja meaning
//
// Parameters:
//  pLexMap        -> (MAPFILE*) ptr to lexicon map struct
//  wchHanja       -> (WCHAR) input hanja
//  wzMean         -> (WCHAR*) output meaning buffer
//  cchMean        -> (int) output meaning buffer size
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 09FEB2000  bhshin  began
BOOL LookupMeaning(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *wzMean, int cchMean)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	int nIndex;
	TRIECTRL *lpTrieCtrl;
	BOOL fFound;
	unsigned short *pidxMean;
	int idxMean;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	nIndex = LookupHanjaIndex(pLexMap, wchHanja);
	if (nIndex == -1)
	{
		return FALSE; // not found;
	}

	// meaning
	pidxMean = (unsigned short*)(pLex + pLexHeader->rgnMeanIdx);
	idxMean = pidxMean[nIndex];

	lpTrieCtrl = TrieInit(pLex + pLexHeader->rgnMeaning);
	if (lpTrieCtrl == NULL)
		return FALSE;

	fFound = TrieIndexToWord(lpTrieCtrl, idxMean, wzMean, cchMean);
	if (!fFound)
	{
		wzMean[0] = L'\0';
	}

	TrieFree(lpTrieCtrl);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\ihjdict.h ===
/****************************************************************************
   IHJDict.h : Declaration of the CHJDict

   Copyright 2000 Microsoft Corp.

   History:
      02-AUG-2000 bhshin  remove unused method for Hand Writing team
	  17-MAY-2000 bhshin  remove unused method for CICERO
	  02-FEB-2000 bhshin  created
****************************************************************************/

#ifndef __HJDICT_H_
#define __HJDICT_H_

#include "resource.h"       // main symbols
#include "Lex.h"

/////////////////////////////////////////////////////////////////////////////
// CHJDict
class ATL_NO_VTABLE CHJDict : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CHJDict, &CLSID_HJDict>,
	public IHJDict
{
public:
	CHJDict()
	{
		m_fLexOpen = FALSE;
	}

	~CHJDict();

DECLARE_REGISTRY_RESOURCEID(IDR_HJDICT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHJDict)
	COM_INTERFACE_ENTRY(IHJDict)
END_COM_MAP()

// IHJDict
public:
	STDMETHOD(Init)();
	STDMETHOD(LookupMeaning)(/*[in]*/ WCHAR wchHanja, /*[out]*/ LPWSTR pwszMeaning, /*[in]*/ int cchMeaning);
	STDMETHOD(LookupHangulOfHanja)(/*[in]*/ LPCWSTR pwszHanja, /*[out]*/ LPWSTR pwszHangul, /*[in]*/ int cchHangul);

// Member Data
protected:
	BOOL m_fLexOpen;  // main dict open flag
	MAPFILE m_LexMap; // lexicon handle
};

#endif //__HJDICT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\ihjdict.cpp ===
/****************************************************************************
   IHJDict.cpp : Implementation of CHJDict

   Copyright 2000 Microsoft Corp.

   History:
      02-AUG-2000 bhshin  remove unused method for Hand Writing team
	  17-MAY-2000 bhshin  remove unused method for CICERO
	  02-FEB-2000 bhshin  created
****************************************************************************/
#include "private.h"
#include "HjDict.h"
#include "IHJDict.h"
#include "Lookup.h"
#include "..\inc\common.h"

// maximum output buffer size
#define	MAX_OUT_BUFFER		512
#define SZLEX_FILENAME		"hanja.lex"

/////////////////////////////////////////////////////////////////////////////
// CHJDict

// CHJDict::~CHjDict
// 
// load main lexicon
//
// Parameters:
//  lpcszPath -> (LPCSTR) lexicon path
//
// Result:
//  (HRESULT)
//
// 02AUG2000  bhshin  began
CHJDict::~CHJDict()
{
	if (m_fLexOpen)
		CloseLexicon(&m_LexMap);
}


// CHJDict::Init
// 
// load main lexicon
//
// Parameters:
//  lpcszPath -> (LPCSTR) lexicon path
//
// Result:
//  (HRESULT)
//
// 02FEB2000  bhshin  began
STDMETHODIMP CHJDict::Init()
{
    CHAR  szLexPath[MAX_PATH], szLexPathExpanded[MAX_PATH]		;
    HKEY  hKey;
    DWORD dwCb, dwType;

    if (m_fLexOpen)
    {
        CloseLexicon(&m_LexMap);
        m_fLexOpen = FALSE;
    }

    // default value
    StringCchCopy(szLexPath, MAX_PATH, "%WINDIR%\\IME\\IMKR6_1\\Dicts\\");
       
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szIMEDirectoriesKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwCb = sizeof(szLexPath);
        dwType = REG_EXPAND_SZ;

        RegQueryValueEx(hKey, g_szDicPath, NULL, &dwType, (LPBYTE)szLexPath, &dwCb);
        RegCloseKey(hKey);
    }

    ExpandEnvironmentStrings(szLexPath, szLexPathExpanded, sizeof(szLexPathExpanded));
    if (szLexPathExpanded[lstrlen(szLexPathExpanded)-1] != '\\')
        StringCchCat(szLexPathExpanded, MAX_PATH, "\\");
    StringCchCat(szLexPathExpanded, MAX_PATH, SZLEX_FILENAME);

    if (!OpenLexicon(szLexPathExpanded, &m_LexMap))
        return E_FAIL;

    m_fLexOpen = TRUE;

    return S_OK;
}

// CHJDict::LookupHangulOfHanja
// 
// lookup hangul of input hanja string 
//
// Parameters:
//  pwszHanja    -> (LPCWSTR) input hanja string
//  pwszHangul  -> (WCHAR *) output hangul string
//  cchHangul    -> (int) output buffer size
//
// Result:
//  (HRESULT)
//
// 02FEB2000  bhshin  began
STDMETHODIMP CHJDict::LookupHangulOfHanja(LPCWSTR pwszHanja, 
										  WCHAR *pwszHangul,
										  int cchHangul)
{
	int cchHanja;
	BOOL fLookup;
	
	cchHanja = wcslen(pwszHanja);
	if (cchHanja == 0)
		return E_FAIL;

	// output buffer insufficient
	if (cchHangul < cchHanja)
		return E_FAIL;

	fLookup = ::LookupHangulOfHanja(&m_LexMap, pwszHanja, cchHanja, pwszHangul, cchHangul);
	if (!fLookup)
		return E_FAIL; // it shoud be found

	return S_OK;
}

// CHJDict::LookupMeaning
// 
// lookup hanja meaning
//
// Parameters:
//  wchHanja    -> (WCHAR) input hanja unicode
//  pwszMeaning -> (LPWSTR) output meaning
//  cchMeaning  -> (int) output buffer size
//
// Result:
//  (HRESULT)
//
// 09FEB2000  bhshin  began
STDMETHODIMP CHJDict::LookupMeaning(WCHAR wchHanja, LPWSTR pwszMeaning, int cchMeaning)
{
	BOOL fLookup;

	fLookup = ::LookupMeaning(&m_LexMap, (WCHAR)wchHanja, pwszMeaning, cchMeaning);
	if (!fLookup)
		return E_FAIL;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\lex.cpp ===
/****************************************************************************
   Lex.cpp : lexicon management functions

   Copyright 2000 Microsoft Corp.

   History:
      17-MAY-2000 bhshin  changed signature for CICERO
	  02-FEB-2000 bhshin  created
****************************************************************************/

#include "private.h"
#include "Lex.h"

// OpenLexicon
// 
// map the lexicon file into memory
//
// Parameters:
//  lpcszLexPath -> (LPCSTR) lexicon path
//  pLexMap      -> (MAPFILE*) ptr to lexicon map struct
//
// Result:
//  (TRUE if success, FALSE if failure)
//
// 02FEB2000  bhshin  began
BOOL OpenLexicon(LPCSTR lpcszLexPath, MAPFILE *pLexMap)
{
    char *pData;
    unsigned short nVersion;

    pLexMap->hFile = NULL;
    pLexMap->hFileMapping = NULL;
    pLexMap->pvData = NULL;

    // open the file for reading
    pLexMap->hFile = CreateFile(lpcszLexPath, GENERIC_READ, FILE_SHARE_READ, NULL,
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (pLexMap->hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    // create a file mapping
    pLexMap->hFileMapping = CreateFileMappingA(pLexMap->hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (pLexMap->hFileMapping == NULL)
        return FALSE;

    // map the entire file for reading
    pLexMap->pvData = MapViewOfFileEx(pLexMap->hFileMapping, FILE_MAP_READ, 0, 0, 0, 0);
    if (pLexMap->pvData == NULL)
        return FALSE;

    // check the version # in the first 2 bytes (swap bytes)
    pData = (char*)pLexMap->pvData;
    nVersion = pData[0];
    nVersion |= (pData[1] << 8);
    if (nVersion < LEX_VERSION)
    {
        return FALSE;
    }

	// check the magic signature
	if (strcmp(pData+2, "HJKO") != 0)
	{
		return FALSE;
	}

    return TRUE;
}

// CloseLexicon
// 
// unmap the lexicon file into memory
//
// Parameters:
//  pLexMap  -> (MAPFILE*) ptr to lexicon map struct
//
// Result:
//  (void)
//
// 02FEB2000  bhshin  began
void CloseLexicon(MAPFILE *pLexMap)
{
    if (pLexMap->pvData != NULL)
        UnmapViewOfFile(pLexMap->pvData);

    if (pLexMap->hFileMapping != NULL)
        CloseHandle(pLexMap->hFileMapping);
    
	if (pLexMap->hFile != NULL)
        CloseHandle(pLexMap->hFile);

    pLexMap->hFile = NULL;
    pLexMap->hFileMapping = NULL;
    pLexMap->pvData = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\lex.h ===
/****************************************************************************
   Lex.h : lexicon structure and declaration of lexicon management functions

   Copyright 2000 Microsoft Corp.

   History:
      02-AUG-2000 bhshin  remove unused dict for Hand Writing team
	  17-MAY-2000 bhshin  remove unused dict for CICERO
	  02-FEB-2000 bhshin  created
****************************************************************************/

#ifndef _LEX_HEADER
#define _LEX_HEADER

// current lexicon version
#define LEX_VERSION 0x0040

// Lexicon Header Structure
// ========================
typedef struct {
	unsigned short nVersion;
	char szMagic[4];
	unsigned short nPadding;
	unsigned long rgnHanjaIdx;			// offset to hanja index (needed for just K1 lex)
    unsigned long rgnReading;			// offset to Hanja Reading
    unsigned long rgnMeanIdx;			// offset to meaning index
	unsigned long rgnMeaning;			// offset to meaning trie
} LEXICON_HEADER;

// MapFile structure
// =================
typedef struct {
    HANDLE hFile;
    HANDLE hFileMapping;
    void *pvData;
} MAPFILE, *pMAPFILE;

// Lexicon Open/Close functions
// ============================
BOOL OpenLexicon(LPCSTR lpcszLexPath, MAPFILE *pLexMap);
void CloseLexicon(MAPFILE *pLexMap);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\memmgr.h ===
// memmgr.h
//
// This file contains declarations and macros for memory management.  
// Implementation details may change so beware of relying on internal details.


#ifndef __INCLUDE_MEMMGR
#define __INCLUDE_MEMMGR

#ifdef __cplusplus
extern "C" 
{
#endif

void *ExternAlloc(DWORD cb);
void *ExternRealloc(void *pv, DWORD cb);
void  ExternFree(void *pv);

char *Externstrdup( const char *strSource );

#ifdef DEBUG
extern int cAllocMem;     // Amount of memory alloced
extern int cAlloc;        // Count of allocs outstanding
extern int cAllocMaxMem;  // Max amount of memory ever alloced.
#endif

#ifdef __cplusplus
};
#endif

#endif //__INCLUDE_MEMMGR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\memmgr.cpp ===
// memmgr.c
//
// This file contains definitions for the memory management.
// Implementation details may change so beware of relying on internal details.
//

#include "private.h"
#include "memmgr.h"

#ifdef DEBUG
int cAllocMem = 0;     // Amount of memory alloced
int cAlloc = 0;        // Count of allocs outstanding
int cAllocMaxMem = 0;  // Max amount of memory ever alloced.
#endif

#ifdef  DEBUG
int	gFailure = 0;
#endif

/******************************Public*Routine******************************\
* ExternAlloc
*
* This guy keeps the size in the first long so we can fake a realloc.  Lot's
* of debug checking for heap overwrites.
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void *ExternAlloc(DWORD cb)
{
    long   *pl;
	DWORD	cbAlloc;

#ifdef  DEBUG
#ifndef WINCE
    //
    // If gFailure is 0 nothing happens, if it's non-zero we
    // fail 1 in gFailure allocations.
    //

    if (gFailure)
    {
        if (((rand() * gFailure) / (RAND_MAX + 1)) == 0)
        {
            return (void *) NULL;
        }
    }
#endif
#endif

// Since we can't use realloc on WINCE, we need to save the original size for memcpy
// in our own realloc function.

	cbAlloc = cb + 4;

#ifdef DEBUG
    cbAlloc +=  3;	// round it up to DWORD boundary
    cbAlloc &= ~3;
    cbAlloc +=  8;	// write size at begining and overwrite detector at begining and end
#endif

	pl = (long *) malloc(cbAlloc);
	if (pl == (long *) NULL)
		return pl;

// Stamp this baby full of invalid bytes so code that relies on 0's in it are sniffed out.

#ifdef DEBUG
	memset(pl,0xff,cbAlloc);
#endif

// OK, tuck the object size away at the begining

  *(pl++) = cb;

#ifdef DEBUG
  *(pl++) = 0xDEADBEEF;
    pl[(cbAlloc / 4) - 3] = 0xDEADBEEF;
    cAlloc++;
    cAllocMem += cb;

    if (cAllocMem > cAllocMaxMem)
    {
        TCHAR szDebug[128];
        cAllocMaxMem = cAllocMem;
        wsprintf(szDebug, TEXT("cAllocMaxMem = %d \r\n"), cAllocMaxMem);
        OutputDebugString(szDebug);
    }
#endif

    return pl;
}

/******************************Public*Routine******************************\
* ExternRealloc
*
* Well this not good but we want the same exact code on NT and WINCE and
* we can't find a way to use the flags and have Realloc work the same on
* both.  Realloc is a very infrequent event so this work for us.
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void *ExternRealloc(void *pv, DWORD cbNew)
{
    void   *pvNew = ExternAlloc(cbNew);

    if (pv && pvNew)
    {
        long   *pl;
        DWORD	cb;

        pl = (long *) pv;

#ifdef	DEBUG
		pl--;
#endif

        cb = (DWORD) *(--pl);
		memcpy(pvNew, pv, min(cbNew, cb));
        ExternFree(pv);
    }

	return pvNew;
}

/******************************Public*Routine******************************\
* ExternFree
*
* Free up the memory, in debug mode check for heap corruption !
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void ExternFree(void *pv)
{
    long   *pl;

// We now allow freeing of null pointers

	if (pv == (void *) NULL)
		return;

    pl = (long *) pv;
    pl--;

#ifdef DEBUG
{
    int		cbAlloc;

// Check nothing has been stepped on.

    pl--;
    cbAlloc = *pl;
    cAllocMem -= cbAlloc;
    cbAlloc = (cbAlloc + 11) & ~3;
    cAlloc--;
}
#endif

	free(pl);
}

char *Externstrdup( const char *strSource )
{
	int		nLen = 0;
	char*	pszOut = NULL;

	// fail immediately on a null pointer
	if (NULL == strSource)
		return NULL;

	// get the length of the ansi string 
	nLen = strlen(strSource) * sizeof(char);

	// fail on a 0 length string 
	//  @todo(petewil) - is this right, or return 0 length string instead?
	if (0 == nLen)
		return NULL;

	// allow room for a trailing null
	nLen += sizeof(char);

	// allocate space for the string
	pszOut = (char*)ExternAlloc(nLen);

	if (NULL == pszOut)
		return NULL;

	// copy the string into the buffer provided
       StringCchCopyA(pszOut, nLen, strSource);
    return pszOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imkrinst\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "IMKRINST"
#define SZ_MODULE       "IMKRINST"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for simx project.
//
//----------------------------------------------------------------------------


#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _OLEAUT32_

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HjDict.rc
//
#define IDS_PROJNAME                    100
#define IDR_HJDICT                      101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\trie.h ===
#ifndef TRIE_H
#define TRIE_H

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; lpbNode points to the first byte of the next node in this state, and
lpbDown points to the first byte referenced by the down pointer, if any */

typedef struct tagTAGDATA
{
	DWORD	cTag;			// Count of tagged nodes below this node in the subtree
	DWORD	dwData;			// Stored tagged data for this node
} TAGDATA;

#define MAXTAGS 8
#if MAXTAGS > 8
#error No more than 8 tags are allowed
#endif

typedef struct tagTRIESCAN
{
	WCHAR	wch;			// Unicode character
	WORD	wFlags;			// see below
	WORD	wMask;			// which tags are valid
	WORD	__pad0;			// 
	DWORD	cWords;			// Words in subtree (only valid if TRIE_NODE_COUNT is set)
	DWORD	cSkipWords;		// Words in subtrees ignored when following a skip pointer
	LPBYTE	lpbNode;		// Address of next byte within the compressed trie
	LPBYTE	lpbDown;		// Address referenced by down pointer, if any
	LPBYTE	lpbRight;		// Address referenced by right pointer, if any
	LPBYTE	lpbSRDown;		// Last single-ref address referenced
	TAGDATA	aTags[MAXTAGS];	// The list of tag counts/data
} TRIESCAN, *PTRIESCAN, *LPTRIESCAN;

// Trie node flags, only the lower 16 bits of the flags are saved in the trie

#define TRIE_NODE_VALID         0x00000001      // wch is the last letter of a valid word
#define TRIE_NODE_END           0x00000002      // Last node in the state (no more alternatives to wch)
#define TRIE_NODE_COUNT         0x00000004		// The count of words in the subtree is stored in the node
#define TRIE_NODE_TAGGED        0x00000008      // The node has tagged data
#define TRIE_NODE_DOWN          0x00000010      // iDown is valid (word so far is a valid prefix)
#define TRIE_NODE_RIGHT         0x00000020      // iRight is valid (word connects to a substate)
#define TRIE_DOWN_INLINE        0x00000040      // iDown omitted, since it points to next node in memory
#define TRIE_DOWN_MULTI         0x00000080      // iDown is a second reference or worse
#define TRIE_DOWN_ABS           0x00000100		// iDown is an absolute immediate offset into the trie
#define	TRIE_NODE_SKIP			0x00000200		// Either iRight is a skip pointer or EOS is a 'soft' EOS
#define	TRIE_NODE_SKIP_COUNT	0x00000400		// cSkipWords is valid

/* Macro to access the data in the node, works for dawgs and tries */

#define DAWGDATA(pdawg)       ((pdawg)->wch)
#define DAWGDOWNFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_DOWN)
#define DAWGENDFLAG(pdawg)    ((pdawg)->wFlags & TRIE_NODE_END)
#define DAWGWORDFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_VALID)

/* Fixed-length part of the compressed trie header */

typedef struct tagTRIESTATS
{
	WORD	version;						// Version of this particular compressed trie
	WORD	__pad0;							//
	BYTE	wTagsMask;						// Which tags are in use
	BYTE	wEnumMask;						// Which tags have enumeration
	BYTE	wDataMask;						// Which tags have stored data
	BYTE	cTagFields;						// Total tags in use
	WORD	cMaxWord;						// Number of characters in longest word
	WORD	cMaxState;						// Number of nodes in longest state (max alternatives)
	WORD	cCharFlagsCodesMax;             // Bytes in longest char/flags code
	WORD	cTagsCodesMax;                  // Bytes in longest tagged data code
	WORD	cMRPointersCodesMax;			// Bytes in longest MR pointer code
	WORD	cSROffsetsCodesMax;             // Bytes in longest Single-ref code
	DWORD	cWords;							// Number of words in dictionary
	DWORD	cUniqueSROffsets;               // Unique offsets in Single-ref segment
	DWORD	cUniqueCharFlags;               // Unique char/flags pairs
	DWORD	cUniqueTags;                    // Unique tagged data values
	DWORD	cUniqueMRPointers;              // Unique multi-ref pointers
	DWORD	cbHeader;						// Bytes in header & tables
	DWORD	cbTrie;							// Bytes in trie
} TRIESTATS, *PTRIESTATS, *LPTRIESTATS;

/* Primary unit of a node.  Nodes usually contain a pointer too */

typedef struct tagCHARFLAGS {
        wchar_t wch;
        short wFlags;
} CHARFLAGS, *PCHARFLAGS, *LPCHARFLAGS;

/* Control structure used to decompress the trie */

typedef struct tagTRIECTRL
{
	TRIESTATS  *lpTrieStats;				// Pointer to base of header segment
	WORD       *lpwCharFlagsCodes;			// decoding table for Char/flags
	WORD       *lpwTagsCodes;				// decoding table for tagged data
	WORD       *lpwMRPointersCodes;			// decoding table for multiref pointers
	WORD       *lpwSROffsetsCodes;			// decoding table for singleref offsets
	CHARFLAGS  *lpCharFlags;				// table to convert codes to char/flags
	DWORD      *lpwTags;					// table to convert codes to tagged data
	DWORD      *lpwMRPointers;				// table to convert codes to multiref pointers
	DWORD      *lpwSROffsets;				// table to convert codes to Singleref offsets
	BYTE       *lpbTrie;					// Pointer to the trie.
} TRIECTRL, *PTRIECTRL, *LPTRIECTRL;

/* Useful Constants */

#define TRIE_MAX_DEPTH          128     // We'll fail on any words longer than this

// The prototypes below are plain C     (this is required for use with C++)

/* Given a pointer to a mapped file or resource containing a compressed trie,
read the trie into memory, making all the allocations required */

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte);

/* Free all the allocations associated with a trie */

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl);

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI
TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

BOOL WINAPI
TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch);

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI
TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguisha valid word from a valid prefix, caller must test
wFlags for fTrieNodeValid. */

BOOL WINAPI
TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t * lpwszWord);

int WINAPI
TrieWordToIndex(
        TRIECTRL   *ptc,                // Trie in which to find word index
        wchar_t    *pwszWord            // Word for which we're looking
);

BOOL WINAPI
TrieIndexToWord(
        TRIECTRL   *ptc,                // Trie in which to find indexed word
        DWORD       nIndex,             // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int         cwc                 // Max characters in buffer (including NULL)
);

int WINAPI
TrieWordToTagIndex(
        TRIECTRL   *ptc,                // Trie in which to find word index
        wchar_t    *pwszWord,           // Word for which we're looking
        int         tag                 // Which tag to enumerate
);

BOOL WINAPI
TrieTagIndexToWord(
        TRIECTRL   *ptc,                // Trie in which to find indexed word
        DWORD       nIndex,             // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int         cwc,                // Max characters in buffer (including NULL)
        int         tag                 // Which tag to enumerate
);

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                // Returned values
        BYTE       *pbValid             // Mask for valid return values
);

int WINAPI
TriePrefixToRange(
        TRIECTRL   *ptc,                // Trie in which to find prefix range
        wchar_t    *pwszWord,           // Prefix for which we're looking
        int                *piStart     // Start of range with this prefix
);

/**** Subroutines for traversing Directed Acyclic Word Graphs ****/

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; iDown indexes the first node in the state wch transitions to. DAWG is a special
kind of trie: a "Directed Acyclic Word Graph," essentially an ending-compressed trie. */

typedef struct tagDAWGNODE
{
    DWORD   wch;            // Unicode character
    DWORD   wFlags;         // see below
    DWORD   cWords;         // Words below this node in the subtree
	DWORD	cSkipWords;		// Words below skipped nodes
    DWORD   iDown;          // Offset of first node in next state
    DWORD   iRight;         // Offset to first node in next substate
    DWORD   cTags[8];       // Count of tagged nodes below this node in the subtree
    DWORD   dwData[8];      // Stored tagged data for this node
} DAWGNODE, *PDAWGNODE, *LPDAWGNODE;

/* Given a trie and a pointer to a node in it, find the next node in that state.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. Returns a pointer to the new node, NULL if there is
no next node (i.e. if this is the end of a state).*/

DAWGNODE * WINAPI DawgGetNextNode(void *pTrie, DAWGNODE *pTrieNode);

/* From this node, find the first node in the state it points to.  This is equivalent
to traversing a down pointer or extending the word one letter and finding the first
alternative.  Returns a pointer to the first node in the new state, NULL if there is
no down pointer. To find the first state in the trie, use pTrieNode == NULL */

DAWGNODE * WINAPI DawgGetNextState(void *pTrie, DAWGNODE *pTrieNode);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns a pointer to the terminal node in pTrie Returns
NULL if there is no path through the trie that corresponds to pwszWord. To distinguish
a valid word from a valid prefix, caller must test wFlags for fTrieNodeValid. */

DAWGNODE * WINAPI DawgCheckWord(void *pTrie, wchar_t *pwszWord);

/* Walk the trie from pTrieNode, calling pfnTrieWord on every valid word.  pvParam is passed through
to pfnTrieWord.  If pfnTrieWord returns non-zero, the enumeration stops.  pwszWord must point to a
space of cwchTrieWordMax+1 wchar_t's.  To walk the entire trie, pass NULL for pTrieNode. Returns
the number of words traversed. pfnTrieWord may be null if all you want is the count of words. */

int WINAPI
DawgEnumerate(
        void *pTrie,                    // Trie to enumerate
        DAWGNODE *pTrieNodeStart,       // point to enumerate from, NULL if all
        wchar_t *pwszWord,              // buffer to hold words being enumerated
        void *pvParam,                  // parameter to pass to pfnTrieWord
        int (*pfnTrieWord)(wchar_t *pwszWord, void *pvParam)
);

// end plain C Prototypes

#ifdef __cplusplus
}
#endif

#endif // TRIE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C92D3440_7CB2_4583_9617_587FFBBBA100__INCLUDED_)
#define AFX_STDAFX_H__C92D3440_7CB2_4583_9617_587FFBBBA100__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C92D3440_7CB2_4583_9617_587FFBBBA100__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\trie.cpp ===
#include "private.h"
#include "trie.h"
#include "memmgr.h"

#define fNLGNewMemory(pp,cb) ((*pp) = (TRIECTRL*)ExternAlloc(cb))       
#define NLGFreeMemory ExternFree

/******************************Public*Routine******************************\
* TrieInit
*
* Given a pointer to a resource or mapped file of a mapped file this
* function allocates and initializes the trie structure.
*
* Returns NULL for failure, trie control structure pointer for success.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte)
{
    LPWORD lpwTables;
    TRIECTRL *lpTrieCtrl;
    LPTRIESTATS lpTrieStats;

    lpTrieStats = (LPTRIESTATS) lpByte;

	if (lpTrieStats == NULL)
		return(NULL);

	// Check the version number.  This code currently only supports version 1 tries  

	if (lpTrieStats->version > 1)
		return NULL;

    //
    // Allocate space for the control structure and the table of SR offsets
    //

    if (!fNLGNewMemory(&lpTrieCtrl, sizeof(TRIECTRL)))
        return NULL;

    //
    // Allocate space for the complete header, copy the fixed part and read in the rest
    //

    lpByte += lpTrieStats->cbHeader;
    lpTrieCtrl->lpTrieStats = lpTrieStats;

    //
    // Set up the table pointers (all these tables are inside the TRIECTRL allocation)
    //

    lpwTables = (LPWORD)(lpTrieStats+1);

    lpTrieCtrl->lpwCharFlagsCodes = lpwTables;
    lpwTables += lpTrieStats->cCharFlagsCodesMax;

    if (lpTrieStats->cCharFlagsCodesMax & 1)               // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwTagsCodes = lpwTables;
    lpwTables += lpTrieStats->cTagsCodesMax;

    if (lpTrieStats->cTagsCodesMax & 1)                     // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwMRPointersCodes = lpwTables;
    lpwTables += lpTrieStats->cMRPointersCodesMax;

    if (lpTrieStats->cMRPointersCodesMax & 1)               // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwSROffsetsCodes = lpwTables;
    lpwTables += lpTrieStats->cSROffsetsCodesMax;

    if (lpTrieStats->cSROffsetsCodesMax & 1)                           // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpCharFlags = (LPCHARFLAGS)lpwTables;
    lpwTables = (LPWORD)(lpTrieCtrl->lpCharFlags + lpTrieStats->cUniqueCharFlags);

    lpTrieCtrl->lpwTags = (DWORD *)lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueTags);

    lpTrieCtrl->lpwMRPointers = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueMRPointers);

    lpTrieCtrl->lpwSROffsets = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueSROffsets);

    //
    // These tables should exactly fill the allocation
    //

    if ((LPBYTE)lpwTables - (LPBYTE)lpTrieStats != (int)lpTrieStats->cbHeader)
    	{
    	TrieFree(lpTrieCtrl);
		return NULL;
    	}

    //
    // Init trie pointers
    //

    lpTrieCtrl->lpbTrie = (LPBYTE)lpByte;

    return lpTrieCtrl;
}

/******************************Public*Routine******************************\
* TrieFree
*
* Free the resources allocated for the control structure.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl)
{
    //
    // Finally free the control structure and all the tables.  STILL MUST FREE THIS FOR ROM
    //

    NLGFreeMemory(lpTrieCtrl);
}

/* Deompress a single symbol using base-256 huffman from a compressed data structure. piSymbol
points to a space to hold the decompressed value, which is an index to a frequency-ordered
table of symbols (0 is most frequent).  pcCodes is a table of code lengths returned from
HuffmanComputeTable.  pbData is a pointer to memory that contains the encoded data.  The
return value is the number of bytes decoded. */

int DecompressSymbol(WORD *piSymbol, WORD *pcCodes, unsigned char *pbData)
{
    int cBytes = 0;
    WORD wCode = 0, wiSymbol = 0;

    /* At each stage in this loop, we're trying to see if we've got a length-n code.
    dwCode is which length-n code it would have to be.  If there aren't that many length-n codes,
    we have to try n+1.  To do that, we subtract the number of length-n codes and shift in
    the next byte. dwiSymbol is the symbol number of the first length-n code. */

    while (1)
    {
        wCode += *pbData++;
        ++cBytes;

        if (wCode < *pcCodes)
        {
			break;
        }
        wiSymbol += *pcCodes;
        wCode -= *pcCodes++;
        wCode <<= 8;
    }

    /* Now that dwCode is a valid number of a length-cBytes code, we can just add it to
    dwiSymbol, because we've already added the counts of the shorter codes to it. */

    wiSymbol += wCode;

    *piSymbol = wiSymbol;

    return cBytes;
}

DWORD Get3ByteAddress(BYTE *pb)
{
    return ((((pb[0] << 8) | pb[1]) << 8) | pb[2]) & 0x00ffffff;
}

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
    TRIESTATS  *lpTrieStats;
    DWORD       wOffset;
    DWORD       wOffset2;
    WORD        wCode;
    DWORD       dwCode;
    BYTE        wMask;
    BYTE        bMask;
    int         iTag;

    lpTrieStats = lpTrieCtrl->lpTrieStats;

    /* If this is an initial call, use the first byte in the trie */

    if (lpTrieScan->wFlags == 0)
    {
        lpTrieScan->lpbSRDown = 0;
        lpTrieScan->lpbNode = lpTrieCtrl->lpbTrie;
    }

    /* Decompress the char/flags */

    lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwCharFlagsCodes, lpTrieScan->lpbNode);
    lpTrieScan->wch      = lpTrieCtrl->lpCharFlags[wCode].wch;
    lpTrieScan->wFlags   = lpTrieCtrl->lpCharFlags[wCode].wFlags;

    // Decompress skip enumeration

    if (lpTrieScan->wFlags & TRIE_NODE_SKIP_COUNT)
    {
		// Values greater than 127 are really 15 or 21 bit values.

        dwCode = (DWORD) *lpTrieScan->lpbNode++;

        if (dwCode >= 0x00c0)
        {
            dwCode  = ((dwCode & 0x003f) << 15);
            dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
            dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
        }
        else if (dwCode >= 0x0080)
            dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

        lpTrieScan->cSkipWords = dwCode;
    }

    /* Code to decompress enumeration goes here */

    if (lpTrieScan->wFlags & TRIE_NODE_COUNT)
    {
		// Values greater than 127 are really 15 or 21 bit values.

        dwCode = (DWORD) *lpTrieScan->lpbNode++;

        if (dwCode >= 0x00c0)
        {
            dwCode  = ((dwCode & 0x003f) << 15);
            dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
            dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
        }
        else if (dwCode >= 0x0080)
            dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

        lpTrieScan->cWords = dwCode;

		// Decompress the tagged enumeration counts

        wMask = 1;
        for (iTag = 0; iTag < MAXTAGS; iTag++)
        {
            if (lpTrieCtrl->lpTrieStats->wEnumMask & wMask)
            {
				// Values greater than 127 are really 15 or 21 bit values.

                dwCode = (DWORD) *lpTrieScan->lpbNode++;

                if (dwCode >= 0x00c0)
                {
                    dwCode  = ((dwCode & 0x003f) << 15);
                    dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
                    dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
                }
                else if (dwCode >= 0x0080)
                    dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

                lpTrieScan->aTags[iTag].cTag = dwCode;
            }
            else
                lpTrieScan->aTags[iTag].cTag = 0;

            wMask <<= 1;
        }
    }
    else
		lpTrieScan->cWords = 0;

    // Any tagged data for this node follows the counts

    lpTrieScan->wMask = 0;

    if (lpTrieScan->wFlags & TRIE_NODE_TAGGED)
    {
		// If there is only one tagged field, the mask byte won't be stored

        if (lpTrieCtrl->lpTrieStats->cTagFields == 1)
                bMask = lpTrieCtrl->lpTrieStats->wDataMask;
        else
                bMask = *lpTrieScan->lpbNode++;

		// Now that we know which elements are stored here, pull them in their proper place

        wMask = 1;
        for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
        {
                if (lpTrieCtrl->lpTrieStats->wDataMask & bMask & wMask)
                {
                    lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwTagsCodes, lpTrieScan->lpbNode);
                    lpTrieScan->aTags[iTag].dwData = lpTrieCtrl->lpwTags[wCode];
                    lpTrieScan->wMask |= wMask;
                }

                bMask  &= ~wMask;
                wMask <<= 1;
        }
    }

    // There are two flavors of right pointers: Multiref and Skip.

    if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
    {
        if (lpTrieScan->wFlags & TRIE_NODE_SKIP)
        {
            lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,lpTrieScan->lpbNode);
            wOffset2 = lpTrieCtrl->lpwSROffsets[wCode];     // Only add this after entire node is decompressed
        }
        else
        {
            /* Multiref: The down pointer is encoded directly */

            lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwMRPointersCodes, lpTrieScan->lpbNode);
            lpTrieScan->lpbRight = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
        }
    }
    else
            lpTrieScan->lpbRight = NULL;

    // There are 4 kinds of down pointer: Absolute, Inline, Multiref, and Singleref Offset.
    // Each requires different decompression

    if (lpTrieScan->wFlags & TRIE_DOWN_ABS)
    {
            // Immediate.  The next 3 bytes are the absolute offset from the base of the trie.

            lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + Get3ByteAddress(lpTrieScan->lpbNode);
            lpTrieScan->lpbNode += 3;
    }
    else if (lpTrieScan->wFlags & TRIE_DOWN_INLINE)
    {
            /* Inline: The down pointer points to the next sequential byte (so it isn't stored) */

            lpTrieScan->lpbSRDown = lpTrieScan->lpbDown = lpTrieScan->lpbNode;
    }
    else if (lpTrieScan->wFlags & TRIE_DOWN_MULTI)
    {
            /* Multiref: The down pointer is encoded directly */

            lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwMRPointersCodes,
                    lpTrieScan->lpbNode);

            lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
    }
    else if (lpTrieScan->wFlags & TRIE_NODE_DOWN)
    {
            /* SR Offset.  The down pointer is encoded as an offset from the LAST downpointer
            into this singleref segment.  So we have to keep the old one around so we can add to it */

            lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,
                    lpTrieScan->lpbNode);

            if (lpTrieScan->lpbSRDown == 0)
            {
                    lpTrieScan->lpbSRDown = lpTrieScan->lpbNode;  // We offset from the end of the first node when going into a new state.
            }

            wOffset = lpTrieCtrl->lpwSROffsets[wCode];
            lpTrieScan->lpbSRDown += wOffset;
            lpTrieScan->lpbDown = lpTrieScan->lpbSRDown;
    }
    else
            lpTrieScan->lpbDown = NULL;

	// We couldn't deal with this until now, since skip pointers are always delta encoded from the end of node

    if ((lpTrieScan->wFlags & (TRIE_NODE_RIGHT | TRIE_NODE_SKIP)) == (TRIE_NODE_RIGHT | TRIE_NODE_SKIP))
        lpTrieScan->lpbRight = lpTrieScan->lpbNode + wOffset2;

} // TrieDecompressNode

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
	// Are we at EOS?

    if (lpTrieScan->wFlags & TRIE_NODE_END)
    {
		// Is this is a hard EOS?

        if (!(lpTrieScan->wFlags & TRIE_NODE_SKIP))
        {
			// If we can follow a right pointer, do so, else fail
        
            if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
                lpTrieScan->lpbNode = lpTrieScan->lpbRight;
            else
                return FALSE;
        }

		// Either we're at a soft EOS or we've followed a right pointer.
		// Both these require us to reset the SRDown for proper decompression

        lpTrieScan->lpbSRDown = 0;
    }

	// Decompress the node at return success

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

BOOL WINAPI TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch)
{
	// If this is the last node in the normal or skip state, quit here

    if (lpTrieScan->wFlags & TRIE_NODE_END)
        return FALSE;

	// If there isn't a right pointer or if the target letter is alphabetically less then
	// the current letter scan right normally.  Otherwise, follow the skip pointer.

    if (!(lpTrieScan->wFlags & TRIE_NODE_RIGHT) || (wch < lpTrieScan->wch))
        return TrieGetNextNode(lpTrieCtrl, lpTrieScan);

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode   = lpTrieScan->lpbRight;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
    /* Flags can't normally be zero; that always means "top node" */

    if (lpTrieScan->wFlags == 0)
    {
        TrieDecompressNode(lpTrieCtrl, lpTrieScan);
        return TRUE;
    }

    if (!(lpTrieScan->wFlags & TRIE_NODE_DOWN))
        return FALSE;

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode = lpTrieScan->lpbDown;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;

} // TrieGetNextState

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguish a valid word from a valid prefix, caller must test
wFlags for TRIE_NODE_VALID. */

BOOL WINAPI TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t far* lpwszWord)
{
    // validate params
    if (lpTrieCtrl == NULL || lpTrieScan == NULL || lpwszWord == NULL)
        return FALSE;
    
    /* Start at the root of the trie and loop through all the letters in the word */

    memset(lpTrieScan,0,sizeof(*lpTrieScan));

    while (*lpwszWord)
    {
        /* Each new letter means we need to go to a new state.  If there is none,
                the word is not in this trie */

        if (!TrieGetNextState(lpTrieCtrl, lpTrieScan))
            return FALSE;

        /* Now we walk across the state looking for this character.  If we don't find
        it, this word is not in this trie */

        while (lpTrieScan->wch != *lpwszWord)
        {
            if (!TrieSkipNextNode(lpTrieCtrl, lpTrieScan, *lpwszWord))
                return FALSE;
        }

        ++lpwszWord;
    }

    return TRUE;

} // TrieCheckWord

// Find the index to the word in the trie.

DWORD CountWords(TRIECTRL *ptc, TRIESCAN *pts)
{
    TRIESCAN        ts     = *pts;
    DWORD           cWords = 0;

    if (!TrieGetNextState(ptc, &ts))
            return cWords;

    do
    {
        if (ts.wFlags & TRIE_NODE_VALID)
            cWords++;

        cWords += CountWords(ptc, &ts);
    } while (TrieGetNextNode(ptc, &ts));

    return cWords;
}

int WINAPI TrieWordToIndex(TRIECTRL *ptc, wchar_t *pwszWord)
{
    TRIESCAN    ts;
    int         ich = 0;
    int         index = 0;
    BOOL        bValid;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
            return FALSE;

    do
    {
        bValid = ts.wFlags & TRIE_NODE_VALID;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

			// If we reached the end of word at a valid state, return the index

            if ((pwszWord[ich] == L'\0') && ts.wFlags & TRIE_NODE_VALID)
                return index;

			// Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return -1;
        }
        else
        {
			// Now, follow the skip pointer if exist and the alphabetic character is greater then
			// the pivot point. Otherwise, goto the next node.  Add the sub tree count.  If it's cached
			// use it, otherwise compute it recursively.

            if ((ts.wFlags & TRIE_NODE_SKIP_COUNT) && (pwszWord[ich] > ts.wch))
            {
                index += ts.cSkipWords;

				// This can't fail if TRIE_NODE_SKIP_COUNT is set

                TrieSkipNextNode(ptc, &ts, pwszWord[ich]);
            }
            else
            {
                index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

                if (!TrieGetNextNode(ptc, &ts))
                    return -1;
            }
        }

		// If the node we just visited was valid, increment the index

        if (bValid)
            index++;

    } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc)
{
    TRIESCAN        ts;
    int             ich = 0;
    DWORD           cWords;
    DWORD           cSkips;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
		// If we're at the end of the buffer, fail

        if (ich + 1 >= cwc)
            return FALSE;

		// Remember this node's character

        pwszWord[ich] = ts.wch;

		// If we're on a valid word AND we've reached the index we're looking for, exit the loop

        if (ts.wFlags & TRIE_NODE_VALID)
        {
            if (!nIndex)
                break;

            nIndex--;
        }

		// Get the count of words in this subtree.

        cWords = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);
        cSkips = (ts.wFlags & TRIE_NODE_SKIP_COUNT) ? ts.cSkipWords : 0x7fffffff;

		// Scan to the right until the word count of the subtree would be greater than or equal to the index
		// we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.
		// If we can use a skip count, do so.

        if (nIndex < cWords)
        {
            if (!TrieGetNextState(ptc, &ts))
                return FALSE;

            ich++;                                  // Advance the character position
        }
        else
        {
            if (nIndex >= cSkips)
            {
                nIndex -= cSkips;

                ts.lpbSRDown = 0;
                ts.lpbNode = ts.lpbRight;
                
                TrieDecompressNode(ptc, &ts);
            }
            else
            {
                nIndex -= cWords;

                if (!TrieGetNextNode(ptc, &ts))
                    return FALSE;
            }
        }

    } while (TRUE);

    pwszWord[++ich] = L'\0';                        // Null terminate the string
    return ts.wFlags & TRIE_NODE_VALID;             // Return validity
}

int WINAPI TriePrefixToRange(TRIECTRL *ptc, wchar_t *pwszWord, int *piStart)
{
    TRIESCAN        ts;
    int                     ich = 0;
    int                     cnt;
    BOOL            bValid;

    memset(&ts, 0, sizeof(TRIESCAN));
	*piStart = 0;

    if (!TrieGetNextState(ptc, &ts))
            return 0;

    // Deal with special case of empty string

    if (pwszWord && !*pwszWord)
            return ptc->lpTrieStats->cWords;

    do
    {
		// Get the count of words below this prefix

        cnt = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

		// If the node we just arrived at is valid, increment the count

        bValid = ts.wFlags & TRIE_NODE_VALID;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
			ich++;

            // If we reached the end of prefix, return the count remaining below

            if (pwszWord[ich] == L'\0')
            {
                if (bValid)
					cnt++;

                return cnt;
            }

            // Try going down a level

            if (!TrieGetNextState(ptc, &ts))
				return 0;
        }
        else
        {
			// Add the sub tree count.

           *piStart += cnt;

			// Try the next letter in this state

            if (!TrieGetNextNode(ptc, &ts))
				return 0;
        }

        if (bValid)
			(*piStart)++;

    } while (TRUE);
}

// TAGS

// Find the index to the word in the trie.

DWORD CountTags(TRIECTRL *ptc, TRIESCAN *pts, DWORD wMask, int iTag)
{
    TRIESCAN	ts = *pts;
    DWORD       cTags = 0;

    if (!TrieGetNextState(ptc, &ts))
		return cTags;

    do
    {
        if (ts.wFlags & wMask)
			cTags++;

        cTags += CountTags(ptc, &ts, wMask, iTag);
    } while (TrieGetNextNode(ptc, &ts));

    return cTags;
}

int WINAPI TrieWordToTagIndex(TRIECTRL *ptc, wchar_t *pwszWord, int iTag)
{
    TRIESCAN	ts;
    int         ich = 0;
    int         index = 0;
    BOOL        bValid;
    DWORD       wMask = 1 << iTag;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
        bValid = ts.wFlags & wMask;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

			// If we reached the end of word at a valid state, return the index

            if ((pwszWord[ich] == L'\0') && ts.wFlags & wMask)
                return index;

			// Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return -1;
        }
        else
        {
			// Add the sub tree count.  If it's cached use it, otherwise compute it recursively.

            index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

            if (!TrieGetNextNode(ptc, &ts))
                return -1;
        }

		// If the node we just visited was valid, increment the index

        if (bValid)
			index++;
    } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieTagIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc, int iTag)
{
    TRIESCAN        ts;
    int             ich = 0;
    DWORD           cTags;
    DWORD           wMask = 1 << iTag;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
		return FALSE;

    do
    {
		// If we're at the end of the buffer, fail

        if (ich + 1 >= cwc)
            return FALSE;

		// Remember this node's character

        pwszWord[ich] = ts.wch;

		// If we're on a valid word AND we've reached the index we're looking for, exit the loop

        if (ts.wFlags & wMask)
        {
            if (!nIndex)
                break;

            nIndex--;
        }

		// Get the count of words in this subtree.

        cTags = (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

		// Scan to the right until the word count of the subtree would be greater than or equal to the index
		// we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.

        if (nIndex < cTags)
        {
            if (!TrieGetNextState(ptc, &ts))
                return FALSE;

                ich++; // Advance the character position
        }
        else
        {
            nIndex -= cTags;

            if (!TrieGetNextNode(ptc, &ts))
                return FALSE;
        }
    } while (TRUE);

    pwszWord[++ich] = L'\0';            // Null terminate the string
    return ts.wFlags & wMask;           // Return validity
}

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                // Returned values
        BYTE       *pbValid             // Mask for valid return values
)
{
    TRIESCAN        ts;
    int             iTag;
    WORD            wMask;
    BYTE            bMask = ptc->lpTrieStats->wTagsMask;

    if (!TrieCheckWord(ptc, &ts, pwszWord))
        return FALSE;

    if (ts.wFlags & TRIE_NODE_TAGGED)
    {
        wMask = 1;
        for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
        {
            if (ts.wMask & wMask)
            {
                pdw[iTag] = ts.aTags[iTag].dwData;
                bMask |= wMask;
            }

            wMask <<= 1;
        }
    }

   *pbValid = (BYTE) wMask;

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imkrinst\imkrinst.cpp ===
/**************************************************************************\
* Module Name: Winmain.cpp
*
* Copyright (C) 2000, Microsoft Corporation
*
* Korean IME 6.1 install utility
*
* History:
* 11-Dec-2000 CSLim Ported from Satori 8.1 code
\**************************************************************************/

#include "private.h"
#include <set>
#include "imkrinst.h"
#include "regtip.h"
#include "insert.h"
#include "..\tip\resource.h"
#include "..\version\verres.h"

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#define MEMALLOC(x)      LocalAlloc(LMEM_FIXED, x)
#define MEMFREE(x)       LocalFree(x)

// Profile reg key
#define SZTIPREG_LANGPROFILE_TEMPLATE TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\%s\\LanguageProfile\\0x00000412")
#if defined(_WIN64)
#define SZTIPREG_LANGPROFILE_TEMPLATE_WOW64 TEXT("SOFTWARE\\Wow6432Node\\Microsoft\\CTF\\TIP\\%s\\LanguageProfile\\0x00000412")
#endif

#ifdef DEBUG
CCicCriticalSectionStatic g_cs;
#endif

// IA64 IME does not support IME Pad. So we just need to take care Wow64 IME in IA64.
#if !defined(_WIN64)
// Pad Applet Registry location
#define SZPADSHARE        TEXT("SOFTWARE\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042")
#define SZAPPLETCLSID    TEXT("SOFTWARE\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042\\AppletCLSIDList")
#define SZAPPLETIID        TEXT("SOFTWARE\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042\\AppletIIDList")
#else
#define SZPADSHARE        TEXT("SOFTWARE\\Wow6432Node\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042")
#define SZAPPLETCLSID    TEXT("SOFTWARE\\Wow6432Node\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042\\AppletCLSIDList")
#define SZAPPLETIID        TEXT("SOFTWARE\\Wow6432Node\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042\\AppletIIDList")
#endif
/////////////////////////////////////////////////////////////////////////////
// Script run routines
BOOL CmdSetupDefaultParameters();
BOOL CmdSetVersion(LPCTSTR szParam);
BOOL CmdFileList(LPCTSTR szFormat);
BOOL CmdPreSetupCheck(LPCTSTR szParam);
BOOL CmdRenamePEFile(LPCTSTR szParam);
BOOL CmdRenameFile(LPCTSTR szParam);
BOOL CmdRegisterInterface(LPCTSTR szParam);
BOOL CmdRegisterInterfaceWow64(LPCTSTR szParam);
BOOL CmdRegisterIMEandTIP(LPCTSTR szParam);
BOOL CmdRegisterPackageVersion(void);
BOOL CmdRegisterPadOrder(void);
BOOL CmdAddToPreload(LPCTSTR szParam);
BOOL CmdPrepareMigration(LPCTSTR szParam);
BOOL CmdCreateDirectory(LPCTSTR szParam);
BOOL CmdRegisterHelpDirs();

/////////////////////////////////////////////////////////////////////////////
// Private Functions
// Utility functions
static DWORD WINAPI ProcessScriptFile();
static void RegisterIMEWithFixedHKL(LPCTSTR szHKL, LPCTSTR szIMEFileName, LPCTSTR szIMEName);
static void cdecl LogOutDCPrintf(LPCTSTR lpFmt, va_list va);
static void DebugLog(LPCTSTR szFormat, ...);
static void ErrorLog(LPCTSTR szFormat, ...);
static INT ParseEnvVar(LPTSTR szBuffer, const UINT arg_nLength);
static void TrimString(LPTSTR szString);
static BOOL fExistFile(LPCTSTR szFilePath);
static BOOL fOldIMEsExist();
static BOOL WINAPI ReplaceFileOnReboot (LPCTSTR pszExisting, LPCTSTR pszNew);
static void GetPEFileVersion(LPTSTR szFilePath, DWORD *pdwMajorVersion, DWORD *pdwMiddleVersion, DWORD *pdwMinorVersion, DWORD *pdwBuildNumber);
static BOOL ActRenameFile(LPCTSTR szSrcPath, LPCTSTR tszDstPath, DWORD dwFileAttributes);
static void RegisterTIP(LPCTSTR szTIPName);
static void RegisterTIPWow64(LPCTSTR szTIPName);
static BOOL RegisterRUNKey(LPCTSTR szParam);
static BOOL MakeSIDList();
static PSECURITY_DESCRIPTOR CreateSD();
static PSID MyCreateSid(DWORD dwSubAuthority);
    
// HKL Helpers
static void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault);
static BOOL HKLHelp412ExistInPreload(HKEY hKeyCU);
static HKL GetHKLfromHKLM(LPTSTR argszIMEFile);
static void RestoreMajorVersionRegistry();

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static TCHAR g_szCurrentDirectory[MAX_PATH] = {0};     // Directory in where this EXE resides.
static TCHAR g_szScriptFile[MAX_PATH] = {0};           // File name (not full path) of script file.
static TCHAR g_szSetupProgram[MAX_PATH] = {0};         // File name (not full path) of setup program.
static TCHAR g_szSystemDirectory[MAX_PATH] = {0};      // System directory.
static TCHAR g_szErrorMessage[200] = {0};              // Global buffer for last error message.
static BOOL  g_fDebugLog = FALSE;                      // Dump debug message when true.
static BOOL  g_fErrorLog = FALSE;                      // Dump error message when true.

static DWORD g_dwMajorVersion  = 0;                    // Package version of this installation.
static DWORD g_dwMiddleVersion = 0;
static DWORD g_dwMinorVersion  = 0;
static DWORD g_dwBuildNumber   = 0;

static std::set <FLE> g_FileList;                      // FileListSet. Used to store set of file paths given by "CmdFileList"
                                                       // script command.

TCHAR g_szVersionKeyCur[MAX_PATH] = {0};
BOOL g_fExistNewerVersion = FALSE;

/*---------------------------------------------------------------------------
    WinMain
---------------------------------------------------------------------------*/
INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    LPTSTR szHitPtr;
    LPTSTR szCommandLine;
    size_t cchCommandLine;
    
    if (FAILED(StringCchLength(GetCommandLine(), MAX_PATH, &cchCommandLine)))
        return (0);

    szCommandLine = new TCHAR[cchCommandLine + 1];
    
    if (szCommandLine == NULL)
        return (0);
    
    // szCommandLine contains all command line.
    // Will be modified by _tcstok.
    StringCchCopy(szCommandLine, cchCommandLine+1, GetCommandLine());

// TEMP Code
//    LogOutDCPrintf(TEXT("WinMain CommandLine arg: %s"), szCommandLine);

    CoInitialize(NULL);

    szHitPtr = _tcstok(szCommandLine, TEXT("\""));
    // g_szCurrentDirectory has path for the process. (IMKRINST.EXE)
    StringCchCopy(g_szCurrentDirectory, ARRAYSIZE(g_szCurrentDirectory), szHitPtr);

    szHitPtr = _tcsrchr(g_szCurrentDirectory, TEXT('\\'));
    // if g_szCurrentDirectory contains full path,
    if (szHitPtr != NULL)
        {                                             
        *szHitPtr = 0;                                // terminate with the last '\' character to obtain current directory,
        StringCchCopy(g_szSetupProgram, ARRAYSIZE(g_szSetupProgram), szHitPtr + 1);      // then copy the rest (after last '\') to g_szScriptFile.
        }
    else
        {
        StringCchCopy(g_szSetupProgram, ARRAYSIZE(g_szSetupProgram), g_szCurrentDirectory);      // Otherwise (g_szCurrentDirectory is not full path), copy entire
        GetCurrentDirectory(MAX_PATH, g_szCurrentDirectory);  // to g_szScriptFile and obtain current directory by GetCurrentDirectory.
        }

    StringCchCopy(g_szScriptFile, ARRAYSIZE(g_szScriptFile), g_szSetupProgram);
    szHitPtr = _tcsrchr(g_szScriptFile, TEXT('.'));
    if (szHitPtr != NULL)                                  // If g_szScriptFile contains '.' character, find the last one
        *szHitPtr = 0;                                     // and terminate string with it, then concatenate ".inf" to it.
                                                           // Usually it results ".exe" -> ".inf" replacement. If g_szScriptFile

    // doesn't have '.' character, just concatenate ".ini".
    lstrcat(g_szScriptFile, TEXT(".ini"));

    // Get system32 dir
    GetSystemDirectory(g_szSystemDirectory, ARRAYSIZE(g_szSystemDirectory));
    
    // g_szCurrentDirectory, g_szSetupProgram, g_szSystemDirectory and g_szScriptFile are prepared.
    // szCommandLine will be no longer used.
    // We can use these environment variable in the process.
    SetEnvironmentVariable(TEXT("SETUPSOURCE"), g_szCurrentDirectory);
    SetEnvironmentVariable(TEXT("SETUPEXE"),    g_szSetupProgram);
    SetEnvironmentVariable(TEXT("SETUPINF"),    g_szScriptFile);
    SetEnvironmentVariable(TEXT("SYSTEMDIR"),   g_szSystemDirectory);
    
    delete[] szCommandLine;
    szCommandLine = NULL;

    //////////////////////////////////////////////////////////////////////////
    // Read and run Script file
    switch (ProcessScriptFile())
        {
    case errNoError:
        break;
    case errPreSetupCheck:
        {
#ifdef NEVER
            for(set<FLE>::iterator itFLE = g_FileList.begin(); itFLE != g_FileList.end(); itFLE++){
                DebugLog(TEXT("Cleanup: Deleting Source file: %s"), itFLE->szFileName);
                DeleteFile(itFLE->szFileName);
            }
#endif // NEVER
        }
        break;
    default:
        DebugLog(g_szErrorMessage);
        }
    
#ifdef NEVER
    for (set<FLE>::iterator itFLE = g_FileList.begin(); itFLE != g_FileList.end(); itFLE++)
        {
        ErrorLog(TEXT("Warning: File %s in CmdFileList will be removed without any processing"), itFLE->szFileName);
        DeleteFile(itFLE->szFileName);
        }
#endif // NEVER
    
    CoUninitialize();
    
    return(0);
}

/////////////////////////////////////////////////////////////////////////////
// Main Script Processing functions
/////////////////////////////////////////////////////////////////////////////
inline LPCTSTR GetParameter(LPTSTR szLineBuffer)
{
    return(szLineBuffer + lstrlen(szLineBuffer) + 1);
}

/*---------------------------------------------------------------------------
    ProcessScriptFile
    Read script file. Dispatch commands for each line.
---------------------------------------------------------------------------*/
DWORD WINAPI ProcessScriptFile()
{
    TCHAR szScriptFilePath[MAX_PATH];
    FILE *fileScript;

    wsprintf(szScriptFilePath, TEXT("%s\\%s"), g_szCurrentDirectory, g_szScriptFile);

    fileScript = _tfopen(szScriptFilePath, TEXT("rt"));
    
    if (fileScript != NULL)
        {
        TCHAR szLineBuffer[_cchBuffer];
        LPTSTR szCommand;

        // Parse command
        // Command form <Command>:<Parameter>
        while (_fgetts(szLineBuffer, _cchBuffer, fileScript) != NULL)
            {
            // Chop CR code.
            szLineBuffer[lstrlen(szLineBuffer) - 1] = 0;

            // Empty or Comment line
            if (lstrlen(szLineBuffer) == 0 || (_tcsncmp(TEXT("//"), szLineBuffer, 2) == 0))
                continue;

            DebugLog(TEXT("Line: %s"), szLineBuffer);
           
            szCommand = _tcstok(szLineBuffer, TEXT(":"));

            if (szCommand == NULL)
            {                                        // Dispatch each commands.
                DebugLog(TEXT("Ignore line"));
            }
            else if (lstrcmpi(szCommand, TEXT("DebugLogOn")) == 0)
            {
                g_fDebugLog = TRUE;
                g_fErrorLog = TRUE;
                DebugLog(TEXT("Turn on DebugLog"));
            }
            else if (lstrcmpi(szCommand, TEXT("DebugLogOff")) == 0)
            {
                DebugLog(TEXT("Turn off DebugLog"));
                g_fDebugLog = FALSE;
                }
            else if (lstrcmpi(szCommand, TEXT("ErrorLogOn")) == 0)
                {
                g_fErrorLog = TRUE;
                DebugLog(TEXT("Turn on DebugLog"));
                }
            else if (lstrcmpi(szCommand, TEXT("ErrorLogOff")) == 0)
                {
                DebugLog(TEXT("Turn off DebugLog"));
                g_fErrorLog = FALSE;
                }
            else if (lstrcmpi(szCommand, TEXT("FileList")) == 0)
                {
                if (!CmdFileList(GetParameter(szCommand)))
                    return(errFileList);
                }
            else if (lstrcmpi(szCommand, TEXT("SetupDefaultParameters")) == 0)
                {
                if (!CmdSetupDefaultParameters())
                    return(errSetDefaultParameters);
                }
            else if (lstrcmpi(szCommand, TEXT("SetVersion")) == 0)
                {
                if (!CmdSetVersion(GetParameter(szCommand)))
                    return(errSetVersion);
                }
            else if (lstrcmpi(szCommand, TEXT("PreSetupCheck")) == 0)
                {
                if (!CmdPreSetupCheck(GetParameter(szCommand)))
                    return(errPreSetupCheck);
                }
            else if (lstrcmpi(szCommand, TEXT("RenamePEFile")) == 0)
                {
                if (!CmdRenamePEFile(GetParameter(szCommand)))
                    return(errRenameFile);
                }
            else if (lstrcmpi(szCommand, TEXT("RenameFile")) == 0)
                {
                if (!CmdRenameFile(GetParameter(szCommand)))
                    return(errRenameFile);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterIMEandTIP")) == 0)
                {
                if (!CmdRegisterIMEandTIP(GetParameter(szCommand)))
                    return(errRegisterIMEandTIP);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterPackageVersion")) == 0)
                 {
                if (!CmdRegisterPackageVersion())
                    return(errRegisterPackageVersion);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterInterface")) == 0)
                {
                if (!CmdRegisterInterface(GetParameter(szCommand)))
                    return(errRegisterInterface);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterInterfaceWow64")) == 0)
                {
                if (!CmdRegisterInterfaceWow64(GetParameter(szCommand)))
                    return(errRegisterInterfaceWow64);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterPadOrder")) == 0)
                {
                if (!CmdRegisterPadOrder())
                    return(errRegisterPadOrder);
                }
            else if (lstrcmpi(szCommand, TEXT("AddToPreload")) == 0)
                {
                if (!CmdAddToPreload(GetParameter(szCommand)))
                    return(errAddToPreload);
                }
            else if (lstrcmpi(szCommand, TEXT("PrepareMigration")) == 0)
                {
                if (!CmdPrepareMigration(GetParameter(szCommand)))
                    return(errPrepareMigration);
                }
            else if (lstrcmpi(szCommand, TEXT("CreateDirectory")) == 0)
                {
                if (!CmdCreateDirectory(GetParameter(szCommand)))
                    return(errCmdCreateDirectory);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterHelpDirs")) == 0)
                {
                if (!CmdRegisterHelpDirs())
                    return(errCmdRegisterHelpDirs);
                }
            else
                DebugLog(TEXT("Ignore line"));
            }
            
        fclose(fileScript);
        }
    else
        {
        wsprintf(g_szErrorMessage, TEXT("Cannot open %s"), g_szScriptFile);
        return(errNoFile);
        }

    return(errNoError);
}

/////////////////////////////////////////////////////////////////////////////
// Command handlers. Which are invoked from ProcessScriptFile
/////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    CmdSetupDefaultParameters
    Setup default parameters. For now, it only sets default ProductVersion value.
---------------------------------------------------------------------------*/
#define MAKE_STR(a) #a
#define MAKE_VERSTR(a, b, c, d) MAKE_STR(a.b.c.d)

#define VERRES_VERSIONSTR MAKE_VERSTR(VERRES_VERSION_MAJOR, VERRES_VERSION_MINOR, VERRES_VERSION_BUILD, VERRES_VERSION_REVISION)

BOOL CmdSetupDefaultParameters()
{
    _stscanf(TEXT(VERRES_VERSIONSTR), TEXT("%d.%d.%d.%d"), &g_dwMajorVersion, &g_dwMiddleVersion, &g_dwMinorVersion, &g_dwBuildNumber);

    wsprintf(g_szVersionKeyCur, "%s\\%d.%d\\%s", g_szVersionKey, g_dwMajorVersion, g_dwMiddleVersion, g_szVersion);

    DebugLog(TEXT("CmdSetupDefaultParameters: Version Info : %d.%d.%d.%d"), g_dwMajorVersion, g_dwMiddleVersion, g_dwMinorVersion, g_dwBuildNumber);

    return(TRUE);
}

/*---------------------------------------------------------------------------
    CmdSetVersion
    Overwrites default ProductVersion value with value provided in script file.
---------------------------------------------------------------------------*/
BOOL CmdSetVersion(LPCTSTR szParam)
{
    int iNum = _stscanf(szParam, TEXT("%d.%d.%d.%d"), &g_dwMajorVersion, &g_dwMiddleVersion, &g_dwMinorVersion, &g_dwBuildNumber);

    wsprintf(g_szVersionKeyCur, "%s\\%d.%d\\%s", g_szVersionKey, g_dwMajorVersion, g_dwMiddleVersion, g_szVersion);

    if (iNum == 4)
        {
        DebugLog(TEXT("CmdSetVersion: Version Info : %d.%d.%d.%d"), g_dwMajorVersion, g_dwMiddleVersion, g_dwMinorVersion, g_dwBuildNumber);
        return(TRUE);
        }
    else
        {
        ErrorLog(TEXT("CmdSetVersion: Failed to retrieve version number from string [%s]"), szParam);
        wsprintf(g_szErrorMessage, TEXT("CmdSetVersion: Failed to retrieve version number from string [%s]"), szParam);
        return(FALSE);
        }
}


/*---------------------------------------------------------------------------
    CmdFileList
    Add file to the file list. Files in the file list will be deleted when they become no longer needed.
---------------------------------------------------------------------------*/
BOOL CmdFileList(LPCTSTR szFormat)
{
    FLE flElem;
    TCHAR szExpandedFileName[MAX_PATH];
    
    flElem.fRemoved = FALSE;
    StringCchCopy(flElem.szFileName, MAX_PATH, szFormat);

    if (ExpandEnvironmentStrings(flElem.szFileName, szExpandedFileName, sizeof(szExpandedFileName)/sizeof(TCHAR)))
        StringCchCopy(flElem.szFileName, MAX_PATH, szExpandedFileName);

    // Add the element to file list set.
    if (g_FileList.insert(flElem).second)
        DebugLog(TEXT("Add to CmdFileList \"%s\" -> Added."), szFormat);
    else
        ErrorLog(TEXT("Add to CmdFileList \"%s\" -> Not added. Duplicate?"), szFormat);

    return(TRUE);
}


/*---------------------------------------------------------------------------
    CmdPreSetupCheck
    Check whether the newer IME has been installed. 
    Return TRUE when we can proceed. 
    !!! FALSE will terminates setup. !!!
---------------------------------------------------------------------------*/
BOOL CmdPreSetupCheck(LPCTSTR szParam)
{
    HKEY hKey;
    TCHAR szInstalledVersionString[30];
    DWORD cbInstalledVersionString = sizeof(szInstalledVersionString);
    DWORD dwInstalledMajorVersion, dwInstalledMiddleVersion, dwInstalledMinorVersion, dwInstalledBuildNumber;

    BOOL fResult = TRUE;

    RestoreMajorVersionRegistry();
    
    //
    // root
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
        {
        cbInstalledVersionString = sizeof(szInstalledVersionString);
        
        RegQueryValueEx(hKey, g_szVersion, NULL, NULL, (LPBYTE)szInstalledVersionString, &cbInstalledVersionString);
        
        if (_stscanf(szInstalledVersionString, TEXT("%d.%d"), &dwInstalledMajorVersion, &dwInstalledMiddleVersion) == 2)
            {
            if (VersionComparison2(g_dwMajorVersion, g_dwMiddleVersion) < VersionComparison2(dwInstalledMajorVersion, dwInstalledMiddleVersion))
                {
                DebugLog(TEXT("Newer version of IME has been already installed."));
                wsprintf(g_szErrorMessage, TEXT("Newer version of IME has been already installed. but, continue to setup"));
                g_fExistNewerVersion = TRUE;
                }
            }
        RegCloseKey(hKey);
        }

    //
    // current
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKeyCur, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        cbInstalledVersionString = sizeof(szInstalledVersionString);
            
        RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE)szInstalledVersionString, &cbInstalledVersionString);
        if (_stscanf(szInstalledVersionString, TEXT("%d.%d.%d.%04d"), 
                &dwInstalledMajorVersion, &dwInstalledMiddleVersion, &dwInstalledMinorVersion, &dwInstalledBuildNumber) == 4)
            {
            if (  VersionComparison4(g_dwMajorVersion, g_dwMiddleVersion, g_dwMinorVersion, g_dwBuildNumber) 
                < VersionComparison4(dwInstalledMajorVersion, dwInstalledMiddleVersion, dwInstalledMinorVersion, dwInstalledBuildNumber))
                {
                DebugLog(TEXT("Newer version of IME has been already installed."));
                wsprintf(g_szErrorMessage, TEXT("Newer version of IME has been already installed."));
                fResult = FALSE;
                    }
            }
        RegCloseKey(hKey);
        }
    
    return(fResult);
}

/*---------------------------------------------------------------------------
    CmdRenamePEFile
    Rename file with PE format version comparison.
---------------------------------------------------------------------------*/
BOOL CmdRenamePEFile(LPCTSTR szParam)
{
    TCHAR szSrc[MAX_PATH], szDst[MAX_PATH];
    TCHAR szExpandedSrc[MAX_PATH], szExpandedDst[MAX_PATH];
    LPTSTR szHitPtr;
    DWORD dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
    DWORD dwSrcMajorVersion, dwSrcMiddleVersion, dwSrcMinorVersion, dwSrcBuildNumber;
    DWORD dwDstMajorVersion, dwDstMiddleVersion, dwDstMinorVersion, dwDstBuildNumber;

    szHitPtr = _tcschr(szParam, TEXT(','));
    if (szHitPtr == NULL)
        {
        ErrorLog(TEXT("CmdRenamePEFile: Invalid parameters (%s)"), szParam);
        wsprintf(g_szErrorMessage, TEXT("CmdRenamePEFile: Invalid parameters (%s)"), szParam);
        return(FALSE);
        }
    *szHitPtr = 0;
    StringCchCopy(szSrc, ARRAYSIZE(szSrc), szParam);
    StringCchCopy(szDst, ARRAYSIZE(szDst), szHitPtr + 1);                // Here, szDst may contain optional parameter.

    szHitPtr = _tcschr(szDst, TEXT(','));
    if (NULL != szHitPtr)
        {
        *szHitPtr = 0;
        _stscanf(szHitPtr + 1, TEXT("%d"), &dwFileAttributes);
        }

    TrimString(szSrc);
    TrimString(szDst);

    ExpandEnvironmentStrings(szSrc, szExpandedSrc, sizeof(szExpandedSrc));
    ExpandEnvironmentStrings(szDst, szExpandedDst, sizeof(szExpandedDst));

    DebugLog(TEXT("CmdRenamePEFile: szExpandedSrc = %s, szExpandedDst = %s"), szExpandedSrc, szExpandedDst);

    GetPEFileVersion(szExpandedSrc, &dwSrcMajorVersion, &dwSrcMiddleVersion, &dwSrcMinorVersion, &dwSrcBuildNumber);
    GetPEFileVersion(szExpandedDst, &dwDstMajorVersion, &dwDstMiddleVersion, &dwDstMinorVersion, &dwDstBuildNumber);

    DebugLog(TEXT("SrcVersion: (%d.%d.%d.%d), DstVersion: (%d.%d.%d.%d)"), dwSrcMajorVersion, dwSrcMiddleVersion, dwSrcMinorVersion, dwSrcBuildNumber,
                                                                           dwDstMajorVersion, dwDstMiddleVersion, dwDstMinorVersion, dwDstBuildNumber);
    if (VersionComparison4(0, 0, 0, 0) == VersionComparison4(dwSrcMajorVersion, dwSrcMinorVersion, dwSrcMiddleVersion, dwSrcBuildNumber))
        ErrorLog(TEXT("Version of source file (%s) is 0.0.0.0. May be file not found."), szSrc);

    if(VersionComparison4(dwSrcMajorVersion, dwSrcMiddleVersion, dwSrcMinorVersion, dwSrcBuildNumber) < 
        VersionComparison4(dwDstMajorVersion, dwDstMiddleVersion, dwDstMinorVersion, dwDstBuildNumber))
        {
        DebugLog(TEXT("CmdRenamePEFile: Source version is less than Destination. Copy skipped and Source will be deleted."));

        if(DeleteFile(szSrc))
            {
            FLE fleKey;
            StringCchCopy(fleKey.szFileName, MAX_PATH, szSrc);
            g_FileList.erase(fleKey);
            }
        else
            DebugLog(TEXT("CmdRenamePEFile: Failed to delete Source file (%s)"), szSrc);
        }
    else
        {
        DebugLog(TEXT("CmdRenamePEFile: Invoke ActRenameFile"));
        ActRenameFile(szSrc, szDst, dwFileAttributes);
        }

    return(TRUE);
}

/*---------------------------------------------------------------------------
    CmdRenameFile
    Rename file without version comparison
---------------------------------------------------------------------------*/
BOOL CmdRenameFile(LPCTSTR szParam)
{
    TCHAR  szSrc[MAX_PATH], szDst[MAX_PATH];
    TCHAR  szExpandedSrc[MAX_PATH], szExpandedDst[MAX_PATH];
    LPTSTR szHitPtr;
    DWORD  dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

    szHitPtr = _tcschr(szParam, TEXT(','));
    if (szHitPtr == NULL)
        {
        ErrorLog(TEXT("CmdRenameFile: Invalid parameters (%s)"), szParam);
        wsprintf(g_szErrorMessage, TEXT("CmdRenameFile: Invalid parameters (%s)"), szParam);
        return(FALSE);
        }
    *szHitPtr = 0;
    StringCchCopy(szSrc, ARRAYSIZE(szSrc), szParam);
    StringCchCopy(szDst, ARRAYSIZE(szDst), szHitPtr + 1);                // Here, szDst may contain optional parameter.

    szHitPtr = _tcschr(szDst, TEXT(','));
    if (szHitPtr != NULL)
        {
        *szHitPtr = 0;
        _stscanf(szHitPtr + 1, TEXT("%d"), &dwFileAttributes);
        }

    TrimString(szSrc);
    TrimString(szDst);

    ExpandEnvironmentStrings(szSrc, szExpandedSrc, sizeof(szExpandedSrc));
    ExpandEnvironmentStrings(szDst, szExpandedDst, sizeof(szExpandedDst));

    DebugLog(TEXT("RanemeFile: szExpandedSrc = %s, szExpandedDst = %s"), szExpandedSrc, szExpandedDst);

    ActRenameFile(szExpandedSrc, szExpandedDst, dwFileAttributes);

    return(TRUE);
}

/*---------------------------------------------------------------------------
    RegisterIMEWithFixedHKL
---------------------------------------------------------------------------*/
void RegisterIMEWithFixedHKL(LPCTSTR szHKL, LPCTSTR szIMEFileName, LPCTSTR szIMEName)
{
    HKEY hKeyKbdLayout;
    HKEY hKeyOneIME;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   TEXT("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts"),
                   &hKeyKbdLayout) != ERROR_SUCCESS)
        return;

    if (RegCreateKey(hKeyKbdLayout,
                szHKL,
                &hKeyOneIME) != ERROR_SUCCESS)
        {
        RegCloseKey(hKeyKbdLayout);
        return;
        }

    if (RegSetValueEx(hKeyOneIME,
                TEXT("Ime File"),
                0,
                REG_SZ,
                (CONST BYTE*)szIMEFileName,
                (lstrlen(szIMEFileName) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS)
        goto WriteImeLayoutFail;

    if (RegSetValueEx(hKeyOneIME,
                TEXT("Layout Text"),
                0,
                REG_SZ,
                (CONST BYTE*)szIMEName,
                (lstrlen(szIMEName) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS)
        goto WriteImeLayoutFail;

WriteImeLayoutFail:
    RegCloseKey(hKeyOneIME);
    RegCloseKey(hKeyKbdLayout);
}

/*---------------------------------------------------------------------------
    CmdRegisterInterface
    Invoke SelfReg. If given file is DLL, call DllRegisterServer export function. If given file is EXE, run it with "/RegServer" 
    command line option.
---------------------------------------------------------------------------*/
typedef HRESULT (STDAPICALLTYPE *pfnDllRegisterServerType)(void);
BOOL CmdRegisterInterface(LPCTSTR szParam)
{
    TCHAR szExpandedModulePath[MAX_PATH];
    HRESULT hr = S_FALSE;
        
    ExpandEnvironmentStrings(szParam, szExpandedModulePath, sizeof(szExpandedModulePath));
    TrimString(szExpandedModulePath);

    INT iLen = 0;
    iLen = lstrlen(szExpandedModulePath);

    if (iLen < 4)
        {
        ErrorLog(TEXT("CmdRegisterInterface: Too short szExpandedModulePath (%s)"), szExpandedModulePath);
        wsprintf(g_szErrorMessage, TEXT("CmdRegisterInterface: Invalid Parameters."));
        return(FALSE);
        }

    if (lstrcmpi(TEXT(".dll"), &szExpandedModulePath[iLen - 4]) == 0)
        {
        DebugLog(TEXT("CmdRegisterInterface: DLL mode for %s"), szExpandedModulePath);

        HINSTANCE hLib = LoadLibrary(szExpandedModulePath);

        if (hLib != NULL)
            {
            pfnDllRegisterServerType pfnDllRegisterServer = (pfnDllRegisterServerType)GetProcAddress(hLib, "DllRegisterServer");
            if (pfnDllRegisterServer != NULL)
                {
                hr = pfnDllRegisterServer();
                ErrorLog(TEXT("CmdRegisterInterface: hResult=%x"), hr);
                }
            FreeLibrary(hLib);
            }
        }
    else
        {
        if (lstrcmpi(TEXT(".exe"), &szExpandedModulePath[iLen - 4]) == 0)
            {
            DebugLog(TEXT("CmdRegisterInterface: EXE mode for %s"), szExpandedModulePath);

            TCHAR szCommandBuffer[MAX_PATH * 2];
            wsprintf(szCommandBuffer, TEXT("%s /RegServer"), szExpandedModulePath);

            STARTUPINFO si;
            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);
            si.dwFlags = STARTF_USESHOWWINDOW;
            si.wShowWindow  = SW_HIDE;

            PROCESS_INFORMATION pi;
            ZeroMemory(&pi, sizeof(pi));
            
            if (CreateProcess(NULL, szCommandBuffer, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &si, &pi))
                {
                DebugLog(TEXT("CmdRegisterInterface: Running \"%s\". Waiting for the process termination."), szCommandBuffer);

                WaitForSingleObject(pi.hProcess, INFINITE);

                DebugLog(TEXT("CmdRegisterInterface: \"%s\" terminates."), szCommandBuffer);

                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                hr = S_OK;
                }
            else
                {
                DWORD dwError = GetLastError();

                ErrorLog(TEXT("CmdRegisterInterface: CreateProcess(\"%s\") failed with error code = %d(%x)"), szCommandBuffer, dwError, dwError);
                }
            }
            else
                ErrorLog(TEXT("Cannot detect module type for %s. Skipped."), szExpandedModulePath);
        }
    
    return(SUCCEEDED(hr));
}

/*---------------------------------------------------------------------------
    CmdRegisterInterfaceWow64
    Invoke SelfReg. If given file is DLL, call DllRegisterServer export function. If given file is EXE, run it with "/RegServer" 
    command line option.
---------------------------------------------------------------------------*/
BOOL CmdRegisterInterfaceWow64(LPCTSTR szParam)
{
#if defined(_WIN64)
    TCHAR szExpandedModulePath[MAX_PATH];
    TCHAR szCommandBuffer[MAX_PATH * 2];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    
    ExpandEnvironmentStrings(szParam, szExpandedModulePath, sizeof(szExpandedModulePath));
    TrimString(szExpandedModulePath);

    INT iLen = 0;
    iLen = lstrlen(szExpandedModulePath);

    if (iLen < 4)
        {
        ErrorLog(TEXT("CmdRegisterInterfaceWow64: Too short szExpandedModulePath (%s)"), szExpandedModulePath);
        wsprintf(g_szErrorMessage, TEXT("CmdRegisterInterface: Invalid Parameters."));
        return(FALSE);
        }

    if (lstrcmpi(TEXT(".dll"), &szExpandedModulePath[iLen - 4]) == 0)
        {
        // First get systemWow64Directory
        TCHAR szSysWow64Dir[MAX_PATH] = TEXT("");
        HMODULE hmod = GetModuleHandle(TEXT("kernel32.dll"));
        DebugLog(TEXT("CmdRegisterInterfaceWow64: DLL mode for %s"), szExpandedModulePath);

        if (hmod == NULL)
            {
            DebugLog(TEXT("CmdRegisterInterfaceWow64: Faile to load kernel32.dll"));
            return (TRUE);
            }

        UINT (WINAPI* pfnGetSystemWow64Directory)(LPTSTR, UINT);

        (FARPROC&)pfnGetSystemWow64Directory = GetProcAddress (hmod, "GetSystemWow64DirectoryA");

        if (pfnGetSystemWow64Directory == NULL)
            {
            DebugLog(TEXT("CmdRegisterInterfaceWow64: Faile to load GetSystemWow64DirectoryA API"));
            return (TRUE);
            }

        /*
         * if GetSystemWow64Directory fails and sets the last error to
         * ERROR_CALL_NOT_IMPLEMENTED, we're on a 32-bit OS
         */
        if (((pfnGetSystemWow64Directory)(szSysWow64Dir, ARRAYSIZE(szSysWow64Dir)) == 0) &&
            (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED))
                {
                DebugLog(TEXT("CmdRegisterInterfaceWow64: Failed to load GetSystemWow64DirectoryA API"));
                return (TRUE);
                }

        wsprintf(szCommandBuffer, TEXT("%s\\regsvr32.exe \"%s\" /s"), szSysWow64Dir, szExpandedModulePath);
        }
    else 
        if (lstrcmpi(TEXT(".exe"), &szExpandedModulePath[iLen - 4]) == 0)
            {
            DebugLog(TEXT("CmdRegisterInterfaceWow64: EXE mode for %s"), szExpandedModulePath);
            wsprintf(szCommandBuffer, TEXT("\"%s\" /RegServer"), szExpandedModulePath);
            }
        else
            {
            ErrorLog(TEXT("Cannot detect module type for %s. Skipped."), szExpandedModulePath);
            // Return true not to stop further processing.
            return (TRUE);
            }

        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(si);
        si.dwFlags = STARTF_USESHOWWINDOW;
        si.wShowWindow  = SW_HIDE;

        ZeroMemory(&pi, sizeof(pi));
        
        if (CreateProcess(NULL, szCommandBuffer, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &si, &pi))
            {
            DebugLog(TEXT("CmdRegisterInterfaceWow64: Running \"%s\". Waiting for the process termination."), szCommandBuffer);

            WaitForSingleObject(pi.hProcess, INFINITE);

            DebugLog(TEXT("CmdRegisterInterfaceWow64: \"%s\" terminates."), szCommandBuffer);

            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
            }
        else
            {
            DWORD dwError = GetLastError();

            ErrorLog(TEXT("CmdRegisterInterfaceWow64: CreateProcess(\"%s\") failed with error code = %d(%x)"), szCommandBuffer, dwError, dwError);
            }
#endif
    return(TRUE);
}

/*---------------------------------------------------------------------------
    CmdRegisterIMEandTIP
    Register IME using IMM API and TIP
---------------------------------------------------------------------------*/
BOOL CmdRegisterIMEandTIP(LPCTSTR szParam)
{
    TCHAR szIMEFileName[MAX_PATH], szTIPName[MAX_PATH], szTIPNameWow64[MAX_PATH];
    TCHAR *szHitPtr;
    TCHAR *szHitPtr2;
    HKL hIME61KL = 0;
    TCHAR szHKL[10];
    TCHAR szNonFullPath[MAX_PATH];
    HKEY hKey;
    
    szHitPtr  = _tcschr(szParam, TEXT(','));
    szHitPtr2 = _tcschr(szHitPtr + 1, TEXT(','));        // because there are three parameters
    if (szHitPtr2 == NULL)
        {
        ErrorLog(TEXT("CmdRegisterIMEandTIP: Invalid parameters (%s)"), szParam);
        wsprintf(g_szErrorMessage, TEXT("CmdRegisterIMEandTIP: Invalid parameters (%s)"), szParam);
        return(FALSE);
        }
    *szHitPtr = 0;
    *szHitPtr2 = 0;
    StringCchCopy(szIMEFileName, ARRAYSIZE(szIMEFileName), szParam);
    StringCchCopy(szTIPName, ARRAYSIZE(szTIPName), szHitPtr + 1);
    StringCchCopy(szTIPNameWow64, ARRAYSIZE(szTIPNameWow64), szHitPtr2 + 1);

    TrimString(szIMEFileName);
    TrimString(szTIPName);
    TrimString(szTIPNameWow64);
    
    ParseEnvVar(szIMEFileName, MAX_PATH);
    ParseEnvVar(szTIPName, MAX_PATH);
    ParseEnvVar(szTIPNameWow64, MAX_PATH);
    
    DebugLog(TEXT("CmdRegisterIMEandTIP: IMEFileName = %s, TIPFileName = %s szTIPNameWow64 = %s"), szIMEFileName, szTIPName, szTIPNameWow64);


    /////////////////////////////////////////////////////////////////////////////
    //    IME registration
    if ((szHitPtr = _tcsrchr(szIMEFileName, TEXT('\\'))) != NULL)
        szHitPtr++;
    else
        szHitPtr = szIMEFileName;

    StringCchCopy(szNonFullPath, ARRAYSIZE(szNonFullPath), szHitPtr);

    hIME61KL = GetHKLfromHKLM(szNonFullPath);

    if (hIME61KL == (HKL)0)
        DebugLog(TEXT("CmdRegisterIMEandTIP: hIME61KL is zero %x --  error"), hIME61KL);

    //if (hKL && HKLHelp412ExistInPreload(HKEY_CURRENT_USER))
    //    {
    //  HKLHelpSetDefaultKeyboardLayout(HKEY_CURRENT_USER, hKL, FALSE);
        //hKL = ImmInstallIME(szIMEFileName, szLayoutText);
    //    }
        

    /////////////////////////////////////////////////////////////////////////////
    // TIP registration
    // Regster wow64 TIP first to avoid regstry overwrite problem.
    RegisterTIPWow64(szTIPNameWow64);
    RegisterTIP(szTIPName);
    
    /////////////////////////////////////////////////////////////////////////////
    // IME and TIP - make substitution
    TCHAR szTIPGuid[MAX_PATH];
    TCHAR szLangProfile[MAX_PATH];
    
    CLSIDToStringA(CLSID_KorIMX, szTIPGuid);
    DebugLog(TEXT("CmdRegisterIMEandTIP: CLSID_KorIMX guid=%s"), szTIPGuid);

    // make a reg key
    wsprintf(szLangProfile, SZTIPREG_LANGPROFILE_TEMPLATE, szTIPGuid);

    /////////////////////////////////////////////////////////////////////////////
    // Add Substitute HKL value to the TIP registry
    if (hIME61KL != 0 && RegOpenKeyEx(HKEY_LOCAL_MACHINE, szLangProfile, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        TCHAR szSubKeyName[MAX_PATH], szHKL[MAX_PATH];
        DWORD dwIndex;
        HKEY hSubKey;

        wsprintf(szHKL, TEXT("0x%x"), hIME61KL);
        dwIndex = 0;
        
        while (RegEnumKey(hKey, dwIndex, szSubKeyName, MAX_PATH) != ERROR_NO_MORE_ITEMS)
                {
                if (RegOpenKeyEx(hKey,szSubKeyName,0,KEY_ALL_ACCESS, &hSubKey) == ERROR_SUCCESS)
                    {
                    RegSetValueEx(hSubKey, TEXT("SubstituteLayout"), 0,REG_SZ,(BYTE *)szHKL, sizeof(TCHAR)*(lstrlen(szHKL)+1));
                    RegCloseKey(hSubKey);
                    }
            dwIndex++;
                }
            RegCloseKey(hKey);
            }

#if defined(_WIN64)
    // make a reg key
    wsprintf(szLangProfile, SZTIPREG_LANGPROFILE_TEMPLATE_WOW64, szTIPGuid);

    /////////////////////////////////////////////////////////////////////////////
    // Add Substitute HKL value to the TIP registry
    if (hIME61KL != 0 && RegOpenKeyEx(HKEY_LOCAL_MACHINE, szLangProfile, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        TCHAR szSubKeyName[MAX_PATH], szHKL[MAX_PATH];
        DWORD dwIndex;
        HKEY hSubKey;

        wsprintf(szHKL, TEXT("0x%x"), hIME61KL);
        dwIndex = 0;
        
        while (RegEnumKey(hKey, dwIndex, szSubKeyName, MAX_PATH) != ERROR_NO_MORE_ITEMS)
                {
                if (RegOpenKeyEx(hKey, szSubKeyName, 0, KEY_ALL_ACCESS, &hSubKey) == ERROR_SUCCESS)
                    {
                    RegSetValueEx(hSubKey, TEXT("SubstituteLayout"), 0, REG_SZ, (BYTE*)szHKL, sizeof(TCHAR)*(lstrlen(szHKL)+1));
                    RegCloseKey(hSubKey);
                    }
                dwIndex++;
                }
        RegCloseKey(hKey);
        }
#endif

    return(TRUE);
}

/*---------------------------------------------------------------------------
    CmdRegisterRUNKey
    Register package version
---------------------------------------------------------------------------*/
BOOL CmdRegisterPackageVersion(void)
{
    HKEY hKey;
    TCHAR szVersionString[30];

    // Write RootVersion reg only if this is latest IME.
    if (g_fExistNewerVersion == FALSE)
        {
        if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL))
            {
            wsprintf(szVersionString, TEXT("%d.%d"), g_dwMajorVersion, g_dwMiddleVersion);
            RegSetValueEx(hKey, g_szVersion, 0, REG_SZ, (CONST BYTE *)szVersionString, (lstrlen(szVersionString) + 1) * sizeof(TCHAR));
            RegCloseKey(hKey);
            }
        }
    
    // Current
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKeyCur, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
        {
        wsprintf(szVersionString, TEXT("%d.%d.%d.%d"), g_dwMajorVersion, g_dwMiddleVersion, g_dwMinorVersion, g_dwBuildNumber);
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (CONST BYTE *)szVersionString, (lstrlen(szVersionString) + 1) * sizeof(TCHAR));
        RegCloseKey(hKey);
        }

    return(TRUE);
}



//
// Register Applet order
//

#define FE_KOREAN   // need Korean stuff
#include "../fecommon/imembx/guids.h"


typedef
struct tagAPPLETCLSID 
{
    const GUID *pguidClsid;
    BOOL fNoUIM;
} APPLETCLSID;

typedef
struct tagAPPLETIID 
{
    const GUID *pguidIID;
} APPLETIID;

/*---------------------------------------------------------------------------
    CmdRegisterPadOrder
    Not support WOW64.
---------------------------------------------------------------------------*/
BOOL CmdRegisterPadOrder(void)
{
    HKEY hKey;
    TCHAR szClsid[MAX_PATH];
    TCHAR szKey[MAX_PATH];
    
    static const APPLETCLSID appletClsid[] = 
    {
        { &CLSID_ImePadApplet_MultiBox, FALSE },
        {0},
    };

    static const APPLETIID appletIID[] = 
    {
        { &IID_MultiBox },
        {0},
    };

    //
    // Applet clsid
    //
    for (INT i = 0; appletClsid[i].pguidClsid; i++)
        {
        CLSIDToStringA(*appletClsid[i].pguidClsid, szClsid);
        wsprintf(szKey, TEXT("%s\\%s"), SZAPPLETCLSID, szClsid);
        
        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
            {
            if(appletClsid[i].fNoUIM)
                {
                DWORD dw = 1;
                RegSetValueEx(hKey, TEXT("nouim"), 0, NULL, (BYTE*)&dw, sizeof(DWORD));
                }

            RegCloseKey(hKey);
            }
        }


    //
    // Applet iid
    //
    TCHAR szSubKey[MAX_PATH];

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZAPPLETIID, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
            {
            for (INT i = 0; appletIID[i].pguidIID; i++)
                {
                CLSIDToStringA(*appletIID[i].pguidIID, szKey);
                wsprintf(szSubKey, TEXT("%d"), i);
                RegSetValueEx(hKey, szSubKey, 0, REG_SZ, (BYTE*)szKey, (lstrlen(szKey)+1)*sizeof(TCHAR));
                }
            RegCloseKey(hKey);
            }

    return(TRUE);
}

/*---------------------------------------------------------------------------
    CmdCreateDirectory
---------------------------------------------------------------------------*/
BOOL CmdCreateDirectory(LPCTSTR szParam)
{
    TCHAR szDirectory[MAX_PATH], szExpandedDirectory[MAX_PATH];

    StringCchCopy(szDirectory, ARRAYSIZE(szDirectory), szParam);
    TrimString(szDirectory);
    ExpandEnvironmentStrings(szDirectory, szExpandedDirectory, sizeof(szExpandedDirectory)/sizeof(TCHAR));

    CreateDirectory(szExpandedDirectory, NULL);

    return(TRUE);

}

/*---------------------------------------------------------------------------
    CmdAddToPreload
    Add HKL for given IMEFile to current user's preload. The HKL won't become default IME.
---------------------------------------------------------------------------*/
BOOL CmdAddToPreload(LPCTSTR szParam)
{
    TCHAR tszIMEFileName[MAX_PATH];
    HKL hKL;

    // If there is no Kor IME exist in preload, we shouldn't add Kor IME.
    if (!HKLHelp412ExistInPreload(HKEY_CURRENT_USER))
        {
        DebugLog(TEXT("CmdAddToPreload: No 0412 HKL exist in HKCU\\Preload"));
        return TRUE;
        }

    StringCchCopy(tszIMEFileName, ARRAYSIZE(tszIMEFileName), szParam);
    TrimString(tszIMEFileName);

    hKL = GetHKLfromHKLM(tszIMEFileName);

    DebugLog(TEXT("CmdAddToPreload: Calling SetDefaultKeyboardLayout(HKEY_CURRENT_USER, %x, FALSE)"), hKL);
    HKLHelpSetDefaultKeyboardLayout(HKEY_CURRENT_USER, hKL, FALSE);

    return(TRUE);
}

/*---------------------------------------------------------------------------
    fOldIMEsExist
    Register Run regi onl if old IME exist in system.
---------------------------------------------------------------------------*/
static BOOL fOldIMEsExist()
{
    HKL hKL;

    static LPCSTR m_szOldIMEs[] = 
        {
        "msime95.ime",    // Win 95 IME
        "msime95k.ime",   // NT 4 IME
        "imekr98u.ime",    // IME98
        "imekr.ime",    // Office 10 IME
        ""
        };

    CHAR** ppch = (CHAR**)&m_szOldIMEs[0];

    while (ppch && **ppch)
        {
        hKL = GetHKLfromHKLM(*ppch);
        if (hKL)
            return TRUE;    // existing
        ppch++;
        }
    return FALSE;
}


/*---------------------------------------------------------------------------
    DisableTIP60ByDefault
---------------------------------------------------------------------------*/
VOID DisableTIP60ByDefault()
{
    // KorIMX CLSID
    // {766A2C14-B226-4fd6-B52A-867B3EBF38D2}
    const static CLSID CLSID_KorTIP60  =  
        {
        0x766A2C14,
        0xB226,
        0x4FD6,
        {0xb5, 0x2a, 0x86, 0x7b, 0x3e, 0xbf, 0x38, 0xd2}
        };

    const static GUID guidProfile60 = 
    // {E47ABB1E-46AC-45f3-8A89-34F9D706DA83}
        {
        0xe47abb1e,
        0x46ac,
        0x45f3,
        {0x8a, 0x89, 0x34, 0xf9, 0xd7, 0x6, 0xda, 0x83}
        };
        
    // Set default Tip as for Cicero.
    CoInitialize(NULL);

    ITfInputProcessorProfiles *pProfile;
    HRESULT hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (SUCCEEDED(hr)) 
        {
        pProfile->EnableLanguageProfileByDefault(CLSID_KorTIP60, 
                                        MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), guidProfile60, FALSE);
                                        
        pProfile->Release();
        }
    else
        {
        OurEnableLanguageProfileByDefault(CLSID_KorTIP60, MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), guidProfile60, FALSE);
        }
    CoUninitialize();
}

/*---------------------------------------------------------------------------
    CmdPrepareMigration
---------------------------------------------------------------------------*/
BOOL CmdPrepareMigration(LPCTSTR szParam)
{
    // Disable TIP 6.0 from HKLM by default
    // This will handle Office 10 install after Whistler mig exe removed from run reg.
    DisableTIP60ByDefault();

    // First user SID list
    if (MakeSIDList() == FALSE)
        return FALSE;

    //Register IMEKRMIG.EXE to run reg Key on "Software\Microsoft\Windows\CurrentVersion\Run"
    return RegisterRUNKey(szParam);
}

/*---------------------------------------------------------------------------
    CmdRegisterHelpDirs
---------------------------------------------------------------------------*/
BOOL CmdRegisterHelpDirs()
{
    TCHAR  szFileNameFullPath[MAX_PATH], szFileName[MAX_PATH];
    LPTSTR szExtension, szFileNamePtr;
    HKEY   hKey;

    for (std::set<FLE>::iterator itFLE = g_FileList.begin(); itFLE != g_FileList.end(); itFLE++)
        {
        StringCchCopy(szFileNameFullPath, ARRAYSIZE(szFileNameFullPath), itFLE->szFileName);
        szExtension = _tcsrchr(szFileNameFullPath, TEXT('.'));
        if (szExtension == NULL)
            continue;

        if (lstrcmpi(szExtension, TEXT(".CHM")) == 0)
            {
            if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\HTML Help"), 0, NULL, 
                                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
                {
                szFileNamePtr  = _tcsrchr(szFileNameFullPath, TEXT('\\'));
                // Get file name
                StringCchCopy(szFileName, ARRAYSIZE(szFileName), szFileNamePtr+1);
                // Get rid of file name we only need path.
                *(szFileNamePtr+1) = 0;
                RegSetValueEx(hKey, szFileName, 0, REG_SZ, (LPBYTE)szFileNameFullPath, (lstrlen(szFileNameFullPath)+1)*sizeof(TCHAR));
                }
            }
        else
            if (lstrcmpi(szExtension, TEXT(".HLP")) == 0)
            {
            if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\Help"), 0, NULL, 
                                    REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
                    {
                    szFileNamePtr  = _tcsrchr(szFileNameFullPath, TEXT('\\'));
                    // Get file name
                    StringCchCopy(szFileName, ARRAYSIZE(szFileName), szFileNamePtr+1);
                    // Get rid of file name we only need path.
                    *(szFileNamePtr+1) = 0;
                    RegSetValueEx(hKey, szFileName, 0, REG_SZ, (LPBYTE)szFileNameFullPath, (lstrlen(szFileNameFullPath)+1)*sizeof(TCHAR));
                    }
            }
        }
    return(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// Private functions
/////////////////////////////////////////////////////////////////////////////

//
// Debug output routine.
//
void cdecl LogOutDCPrintf(LPCTSTR lpFmt, va_list va)
{
    static INT DCLine = 0;
    HDC hDC = GetDC((HWND)0);
    TCHAR sz[512];
    HANDLE hFile;
    DWORD dwWrite;
    
    wvsprintf(sz, lpFmt, va );
    lstrcat(sz, TEXT("|    "));
    TextOut(hDC, 0, DCLine*16, sz, lstrlen(sz));

    if (DCLine++ > 50)
        DCLine = 0;
    
    hFile = CreateFile(TEXT("\\IMKRINST.LOG"), GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile != INVALID_HANDLE_VALUE)
        {
        SetFilePointer(hFile, 0, NULL, FILE_END);
        WriteFile(hFile, sz, lstrlen(sz), &dwWrite, NULL);
        WriteFile(hFile, TEXT("\r\n"), 2, &dwWrite, NULL);
        CloseHandle(hFile);
        }

    ReleaseDC((HWND)0, hDC);
}

void DebugLog(LPCTSTR szFormat, ...)
{
    va_list va;

    va_start(va, szFormat);

    if (g_fDebugLog)
        LogOutDCPrintf(szFormat, va);

    va_end(va);
}

void ErrorLog(LPCTSTR szFormat, ...)
{
    va_list va;

    va_start(va, szFormat);

    if (g_fErrorLog)
        LogOutDCPrintf(szFormat, va);

    va_end(va);
}


/*---------------------------------------------------------------------------
    ParseEnvVar
    Evaluate environment variable. Modiry given string.
---------------------------------------------------------------------------*/
INT ParseEnvVar(LPTSTR szBuffer, const UINT arg_nLength)
{
    INT iTranslated=0, i, j;
    TCHAR *pLParen, *pRParen, *pStart = szBuffer;
    INT nLength = min(arg_nLength, MAX_PATH);
    static TCHAR szInternalBuffer[MAX_PATH*2], szValue[MAX_PATH];

    szInternalBuffer[0] = 0;
    for (i=0; i<nLength; i++)
        {
        if (szBuffer[i] == 0)
            break;
            
        if (szBuffer[i] == '%')
            {
            pLParen = &(szBuffer[i]);
            pRParen = NULL;

            for (j=1; i+j<nLength; j++)
                {
                if (szBuffer[i+j] == 0)
                    break;

                if (szBuffer[i+j] == TEXT('%'))
                    {
                    pRParen = &(szBuffer[i+j]);
                    break;
                    }
                }

            if (pRParen)
                {
                *pLParen = 0;
                *pRParen = 0;
                lstrcat(szInternalBuffer, pStart);
                
                if (GetEnvironmentVariable(pLParen+1, szValue, sizeof(szValue)/sizeof(TCHAR)) == 0)
                    {
                    lstrcat(szInternalBuffer, TEXT("%"));
                    lstrcat(szInternalBuffer, pLParen+1);
                    lstrcat(szInternalBuffer, TEXT("%"));
                    }
                else
                    {
                    lstrcat(szInternalBuffer, szValue);
                    iTranslated++;
                    }
                pStart = pRParen+1;
                i += j;
                }
            }
        }
        
    if (iTranslated)
        {
        lstrcat(szInternalBuffer, pStart);
        lstrcpyn(szBuffer, szInternalBuffer, arg_nLength);
        }
        
    return(iTranslated);
}

/*---------------------------------------------------------------------------
    TrimString
    Chop head/tail white space from given string. Given string will be modified.
---------------------------------------------------------------------------*/
void TrimString(LPTSTR szString)
{
    INT iBuffSize = lstrlen(szString) + 1;
    LPTSTR szBuffer = new TCHAR[iBuffSize];

    if (szBuffer != NULL)
        {
        INT iHeadSpace, iTailSpace;

        StringCchCopy(szBuffer, MAX_PATH, szString);

        iHeadSpace = (INT)_tcsspn(szBuffer, TEXT(" \t"));
        _tcsrev(szBuffer);
        iTailSpace = (INT)_tcsspn(szBuffer, TEXT(" \t"));
        _tcsrev(szBuffer);

        szBuffer[lstrlen(szBuffer) - iTailSpace] = 0;
        StringCchCopy(szString, MAX_PATH, szBuffer + iHeadSpace);
        }

    if (szBuffer != NULL)
        {
        delete[] szBuffer;
        szBuffer = NULL;
        }
}

/*---------------------------------------------------------------------------
    fExistFile
---------------------------------------------------------------------------*/
BOOL fExistFile(LPCTSTR szFilePath)
{
    BOOL fResult = TRUE;

    if (GetFileAttributes(szFilePath) == -1)
        fResult = FALSE;
    
    return(fResult);
}


/*---------------------------------------------------------------------------
    ReplaceFileOnReboot
    Writes wininit.ini rename section. Note that this function writes lines in reverse order (down to upper).
---------------------------------------------------------------------------*/
BOOL WINAPI ReplaceFileOnReboot(LPCTSTR pszExisting, LPCTSTR pszNew)
{
    if (MoveFileEx(pszExisting, pszNew, MOVEFILE_DELAY_UNTIL_REBOOT)) 
        return TRUE;
    else
        return FALSE;
}

/*---------------------------------------------------------------------------
    GetPEFileVersion
    Get version information from PE format.
---------------------------------------------------------------------------*/
void GetPEFileVersion(LPTSTR szFilePath, DWORD *pdwMajorVersion, DWORD *pdwMiddleVersion, DWORD *pdwMinorVersion, DWORD *pdwBuildNumber)
{
    *pdwMajorVersion = *pdwMiddleVersion = *pdwMinorVersion = *pdwBuildNumber = 0;

    DWORD dwDummy, dwVerResSize;
    
    dwVerResSize = GetFileVersionInfoSize(szFilePath, &dwDummy);
    if (dwVerResSize)
        {
        BYTE *pbData = new BYTE[dwVerResSize];

        if (NULL != pbData)
            {
            if(GetFileVersionInfo(szFilePath, 0, dwVerResSize, pbData))
                {
                VS_FIXEDFILEINFO *pffiVersion;
                UINT cbffiVersion;

                if(VerQueryValue(pbData, TEXT("\\"), (LPVOID *)&pffiVersion, &cbffiVersion))
                    {
                    *pdwMajorVersion = HIWORD(pffiVersion->dwFileVersionMS);
                    *pdwMiddleVersion = LOWORD(pffiVersion->dwFileVersionMS);
                    *pdwMinorVersion = HIWORD(pffiVersion->dwFileVersionLS);
                    *pdwBuildNumber = LOWORD(pffiVersion->dwFileVersionLS);
                    }
                }
            }

        if (NULL != pbData)
            {
            delete[] pbData;
            pbData = NULL;
            }
        }
}

/*---------------------------------------------------------------------------
    ActRenameFile
    MoveFile. If destination file exists, it will be overwritten. If existing destination file cannot be
    overwritten in this session, file replacement is reserved to be held after rebooting.
---------------------------------------------------------------------------*/

BOOL ActRenameFile(LPCTSTR szSrcPath, LPCTSTR tszDstPath, DWORD dwFileAttributes)
{
    BOOL fReplaceAfterReboot = FALSE;
    BOOL fResult = TRUE;

    FLE fleKey;
    StringCchCopy(fleKey.szFileName, MAX_PATH, szSrcPath);
    
    if (g_FileList.end() == g_FileList.find(fleKey))
        ErrorLog(TEXT("ActRenameFile: WARNING: Cannot find source file [%s] in CmdFileList"), szSrcPath);

    if (!fExistFile(szSrcPath))
        {
        ErrorLog(TEXT("ActRenameFile: Source file [%s] doesn't exist."), szSrcPath);
        wsprintf(g_szErrorMessage, TEXT("ActRenameFile: Source file [%s] doesn't exist."), szSrcPath);
        return(FALSE);
        }

    if (fExistFile(tszDstPath))
        {
        SetFileAttributes(tszDstPath, FILE_ATTRIBUTE_NORMAL);

        if(!DeleteFile(tszDstPath))
            {
            DWORD dwError = GetLastError();
            fReplaceAfterReboot = TRUE;

            DebugLog(TEXT("ActRenameFile: Cannot delete destination file [%s] with error code = %d(%x)"), tszDstPath, dwError, dwError);
            }
        }

    if (!fReplaceAfterReboot)
        {
        if(MoveFile(szSrcPath, tszDstPath))
            {
            SetFileAttributes(szSrcPath, dwFileAttributes);
            DebugLog(TEXT("ActRenameFile: MoveFile(%s, %s) succeeded."), szSrcPath, tszDstPath);
            }
        else
            {
            DWORD dwError = GetLastError();
            DebugLog(TEXT("ActRenameFile: MoveFile(%s, %s) failed with error code = %d(%x)."), szSrcPath, tszDstPath, dwError, dwError);
            DebugLog(TEXT("ActRenameFile: Try again with fReplaceAfterReboot."));
            fReplaceAfterReboot = TRUE;
            }
        }
    
    if (fReplaceAfterReboot)
        {
        SetFileAttributes(szSrcPath, dwFileAttributes);    // In this case, change file attributes for Src path.
        ReplaceFileOnReboot(szSrcPath, tszDstPath);        // Since this function writes lines in reverse order, deletion of
        DebugLog(TEXT("ActRenameFile: ReplaceFileOnReboot(%s, %s)."), szSrcPath, tszDstPath);
        ReplaceFileOnReboot(tszDstPath, NULL);              // tszDstPath will come first.
        DebugLog(TEXT("ActRenameFile: ReplaceFileOnReboot(%s, NULL)."), tszDstPath);
        }

    if (fResult)
        g_FileList.erase(fleKey);

    return(fResult);
}

///////////////////////////////////////////////////////////////////////////////
// This should sync with SERVER.CPP in TIP folder
// TIP Categories to be added
const REGISTERCAT c_rgRegCat[] =
{
    {&GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER,     &CLSID_KorIMX},
    {&GUID_TFCAT_TIP_KEYBOARD,                 &CLSID_KorIMX},
    {&GUID_TFCAT_PROPSTYLE_CUSTOM,             &GUID_PROP_OVERTYPE},
    {NULL, NULL}
};


// TIP Profile name
const REGTIPLANGPROFILE c_rgProf[] =
{
    { MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), &GUID_Profile, SZ_TIPDISPNAME, SZ_TIPMODULENAME, (IDI_UNIKOR-IDI_ICONBASE), IDS_PROFILEDESC },
    {0, &GUID_NULL, L"", L"", 0, 0}
};
//
///////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    RegisterTIP

    Write neccessary registry key and values for TIP
---------------------------------------------------------------------------*/
void RegisterTIP(LPCTSTR szTIPName)
{
    HKEY  hKey;
    TCHAR szTIPGuid[MAX_PATH];
    TCHAR szTIPProfileGuid[MAX_PATH];
    TCHAR szSubKey[MAX_PATH];
    DWORD dwValue;

    DebugLog(TEXT("RegisterTIP: (%s)."), szTIPName);
        
    // Run self reg
    // If self reg fails, run custom TIP registration
    if (!CmdRegisterInterface(szTIPName))
        {
        TCHAR szExpandedTIPPath[MAX_PATH];

        DebugLog(TEXT("RegisterTIP: TIP self reg failed, Run custom reg"));

        // Expand Env var
        ExpandEnvironmentStrings(szTIPName, szExpandedTIPPath, sizeof(szExpandedTIPPath));

        // Register TIP CLSID
        if (!RegisterServer(CLSID_KorIMX, SZ_TIPSERVERNAME, szExpandedTIPPath, TEXT("Apartment"), NULL))
            {
            DebugLog(TEXT("RegisterTIP: RegisterServer failed"));
            return;
            }

        if (!OurRegisterTIP(szExpandedTIPPath, CLSID_KorIMX, SZ_TIPNAME, c_rgProf))
            {
            DebugLog(TEXT("RegisterTIP: szExpandedTIPPath failed"));
            return;
            }

        if (FAILED(OurRegisterCategories(CLSID_KorIMX, c_rgRegCat)))
            {
            DebugLog(TEXT("RegisterTIP: OurRegisterCategories failed"));
            return;
            }

        }

    // Get String format GUIDs
    CLSIDToStringA(CLSID_KorIMX, szTIPGuid);
    CLSIDToStringA(GUID_Profile, szTIPProfileGuid);

    /////////////////////////////////////////////////////////////////////////////
    // If no Kor IME is in .default user.
    // Set HKLM [HKLM\Software\Microsoft\CTF\TIP\TIP classid\LanguageProfile\Language ID\Guid Profile]
    //     "Enable" = "0" (DWORD)
    if (RegOpenKeyEx(HKEY_USERS, TEXT(".DEFAULT"), 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        if (!HKLHelp412ExistInPreload(hKey))
            {
            HKEY hKProfRegKey;
            // Create "Software\Microsoft\CTF\TIP\{CLSID_KorIMX}\LanguageProfile\0x00000412\{CLSID_INPUTPROFILE}"
            wsprintf(szSubKey, TEXT("%s%s\\LanguageProfile\\0x00000412\\%s"), TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\"), szTIPGuid, szTIPProfileGuid);
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_ALL_ACCESS, &hKProfRegKey) == ERROR_SUCCESS)
                {
                // Enabled
                DebugLog(TEXT("RegisterTIP: IME HKL not exist in HKU\\.Default disable TIP"));
                dwValue= 0;
                RegSetValueEx(hKProfRegKey, TEXT("Enable"), 0, REG_DWORD, (BYTE*)&dwValue, sizeof(dwValue));
                RegCloseKey(hKProfRegKey);
                }
            }

        RegCloseKey(hKey);
        }

}


/*---------------------------------------------------------------------------
    RegisterTIPWow64

    Write neccessary registry key and values for TIP
---------------------------------------------------------------------------*/
void RegisterTIPWow64(LPCTSTR szTIPName)
{
#if defined(_WIN64)
    // Run just selfreg. Cicero doesn't use "HKLM\Software\Wow6432Node\Microsoft\CTF\TIP\"
    CmdRegisterInterfaceWow64(szTIPName);
#endif
}

////////////////////////////////////////////////////////////////////////////
// HKL Helper functions
////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    GetHKLfromHKLM
---------------------------------------------------------------------------*/
HKL GetHKLfromHKLM(LPTSTR argszIMEFile)
{
    HKL  hklAnswer = 0;
    HKEY hKey, hSubKey;
    DWORD i, cbSubKey, cbIMEFile;
    TCHAR szSubKey[MAX_PATH], szIMEFile[MAX_PATH];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\Keyboard Layouts"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        for (i=0; ;i++)
            {
            cbSubKey = MAX_PATH;
            if (RegEnumKeyEx(hKey, i, szSubKey, &cbSubKey, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
                break;

            RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey);

            cbIMEFile=MAX_PATH;
            if (RegQueryValueEx(hSubKey, TEXT("IME File"), NULL, NULL, (LPBYTE)szIMEFile, &cbIMEFile) == ERROR_SUCCESS)
                {
                if (lstrcmpi(argszIMEFile, szIMEFile) == 0)
                    {
                    RegCloseKey(hSubKey);
                    _stscanf(szSubKey, TEXT("%08x"), &hklAnswer);
                    break;
                    }
                }
            RegCloseKey(hSubKey);
            }
            
        RegCloseKey(hKey);
        }
        
    return(hklAnswer);
}

/*---------------------------------------------------------------------------
    HKLHelpSetDefaultKeyboardLayout
---------------------------------------------------------------------------*/
void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault)
{
    TCHAR szKL[20];
    BYTE  Data[MAX_PATH];
    DWORD cbData;
    TCHAR szSubKey[MAX_PATH];
    HKEY  hKey,hSubKey;
    DWORD NumKL;

    wsprintf(szKL, TEXT("%08x"), hKL);

    RegOpenKeyEx(hKeyHKCU, TEXT("Keyboard Layout\\Preload"), 0, KEY_ALL_ACCESS, &hKey);
    RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumKL, NULL, NULL, NULL, NULL);

    for (DWORD i=0; i<NumKL; i++)
        {
        wsprintf(szSubKey, TEXT("%d"), i+1);
        cbData = MAX_PATH;
        RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

        if (lstrcmpi((LPCTSTR)Data, szKL) == 0)
            break;
        }

    // if hKL is not exist create it.
    if (NumKL == i)
        {
        wsprintf(szSubKey, TEXT("%d"), i+1);
        RegSetValueEx(hKey, szSubKey, 0, REG_SZ, (const LPBYTE)szKL, (lstrlen(szKL)+1)*sizeof(TCHAR));
        NumKL++;
        }

    // Set hKL as first, Shift down other.
    if(fSetToDefault)
        {
        for(int j=i; j>0; j--)
            {
            wsprintf(szSubKey, TEXT("%d"),j);

            cbData = MAX_PATH;
            RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

            wsprintf(szSubKey, TEXT("%d"),j+1);
            RegSetValueEx(hKey, szSubKey, 0, REG_SZ, Data, cbData);
            }
        RegSetValueEx(hKey, TEXT("1"), 0, REG_SZ, (const LPBYTE)szKL, (lstrlen(szKL)+1)*sizeof(TCHAR));
        }
    RegCloseKey(hKey);

    (void)LoadKeyboardLayout(szKL, KLF_ACTIVATE);
    // To activate IME2002 right now without reboot.
    if(fSetToDefault)
        (void)SystemParametersInfo(SPI_SETDEFAULTINPUTLANG, 0, &hKL, SPIF_SENDCHANGE);
}


#define MAX_NAME 100

/*---------------------------------------------------------------------------
    HKLHelp412ExistInPreload
---------------------------------------------------------------------------*/
BOOL HKLHelp412ExistInPreload(HKEY hKeyCU)
{
    HKEY hKey, hSubKey;
    int i ,j;
    DWORD cbName, cbData;
    CHAR szName[MAX_NAME];
    CHAR szData[MAX_NAME];
    HKL  hkl;
    FILETIME ftLastWriteTime;
    BOOL fResult = FALSE;

    if (RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        for (j=0; cbName=MAX_NAME, cbData=MAX_NAME, RegEnumValue(hKey, j, szName, &cbName, NULL, NULL, (LPBYTE)szData, &cbData) != ERROR_NO_MORE_ITEMS; j++)
            {
            // See If Korean KL exist. Just compare last LCID part if it's 0x412.
            // IME hkl set 0xE000 on hiword.
            sscanf(szData, "%08x", &hkl);
            if ((HIWORD(hkl) & 0xe000) && LOWORD(hkl) == 0x0412)
                {
                fResult = TRUE;
                break;
                }
            }
        RegCloseKey(hKey);
        }

    return(fResult);
}


/*---------------------------------------------------------------------------
    RegisterRUNKey
    Register IME using IMM API and TIP
---------------------------------------------------------------------------*/
BOOL RegisterRUNKey(LPCTSTR szParam)
{
    TCHAR szKey[MAX_PATH];
    TCHAR szFilename[MAX_PATH];
    TCHAR *szHitPtr;
    HKEY hRunKey;

    szHitPtr = _tcschr(szParam, TEXT(','));
    if (szHitPtr == NULL)
        {
        ErrorLog(TEXT("RegisterRUNKey: Invalid parameters (%s)"), szParam);
        wsprintf(g_szErrorMessage, TEXT("RegisterRUNKey: Invalid parameters (%s)"), szParam);
        return(FALSE);
        }
    *szHitPtr = 0;
    StringCchCopy(szKey, ARRAYSIZE(szKey), szParam);
    StringCchCopy(szFilename, ARRAYSIZE(szFilename), szHitPtr + 1);

    TrimString(szKey);
    TrimString(szFilename);

    ParseEnvVar(szKey, MAX_PATH);
    ParseEnvVar(szFilename, MAX_PATH);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRunKey, NULL) == ERROR_SUCCESS)
        {
        RegSetValueEx(hRunKey, szKey, 0, REG_SZ, (CONST BYTE *)szFilename, (lstrlen(szFilename)+1)*sizeof(TCHAR));
        RegCloseKey(hRunKey);
        }

    return(TRUE);
}


/*---------------------------------------------------------------------------
    MakeSIDList
    Gets all users' SID and list that in the reg for migration
---------------------------------------------------------------------------*/
BOOL MakeSIDList()
{
    HKEY hKey, hUserList;
    DWORD i, cbName;
    BOOL fNoMoreSID = FALSE;
    TCHAR szMigRegKey[MAX_PATH], szName[500];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"), 0, KEY_READ, &hKey) ==ERROR_SUCCESS)
        {
        StringCchCopy(szMigRegKey, ARRAYSIZE(g_szIMERootKey), g_szIMERootKey);
        lstrcat(szMigRegKey, TEXT("\\MigrateUser"));

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szMigRegKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hUserList, NULL) == ERROR_SUCCESS)
            {
            for (i=0; !fNoMoreSID; i++)
                {
                cbName = 500;
                if (RegEnumKeyEx(hKey, i, szName, &cbName, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
                    fNoMoreSID = TRUE;
                else
                    {
                    // Do not add Local Service and Network Service pid
                    if (lstrlen(szName) > 8)
                        RegSetValueEx(hUserList, szName, 0, REG_SZ, (BYTE *)TEXT(""), sizeof(TCHAR)*2);
                    }
                }

            //Change MigrateUser List security settings
            PSECURITY_DESCRIPTOR pSD = CreateSD();
            if (pSD)
                {
                RegSetKeySecurity(hUserList, DACL_SECURITY_INFORMATION, pSD);
                MEMFREE(pSD);
                }                        
            RegCloseKey(hUserList);
            }
        RegCloseKey(hKey);
        }
    return (TRUE);
}

/*---------------------------------------------------------------------------
    RestoreMajorVersionRegistry

    Restore IME major version reg value. 
    It could be overwritten during Win9x to NT upgrade.
---------------------------------------------------------------------------*/
void RestoreMajorVersionRegistry()
{
    HKEY  hKey;
    
    ///////////////////////////////////////////////////////////////////////////
    // Restore IME major version reg value. 
    // It could be overwritten during Win9x to NT upgrading.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        CHAR  szVersion[MAX_PATH];
        DWORD cbVersion = MAX_PATH;
    	CHAR szMaxVersion[MAX_PATH];
		FILETIME time;
		float flVersion, flMaxVersion;

        StringCchCopy(szMaxVersion, ARRAYSIZE(szMaxVersion),  "0");
 		for (int i=0; cbVersion = MAX_PATH, RegEnumKeyEx(hKey, i, szVersion, &cbVersion, NULL, NULL, NULL, &time) != ERROR_NO_MORE_ITEMS; i++)
            {
            if (lstrcmp(szVersion, szMaxVersion) > 0)
                StringCchCopy(szMaxVersion, ARRAYSIZE(szMaxVersion), szVersion);
            }

        StringCchCopy(szVersion, ARRAYSIZE(szVersion), "0");
        RegQueryValueEx(hKey, g_szVersion, NULL, NULL, (BYTE *)szVersion, &cbVersion);
        flVersion = (float)atof(szVersion);
        flMaxVersion = (float)atof(szMaxVersion);

        if (flVersion < flMaxVersion)
            RegSetValueEx(hKey, g_szVersion, 0, REG_SZ, (BYTE *)szMaxVersion, (sizeof(CHAR)*lstrlen(szMaxVersion)));

        RegCloseKey(hKey);
	}
    ///////////////////////////////////////////////////////////////////////////
}

/*---------------------------------------------------------------------------
    CreateSecurityAttributes
---------------------------------------------------------------------------*/
PSECURITY_DESCRIPTOR CreateSD()
{
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    ULONG                AclSize;

    PSID                 psid1, psid2, psid3, psid4;
    BOOL                 fResult;

    psid1 = MyCreateSid(SECURITY_INTERACTIVE_RID);
    if (psid1 == NULL)
        return NULL;

    psid2 = MyCreateSid(SECURITY_LOCAL_SYSTEM_RID);
    if (psid2 == NULL)
        goto Fail4;

    psid3 = MyCreateSid(SECURITY_SERVICE_RID);
    if (psid3 == NULL)
        goto Fail3;

    psid4 = MyCreateSid(SECURITY_NETWORK_RID);
    if (psid4 == NULL)
        goto Fail2;

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SIDs we've just created.
    //
    AclSize =  sizeof(ACL) + 
               (4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) + 
               GetLengthSid(psid1) + 
               GetLengthSid(psid2) + 
               GetLengthSid(psid3) + 
               GetLengthSid(psid4);

    //
    // allocate and initialize a new security descriptor plus ACL
    //
    psd = MEMALLOC(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);
    if (psd == NULL)
    {
        return NULL;
    }

    pacl = (PACL)((LPBYTE)psd + SECURITY_DESCRIPTOR_MIN_LENGTH);

    fResult = InitializeAcl(pacl, AclSize, ACL_REVISION);
    if (!fResult)
    {
        goto Fail;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid1);

    if (!fResult)
    {
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid2);

    if (!fResult)
    {
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid3);

    if (!fResult)
    {
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid4);

    if (!fResult)
    {
        goto Fail;
    }

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl))
    {
        goto Fail;
    }


    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
    {
        goto Fail;
    }

    fResult = SetSecurityDescriptorDacl(psd, fTrue, pacl, fFalse );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if (!fResult)
    {
        goto Fail;
    } 

    if (!IsValidSecurityDescriptor(psd))
    {
        goto Fail;
    }

    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid(psid1);
    FreeSid(psid2);
    FreeSid(psid3);
    FreeSid(psid4);

    return psd;

Fail:
    MEMFREE(psd);
    FreeSid(psid4);
Fail2:
    FreeSid(psid3);
Fail3:
    FreeSid(psid2);
Fail4:
    FreeSid(psid1);
    
    return NULL;
}

PSID MyCreateSid(DWORD dwSubAuthority)
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid(&SidAuthority,
                                       1,
                                       dwSubAuthority,
                                       0,0,0,0,0,0,0,
                                       &psid );
    if (!fResult)
    {
        return NULL;
    }

    if (!IsValidSid(psid))
    {
        FreeSid(psid);
        return NULL;
    }

    return psid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imkrinst\imkrinst.h ===
/****************************** Module Header ******************************\
* Module Name: imkrinst.h
*
* Copyright (c) 2000, Microsoft Corporation
*
* IMKRINST, main header file
*
\***************************************************************************/
#if !defined (_IMKRINST_H__INCLUDED_)
#define _IMKRINST_H__INCLUDED_

/////////////////////////////////////////////////////////////////////////////
// Global constants
/////////////////////////////////////////////////////////////////////////////

// Line buffer length for script file.
const int _cchBuffer = 1024;

// Error code returned from ProcessScriptFile.
enum 
{                                 
	errNoError,
    errNoFile,
    errFileList,
    errSetDefaultParameters,
    errSetVersion,
    errPreSetupCheck,
    errRenameFile,
    errRegisterIME,
    errRegisterIMEandTIP,
    errRegisterInterface,
    errRegisterInterfaceWow64,
    errAddToPreload,
    errPrepareMigration,
    errRegisterPackageVersion,
    errRegisterPadOrder,
    errCmdCreateDirectory,
    errCmdRegisterHelpDirs
};

/////////////////////////////////////////////////////////////////////////////
// Utility classes
/////////////////////////////////////////////////////////////////////////////
//
// FileListElement. Constructs FileListSet.
//
class FLE
{                                              // I use short incomprehensible name such as "FLE"
public:                                                 // since we'll meet many C4786 warnings when I use
    BOOL fRemoved;                                      // longer name.
    TCHAR szFileName[MAX_PATH];    
};

// binary operator required to construct a set of this class.
bool operator < (const FLE &fle1, const FLE &fle2)
{
	return(0 > lstrcmpi(fle1.szFileName, fle2.szFileName));
};

//
// VersionComparison. Used to compare two version info. Used for IsNewer.
//
class VersionComparison2
{
public:
    VersionComparison2(const DWORD arg_dwMajorVersion, const DWORD arg_dwMinorVersion) 
        : dwMajorVersion(arg_dwMajorVersion), dwMinorVersion(arg_dwMinorVersion){};

    virtual bool operator <(const VersionComparison2 &vc2)
    	{
        if((dwMajorVersion < vc2.dwMajorVersion) || 
           ((dwMajorVersion == vc2.dwMajorVersion) && (dwMinorVersion < vc2.dwMinorVersion)))
            return(true);
        else
            return(false);
    	}

    virtual bool operator ==(const VersionComparison2 &vc2)
    {
        return((dwMajorVersion == vc2.dwMajorVersion) && (dwMinorVersion == vc2.dwMinorVersion));
    }

private:
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
};

class VersionComparison4
{
public:
    VersionComparison4(const DWORD arg_dwMajorVersion, const DWORD arg_dwMiddleVersion, const DWORD arg_dwMinorVersion, const DWORD arg_dwBuildNumber) 
        : dwMajorVersion(arg_dwMajorVersion), dwMiddleVersion(arg_dwMiddleVersion), dwMinorVersion(arg_dwMinorVersion), dwBuildNumber(arg_dwBuildNumber){};

    virtual bool operator <(const VersionComparison4 &vc4)
    {
        if((dwMajorVersion < vc4.dwMajorVersion) || 
           ((dwMajorVersion == vc4.dwMajorVersion) && (dwMiddleVersion < vc4.dwMiddleVersion)) ||
           ((dwMajorVersion == vc4.dwMajorVersion) && (dwMiddleVersion == vc4.dwMiddleVersion) && (dwMinorVersion < vc4.dwMinorVersion)) ||
           ((dwMajorVersion == vc4.dwMajorVersion) && (dwMiddleVersion == vc4.dwMiddleVersion) && (dwMinorVersion == vc4.dwMinorVersion) && (dwBuildNumber < vc4.dwBuildNumber)))
            return(true);
        else
            return(false);
    }

    virtual bool operator ==(const VersionComparison4 &vc4)
    {
        return((dwMajorVersion == vc4.dwMajorVersion) && (dwMiddleVersion == vc4.dwMiddleVersion) &&
               (dwMinorVersion == vc4.dwMinorVersion) && (dwBuildNumber == vc4.dwBuildNumber));
    }
    
private:
    DWORD dwMajorVersion;
    DWORD dwMiddleVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
};

#endif // !defined (_IMKRINST_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imkrinst\private.h ===
//
//  Private.h
//
//  Contents:   Private header for korimx project.
//

#if !defined (__PRIVATE_H__INCLUDED_)
#define __PRIVATE_H__INCLUDED_

#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include "initguid.h"
#include "common.h"
#include "debug.h"
#include "msctf.h"
#include "regsvr.h"

#define fTrue   1
#define fFalse  0

#endif  // __PRIVATE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\apientry.cpp ===
/****************************************************************************
    APIENTRY.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    API entries between IMM32 and IME

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "apientry.h"
#include "common.h"
#include "ui.h"
#include "hauto.h"
#include "dllmain.h"
#include "hanja.h"
#include "escape.h"
#include "config.h"
#include "names.h"
#include "winex.h"
#include "hanja.h"
#include "cpadsvr.h"
#include "debug.h"

///////////////////////////////////////////////////////////////////////////////
// ImeMenu Define
#define NUM_ROOT_MENU_L 4
#define NUM_ROOT_MENU_R 1
#define NUM_SUB_MENU_L 0
#define NUM_SUB_MENU_R 0

#define IDIM_ROOT_ML_1       0x10
#define IDIM_ROOT_ML_2       0x11
#define IDIM_ROOT_ML_3       0x12
#define IDIM_ROOT_ML_4       0x13
#define IDIM_ROOT_MR_1       0x30

///////////////////////////////////////////////////////////////////////////////
// Private function Declarations
PRIVATE BOOL IsInSystemSetupMode();
PRIVATE BOOL IsRunningAsLocalSystem();
PRIVATE BOOL IsRunningInOOBE();
PRIVATE BOOL PASCAL Select(HIMC hImc, BOOL fSelect);
PRIVATE VOID PASCAL UpdateOpenCloseState(PCIMECtx pImeCtx);
PRIVATE VOID PASCAL ToAsciiExHangulMode(PCIMECtx pImeCtx, UINT uVirKey, UINT uScanCode, CONST LPBYTE lpbKeyState);
PRIVATE BOOL PASCAL ToAsciiExHanja(PCIMECtx pImeCtx, UINT uVirKey, CONST LPBYTE lpbKeyState);

PRIVATE WCHAR PASCAL Banja2Junja(WCHAR bChar);
PRIVATE BOOL  PASCAL IsKSC5601(WCHAR wcCur);


/*----------------------------------------------------------------------------
    ImeInquire

    This function handle initialization of IME. It also returns IMEINFO structure 
    and UI class name of IME
----------------------------------------------------------------------------*/
BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo, LPTSTR lpszWndClass, DWORD dwSystemInfoFlags)
{
    BOOL    fRet = fFalse;

    Dbg(DBGID_API, TEXT("ImeInquire():lpIMEInfo = 0x%08lX, dwSystemInfoFlags = 0x%08lX"), lpIMEInfo, dwSystemInfoFlags);

    if (lpIMEInfo)
        {
        lpIMEInfo->dwPrivateDataSize = sizeof(IMCPRIVATE);    // The private data in an IME context.
        lpIMEInfo->fdwProperty =  IME_PROP_AT_CARET            // IME conversion window is at caret position.
                                | IME_PROP_NEED_ALTKEY        // ALT key pass into ImeProcessKey
                                | IME_PROP_CANDLIST_START_FROM_1 // Candidate list start from 1
                                | IME_PROP_END_UNLOAD;

        if (IsMemphis() || IsWinNT5orUpper())
            lpIMEInfo->fdwProperty |= IME_PROP_COMPLETE_ON_UNSELECT; // Complete when IME unselected.

        lpIMEInfo->fdwConversionCaps =   IME_CMODE_NATIVE        // IMEs in NATIVE mode else ALPHANUMERIC mode
                                       | IME_CMODE_FULLSHAPE    // else in SBCS mode
                                       | IME_CMODE_HANJACONVERT;// Hangul hanja conversion

        lpIMEInfo->fdwSentenceCaps = 0;                            // IME sentence mode capability
        lpIMEInfo->fdwUICaps = 0;
        lpIMEInfo->fdwSCSCaps = SCS_CAP_COMPSTR;                // IME can generate the composition string by SCS_SETSTR
        lpIMEInfo->fdwSelectCaps = SELECT_CAP_CONVERSION;        // ImeSetCompositionString capability

        // Set Unicode flag if system support it
        if (vfUnicode == fTrue)
            lpIMEInfo->fdwProperty |= IME_PROP_UNICODE;    // String content of the Input Context will be UNICODE

        // NT5 Unicode injection through VK_PACKET
        if (IsWinNT5orUpper())
            lpIMEInfo->fdwProperty |= IME_PROP_ACCEPT_WIDE_VKEY;
            
        // Return Unicode string for Unicode environment
#ifndef UNDER_CE // Windows CE always Unicode
        if (vfUnicode == fTrue) 
            StrCopyW((LPWSTR)lpszWndClass, wszUIClassName);
        else
            lstrcpyA(lpszWndClass, szUIClassName);
#else // UNDER_CE
        lstrcpyW(lpszWndClass, wszUIClassName);
#endif // UNDER_CE

        fRet = fTrue;
        }
    
    //////////////////////////////////////////////////////////////////////////
    // 16 bit application check
    // If client is 16 bit Apps, only allow KS C-5601 chars.

    if (IsWinNT())
        {
        // Win98 does not pass dwSystemInfoFlags;
        vpInstData->dwSystemInfoFlags = dwSystemInfoFlags;
            
        if (dwSystemInfoFlags & IME_SYSINFO_WOW16)
            vpInstData->f16BitApps = fTrue;

        // If in MT setup mode(system setup, upgrading and OOBE), display IME status window.
        if (IsInSystemSetupMode())
            vpInstData->dwSystemInfoFlags |= IME_SYSINFO_WINLOGON;
        }
    else
        {
        // user GetProcessVersion
        DWORD dwVersion = GetProcessVersion(GetCurrentProcessId());
        // Windowss 3.x
        if (HIWORD(dwVersion) <= 3)
            {
            vpInstData->f16BitApps = fTrue;
        #ifdef DEBUG
            DebugOutT(TEXT("!!! 16bit Apps running under Win9x !!!\r\n"));
        #endif
            }
        }

    // If 16bit apps, always disable ISO10646(full range Hangul)
    if (vpInstData->f16BitApps == fTrue)
        vpInstData->fISO10646 = fFalse;
        
    return fRet;
}

/*----------------------------------------------------------------------------
    ImeConversionList

    obtain the list of candidate list from one character
----------------------------------------------------------------------------*/
DWORD WINAPI ImeConversionList(HIMC hIMC, LPCTSTR lpSource, LPCANDIDATELIST lpDest, DWORD dwBufLen, UINT uFlag)
{
    WCHAR wchHanja;

    Dbg(DBGID_API, TEXT("ImeConversionList():hIMC = 0x%08lX, *lpSource = %04X, dwBufLen =%08lX"), hIMC, *(LPWSTR)lpSource, dwBufLen);

    if (hIMC == NULL)
        return 0;
        
    if (lpSource == NULL || *(LPWSTR)lpSource == 0)
        return 0;

    // If dwBufLen==0 then should return buffer size
    if (dwBufLen && lpDest == NULL)
        return 0;

    //
    // Code Conversion
    //
    // CONFIRM: Win98 send Unicode or not?
    if (IsMemphis() || IsWinNT())
        wchHanja = *(LPWSTR)lpSource;
    else 
        {
        if (MultiByteToWideChar(CP_KOREA, MB_PRECOMPOSED, lpSource, 2, &wchHanja, 1) == 0)
            return 0;
        }

    switch (uFlag)
        {
        case GCL_CONVERSION:
            return GetConversionList(wchHanja, lpDest, dwBufLen);
            break;
        case GCL_REVERSECONVERSION:
        case GCL_REVERSE_LENGTH:
            break;
        default:
            DbgAssert(0);
        }
    return (0);
}

/*----------------------------------------------------------------------------
    ImeConfigure

    Open IME configuration DLG
----------------------------------------------------------------------------*/
BOOL WINAPI ImeConfigure(HKL hKL, HWND hWnd, DWORD dwMode, LPVOID lpData)
{
    BOOL fRet = fFalse;

    Dbg    (DBGID_API, TEXT("ImeConfigure():hKL = 0x%08lX, dwMode = 0x%08lX"), hKL, dwMode);
    
    switch (dwMode)
        {
        case IME_CONFIG_GENERAL:
            if (ConfigDLG(hWnd))
                fRet = fTrue;
            break;

        default:
            break;
        }
    return fRet;
}

/*----------------------------------------------------------------------------
    ImeDestroy
----------------------------------------------------------------------------*/
BOOL WINAPI ImeDestroy(UINT uReserved)
{
    Dbg(DBGID_API, TEXT("ImeDestroy(): Bye  *-<\r\nSee Again !"));
    if (uReserved)
        return (fFalse);
    else
        return (fTrue);
}

/*----------------------------------------------------------------------------
    ImeEscape

    Support Korean IME escape functions
----------------------------------------------------------------------------*/
LRESULT WINAPI ImeEscape(HIMC hIMC, UINT uSubFunc, LPVOID lpData)
{
    PCIMECtx     pImeCtx = GetIMECtx(hIMC);
    LRESULT        lRet;

    if (lpData == NULL || pImeCtx == NULL)
        return 0;
        
    Dbg(DBGID_API, TEXT("ImeEscape():hIMC = 0x%08lX, uSubFunc = 0x%08lX"), hIMC, uSubFunc);
    switch (uSubFunc)
        {
        case IME_ESC_AUTOMATA:
            lRet = EscAutomata(pImeCtx, (LPIMESTRUCT32)lpData, fTrue);
            break;

        case IME_AUTOMATA:
            lRet = EscAutomata(pImeCtx, (LPIMESTRUCT32)lpData, fFalse);
            break;

        case IME_GETOPEN:
            lRet = EscGetOpen(pImeCtx, (LPIMESTRUCT32)lpData);
            break;

        // Popup Hanja candidate window
        case IME_ESC_HANJA_MODE:
            if (lRet = EscHanjaMode(pImeCtx, (LPSTR)lpData, fTrue))
                {
                pImeCtx->SetCandidateMsg(CIMECtx::MSG_OPENCAND);
                pImeCtx->GenerateMessage();
                }
            break;

        // 16bit apps(Win 3.1) compatibility
        case IME_HANJAMODE:
            if (lRet = EscHanjaMode(pImeCtx, (LPSTR)lpData, fFalse))
                {
                pImeCtx->SetCandidateMsg(CIMECtx::MSG_OPENCAND);
                pImeCtx->GenerateMessage();
                }
            break;

        case IME_SETOPEN:
            lRet = EscSetOpen(pImeCtx, (LPIMESTRUCT32)lpData);
            break;

        case IME_MOVEIMEWINDOW:
            lRet = EscMoveIMEWindow(pImeCtx, (LPIMESTRUCT32)lpData);
            break;

        case 0x1100:
            lRet = EscGetIMEKeyLayout(pImeCtx, (LPIMESTRUCT32)lpData);
            break;

        default:
            Dbg(DBGID_Misc, TEXT("Unknown ImeEscape() subfunc(#0x%X) is called."), uSubFunc);
            return (0);
        }
    return (lRet);
    
}

/*----------------------------------------------------------------------------
    ImeSetActiveContext
----------------------------------------------------------------------------*/
BOOL WINAPI ImeSetActiveContext(HIMC hIMC, BOOL fActive)
{
    Dbg(DBGID_API, TEXT("ImeSetActiveContext():hIMC = 0x%08lX, fActive = 0x%d"), hIMC, fActive);

    // Initialize composition context. For Korean IME, don't need to kee composition str,
    // when context changed.
    //if (pImeCtx)
        //{
        //pImeCtx->ClearCompositionStrBuffer();
        //pImeCtx->GetAutomata()->InitState();
        //pImeCtx->ResetComposition();
        //}
// CONFIRM: Is this really safe to disable?
#if 0
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;

    Dbg(DBGID_API, _T("ImeSetActiveContext():hIMC = 0x%08lX, fActive = 0x%d"), hIMC, fActive);

    if (!hIMC)
        return fFalse;

    lpIMC = ImmLockIMC(hIMC);
    if (!lpIMC)
        return fFalse;

    if (fActive)
        {
        if (lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr)) 
            {
            if (lpCompStr->dwCompStrLen)
                {
                 CIMEData            ImeData;

                // if composition character mismatched with Automata object's reset with lpCompStr
                // I'm really suspicious when this situation occurs. I think never occur... -cslim
                if (pInstData->pMachine->GetCompositionChar()
                    != *(LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset)) 
                    {
                    pInstData->pMachine->InitState();
                    pInstData->pMachine->
                        SetCompositionChar(*(LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset));
                    }
                }
            ImmUnlockIMCC(lpIMC->hCompStr);
            }
        }

    ImmUnlockIMC(hIMC);
#endif

    return fTrue;
}

/*----------------------------------------------------------------------------
    ImeProcessKey

    Return fTrue if IME should process the key
----------------------------------------------------------------------------*/
BOOL WINAPI ImeProcessKey(HIMC hIMC, UINT uVirKey, LPARAM lParam, CONST LPBYTE lpbKeyState)
{
    PCIMECtx pImeCtx;
    WORD     uScanCode;
    BOOL     fRet = fFalse;

    Dbg(DBGID_API, TEXT("ImeProcessKey():hIMC=0x%08lX, uVKey=0x%04X, lParam=0x%08lX"), hIMC, uVirKey, lParam);

    if (lpbKeyState == NULL)
        return fFalse;
    
    // NT5 Unicode injection
    uVirKey   = (UINT)LOWORD(uVirKey);
    uScanCode = HIWORD(lParam);
    
    if (uVirKey == VK_PROCESSKEY)    // Mouse button clicked
        { 
        Dbg(DBGID_Key, TEXT("ImeProcessKey : return fTrue - Mouse Button Pressed"));
        return fTrue;
        } 
    else if (uScanCode & KF_UP) 
        {
        Dbg(DBGID_Key, TEXT("ImeProcessKey : return fFalse - KF_UP"));
        return (fFalse);
        } 
    else if (uVirKey == VK_SHIFT) // no SHIFT key
        {
        Dbg(DBGID_Key, TEXT("ImeProcessKey : return fFalse - VK_SHIFT"));
        return (fFalse);
        } 
    else if (uVirKey == VK_CONTROL) // no CTRL key
        {
        Dbg(DBGID_Key, TEXT("ImeProcessKey : return fFalse - VK_CONTROL"));
        return (fFalse);
        } 
    else if (uVirKey == VK_HANGUL || uVirKey == VK_JUNJA || uVirKey == VK_HANJA) 
        {
         Dbg(DBGID_Key, TEXT("ImeProcessKey : return fTrue - VK_HANGUL, VK_JUNJA, VK_HANJA"));
        return (fTrue);
        }
    else 
        {
        // need more check
        }

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;
    
    // If IME close, return with no action.
    if (pImeCtx->IsOpen() == fFalse)
        {              
        Dbg(DBGID_Key, TEXT("ImeProcessKey : return fFalse - IME closed"));
        return fFalse;
        }

    // If Hanja conv mode return fTrue. ImeToAsciiEx will handle.
    if (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)
        {
        return fTrue;
        }
    
    // If interim state
    if (pImeCtx->GetCompBufLen())
        {
        // If ALT key down and in composition process, finalize it.
        if (uVirKey == VK_MENU) 
            {
            Dbg(DBGID_Key, TEXT("ImeProcessKey : Finalize and return fFalse - VK_MENU"));
            pImeCtx->FinalizeCurCompositionChar();
            pImeCtx->GenerateMessage();
            }
        else 
            {
            Dbg(DBGID_Key, TEXT("ImeProcessKey : Interim state. Key pressed except ALT"));
            fRet = fTrue;
            }
        } 
    else // If composition string does not exist,
        {         
        // if Ctrl+xx key, do not process in non-interim mode
        if (IsControlKeyPushed(lpbKeyState) == fFalse)
            {
            // If Hangul mode
            if (pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) 
                {    // Start of hangul composition
                WORD         wcCur = 0;

                if (pImeCtx->GetAutomata() != NULL)
                    {
                    wcCur = pImeCtx->GetAutomata()->GetKeyMap(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 );
                    }
                // 2beolsik Alphanumeric keys have same layout as English key
                // So we don't need process when user pressed Alphanumeric key under 2beolsik
                if ( (wcCur && pImeCtx->GetGData() && pImeCtx->GetGData()->GetCurrentBeolsik() != KL_2BEOLSIK) || (wcCur & H_HANGUL) )
                    fRet = fTrue;
                }

            // if IME_CMODE_FULLSHAPE
            if (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE) 
                {
                if (CHangulAutomata::GetEnglishKeyMap(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0))
                    fRet = fTrue;
                }
            }
        }

    // NT 5 Unicode injection
    if (uVirKey == VK_PACKET)
        {
        Dbg(DBGID_Key, TEXT("ImeProcessKey : VK_PACKET"));
        fRet = fTrue;
        }
        
    Dbg(DBGID_Key, TEXT("ImeProcessKey : return value = %d"), fRet);
    return fRet;
}

/*----------------------------------------------------------------------------
    NotifyIME

    Change the status of IME according to the given parameter
----------------------------------------------------------------------------*/
BOOL WINAPI NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
{
    PCIMECtx          pImeCtx;
    BOOL             fRet = fFalse;

    Dbg(DBGID_API, TEXT("NotifyIME():hIMC = 0x%08lX, dwAction = 0x%08lX, dwIndex = 0x%08lX, dwValue = 0x%08lX"), hIMC, dwAction, dwIndex, dwValue);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;

    switch (dwAction)
        {
    case NI_COMPOSITIONSTR:
           switch (dwIndex)
            {
        //////////////////////////////////////////////////////////
        case CPS_COMPLETE:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_COMPOSITIONSTR-CPS_COMPLETE"));

            // If composition state
            if (pImeCtx->GetCompBufLen()) 
                {
                // For ESC_HANJAMODE call this, we should reset comp str.
                pImeCtx->ResetComposition();
                pImeCtx->SetResultStr(pImeCtx->GetCompBufStr());
                pImeCtx->SetEndComposition(fTrue);
                pImeCtx->StoreComposition();

                // Raid #104
                if (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)
                    {
                    // Cancel Hanja change mode
                    pImeCtx->SetConversionMode(pImeCtx->GetConversionMode() & ~IME_CMODE_HANJACONVERT);
                    pImeCtx->SetCandidateMsg(CIMECtx::MSG_CLOSECAND);
                    }

                // Clear all automata states
                pImeCtx->GetAutomata()->InitState();
                pImeCtx->GenerateMessage();

                fRet = fTrue;
                }
            break;
    
        //////////////////////////////////////////////////////////
        case CPS_CANCEL:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_COMPOSITIONSTR-CPS_CANCEL"));

            // if composition string exist, remove it and send WM_IME_ENDCOMPOSITION
            if (pImeCtx->GetCompBufLen())
                {
                pImeCtx->SetEndComposition(fTrue);
                pImeCtx->GenerateMessage();
                pImeCtx->ClearCompositionStrBuffer();
                
                fRet = fTrue;
                }
            break;
        
        //////////////////////////////////////////////////////////                    
        case CPS_CONVERT: 
        case CPS_REVERT:

        default:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_COMPOSITIONSTR-CPS_CONVERT or CPS_REVERT !!! NOT IMPMLEMENTED !!!"));
            break;
            } // switch (dwIndex)
        break;

    case NI_OPENCANDIDATE:
        Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_OPENCANDIDATE"));
        // if not Hanja mocde
        if (!(pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT))
            {
            if (pImeCtx->GetCompBufLen() && GenerateHanjaCandList(pImeCtx))
                {
                pImeCtx->SetCandidateMsg(CIMECtx::MSG_OPENCAND);
                // Set Hanja conv mode
                pImeCtx->SetConversionMode(pImeCtx->GetConversionMode() | IME_CMODE_HANJACONVERT);
                OurSendMessage(pImeCtx->GetAppWnd(), WM_IME_NOTIFY, IMN_SETCONVERSIONMODE, 0L);
                pImeCtx->GenerateMessage();
                fRet = fTrue;
                }
            }
        break;

    case NI_CLOSECANDIDATE:
        if (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)
            {
            pImeCtx->SetCandidateMsg(CIMECtx::MSG_CLOSECAND);
            // Set clear Hanja conv mode
            pImeCtx->SetConversionMode(pImeCtx->GetConversionMode() & ~IME_CMODE_HANJACONVERT);
            // To Notify to UI wnd
            OurSendMessage(pImeCtx->GetAppWnd(), WM_IME_NOTIFY, IMN_SETCONVERSIONMODE, 0L);
            pImeCtx->GenerateMessage();
            fRet = fTrue;
            }
        break;

    case NI_SELECTCANDIDATESTR:
    case NI_SETCANDIDATE_PAGESTART:
        Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_SETCANDIDATE_PAGESTART"));
        if (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)
            {
            pImeCtx->SetCandStrSelection(dwValue);
            pImeCtx->SetCandidateMsg(CIMECtx::MSG_CHANGECAND);
            pImeCtx->GenerateMessage();
            fRet = fTrue;
            }
        break;

    case NI_CONTEXTUPDATED:
        Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_CONTEXTUPDATED"));
        switch (dwValue)
            {
        case IMC_SETOPENSTATUS:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_CONTEXTUPDATED - IMC_SETOPENSTATUS"));
            Dbg(DBGID_IMENotify, TEXT("pImeCtx->GetConversionMode() = 0x%08lX"), pImeCtx->GetConversionMode());
            UpdateOpenCloseState(pImeCtx);
            fRet = fTrue;
            break;                        

        case IMC_SETCONVERSIONMODE:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_CONTEXTUPDATED - IMC_SETCONVERSIONMODE"));
            Dbg(DBGID_IMENotify, TEXT("pImeCtx->GetConversionMode() = 0x%08lX"), pImeCtx->GetConversionMode());
            UpdateOpenCloseState(pImeCtx);
            fRet = fTrue;
            break;                        
        //case IMC_SETSTATUSWINDOWPOS:
        case IMC_SETCANDIDATEPOS:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_SETCOMPOSITIONWINDOW:
            //DbgAssert(0);
            fRet = fTrue;
            break;

        default:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_CONTEXTUPDATED - Unhandeled IMC value = 0x%08lX"), dwValue);
            break;
            } // switch (dwValue)
        break;
            
    case NI_IMEMENUSELECTED:
        Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_IMEMENUSELECTED"));
        switch (dwIndex) 
            {
        case IDIM_ROOT_MR_1:
            // BUGBUG: NT Bug #379149
            // Because Internat uses SendMessage, If user does not cancel the DLG, Deadlock occurs.
            // ImeConfigure(GetKeyboardLayout(NULL), pImeCtx->GetAppWnd(), IME_CONFIG_GENERAL, NULL);
            OurPostMessage(GetActiveUIWnd(), WM_MSIME_PROPERTY, 0L, IME_CONFIG_GENERAL);
            break;
        case IDIM_ROOT_ML_4: 
            fRet = OurImmSetConversionStatus(hIMC, 
                    (pImeCtx->GetConversionMode() & ~IME_CMODE_HANGUL) | IME_CMODE_FULLSHAPE,
                    pImeCtx->GetSentenceMode());
            break;
        case IDIM_ROOT_ML_3:
            fRet = OurImmSetConversionStatus(hIMC, 
                    pImeCtx->GetConversionMode() & ~(IME_CMODE_HANGUL | IME_CMODE_FULLSHAPE),
                    pImeCtx->GetSentenceMode());
            break;
        case IDIM_ROOT_ML_2: 
            fRet = OurImmSetConversionStatus(hIMC, 
                    pImeCtx->GetConversionMode() | IME_CMODE_HANGUL | IME_CMODE_FULLSHAPE,
                    pImeCtx->GetSentenceMode());
            break;
        case IDIM_ROOT_ML_1:
            fRet = OurImmSetConversionStatus(hIMC, 
                    (pImeCtx->GetConversionMode() | IME_CMODE_HANGUL) & ~IME_CMODE_FULLSHAPE,
                    pImeCtx->GetSentenceMode());
            break;
            } //         switch (dwIndex) 
        break;
        
    case NI_CHANGECANDIDATELIST:
    case NI_FINALIZECONVERSIONRESULT:
    case NI_SETCANDIDATE_PAGESIZE:
        default:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): Unhandeled NI_ value = 0x%08lX"), dwAction);
        break;
        } // switch (dwAction)

    return fRet;
}

/*----------------------------------------------------------------------------
    ImeSelect

    Initialize/Uninitialize IME private context
----------------------------------------------------------------------------*/
BOOL WINAPI ImeSelect(HIMC hIMC, BOOL fSelect)    // fTrue-initialize, fFalse-uninitialize(free resource)
{
    BOOL fRet = fFalse;

    Dbg(DBGID_API, TEXT("ImeSelect():hIMC = 0x%08lX, fSelect = 0x%d"), hIMC, fSelect);

    if (!hIMC) // if invalid input context handle
        {
        DbgAssert(0);
        return fFalse;
        }

    // If DLL_PROCESS_DETACH already called once.
    if (vfDllDetachCalled)
        {
        return fFalse;
        }
    fRet = Select(hIMC, fSelect);

    return fRet;
}

/*----------------------------------------------------------------------------
    ImeSetCompositionString
----------------------------------------------------------------------------*/
BOOL WINAPI ImeSetCompositionString(HIMC hIMC, DWORD dwIndex, LPVOID lpComp,
                                    DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
{
    PCIMECtx     pImeCtx;
    WCHAR        wcComp;
    BOOL        fSendStart, 
                fRet = fFalse;

    Dbg(DBGID_API|DBGID_SetComp, TEXT("ImeSetCompositionString():hIMC = 0x%08lX, dwIndex = 0x%08lX, lpComp = 0x%04X"), hIMC, dwIndex, *(LPWSTR)lpComp);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;

    if (dwIndex == SCS_SETSTR)
        {
        // Conv mode check
        if ((pImeCtx->GetConversionMode() & IME_CMODE_HANGUL)==0)
            {
            Dbg(DBGID_API|DBGID_SetComp, TEXT("!!! WARNING !!!: ImeSetCompositionString(): English mode"));
            return fFalse;
            }

        // Send WM_IME_STARTCOMPOSITION if not interim state.
        fSendStart = pImeCtx->GetCompBufLen() ? fFalse : fTrue;

        wcComp = L'\0';
        // Parameter check
        if (lpComp != NULL && *(LPWSTR)lpComp != L'\0' && dwCompLen != 0)
            {
            if (pImeCtx->IsUnicodeEnv())
                wcComp = *(LPWSTR)lpComp;
            else
                if (MultiByteToWideChar(CP_KOREA, MB_PRECOMPOSED, (LPSTR)lpComp, 2, &wcComp, 1) == 0)
                    {
                    DbgAssert(0);
                    wcComp = 0;
                    }

            // Hangul range check
            if ( (wcComp > 0x3130  && wcComp < 0x3164) || 
                 (wcComp >= 0xAC00 && wcComp < 0xD7A4) )
                {
                pImeCtx->SetCompositionStr(wcComp);
                pImeCtx->StoreComposition();
                }
            else
                {
                Dbg(DBGID_SetComp, TEXT("!!! WARNING !!!: lpComp is null or Input character is not Hangul"));
                DbgAssert(0);
                wcComp = 0;
                }
            }

        // Send WM_IME_STARTCOMPOSITION
        if (fSendStart)
            pImeCtx->SetStartComposition(fTrue);

        // REVIEW: Even if wcComp ==0, Should send WM_IME_COMPOSITION
        // Send composition char
        //SetTransBuffer(lpTransMsg, WM_IME_COMPOSITION, 
        //                (WPARAM)wcComp, (GCS_COMPSTR|GCS_COMPATTR|CS_INSERTCHAR|CS_NOMOVECARET));

        // Set Automata state if non-null comp char
        if (wcComp) 
            pImeCtx->GetAutomata()->SetCompositionChar(wcComp);
        else
            {
            // REVIEW: Even if wcComp ==0, Should send WM_IME_COMPOSITION
            pImeCtx->ClearCompositionStrBuffer();
            pImeCtx->AddMessage(WM_IME_COMPOSITION, 0, (GCS_COMPSTR|GCS_COMPATTR|CS_INSERTCHAR|CS_NOMOVECARET));
            pImeCtx->SetEndComposition(fTrue);
            pImeCtx->GetAutomata()->InitState();
            }

        // Generate IME message
        pImeCtx->GenerateMessage();

        fRet = fTrue;
        }

    return fRet;
}
    
/*----------------------------------------------------------------------------
    ImeToAsciiEx
----------------------------------------------------------------------------*/
UINT WINAPI ImeToAsciiEx(UINT uVirKey, UINT uScanCode, CONST LPBYTE lpbKeyState,
                         LPTRANSMSGLIST lpTransBuf, UINT fuState, HIMC hIMC)
{
    PCIMECtx pImeCtx;
    UINT     uNumMsg=0;
    WORD     bKeyCode;

    Dbg(DBGID_API, TEXT("ImeToAsciiEx(): hIMC = 0x%08lX, uVirKey = 0x%04X, uScanCode = 0x%04X"), hIMC, uVirKey, uScanCode);
    Dbg(DBGID_Key, TEXT("lpbKeyState = 0x%08lX, lpdwTransBuf = 0x%08lX, fuState = 0x%04X"), lpbKeyState, lpTransBuf, fuState);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return 0;

    // Start process key
    pImeCtx->SetProcessKeyStatus(fTrue);

    // special message buffer for ToAsciiEx()
    pImeCtx->SetTransMessage(lpTransBuf);

    ///////////////////////////////////////////////////////////////////////////
    // If Hanja conv mode
    if (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)
        {
        if (ToAsciiExHanja(pImeCtx, uVirKey, lpbKeyState) == fFalse)
            goto ToAsciiExExit_NoMsg;
        }
    else
        {
        ///////////////////////////////////////////////////////////////////////////
        // W2K specific - Unicode injection
        if (LOWORD(uVirKey) == VK_PACKET) 
            {
            WCHAR wch = HIWORD(uVirKey);
            Dbg(DBGID_Key, TEXT("ImeToAsciiEx: VK_PACKET arrived(NonHanja conv mode)"));

            // If composition char exist, first finalize and append injection char, then send all.
            if (pImeCtx->GetCompBufLen()) 
                {
                pImeCtx->FinalizeCurCompositionChar();
                pImeCtx->AppendResultStr(wch);
                }
            else
                // If no composition char exist, just insert injection char as finalized char.
                pImeCtx->SetResultStr(wch);
            goto ToAsciiExExit;
            }

        ///////////////////////////////////////////////////////////////////////////
        // If Non-Hanja conv mode
        switch (uVirKey) 
            {
        case VK_PROCESSKEY:    // if mouse button clicked 
            Dbg(DBGID_Key, TEXT("ImeToAsciiEx : VK_PROCESSKEY"));
            if (pImeCtx->GetCompBufLen()) 
                pImeCtx->FinalizeCurCompositionChar();
            break;
        
        case VK_HANGUL :
            Dbg(DBGID_Key, "             -  VK_HANGUL");
            if (pImeCtx->GetCompBufLen()) 
                pImeCtx->FinalizeCurCompositionChar();

            OurImmSetConversionStatus(hIMC, 
                                    pImeCtx->GetConversionMode()^IME_CMODE_HANGUL, 
                                    pImeCtx->GetSentenceMode());
            UpdateOpenCloseState(pImeCtx);
            break;

        case VK_JUNJA :
            Dbg(DBGID_Key, TEXT("             -  VK_JUNJA"));
            if (pImeCtx->GetCompBufLen()) 
                pImeCtx->FinalizeCurCompositionChar();

            pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);

            OurImmSetConversionStatus(hIMC, 
                                        pImeCtx->GetConversionMode()^IME_CMODE_FULLSHAPE,
                                        pImeCtx->GetSentenceMode());
            UpdateOpenCloseState(pImeCtx);
            break;

        case VK_HANJA :
            Dbg(DBGID_Key, TEXT("             -  VK_HANJA"));
            if (pImeCtx->GetCompBufLen())
                {
                // Keep current composition str
                pImeCtx->SetCompositionStr(pImeCtx->GetCompBufStr());
                if (GenerateHanjaCandList(pImeCtx))
                    {
                    pImeCtx->SetCandidateMsg(CIMECtx::MSG_OPENCAND);
                    OurImmSetConversionStatus(hIMC, 
                                            pImeCtx->GetConversionMode() | IME_CMODE_HANJACONVERT, 
                                            pImeCtx->GetSentenceMode());
                    }
                }
            else
                pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);
            break;

        default :
            // if hangul mode
            if (pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) 
                ToAsciiExHangulMode(pImeCtx, uVirKey, uScanCode, lpbKeyState);
            else 
                // if junja mode
                if (    (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE)
                     && (bKeyCode = CHangulAutomata::GetEnglishKeyMap(uVirKey, 
                                    (IsShiftKeyPushed(lpbKeyState) ? 1 : 0))) )
                    {
                    if (uVirKey >= 'A' && uVirKey <= 'Z') 
                        {
                        bKeyCode = CHangulAutomata::GetEnglishKeyMap(uVirKey, 
                                    (IsShiftKeyPushed(lpbKeyState) ? 1 : 0) 
                                     ^ ((lpbKeyState[VK_CAPITAL] & 0x01) ? 1: 0));
                        }
                        
                    bKeyCode = Banja2Junja(bKeyCode);
                    pImeCtx->SetResultStr(bKeyCode);
                    }
                // Unknown mode
                else 
                    {
                    DbgAssert(0);
                    pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);
                    }
            } // switch (uVirKey) 
        }
        
ToAsciiExExit:
    pImeCtx->StoreComposition();
    //pImeCtx->StoreCandidate();
    pImeCtx->FinalizeMessage();    // final setup for IME Messages

ToAsciiExExit_NoMsg:
    uNumMsg = pImeCtx->GetMessageCount();
    pImeCtx->ResetMessage();    // reset
    pImeCtx->SetTransMessage((LPTRANSMSGLIST)NULL);// start process key
    pImeCtx->SetProcessKeyStatus(fFalse);

    return (uNumMsg);
}

/*----------------------------------------------------------------------------
    ToAsciiExHangulMode

    Subroutine used by ImeToAsciiEx.
----------------------------------------------------------------------------*/
VOID PASCAL ToAsciiExHangulMode(PCIMECtx pImeCtx, UINT uVirKey, UINT uScanCode, CONST LPBYTE lpbKeyState)
{
    CHangulAutomata* pAutomata;
    WCHAR              wcCur;
    UINT              uNumMsg=0;

    Dbg(DBGID_API, TEXT("ToAsciiExHangulMode()"));
    pAutomata = pImeCtx->GetAutomata();
    DbgAssert(pAutomata != NULL);
    
    switch (uVirKey) 
        {
    ///////////////////////////////////////////////////////////
    // Back space processing
    case VK_BACK :
        Dbg(DBGID_Key, TEXT("ImeToAsciiEx : VK_BACK"));
        if (pAutomata->BackSpace()) 
            {
            wcCur = pAutomata->GetCompositionChar();
            if (pImeCtx->GetGData() && pImeCtx->GetGData()->GetJasoDel() == fFalse) 
                {
                pAutomata->InitState();
                wcCur = 0;
                }

            if (wcCur) 
                {
                pImeCtx->SetCompositionStr(wcCur);
                break;
                }
            else 
                {
                Dbg(DBGID_Key, TEXT("ImeToAsciiEx : VK_BACK - Empty char"));

                // Send Empty Composition stringto clear message
                pImeCtx->AddMessage(WM_IME_COMPOSITION, 0, (GCS_COMPSTR|GCS_COMPATTR|CS_INSERTCHAR|CS_NOMOVECARET));
                
                // Send Close composition window message
                pImeCtx->SetEndComposition(fTrue);
                break;
                }
            }
        else 
            {
            // BUG :
            DbgAssert(0);
            // Put the Backspace message into return buffer.
            pImeCtx->AddMessage(WM_CHAR, (WPARAM)VK_BACK, (LPARAM)0x000E0001L); //(uScanCode << 16) | 1UL
            }
        break;

    default :
        // Ctrl+xx processing bug #60
        if (IsControlKeyPushed(lpbKeyState)) 
            {
            pImeCtx->FinalizeCurCompositionChar();
            pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);
            }
        else
            switch (pAutomata->Machine(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 ))
                {
            case HAUTO_COMPOSITION:
                // Send start composition msg. if no composition exist.
                if (pImeCtx->GetCompBufLen() == 0)
                    pImeCtx->SetStartComposition(fTrue);

                // Get Current composition char
                wcCur = pAutomata->GetCompositionChar();

                // if ISO10646 flag disabled, should permit only KSC5601 chars
                if (vpInstData->fISO10646== fFalse)
                    {
                    Dbg(DBGID_API, TEXT("ToAsciiExHangulMode - ISO10646 Off"));
                    if (IsKSC5601(wcCur) == fFalse) 
                        {
                        Dbg(DBGID_API, TEXT("ToAsciiExHangulMode - Non KSC5601 char"));
                        // To cancel last Jaso
                        pAutomata->BackSpace();
                        // Complete
                        pAutomata->MakeComplete();
                        pImeCtx->SetResultStr(pAutomata->GetCompleteChar());
                        // Run Automata again
                        pAutomata->Machine(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 );
                        wcCur = pAutomata->GetCompositionChar();
                        }
                    }

                pImeCtx->SetCompositionStr(wcCur);
                break;

            case HAUTO_COMPLETE:
                pImeCtx->SetResultStr(pAutomata->GetCompleteChar());
                pImeCtx->SetCompositionStr(pAutomata->GetCompositionChar());
                break;

            ////////////////////////////////////////////////////////
            // User pressed Alphanumeric key.
            // When user type alphanumeric char in interim state.
            // ImeProcessKey should guarantee return fTrue only if 
            // hangul key pressed or alphanumeric key(including special keys) 
            // pressed in interim state or Fullshape mode.
            case HAUTO_NONHANGULKEY:
                wcCur = pAutomata->GetKeyMap(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0);
                    
                if (wcCur && (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE))
                    wcCur = Banja2Junja(wcCur);

                // if interim state
                if (pImeCtx->GetCompBufLen()) 
                    {
                    //DbgAssert(lpImcP->fdwImeMsg & MSG_ALREADY_START);
                    pImeCtx->FinalizeCurCompositionChar();
                    if (wcCur)
                        pImeCtx->AppendResultStr(wcCur);
                    else
                        pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);
                    } 
                else // Not interim state
                    {    
                    if (wcCur)
                        pImeCtx->SetResultStr(wcCur);
                    else
                        // if not alphanumeric key(special key), just send it to App
                        pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);
                    }
                break;

            default :
            DbgAssert(0);
                } // switch (pAutomata->Machine(uVirKey, (lpbKeyState[VK_SHIFT] & 0x80) ? 1 : 0 ) ) 
        } // switch (uVirKey) 
    
    return;
}

/*----------------------------------------------------------------------------
    ToAsciiExHanja

    Subroutine used by ImeToAsciiEx. Handle key code in Hanja conversion mode on

    Returns True only if there is message need to generated.
----------------------------------------------------------------------------*/
BOOL PASCAL ToAsciiExHanja(PCIMECtx pImeCtx, UINT uVirKey, CONST LPBYTE lpbKeyState)
{
    UINT             uNumMsg = 0;
    DWORD           iStart;
    WORD            bKeyCode;
    LPCANDIDATELIST lpCandList;
    WCHAR            wcHanja, wchInject;

    Dbg(DBGID_Hanja, TEXT("ToAsciiExHanja(): IME_CMODE_HANJACONVERT"));

       
    // if Left Alt key or Ctrl+xx down or no cand info.
    if (pImeCtx->GetPCandInfo() == NULL || pImeCtx->GetPCandInfo()->dwCount == 0)
        {
        Dbg(DBGID_Hanja, TEXT("ToAsciiExHanja(): WARNING no cand info. send MSG_CLOSE_CANDIDATE"));
        pImeCtx->SetCandidateMsg(CIMECtx::MSG_CLOSECAND);
        // Cancel Hanja conversion mode
        OurImmSetConversionStatus(pImeCtx->GetHIMC(), 
                                  pImeCtx->GetConversionMode() & ~IME_CMODE_HANJACONVERT, 
                                  pImeCtx->GetSentenceMode());
        return fTrue;
        }

    wchInject = HIWORD(uVirKey);
    uVirKey   = LOWORD(uVirKey);
    
    lpCandList = (LPCANDIDATELIST)((LPBYTE)pImeCtx->GetPCandInfo() + sizeof(CANDIDATEINFO));
    iStart = (lpCandList->dwSelection / lpCandList->dwPageSize) * lpCandList->dwPageSize;

    // FIXED : In Hanja conversion mode, for selection candidate, use english keymap
    bKeyCode = CHangulAutomata::GetEnglishKeyMap(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 );
    if (bKeyCode && (uVirKey != VK_PACKET))
        {
        if (bKeyCode >= '1' && bKeyCode <= '9' 
            && iStart + bKeyCode - '1' < lpCandList->dwCount)
            {
            wcHanja = pImeCtx->GetCandidateStr(iStart + bKeyCode - '1');
            Dbg(DBGID_Hanja, TEXT("ImeToAsciiEx-HANJACONVERT : wcHanja = 0x%04X"), wcHanja);

            pImeCtx->SetEndComposition(fTrue);
            pImeCtx->SetCandidateMsg(CIMECtx::MSG_CLOSECAND);
            pImeCtx->SetResultStr(wcHanja);

            OurImmSetConversionStatus(pImeCtx->GetHIMC(), 
                                        pImeCtx->GetConversionMode() & ~IME_CMODE_HANJACONVERT,
                                        pImeCtx->GetSentenceMode());
            // pImeCtx->ClearCompositionStrBuffer();
            }
        else
            goto Exit_NoHandledKey;
        }
    else
        {
        switch (uVirKey)
            {
            case VK_HANJA :
            case VK_ESCAPE :
            case VK_PROCESSKEY :
            case VK_HANGUL :
            // Added for left and right Window buttons
            case VK_LWIN : case VK_RWIN : 
            case VK_APPS :
            case VK_MENU :
            case VK_PACKET :
                // FIXED : Bug #27
                // Word notify CPS_COMPLETE when user ALT down in hanja conv mode
                // then send double finalize char
                // check if composition char exist
                DbgAssert(pImeCtx->GetCompBufLen()); // Comp string should be exist in Hanja conv mode.
                if (pImeCtx->GetCompBufLen()) 
                    {
                    // FIXED : if ESC_HANJA called, MSG_ALREADY_START is not set
                    //           This prevent MSG_END_COMPOSITION.
                    pImeCtx->SetEndComposition(fTrue);
                    pImeCtx->SetResultStr(pImeCtx->GetCompBufStr());
                    
                    // Unicode injection
                    if (uVirKey == VK_PACKET)
                        {
                        Dbg(DBGID_Key|DBGID_Hanja, TEXT("ImeToAsciiEx: VK_PACKET arrived(Hanja conv mode Comp char exist) - Append 0x%x"), wchInject);
                        pImeCtx->AppendResultStr(wchInject);
                        }
                    }

                pImeCtx->SetCandidateMsg(CIMECtx::MSG_CLOSECAND);

                // Cancel Hanja conversion mode
                OurImmSetConversionStatus(pImeCtx->GetHIMC(), 
                                        pImeCtx->GetConversionMode() & ~IME_CMODE_HANJACONVERT, 
                                        pImeCtx->GetSentenceMode());
                break;

            case VK_LEFT :
                if (iStart)
                    {
                    lpCandList->dwPageStart -= CAND_PAGE_SIZE;
                    lpCandList->dwSelection -= CAND_PAGE_SIZE;
                    pImeCtx->SetCandidateMsg(CIMECtx::MSG_CHANGECAND);
                    }
                else
                    goto Exit_NoHandledKey;

                // Keep current composition str
                   pImeCtx->SetCompositionStr(pImeCtx->GetCompBufStr());
                break;

            case VK_RIGHT :
                if (iStart + CAND_PAGE_SIZE < lpCandList->dwCount)
                    { 
                    lpCandList->dwPageStart += CAND_PAGE_SIZE;
                    lpCandList->dwSelection += CAND_PAGE_SIZE;
                    pImeCtx->SetCandidateMsg(CIMECtx::MSG_CHANGECAND);
                    }
                else
                    goto Exit_NoHandledKey;

                // Keep current composition str
                pImeCtx->SetCompositionStr(pImeCtx->GetCompBufStr());
                break;

            default :
                // Keep current composition str
                // pImeCtx->SetCompositionStr(pImeCtx->GetCompBufStr());
                goto Exit_NoHandledKey;
            }
        }

    return fTrue;
    
Exit_NoHandledKey:
    MessageBeep(MB_ICONEXCLAMATION);
    return fFalse;
}

/*----------------------------------------------------------------------------
    ImeRegisterWord

    NOT USED
----------------------------------------------------------------------------*/
BOOL WINAPI ImeRegisterWord(LPCTSTR lpszReading, DWORD dwStyle, LPCTSTR lpszString)
{
    Dbg(DBGID_API, TEXT("ImeRegisterWord() : NOT IMPLEMENTED"));
    return fFalse;
}

/*----------------------------------------------------------------------------
    ImeUnregisterWord

    NOT USED
----------------------------------------------------------------------------*/
BOOL WINAPI ImeUnregisterWord(LPCTSTR lpszReading, DWORD dwStyle, LPCTSTR lpszString)
{
    Dbg(DBGID_API, TEXT("ImeUnregisterWord() : NOT IMPLEMENTED"));
    return fFalse;
}

/*----------------------------------------------------------------------------
    ImeGetRegisterWordStyle

    NOT USED
----------------------------------------------------------------------------*/
UINT WINAPI ImeGetRegisterWordStyle(UINT nItem, LPSTYLEBUF lpStyleBuf)
{
    Dbg(DBGID_API, TEXT("ImeGetRegisterWordStyle() : NOT IMPLEMENTED"));
    return (0);
}

/*----------------------------------------------------------------------------
    ImeEnumRegisterWord

    NOT USED
----------------------------------------------------------------------------*/
UINT WINAPI ImeEnumRegisterWord(REGISTERWORDENUMPROC lpfnRegisterWordEnumProc,
            LPCTSTR lpszReading, DWORD dwStyle, LPCTSTR lpszString, LPVOID lpData)
{
    Dbg(DBGID_API, TEXT("ImeEnumRegisterWord() : NOT IMPLEMENTED"));
    return (0);
}

/*----------------------------------------------------------------------------
    ImeGetImeMenuItems
----------------------------------------------------------------------------*/
DWORD WINAPI ImeGetImeMenuItems(HIMC hIMC, DWORD dwFlags, DWORD dwType, 
                                LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, 
                                DWORD dwSize)
{
    PCIMECtx     pImeCtx;
    DWORD        dwNumOfItems=0;

    Dbg(DBGID_API, TEXT("ImeGetImeMenuItems() : "));

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return 0;
    
    if (!lpImeMenu)
        {
        if (!lpImeParentMenu)
            {
            if (dwFlags & IGIMIF_RIGHTMENU)
                dwNumOfItems = NUM_ROOT_MENU_R;
            else
                dwNumOfItems = NUM_ROOT_MENU_L;
            goto ImeGetImeMenuItemsExit;
            }
        else
            {
            if (dwFlags & IGIMIF_RIGHTMENU)
                dwNumOfItems = NUM_SUB_MENU_R;
            else
                dwNumOfItems = NUM_SUB_MENU_L;
            goto ImeGetImeMenuItemsExit;
            }
        return 0;
        }

    if (!lpImeParentMenu)  
        {
        if (dwFlags & IGIMIF_RIGHTMENU)
            {
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFOW);
            lpImeMenu->fType = 0;
            lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_ROOT_MR_1;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            OurLoadStringW(vpInstData->hInst, IDS_CONFIG, lpImeMenu->szString, IMEMENUITEM_STRING_SIZE);
            lpImeMenu->hbmpItem = 0;

            dwNumOfItems = NUM_ROOT_MENU_R;
            }
        else // Left Menu
            {
            // 1. Hangul Halfshape menu
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFOW);
            lpImeMenu->fType = IMFT_RADIOCHECK;
            if ((pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) && 
                !(pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE))
                lpImeMenu->fState = IMFS_CHECKED;
            else
                lpImeMenu->fState = 0;

            lpImeMenu->wID = IDIM_ROOT_ML_1;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            OurLoadStringW(vpInstData->hInst, IDS_IME_HANGUL_HALF, lpImeMenu->szString, IMEMENUITEM_STRING_SIZE);
            lpImeMenu->hbmpItem = 0;

            // 2. Hangul Fullshape menu
            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFOW);
            lpImeMenu->fType = IMFT_RADIOCHECK;
            if ((pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) && 
                (pImeCtx->GetConversionMode()& IME_CMODE_FULLSHAPE))
                lpImeMenu->fState = IMFS_CHECKED;
            else
                lpImeMenu->fState = 0;

            lpImeMenu->wID = IDIM_ROOT_ML_2;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            OurLoadStringW(vpInstData->hInst, IDS_IME_HANGUL_FULL, lpImeMenu->szString, IMEMENUITEM_STRING_SIZE);
            lpImeMenu->hbmpItem = 0;


            // 3. English Halfshape menu
            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFOW);
            lpImeMenu->fType = IMFT_RADIOCHECK;
            if (!(pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) && 
                !(pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE))
                lpImeMenu->fState = IMFS_CHECKED;
            else
                lpImeMenu->fState = 0;

            lpImeMenu->wID = IDIM_ROOT_ML_3;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            OurLoadStringW(vpInstData->hInst, IDS_IME_ENG_HALF, lpImeMenu->szString, IMEMENUITEM_STRING_SIZE);
            lpImeMenu->hbmpItem = 0;

            // 4. English Fullshape menu
            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFOW);
            lpImeMenu->fType = IMFT_RADIOCHECK;
            if ( !(pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) && 
                  (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE))
                lpImeMenu->fState = IMFS_CHECKED;
            else
                lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_ROOT_ML_4;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            OurLoadStringW(vpInstData->hInst, IDS_IME_ENG_FULL, lpImeMenu->szString, IMEMENUITEM_STRING_SIZE);
            lpImeMenu->hbmpItem = 0;

            // return total number of menu list
            dwNumOfItems = NUM_ROOT_MENU_L;
            }
        }

ImeGetImeMenuItemsExit:
    return dwNumOfItems;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Private Helper Functions
//

//
// OS setup (Whistler,Win2K) sets this flag
//
BOOL IsInSystemSetupMode()
{
   LPCSTR szKeyName = "SYSTEM\\Setup";
   DWORD  dwType, dwSize;
   HKEY   hKeySetup;
   DWORD  dwSystemSetupInProgress = 0;
   DWORD  dwUpgradeInProcess = 0;
   DWORD  dwOOBEInProcess = 0;
   LONG   lResult;

   if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_READ, &hKeySetup) == ERROR_SUCCESS)
        {
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hKeySetup, TEXT("SystemSetupInProgress"), NULL, &dwType, (LPBYTE) &dwSystemSetupInProgress, &dwSize);
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hKeySetup, TEXT("UpgradeInProgress"), NULL, &dwType, (LPBYTE) &dwUpgradeInProcess, &dwSize);
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hKeySetup, TEXT("OobeInProgress"), NULL, &dwType, (LPBYTE) &dwOOBEInProcess, &dwSize);

        if (dwSystemSetupInProgress == 1 || dwUpgradeInProcess == 1 || dwOOBEInProcess == 1)
            {
            RegCloseKey (hKeySetup);
            return TRUE;
            }
        RegCloseKey (hKeySetup);
        }

    if (IsWinNT5orUpper() && (IsRunningAsLocalSystem() || IsRunningInOOBE()))
        return TRUE;
        
    return FALSE ;
}

//+----------------------------------------------------------------------------
//
//  Function:   RunningAsLocalSystem
//
//  Synopsis:   Detects whether we're running in the System account.
//
//  Arguments:  None
//
//  Returns:    TRUE  if the service is running as LocalSystem
//              FALSE if it is not or if any errors were encountered
//
//-----------------------------------------------------------------------------
BOOL IsRunningAsLocalSystem()
{
    SID    LocalSystemSid = { SID_REVISION,
                              1,
                              SECURITY_NT_AUTHORITY,
                              SECURITY_LOCAL_SYSTEM_RID };

 

    BOOL   fCheckSucceeded;
    BOOL   fIsLocalSystem = FALSE;

 

    fCheckSucceeded = CheckTokenMembership(NULL,
                                           &LocalSystemSid,
                                           &fIsLocalSystem);

 

    return (fCheckSucceeded && fIsLocalSystem);
}

/*----------------------------------------------------------------------------
    IsRunningInOOBE

    Bug #401732:IME Status window does not come up on the registration page of WPA in the windows starting mode
----------------------------------------------------------------------------*/
BOOL IsRunningInOOBE()
{
    TCHAR  achModule[MAX_PATH];
    TCHAR  ch;
    LPTSTR pch;
    LPTSTR pchFileName;
    
    if (GetModuleFileName(NULL, achModule, ARRAYSIZE(achModule)) == 0)
        return FALSE;

    pch = pchFileName = achModule;

    while ((ch = *pch) != 0)
        {
        pch = CharNext(pch);

        if (ch == '\\')
            pchFileName = pch;
        }
    
    if (lstrcmpi(pchFileName, TEXT("msoobe.exe")) == 0)
        return TRUE;

    return FALSE;
}
    
BOOL PASCAL Select(HIMC hIMC, BOOL fSelect)
{
    PCIMECtx    pImeCtx  = NULL;
    BOOL         fRet     = fTrue;

    // If IME select On
    if (fSelect) 
        {
        IMCPRIVATE      imcPriv;
        IImeIPoint1*    pIP      = NULL;
        LPCImeIPoint    pCIImeIPoint = NULL;
        DWORD             dwInitStatus = 0;

        // Clear all private buffer
        ZeroMemory(&imcPriv, sizeof(IMCPRIVATE));

        //////////////////////////////////////////////////////////////////////
        // Create IImeIPoint1 instance
        //////////////////////////////////////////////////////////////////////
        if ((pCIImeIPoint = new CIImeIPoint)==NULL)
            return fFalse;
        // This increments the reference count
        if (FAILED(pCIImeIPoint->QueryInterface(IID_IImeIPoint1, (VOID **)&pIP)))
            return fFalse;
        AST(pIP != NULL);
        imcPriv.pIPoint = pIP;

        // initialize IImeIPoint interface. This will create CImeCtx object
        Dbg(DBGID_API, "ImeSelect - init IP");
        pCIImeIPoint->Initialize(hIMC);

        //////////////////////////////////////////////////////////////////////
        // Get CImeCtx object from IImeIPoint1
        //////////////////////////////////////////////////////////////////////
        pCIImeIPoint->GetImeCtx((VOID**)&pImeCtx);
        AST(pImeCtx != NULL);
        if (pImeCtx == NULL) 
            {
            Dbg( DBGID_API, "ImeSelect - pImeCtx == NULL" );
            return fFalse;
            }

        // Set pImeCtx
        imcPriv.pImeCtx = pImeCtx;

        // Set hIMC for compare
        imcPriv.hIMC = hIMC;

        //////////////////////////////////////////////////////////////////////
        // Set IMC private buffer
        //////////////////////////////////////////////////////////////////////
        Dbg(DBGID_API, TEXT("ImeSelect - set priv buf"));
           SetPrivateBuffer(hIMC, &imcPriv, sizeof(IMCPRIVATE));

        // Set Unicode flag
        pImeCtx->SetUnicode(vfUnicode);
        
        //////////////////////////////////////////////////////////////////////
        // Set initial IMC states if not already set
        //////////////////////////////////////////////////////////////////////
        pImeCtx->GetInitStatus(&dwInitStatus);

        // if INPUTCONTEXT member are not initialized, initialize it.
        if (!(dwInitStatus & INIT_CONVERSION))
            {
            pImeCtx->SetOpen(fFalse);    // Initial IME close status == Alphanumeric mode
            pImeCtx->SetConversionMode(IME_CMODE_ALPHANUMERIC); // Set initial conversion mode.
            dwInitStatus |= INIT_CONVERSION;
            }
#if 0
// !!! We don't need this code NT5 IMM does it !!!
        else
            {
            // When IME switched from other IME, for example KKIME,
            // status window sometimes not updated to correct info because KKIME maintains 
            // conversion mode independetly from Open/Close status and they uses non-Korean
            // conversion mode like IME_CMODE_KATAKANA or IME_CMODE_ROMAN. 
            // So need to adjust conversion mode according to Open/Clos Status and current
            // conversion mode.

               if (pImeCtx->IsOpen() == fFalse && pImeCtx->GetConversionMode() != IME_CMODE_ALPHANUMERIC)
                   pImeCtx->SetConversionMode(IME_CMODE_ALPHANUMERIC);
            else                
               if (pImeCtx->IsOpen() && (pImeCtx->GetConversionMode() & (IME_CMODE_HANGUL|IME_CMODE_FULLSHAPE)) == fFalse)
                   pImeCtx->SetConversionMode(IME_CMODE_HANGUL);
            }
#endif

        if (!(dwInitStatus & INIT_LOGFONT))
            {
            LOGFONT* pLf = pImeCtx->GetLogFont();

            //////////////////////////////////////////////////////////////////
            // Note: Win98 does not support CreateFontW(). 
            //       But, imc->logfont->lfFaceName is UNICODE!
            if (IsMemphis() || IsWinNT())
                StrCopyW((LPWSTR)pLf->lfFaceName, wzIMECompFont);
            else
                lstrcpyA(pLf->lfFaceName, szIMECompFont);

            // Gulim 9pt
            pLf->lfHeight = 16;
            pLf->lfEscapement = 0;
            pLf->lfOrientation = 0;
            pLf->lfWeight = FW_NORMAL;
            pLf->lfItalic = fFalse;
            pLf->lfUnderline = fFalse;
            pLf->lfStrikeOut = fFalse;
            pLf->lfCharSet = HANGUL_CHARSET;
            pLf->lfOutPrecision = OUT_DEFAULT_PRECIS;
            pLf->lfClipPrecision = CLIP_DEFAULT_PRECIS;
            pLf->lfQuality = DEFAULT_QUALITY;
            pLf->lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
            dwInitStatus |= INIT_LOGFONT;
            }

        if (!(dwInitStatus & INIT_STATUSWNDPOS))
            {
            if (pImeCtx->GetGDataRaw())
                {
                pImeCtx->SetStatusWndPos((pImeCtx->GetGDataRaw())->ptStatusPos);
                }
            dwInitStatus |= INIT_STATUSWNDPOS;
            }
       
        if (!(dwInitStatus & INIT_COMPFORM))
            {
            pImeCtx->SetCompositionFormStyle(CFS_DEFAULT);
            dwInitStatus |= INIT_COMPFORM;
            }

        // Set New initialization status
        pImeCtx->SetInitStatus(dwInitStatus);
        }
    else // fSelect
        {
        IImeIPoint1*  pIP = GetImeIPoint(hIMC);
        LPCImePadSvr lpCImePadSvr;
        CIMCPriv     ImcPriv;
        LPIMCPRIVATE pImcPriv;
            
        // Cleanup Private buffer and release IImeIPoint1
        // Always OnImeSelect already cleanup.
        if (pIP)
            pIP->Release();

        lpCImePadSvr = CImePadSvr::GetCImePadSvr();
        if(lpCImePadSvr)
            lpCImePadSvr->SetIUnkIImeIPoint((IUnknown *)NULL);

        if (ImcPriv.LockIMC(hIMC)) 
            {
            ImcPriv->pIPoint = (IImeIPoint1*)NULL;
            ImcPriv->pImeCtx = NULL;
            ImcPriv.ResetPrivateBuffer();            
            }
        }

    Dbg(DBGID_API, "Select() exit hIMC=%x, fSelect=%d", hIMC, fSelect);
    return (fTrue);
}

//////////////////////////////////////////////////////////////////////////////
// Conversion mode and Open/Close Helper functions
// In Kor IME, Open status equal to Han mode and Close status equal to Eng mode
// So, we change pair open status with conversion mode, and vice versa.

//////////////////////////////////////////////////////////////////////////////
// UpdateOpenCloseState()
// Purpose :
//        Set Open/Close state according to conversion mode
//        if Eng mode - set Close
//        if Han mode - Set Open
VOID PASCAL UpdateOpenCloseState(PCIMECtx pImeCtx)
{
    if (   (pImeCtx->GetConversionMode() & IME_CMODE_HANGUL)
        || (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE)
        || (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT) ) 
        {
        if (pImeCtx->IsOpen() == fFalse) 
            OurImmSetOpenStatus(pImeCtx->GetHIMC(), fTrue);
        }
    else
        {
        if (pImeCtx->IsOpen()) 
            OurImmSetOpenStatus(pImeCtx->GetHIMC(), fFalse);
        }
}

#if NOTUSED
//////////////////////////////////////////////////////////////////////////////
// UpdateConversionState()
// Purpose :
//        Set Conversion state according to Open/Close status
//        if Open - Set Han mode
//        if Close - Set Eng mode
VOID PASCAL UpdateConversionState(HIMC hIMC)
{
    LPINPUTCONTEXT  lpIMC;

    if (lpIMC = OurImmLockIMC(hIMC)) 
    {
        if (OurImmGetOpenStatus(hIMC)) 
        {
            if ( !(lpIMC->fdwConversion & (IME_CMODE_HANGUL|IME_CMODE_FULLSHAPE)) )
            {
                OurImmSetConversionStatus(hIMC, lpIMC->fdwConversion | IME_CMODE_HANGUL,
                                    lpIMC->fdwSentence);
            }
            DbgAssert(lpIMC->fdwConversion & (IME_CMODE_HANGUL|IME_CMODE_FULLSHAPE));
        }
        else
        {
            // BUG: IME_CMODE_HANJACONVERT ????
            if (lpIMC->fdwConversion & (IME_CMODE_HANGUL|IME_CMODE_FULLSHAPE))
                OurImmSetConversionStatus(hIMC, lpIMC->fdwConversion & ~(IME_CMODE_HANGUL|IME_CMODE_FULLSHAPE),
                                    lpIMC->fdwSentence);
            DbgAssert(!(lpIMC->fdwConversion & IME_CMODE_HANGUL));
        }
        OurImmUnlockIMC(hIMC);
    }
}
#endif

/*----------------------------------------------------------------------------
    Banja2Junja

    Convert Ascii Half shape to Full shape character
----------------------------------------------------------------------------*/
WCHAR PASCAL Banja2Junja(WCHAR bChar) //, LPDWORD lpTransBuf, LPCOMPOSITIONSTRING lpCompStr)
{
    WCHAR wcJunja;

    if (bChar == L' ')
        wcJunja = 0x3000;    // FullWidth space
    else 
        if (bChar == L'~')
            wcJunja = 0xFF5E;
        else
            if (bChar == L'\\')
                wcJunja = 0xFFE6;   // FullWidth WON sign
            else
                   wcJunja = 0xFF00 + (WORD)(bChar - (BYTE)0x20);

    Dbg(DBGID_Misc, TEXT("Banja2Junja: wcJunja = 0x%04X"), wcJunja);
    return wcJunja;
}

/*----------------------------------------------------------------------------
    IsKSC5601

    Test if character within the KSC 5601
    Return True if input Unicode chracter has correspoding KSC 5601 code
----------------------------------------------------------------------------*/
BOOL PASCAL IsKSC5601(WCHAR wcCur)
{
    WCHAR    wcUni[2];
    BYTE    szWansung[4];

    wcUni[0] = wcCur;
    wcUni[1] = 0;

    // check if compatibility Hangul jamo
    if (wcCur >= 0x3131 && wcCur <= 0x3163)
        return fTrue;
        
    // Convert to ANSI
    if (WideCharToMultiByte(CP_KOREA, 0, wcUni, 1, (LPSTR)szWansung, sizeof(szWansung), NULL, NULL)==0) 
        {
        DbgAssert(0);
        return fFalse;
        }
    else 
        {
        // KSC 5601 Area in 949 cp
        if (   (szWansung[0]>=0xB0 && szWansung[0]<=0xC8) 
            && (szWansung[1]>=0xA1 && szWansung[1]<=0xFE) )
            return fTrue;
        else
            return fFalse;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imkrinst\regtip.h ===
/****************************** Module Header ******************************\
* Module Name: regtip.h
*
* Copyright (c) 2000, Microsoft Corporation
*
* TIP Register/Unregister TIP functionality.
*
\***************************************************************************/
#if !defined (_REGTIP_H__INCLUDED_)
#define _REGTIP_H__INCLUDED_

#include "regimx.h"
#include "catutil.h"

extern BOOL OurRegisterTIP( LPSTR szFilePath, REFCLSID rclsid, WCHAR *pwszDesc, const REGTIPLANGPROFILE *plp);
extern HRESULT OurRegisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid );
extern HRESULT OurRegisterCategories( REFCLSID rclsid, const REGISTERCAT *pregcat );
extern HRESULT OurUnregisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid );
extern HRESULT OurEnableLanguageProfileByDefault(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imkrinst\regtip.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       regtip.cpp
//
//  Contents:   Reister/Unregister TIP functionality.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "regtip.h"

//
// misc def in Cicero
//

const TCHAR c_szCTFTIPKey[]          = TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\");
const TCHAR c_szCTFTIPKeyWow6432[]   = TEXT("Software\\Wow6432Node\\Microsoft\\CTF\\TIP");
const TCHAR c_szEnable[]             = TEXT("Enable");
const WCHAR c_szEnableW[]            = L"Enable";
const TCHAR c_szLanguageProfileKey[] = TEXT("LanguageProfile\\");
const WCHAR c_szDescriptionW[]       = L"Description";
const WCHAR c_szIconFileW[]          = L"IconFile";
const TCHAR c_szIconIndex[]          = TEXT("IconIndex");
const TCHAR c_szItem[]               = TEXT("Item\\");         // Item to category mapping
const TCHAR c_szCategoryKey[]        = TEXT("Category\\");
const WCHAR c_wszDescription[]       = L"Description";
const TCHAR c_szCategory[]           = TEXT("Category\\"); // Category to item mapping
const WCHAR c_szMUIDescriptionW[]    =  L"Display Description";

typedef enum 
{ 
	CAT_FORWARD  = 0x0,
	CAT_BACKWARD = 0x1
} OURCATDIRECTION;


//
// registry access functions
//

/*   S E T  R E G  V A L U E   */
/*-----------------------------------------------------------------------------



-----------------------------------------------------------------------------*/
static BOOL SetRegValue(HKEY hKey, const WCHAR *szName, WCHAR *szValue)
{
	LONG ec;

	ec = RegSetValueExW(hKey, szName, 0, REG_SZ, (BYTE *)szValue, (lstrlenW(szValue)+1) * sizeof(WCHAR));

	return (ec == ERROR_SUCCESS);
}


/*   S E T  R E G  V A L U E   */
/*-----------------------------------------------------------------------------



-----------------------------------------------------------------------------*/
static BOOL SetRegValue(HKEY hKey, const CHAR *szName, DWORD dwValue)
{
	LONG ec;

	ec = RegSetValueExA( hKey, szName, 0, REG_DWORD, (BYTE *)&dwValue, sizeof(DWORD) );

	return (ec == ERROR_SUCCESS);
}


/*   D E L E T E  R E G  K E Y   */
/*-----------------------------------------------------------------------------



-----------------------------------------------------------------------------*/
static LONG DeleteRegKey( HKEY hKey, const CHAR *szKey )
{
	HKEY hKeySub;
	LONG ec = RegOpenKeyEx( hKey, szKey, 0, KEY_READ | KEY_WRITE, &hKeySub );

	if (ec != ERROR_SUCCESS) {
		return ec;
	}

	FILETIME time;
	DWORD dwSize = 256;
	TCHAR szBuffer[256];
	while (RegEnumKeyEx( hKeySub, 0, szBuffer, &dwSize, NULL, NULL, NULL, &time) == ERROR_SUCCESS) {
		ec = DeleteRegKey( hKeySub, szBuffer );
		if (ec != ERROR_SUCCESS) {
			return ec;
		}
		dwSize = 256;
	}

	RegCloseKey( hKeySub );

	return RegDeleteKey( hKey, szKey );
}


/*   D E L E T E  R E G  V A L U E   */
/*-----------------------------------------------------------------------------



-----------------------------------------------------------------------------*/
static LONG DeleteRegValue( HKEY hKey, const WCHAR *szName )
{
	LONG ec;

	ec = RegDeleteValueW( hKey, szName );

	return (ec == ERROR_SUCCESS);
}


//
// Input processor profile functions
//

/*   O U R  R E G I S T E R   */
/*-----------------------------------------------------------------------------

	private version of CInputProcessorProfiles::Register()
	(Cicero interface function)

-----------------------------------------------------------------------------*/
static HRESULT OurRegister(REFCLSID rclsid)
{
// --- CInputProcessorProfiles::Register() ---
//    CMyRegKey key;
//    TCHAR szKey[256];
//
//    lstrcpy(szKey, c_szCTFTIPKey);
//    CLSIDToStringA(rclsid, szKey + lstrlen(szKey));
//
//    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
//        return E_FAIL;
//
//    key.SetValueW(L"1", c_szEnableW);
//
//    return S_OK;

	HKEY hKey;
	CHAR szKey[ 256 ];
	LONG ec;

	lstrcpy(szKey, c_szCTFTIPKey);
	CLSIDToStringA(rclsid, szKey + lstrlen(szKey));

	ec = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

	SetRegValue(hKey, c_szEnableW, L"1");

	RegCloseKey(hKey);
	return S_OK;
}


/*   O U R  A D D  L A N G U A G E  P R O F I L E   */
/*-----------------------------------------------------------------------------

	private version of CInputProcessorProfiles::AddLanguageProfile()
	(Cicero interface function)

-----------------------------------------------------------------------------*/
static HRESULT OurAddLanguageProfile( REFCLSID rclsid,
                               LANGID langid,
                               REFGUID guidProfile,
                               const WCHAR *pchProfile,
                               ULONG cch,
                               const WCHAR *pchFile,
                               ULONG cchFile,
                               ULONG uIconIndex)
{
// --- CInputProcessorProfiles::AddLanguageProfile() ---
//    CMyRegKey keyTmp;
//    CMyRegKey key;
//    char szTmp[256];
//
//    if (!pchProfile)
//       return E_INVALIDARG;
//
//    lstrcpy(szTmp, c_szCTFTIPKey);
//    CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
//    lstrcat(szTmp, "\\");
//    lstrcat(szTmp, c_szLanguageProfileKey);
//    wsprintf(szTmp + lstrlen(szTmp), "0x%08x", langid);
//
//    if (keyTmp.Create(HKEY_LOCAL_MACHINE, szTmp) != S_OK)
//        return E_FAIL;
//
//    CLSIDToStringA(guidProfile, szTmp);
//    if (key.Create(keyTmp, szTmp) != S_OK)
//        return E_FAIL;
//
//    key.SetValueW(WCHtoWSZ(pchProfile, cch), c_szDescriptionW);
//
//    if (pchFile)
//    {
//        key.SetValueW(WCHtoWSZ(pchFile, cchFile), c_szIconFileW);
//        key.SetValue(uIconIndex, c_szIconIndex);
//    }
//
//    CAssemblyList::InvalidCache();
//    return S_OK;

	HKEY hKey;
	HKEY hKeyTmp;
	LONG ec;
	CHAR szTmp[256];
	WCHAR szProfile[256];
	
	if (!pchProfile)
		return E_INVALIDARG;

	lstrcpy(szTmp, c_szCTFTIPKey);
	CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
	lstrcat(szTmp, "\\" );
	lstrcat(szTmp, c_szLanguageProfileKey);
	wsprintf(szTmp + lstrlen(szTmp), "0x%08x", langid);

	ec = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyTmp, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

	CLSIDToStringA(guidProfile, szTmp);
	ec = RegCreateKeyEx(hKeyTmp, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	RegCloseKey(hKeyTmp);
	
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

	lstrcpynW(szProfile, pchProfile, cch+1);
	szProfile[cch] = L'\0';
	SetRegValue(hKey, c_szDescriptionW, szProfile);

	if (pchFile) 
		{
		WCHAR szFile[ MAX_PATH ];
		lstrcpynW(szFile, pchFile, cchFile+1);
		szFile[cchFile] = L'\0';
		SetRegValue(hKey, c_szIconFileW, szFile);
		SetRegValue(hKey, c_szIconIndex, uIconIndex);
		}

	RegCloseKey( hKey );
	return S_OK;
}



//+---------------------------------------------------------------------------
//
// NumToWDec
//
//----------------------------------------------------------------------------

static void NumToWDec(DWORD dw, WCHAR *psz)
{
    DWORD dwIndex = 1000000000;
    BOOL fNum = FALSE;

    while (dwIndex)
    {
        BYTE b = (BYTE)(dw / dwIndex);
        
        if (b)
            fNum = TRUE;

        if (fNum)
        {
            *psz = (WCHAR)(L'0' + b);
            psz++;
        }

        dw %= dwIndex;
        dwIndex /= 10;
    }

    if (!fNum)
    {
        *psz = L'0';
        psz++;
    }
    *psz = L'\0';

    return;
}

//+---------------------------------------------------------------------------
//
// OurSetLanguageProfileDisplayName
//
//----------------------------------------------------------------------------

static HRESULT OurSetLanguageProfileDisplayName(REFCLSID rclsid,
                                               LANGID langid,
                                               REFGUID guidProfile,
                                               const WCHAR *pchFile,
                                               ULONG cchFile,
                                               ULONG uResId)
{
    HKEY hKeyTmp;
    HKEY hKey;
   	LONG ec;
    CHAR szTmp[MAX_PATH];
    WCHAR wszTmp[MAX_PATH];
    WCHAR wszResId[MAX_PATH];
	WCHAR szFile[MAX_PATH];
	
    if (!pchFile)
       return E_INVALIDARG;

    lstrcpy(szTmp, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
    lstrcat(szTmp, "\\");
    lstrcat(szTmp, c_szLanguageProfileKey);
    wsprintf(szTmp + lstrlen(szTmp), "0x%08x", langid);

	ec = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyTmp, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

    CLSIDToStringA(guidProfile, szTmp);
    ec = RegCreateKeyEx(hKeyTmp, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	RegCloseKey(hKeyTmp);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

    //
    // make "@[filename],-ResId" string 
    //
    lstrcpyW(wszTmp, L"@");

	// WCHtoWSZ(pchFile, cchFile)
    lstrcpynW(szFile, pchFile, cchFile+1);
	szFile[cchFile] = L'\0';

    lstrcatW(wszTmp, szFile);
    lstrcatW(wszTmp, L",-");
    NumToWDec(uResId, wszResId);
    lstrcatW(wszTmp, wszResId);

	SetRegValue(hKey, c_szMUIDescriptionW, wszTmp);
	RegCloseKey(hKey);
    return S_OK;
}

//
// Category manager functions
//

/*   O U R  G E T  C A T  K E Y   */
/*-----------------------------------------------------------------------------

	private version of GetCatKey()
	(Cicero internal function)

-----------------------------------------------------------------------------*/
static inline void OurGetCatKey( REFCLSID rclsid, REFGUID rcatid, LPSTR pszKey, LPCSTR pszItem )
{
// --- GetCatKey() ---
//    lstrcpy(pszKey, c_szCTFTIPKey);
//    CLSIDToStringA(rclsid, pszKey + lstrlen(pszKey));
//    lstrcat(pszKey, "\\");
//    lstrcat(pszKey, c_szCategoryKey);
//    lstrcat(pszKey, pszItem);
//    CLSIDToStringA(rcatid, pszKey + lstrlen(pszKey));

	lstrcpy(pszKey, c_szCTFTIPKey);
	CLSIDToStringA(rclsid, pszKey + lstrlen(pszKey));
	lstrcat(pszKey, "\\");
	lstrcat(pszKey, c_szCategoryKey);
	lstrcat(pszKey, pszItem);
	CLSIDToStringA(rcatid, pszKey + lstrlen(pszKey));
}


/*   O U R  R E G I S T E R  G  U  I  D  D E S C R I P T I O N   */
/*-----------------------------------------------------------------------------

	private version of RegisterGUIDDescription()
	(Cicero library function & interface function)

-----------------------------------------------------------------------------*/
static HRESULT OurRegisterGUIDDescription( REFCLSID rclsid, REFGUID rcatid, WCHAR *pszDesc )
{
// --- RegisterGUIDDescription() ---
//    ITfCategoryMgr *pcat;
//    HRESULT hr;
//
//    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
//                                   NULL, 
//                                   CLSCTX_INPROC_SERVER, 
//                                   IID_ITfCategoryMgr, 
//                                   (void**)&pcat)))
//    {
//        hr = pcat->RegisterGUIDDescription(rclsid, rcatid, pszDesc, wcslen(pszDesc));
//        pcat->Release();
//    }
//
//    return hr;

// --- CCategoryMgr::RegisterGUIDDescription() ---
//    return s_RegisterGUIDDescription(rclsid, rguid, WCHtoWSZ(pchDesc, cch));

// --- CCategoryMgr::s_RegisterGUIDDescription() ---
//    TCHAR szKey[256];
//    CMyRegKey key;
//    
//    GetCatKey(rclsid, rguid, szKey, c_szItem);
//
//    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
//        return E_FAIL;
//
//    key.SetValueW(pszDesc, c_wszDescription);
//
//    return S_OK;

	CHAR szKey[ 256 ];
	HKEY hKey;
	LONG ec;

	OurGetCatKey( rclsid, rcatid, szKey, c_szItem );

	ec = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

	SetRegValue(hKey, c_wszDescription, pszDesc);

	RegCloseKey(hKey);
	return S_OK;
}


/*   O U R  I N T E R N A L  R E G I S T E R  C A T E G O R Y   */
/*-----------------------------------------------------------------------------

	private version of CCategoryMgr::_InternalRegisterCategory()
	(Cicero interface function)

-----------------------------------------------------------------------------*/
static HRESULT OurInternalRegisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, OURCATDIRECTION catdir )
{
// --- CCategoryMgr::_InternalRegisterCategory() ---
//    TCHAR szKey[256];
//    CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
//    CMyRegKey key;
//    CMyRegKey keySub;
//    
//    GetCatKey(rclsid, rcatid, szKey, pszForward);
//
//    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
//        return E_FAIL;
//
//    //
//    // we add this guid and save it.
//    //
//    char szValue[CLSID_STRLEN + 1];
//    CLSIDToStringA(rguid, szValue);
//    keySub.Create(key, szValue);
//    _FlushGuidArrayCache(rguid, catdir);
//
//    return S_OK;

	TCHAR szKey[256];
	CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
	HKEY hKey;
	HKEY hKeySub;
	LONG ec;
    
	OurGetCatKey(rclsid, rcatid, szKey, pszForward);
	ec = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

	char szValue[CLSID_STRLEN + 1];

	CLSIDToStringA(rguid, szValue);
	RegCreateKeyEx( hKey, szValue, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeySub, NULL);

	RegCloseKey( hKey );
	RegCloseKey( hKeySub );
	return S_OK;
}


/*   O U R  I N T E R N A L  U N R E G I S T E R  C A T E G O R Y   */
/*-----------------------------------------------------------------------------

	private version of CCategoryMgr::_InternalUnregisterCategory()
	(Cicero interface function)

-----------------------------------------------------------------------------*/
static HRESULT OurInternalUnregisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, OURCATDIRECTION catdir )
{
// --- CCategoryMgr::_InternalUnregisterCategory ---
//    TCHAR szKey[256];
//    CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
//    CMyRegKey key;
//    
//    GetCatKey(rclsid, rcatid, szKey, pszForward);
//
//    if (key.Open(HKEY_LOCAL_MACHINE, szKey) != S_OK)
//        return E_FAIL;
//
//    DWORD dwIndex = 0;
//    DWORD dwCnt;
//    char szValue[CLSID_STRLEN + 1];
//    dwCnt = sizeof(szValue);
//
//    CLSIDToStringA(rguid, szValue);
//    key.RecurseDeleteKey(szValue);
//    _FlushGuidArrayCache(rguid, catdir);
//
//    return S_OK;

	CHAR szKey[256];
	CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
	HKEY hKey;
	LONG ec;
    
	OurGetCatKey(rclsid, rcatid, szKey, pszForward);
	ec = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, KEY_ALL_ACCESS, &hKey );
	if (ec != ERROR_SUCCESS) {
		return E_FAIL;
	}

	DWORD dwCnt;
	char szValue[CLSID_STRLEN + 1];
	dwCnt = sizeof(szValue);

	CLSIDToStringA( rguid, szValue );
	DeleteRegKey( hKey, szValue );

//    _FlushGuidArrayCache(rguid, catdir);
//	^ NOTE: KOJIW: We cannot clear Cicero internal cache from TIP side...

	RegCloseKey( hKey );
	return S_OK;
}


/*   O U R  R E G I S T E R  T  I  P   */
/*-----------------------------------------------------------------------------

	private version of RegisterTIP()
	(Cicero library function)

-----------------------------------------------------------------------------*/
BOOL OurRegisterTIP(LPSTR szFilePath, REFCLSID rclsid, WCHAR *pwszDesc, const REGTIPLANGPROFILE *plp)
{
// --- RegisterTIP() ---
//    ITfInputProcessorProfiles *pReg = NULL;
//    HRESULT hr;
//    
//    // register ourselves with the ActiveIMM
//    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, 
//                          CLSCTX_INPROC_SERVER,
//                          IID_ITfInputProcessorProfiles, (void**)&pReg);
//    if (FAILED(hr))
//        goto Exit;
//
//    hr = pReg->Register(rclsid);
//
//    if (FAILED(hr))
//        goto Exit;
//
//    while (plp->langid)
//    {
//        WCHAR wszFilePath[MAX_PATH];
//        WCHAR *pv = &wszFilePath[0];
//
//        wszFilePath[0] = L'\0';
//
//        if (wcslen(plp->szIconFile))
//        {
//            char szFilePath[MAX_PATH];
//            WCHAR *pvCur;
//
//            GetModuleFileName(hInst, szFilePath, ARRAYSIZE(szFilePath));
//            wcscpy(wszFilePath, AtoW(szFilePath));
//
//            pv = pvCur = &wszFilePath[0];
//            while (*pvCur)
//            { 
//                if (*pvCur == L'\\')
//                    pv = pvCur + 1;
//                pvCur++;
//            }
//            *pv = L'\0';
//           
//        }
//        wcscpy(pv, plp->szIconFile);
//        
//        pReg->AddLanguageProfile(rclsid, 
//                                 plp->langid, 
//                                 *plp->pguidProfile, 
//                                 plp->szProfile, 
//                                 wcslen(plp->szProfile),
//                                 wszFilePath,
//                                 wcslen(wszFilePath),
//                                 plp->uIconIndex);
//        plp++;
//    }
//
//    RegisterGUIDDescription(rclsid, rclsid, pwszDesc);
//Exit:
//    SafeRelease(pReg);
//    return SUCCEEDED(hr);

	HRESULT hr;

	hr = OurRegister(rclsid);
	if (FAILED(hr))
		goto Exit;

	while (plp->langid) 
		{
		WCHAR wszFilePath[MAX_PATH];
		WCHAR *pv = &wszFilePath[0];

		wszFilePath[0] = L'\0';

		if (wcslen(plp->szIconFile))
			{
			WCHAR *pvCur;

			MultiByteToWideChar(CP_ACP, 0, szFilePath, -1, wszFilePath, MAX_PATH);

			pv = pvCur = &wszFilePath[0];
			while (*pvCur) 
				{
				if (*pvCur == L'\\')
					pv = pvCur + 1;
				pvCur++;
				}
			*pv = L'\0';
 
			}
		lstrcpyW(pv, plp->szIconFile);

		OurAddLanguageProfile(rclsid, 
								plp->langid, 
								*plp->pguidProfile, 
								plp->szProfile, 
								lstrlenW(plp->szProfile),
								wszFilePath,
								lstrlenW(wszFilePath),
								plp->uIconIndex);

		if (plp->uDisplayDescResIndex)
        	{
            OurSetLanguageProfileDisplayName(rclsid, 
                                         plp->langid, 
                                         *plp->pguidProfile, 
                                         wszFilePath,
                                         wcslen(wszFilePath),
                                         plp->uDisplayDescResIndex);
        	}

		plp++;
		}

	OurRegisterGUIDDescription( rclsid, rclsid, pwszDesc );

Exit:
	return SUCCEEDED(hr);
}


/*   O U R  R E G I S T E R  C A T E G O R Y   */
/*-----------------------------------------------------------------------------

	private versio of RegisterCategory()
	(Cicero library function)

-----------------------------------------------------------------------------*/
HRESULT OurRegisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid )
{
// --- RegisterCategory() ---
//    ITfCategoryMgr *pcat;
//    HRESULT hr;
//
//    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
//                                   NULL, 
//                                   CLSCTX_INPROC_SERVER, 
//                                   IID_ITfCategoryMgr, 
//                                   (void**)&pcat)))
//    {
//        hr = pcat->RegisterCategory(rclsid, rcatid, rguid);
//        pcat->Release();
//    }
//
//    return hr;

// --- CCategoryMgr::RegisterCategory() ---
//    return s_RegisterCategory(rclsid, rcatid, rguid);

// --- CCategoryMgr::s_RegisterGUIDDescription() ---
//    HRESULT hr;
//
//    //
//    // create forward link from category to guids.
//    //
//    if (FAILED(hr = _InternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD)))
//        return hr;
//
//    //
//    // create backward link from guid to categories.
//    //
//    if (FAILED(hr = _InternalRegisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD)))
//    {
//        _InternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
//        return hr;
//    }
//
//    return S_OK;

	HRESULT hr;

	if (FAILED(hr = OurInternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD))) {
		return hr;
	}

	if (FAILED(hr = OurInternalRegisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD))) {
		OurInternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
		return hr;
	}

	return S_OK;
}


/*   O U R  U N R E G I S T E R  C A T E G O R Y   */
/*-----------------------------------------------------------------------------

	private version of UnregisterCategory()
	(Cicero library function)

-----------------------------------------------------------------------------*/
HRESULT OurUnregisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid )
{
// --- UnregisterCategory() ---
//    ITfCategoryMgr *pcat;
//    HRESULT hr;
//
//    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
//                                   NULL, 
//                                   CLSCTX_INPROC_SERVER, 
//                                   IID_ITfCategoryMgr, 
//                                   (void**)&pcat)))
//    {
//        hr = pcat->UnregisterCategory(rclsid, rcatid, rguid);
//        pcat->Release();
//    }
//
//    return hr;

// --- CCategoryMgr::UnregisterCategory() ---
//    return s_UnregisterCategory(rclsid, rcatid, rguid);

// --- CCategoryMgr::s_UnregisterCategory() ---
//    HRESULT hr;
//
//    //
//    // remove forward link from category to guids.
//    //
//    if (FAILED(hr = _InternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD)))
//        return hr;
//
//    //
//    // remove backward link from guid to categories.
//    //
//    if (FAILED(hr = _InternalUnregisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD)))
//    {
//        _InternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
//        return hr;
//    }
//
//    return S_OK;

	HRESULT hr;

	if (FAILED(hr = OurInternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD))) {
		return hr;
	}

	if (FAILED(hr = OurInternalUnregisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD))) {
		OurInternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
		return hr;
	}

	return S_OK;
}


/*   O U R  R E G I S T E R  C A T E G O R I E S   */
/*-----------------------------------------------------------------------------

	private version of RegisterCategories()
	(Cicero library function)

-----------------------------------------------------------------------------*/
HRESULT OurRegisterCategories( REFCLSID rclsid, const REGISTERCAT *pregcat )
{
// --- RegisterCategories() ---
//    while (pregcat->pcatid)
//    {
//        if (FAILED(RegisterCategory(rclsid, *pregcat->pcatid, *pregcat->pguid)))
//            return E_FAIL;
//        pregcat++;
//    }
//    return S_OK;

	while (pregcat->pcatid) {
		if (FAILED(OurRegisterCategory(rclsid, *pregcat->pcatid, *pregcat->pguid))) {
			return E_FAIL;
		}
		pregcat++;
	}
	return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitProfileRegKeyStr
//
//----------------------------------------------------------------------------

static BOOL InitProfileRegKeyStr(char *psz, REFCLSID rclsid, LANGID langid, REFGUID guidProfile)
{
    lstrcpy(psz, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, psz + lstrlen(psz));
    lstrcat(psz, "\\");
    lstrcat(psz, c_szLanguageProfileKey);
    wsprintf(psz + lstrlen(psz), "0x%08x", langid);
    lstrcat(psz, "\\");
    CLSIDToStringA(guidProfile, psz + lstrlen(psz));

    return TRUE;
}


HRESULT OurEnableLanguageProfileByDefault(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable)
{
    HKEY hKey;
    char szTmp[256];
	LONG ec;
	
    if (!InitProfileRegKeyStr(szTmp, rclsid, langid, guidProfile))
        return E_FAIL;

	ec = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;
	
	SetRegValue(hKey, c_szEnable, (DWORD)(fEnable ? 1 : 0));
	
	RegCloseKey(hKey);
	
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\candui.cpp ===
/****************************************************************************
    CANDUI.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Candidate window UI functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "debug.h"
#include "ui.h"
#include "lexheader.h"
#include "names.h"
#include "escape.h"
#include "imedefs.h"
#include "hanja.h"
#include "winex.h"

///////////////////////////////////////////////////////////////////////////////
// Private data
// =====-- START OF SHARED DATA --=====
#pragma data_seg(".MSIMESHR") 
PRIVATE RECT rcCandCli = { 0, 0, 319, 29 },
            rcLArrow  = { 15, 4, 27, 25 }, rcRArrow = { 292, 4, 304, 25 },
            s_rcCandBtn[CAND_PAGE_SIZE] = { 
                                {  30, 4,  57, 25 }, {  59, 4,  86, 25 },
                                   {  88, 4, 115, 25 }, { 117, 4, 144, 25 },
                                   { 146, 4, 173, 25 }, { 175, 4, 202, 25 },
                                   { 204, 4, 231, 25 }, { 233, 4, 260, 25 },
                                   { 262, 4, 289, 25 }   };
#pragma data_seg()
// =====-- END OF SHARED DATA --=====

///////////////////////////////////////////////////////////////////////////////
// Private functions
PRIVATE VOID PASCAL PaintCandWindow(HWND hCandWnd, HDC hDC);
PRIVATE BOOL PASCAL CandOnSetCursor(HWND hCandWnd, WORD Message);
PRIVATE VOID PASCAL AdjustCandBoundry(LPPOINT lpptCandWnd);
PRIVATE VOID PASCAL AdjustCandRectBoundry(PCIMECtx pImeCtx, LPPOINT lpptCaret);

#ifdef NOTUSED
PRIVATE VOID NotifyTooltip( HWND hCandWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    HGLOBAL            hUIPrivate;
    LPUIPRIV        lpUIPrivate;
    HWND            hUIWnd;
    MSG                msg;
    POINT            ptCur;

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)
        return;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)         // can not draw candidate window
        return;

    ZeroMemory(&msg, sizeof(MSG));
    msg.hwnd = hCandWnd; msg.message = message;
    msg.wParam = 0; //msg.lParam = 0x00050023L;
    
    if (message == WM_SETCURSOR) 
        {
        GetCursorPos(&ptCur);
        ScreenToClient(hCandWnd, &ptCur);
        msg.lParam = (ptCur.y << 16) | ptCur.x;
        }
    else 
        {
        msg.message = message;
        msg.wParam    = wParam;
        msg.lParam    = lParam;
        }

    Dbg(DBGID_Cand, TEXT("CandOnSetCursor(): WM_MOUSEMOVE - msg.lParam= 0x%08lX"), msg.lParam),
    OurSendMessage(lpUIPrivate->hCandTTWnd, TTM_RELAYEVENT, 0, (LPARAM) (LPMSG) &msg);
    GlobalUnlock(hUIPrivate);
}
#endif

///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK CandWndProc(HWND hCandWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    Dbg(DBGID_UI, TEXT("CandWndProc():uMessage = 0x%08lX, wParam = 0x%04X, lParam = 0x%08lX"), uMessage, wParam, lParam);

    switch (uMessage)
        {
        case WM_IME_CHAR :            case WM_IME_COMPOSITIONFULL :
        case WM_IME_COMPOSITION :    case WM_IME_CONTROL :
        case WM_IME_SELECT :
        case WM_IME_SETCONTEXT :    case WM_IME_STARTCOMPOSITION :
        case WM_IME_ENDCOMPOSITION :
                return 0;

        case WM_SETCURSOR:
                CandOnSetCursor( (HWND) wParam, HIWORD(lParam) );
            return 1;

        case WM_PAINT:
                {
                HDC         hDC;
                PAINTSTRUCT ps;

                hDC = BeginPaint(hCandWnd, &ps);
                PaintCandWindow(hCandWnd, hDC);
                EndPaint(hCandWnd, &ps);
                }
            break;

        default :
            return DefWindowProc(hCandWnd, uMessage, wParam, lParam);
        }
    return (0L);
}


VOID PASCAL OpenCand(HWND hUIWnd)
{
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;
    HIMC        hIMC;
    PCIMECtx    pImeCtx;
    POINT       ptWnd, ptClientWnd;
    CIMEData    ImeData;

#if 1 // MultiMonitor
    RECT rcWorkArea;
#endif

    Dbg(DBGID_Cand, TEXT("OpenCand():"));
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)          // can not draw candidate window
        {
        DbgAssert(0);
        return;
        }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)         // can not draw candidate window
        return;

    // Check WM_IME_SETCONTEXT lParam
    if ((lpUIPrivate->uiShowParam & ISC_SHOWUICANDIDATEWINDOW)==0)
        {
        Dbg(DBGID_Cand, TEXT("!!! No ISC_SHOWUICANDIDATEWINDOW bit exit OpenCand()"));
        goto OpenCandUnlockUIPriv;
        }


    hIMC = GethImcFromHwnd(hUIWnd);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        {
        DbgAssert(0);
        goto OpenCandUnlockUIPriv;
        }

    //if (!(fdwImeMsg & MSG_ALREADY_OPEN)) 
    //    {
        // Sometime the application call ImmNotifyIME to cancel the
        // composition before it process IMN_OPENCANDIDATE.
        // We should avoid to process this kind of IMN_OPENCANDIDATE.
    //    goto OpenCandUnlockIMC;
    //    }
    if (pImeCtx->GetCompBufLen() == 0)
        {
        DbgAssert(0);
        goto OpenCandUnlockUIPriv;
        }

    if (pImeCtx->GetCandidateFormIndex(0) == 0) 
        {
        //ptWnd = lpIMC->cfCandForm[0].ptCurrentPos;
        pImeCtx->GetCandidateFormPos(&ptWnd, 0);

        ClientToScreen(pImeCtx->GetAppWnd(), &ptWnd);

        if (pImeCtx->GetCandidateFormStyle(0) & CFS_FORCE_POSITION) 
            {
            Dbg(DBGID_Cand, TEXT("OpenCand(): CFS_FORCE_POSITION"));
            } 
        else 
            if (pImeCtx->GetCandidateFormStyle(0) == CFS_EXCLUDE) 
                {
                //RECT rcCand;

                Dbg(DBGID_Cand, TEXT("OpenCand(): CFS_EXCLUDE"));
                //if (lpUIPrivate->hCandWnd) {
                //    GetWindowRect(lpUIPrivate->hCandWnd, &rcCand);
                //} else {
                //    *(LPPOINT)&rcCand = ptWnd;
                //}
                AdjustCandRectBoundry(pImeCtx, &ptWnd);

                } 
            else 
                if (pImeCtx->GetCandidateFormStyle(0) == CFS_CANDIDATEPOS) 
                    {
                    Dbg(DBGID_Cand, TEXT("OpenCand(): CFS_CANDIDATEPOS"));
                    AdjustCandBoundry(&ptWnd);
                    } 
                else 
                    {
                    goto OpenCandDefault;
                    }
        } 
    else // if (lpIMC->cfCandForm[0].dwIndex != 0)
        {
OpenCandDefault:
    Dbg(DBGID_Cand, TEXT("OpenCand(): OpenCandDefault"));
    /*
        if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
            ptWnd.x = ptWnd.y = 0;
            ClientToScreen(lpUIPrivate->hCompWnd, &ptWnd);

            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
        } else {
            POINT ptNew;

            ptWnd = lpIMC->cfCompForm.ptCurrentPos;
            ClientToScreen(lpIMC->hWnd, &ptWnd);

            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
            ptNew = ptWnd;

            // try to simulate the position of composition window
            AdjustCompPosition(lpIMC, &ptWnd, &ptNew);
        }
    */
    //    CalcCandPos(lpIMC, &ptWnd);
    
#if 1 // MultiMonitor
        ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcWorkArea);
        ptWnd.x = rcWorkArea.right - ImeData->xCandWi;
        ptWnd.y = rcWorkArea.bottom - ImeData->yCandHi;
#else
        ptWnd.x = ImeData->rcWorkArea.right - ImeData->xCandWi;
        ptWnd.y = ImeData->rcWorkArea.bottom - ImeData->yCandHi;
#endif
        pImeCtx->SetCandidateFormStyle(CFS_CANDIDATEPOS);
        ptClientWnd = ptWnd;
        ScreenToClient(pImeCtx->GetAppWnd(), &ptClientWnd);
        pImeCtx->SetCandidateFormPos(ptClientWnd);
        }

    if (lpUIPrivate->hCandWnd) 
        {
        Dbg(DBGID_Cand, TEXT("OpenCand - SetWindowPos"), ptWnd.x, ptWnd.y);

        SetWindowPos(lpUIPrivate->hCandWnd, NULL,
                    ptWnd.x, ptWnd.y,
                    0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
        } 
    else 
        {
        Dbg(DBGID_Cand, TEXT("OpenCand - CreateWindowEx x=%d, y=%d"), ptWnd.x, ptWnd.y);

        // Create Candidate window
        lpUIPrivate->hCandWnd = CreateWindowEx(0,
                                        szCandClassName, NULL,
                                        WS_POPUP|WS_DISABLED,
                                        ptWnd.x, ptWnd.y,
                                        ImeData->xCandWi, ImeData->yCandHi,
                                        hUIWnd, 
                                        (HMENU)NULL, 
                                        vpInstData->hInst, 
                                        NULL);

        if (lpUIPrivate->hCandWnd == NULL)
            goto OpenCandUnlockUIPriv;

        // Create candidate TT
        if (IsWinNT())
            lpUIPrivate->hCandTTWnd = CreateWindowW(
                                            wszTooltipClassName, 
                                            NULL,
                                            TTS_ALWAYSTIP|WS_DISABLED, 
                                            CW_USEDEFAULT, CW_USEDEFAULT, 
                                            CW_USEDEFAULT, CW_USEDEFAULT,
                                            lpUIPrivate->hCandWnd, 
                                            (HMENU) NULL, 
                                            vpInstData->hInst, 
                                            NULL);
        else
            lpUIPrivate->hCandTTWnd = CreateWindow(
                                            szTooltipClassName, 
                                            NULL,
                                            TTS_ALWAYSTIP|WS_DISABLED, 
                                            CW_USEDEFAULT, CW_USEDEFAULT, 
                                            CW_USEDEFAULT, CW_USEDEFAULT,
                                            lpUIPrivate->hCandWnd, 
                                            (HMENU) NULL, 
                                            vpInstData->hInst, 
                                            NULL);
        DbgAssert(lpUIPrivate->hCandTTWnd != 0);
        
        if (lpUIPrivate->hCandTTWnd) 
            {
            TOOLINFO        ti;
        
            ZeroMemory(&ti, sizeof(TOOLINFO));
            ti.cbSize = sizeof(TOOLINFO);
            ti.uFlags = 0;
            ti.hwnd = lpUIPrivate->hCandWnd;
            ti.hinst = vpInstData->hInst;

            // Reset Tooltip data
            for (INT i=0; i<CAND_PAGE_SIZE; i++) 
                {
                ti.uId = i;
                ti.lpszText = "";
                ti.rect = s_rcCandBtn[i];
                OurSendMessage(lpUIPrivate->hCandTTWnd, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
                }
            }

        }

    ShowCand(hUIWnd, SW_SHOWNOACTIVATE);

OpenCandUnlockUIPriv:
    GlobalUnlock(hUIPrivate);
    return;
}


///////////////////////////////////////////////////////////////////////////////
//
VOID PASCAL AdjustCandBoundry(LPPOINT lpptCandWnd)
{
    CIMEData            ImeData;
#if 1 // MultiMonitor
    RECT rcWorkArea;
    RECT rcCandWnd;
#endif
    Dbg(DBGID_UI, TEXT("AdjustCandBoundry():"));

#if 1 // MultiMonitor
    *(LPPOINT)&rcCandWnd = *(LPPOINT)lpptCandWnd;
    rcCandWnd.right = rcCandWnd.left + ImeData->xCandWi;
    rcCandWnd.bottom = rcCandWnd.top + ImeData->yCandHi;

    ImeMonitorWorkAreaFromRect(&rcCandWnd, &rcWorkArea);

    if (lpptCandWnd->x < rcWorkArea.left) {
        lpptCandWnd->x = rcWorkArea.left;
    } else if (lpptCandWnd->x + ImeData->xCandWi > rcWorkArea.right) {
        lpptCandWnd->x = rcWorkArea.right - ImeData->xCandWi;
    } else {
    }

    if (lpptCandWnd->y < rcWorkArea.top) {
        lpptCandWnd->y = rcWorkArea.top;
    } else if (lpptCandWnd->y + ImeData->yCandHi > rcWorkArea.bottom) {
        lpptCandWnd->y = rcWorkArea.bottom - ImeData->yCandHi;
    } else {
    }

#else
    if (lpptCandWnd->x < ImeData->rcWorkArea.left) {
        lpptCandWnd->x = ImeData->rcWorkArea.left;
    } else if (lpptCandWnd->x + ImeData->xCandWi > ImeData->rcWorkArea.right) {
        lpptCandWnd->x = ImeData->rcWorkArea.right - ImeData->xCandWi;
    } else {
    }

    if (lpptCandWnd->y < ImeData->rcWorkArea.top) {
        lpptCandWnd->y = ImeData->rcWorkArea.top;
    } else if (lpptCandWnd->y + ImeData->yCandHi > ImeData->rcWorkArea.bottom) {
        lpptCandWnd->y = ImeData->rcWorkArea.bottom - ImeData->yCandHi;
    } else {
    }
#endif
}

VOID PASCAL AdjustCandRectBoundry(PCIMECtx pImeCtx, LPPOINT lpptCaret)               // the caret position. Screen coord
{
    RECT      rcExclude, rcCandRect, rcInterSect;
    POINT     ptCurrentPos;
    CIMEData ImeData;

    // translate from client coordinate to screen coordinate
    // rcExclude = lpIMC->cfCandForm[0].rcArea;
    pImeCtx->GetCandidateForm(&rcExclude);
    pImeCtx->GetCandidateFormPos(&ptCurrentPos);

    rcExclude.left += lpptCaret->x - ptCurrentPos.x;
    rcExclude.right += lpptCaret->x - ptCurrentPos.x;

    rcExclude.top += lpptCaret->y - ptCurrentPos.y;
    rcExclude.bottom += lpptCaret->y - ptCurrentPos.y;

    AdjustCandBoundry(lpptCaret);

    *(LPPOINT)&rcCandRect = *lpptCaret;
    rcCandRect.right = rcCandRect.left + ImeData->xCandWi;
    rcCandRect.bottom = rcCandRect.top + ImeData->yCandHi;

    if (IntersectRect(&rcInterSect, &rcCandRect, &rcExclude))
    {
#if 1 // MultiMonitor
        RECT rcWorkArea;
        ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcWorkArea);
        // Adjust y-axis only
        if ( (rcExclude.bottom + ImeData->yCandHi) < rcWorkArea.bottom )
            lpptCaret->y = rcExclude.bottom;
        else
            lpptCaret->y = rcExclude.top - ImeData->yCandHi;

#else
        // Adjust y-axis only
        if ( (rcExclude.bottom + ImeData->yCandHi) < ImeData->rcWorkArea.bottom )
            lpptCaret->y = rcExclude.bottom;
        else
            lpptCaret->y = rcExclude.top - ImeData->yCandHi;
#endif
    }
}

BOOL fSetCandWindowPos(HWND  hCandWnd)
{
    HWND     hUIWnd;
    HIMC     hIMC;
    PCIMECtx pImeCtx;
    POINT    ptWnd;
    CIMEData ImeData;

    if (hCandWnd == 0)
        {
        DbgAssert(0);
        return fTrue;
        }
    hUIWnd = GetWindow(hCandWnd, GW_OWNER);

    hIMC = GethImcFromHwnd(hUIWnd);
    //if (!hIMC) 
    //    {
    //    DbgAssert(0);        
    //  return fFalse;
    //    }

    //lpIMC = (LPINPUTCONTEXT)OurImmLockIMC(hIMC);
    //if (!lpIMC) 
    //    {
    //    DbgAssert(0);        
    //  return fFalse;
    //    }

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;

    //ptWnd = lpIMC->cfCandForm[0].ptCurrentPos;
    pImeCtx->GetCandidateFormPos(&ptWnd);
    
    ClientToScreen(pImeCtx->GetAppWnd(), &ptWnd);

    if (pImeCtx->GetCandidateFormStyle() & CFS_FORCE_POSITION) 
        {
        } 
    else 
        if (pImeCtx->GetCandidateFormStyle() == CFS_EXCLUDE) 
        {
        RECT rcCand;

        GetWindowRect(hCandWnd, &rcCand);
        AdjustCandRectBoundry(pImeCtx, &ptWnd);

        if (ptWnd.x == rcCand.left && ptWnd.y == rcCand.right)
            return (0L);
        } 
    else 
    if (pImeCtx->GetCandidateFormStyle() == CFS_CANDIDATEPOS) 
        {
        AdjustCandBoundry(&ptWnd);
        } 
    else 
    if (pImeCtx->GetCandidateFormStyle() == CFS_DEFAULT) 
        {
#if 1 // MultiMonitor
        RECT rcWorkArea;
        ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcWorkArea);
        ptWnd.x = rcWorkArea.right - ImeData->xCandWi;
        ptWnd.y = rcWorkArea.bottom - ImeData->yCandHi;
#else
        ptWnd.x = ImeData->rcWorkArea.right - ImeData->xCandWi;
        ptWnd.y = ImeData->rcWorkArea.bottom - ImeData->yCandHi;
#endif
        }

    SetWindowPos(hCandWnd, NULL, ptWnd.x, ptWnd.y, 0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    return (0L);
    }


// Show the candidate window
VOID ShowCand(HWND hUIWnd, INT nShowCandCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    Dbg(DBGID_Cand, TEXT("ShowCand(): nShowCandCmd = %d"), nShowCandCmd);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)          // can not darw candidate window
        return;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)          // can not draw candidate window
        return;

    if (nShowCandCmd == SW_SHOWNOACTIVATE)
        nShowCandCmd = vfWndOpen[CAND_WINDOW] ? SW_SHOWNOACTIVATE : SW_HIDE;

    if (lpUIPrivate->nShowCandCmd == nShowCandCmd)
        goto SwCandNoChange;

    if (lpUIPrivate->hCandWnd)
        {
        ShowWindow(lpUIPrivate->hCandWnd, nShowCandCmd);
        lpUIPrivate->nShowCandCmd = nShowCandCmd;
        }
    else
        lpUIPrivate->nShowCandCmd = SW_HIDE;

SwCandNoChange:
    GlobalUnlock(hUIPrivate);
    return;
}


BOOL PASCAL CandOnSetCursor(HWND hCandWnd, WORD message)
{
    INT iLoop;
    POINT    ptPos;

    SetCursor(LoadCursor(vpInstData->hInst, MAKEINTRESOURCE(IDC_IME_HAND)));
    
    switch (message)
    {
        case WM_LBUTTONDOWN:
            GetCursorPos(&ptPos);
            ScreenToClient(hCandWnd, &ptPos);
            if (PtInRect((LPRECT)&rcCandCli, ptPos))
            {
                if (!PtInRect((LPRECT)&rcLArrow, ptPos)
                        && !PtInRect((LPRECT)&rcRArrow, ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[0], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[1], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[2], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[3], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[4], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[5], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[6], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[7], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[8], ptPos))
                    MessageBeep(MB_ICONEXCLAMATION);
            }
            break;

        case WM_LBUTTONUP:
            GetCursorPos(&ptPos);
            ScreenToClient(hCandWnd, &ptPos);
            if (PtInRect((LPRECT)&rcLArrow, ptPos))
            {
                keybd_event(VK_LEFT, 0, KEYEVENTF_EXTENDEDKEY, 0);
                keybd_event(VK_LEFT, 0, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, 0);
            }
            else if (PtInRect((LPRECT)&rcRArrow, ptPos))
            {
                keybd_event(VK_RIGHT, 0, KEYEVENTF_EXTENDEDKEY, 0);
                keybd_event(VK_RIGHT, 0, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, 0);
            }
            else
            {
                for (iLoop = 0; iLoop < CAND_PAGE_SIZE; iLoop++)
                    if (PtInRect((LPRECT)&s_rcCandBtn[iLoop], ptPos))
                    {    
                        keybd_event((BYTE)(iLoop + '1'), 0, 0, 0);
                        keybd_event((BYTE)(iLoop + '1'), 0, KEYEVENTF_KEYUP, 0);
                        break;
                    }
            }
            break;

        case WM_MOUSEMOVE:
        //case WM_LBUTTONDOWN:
        //case WM_LBUTTONUP:
            {
                HGLOBAL            hUIPrivate;
                LPUIPRIV        lpUIPrivate;
                HWND            hUIWnd;
                MSG                msg;
                POINT            ptCur;

                hUIWnd = GetWindow(hCandWnd, GW_OWNER);
                hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
                if (!hUIPrivate) {
                    break;
                }
                lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
                if (!lpUIPrivate) {         // can not draw candidate window
                    break;
                }
                ZeroMemory(&msg, sizeof(MSG));
                msg.message = message;
                msg.hwnd = hCandWnd;
                msg.wParam = 0; //msg.lParam = 0x00050023L;
                GetCursorPos(&ptCur);
                ScreenToClient(hCandWnd, &ptCur);
                msg.lParam = MAKELONG(ptCur.x, ptCur.y);
                Dbg(DBGID_Cand|DBGID_UI, TEXT("CandOnSetCursor(): WM_MOUSEMOVE - msg.lParam= 0x%08lX"), msg.lParam),
                OurSendMessage(lpUIPrivate->hCandTTWnd, TTM_RELAYEVENT, 0, (LPARAM) (LPMSG) &msg);
                GlobalUnlock(hUIPrivate);
            }
            break;
    }    
    return fTrue;
}


VOID PASCAL PaintCandWindow(HWND hCandWnd, HDC hDC)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    PCIMECtx    pImeCtx;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
//  LPSTR       lpCandStr;
    HFONT       hFontFix, hOldFont;
    DWORD       iLoop, iStart;
    HBITMAP        hBMCand, hBMCandNum, hBMCandArr1, hBMCandArr2;
    INT         iSaveBkMode;
    TOOLINFO    ti;
    HGLOBAL        hUIPrivate;
    LPUIPRIV    lpUIPrivate;


    Dbg(DBGID_UI, TEXT("PaintCandWindow"));

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);
    
    hIMC = GethImcFromHwnd(hUIWnd);
    
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)
        {
        DbgAssert(0);
        return;
        }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)
        return;

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        {
        DbgAssert(0);
        goto PaintCandWindowExit;
        }
    
    lpCandInfo = pImeCtx->GetPCandInfo();
    if (lpCandInfo == NULL)
        {
        DbgAssert(0);
        goto PaintCandWindowExit;
        }

    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo + sizeof(CANDIDATEINFO));
    Dbg(DBGID_UI, TEXT("PaintCandWindow - dwCount = %d"), lpCandList->dwCount);

    if (lpCandList->dwCount)
        {
        if (IsWinNT())
            hFontFix = CreateFontW(
                            -16,0,0,0, 
                            0,0,0,0,
                            HANGUL_CHARSET,
                            OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, 
                             DEFAULT_QUALITY, 
                             FIXED_PITCH, 
                             wzIMECompFont);
         else
            hFontFix = CreateFontA(
                            -16,0,0,0, 
                            0,0,0,0,
                            HANGUL_CHARSET,
                            OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, 
                             DEFAULT_QUALITY, 
                             FIXED_PITCH, 
                             szIMECompFont);
             
        
        hOldFont = (HFONT)SelectObject(hDC, hFontFix);
        // Load bitmaps
        hBMCand = (HBITMAP)OurLoadImage(MAKEINTRESOURCE(IDB_CAND_WIN),
                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );
        hBMCandNum = (HBITMAP)OurLoadImage(MAKEINTRESOURCE(IDB_CAND_NUM),
                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );
        hBMCandArr1 = (HBITMAP)OurLoadImage(MAKEINTRESOURCE(IDB_CAND_ARRY1),
                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );
        hBMCandArr2 = (HBITMAP)OurLoadImage(MAKEINTRESOURCE(IDB_CAND_ARRY2),
                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );

        DrawBitmap(hDC, 0, 0, hBMCand);
        iSaveBkMode = SetBkMode(hDC, TRANSPARENT);
        iStart = (lpCandList->dwSelection / lpCandList->dwPageSize) * lpCandList->dwPageSize;

        ZeroMemory(&ti, sizeof(TOOLINFO));
        ti.cbSize = sizeof(TOOLINFO);
        ti.uFlags = 0;
        ti.hwnd = hCandWnd;
        ti.hinst = vpInstData->hInst;

        // Paint current page 9 candidate chars
        for (iLoop = 0; iLoop < CAND_PAGE_SIZE && iStart+iLoop < lpCandList->dwCount; iLoop++)
            {
            // Set text color
            if ( (iStart + iLoop) >= GetNumOfK0() )    // if K1 Hanja set it blue color
                {
                // If button face is black
                if (GetSysColor(COLOR_3DFACE) == RGB(0,0,0)) 
                    SetTextColor(hDC, RGB(0, 128, 255));
                else
                    SetTextColor(hDC, RGB(0, 0, 255));
                }
            else
                SetTextColor(hDC, GetSysColor(COLOR_MENUTEXT));

//          lpCandStr = (LPSTR)((LPSTR)lpCandList + lpCandList->dwOffset[iStart + iLoop]);
            OurTextOutW(hDC, s_rcCandBtn[iLoop].left + 10, s_rcCandBtn[iLoop].top +3, 
                            pImeCtx->GetCandidateStr(iStart + iLoop));
//                            (LPWSTR)lpCandStr, 
//                            1);
//            Dbg(DBGID_UI, TEXT("PaintCandWindow -  Cand Char = 0x%04x"), *(LPWSTR)lpCandStr);

            // Set tooltip info
            if (IsWin(lpUIPrivate->hCandTTWnd))
                {
                CIMEData     ImeData;
                CHAR        szCurSense[MAX_SENSE_LENGTH+6+1]; // 6 reserved for Unicode display(Format "U+0000")
                WCHAR        wszCurSense[MAX_SENSE_LENGTH+6+1]; // 6 reserved for Unicode display(Format "U+0000")
                CHAR        szHanjaMeaning[MAX_SENSE_LENGTH+1];
                WCHAR        wzHangulOfHanja[2];  // Need just one character
                CHAR        szHangulOfHanja[4];    // One DBCS + One Null + extra byte
                LPWSTR        pwszMeaning;

                // Init local vars
                szCurSense[0]  = '\0';
                wszCurSense[0] = L'\0';
                szHanjaMeaning[0] = '\0';
                wzHangulOfHanja[0] = L'\0';
                szHangulOfHanja[0] = '\0';
                    
                ti.uId = iLoop;
                // Get the meaning of current Hanja 
                if (pwszMeaning = pImeCtx->GetCandidateMeaningStr(iStart+iLoop)) 
                    {
                    
                    // Get Hangul pronounciation of current Hanja 
                    wzHangulOfHanja[0] = GetCurrentHangulOfHanja();
                    wzHangulOfHanja[1] = L'\0';

                    if (IsWinNT())
                        {
                        if (ImeData->fCandUnicodeTT)
                            wsprintfW(wszCurSense, L"%s %s\r\nU+%04X", 
                                      pwszMeaning, 
                                      wzHangulOfHanja,
                                      (WORD)pImeCtx->GetCandidateStr(iStart + iLoop));
                        else
                            wsprintfW(wszCurSense, L"%s %s", pwszMeaning, wzHangulOfHanja);

                        ti.lpszText = (LPSTR)wszCurSense;
                        }
                    else // If not NT, convert to ANSI
                        {
                        if (WideCharToMultiByte(CP_KOREA, 0, 
                                            pwszMeaning, 
                                            -1, 
                                            (LPSTR)szHanjaMeaning, 
                                            sizeof(szHanjaMeaning), 
                                            NULL, 
                                            NULL) == 0)
                            szHanjaMeaning[0] = 0;

                        if (WideCharToMultiByte(CP_KOREA, 0, 
                                            wzHangulOfHanja, 
                                            -1, 
                                            (LPSTR)szHangulOfHanja, 
                                            sizeof(szHangulOfHanja), 
                                            NULL, 
                                            NULL) == 0)
                            szHangulOfHanja[0] = 0;

                        if (ImeData->fCandUnicodeTT)
                            wsprintfA(szCurSense, "%s %s\r\nU+%04X", 
                                      szHanjaMeaning, 
                                      szHangulOfHanja,
                                      (WORD)pImeCtx->GetCandidateStr(iStart + iLoop));
                        else
                            wsprintfA(szCurSense, "%s %s", szHanjaMeaning, szHangulOfHanja);

                        ti.lpszText = szCurSense;
                        }
                    }
                else
                    {
                    if (ImeData->fCandUnicodeTT)
                        {
                        wsprintfA(szCurSense, "U+%04X", (WORD)pImeCtx->GetCandidateStr(iStart + iLoop));
                        ti.lpszText = szCurSense;
                        }
                    }

                // Set Tooltip Text
                if (ti.lpszText)
                    {
                    UINT uiMsgUpdateTxt = TTM_UPDATETIPTEXTW;
                    
                    if (!IsWinNT())
                        uiMsgUpdateTxt = TTM_UPDATETIPTEXT;
                    OurSendMessage(lpUIPrivate->hCandTTWnd, uiMsgUpdateTxt, 0, (LPARAM) (LPTOOLINFO) &ti);
                    
                    //  To force the tooltip control to use multiple lines
                    OurSendMessage(lpUIPrivate->hCandTTWnd, TTM_SETMAXTIPWIDTH, 0, 300);
                    }
                }
            }
            
        SetBkMode(hDC, iSaveBkMode);
        // Reset blank cand list tooltip
        if (iLoop < CAND_PAGE_SIZE) 
            {
            ti.lpszText = NULL;
            for (; iLoop < CAND_PAGE_SIZE; iLoop++) 
                {
                ti.uId = iLoop;
                OurSendMessage(lpUIPrivate->hCandTTWnd, TTM_UPDATETIPTEXT, 0, (LPARAM) (LPTOOLINFO) &ti);
                DrawBitmap(hDC, s_rcCandBtn[iLoop].left + 3, s_rcCandBtn[iLoop].top + 6, hBMCandNum);
                }
            }
        //
        if (iStart)
            DrawBitmap(hDC, 19, 8, hBMCandArr1);
        
        if (iStart + CAND_PAGE_SIZE < lpCandList->dwCount)
            DrawBitmap(hDC, 296, 8, hBMCandArr2);

        DeleteObject(hBMCand);
        DeleteObject(hBMCandNum);
        DeleteObject(hBMCandArr1);
        DeleteObject(hBMCandArr2);
        SelectObject(hDC, hOldFont);
        DeleteObject(hFontFix);
        }
    
PaintCandWindowExit:
    GlobalUnlock(hUIPrivate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\apientry.h ===
/****************************************************************************
	APIENTRY.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Header file for API entries between IMM32 and IME

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_APIENTRY_H__INCLUDED_)
#define _APIENTRY_H__INCLUDED_

#include "debug.h"

extern "C" {
DWORD WINAPI ImeGetImeMenuItems(HIMC hIMC, DWORD dwFlags, DWORD dwType, 
								LPIMEMENUITEMINFO lpImeParentMenu, LPIMEMENUITEMINFO lpImeMenu, 
								DWORD dwSize);
}

///////////////////////////////////////////////////////////////////////////////
// Inline Functions

// Fill a TransMsg Helper function
inline 
void SetTransBuffer(LPTRANSMSG lpTransMsg, 
					UINT message, WPARAM wParam, LPARAM lParam)
{
	DbgAssert(lpTransMsg != NULL);
	if (lpTransMsg)
		{
		lpTransMsg->message = message;
		lpTransMsg->wParam = wParam;
		lpTransMsg->lParam = lParam;
		}
}

#endif // !defined (_APIENTRY_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\cicbtn.cpp ===
//
// cicbtn.cpp
//
// base code: nuibase sample
//

#include "precomp.h"
#include "cicbtn.h"
#include "common.h"
#include "cicero.h"
#include <olectl.h>

#define CICBTN_ITEMSINK_COOKIE 0x80000004

//////////////////////////////////////////////////////////////////////////////
//
// CCicButton
//
//////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCicButton::~CCicButton()
{
    SafeRelease(m_plbiSink);
}

//+---------------------------------------------------------------------------
//
// InitInfo
//
//----------------------------------------------------------------------------

void CCicButton::InitInfo(REFCLSID rclsid, 
                                REFGUID rguid, 
                                DWORD dwStyle, 
                                ULONG ulSort,
                                LPWSTR pszDesc)
{
    // init nuiInfo.
    m_lbiInfo.clsidService = rclsid;
    m_lbiInfo.guidItem = rguid;
    m_lbiInfo.dwStyle = dwStyle;
    m_lbiInfo.ulSort = ulSort;
    StrCopyW(m_lbiInfo.szDescription, pszDesc);
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    *pInfo = m_lbiInfo;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetStatus(DWORD *pdwStatus)
{
    *pdwStatus = m_dwStatus;
    
    if (m_fEnable)    // enable?
        {
        // do nothing
        }
    else
        *pdwStatus |= TF_LBI_STATUS_DISABLED;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CCicButton::Show(BOOL fShow)
{
    ITfLangBarItemSink* pSink;

    ShowInternal(fShow);
    pSink = GetSink();
    if (pSink)
        pSink->OnUpdate(TF_LBI_STATUS);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

HRESULT CCicButton::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    HRESULT hr;

    if (pdwCookie == NULL)
        return E_INVALIDARG;

    if (IsEqualIID(IID_ITfLangBarItemSink, riid))
        {
        if (m_plbiSink)
            hr = CONNECT_E_CANNOTCONNECT;
        else
            {
            hr = punk->QueryInterface(IID_ITfLangBarItemSink, (void **)&m_plbiSink);
            if (SUCCEEDED(hr))
                *pdwCookie = CICBTN_ITEMSINK_COOKIE;
            }
        }
    else
        hr = CONNECT_E_CANNOTCONNECT;
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

HRESULT CCicButton::UnadviseSink(DWORD dwCookie)
{
    if (CICBTN_ITEMSINK_COOKIE  != dwCookie)
        return E_FAIL;

    if (!m_plbiSink)
        return E_UNEXPECTED;

    m_plbiSink->Release();
    m_plbiSink = NULL;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

HRESULT CCicButton::ShowInternal(BOOL fShow, BOOL fNotify)
{
    m_fShown = fShow;
    DWORD dwOldStatus = m_dwStatus;

    if (fShow)
        m_dwStatus &= ~TF_LBI_STATUS_HIDDEN;
    else
        m_dwStatus |= TF_LBI_STATUS_HIDDEN;

    if (fNotify && (dwOldStatus != m_dwStatus) && m_plbiSink)
         m_plbiSink->OnUpdate(TF_LBI_STATUS);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemButtonBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCicButton::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
        {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
        }
    else if (IsEqualIID(riid, IID_ITfLangBarItemButton))
        {
        *ppvObj = SAFECAST(this, ITfLangBarItemButton *);
        }
    else if (IsEqualIID(riid, IID_ITfSource))
        {
        *ppvObj = SAFECAST(this, ITfSource *);
        }

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CCicButton::AddRef()
{
    return ++m_cRef;
}

#ifdef NEVER // each button object has this
STDAPI_(ULONG) CCicButton::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}
#endif // NEVER


//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CCicButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    switch (click)
        {
        case TF_LBI_CLK_RIGHT:
            return OnRButtonUp(pt, prcArea);
        case TF_LBI_CLK_LEFT:
            return OnLButtonUp(pt, prcArea);
        }
        
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CCicButton::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    pt, prcArea; // no ref
   return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT CCicButton::OnRButtonUp(const POINT pt, const RECT *prcArea)
{
    pt, prcArea; // no ref
   return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CCicButton::InitMenu(ITfMenu *pMenu)
{
    pMenu; // no ref
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CCicButton::OnMenuSelect(UINT uID)
{
    uID; // no ref
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetIcon(HICON *phIcon)
{
    phIcon; // no ref
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetText(BSTR *pbstrText)
{
    if (!pbstrText)
        return E_INVALIDARG;

    *pbstrText = OurSysAllocString(m_szText);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetTooltipString(BSTR *pbstrToolTip)
{
    if (!pbstrToolTip)
        return E_INVALIDARG;

    *pbstrToolTip = OurSysAllocString(m_szToolTip);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\cicbtn.h ===
//
// cicbtn.h
//

#ifndef _CICBTN_H_
#define _CICBTN_H_

#include "msctf.h"
#include <initguid.h>
#include "..\CiceroLib\inc\slbarid.h"

#define CICBTN_TOOLTIP_MAX	256
#define CICBTN_TEXT_MAX	256

class __declspec(novtable) CCicButton : public ITfSource, public ITfLangBarItemButton
{
public:
    CCicButton()
    {
		m_uid       = (UINT)-1;
		m_dwStatus  = 0;
		m_fShown    = FALSE;
		m_fEnable   = TRUE;
		m_szText[0] = L'\0';
		m_plbiSink  = NULL;
		m_cRef      = 1;
	}
    ~CCicButton();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
	//virtual STDMETHODIMP_(ULONG) Release(void);

    void InitInfo(REFCLSID clsid, REFGUID rguid, DWORD dwStyle, ULONG ulSort, LPWSTR pszDesc);
    virtual STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    virtual STDMETHODIMP GetStatus(DWORD *pdwStatus);
    virtual STDMETHODIMP Show(BOOL fShow);
    virtual STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);
    virtual STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    virtual STDMETHODIMP UnadviseSink(DWORD dwCookie);
	virtual STDMETHODIMP OnClick( /* [in] */ TfLBIClick click, /* [in] */ POINT pt, /* [in] */ const RECT __RPC_FAR *prcArea);
	virtual STDMETHODIMP InitMenu( /* [in] */ ITfMenu __RPC_FAR *pMenu);
	virtual STDMETHODIMP OnMenuSelect( /* [in] */ UINT wID);
	virtual STDMETHODIMP GetIcon( /* [out] */ HICON __RPC_FAR *phIcon);
	virtual STDMETHODIMP GetText( /* [out] */ BSTR __RPC_FAR *pbstrText);

    virtual HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    virtual HRESULT OnRButtonUp(const POINT pt, const RECT *prcArea);

    DWORD GetStyle() {return m_lbiInfo.dwStyle;}
    void SetStyle(DWORD dwStyle) {m_lbiInfo.dwStyle = dwStyle;}

    GUID* GetGuidItem() {return &m_lbiInfo.guidItem;}

    DWORD GetStatusInternal() {return m_dwStatus;}
    void SetStatusInternal(DWORD dw) {m_dwStatus = dw;}
    HRESULT ShowInternal(BOOL fShow, BOOL fNotify = FALSE);

    void SetOrClearStatus(DWORD dw, BOOL fSet);

    ITfLangBarItemSink *GetSink() { return m_plbiSink; }

    void SetText(WCHAR *psz);
    void SetToolTip(WCHAR *psz);
	void SetStatus(DWORD dwStatus);
	void Enable(BOOL fEnable);
	BOOL IsEnable() { return m_fEnable;	}
	void ShowDefault(BOOL fShowDefault);

	void SetID(UINT uid) { m_uid = uid;  }
	UINT GetID()	     { return m_uid; }

	void UpdateButton();

protected:
    //DWORD _dwStatus;
    TF_LANGBARITEMINFO m_lbiInfo;
    WCHAR m_szToolTip[CICBTN_TOOLTIP_MAX];
    long m_cRef;
    ITfLangBarItemSink *m_plbiSink;

private:
    DWORD m_dwCookie;
	DWORD m_dwStatus;
	BOOL m_fShown;
	BOOL m_fEnable;
	UINT m_uid;
    WCHAR m_szText[CICBTN_TEXT_MAX];
};

inline
void CCicButton::SetOrClearStatus(DWORD dw, BOOL fSet)
{
    if (fSet)
        m_dwStatus |= dw;
    else
        m_dwStatus &= ~dw;
}

inline
void CCicButton::SetToolTip(WCHAR *psz)
{
    StrnCopyW(m_szToolTip, psz, CICBTN_TOOLTIP_MAX);
}


inline
void CCicButton::SetStatus(DWORD dwStatus)
{
	BOOL fShown = m_fShown;
	m_dwStatus = dwStatus;
	ShowInternal(fShown);
}

inline
void CCicButton::Enable(BOOL fEnable)
{
	m_fEnable = fEnable;
	if(fEnable) {	// enable?
		m_dwStatus &= ~TF_LBI_STATUS_DISABLED;
	} else {
		m_dwStatus |= TF_LBI_STATUS_DISABLED;
	}
}

inline
void CCicButton::ShowDefault(BOOL fShowDefault)
{
	if( fShowDefault == FALSE ) {
		m_lbiInfo.dwStyle |= TF_LBI_STYLE_HIDDENBYDEFAULT;
	} else {
		m_lbiInfo.dwStyle &= ~TF_LBI_STYLE_HIDDENBYDEFAULT;
	}
}

inline
void CCicButton::SetText(WCHAR *psz)
{
	StrnCopyW(m_szText, psz, CICBTN_TEXT_MAX);
}

inline
void CCicButton::UpdateButton()
{
	if (m_plbiSink)
		m_plbiSink->OnUpdate(TF_LBI_BTNALL| /*TF_LBI_BITMAP |*/ TF_LBI_STATUS /*| TF_LBI_BMPALL*/);
}

#endif // _CICBTN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\cicero.h ===
/****************************************************************************
	CICERO.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Cicero Toolbar Handling

	History:
	29-MAY-2000 cslim       Ported from KKIME
*****************************************************************************/

#ifndef __CICERO_H__
#define __CICERO_H__

#include "msctf.h"

//
// !! external functions must not in the extern "C" {}
//
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

extern BOOL vfCicero;

BOOL WINAPI CiceroInitialize();
BOOL WINAPI CiceroTerminate();
HRESULT WINAPI Cicero_CreateLangBarMgr(ITfLangBarMgr **pppbm);

__inline BOOL WINAPI IsCicero(VOID)
{
	return vfCicero;
}

BSTR OurSysAllocString(const OLECHAR* pOleSz);

#ifdef __cplusplus
}            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#endif // __CICERO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\cmode.h ===
//
// CMODE.H
//

#if !defined (__CMODE_H__INCLUDED_)
#define __CMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class CMode : public CCicButton
{
public:
    CMode(CToolBar *ptb);
    ~CMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
 //   HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:
	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __CMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\cmode.cpp ===
/****************************************************************************
   CMODE.CPP : CMode class implementation which manage conversion mode button
                      on the Cicero Toolbar

   History:
      10-JAN-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "cmode.h"
#include "gdata.h"
#include "ui.h"
#include "winex.h"
#include "resource.h"

// {3CB8145F-8A84-4d53-8899-5783B942FBDE}
const GUID GUID_LBI_KORIME_CMODE = 
{
    0x3cb8145f, 0x8a84, 0x4d53,
    { 0x88, 0x99, 0x57, 0x83, 0xb9, 0x42, 0xfb, 0xde }
};

/*---------------------------------------------------------------------------
    CMode::CMode
---------------------------------------------------------------------------*/
CMode::CMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    szText[0] = L'\0';
        
    // Set Add/Remove text and tootip text
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_TT_HAN_ENG, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_SYSTEMLANGBARITEM_KEYBOARD, 
                GUID_LBI_KORIME_CMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_SHOWNINTRAY | TF_LBI_STYLE_TEXTCOLORICON,
                200, 
                szText);
    SetToolTip(szText);

    // Set button text
    szText[0] = L'\0';
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_BUTTON_HAN_ENG, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}


/*---------------------------------------------------------------------------
    CMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CMode::Release()
{
    long cr;

    cr = --m_cRef;
    DbgAssert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    CMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI CMode::GetIcon(HICON *phIcon)
{
    DWORD dwCM = GetCMode();
    UINT uiIcon = 0;
    static const UINT uidIcons[2][2] = 
    {
        { IDI_CMODE_ENGLISH, IDI_CMODE_ENGLISHW },
        { IDI_CMODE_HANGUL,  IDI_CMODE_HANGULW }
    };

    if (m_pTb->IsOn() && (m_pTb->GetConversionMode() & IME_CMODE_HANGUL))
        uiIcon = 1;

    if (IsHighContrastBlack())
        uiIcon = uidIcons[uiIcon][1];
    else
        uiIcon = uidIcons[uiIcon][0];
    
    *phIcon = (HICON)LoadImage(vpInstData->hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    CMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    CMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
#if 0
    DWORD dwConvMode;

    dwConvMode = m_pTb->GetConversionMode();

    // Toggle Hangul mode
    if (dwConvMode & IME_CMODE_HANGUL)
        dwConvMode &= ~TIP_HANGUL_MODE;
    else
        dwConvMode |= TIP_HANGUL_MODE;

    SetCMode(dwConvMode);
#endif

    keybd_event(VK_HANGUL, 0, 0, 0);
    keybd_event(VK_HANGUL, 0, KEYEVENTF_KEYUP, 0);

    return S_OK;
}

#if 0
//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT CMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    HMENU hMenu;
    DWORD dwConvMode;
    PCIMECtx pImeCtx;
    CHAR  szText[256];
    UINT  uiId;
    int   nRet;

    hMenu      = CreatePopupMenu();
    dwConvMode = GetCMode();

    if (dwConvMode & IME_CMODE_HANGUL)
        uiId = IDS_CIC_ENGLISH_MODE;
    else
        uiId = IDS_CIC_HANGUL_MODE;

    // Add Hangul/English mode menu
    OurLoadStringA(vpInstData->hInst, uiId, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 1, szText);

    // Add Cancel menu
    OurLoadStringA(vpInstData->hInst, IDS_CIC_CANCEL, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 0, szText);

    nRet = TrackPopupMenuEx(hMenu, 
                         TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                         pt.x, pt.y, GetActiveUIWnd(), NULL);
    switch (nRet)
        {
    case 1: 
        dwConvMode = GetCMode();

        // Toggle Hangul mode
        if (dwConvMode & IME_CMODE_HANGUL)
            dwConvMode &= ~IME_CMODE_HANGUL;
        else
            dwConvMode |= IME_CMODE_HANGUL;

        pImeCtx = m_pTb->GetImeCtx();
        if (pImeCtx)
            OurImmSetConversionStatus(pImeCtx->GetHIMC(), 
                                      dwConvMode, pImeCtx->GetSentenceMode());
        break;
        }

    DestroyMenu(hMenu);

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\cimecb.cpp ===
/****************************************************************************
    CIMECB.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IME PAD wrapper functions

    History:
    23-APR-1999 cslim       Created
*****************************************************************************/
#include "precomp.h"
#include "cimecb.h"
#include "pad.h"
#include "UI.h"

static LPCImeCallback g_lpCImeCallback = NULL;

LPCImeCallback CImeCallback::Fetch(VOID)
{
    if(g_lpCImeCallback) {
        return g_lpCImeCallback;
    }
    g_lpCImeCallback = new CImeCallback();
    return g_lpCImeCallback;
}

VOID
CImeCallback::Destroy(VOID)
{
    //OutputDebugString("CImeCallback::Destroy START\n");
    if(g_lpCImeCallback) {
        //OutputDebugString("--> g_lpCImeCallback is allocated\n");
        delete g_lpCImeCallback;
        g_lpCImeCallback = NULL;
    }
    //OutputDebugString("CImeCallback::Destroy END\n");
}

CImeCallback::CImeCallback()
{
    m_cRef = 1;
}

CImeCallback::~CImeCallback()
{

}

HRESULT __stdcall CImeCallback::QueryInterface(REFIID refiid, LPVOID* ppv)
{
    if (ppv == NULL)
        return E_POINTER;

    if(refiid == IID_IUnknown) {
        *ppv = static_cast<IUnknown *>(this);
    }
    else if(refiid == IID_IImeCallback) {
        *ppv = static_cast<IImeCallback *>(this);
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;
}

ULONG    __stdcall CImeCallback::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG   __stdcall CImeCallback::Release()
{
    if(InterlockedDecrement(&m_cRef) == 0) {
        //Delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT __stdcall CImeCallback::GetApplicationHWND(HWND *pHwnd)
{
    //----------------------------------------------------------------
    //Get Application's Window Handle.
    //----------------------------------------------------------------
    if(pHwnd) {
        *pHwnd = GetActiveUIWnd();
        return S_OK;
    }
    return S_FALSE;
}

HRESULT __stdcall CImeCallback::Notify(UINT notify, WPARAM wParam, LPARAM lParam)
{
    HWND hUIWnd;
    
#ifdef _DEBUG
    CHAR szBuf[256];
    wsprintf(szBuf, "Cimecallback::NOtify notify [%d]\n", notify);
    OutputDebugString(szBuf);
#endif
    switch(notify) {
    case IMECBNOTIFY_IMEPADCLOSED:
        //----------------------------------------------------------------
        //ImePad has Closed. repaint toolbar...
        //----------------------------------------------------------------
        // UI::IMEPadNotify();
        hUIWnd = GetActiveUIWnd();
        if (hUIWnd)
            {
            OurPostMessage(hUIWnd, WM_MSIME_UPDATETOOLBAR, 0, 0);
            }
        break;
    default:
        break;
    }
    return S_OK;
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\cicero.cpp ===
/****************************************************************************
    CICERO.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Cicero Toolbar Handling

    History:
    29-MAY-2000 cslim       Ported from KKIME
*****************************************************************************/

#include "precomp.h"
#include "cicero.h"
#include "gdata.h"

BOOL vfCicero = fFalse;

#define SZCICEROMODULE    "msctf.dll"
HMODULE g_hCicero = (HMODULE)0;

#define SZOLEAUTOMODULE    "oleaut32.dll"
HMODULE g_hOleAuto = (HMODULE)0;

typedef HRESULT(* FPTF_CreateLangBarMgr)(ITfLangBarMgr **pppbm);
static FPTF_CreateLangBarMgr pFPTF_CreateLangBarMgr = 0;

typedef BSTR(* FPSysAllocString)(const OLECHAR* pOleSz);
static  FPSysAllocString pFPSysAllocString = 0;

static BOOL IsDisabledTextServices();

/*----------------------------------------------------------------------------
    CiceroInitialize

    Load Cicero Language bar
----------------------------------------------------------------------------*/
BOOL WINAPI CiceroInitialize()
{
    // Winlogon process wouldn't run Cicero
    if (vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON 
        || IsDisabledTextServices())
        return fFalse;
        
    if (g_hCicero == (HMODULE)0) 
        {
        g_hCicero=LoadLibrary(SZCICEROMODULE);
        if (!g_hCicero)
            return fFalse;
        }

    if (g_hOleAuto == (HMODULE)0) 
        {
        g_hOleAuto=LoadLibrary(SZOLEAUTOMODULE);
        if (!g_hOleAuto)
            return fFalse;
        }

    if (pFPTF_CreateLangBarMgr == NULL)
        pFPTF_CreateLangBarMgr = (FPTF_CreateLangBarMgr)GetProcAddress(g_hCicero, "TF_CreateLangBarMgr");

    if (pFPTF_CreateLangBarMgr)
        vfCicero = fTrue;

    if (pFPSysAllocString == NULL)
        pFPSysAllocString = (FPSysAllocString)GetProcAddress(g_hOleAuto, "SysAllocString");

    if (pFPSysAllocString)
        {
        // ok
        }

    return vfCicero;
}

/*----------------------------------------------------------------------------
    CiceroTerminate

    Terminate Cicero Language bar service
----------------------------------------------------------------------------*/
BOOL WINAPI CiceroTerminate()
{
    BOOL fRetCic = fFalse;
    BOOL fRetOle = fFalse;
    
    if (g_hCicero)
        {
        FreeLibrary(g_hCicero);
        g_hCicero = NULL;
        vfCicero = fFalse;
        fRetCic= fTrue;
        }
        
    if (g_hOleAuto)
        {
        FreeLibrary(g_hOleAuto);
        g_hOleAuto = NULL;
        fRetOle    = fTrue;
        }
        
    if (fRetCic && fRetOle)
        return fTrue;
    else        
        return fFalse;
}

/*----------------------------------------------------------------------------
    Cicero_CreateLangBarMgr

    Create Cicero Lang bar manager object
----------------------------------------------------------------------------*/
HRESULT WINAPI Cicero_CreateLangBarMgr(ITfLangBarMgr **pppbm)
{
    *pppbm = NULL;
    
    if (vfCicero && g_hCicero)
        return pFPTF_CreateLangBarMgr(pppbm);

    return S_FALSE;
}

/*----------------------------------------------------------------------------
    OurSysAllocString
----------------------------------------------------------------------------*/
BSTR OurSysAllocString(const OLECHAR* pOleSz)
{
    if (pFPSysAllocString)
        return pFPSysAllocString(pOleSz);

    return NULL;
}

//+---------------------------------------------------------------------------
//
// IsDisabledTextServices
// 
// Copied from immxutil.cpp
//----------------------------------------------------------------------------
BOOL IsDisabledTextServices()
{
    static const TCHAR c_szCTFKey[]     = TEXT("SOFTWARE\\Microsoft\\CTF");
    static const TCHAR c_szDiableTim[]  = TEXT("Disable Thread Input Manager");

    HKEY hKey;

    if (RegOpenKey(HKEY_CURRENT_USER, c_szCTFKey, &hKey) == ERROR_SUCCESS)
    {
        DWORD cb;
        DWORD dwDisableTim = 0;

        cb = sizeof(DWORD);

        RegQueryValueEx(hKey,
                        c_szDiableTim,
                        NULL,
                        NULL,
                        (LPBYTE)&dwDisableTim,
                        &cb);

        RegCloseKey(hKey);

        //
        // Ctfmon disabling flag is set, so return fail CreateInstance.
        //
        if (dwDisableTim)
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\cimecb.h ===
#ifndef __C_IME_CALLBACK_H__
#define __C_IME_CALLBACK_H__
#include "../../fecommon/include/iimecb.h"

class CImeCallback;
typedef CImeCallback*	LPCImeCallback;
class CImeCallback: public IImeCallback
{
public:	
	//----------------------------------------------------------------
	//IUnknown
	//----------------------------------------------------------------
    virtual HRESULT __stdcall QueryInterface(REFIID riid, LPVOID* ppvObj);
    virtual ULONG	__stdcall AddRef();
    virtual ULONG   __stdcall Release();
	//----------------------------------------------------------------
	//IImeConnectionPoint method
	//----------------------------------------------------------------
	virtual HRESULT __stdcall GetApplicationHWND(HWND *pHWND);
	virtual HRESULT __stdcall Notify(UINT notify, WPARAM wParam, LPARAM lParam);
	CImeCallback(FARPROC lpfn);
	CImeCallback();
	~CImeCallback();
	//Temporary
	static LPCImeCallback Fetch(VOID);
	static VOID Destroy(VOID); //990803:ToshiaK
	void *operator new(size_t size) { return GlobalAlloc(GMEM_FIXED, size);}
	void operator  delete(void *pv) { GlobalFree(pv);}
private:	
	static	m_lpCImeCallback;
	LONG	m_cRef; 
};

#endif //__C_IIME_CALLBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\debug.h ===
/****************************************************************************
	DEBUG.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Debug functions

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_DEBUG_H__INCLUDED_)
#define _DEBUG_H__INCLUDED_
//#include <StdArg.H>            // va_list, va_start()

// Debug flag
extern DWORD vdwDebug;

#define	DBGID_API 		0x00000001	// IME API called
#define	DBGID_Key 		0x00000002
#define	DBGID_Mode 		0x00000004
#define	DBGID_UI 		0x00000008
#define	DBGID_UIObj 	0x00000010
#define	DBGID_Cand 		0x00000020
#define	DBGID_Conv 		0x00000040
#define	DBGID_UIWin 	0x00000080
#define	DBGID_IMECnt 	0x00000100
#define	DBGID_Tray 		0x00000200
#define	DBGID_UIMsg 	0x00000400
#define	DBGID_Mem	 	0x00000800
#define	DBGID_ARRData 	0x00001000
#define	DBGID_Mouse	 	0x00002000
#define	DBGID_SendMsg 	0x00004000
#define	DBGID_Automata 	0x00008000
#define	DBGID_IMENotify	0x00010000
#define	DBGID_Hanja 	0x00020000
#define DBGID_CompChar  0x00040000
#define DBGID_IMEDATA   0x00080000
#define DBGID_SetComp   0x00100000
#define DBGID_IMEPAD    0x00200000


#define	DBGID_Misc 		0x01000000

// destination
#define	DBGID_OUTCOM	0x00000000
#define	DBGID_OUTVIDEO	0x10000000
#define	DBGID_OUTFILE	0x20000000

#ifdef DEBUG
// Start of debug code
#define DbgW(a)	DebugOutW(a)
VOID InitDebug(VOID);

#define AST(a) _AST(__FILE__, __LINE__, a, #a, fFalse)
#define AST_EX(a) _AST(__FILE__, __LINE__, a, #a, fTrue)
#define DbgAssert	AST_EX

inline VOID DebugOut(LPCSTR pSz)
	{
	static INT DCLine = 0;
	//
	// out to com
	//
	OutputDebugStringA(pSz);

	//
	// out to video
	//
	if (vdwDebug & DBGID_OUTVIDEO) 
		{
		HDC hDC = GetDC((HWND)0);
		static CHAR sz[512];
		wsprintfA((LPSTR)sz, "%s||", (CHAR*)pSz);
		TextOutA(hDC, 0, DCLine*16, (LPSTR)sz, lstrlenA((LPSTR)sz));

		if( DCLine++ > 50 ) 
			{
			DCLine = 0;
			}
		ReleaseDC( (HWND)0, hDC );
		}

	//
	// out to file
	//
	if (vdwDebug & DBGID_OUTFILE) 
		{
		HANDLE hFile;
		DWORD dwWrite;
		hFile = CreateFile(TEXT("C:\\IMEDBGKO.TXT"), GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0 );
		SetFilePointer(hFile, 0, NULL, FILE_END);
		WriteFile( hFile, pSz, lstrlenA(pSz), &dwWrite, NULL );
		WriteFile( hFile, "\r\n", 2, &dwWrite, NULL );
		CloseHandle(hFile);
		}
	}

inline VOID DebugOutW(LPCWSTR pwSz)
	{	
	static CHAR pSz[1280] = {0};
	INT cwch = lstrlenW( pwSz );
	INT cch = WideCharToMultiByte( 949, 0, (LPWSTR)pwSz, -1, NULL, NULL, NULL, NULL );
	WideCharToMultiByte( 949, 0, (LPWSTR)pwSz, cwch, pSz, sizeof(pSz), NULL, NULL );
	pSz[cch-1] = 0;
	DebugOut( pSz );
	}

inline VOID DebugOutT(LPTSTR pwSz)
	{
	#if !defined (UNICODE)
		DebugOut(pwSz);
	#else
		DebugOutW(pwSz);
	#endif
	}
	
inline void cdecl Dbg( DWORD dID, LPCTSTR szFormat, ...)
	{
	static TCHAR szOutput[512];
	va_list valist;

	szOutput[0] = 0;
	if( vdwDebug & dID ) 
		{
		va_start( valist, szFormat );
		wvsprintf(szOutput, szFormat, valist);
		va_end(valist);
		
		lstrcat(szOutput, TEXT("\r\n"));
		DebugOutT(szOutput);
		}
	return;
	}

inline void _AST(LPCSTR szFile, INT iLine, BOOL fAssert, LPCSTR pSz, BOOL fBreak)
	{
	if( fAssert == fFalse ) 
		{
		static CHAR szOutput[512];
		wsprintfA(szOutput, "* * * * * A S S E R T I O N  F A I L E D * * * * *\r\n%s(%d)  :  value=%d / %s", szFile, iLine, fTrue, pSz  );
		lstrcatA(szOutput, "\r\n");
//#if !defined (UNICODE)
		DebugOut(szOutput);
//#else
//		DebugOutW(szOutput);
//#endif
		if( fBreak == fTrue ) 
			{
			__try 
				{ 
				DebugBreak(); 
				}
			__except(EXCEPTION_EXECUTE_HANDLER) 
				{ 
				OutputDebugStringA("DebugBreak"); 
				}
			}
		}
	}
#else
// Start of retail code
// Define Dbg as void(0) will not compile with 64bit compiler
#define Dbg		/##/	// Dbg should be appeared as one line. Even brace will cause compile error.
#define DbgW	/##/
#define DbgAssert(a)
#define DebugOut(a)
#define DebugOutW(a)
#define DebugOutT(a)
#define AST(a)	
#define AST_EX(a)	
// End of retail code

#endif // ifndef _DEBUG

#endif // !defined (_DEBUG_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\dllmain.h ===
/****************************************************************************
	DLLMAIN.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	DLL Main entry function

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_DLLMAIN_H__INCLUDED_)
#define _DLLMAIN_H__INCLUDED_

extern BOOL vfDllDetachCalled;
void InitImeData();

#endif //!defined (_DLLMAIN_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\dllmain.cpp ===
/****************************************************************************
    DLLMAIN.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    DLL Main entry function

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "dllmain.h"
#include "ui.h"
#include "hauto.h"
#include "config.h"
#include "winex.h"
#include "hanja.h"
#include "cpadsvr.h"
#include "cimecb.h"
#include "cicero.h"
#include "debug.h"


#if 1 // MultiMonitor support
LPFNMONITORFROMWINDOW g_pfnMonitorFromWindow = NULL;
LPFNMONITORFROMPOINT  g_pfnMonitorFromPoint  = NULL;
LPFNMONITORFROMRECT   g_pfnMonitorFromRect   = NULL;
LPFNGETMONITORINFO    g_pfnGetMonitorInfo    = NULL;
#endif

///////////////////////////////////////////////////////////////////////////////
PRIVATE BOOL APIInitialize();
PRIVATE BOOL LoadMMonitorService();
//PRIVATE BOOL DetachIme();

BOOL vfDllDetachCalled = fFalse;

///////////////////////////////////////////////////////////////////////////////
// D L L M A I N
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason)
        {
        case DLL_PROCESS_ATTACH:
        // init Debugger module
        #ifdef _DEBUG
        InitDebug();
            {
            TCHAR sz[128];
            GetModuleFileName( NULL, sz, 127 );
            DebugOutT(TEXT("IMEKR61.IME - DLL_PROCESS_ATTACH - "));
            DebugOutT(sz);
            DebugOutT(TEXT("\r\n"));
            }
        #endif

            ///////////////////////////////////////////////////////////////////
            // Initialize per process data
            vpInstData = &vInstData;
            vpInstData->hInst = hinstDLL;
            vpInstData->dwSystemInfoFlags = 0;

            ///////////////////////////////////////////////////////////////////
            // Default value of fISO10646
            // Default enable 11,172 Hangul.
            // CONFIRM: How to set default of this value for Win95???
            vpInstData->fISO10646 = fTrue;
            vpInstData->f16BitApps = fFalse;
            
            // Load IMM32
            StartIMM();

            // Initialize Shared memory
            CIMEData::InitSharedData();

            // Initialize proc
            APIInitialize();

            // Initialize UI
            RegisterImeUIClass(vpInstData->hInst);
            // init common control
            InitCommonControls();

            // Init UI TLS
            OnUIProcessAttach();

            // Init IME Pad
            CImePadSvr::OnProcessAttach((HINSTANCE)hinstDLL);

            break;

        case DLL_PROCESS_DETACH:
            vfDllDetachCalled = fTrue;
            // IImeCallBack
            CImeCallback::Destroy();

            // IME Pad
            CImePadSvr::OnProcessDetach();

            // UnInit UI TLS
            OnUIProcessDetach();

            // UI uninitialization
            UnregisterImeUIClass(vpInstData->hInst);

            // Close lex file if has opened ever.
            CloseLex();

            // Close shared memory
            CIMEData::CloseSharedMemory();

            // Unload IMM32
            EndIMM();
        
        #ifdef _DEBUG
                {
                TCHAR sz[128];
                GetModuleFileName(NULL, sz, 127);
                DebugOutT(TEXT("IMEKR.IME - DLL_PROCESS_DETACH - "));
                DebugOutT( sz );
                DebugOutT(TEXT("\r\nBye! See you again! *-<\r\nModule name: "));
                DebugOutT(sz);
                }

            // Comment out _CRT_INIT call due to AV in KERNEL32.DLL on Win9x.
             //_CRT_INIT(hinstDLL, dwReason, pvReserved);

        #endif // _DEBUG
            break;

        case DLL_THREAD_ATTACH:
        #ifdef _DEBUG
            DebugOutT(TEXT("DllMain() : DLL_THREAD_ATTACH"));
        #endif
            CImePadSvr::OnThreadAttach();
            break;

        case DLL_THREAD_DETACH:
        #ifdef _DEBUG
            DebugOutT(TEXT("DllMain() : DLL_THREAD_DETACH"));
        #endif
            CImePadSvr::OnThreadDetach();
            OnUIThreadDetach();
            break;
        }
    return fTrue;
}

/*----------------------------------------------------------------------------
    APIInitialize

    Init UI and detect 16 bit apps
----------------------------------------------------------------------------*/
PRIVATE BOOL APIInitialize()
{
    DWORD dwType = 1;    

#ifdef DEBUG
        DebugOutT(TEXT("APIInitialize()\r\n"));
#endif

    // System support Unicode? Win98 and NT support Unicode IME
    vfUnicode = IsUnicodeUI();

    // Register private window messages
    InitPrivateUIMsg();
    
    // Load MultiMonitor procs
    LoadMMonitorService();

   return fTrue;
}


///////////////////////////////////////////////////////////////////////////////
BOOL LoadMMonitorService()
{
#if 1 // MultiMonitor support
    HMODULE hUser32;
#endif

#ifdef DEBUG
    OutputDebugString(TEXT("LoadMMonitorService: \r\n"));
#endif

#if 1 // MultiMonitor support
    //////////////////////////////////////////////////////////////////////////
    // Load Multimonitor functions
    //////////////////////////////////////////////////////////////////////////
    if ((hUser32 = GetModuleHandle(TEXT("USER32"))) &&
        (*(FARPROC*)&g_pfnMonitorFromWindow   = GetProcAddress(hUser32,"MonitorFromWindow")) &&
        (*(FARPROC*)&g_pfnMonitorFromRect     = GetProcAddress(hUser32,"MonitorFromRect")) &&
        (*(FARPROC*)&g_pfnMonitorFromPoint    = GetProcAddress(hUser32,"MonitorFromPoint")) &&
        (*(FARPROC*)&g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoA")))
        {
        return fTrue;
        }
    else
        {
        g_pfnMonitorFromWindow    = NULL;
        g_pfnMonitorFromRect      = NULL;
        g_pfnMonitorFromPoint     = NULL;
        g_pfnGetMonitorInfo          = NULL;
        return fFalse;
        }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\config.cpp ===
/****************************************************************************
    CONFIG.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IME Configuration DLG and registry access functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "ui.h"
#include "imedefs.h"
#include "debug.h"
#include "common.h"
#include "names.h"
#include "winex.h"
#include "config.h"
#include "cicero.h"
#include "resource.h"

// Config DLG Help ID
#define IDH_GRP_STATUSWIN               1001
#define IDH_JUNBAN_TOGGLE               1002
#define IDH_HANJA_CONV                  1003
#define IDH_GRP_KEYLAYOUT               1004
#define IDH_2BEOLSIK                    1005
#define IDH_3BEOLSIK_390                1006
#define IDH_3BEOLSIK_FINAL              1007
#define IDH_DELJASO                     1008
#define IDH_K1HANJA                        1009

// Private functions
static void PASCAL AddPage(LPPROPSHEETHEADERW ppsh, UINT id, DLGPROC pfn);
static INT_PTR CALLBACK ConfigDLGProc1(HWND hDlg, UINT message, 
                                   WPARAM wParam, LPARAM lParam);
static int *GetContextHelpList();
static BOOL IsValidCtrlIdForHelp(INT *helpList, INT ctrlId);
static void GetHelpFileName();

int *GetContextHelpList()
{
    // Context Help Ids of PropertySheet
    static int ProDlgCtxHelpList[] = 
        {
        IDC_GRP_KEYLAYOUT,  IDH_GRP_KEYLAYOUT,
        IDC_GRP_STATUSWIN,  IDH_GRP_STATUSWIN,
        IDC_JUNBAN_TOGGLE,  IDH_JUNBAN_TOGGLE,
        IDC_HANJA_CONV,     IDH_HANJA_CONV,
        IDC_2BEOLSIK,       IDH_2BEOLSIK,   
        IDC_3BEOLSIK_390,   IDH_3BEOLSIK_390,
        IDC_3BEOLSIK_FINAL, IDH_3BEOLSIK_FINAL,
        IDC_DELJASO,        IDH_DELJASO,
        IDC_K1HANJA,        IDH_K1HANJA,
        0,      0
        };
    return ProDlgCtxHelpList;
}

BOOL IsValidCtrlIdForHelp(INT *helpList, INT ctrlId)
{
    INT *p;
    for(p = helpList; *p != 0;  p+=2) 
        {
        if(ctrlId == *p)
            return fTrue;
        }
    return fFalse;
}

void GetHelpFileName(LPTSTR szHelpFileNameFull, int cchszHelpFileNameFull)
{
    // WARNING: This only will work for NT or Win98. For Win95 need to check system locale
    OurLoadStringA(vpInstData->hInst, IDS_CONTEXTHELP_FILENAME, szHelpFileNameFull, MAX_PATH);
}

static HWND hwndPropSheet = (HWND)0;
static BOOL g_fDestroyPropNow = FALSE;

BOOL ConfigDLG(HWND hwndParent)
{
    static HPROPSHEETPAGE  rPages[1];
    static PROPSHEETHEADERW psh;
       static WCHAR szCaption[64];
    MSG    msg;
    BOOL   fRet = fFalse;

    // If config DLG already created
    if (IsWindow(hwndPropSheet))
        {
        SetForegroundWindow(hwndPropSheet);
        return fTrue;
        }

    // init msg
    ZeroMemory(&msg, sizeof(MSG));
    
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_NOAPPLYNOW | PSH_USEICONID | PSH_MODELESS | PSH_USEPAGELANG;
    psh.hwndParent = hwndParent;
    psh.hInstance = vpInstData->hInst;

    if (IsWinNT())
        OurLoadStringW(vpInstData->hInst, IDS_PROGRAM, szCaption, sizeof(szCaption)/sizeof(WCHAR));
    else
        OurLoadStringA(vpInstData->hInst, IDS_PROGRAM, (LPSTR)szCaption, sizeof(szCaption));
    psh.pszCaption = szCaption;
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = rPages;

    AddPage(&psh, IDD_CONFIG_PAGE1, ConfigDLGProc1);

//    if (PropertySheet(&psh) != -1)
//        return fTrue;
//    else
//        return fFalse;
    
    if (IsWinNT())
        hwndPropSheet = (HWND)PropertySheetW(&psh);
    else
        hwndPropSheet = (HWND)PropertySheetA((PROPSHEETHEADERA*)&psh);

    while (IsWindow(hwndPropSheet) && OurGetMessage(&msg, NULL, 0x00, 0x00))
        {
        // If the modeless guy is up and is ready to be destroyed
        // (PropSheet_GetCurrentPageHwnd returns NULL) then destroy the dialog.
        
        // PropSheet_GetCurrentPageHwnd will return NULL after the OK or Cancel 
        // button has been pressed and all of the pages have been notified. The 
        // Apply button doesn't cause this to happen.
        if(/*g_fDestroyPropNow == fTrue || */(hwndPropSheet && (NULL == PropSheet_GetCurrentPageHwnd(hwndPropSheet)))) {
            //enable the parent first to prevent another window from becoming the foreground window
            //EnableWindow(hwndParent, TRUE);
            DestroyWindow(hwndPropSheet);
            //break;
        }

        //use PropSheet_IsDialogMessage instead of IsDialogMessage
        if(!PropSheet_IsDialogMessage(hwndPropSheet, &msg))
            {
            TranslateMessage(&msg);
            if (IsWinNT())
                DispatchMessageW(&msg);
            else
                DispatchMessageA(&msg);
            }
        }
    
    hwndPropSheet = (HWND)0;
    
//    if (g_fDestroyPropNow == fTrue) // closed a property sheet by the other process
//        PostMessage(hwndParent, WM_PAUSERESUME, TRUE, FALSE);    // close engine

//    g_fDestroyPropNow = fFalse;

    return fTrue;
}

void PASCAL AddPage(LPPROPSHEETHEADERW ppsh, UINT idDlg, DLGPROC pfn)
{
    //if (ppsh->nPages < 3)
    //{
    PROPSHEETPAGE psp;
    ZeroMemory(&psp, sizeof(psp));

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DLGINDIRECT;
    psp.hInstance = vpInstData->hInst;
    psp.pResource = ExLoadDialogTemplate(GetSystemDefaultLangID(), vpInstData->hInst, MAKEINTRESOURCE(idDlg));
    psp.pfnDlgProc = pfn;
    psp.lParam = 0;

    ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);
    if (ppsh->phpage[ppsh->nPages])
      ppsh->nPages++;
   //}
}

INT_PTR CALLBACK ConfigDLGProc1(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    UINT i;
    static StatusButtonTypes prevButtonTypes[MAX_NUM_OF_STATUS_BUTTONS];
    static UINT    uPrevNumOfButtons, uPrevKeyboardType;
    static BOOL    fPrevJasoDel;
    static BOOL fK1Hanja;
    BOOL fShowIME=fTrue;
    BOOL fFound = fFalse;
    TCHAR  szHelpFileNameFull[MAX_PATH];
    CIMEData    ImeData(CIMEData::SMReadWrite);

    // When no IME instance is running on the system, we should init shared mem.
    ImeData.InitImeData();

    Dbg(DBGID_Misc, TEXT("ConfigDLGProc"));

    switch(message)
        {
        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
                {
            case PSN_APPLY:
                DbgAssert(uPrevNumOfButtons <= MAX_NUM_OF_STATUS_BUTTONS);
                ImeData->uNumOfButtons = uPrevNumOfButtons;

                for (i = 0; i<MAX_NUM_OF_STATUS_BUTTONS; i++)
                    ImeData->StatusButtons[i].m_ButtonType = prevButtonTypes[i];

                UpdateStatusButtons(ImeData);
                UpdateStatusWinDimension();

                ImeData.SetCurrentBeolsik(uPrevKeyboardType);
                ImeData.SetJasoDel(fPrevJasoDel);
                ImeData.SetKSC5657Hanja(fK1Hanja);
                SetRegValues(GETSET_REG_STATUS_BUTTONS|GETSET_REG_IMEKL|GETSET_REG_JASODEL|GETSET_REG_KSC5657);
                break;
                    
            default:
                return fFalse;
                }
            break;

        case WM_INITDIALOG:
            DbgAssert(ImeData->uNumOfButtons <= MAX_NUM_OF_STATUS_BUTTONS);
            uPrevNumOfButtons = ImeData->uNumOfButtons;

            // Backup current button status
            for (i=0; i<MAX_NUM_OF_STATUS_BUTTONS; i++)
                prevButtonTypes[i] = ImeData->StatusButtons[i].m_ButtonType;

            for (i = 0; i < uPrevNumOfButtons; i++) 
                {
                switch (prevButtonTypes[i]) 
                    {
                    case JUNJA_BANJA_TOGGLE_BUTTON:
                        CheckDlgButton(hDlg, IDC_JUNBAN_TOGGLE, BST_CHECKED);
                        break;
                    case HANJA_CONV_BUTTON:
                        CheckDlgButton(hDlg, IDC_HANJA_CONV, BST_CHECKED);
                        break;
                    case IME_PAD_BUTTON:
                        CheckDlgButton(hDlg, IDC_IMEPAD, BST_CHECKED);
                        break;
                    }
                }

            // Get Show IME stataus window flag
            // If this flag is fFalse disable all show button check boxes
            SystemParametersInfo(SPI_GETSHOWIMEUI, 0, (PVOID)&fShowIME, 0);
            if (fShowIME==fFalse || IsCicero())
                {
                EnableWindow(GetDlgItem(hDlg, IDC_JUNBAN_TOGGLE), fFalse);
                EnableWindow(GetDlgItem(hDlg, IDC_HANJA_CONV), fFalse);
                EnableWindow(GetDlgItem(hDlg, IDC_IMEPAD), fFalse);
                }

            #if defined(_WIN64)
                EnableWindow(GetDlgItem(hDlg, IDC_IMEPAD), fFalse);
            #endif

            uPrevKeyboardType = ImeData.GetCurrentBeolsik();
            CheckRadioButton(hDlg, IDC_2BEOLSIK, IDC_3BEOLSIK_FINAL, IDC_2BEOLSIK+uPrevKeyboardType);
            fPrevJasoDel = ImeData.GetJasoDel();
            if (fPrevJasoDel)
                CheckDlgButton(hDlg, IDC_DELJASO, BST_CHECKED);
            else
                CheckDlgButton(hDlg, IDC_DELJASO, BST_UNCHECKED);

            // KSC-5657 Hanja
            fK1Hanja = ImeData.GetKSC5657Hanja() && (vpInstData->f16BitApps == fFalse) && !IsWin95();
            if (fK1Hanja)
                CheckDlgButton(hDlg, IDC_K1HANJA, BST_CHECKED);
            else
                CheckDlgButton(hDlg, IDC_K1HANJA, BST_UNCHECKED);

            // If 16 bit Apps disable K1 Hanja
            if (vpInstData->f16BitApps || IsWin95())
                EnableWindow(GetDlgItem(hDlg, IDC_K1HANJA), fFalse);

            return fTrue;

        case WM_COMMAND:
            switch (wParam)
               {
            case IDC_2BEOLSIK:
                //if (IsDlgButtonChecked(hDlg, IDC_2BEOLSIK)) {
                    uPrevKeyboardType = KL_2BEOLSIK;
                //}
                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_3BEOLSIK_390:
                uPrevKeyboardType = KL_3BEOLSIK_390;
                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_3BEOLSIK_FINAL:
                uPrevKeyboardType = KL_3BEOLSIK_FINAL;
                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;
                
            case IDC_JUNBAN_TOGGLE:
                // Jun/Banja toggle button setting
                if (IsDlgButtonChecked(hDlg, IDC_JUNBAN_TOGGLE)) 
                    {
                    if (prevButtonTypes[1] != JUNJA_BANJA_TOGGLE_BUTTON)
                        {
                        for (i = uPrevNumOfButtons-1; i >= 1; i--)
                            prevButtonTypes[i+1] = prevButtonTypes[i];
                        prevButtonTypes[1] = JUNJA_BANJA_TOGGLE_BUTTON;
                        uPrevNumOfButtons++;
                        }
                    }
                else 
                    {
                    if (prevButtonTypes[1] == JUNJA_BANJA_TOGGLE_BUTTON)
                        {
                        for (i = 1; i < uPrevNumOfButtons-1; i++)
                            prevButtonTypes[i] = prevButtonTypes[i+1];
                        prevButtonTypes[uPrevNumOfButtons] = NULL_BUTTON;
                        uPrevNumOfButtons--;
                        }
                    }
                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_HANJA_CONV:
                for (i = 1; i < uPrevNumOfButtons; i++)
                    {
                    if (prevButtonTypes[i] == HANJA_CONV_BUTTON)
                        {
                        fFound = fTrue;
                        break;
                        }
                    }
                    
                // Hanja conv button setting
                if (IsDlgButtonChecked(hDlg, IDC_HANJA_CONV))
                    {
                    if (fFound == fFalse)
                        {
                        if (prevButtonTypes[uPrevNumOfButtons-1] == IME_PAD_BUTTON)
                            {
                            prevButtonTypes[uPrevNumOfButtons-1] = HANJA_CONV_BUTTON;
                            prevButtonTypes[uPrevNumOfButtons] = IME_PAD_BUTTON;
                            }
                        else
                            {
                            prevButtonTypes[uPrevNumOfButtons] = HANJA_CONV_BUTTON;
                            }
                        uPrevNumOfButtons++;
                        }
                    }
                else
                    {
                    if (fFound == fTrue)
                        {
                        uPrevNumOfButtons--;
                        for (; i < uPrevNumOfButtons; i++)
                            prevButtonTypes[i] = prevButtonTypes[i+1];
                        prevButtonTypes[uPrevNumOfButtons] = NULL_BUTTON;
                        }
                    }

                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_IMEPAD:
                if (IsDlgButtonChecked(hDlg, IDC_IMEPAD))
                    {
                    if (prevButtonTypes[uPrevNumOfButtons-1] != IME_PAD_BUTTON)
                        prevButtonTypes[uPrevNumOfButtons++] = IME_PAD_BUTTON;
                    }
                else
                    {
                    if (prevButtonTypes[uPrevNumOfButtons-1] == IME_PAD_BUTTON)
                        prevButtonTypes[--uPrevNumOfButtons] = NULL_BUTTON;
                    }

                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_DELJASO:
                if (IsDlgButtonChecked(hDlg, IDC_DELJASO))
                    fPrevJasoDel = fTrue;
                else
                    fPrevJasoDel = fFalse;

                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_K1HANJA:
                if (IsDlgButtonChecked(hDlg, IDC_K1HANJA))
                    fK1Hanja = fTrue;
                else
                    fK1Hanja = fFalse;
                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            default:
                return fFalse;
               }
            break;

        case WM_CONTEXTMENU:
            GetHelpFileName(szHelpFileNameFull, MAX_PATH);
            WinHelp((HWND)wParam, 
                    szHelpFileNameFull, 
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)(LPVOID)GetContextHelpList());
            return 0;

        case WM_HELP:
            INT *pHelpList;
            pHelpList = GetContextHelpList();
            if(IsValidCtrlIdForHelp(pHelpList, ((LPHELPINFO)lParam)->iCtrlId)) 
                {
                GetHelpFileName(szHelpFileNameFull, MAX_PATH);
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                        szHelpFileNameFull,
                        HELP_WM_HELP,
                        (ULONG_PTR)pHelpList);
                }
            return 0;

        default:
            return fFalse;
        }
    return fTrue;
}

BOOL GetStatusWinPosReg(POINT *pptStatusWinPosReg)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb;
    BOOL    fSuccess = fFalse;

    // Prevent Winlogon process from accessing registry
    if ((vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON)) 
        return fFalse;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, g_szIMEKL, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        dwCb = sizeof(dwBuf);
        if (RegQueryValueEx(hKey, g_szStatusPos, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS)
            {
            pptStatusWinPosReg->x = HIWORD(dwBuf);
            pptStatusWinPosReg->y = LOWORD(dwBuf);
            fSuccess = fTrue;
            }
            
        RegCloseKey(hKey);
        }

    return fSuccess;
}

///////////////////////////////////////////////////////////////////////////////
//
BOOL GetRegValues(UINT uGetBits)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb, dwType;
    CHAR    szLexFileName[MAX_PATH];
    CIMEData    ImeData(CIMEData::SMReadWrite);
    BOOL    fSuccess = fTrue;

    Dbg(DBGID_Misc, "GetRegValues()");

    if (RegOpenKeyEx(HKEY_CURRENT_USER, g_szIMERootKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        ///////////////////////////////////////////////////////////////////
        // IME Keyboard Layout
        if (uGetBits & GETSET_REG_IMEKL) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szIMEKL, NULL, NULL, (LPBYTE)&dwBuf, &dwCb)
                == ERROR_SUCCESS) 
                {
                if (/*dwBuf >= KL_2BEOLSIK &&*/ dwBuf <= KL_3BEOLSIK_FINAL)
                    ImeData.SetCurrentBeolsik(dwBuf);
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Status window pos
        if (uGetBits & GETSET_REG_STATUSPOS) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szStatusPos, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS)
                {
                ImeData->ptStatusPos.x = HIWORD(dwBuf);
                ImeData->ptStatusPos.y = LOWORD(dwBuf);
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Status window button setting
        if (uGetBits & GETSET_REG_STATUS_BUTTONS) 
            {
            BYTE ButtonReg[MAX_NUM_OF_STATUS_BUTTONS+1];
            int        nButton;

            dwCb = sizeof(ButtonReg);
            dwType = REG_BINARY;
            if (RegQueryValueEx(hKey, g_szStatusButtons, NULL, &dwType, (LPBYTE)&ButtonReg, &dwCb) == ERROR_SUCCESS)
                {
                if (ButtonReg[0] == 0)
                    ButtonReg[0] = 1;
                    
                if (ButtonReg[0]<=MAX_NUM_OF_STATUS_BUTTONS) 
                    {
                    for (nButton=0; nButton<ButtonReg[0]; nButton++) 
                        {
                        // button data validity check
                    #if !defined(_WIN64)
                        if (ButtonReg[nButton+1] <= IME_PAD_BUTTON && ButtonReg[nButton+1] != NULL_BUTTON)
                    #else
                        if (ButtonReg[nButton+1] <= HANJA_CONV_BUTTON && ButtonReg[nButton+1] != NULL_BUTTON)
                    #endif
                            ImeData->StatusButtons[nButton].m_ButtonType = (StatusButtonTypes)ButtonReg[nButton+1];
                        else
                            break;
                        }
                    ImeData->uNumOfButtons = nButton;
                    UpdateStatusButtons(ImeData);
                    UpdateStatusWinDimension();
                    }
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Deletion by Jaso
        if (uGetBits & GETSET_REG_JASODEL) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szCompDel, NULL, NULL, (LPBYTE)&dwBuf, &dwCb)
                    == ERROR_SUCCESS)
                ImeData.SetJasoDel(dwBuf);
            }


        if (uGetBits & GETSET_REG_ISO10646) 
            {
            Dbg(DBGID_Misc, "GetRegValues() : vpInstData->f16BitApps = %d", vpInstData->f16BitApps);

            // If 16bit apps, always disable ISO10646(full range Hangul)
            if (vpInstData->f16BitApps == fTrue)
                {
                vpInstData->fISO10646 = fFalse;
                }
            else
                {
                dwCb = sizeof(dwBuf);
                if (RegQueryValueEx(hKey, g_szXWEnable, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) 
                    == ERROR_SUCCESS)
                    vpInstData->fISO10646 = dwBuf;
                else
                    fSuccess = fFalse;

                // For Win95 and Win98 lookup INI file for ISO10646 setting.
                // ISO10646.EXE set registry
                if (!IsWinNT())
                    vpInstData->fISO10646 = GetProfileInt(g_szXWEnable, 
                                                    OurGetModuleFileName(fFalse), 
                                                    vpInstData->fISO10646);
                }
            }

        // Get KSC5657 K1 Hanja flag
        if (uGetBits & GETSET_REG_KSC5657) 
            {
            dwCb = sizeof(dwBuf);
            dwType = REG_DWORD;
            if (RegQueryValueEx(hKey, g_szEnableK1Hanja, NULL, &dwType, (LPBYTE)&dwBuf, &dwCb)    == ERROR_SUCCESS) 
                ImeData->fKSC5657Hanja = dwBuf;
            else
                ImeData->fKSC5657Hanja = fFalse;
            }

        // Get Unicode Tooltip Cand window flag
        // Currently this has no UI part which means hidden spec so no need SetReg now.
        if (uGetBits & GETSET_REG_CANDUNICODETT) 
            {
            dwCb = sizeof(dwBuf);
            dwType = REG_DWORD;
            if (RegQueryValueEx(hKey, g_szEnableCandUnicodeTT, NULL, &dwType, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS) 
                ImeData->fCandUnicodeTT = dwBuf;
            else
                ImeData->fCandUnicodeTT = fFalse;
            }

        RegCloseKey(hKey);
        }
    else
        {
        fSuccess = fFalse;
        // DbgBreak can happen when logon and cumbersome especially in stress machine running chk build.
        // DbgAssert(0);
        }

    return fSuccess;
}

BOOL SetRegValues(UINT uSetBits)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb;
    int        nButton;
    CIMEData    ImeData;

    ///////////////////////////////////////////////////////////////////////////
    // Set status pos
    if (RegCreateKey(HKEY_CURRENT_USER, g_szIMERootKey, &hKey) == ERROR_SUCCESS) 
        {
        if (uSetBits & GETSET_REG_STATUSPOS) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = (ImeData->ptStatusPos.x << 16) | (ImeData->ptStatusPos.y & 0xFFFF);  // HIWORD : X, LOWORD : Y
            RegSetValueEx(hKey, g_szStatusPos, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);

            }

        if (uSetBits & GETSET_REG_STATUS_BUTTONS) 
            {
            BYTE ButtonReg[MAX_NUM_OF_STATUS_BUTTONS+1];
            dwCb = sizeof(ButtonReg);

            DbgAssert(ImeData->uNumOfButtons <= MAX_NUM_OF_STATUS_BUTTONS);
            // set number of button as the first element of array
            if (ImeData->uNumOfButtons<=MAX_NUM_OF_STATUS_BUTTONS)
                ButtonReg[0] = (BYTE)ImeData->uNumOfButtons;

            for (nButton=0; nButton < (INT)ImeData->uNumOfButtons; nButton++) 
                ButtonReg[nButton+1] = ImeData->StatusButtons[nButton].m_ButtonType;
                
            // clear
            for (; nButton<MAX_NUM_OF_STATUS_BUTTONS; nButton++)
                ButtonReg[nButton+1] = NULL_BUTTON;

            RegSetValueEx(hKey, g_szStatusButtons, 0, REG_BINARY, (LPBYTE)&ButtonReg, dwCb);
            }


        if (uSetBits & GETSET_REG_IMEKL) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetCurrentBeolsik();
            RegSetValueEx(hKey, g_szIMEKL, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }
        
        if (uSetBits & GETSET_REG_JASODEL) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetJasoDel();
            RegSetValueEx(hKey, g_szCompDel, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }

        // Get KSC5657 K1 Hanja flag
        if (uSetBits & GETSET_REG_KSC5657) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetKSC5657Hanja();
            RegSetValueEx(hKey, g_szEnableK1Hanja, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }

        RegCloseKey(hKey);
        }
    else 
        return fFalse;
        
    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\compui.cpp ===
/****************************************************************************
    COMPUI.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Composition window UI functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "ui.h"
#include "imedefs.h"
#include "names.h"
#include "escape.h"
#include "winex.h"
#include "cicero.h"
#include "debug.h"
#include "resource.h"

PRIVATE  VOID PASCAL PaintCompWindow(HWND hCompWnd, HDC hDC);

///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK CompWndProc(HWND hCompWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    Dbg(DBGID_UI, TEXT("CompWndProc():uMessage = 0x%08lX, wParam = 0x%04X, lParam = 0x%08lX"), uMessage, wParam, lParam);

    switch (uMessage)
        {
        case WM_IME_CHAR: 
        case WM_IME_COMPOSITIONFULL:
        case WM_IME_COMPOSITION:
        case WM_IME_CONTROL:
        case WM_IME_SELECT:
        case WM_IME_SETCONTEXT:
        case WM_IME_STARTCOMPOSITION:
        case WM_IME_ENDCOMPOSITION:
            return (0L);

        case WM_PAINT:
            {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hCompWnd, &ps);
            PaintCompWindow(hCompWnd, hDC);
            EndPaint(hCompWnd, &ps);
            }
            break;
        default :
            return DefWindowProc(hCompWnd, uMessage, wParam, lParam);
        }
    return (0L);
}

VOID PASCAL PaintCompWindow(HWND hCompWnd, HDC hDC)
{
    HWND        hWndUI;
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    HFONT        hFontFix, hOldFont;
    HBITMAP        hBMComp;
    INT         iSaveBkMode;

    hWndUI = GetWindow(hCompWnd, GW_OWNER);
    hIMC = GethImcFromHwnd(hWndUI);


    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return;

       Dbg(DBGID_UI, TEXT("PaintCompWindow():CompCh = 0x%X"), pImeCtx->GetCompBufStr());

    if (pImeCtx->GetCompBufLen())
        {
        // Create font
        if (IsWinNT())
            hFontFix = CreateFontW(
                            -16,0,0,0, 
                            0,0,0,0,
                            HANGUL_CHARSET,
                            OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, 
                             DEFAULT_QUALITY, 
                             FIXED_PITCH, 
                             wzIMECompFont);
         else
            hFontFix = CreateFontA(
                            -16,0,0,0, 
                            0,0,0,0,
                            HANGUL_CHARSET,
                            OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, 
                             DEFAULT_QUALITY, 
                             FIXED_PITCH, 
                             szIMECompFont);
        hOldFont = (HFONT)SelectObject(hDC, hFontFix);

        // Draw comp window Bitmap
        hBMComp = (HBITMAP)OurLoadImage(MAKEINTRESOURCE(IDB_COMP_WIN), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );
        DrawBitmap(hDC, 0, 0, hBMComp);
        
        iSaveBkMode = SetBkMode(hDC, TRANSPARENT);
        // Set text color
        SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
        OurTextOutW(hDC, 3, 3, pImeCtx->GetCompBufStr());

        // restore and delete created objects
        SelectObject(hDC, hOldFont);
        SetBkMode(hDC, iSaveBkMode);
        DeleteObject(hBMComp);
        DeleteObject(hFontFix);
        }
}

// open comp window
VOID PASCAL OpenComp(HWND hUIWnd)
{
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    INT         nShowCompCmd;
    POINT        ptClientComp;
    CIMEData    ImeData;

       Dbg(DBGID_UI, TEXT("OpenComp()"));

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    // can not draw comp window
    if (!hUIPrivate) 
        {
        DbgAssert(0);
        return;
        }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)
        return;

    // Check WM_IME_SETCONTEXT lParam
    if ((lpUIPrivate->uiShowParam & ISC_SHOWUICOMPOSITIONWINDOW) == 0)
        goto OpenCompUnlockUIPriv;
    
    hIMC = GethImcFromHwnd(hUIWnd);
    pImeCtx = GetIMECtx(hIMC);
    if (pImeCtx == NULL) 
        {
        Dbg(DBGID_UI, TEXT("OpenComp - Invalid hImc"));

        ImeData->ptCompPos.x = ImeData->rcWorkArea.right - COMP_SIZEX;
        ImeData->ptCompPos.y = ImeData->rcWorkArea.bottom - COMP_SIZEY;
        nShowCompCmd = SW_HIDE;
        } 
    else 
        {
#if 1 // MultiMonitor
        RECT rcWorkArea;
        
        ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcWorkArea);

        // if client window exist in same monitor as status window
        if (!IsCicero() && PtInRect(&rcWorkArea, ImeData->ptStatusPos)) 
            {
            ImeData->ptCompPos.x = 
                (ImeData->ptStatusPos.x+ImeData->xStatusWi+UI_GAPX + COMP_SIZEX > ImeData->rcWorkArea.right) ?
                ImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : ImeData->ptStatusPos.x + ImeData->xStatusWi + UI_GAPX;
            ImeData->ptCompPos.y = ImeData->ptStatusPos.y;
            Dbg(DBGID_UI, TEXT("OpenComp - PtInRect x = %d, y = %d"), ImeData->ptCompPos.x, ImeData->ptCompPos.y);
            }
        else 
            {   
            // if client window appeared in different monitor from status window resides,
            // then display left top of workarea of client window montitor
            ImeData->ptCompPos.x = 0;
            ImeData->ptCompPos.y = 0;
            }
#else
        ImeData->ptCompPos.x = 
            (ImeData->ptStatusPos.x+ImeData->xStatusWi+UI_GAPX + COMP_SIZEX > ImeData->rcWorkArea.right) ?
            ImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : ImeData->ptStatusPos.x + ImeData->xStatusWi + UI_GAPX;
        ImeData->ptCompPos.y = ImeData->ptStatusPos.y;
#endif
        // Set Comp wnd position of HIMC in client coordinate
        ptClientComp = ImeData->ptCompPos;
           ScreenToClient(pImeCtx->GetAppWnd(), &ptClientComp);
           pImeCtx->SetCompositionFormPos(ptClientComp);

        nShowCompCmd = SW_SHOWNOACTIVATE;
        } 

    if (lpUIPrivate->hCompWnd) 
        {
        SetWindowPos(lpUIPrivate->hCompWnd, NULL,
                    ImeData->ptCompPos.x, ImeData->ptCompPos.y,
                    0, 0,
                    SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
        } 
    else 
        {
           Dbg(DBGID_UI, TEXT("OpenComp - CreateWindow x = %d, y = %d"), ImeData->ptCompPos.x, ImeData->ptCompPos.y);
        // create comp window
        lpUIPrivate->hCompWnd = CreateWindow(
                                    szCompClassName, TEXT("\0"),
                                    WS_DISABLED | WS_POPUP,
                                    ImeData->ptCompPos.x, ImeData->ptCompPos.y,
                                    COMP_SIZEX, COMP_SIZEX, 
                                    hUIWnd, (HMENU)NULL, vpInstData->hInst, NULL);
        DbgAssert(lpUIPrivate->hCompWnd != 0);
        
        //if (!lpUIPrivate->hCompWnd)
        //    goto OpenCompUnlockUIPriv;
        }
    
    //if (pImeCtx)
    //    ShowComp(hUIWnd, SW_SHOWNOACTIVATE);

OpenCompUnlockUIPriv:
    GlobalUnlock(hUIPrivate);
    return;
    }

// Show the composition window
VOID ShowComp(HWND hUIWnd, INT nShowCompCmd)
    {
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    
    Dbg(DBGID_UI, TEXT("ShowComp(): nShowCompCmd = %d"), nShowCompCmd);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);

    // can not draw comp window
    if (!hUIPrivate)
        {
        DbgAssert(0);
        return;
        }
        
    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)
        {
        DbgAssert(0);
        return;
        }

    hIMC = GethImcFromHwnd(hUIWnd);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        goto SwCompNoChange;

    // b#53794
    // Some absurd Apps send WM_IME_START_COMPOSITION and WM_IME_COMPOSITION,
    // even though they have no composition string
    // In this case wrong composition window appears in screen like white square or something.
    if (nShowCompCmd == SW_SHOWNOACTIVATE)
        {
        if (pImeCtx->GetCompBufLen() == 0 || vfWndOpen[COMP_WINDOW] == fFalse)
            nShowCompCmd = SW_HIDE;
        }

    if (lpUIPrivate->nShowCompCmd == nShowCompCmd)
        goto SwCompNoChange;

    if (lpUIPrivate->hCompWnd) 
        {
        ShowWindow(lpUIPrivate->hCompWnd, nShowCompCmd);
        lpUIPrivate->nShowCompCmd = nShowCompCmd;
        }
    else
        lpUIPrivate->nShowCompCmd = SW_HIDE;

SwCompNoChange:
    GlobalUnlock(hUIPrivate);
}


BOOL fSetCompWindowPos(HWND hCompWnd)
{
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    RECT        rcCur;
    POINT         ptNew;
    CIMEData    ImeData;

    // No composition window
    if (hCompWnd == 0)
        return fFalse;

    hIMC = GethImcFromHwnd(GetWindow(hCompWnd, GW_OWNER));
    //if (!hIMC) 
    //    {
    //    DbgAssert(0);
    //    return fFalse;
    //    }

    //lpIMC = (LPINPUTCONTEXT)OurImmLockIMC(hIMC);
    //if (!lpIMC)
    //    {
    //    DbgAssert(0);
    //    return fFalse;
    //    }

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;
        
    Dbg(DBGID_UI, TEXT("fSetCompWindowPos()"));

    if (pImeCtx->GetCompositionFormStyle() & CFS_RECT)
        {
        Dbg(DBGID_UI, TEXT("fSetCompWindowPos(): CFS_RECT"));
        pImeCtx->GetCompositionForm(&rcCur);
        ptNew.x = rcCur.left;
        ptNew.y = rcCur.top;
        ClientToScreen(pImeCtx->GetAppWnd(), &ptNew);
        }
    else 
        if (pImeCtx->GetCompositionFormStyle() & CFS_POINT)
        {
        Dbg(DBGID_UI, TEXT("fSetCompWindowPos(): CFS_POINT"));
        pImeCtx->GetCompositionForm(&ptNew);
        ClientToScreen(pImeCtx->GetAppWnd(), &ptNew);
        }
        else 
            {   // For CFS_DEFAULT
            Dbg(DBGID_UI, TEXT("fSetCompWindowPos(): CFS_DEFAULT"));
    #if 1 // MultiMonitor
            RECT  rcWorkArea;

            ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcWorkArea);
                
            // if client window exist in same monitor as status window
            if ( PtInRect(&rcWorkArea, ImeData->ptStatusPos) ) 
                {
                ptNew.x = 
                    (ImeData->ptStatusPos.x+ImeData->xStatusWi+UI_GAPX + COMP_SIZEX > ImeData->rcWorkArea.right) ?
                    ImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : ImeData->ptStatusPos.x + ImeData->xStatusWi + UI_GAPX;
                ptNew.y = ImeData->ptStatusPos.y;
                }
            else 
                {    // if client window appeared in different monitor from status window resides,
                    // then display right bottom of workarea of client window montitor
                ptNew.x = rcWorkArea.right - COMP_SIZEX;
                ptNew.y = rcWorkArea.bottom - COMP_SIZEY;
                }
    #else
            ptNew.x = 
                (ImeData->ptStatusPos.x+ImeData->xStatusWi+UI_GAPX + COMP_SIZEX > ImeData->rcWorkArea.right) ?
                ImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : ImeData->ptStatusPos.x + ImeData->xStatusWi + UI_GAPX;
            ptNew.y = ImeData->ptStatusPos.y;
    #endif
            ImeData->ptCompPos = ptNew;
            ScreenToClient(pImeCtx->GetAppWnd(), &ptNew);
            pImeCtx->SetCompositionFormPos(ptNew);
            }

    SetWindowPos(hCompWnd, NULL,
                ptNew.x, ptNew.y,
                0, 0, SWP_NOACTIVATE|SWP_NOCOPYBITS|SWP_NOSIZE|SWP_NOZORDER);

    return (fTrue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\config.h ===
/****************************************************************************
	CONFIG.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IME Configuration DLG and registry access functions

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_CONFIG_H__INCLUDED_)
#define _CONFIG_H__INCLUDED_

//////////////////////////////////////////////////////////////////////////////
// Bit const for SetRegValues
#define GETSET_REG_STATUSPOS		0x0001
#define GETSET_REG_IMEKL			0x0002
#define GETSET_REG_JASODEL			0x0004
#define GETSET_REG_ISO10646			0x0008
#define GETSET_REG_STATUS_BUTTONS	0x0010
#define GETSET_REG_KSC5657			0x0020
#define GETSET_REG_CANDUNICODETT	0x0040
#define GETSET_REG_ALL				0xFFFF

extern BOOL ConfigDLG(HWND hWnd);
extern BOOL GetRegValues(UINT uGetBits);	// get configuration info from reg. and set it to pImeData
extern BOOL GetStatusWinPosReg(POINT *pptStatusWinPosReg);
extern BOOL SetRegValues(UINT uSetBits); // set configuration info to reg.


#endif //!defined (_CONFIG_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\debug.cpp ===
/****************************************************************************
    DEBUG.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Debug functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#ifdef DEBUG

#include "PreComp.h"
#include "debug.h"
#include "common.h"

// ====-- SHARED SECTION START --====
#pragma data_seg(".DBGSHR")
DWORD vdwDebug = DBGID_OUTCOM;    // Default output to COM port
#pragma data_seg() 
// ====-- SHARED SECTION END --====

VOID InitDebug(VOID)
{
    HKEY        hKey;
    DWORD        size;
    BOOL        rc = fFalse;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, g_szIMERootKey, 0, KEY_READ, &hKey) !=  ERROR_SUCCESS) 
        {
        return;
        }
    size = sizeof(DWORD);
    if ( RegQueryValueEx( hKey, TEXT("DebugOption"), NULL, NULL, (LPBYTE)&vdwDebug, &size) ==  ERROR_SUCCESS) 
        {
        rc = fTrue;
        }

    RegCloseKey( hKey );

    return;
}

#endif  // _DEBUG

/*------------------------------------------------------------------------
    _purecall

    Stub for that super-annoying symbol the compiler generates for pure
    virtual functions
    Copied from MSO9 Dbgassert.cpp
---------------------------------------------------------------- RICKP -*/
int __cdecl _purecall(void)
{
#ifdef DEBUG
    DbgAssert(0);
    OutputDebugStringA("Called pure virtual function");
#endif
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\escape.cpp ===
/****************************************************************************
    ESCAPE.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    ImeEscape functions
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "ui.h"
#include "debug.h"
#include "hanja.h"
#include "escape.h"
#include "apientry.h"

// IME_AUTOMATA subfunctions
#define IMEA_INIT               0x01
#define IMEA_NEXT               0x02
#define IMEA_PREV               0x03
// IME_MOVEIMEWINDOW
#define MCW_DEFAULT             0x00
#define MCW_WINDOW              0x02
#define MCW_SCREEN              0x04

BOOL    vfWndOpen[3] = { fTrue, fTrue, fTrue };
static WORD    wWndCmd[3] = { MCW_DEFAULT, MCW_DEFAULT, MCW_DEFAULT };

///////////////////////////////////////////////////////////////////////////////
// IME_ESC_HANJA_MODE processing routine called by ImeEscape
// Korean specific 
// It is for conversion from Hangul to Hanja the Input parameter (LPSTR)lpData
// is filled with Hangul charactert which will be converted to Hanja.
int EscHanjaMode(PCIMECtx pImeCtx, LPSTR lpIME32, BOOL fNewFunc)
{
    LPWSTR pwchSrc;
    LPSTR  pchSrc;
    WCHAR  wchSrc;
    INT    iRet = fFalse;

    // Update IMC values with lpIME32
    if (pImeCtx->IsUnicodeEnv())
        {
        pwchSrc = (fNewFunc) ? (LPWSTR)lpIME32 : GET_LPSOURCEW((LPIMESTRUCT32)lpIME32);
        if (pwchSrc == NULL || *pwchSrc == L'\0')
            {
            DbgAssert(0);
            return 0;
            }
        wchSrc = *pwchSrc;
        }
    else
        {
        pchSrc = (fNewFunc) ? (LPSTR)lpIME32 : GET_LPSOURCEA((LPIMESTRUCT32)lpIME32);
        if (pchSrc == NULL || *pchSrc == '\0')
            {
            DbgAssert(0);
            return 0;
            }

        if (MultiByteToWideChar(CP_KOREA, MB_PRECOMPOSED, pchSrc, 2, &wchSrc, 1) == 0)
            {
            return 0;
            }
        }

    Dbg(DBGID_Hanja, TEXT("EscHanjaMode = %04X"), wchSrc);
    if (GenerateHanjaCandList(pImeCtx, wchSrc))
        {
        // Set current comp str
        if (pImeCtx->IsUnicodeEnv())
            pImeCtx->SetCompBufStr(wchSrc);
        else
            pImeCtx->SetCompBufStr(*pchSrc, *(pchSrc+1));

           // Change to Hanja conv mode
        iRet = OurImmSetConversionStatus(pImeCtx->GetHIMC(), pImeCtx->GetConversionMode() | IME_CMODE_HANJACONVERT,
                pImeCtx->GetSentenceMode());
        }
    else  // if failed to convert
        {
        MessageBeep(MB_ICONEXCLAMATION);
        }

    Dbg(DBGID_Hanja, TEXT("EscHanjaMode return = %d"), iRet);
    return (iRet);
}


INT EscGetOpen(PCIMECtx pIMECtx, LPIMESTRUCT32 lpIME32)
{
    LPIMEDATA   lpImeData = pIMECtx->GetGDataRaw();
    INT         iRet = fTrue;

    if (lpImeData == NULL)
        return fFalse;
        
    if (lpIME32->dchSource > CAND_WINDOW)
        iRet = fFalse;
    else
        {
        iRet = vfWndOpen[lpIME32->dchSource] | 0x80000000UL;
        lpIME32->wCount = wWndCmd[lpIME32->dchSource];

        switch (lpIME32->wCount)
            {
        case MCW_DEFAULT:
            switch (lpIME32->dchSource) 
                {
            case COMP_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->ptStatusPos.y,
                                        (lpImeData->ptStatusPos.x+lpImeData->xStatusWi+UI_GAPX + COMP_SIZEX > lpImeData->rcWorkArea.right) ?
                                        lpImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : lpImeData->ptStatusPos.x + lpImeData->xStatusWi + UI_GAPX);
                break;
            case STATE_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->rcWorkArea.bottom - lpImeData->yStatusHi,
                                    lpImeData->rcWorkArea.right - lpImeData->xStatusWi);
                break;
            case CAND_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->rcWorkArea.bottom - lpImeData->yCandHi,
                                    lpImeData->rcWorkArea.right - lpImeData->xCandWi);

                break;

                }
            break;

        case MCW_SCREEN:
            switch (lpIME32->dchSource)
                {
            case COMP_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->ptCompPos.y, lpImeData->ptCompPos.x);
                break;

            case STATE_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->ptStatusPos.y, lpImeData->ptStatusPos.x);
                break;

            case CAND_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->rcWorkArea.bottom - lpImeData->yCandHi,
                                            lpImeData->rcWorkArea.right  - lpImeData->xCandWi);
                break;
                }
            break;

        case MCW_WINDOW:
            switch (lpIME32->dchSource)
                {
            case COMP_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->ptCompPos.y, lpImeData->ptCompPos.x);
                break;

            case STATE_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->ptStatusPos.y, lpImeData->ptStatusPos.x);
                break;

            case CAND_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->rcWorkArea.bottom - lpImeData->yCandHi,
                                            lpImeData->rcWorkArea.right  - lpImeData->xCandWi);
                break;
                }
            lpIME32->lParam1 -= lpIME32->lParam2;
            break;

        default:
            iRet = fFalse;
            }
        }
    return (iRet);
}

INT EscSetOpen(PCIMECtx pIMECtx, LPIMESTRUCT32 lpIME32)
{
    BOOL    fTmp;
    HWND    hDefIMEWnd;
    INT        iRet = fTrue;

    if (lpIME32->dchSource > CAND_WINDOW)
        iRet = fFalse;
    else
        {
        fTmp = vfWndOpen[lpIME32->dchSource];
        vfWndOpen[lpIME32->dchSource] = lpIME32->wParam;
        iRet = fTmp | 0x80000000UL;
        if (lpIME32->dchSource == STATE_WINDOW)
            {
            hDefIMEWnd = OurImmGetDefaultIMEWnd(pIMECtx->GetAppWnd());
            if (hDefIMEWnd)
                OurSendMessage(hDefIMEWnd, WM_IME_NOTIFY,
                        (lpIME32->wParam)? IMN_OPENSTATUSWINDOW: IMN_CLOSESTATUSWINDOW, 0L);
            }
        }
        
    return (iRet);
}

INT EscMoveIMEWindow(PCIMECtx pIMECtx, LPIMESTRUCT32 lpIME32)
{
    LPIMEDATA pImeData = pIMECtx->GetGDataRaw();
    INT       iRet        = fTrue;

    if (pImeData == NULL)
        return fFalse;

    if (lpIME32->dchSource > CAND_WINDOW)
        iRet = fFalse;
    else
        {
        switch (wWndCmd[lpIME32->dchSource] = lpIME32->wParam)
           {
        case MCW_DEFAULT:
            switch (lpIME32->dchSource)
                {
            case COMP_WINDOW:
                pImeData->ptCompPos.x = (pImeData->ptStatusPos.x+pImeData->xStatusWi+UI_GAPX + COMP_SIZEX > pImeData->rcWorkArea.right) ?
                                        pImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : pImeData->ptStatusPos.x + pImeData->xStatusWi + UI_GAPX;
                pImeData->ptCompPos.y = pImeData->ptStatusPos.y;
                break;

            case STATE_WINDOW:
                pImeData->ptStatusPos.x = pImeData->rcWorkArea.right - pImeData->xStatusWi;
                pImeData->ptStatusPos.y = pImeData->rcWorkArea.bottom - pImeData->yStatusHi;
                break;

            case CAND_WINDOW:
                //pImeData->ptCandPos.x = pImeData->rcWorkArea.right - pImeData->xCandWi;
                //pImeData->ptCandPos.y = pImeData->rcWorkArea.bottom - pImeData->yCandHi;
                break;
                }
            break;

        case MCW_WINDOW:
        case MCW_SCREEN:
            switch (lpIME32->dchSource)
                {
            case COMP_WINDOW:
                pImeData->ptCompPos.x = LOWORD(lpIME32->lParam1);
                pImeData->ptCompPos.y = HIWORD(lpIME32->lParam1);
                break;

            case STATE_WINDOW:
                pImeData->ptStatusPos.x = LOWORD(lpIME32->lParam1);
                pImeData->ptStatusPos.y = HIWORD(lpIME32->lParam1);
                break;

            case CAND_WINDOW:
                //pImeData->ptCandPos.x = LOWORD(lpIME32->lParam1);
                //pImeData->ptCandPos.y = HIWORD(lpIME32->lParam1);
                break;
                }
            break;

        default:
            iRet = fFalse;
            }
        }
    return (iRet);
}


INT EscAutomata(PCIMECtx pIMECtx, LPIMESTRUCT32 lpIME32, BOOL fNewFunc)
{
//    LPCOMPOSITIONSTRING lpCompStr;
    INT        iRet = fFalse;
    WCHAR    wcCur;

    Dbg(DBGID_Automata, TEXT("EscAutomata: fNewFunc=%d, lpIME32->wParam=%04X, lpIME32->lParam1=0x%08X, lpIME32->lParam2=0x%08X, lpIME32->lParam3=0x%08X"), fNewFunc, lpIME32->wParam, lpIME32->lParam1, lpIME32->lParam2, lpIME32->lParam3 );

    if (fNewFunc)
        {
        iRet = ImeProcessKey(pIMECtx->GetHIMC(), lpIME32->wParam,
                             lpIME32->lParam1, (LPBYTE)lpIME32 + (INT_PTR)lpIME32->dchSource);
        if (iRet)
            {
            lpIME32->wCount = (WORD)ImeToAsciiEx(lpIME32->wParam,
                    HIWORD(lpIME32->lParam1), (LPBYTE)lpIME32 + lpIME32->dchSource,
                    (LPTRANSMSGLIST)((LPBYTE)lpIME32 + (INT_PTR)lpIME32->dchDest), 0, pIMECtx->GetHIMC());
            }
        else 
            if (lpIME32->wParam != VK_MENU)
            {
                LPTRANSMSGLIST    lpTransBuf;
                LPTRANSMSG        lpTransMsg;

                lpIME32->wCount = 1;
                lpTransBuf = (LPTRANSMSGLIST)((LPBYTE)lpIME32 + (INT_PTR)lpIME32->dchDest);
                if (lpTransBuf)
                    {
                    lpTransMsg = lpTransBuf->TransMsg;
                    SetTransBuffer(lpTransMsg, (HIWORD(lpIME32->lParam1) & 0x8000)? WM_IME_KEYUP: WM_IME_KEYDOWN, lpIME32->wParam, lpIME32->lParam1);
                    lpTransMsg++;
                    }
                
                iRet = fTrue;
            }
        }
    else
        {
        CHangulAutomata *pAutoMata = pIMECtx->GetAutomata();
        DbgAssert(pAutoMata != NULL);
        if (pAutoMata == NULL)
            {
            return fFalse;
            }

        // It's only for HWin31 IME app compatibility layer
        switch (lpIME32->wParam)
            {
        //lpIME32->dchSource = bState;
        case IMEA_INIT:
            pIMECtx->ClearCompositionStrBuffer();
            break;

        case IMEA_NEXT:
            //HangeulAutomata(
            //        Atm_table[uCurrentInputMethod - IDD_2BEOL][lpIME32->dchSource - 0x20],
            //        NULL, lpCompStr);
            DbgAssert(0);
            break;

        case IMEA_PREV:
            //HangeulAutomata(0x80, NULL, lpCompStr); // 0x80 is for VK_BACK
            pAutoMata->BackSpace();
            wcCur = pAutoMata->GetCompositionChar();

            if (pIMECtx->GetGData() && pIMECtx->GetGData()->GetJasoDel() == fFalse) 
                {
                pAutoMata->InitState();
                wcCur = 0;
                }

            if (wcCur)
                {
                pIMECtx->SetCompositionStr(wcCur);
                pIMECtx->StoreComposition();
                }
            else
                pIMECtx->ClearCompositionStrBuffer();
            break;
        }
        iRet = fTrue;
    }

    return (iRet);
}

int EscGetIMEKeyLayout(PCIMECtx pIMECtx, LPIMESTRUCT32 lpIME32)
{
    if (pIMECtx->GetGData() == NULL)
        return fFalse;
    else
        lpIME32->lParam1 = (LONG)(pIMECtx->GetGData()->GetCurrentBeolsik());
    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\fmode.cpp ===
/****************************************************************************
   FMODE.CPP : FMode class implementation which manage Full/Half shape mode 
                   button on the Cicero Toolbar

   History:
      23-FEB-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "fmode.h"
#include "gdata.h"
#include "ui.h"
#include "winex.h"
#include "resource.h"

// {D770009D-DC5C-4d2d-8DA1-8B1211E5B69C}
const GUID GUID_LBI_KORIME_FMODE = 
{
    0xd770009d,
    0xdc5c,
    0x4d2d,
    { 0x8d, 0xa1, 0x8b, 0x12, 0x11, 0xe5, 0xb6, 0x9c }
};

/*---------------------------------------------------------------------------
    FMode::FMode
---------------------------------------------------------------------------*/
FMode::FMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    szText[0] = L'\0';
    
    m_pTb = ptb;

    // Set Add/Remove text and tootip text
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_TT_JUN_BAN, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_SYSTEMLANGBARITEM_KEYBOARD, 
                GUID_LBI_KORIME_FMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_HIDDENBYDEFAULT | TF_LBI_STYLE_TEXTCOLORICON, 
                210, 
                szText);
    SetToolTip(szText);

    // Set button text
    szText[0] = L'\0';
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_BUTTON_JUN_BAN, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}

/*---------------------------------------------------------------------------
    CMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) FMode::Release()
{
    long cr;

    cr = --m_cRef;
    DbgAssert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    FMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI FMode::GetIcon(HICON *phIcon)
{
    DWORD dwCM = GetCMode();
    UINT uiIcon = 0;
    static const UINT uidIcons[2][2] = 
    {
        { IDI_CMODE_BANJA, IDI_CMODE_BANJAW },
        { IDI_CMODE_JUNJA,  IDI_CMODE_JUNJAW }
    };

    if (m_pTb->IsOn() && (m_pTb->GetConversionMode() & IME_CMODE_FULLSHAPE))
        uiIcon = 1;

    if (IsHighContrastBlack())
        uiIcon = uidIcons[uiIcon][1];
    else
        uiIcon = uidIcons[uiIcon][0];

    *phIcon = (HICON)LoadImage(vpInstData->hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    FMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI FMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    FMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI FMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT FMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
#if 0
    DWORD dwConvMode;

    dwConvMode = GetCMode();

    // Toggle Full/Half mode
    if (dwConvMode & TIP_JUNJA_MODE)
        dwConvMode &= ~TIP_JUNJA_MODE;
    else
        dwConvMode |= TIP_JUNJA_MODE;

    SetCMode(dwConvMode);
#endif

    keybd_event(VK_JUNJA, 0, 0, 0);
    keybd_event(VK_JUNJA, 0, KEYEVENTF_KEYUP, 0);

    return S_OK;
}

#if 0
//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT FMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    HMENU    hMenu;
    DWORD    dwConvMode;
    PCIMECtx pImeCtx;
    CHAR       szText[256];
    UINT     uiId;    
    int      nRet;
    
    hMenu      = CreatePopupMenu();
    dwConvMode = GetCMode();

    if (dwConvMode & IME_CMODE_FULLSHAPE)
        uiId = IDS_CIC_BANJA_MODE;
    else
        uiId = IDS_CIC_JUNJA_MODE;

    // Add Banja/Junja mode menu
    OurLoadStringA(vpInstData->hInst, uiId, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 1, szText);

    // Add Cancel menu
    OurLoadStringA(vpInstData->hInst, IDS_CIC_CANCEL, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 0, szText);

    nRet = TrackPopupMenuEx(hMenu, 
                         TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                         pt.x, pt.y, GetActiveUIWnd(), NULL);
    switch (nRet)
        {
    case 1: 
        dwConvMode = GetCMode();

        // Toggle Full/Half mode
        if (dwConvMode & IME_CMODE_FULLSHAPE)
            dwConvMode &= ~IME_CMODE_FULLSHAPE;
        else
            dwConvMode |= IME_CMODE_FULLSHAPE;

        pImeCtx = m_pTb->GetImeCtx();
        if (pImeCtx)
            OurImmSetConversionStatus(pImeCtx->GetHIMC(), 
                                      dwConvMode, pImeCtx->GetSentenceMode());
        break;
        }

    DestroyMenu(hMenu);

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\escape.h ===
/****************************************************************************
	ESCAPE.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	ImeEscape functions
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_ESCAPE__H__INCLUDED_)
#define _ESCAPE__H__INCLUDED_

// For User Interface
#define COMP_WINDOW     0
#define STATE_WINDOW    1
#define CAND_WINDOW     2

extern BOOL    vfWndOpen[3];

#pragma pack(push, MYIMESTRUCT)
#pragma pack(2)

#define GET_LPSOURCEW(lpks)  (LPWSTR)((LPBYTE)(lpks)+(lpks)->dchSource)
#define GET_LPDESTW(lpks)    (LPWSTR)((LPBYTE)(lpks)+(lpks)->dchDest)
#define GET_LPSOURCEA(lpks)  (LPSTR)((LPBYTE)(lpks)+(lpks)->dchSource)
#define GET_LPDESTA(lpks)    (LPSTR)((LPBYTE)(lpks)+(lpks)->dchDest)

typedef struct tagIMESTRUCT32
{
    WORD        fnc;                    // function code
    WORD        wParam;                 // word parameter
    WORD        wCount;                 // word counter
    WORD        dchSource;              // offset to Source from top of memory object
    WORD        dchDest;                // offset to Desrination from top of memory object
    DWORD       lParam1;
    DWORD       lParam2;
    DWORD       lParam3;
} IMESTRUCT32;

typedef IMESTRUCT32         *PIMESTRUCT32;
typedef IMESTRUCT32 NEAR    *NPIMESTRUCT32;
typedef IMESTRUCT32 FAR     *LPIMESTRUCT32;

#pragma pack(pop, MYIMESTRUCT)

extern INT EscHanjaMode(PCIMECtx pImeCtx, LPSTR lpIME32, BOOL fNewFunc);
extern INT EscGetOpen(PCIMECtx pImeCtx, LPIMESTRUCT32 lpIME32);
extern INT EscSetOpen(PCIMECtx pImeCtx, LPIMESTRUCT32 lpIME32);
extern INT EscAutomata(PCIMECtx pImeCtx, LPIMESTRUCT32 lpIME32, BOOL fNewFunc);
extern INT EscMoveIMEWindow(PCIMECtx pImeCtx, LPIMESTRUCT32 lpIME32);
extern INT EscGetIMEKeyLayout(PCIMECtx pImeCtx, LPIMESTRUCT32 lpIME32);

#endif // !defined (_ESCAPE__H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\gdata.h ===
/****************************************************************************
	GDATA.J

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Instance data and Shared memory data management functions

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_GDATA_H__INCLUDED_)
#define _GDATA_H__INCLUDED_

#include "ui.h"

class CIMEData;

PUBLIC BOOL InitSharedData();
VOID InitImeData(CIMEData& ImeData);
PUBLIC BOOL CloseSharedMemory();

#define IMEDATA_MAGIC_NUMBER 		0x12345678	// This will repesent whether IMEDATA initialized or not


// Type of IME Hangul keyboard layout
enum _KeyBoardType 
{ 
	KL_2BEOLSIK = 0, KL_3BEOLSIK_390, KL_3BEOLSIK_FINAL 
};

#define NUM_OF_IME_KL			3

///////////////////////////////////////////////////////////////////////////////
// Global data  S H A R E D  to all IME instance
struct IMEDATA 
    {
    ULONG		ulMagic;

	// Workarea
	RECT		rcWorkArea;
	
	// Configuration of the IME
	UINT		uiCurrentKeylayout;
	BOOL		fJasoDel;		// Backspace : delete per jaso or char
								// which means All ISO-10646 hangul.
	BOOL		fKSC5657Hanja;	// K1(KSC-5657) Hanja enable
	BOOL		fCandUnicodeTT;

	// Status window
	UINT		uNumOfButtons;
	//_StatusButtonTypes	ButtonTypes[MAX_NUM_OF_STATUS_BUTTONS];
	INT			iCurButtonSize;

    INT         xStatusWi;      // width of status window
    INT         yStatusHi;      // high of status window

	LONG		xStatusRel, yStatusRel;

	INT			xButtonWi;
	INT			yButtonHi;
	INT			cxStatLeftMargin, cxStatRightMargin,
				cyStatMargin, cyStatButton;
	RECT		rcButtonArea;
	POINT       ptStatusPos;

	// Candidate window
    INT         xCandWi;
    INT         yCandHi;

	// Comp window pos
	POINT       ptCompPos;

	// This should be last - ia64 alignment issue
	StatusButton StatusButtons[MAX_NUM_OF_STATUS_BUTTONS];
};

typedef IMEDATA	*LPIMEDATA;

//////////////////////////////////////////////////////////////////////////////
// I N S T A N C E  D A T A
// Per Process Data
struct INSTDATA 
    {
	HINSTANCE		hInst;		// IME DLL instance handle
	DWORD			dwSystemInfoFlags;
	BOOL			fISO10646;	// XWansung area hangul enabled, 
	BOOL			f16BitApps;
    };
typedef INSTDATA	*LPINSTDATA;

// Global variables
PUBLIC BOOL 		vfUnicode;
PUBLIC INSTDATA		vInstData;
PUBLIC LPINSTDATA	vpInstData;

/////////////////////////////////////////////////////////////////////////////
// Class CIMEData
//
// Purpose : Shared memory handling across process boundary.
//           This use MapViewOfFile() to mapping local process memory and Unlock 
//           automatically when reference count become zero
// Note    : Currently Read only flag behaves same as R/W flag.
class CIMEData
    {
    public:
        enum LockType { SMReadOnly, SMReadWrite };
       
        CIMEData(LockType lockType=SMReadWrite);
        ~CIMEData() { UnlockSharedMemory(); }

        static BOOL InitSharedData();
        static BOOL CloseSharedMemory();

		void InitImeData();

        LPIMEDATA LockROSharedData();
        LPIMEDATA LockRWSharedData();
        BOOL UnlockSharedMemory();
        LPIMEDATA operator->() { DbgAssert(m_pImedata != 0);  return m_pImedata; }
        LPIMEDATA GetGDataRaw() { DbgAssert(m_pImedata != 0); return m_pImedata; }
        UINT GetCurrentBeolsik() { return (m_pImedata ? m_pImedata->uiCurrentKeylayout : 0); }
		VOID SetCurrentBeolsik(UINT icurBeolsik);		
		BOOL GetJasoDel() { return (m_pImedata ? m_pImedata->fJasoDel : 1); }
		VOID SetJasoDel(BOOL fJasoDel) { m_pImedata->fJasoDel = fJasoDel; }
		BOOL GetKSC5657Hanja() { return (m_pImedata ? m_pImedata->fKSC5657Hanja : 0); }
		VOID SetKSC5657Hanja(BOOL f5657) { m_pImedata->fKSC5657Hanja = f5657; }

		
    private:
        LPIMEDATA m_pImedata;
        static IMEDATA m_ImeDataDef;
        PRIVATE HANDLE m_vhSharedData;
    };

inline
CIMEData::CIMEData(LockType lockType)
    {
    DbgAssert(m_vhSharedData != 0);
    Dbg(DBGID_IMEDATA, TEXT("CIMEData(): Const"));
    m_pImedata = 0;
    LockRWSharedData();
    ZeroMemory(&m_ImeDataDef, sizeof(IMEDATA));
	// If failed to allocate or map shared memory, use static default data instead.
    if (m_pImedata == NULL)
        {
        m_pImedata = &m_ImeDataDef;
        return;
        }
    }

inline
LPIMEDATA CIMEData::LockROSharedData()
    {
    DbgAssert(m_vhSharedData != 0);
    Dbg(DBGID_IMEDATA, TEXT("CIMEData::LockROSharedData()"));

    if (m_vhSharedData)
	    m_pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ, 0, 0, 0);
    DbgAssert(m_pImedata != 0);
    return m_pImedata;
    }

inline    
LPIMEDATA CIMEData::LockRWSharedData()
    {
    DbgAssert(m_vhSharedData != 0);
    Dbg(DBGID_IMEDATA, TEXT("CIMEData::LockRWSharedData()"));
    
    if (m_vhSharedData)
    	{
		Dbg(DBGID_IMEDATA, TEXT("CIMEData::LockRWSharedData(): m_vhSharedData is null call MapViewOfFile"));
	    m_pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
	    }
    DbgAssert(m_pImedata != 0);
	return m_pImedata;
    }

// For unlocking shared memory
inline
BOOL CIMEData::UnlockSharedMemory()
    {
    Dbg(DBGID_IMEDATA, TEXT("CIMEData::UnlockSharedMemory(): Lock count zero UnmapViewOfFile"));
    if (m_pImedata != &m_ImeDataDef)
    	{
	    UnmapViewOfFile(m_pImedata);
    	}
	m_pImedata = 0;
    return fTrue;
    }

inline
VOID CIMEData::SetCurrentBeolsik(UINT uicurBeolsik) 
{ 
	DbgAssert(/*uicurBeolsik>=KL_2BEOLSIK &&*/ uicurBeolsik<=KL_3BEOLSIK_FINAL);
	if (uicurBeolsik<=KL_3BEOLSIK_FINAL)
		m_pImedata->uiCurrentKeylayout = uicurBeolsik; 
}

#endif // _GDATA_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\gdata.cpp ===
/****************************************************************************
    GDATA.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Instance data and Shared memory data management functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "hanja.h"
#include "immsec.h"
#include "debug.h"
#include "config.h"
#include "gdata.h"

///////////////////////////////////////////////////////////////////////////////
// Per process variables
// Make sure all per process data shoulde be initialized
BOOL         vfUnicode = fTrue;
INSTDATA     vInstData = {0};
LPINSTDATA   vpInstData = NULL;
// CIMEData static variables
HANDLE       CIMEData::m_vhSharedData = 0;
IMEDATA      CIMEData::m_ImeDataDef;


static const CHAR IMEKR_IME_SHAREDDATA_MUTEX_NAME[] =  "{E12875A0-C3F1-4273-AB6D-9B9948804271}";
static const CHAR IMEKR_IME_SHAREDDATA_NAME[] = "{F6AE3B77-65B1-4181-993C-701461C8F982}";

BOOL CIMEData::InitSharedData()
{
    HANDLE hMutex;
    BOOL fRet = fFalse;
    LPIMEDATA pImedata;

    Dbg(DBGID_Mem, TEXT("InitSharedData"));

       hMutex = CreateMutex(GetIMESecurityAttributes(), fFalse, IMEKR_IME_SHAREDDATA_MUTEX_NAME);
       if (hMutex != NULL)
           {
           // *** Begin Critical Section ***
           DoEnterCriticalSection(hMutex);

        if((m_vhSharedData = OpenFileMapping(FILE_MAP_READ|FILE_MAP_WRITE, fTrue, IMEKR_IME_SHAREDDATA_NAME)))
            {
            Dbg(DBGID_Mem, TEXT("InitSharedData - IME shared data already exist"));
            fRet = fTrue;
            }
        else    // if shared memory does not exist
            {
            m_vhSharedData = CreateFileMapping(INVALID_HANDLE_VALUE, GetIMESecurityAttributes(), PAGE_READWRITE, 
                                0, sizeof(IMEDATA),
                                IMEKR_IME_SHAREDDATA_NAME);
            DbgAssert(m_vhSharedData != 0);
            // if shared memory not exist create it
            if (m_vhSharedData) 
                {
                  Dbg(DBGID_Mem, TEXT("InitSharedData::InitSharedData() - File mapping Created"));
                pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);

                if (!pImedata)
                    {
                    DbgAssert(0);
                    goto ExitCreateSharedData;
                    }

                // initialize the data to zero
                ZeroMemory(pImedata, sizeof(IMEDATA));
                // Unint value of status and comp window position
                pImedata->ptStatusPos.x = pImedata->ptStatusPos.y = -1;
                pImedata->ptCompPos.x = pImedata->ptCompPos.y = -1;

                // Unmap memory
                UnmapViewOfFile(pImedata);
                Dbg(DBGID_Mem, TEXT("IME shared data handle created successfully"));
                fRet = fTrue;
                }
            }
            
    ExitCreateSharedData:
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
           // *** End Critical Section ***
           }
    FreeIMESecurityAttributes();
    
    return fRet;
}

// Close shared memory handle. This called when process detach time.
BOOL CIMEData::CloseSharedMemory()
{
    HANDLE hMutex;
    BOOL fRet = fTrue;

    Dbg(DBGID_Mem, TEXT("CloseSharedMemory"));

    hMutex = CreateMutex(GetIMESecurityAttributes(), fFalse, IMEKR_IME_SHAREDDATA_MUTEX_NAME);
    if (hMutex != NULL)
        {
           // *** Begin Critical Section ***
           DoEnterCriticalSection(hMutex);
        if (m_vhSharedData)
            {
            if (fRet = CloseHandle(m_vhSharedData))
                m_vhSharedData = 0;
            DbgAssert(fRet);
            }
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
           // *** End Critical Section ***
        }
       FreeIMESecurityAttributes();

    return fTrue;
}

///////////////////////////////////////////////////////////////////////////////
void CIMEData::InitImeData()
{
    POINT ptStatusWinPosReg;

    // Get Work Area
    SystemParametersInfo(SPI_GETWORKAREA, 0, &(m_pImedata->rcWorkArea), 0);

    // if current status window position different from registy, reset reg value
    if (GetStatusWinPosReg(&ptStatusWinPosReg))
        {
        if (ptStatusWinPosReg.x != m_pImedata->ptStatusPos.x ||
            ptStatusWinPosReg.y != m_pImedata->ptStatusPos.y)
            SetRegValues(GETSET_REG_STATUSPOS);
        }

    // Reset magic number for Winlogon process.
    if ((vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON) != 0)
        m_pImedata->ulMagic = 0;

    // If IMEDATA is not initialized ever, fill it with default value first,
    // and then try to read from registry.
    // If IMEDATA overwritten by any reason, it will recover to initial data.
    if (m_pImedata->ulMagic != IMEDATA_MAGIC_NUMBER)
        {
        // Set magic number only if not a Winlogon process
        // If current process is WinLogon, we should reload user setting after login
        if ((vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON) == 0)
            m_pImedata->ulMagic = IMEDATA_MAGIC_NUMBER;

        // Default option setting. It can be changed according to registry in ImeSelect
        SetCurrentBeolsik(KL_2BEOLSIK);
        m_pImedata->fJasoDel = fTrue;
        m_pImedata->fKSC5657Hanja = fFalse;

        // Default status Buttons
#if !defined(_WIN64)
        m_pImedata->uNumOfButtons = 3;
#else
        m_pImedata->uNumOfButtons = 2;
#endif
        m_pImedata->iCurButtonSize = BTN_MIDDLE;
        m_pImedata->StatusButtons[0].m_ButtonType = HAN_ENG_TOGGLE_BUTTON;
        m_pImedata->StatusButtons[1].m_ButtonType = HANJA_CONV_BUTTON;
#if !defined(_WIN64)
        m_pImedata->StatusButtons[2].m_ButtonType = IME_PAD_BUTTON;
        m_pImedata->StatusButtons[3].m_ButtonType = NULL_BUTTON;
#else
        m_pImedata->StatusButtons[2].m_ButtonType = NULL_BUTTON;
#endif

        // init with default button status
        UpdateStatusButtons(*this);

        m_pImedata->cxStatLeftMargin = 3; // 9; if left two vertical exist
        m_pImedata->cxStatRightMargin = 3;
        m_pImedata->cyStatMargin = 3;

        m_pImedata->cyStatButton = m_pImedata->cyStatMargin;

        // Get all regstry info
        GetRegValues(GETSET_REG_ALL);

        UpdateStatusWinDimension();
        //
        m_pImedata->xCandWi = 320;
        m_pImedata->yCandHi = 30;
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\hanja.cpp ===
/****************************************************************************
    HANJA.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Hanja conversion and dictionary lookup functions. Dictionary index is 
    stored as globally shared memory.
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "apientry.h"
#include "ui.h"
#include "debug.h"
#include "lexheader.h"
#include "hanja.h"
#include "immsec.h"
#include "winex.h"
#include "common.h"
#include <WINERROR.H>

// NT5 Globally shared memory. 
const TCHAR IMEKR_LEX_SHAREDDATA_MUTEX_NAME[]        = TEXT("{C5AFBBF9-8383-490c-AA9E-4FE93FA05512}");
const TCHAR IMEKR_LEX_SHAREDDATA_NAME[]              = TEXT("ImeKrLexHangul2Hanja.SharedMemory");


UINT   vuNumofK0=0, vuNumofK1=0;
WCHAR  vwcHangul=0;

// Private data
PRIVATE BOOL    vfLexOpen = fFalse;
PRIVATE HANDLE vhLex=0;
PRIVATE HANDLE vhLexIndexTbl=0;
PRIVATE UINT    vuNumOfHangulEntry=0;
PRIVATE DWORD viBufferStart=0;    // seek point

// Private functions
PRIVATE BOOL OpenLex();
//static VOID ClearHanjaSenseArray();
PRIVATE INT SearchHanjaIndex(WCHAR wHChar, _LexIndex *pLexIndexTbl);

/*
CHanja::CHanja()
    {
    vfLexOpen = fFalse;
    vhLex = vhLexIndexTbl = vhLexIndexTbl = NULL;
    vuNumOfHangulEntry = 0;

    for (int i=0; i<MAX_CANDSTR; i++) 
        vprwszHanjaMeaning[i] = 0;
    }
*/

BOOL EnsureHanjaLexLoaded()
{
    _DictHeader *pLexHeader;
    DWORD         dwReadBytes;
    CHAR         szLexFileName[MAX_PATH], szLexPathExpanded[MAX_PATH];
    HKEY        hKey;
    DWORD        dwType, dwCb;
    CIMEData    ImeData;

    if (vfLexOpen)
        return fTrue;

    // Get Lex file name with full path
    szLexFileName[0] = 0;
    szLexPathExpanded[0] = 0;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szIMERootKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        dwCb = sizeof(szLexFileName);
        dwType = REG_SZ;

        if (RegQueryValueEx(hKey, g_szDictionary, NULL, &dwType, (LPBYTE)szLexFileName, &dwCb) == ERROR_SUCCESS)
            ExpandEnvironmentStrings(szLexFileName, szLexPathExpanded, sizeof(szLexPathExpanded));
        RegCloseKey(hKey);
        }

    DbgAssert(szLexPathExpanded[0] != 0);
    if (szLexPathExpanded[0] == 0)
        return fFalse;

    vhLex = CreateFile(szLexPathExpanded, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL);
    if (vhLex==INVALID_HANDLE_VALUE) 
        {
        DbgAssert(0);
        return fFalse;
        }

    pLexHeader = new _DictHeader;
    if (!pLexHeader)
        return fFalse;

    if (ReadFile(vhLex, pLexHeader, sizeof(_DictHeader), &dwReadBytes, 0) == 0 || (dwReadBytes != sizeof(_DictHeader)))
        {
        DbgAssert(0);
        return fFalse;
        }

    // Set member vars
    vuNumOfHangulEntry = pLexHeader->NumOfHangulEntry;
    viBufferStart = pLexHeader->iBufferStart;

    if (pLexHeader->Version < LEX_VERSION || pLexHeader->Version > LEX_COMPATIBLE_VERSION_LIMIT ) 
        {
        delete pLexHeader;
        return fFalse;
        }
        
    if (lstrcmpA(pLexHeader->COPYRIGHT_HEADER, COPYRIGHT_STR)) 
        {
        delete pLexHeader;
        return fFalse;
        }

    // Read Index table
    SetFilePointer(vhLex, pLexHeader->Headersize, 0, FILE_BEGIN);    
    delete pLexHeader;

    return OpenLex();
}

BOOL OpenLex()
{
    BOOL          fRet = fFalse;
    _LexIndex     *pLexIndexTbl;
    HANDLE         hMutex;
    DWORD         dwReadBytes;
    
    ///////////////////////////////////////////////////////////////////////////
    // Mapping Lex file
    // The dictionary index is shared data between all IME instance
    hMutex=CreateMutex(GetIMESecurityAttributes(), fFalse, IMEKR_LEX_SHAREDDATA_MUTEX_NAME);

    if (hMutex != NULL)
        {
        if (DoEnterCriticalSection(hMutex) == fFalse)
            goto ExitOpenLexCritSection;

        vhLexIndexTbl = OpenFileMapping(FILE_MAP_READ, fTrue, IMEKR_LEX_SHAREDDATA_NAME);

        if(vhLexIndexTbl)
            {
            Dbg(DBGID_Hanja|DBGID_Mem, TEXT("CHanja::OpenLex() - File mapping already exists"));
            fRet = fTrue;
            }
        else
            {
            // if no file mapping exist
            vhLexIndexTbl    = CreateFileMapping(INVALID_HANDLE_VALUE, GetIMESecurityAttributes(), PAGE_READWRITE, 
                                0, sizeof(_LexIndex)*(vuNumOfHangulEntry),
                                IMEKR_LEX_SHAREDDATA_NAME);

            if (vhLexIndexTbl) 
                {
                Dbg(DBGID_Hanja|DBGID_Mem, TEXT("CHanja::OpenLex() - File mapping Created"));
                pLexIndexTbl = (_LexIndex*)MapViewOfFile(vhLexIndexTbl, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
                if (!pLexIndexTbl)
                    goto ExitOpenLexCritSection;

                if (ReadFile(vhLex, pLexIndexTbl, vuNumOfHangulEntry*sizeof(_LexIndex), &dwReadBytes, 0) != 0 &&
					dwReadBytes == vuNumOfHangulEntry*sizeof(_LexIndex))
                	{
                    fRet = fTrue;
                	}
                else
                	{
                    fRet = fFalse;
                	}
                
                UnmapViewOfFile(pLexIndexTbl);
                }
        #ifdef _DEBUG
            else
                DbgAssert(0);
        #endif
            }
            
    ExitOpenLexCritSection:
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
        }
    
    FreeIMESecurityAttributes();

    vfLexOpen = fRet;
    return fRet;
}

BOOL CloseLex()
{
    //ClearHanjaSenseArray();
    
    if (vhLexIndexTbl) 
        {
        CloseHandle(vhLexIndexTbl);
        vhLexIndexTbl = 0;
        }

    if (vhLex) 
        {
        CloseHandle(vhLex);
        vhLex = 0;
        }

    vfLexOpen =  fFalse;
    return fTrue;
}

///////////////////////////////////////////////////////////////////////////////
BOOL GenerateHanjaCandList(PCIMECtx pImeCtx, WCHAR wcHangul)
{
    WCHAR       wcCandChar;
    INT         iMapCandStr;
    UINT        uNumOfCandStr;
    _LexIndex    *pLexIndexTbl;
    WCHAR        wszMeaning[MAX_SENSE_LENGTH+1];
    BYTE        cchMeaning = 0;
    DWORD        dwReadBytes;
    BOOL        fRet = fFalse;

    Dbg(DBGID_Hanja, "GenerateHanjaCandList");
    if (!EnsureHanjaLexLoaded()) 
        {
        MessageBeep(MB_ICONEXCLAMATION);
        return fFalse;
        }

    // Get Current composition char
    if (wcHangul == 0)
        wcHangul = pImeCtx->GetCompBufStr();
        
    if (wcHangul == 0)
        return fFalse;

    pLexIndexTbl = (_LexIndex*)MapViewOfFile(vhLexIndexTbl, FILE_MAP_READ, 0, 0, 0);
    if (!pLexIndexTbl) 
        {
        Dbg(DBGID_Hanja, TEXT("pLexIndexTbl==0"));
        DbgAssert(0);    
        return fFalse;
        }

    if ((iMapCandStr = SearchHanjaIndex(wcHangul, pLexIndexTbl)) < 0)
        MessageBeep(MB_ICONEXCLAMATION);
    else
        {
        // Set member vars
        vwcHangul = wcHangul;
        vuNumofK0 = pLexIndexTbl[iMapCandStr].wNumOfK0;

        // Is K1 Hanja enabled?
        if (pImeCtx->GetGData() && pImeCtx->GetGData()->GetKSC5657Hanja() && (vpInstData->f16BitApps == fFalse) && !IsWin95())
            vuNumofK1 = pLexIndexTbl[iMapCandStr].wNumOfK1;
        else
            vuNumofK1 = 0;

        uNumOfCandStr = vuNumofK0 + vuNumofK1;
        if (uNumOfCandStr == 0)
            goto GenerateHanjaCandListExit;

        Dbg(DBGID_Hanja, "Hangul = 0x%04X, K0=%d, K1=%d, iMapCandStr=%d", vwcHangul, vuNumofK0, vuNumofK1, iMapCandStr);

        // Seek to mapping Hanja
        SetFilePointer(vhLex, viBufferStart + pLexIndexTbl[iMapCandStr].iOffset, 0, FILE_BEGIN);    

        // Read all candidates
        for (UINT i = 0; i < uNumOfCandStr; i++)
            {
            if (ReadFile(vhLex, &wcCandChar, sizeof(WCHAR), &dwReadBytes, 0) == 0)
            	goto GenerateHanjaCandListExit;
            if (ReadFile(vhLex, &cchMeaning, sizeof(BYTE), &dwReadBytes, 0) == 0)
            	goto GenerateHanjaCandListExit;
            if (wcCandChar && (cchMeaning < MAX_SENSE_LENGTH*sizeof(WCHAR)))
                {
                if (cchMeaning)
                    {
                    if (ReadFile(vhLex, wszMeaning, cchMeaning, &dwReadBytes, 0) == 0)
                        goto GenerateHanjaCandListExit;
                    }
                
                wszMeaning[cchMeaning>>1] = L'\0';
                Dbg(DBGID_Hanja, "Read Cand[%d], Hanja=0x%04X", i, wcCandChar);
                pImeCtx->AppendCandidateStr(wcCandChar, wszMeaning);
                }
            }

        pImeCtx->StoreCandidate();
        
        fRet = fTrue;
        }

    GenerateHanjaCandListExit:
        UnmapViewOfFile(pLexIndexTbl);

    return fRet;
    }

// For ImeConversionList.
DWORD GetConversionList(WCHAR wcReading, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
    {
    _LexIndex            *pLexIndexTbl;
    INT                    iMaxCand;
    INT                    i, iMapCandStr;
    UINT                uNumOfCandStr;
    DWORD                dwSize, readBytes, dwStartOfCandStr;
    BYTE                senseLen;
    WCHAR                szSense[MAX_SENSE_LENGTH];
    CIMEData            ImeData;

    if (!EnsureHanjaLexLoaded())
        return (0L);

    // Calculate possible maximum candidates dwBufLen can contain.
    if (dwBufLen) 
        {
        iMaxCand = dwBufLen - sizeof(CANDIDATELIST) + sizeof(DWORD); // Minus header info.(unvariable part)
        iMaxCand = iMaxCand / (sizeof(DWORD) + (sizeof(WCHAR)*2)); // DWORD: offset, WCHAR*2: 1 Character + null
        }
    else 
        iMaxCand = 0;

    pLexIndexTbl = (_LexIndex*)MapViewOfFile(vhLexIndexTbl, FILE_MAP_READ, 0, 0, 0);
    if (!pLexIndexTbl) 
        {
        DbgAssert(0);    
        return (0L);
        }

    dwSize = 0;

    if ((iMapCandStr = SearchHanjaIndex(wcReading, pLexIndexTbl)) < 0) 
        goto ConversionExit1;
    else
        {
        vuNumofK0 = pLexIndexTbl[iMapCandStr].wNumOfK0;
        
        if (ImeData->fKSC5657Hanja && (vpInstData->f16BitApps == fFalse) && !IsWin95())
            vuNumofK1 = pLexIndexTbl[iMapCandStr].wNumOfK1;
        else
            vuNumofK1 = 0;

        uNumOfCandStr = vuNumofK0 + vuNumofK1;
        if (uNumOfCandStr == 0)    // if no Hanja found
            goto ConversionExit1;

        dwSize =  sizeof(CANDIDATELIST) + uNumOfCandStr*sizeof(DWORD)
                    + uNumOfCandStr * sizeof(WCHAR) * 2;
        // return required buffer size
        if (dwBufLen == NULL)
            goto ConversionExit1;
        lpCandList->dwSize  = dwSize;
        lpCandList->dwStyle = IME_CAND_READ;
        lpCandList->dwCount = uNumOfCandStr;
        lpCandList->dwPageStart = lpCandList->dwSelection = 0;
        lpCandList->dwPageSize = CAND_PAGE_SIZE;
    
        //
        SetFilePointer(vhLex, viBufferStart + pLexIndexTbl[iMapCandStr].iOffset, 0, FILE_BEGIN);    

        dwStartOfCandStr = sizeof(CANDIDATELIST) 
                         + sizeof(DWORD) * uNumOfCandStr; // for dwOffset array
                        
        for (i = 0; (i < (INT)uNumOfCandStr) && (i < iMaxCand); i++)
            {
            WCHAR    wchHanja;
            LPWSTR    lpwchCand;
            LPSTR    lpchCand;
            CHAR     szCand[4] = ""; // one DBCS + one Null + one extra

            lpCandList->dwOffset[i] = dwStartOfCandStr + (i<<2);

            if (ReadFile(vhLex, &wchHanja, sizeof(WCHAR), &readBytes, 0) == 0)
                goto ConversionExit1;

            // if Unicode environment
            if (vfUnicode)
                {
                lpwchCand = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[i]);
                *lpwchCand++ = wchHanja;
                *lpwchCand = L'\0';
                }
            else
                {
                // Convert to ANSI
                WideCharToMultiByte(CP_KOREA, 0, 
                                    &wchHanja, 1, (LPSTR)szCand, sizeof(szCand), 
                                    NULL, NULL);
                lpchCand = (LPSTR)((LPSTR)lpCandList + lpCandList->dwOffset[i]);
                *lpchCand++ = szCand[0];
                *lpchCand++ = szCand[1];
                *lpchCand = '\0';
                }
            // Skip meaning
            if (ReadFile(vhLex, &senseLen, sizeof(BYTE), &readBytes, 0) == 0)
                goto ConversionExit1;
            if (senseLen < MAX_SENSE_LENGTH)
                {
                if (ReadFile(vhLex, szSense, senseLen, &readBytes, 0) == 0)
                    goto ConversionExit1;
                }
            }
        }

    // if buffer size too small to copy all conversion list info
    if (i == iMaxCand && i < (INT)uNumOfCandStr) 
        {
        lpCandList->dwSize = dwSize = (sizeof(CANDIDATELIST) - sizeof(DWORD))+ i*sizeof(DWORD) + i*sizeof(WCHAR)*2;
        lpCandList->dwCount = (UINT)i;
        }

ConversionExit1:
    UnmapViewOfFile(pLexIndexTbl);

    return (dwSize);
}

INT SearchHanjaIndex(WCHAR wHChar, _LexIndex *pLexIndexTbl)
{
    int iHead = 0, iTail = vuNumOfHangulEntry-1, iMid;

    while (iHead <= iTail)
        {
        iMid = (iHead + iTail) >> 1;

        if (pLexIndexTbl[iMid].wcHangul > wHChar)
            iTail = iMid - 1;
        else 
            if (pLexIndexTbl[iMid].wcHangul < wHChar)
                iHead = iMid + 1;
            else 
                return (iMid);
        }

    return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\guids.cpp ===
#define INITGUID

#include "imepad_.h"
#include "ipoint1.h"
#include "iimecb.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\fmode.h ===
//
// FMODE.H
//

#if !defined (__FMODE_H__INCLUDED_)
#define __FMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class FMode : public CCicButton
{
public:
    FMode(CToolBar *ptb);
    ~FMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
//    HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:
	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __FMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\hanja.h ===
/****************************************************************************
	HANJA.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Hanja conversion and dictionary lookup functions. Dictionary index is 
	stored as globally shared memory.
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_HANJA_H__INCLUDED_)
#define _HANJA_H__INCLUDED_

#include "LexHeader.h"

#define CAND_PAGE_SIZE 			9

#define MAX_CANDSTR				128	// !!! max num of candidate !!! 
									// currently '' has total 103 candidate str

PUBLIC UINT vuNumofK0, vuNumofK1;
PUBLIC WCHAR  vwcHangul;

PUBLIC BOOL EnsureHanjaLexLoaded();
PUBLIC BOOL CloseLex();
PUBLIC BOOL GenerateHanjaCandList(PCIMECtx pImeCtx, WCHAR wcHangul = 0);
PUBLIC DWORD GetConversionList(WCHAR wcReading, LPCANDIDATELIST lpCandList, DWORD dwBufLen);

__inline UINT GetNumOfK0() { return vuNumofK0; }
__inline UINT GetNumOfK1() { return vuNumofK1; }
//inline LPWSTR GetHanjaMeaning(int i) { return vprwszHanjaMeaning[i]; }
__inline WCHAR  GetCurrentHangulOfHanja() { return vwcHangul; }

#endif // !defined (_HANJA_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\hjmode.h ===
//
// HJMODE.H
//

#if !defined (__HJMODE_H__INCLUDED_)
#define __HJMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class HJMode : public CCicButton
{
public:
    HJMode(CToolBar *ptb);
    ~HJMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:

	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __HJMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\imc.h ===
/****************************************************************************
	IMC.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IME Context abstraction class
	
	History:
	20-JUL-1999 cslim       Created
*****************************************************************************/

#if !defined(_IMC_H__INCLUDED_)
#define _IMC_H__INCLUDED_

#include "gdata.h"

// No GCS_COMPCLAUSE
#define GCS_COMP_KOR (GCS_COMPSTR|GCS_COMPATTR)

class CIMECtx 
{
// Ctor and Dtor
public:
	CIMECtx(HIMC hIMC);
	~CIMECtx();

// CIMECtx Methods
public:
	CIMEData* GetGData();
	LPIMEDATA GetGDataRaw();
	CHangulAutomata* GetAutomata();
	HIMC  GetHIMC();
	HWND  GetAppWnd();
	HWND  GetUIWnd();
	VOID  SetUIWnd(HWND hUIWnd);
	HIMCC GetHCandInfo();
	LPCANDIDATEINFO GetPCandInfo();

	HIMCC GetHCompStr();
	HIMCC GetHMsgBuf();
	BOOL  IsOpen();
	VOID  SetOpen(BOOL fOpen);
	VOID  SetStatusWndPos(POINT &pt);
	VOID  GetStatusWndPos(POINT* pPt);
	DWORD SetConversionMode(DWORD dwConvMode);
	DWORD GetConversionMode();
	DWORD SetSentenceMode(DWORD dwSentMode);
	DWORD GetSentenceMode();

	LOGFONT* GetLogFont();

	// Initial status
	VOID SetInitStatus(DWORD dwInitState);
	VOID GetInitStatus(LPDWORD pdwInitState);

	// Composition string
	VOID SetCompositionStr(WCHAR wch);
	WCHAR GetCompositionStr();
	WCHAR GetCompBufStr();
	VOID SetCompBufStr(WCHAR wch);
	VOID SetCompBufStr(CHAR chHigh, CHAR chLow);
	VOID ClearCompositionStrBuffer();
	VOID SetResultStr(WCHAR* pwSz);
	VOID SetResultStr(WCHAR wch1, WCHAR wch2=0);
	VOID AppendResultStr(WCHAR wch);
	VOID FinalizeCurCompositionChar();

	VOID ResetComposition();
	VOID StoreComposition();
	BOOL IsCompositionString();
	DWORD GetCompBufLen();
	VOID SetStartComposition(BOOL fStart);
	VOID SetEndComposition(BOOL fEnd);
	//LPCOMPOSITIONSTRING GetCompositionStrBuffer() { DbgAssert(m_pCompStr!=NULL); return m_pCompStr; }
	
	// Cand string
	VOID ResetCandidate();
	VOID AppendCandidateStr(WCHAR wcCand, LPWSTR wszMeaning);
	WCHAR GetCandidateStr(INT iIdx);
	LPWSTR GetCandidateMeaningStr(INT iIdx);
	INT GetCandidateCount();
	VOID StoreCandidate();
	enum MSG_CAND { MSG_NONE = 0, MSG_OPENCAND, MSG_CLOSECAND, MSG_CHANGECAND };
	VOID SetCandidateMsg(UINT uiMsg);
	VOID SetCandStrSelection(DWORD dwSel);

	// Composition form
	VOID GetCompositionForm(LPCOMPOSITIONFORM* ppCompForm);
	VOID SetCompositionFormStyle(DWORD dwStyle);
	DWORD GetCompositionFormStyle();
	VOID SetCompositionFormPos(POINT pt);
	VOID GetCompositionForm(POINT* pPt);
	VOID GetCompositionForm(RECT* pRc);

	// Cand Form
	DWORD GetCandidateFormIndex(INT iIdxCand);
	VOID SetCandidateFormIndex(INT iIdx, INT iIdxCand = 0);
	DWORD GetCandidateFormStyle(INT iIdxCand = 0);
	VOID SetCandidateFormStyle(DWORD dwStyle, INT iIdxCand = 0);
	VOID GetCandidateForm(RECT* pRc, INT iIdxCand = 0);
	VOID SetCandidateFormArea(RECT* pRc, INT iIdxCand = 0);
	VOID GetCandidateFormPos(POINT* pPt, INT iIdxCand = 0);
	VOID SetCandidateFormPos(POINT pt, INT iIdxCand = 0);
	/////////////////////////////////////////////////
	//  MSG buffer structure support
	VOID SetTransMessage(LPTRANSMSGLIST pMessage);
	VOID ResetMessage();
	INT  GetMessageCount();
	BOOL FinalizeMessage();
	VOID FlushCandMessage();
	BOOL GenerateMessage();
	INT  AddMessage(UINT uiMessage, WPARAM wParam = 0, LPARAM lParam = 0);
	VOID AddKeyDownMessage(WPARAM wParam = 0, LPARAM lParam = 0);

	/////////////////////////////////////////////////
	//  Unicode environment
	BOOL IsUnicodeEnv(VOID);
	VOID SetUnicode(BOOL fUnicode);
	VOID NonUnicodeConversion(WCHAR* pwStr, INT* pcchStr, CHAR* pwOStr, BYTE* pbAtr, INT* pcchAtr, BYTE* pbOAtr, DWORD* pdwCls, INT* pcchCls, DWORD* pdwOCls);

	VOID SetProcessKeyStatus(BOOL fSet);
	BOOL IsProcessKeyStatus(VOID);

	// new and delete operator overloading
	void* operator new(size_t size);
	void  operator delete(void *lp);

// Implementation
private:
	VOID InitCompStrStruct();
	/////////////////////////////////////////////////
	//  Private status
	VOID ResetGCS();
	DWORD GetGCS();
	VOID DelGCS(DWORD dwGCS);
	VOID AddGCS(DWORD dwGCS);
	DWORD ValidateGCS();

	void ClearCandMeaningArray();

// Implementation
protected:
	CIMEData* 	     m_pCIMEData;

// Internal data
private:
	// IME Context handle and pointer
	HIMC 			m_hIMC;
	LPINPUTCONTEXT	m_pIMC;

    // hangul Automata. Created once and will be shared between all apps.
	CHangulAutomata*   m_rgpHangulAutomata[NUM_OF_IME_KL];

	// Unicode flag
	BOOL 			m_fUnicode;	// TRUE=UNICODE env. FALSE=NON UNICODE env

	// Composition string support
	LPCOMPOSITIONSTRING	m_pCompStr;

	// Candidate list support
	LPCANDIDATEINFO		m_pCandInfo;
	INT 				m_iciCandidate;
	LPWSTR				m_pCandStr;
	LPWSTR*				m_rgpCandMeaningStr;
	
	// Msg generation support
	BOOL m_fEndComposition;		// don't call AddMes( WM_IME_ENDCOMPOSITION) now
	BOOL m_fStartComposition;	// don't call AddMes( WM_IME_STARTCOMPOSITION) now
//	BOOL m_fStartCompMsgSent;
	UINT m_uiSendCand;
	BOOL m_fKeyProcessing;		// TRUE while ImeProcessKey()

	// REVIEW: see KKIME ui.cpp SetOpenStatusWindow( TRUE );
	BOOL m_fOpenStatusWindow;	// open status window status

	// for WM_IME_COMPOSITION flag
	DWORD m_dwGCS;			
	/////////////////////////////////////////////////
	//  Composition string buffer
	WCHAR m_wcComp;							// Comp string always 1 char long
	WCHAR m_wzResult[nMaxResultStrLen + 2];	// Result string maximum 2 chars + one null + one extra wchar
	// ANSI Composition string
	UCHAR m_szComp[nMaxCompStrLen*2 + 2]; 	// 2: one null + extra byte
	UCHAR m_szResult[nMaxResultStrLen*2 + 4]; // 2: one null + extra bytes


	/////////////////////////////////////////////////
	//  MSG buffer structure support
	UINT 			m_uiMsgCount;
	LPTRANSMSG		m_pMessage;
	LPTRANSMSGLIST	m_pTransMessage;	// for ToAsciiEx

	// WM_IME_KEYDOWN support
	BOOL			m_fKeyDown;
	WPARAM			m_wParamKeyDown;
	LPARAM			m_lParamKeyDown;
	
	/////////////////////////////////////////////////
	// Private status
	DWORD m_dwCandInfoSize;
	DWORD m_dwMessageSize;
};
typedef CIMECtx* PCIMECtx;


//////////////////////////////////////////////////////////////////////////////
// Inline functions
__inline
CIMEData* CIMECtx::GetGData()
{
	return m_pCIMEData;
}

__inline
LPIMEDATA CIMECtx::GetGDataRaw()
{
	if (m_pCIMEData)
		return m_pCIMEData->GetGDataRaw();
	else
		return NULL;
}

__inline
CHangulAutomata* CIMECtx::GetAutomata()
{
	AST_EX(m_pCIMEData != NULL);
	if (m_pCIMEData)
		return m_rgpHangulAutomata[m_pCIMEData->GetCurrentBeolsik()];
	else
		return m_rgpHangulAutomata[0];
}

__inline
HIMC CIMECtx::GetHIMC()
{
	return m_hIMC;
}

__inline
HWND CIMECtx::GetAppWnd()	// m_hIMC->hWnd
{
	AST_EX(m_pIMC != NULL);
	if (m_pIMC == NULL)
		return (HWND)0;
	return m_pIMC->hWnd;
}

__inline
HIMCC CIMECtx::GetHCandInfo()
{
	AST_EX(m_pIMC != NULL);
	AST_EX(m_pIMC->hCandInfo != (HIMCC)0);
	if (m_pIMC == NULL)
		return NULL;
	return m_pIMC->hCandInfo;
}

__inline
LPCANDIDATEINFO CIMECtx::GetPCandInfo() 
{ 
	return m_pCandInfo; 
}

__inline
HIMCC CIMECtx::GetHCompStr()
{
	AST_EX(m_pIMC != NULL);
	AST_EX(m_pIMC->hCompStr != (HIMCC)0);
	if (m_pIMC == NULL)
		return NULL;
	return m_pIMC->hCompStr;
}

__inline
HIMCC CIMECtx::GetHMsgBuf()
{
	AST_EX(m_pIMC != NULL);
	AST_EX(m_pIMC->hMsgBuf != (HIMCC)0);
	if (m_pIMC == NULL)
		return NULL;
	return m_pIMC->hMsgBuf;
}

__inline
VOID  CIMECtx::SetOpen(BOOL fOpen)
{
	m_pIMC->fOpen = fOpen;
}

__inline
BOOL CIMECtx::IsOpen()
{
	// sometime IMM sets 0xffffffff as TRUE
	if (m_pIMC == NULL) 
		return fFalse;
	return (m_pIMC->fOpen ? fTrue : fFalse);
}

__inline
VOID CIMECtx::SetStatusWndPos(POINT &pt)
{
	m_pIMC->ptStatusWndPos = pt;
}

__inline
VOID CIMECtx::GetStatusWndPos(POINT* pPt)
{
	*pPt = m_pIMC->ptStatusWndPos;
}

__inline
DWORD CIMECtx::SetConversionMode(DWORD dwConvMode)
{
	DWORD dwPrevConv = m_pIMC->fdwConversion;
	m_pIMC->fdwConversion = dwConvMode;
	return dwPrevConv;	// return previous conversion mode
}

__inline
DWORD CIMECtx::GetConversionMode()
{
	return m_pIMC->fdwConversion;
}

__inline
DWORD CIMECtx::SetSentenceMode(DWORD dwSentMode)
{
	DWORD dwPrevSent = m_pIMC->fdwSentence;
	m_pIMC->fdwSentence = dwSentMode;
	return dwPrevSent;	// return previous sentence mode
}

__inline
DWORD CIMECtx::GetSentenceMode()
{
	return m_pIMC->fdwSentence;
}

__inline
LOGFONT* CIMECtx::GetLogFont()
{
	return (&(m_pIMC->lfFont.A));
}

// Composition form
__inline
VOID CIMECtx::GetCompositionForm(LPCOMPOSITIONFORM *ppCompForm)
{
	*ppCompForm = &m_pIMC->cfCompForm;
}

__inline
VOID CIMECtx::SetCompositionFormStyle(DWORD dwStyle)
{
	m_pIMC->cfCompForm.dwStyle = dwStyle;
}

__inline
DWORD CIMECtx::GetCompositionFormStyle()
{
	return m_pIMC->cfCompForm.dwStyle;
}

__inline
VOID CIMECtx::SetCompositionFormPos(POINT pt)
{
	m_pIMC->cfCompForm.ptCurrentPos = pt;
}

__inline
VOID CIMECtx::GetCompositionForm(POINT* pPt)
{
	pPt->x = m_pIMC->cfCompForm.ptCurrentPos.x;
	pPt->y = m_pIMC->cfCompForm.ptCurrentPos.y;
}

__inline
VOID CIMECtx::GetCompositionForm(RECT* pRc)
{
	CopyRect(pRc, &m_pIMC->cfCompForm.rcArea);
}


__inline
VOID CIMECtx::SetInitStatus(DWORD dwInitState)
{
	m_pIMC->fdwInit = dwInitState;
}

__inline
VOID CIMECtx::GetInitStatus(LPDWORD pdwInitState)
{
	*pdwInitState = m_pIMC->fdwInit;
}

__inline
VOID CIMECtx::SetCompositionStr(WCHAR wch)
{
	DbgAssert(wch != 0);
	m_wcComp = wch;
	AddGCS(GCS_COMPSTR);
}

__inline
WCHAR CIMECtx::GetCompositionStr()
{
	return m_wcComp;
}

// WARNING: This function will set raw data to comp buffer directly. 
// Pls. very careful to use this function. It could break everything.
__inline
VOID  CIMECtx::SetCompBufStr(WCHAR wch)
{
	DbgAssert(IsUnicodeEnv() == fTrue);
	m_pCompStr->dwCompStrLen = m_pCompStr->dwCompAttrLen = 1;
	*((LPBYTE)m_pCompStr + m_pCompStr->dwCompAttrOffset) = ATTR_INPUT;
	*(LPWSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset) = wch;
}

// For ANSI conversion
__inline
VOID  CIMECtx::SetCompBufStr(CHAR chHigh, CHAR chLow)
{
	DbgAssert(IsUnicodeEnv() == fFalse);
	m_pCompStr->dwCompStrLen  = 2;
	m_pCompStr->dwCompAttrLen = 1;
	*((LPBYTE)m_pCompStr + m_pCompStr->dwCompAttrOffset) = ATTR_INPUT;
	*(LPSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset) = chHigh;
	*(LPSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset + 1) = chLow;
}

// WARNING: This function will set raw data to comp buffer directly. 
// Pls. very careful to use this function. It could break everything.
__inline
VOID CIMECtx::ClearCompositionStrBuffer()
{
	Dbg(DBGID_Key, TEXT("ClearCompositionStrBuffer():"));

	if (m_pCompStr)
		{
		m_pCompStr->dwCompStrLen = m_pCompStr->dwCompAttrLen = 0;
		*(LPWSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset) = L'\0';
		*((LPBYTE)m_pCompStr + m_pCompStr->dwCompAttrOffset) = 0;
		}
}

__inline
VOID CIMECtx::SetResultStr(LPWSTR pwSz)
{
	DbgAssert(pwSz != NULL);
	m_wzResult[0] = *pwSz++;
	m_wzResult[1] = *pwSz;
	AddGCS(GCS_RESULTSTR);
}

__inline
VOID CIMECtx::SetResultStr(WCHAR wch1, WCHAR wch2)
{
	DbgAssert(wch1 != 0);
	Dbg(DBGID_Key, "CIMECtx::SetResultStr - wch1 = 0x%04X, wch2 = 0x%04X", wch1, wch2);
	m_wzResult[0] = wch1;
	m_wzResult[1] = wch2;
	AddGCS(GCS_RESULTSTR);
}

__inline
VOID CIMECtx::AppendResultStr(WCHAR wch)
{
	DbgAssert(wch != 0);
	if (m_wzResult[0] == L'\0')
		m_wzResult[0] = wch;
	else
		m_wzResult[1] = wch;
	AddGCS(GCS_RESULTSTR);
}

__inline
VOID CIMECtx::FinalizeCurCompositionChar()
{
	if (GetAutomata() != NULL)
		{
		GetAutomata()->MakeComplete();
		SetResultStr(GetAutomata()->GetCompleteChar());
		}
	SetEndComposition(fTrue);
	if (!IsProcessKeyStatus())
		StoreComposition();
}

__inline
VOID CIMECtx::ResetComposition()
{
	m_wcComp = L'\0';
	ZeroMemory(m_wzResult, sizeof(m_wzResult));
}

__inline
BOOL CIMECtx::IsCompositionString()
{
	return (m_wcComp ? fTrue : fFalse);
}

__inline
DWORD CIMECtx::GetCompBufLen()
{
	if (GetHCompStr() != NULL)
		return (m_pCompStr->dwCompStrLen);
	else
		return 0;
}

__inline
VOID CIMECtx::SetStartComposition(BOOL fStart)
{
	m_fStartComposition = fStart;
}

__inline
VOID CIMECtx::SetEndComposition(BOOL fEnd)
{
	m_fEndComposition = fEnd;
}

__inline
VOID CIMECtx::ResetCandidate()
{
	ClearCandMeaningArray();
	m_iciCandidate = 0;
}

__inline
INT CIMECtx::GetCandidateCount()
{
	return m_iciCandidate;
}

__inline
VOID CIMECtx::SetCandidateMsg(UINT uiMsg)
{
	m_uiSendCand = uiMsg;
}

__inline
VOID CIMECtx::SetCandStrSelection(DWORD dwSel)
{
	LPCANDIDATELIST	lpCandList;
	if (m_pCandInfo == NULL || m_pCandInfo->dwCount == 0)
		{
		DbgAssert(0);
		return;
		}
	lpCandList = (LPCANDIDATELIST)((LPBYTE)m_pCandInfo + sizeof(CANDIDATEINFO));
	lpCandList->dwPageStart = (dwSel / lpCandList->dwPageSize) * lpCandList->dwPageSize;
    lpCandList->dwSelection = dwSel;
}

/////////////////////////////////////////////////
// Candidate form
__inline
DWORD CIMECtx::GetCandidateFormIndex(INT iIdxCand)
{
	return m_pIMC->cfCandForm[iIdxCand].dwIndex;
}

__inline
VOID CIMECtx::SetCandidateFormIndex(INT iIdx, INT iIdxCand)
{
	m_pIMC->cfCandForm[iIdxCand].dwIndex = (DWORD)iIdx;
}

__inline
VOID CIMECtx::SetCandidateFormStyle(DWORD dwStyle, INT iIdxCand)
{
	m_pIMC->cfCandForm[iIdxCand].dwStyle = dwStyle;
}

__inline
DWORD CIMECtx::GetCandidateFormStyle(INT iIdxCand)
{
	return m_pIMC->cfCandForm[iIdxCand].dwStyle;
}

__inline
VOID CIMECtx::GetCandidateForm(RECT* pRc, INT iIdxCand)
{
	CopyRect( pRc, &m_pIMC->cfCandForm[iIdxCand].rcArea );
}

__inline
VOID CIMECtx::SetCandidateFormArea(RECT* pRc, INT iIdxCand)
{
	CopyRect( &m_pIMC->cfCandForm[iIdxCand].rcArea, pRc );
}

__inline
VOID CIMECtx::GetCandidateFormPos(POINT* pPt, INT iIdxCand)
{
	pPt->x = m_pIMC->cfCandForm[iIdxCand].ptCurrentPos.x;
	pPt->y = m_pIMC->cfCandForm[iIdxCand].ptCurrentPos.y;
}

__inline
VOID CIMECtx::SetCandidateFormPos(POINT pt, INT iIdxCand)
{
	m_pIMC->cfCandForm[iIdxCand].ptCurrentPos = pt;
}

/////////////////////////////////////////////////
//  MSG buffer structure support
__inline
VOID CIMECtx::SetTransMessage(LPTRANSMSGLIST pMessage)
{
	m_pTransMessage = pMessage;
}

__inline
VOID CIMECtx::ResetMessage()
{
	m_uiMsgCount = 0;
	m_pTransMessage = NULL; // trans message now NULL
	m_fEndComposition = fFalse;
	m_fStartComposition = fFalse;
	m_uiSendCand = 0;
	m_fKeyDown = fFalse;
}

__inline
INT CIMECtx::GetMessageCount()
{
	return m_uiMsgCount;
}

__inline
VOID CIMECtx::AddKeyDownMessage(WPARAM wParam, LPARAM lParam)
{
	m_fKeyDown = fTrue;
	m_wParamKeyDown = wParam;
	m_lParamKeyDown = lParam;
}

/////////////////////////////////////////////////
//  Unicode environment
__inline
BOOL CIMECtx::IsUnicodeEnv(VOID)
{
	return m_fUnicode;
}

/////////////////////////////////////////////////
//  Private status
__inline
VOID CIMECtx::ResetGCS(VOID)
{
	m_dwGCS = 0;
}

__inline
DWORD CIMECtx::GetGCS(VOID)
{
	return m_dwGCS;
}

__inline
VOID CIMECtx::DelGCS(DWORD dwGCS)
{
	m_dwGCS &= ~dwGCS;
}

__inline
VOID CIMECtx::AddGCS(DWORD dwGCS)
{
	m_dwGCS |= dwGCS;
}

__inline
DWORD CIMECtx::ValidateGCS(VOID)
{
	if (m_wcComp == 0)
		DelGCS(GCS_COMP_KOR);

	if (m_wzResult[0] == 0)
		DelGCS(GCS_RESULT);

	return m_dwGCS;
}

__inline
VOID CIMECtx::SetUnicode(BOOL fUnicode)
{
	m_fUnicode = fUnicode;
}
	
__inline
VOID CIMECtx::SetProcessKeyStatus(BOOL fSet)
{
	m_fKeyProcessing = fSet;
}

__inline
BOOL CIMECtx::IsProcessKeyStatus(VOID)
{
	return m_fKeyProcessing;
}

__inline
void* CIMECtx::operator new(size_t size)
{
	return (void*)GlobalAllocPtr(GHND, size);
}

__inline
void CIMECtx::operator delete(void* pv)
{
	if (pv)
		GlobalFreePtr(pv);
}


#endif // _IMC_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\imcsub.cpp ===
/****************************************************************************
    IMCSUB.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Subroutines related to HIMC
    !!! NEED FULL REVIEW ALL FUNCTIONS NEED TO USE AND WORKS CORRECTLY !!!
    
    History:
    21-JUL-1999 cslim       Created(Borrowed almost part from KKIME)
*****************************************************************************/

#include "precomp.h"
#include "imc.h"
#include "imcsub.h"
#include "debug.h"

CIMECtx* GetIMECtx(HIMC hIMC)
{
    CIMECtx* pImeCtx;
    CIMCPriv ImcPriv;
    
    if (hIMC == (HIMC)0)
        return NULL;

    if (ImcPriv.LockIMC(hIMC) == fFalse) 
        {
        return NULL;
        }

    if (ImcPriv->hIMC != hIMC) 
        {
        AST(ImcPriv->hIMC == hIMC);
        return NULL;
        }

    pImeCtx = ImcPriv->pImeCtx;

    if (pImeCtx == NULL) 
        {
        AST(pImeCtx != NULL);
        return NULL;
        }

    if (pImeCtx->GetHIMC() != hIMC)
        {
        AST(pImeCtx->GetHIMC() == hIMC);
        return NULL;
        }

    if (ImcPriv->pIPoint == NULL)
        {
        AST(ImcPriv->pIPoint != NULL);
        return NULL;
        }

    return pImeCtx;
}

//IImePadInternal* GetImePad( HIMC hIMC )
//{
    //
    // new : because, IMEPad is per process object
    //
    //Toshiak
//    return GetIImePadInThread();
//    hIMC; //no ref;
//}


BOOL CloseInputContext(HIMC hIMC)
{
    Dbg(DBGID_API, "CloseInputContext::hiMC == %x .\r\n", hIMC);

    if (hIMC) 
        {
        // Because ImeSelect has not been called from IMM on WIN95,
        // clean up hIMC private buffer here.
        CIMCPriv ImcPriv(hIMC);
        IMCPRIVATE* pImcPriv;
        pImcPriv = ImcPriv;
        if (pImcPriv) 
            {
            Dbg(DBGID_API, "CloseInputContext::ImeSelect has not called yet.\r\n");

            // REVIEW:
            if (pImcPriv->pIPoint)
                {
                Dbg(DBGID_API, "CloseInputContext::IPoint Release\r\n");
                pImcPriv->pIPoint->Release();
                pImcPriv->pIPoint = NULL;
                }
            pImcPriv->hIMC = (HIMC)0;
            }
        ImcPriv.ResetPrivateBuffer();
        return fFalse;
        }
    return fTrue;
}

VOID SetPrivateBuffer(HIMC hIMC, VOID* pv, DWORD dwSize)
{
    VOID* pvPriv;
    DWORD dwCurrentSize;
    LPINPUTCONTEXT pCtx;
    
    if (hIMC == NULL)
        return;

    pCtx = (INPUTCONTEXT*)OurImmLockIMC(hIMC);
    if (pCtx == NULL || pCtx->hPrivate == NULL)
        return;

    dwCurrentSize = OurImmGetIMCCSize(pCtx->hPrivate);

    // Check if need to re-allocate
    if (dwCurrentSize < dwSize) 
        { 
        OurImmUnlockIMCC( pCtx->hPrivate );
        pCtx->hPrivate = OurImmReSizeIMCC(pCtx->hPrivate, dwSize);
        AST_EX(pCtx->hPrivate != (HIMCC)0);
        if (pCtx->hPrivate == (HIMCC)0)
            return;
        pvPriv = (VOID*)OurImmLockIMCC(pCtx->hPrivate);
        } 
    else 
        {
        // already sized
        pvPriv = (VOID*)OurImmLockIMCC(pCtx->hPrivate);
        }

    if (pvPriv)
        CopyMemory(pvPriv, pv, dwSize);

    OurImmUnlockIMCC(pCtx->hPrivate);
    OurImmUnlockIMC(hIMC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\imc.cpp ===
/****************************************************************************
    IMC.H

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IME Context abstraction class
    
    History:
    21-JUL-1999 cslim       Created
*****************************************************************************/

#include "precomp.h"
#include "hanja.h"
#include "imc.h"
#include "debug.h"

/*----------------------------------------------------------------------------
    CIMECtx::CIMECtx

    Ctor
----------------------------------------------------------------------------*/
CIMECtx::CIMECtx(HIMC hIMC)
{
    m_fUnicode = fTrue;    // default is UNICODE

    m_dwMessageSize = 0;
    m_dwCandInfoSize = 0;
    
    // Init Context variables
    m_hIMC = hIMC;
    m_pIMC = OurImmLockIMC(m_hIMC);

    //m_hCandInfo = m_pIMC->hCandInfo;
    m_pCandInfo = (LPCANDIDATEINFO)OurImmLockIMCC(GetHCandInfo());

    //m_hCompStr = m_pIMC->hCompStr;
    InitCompStrStruct();
    
    //m_hMessage = m_pIMC->hMsgBuf;
    m_pMessage = (LPTRANSMSG)OurImmLockIMCC(GetHMsgBuf());

    // Reset composition info.
    ResetComposition();

    // Reset candidate infos
    m_pCandStr = NULL;
    m_rgpCandMeaningStr    = NULL;
    ResetCandidate();
    
    // Reset GCS flag to zero
    ResetGCS();
    
    // initialize message buffer
    ResetMessage();
    
    // clear hCompStr
    ClearCompositionStrBuffer();

    //////////////////////////////////////////////////////////////////////
    // initialize Shared memory. If this is only IME in the system
    // Shared memory will be created as file mapping object.
    //////////////////////////////////////////////////////////////////////
    m_pCIMEData = new CIMEData;
    DbgAssert(m_pCIMEData != 0);
    
    // Initialize IME shared memory to default value and set reg value if avaliable
    // Read registry: Do not call it in the DllMain
    if (m_pCIMEData)
        {
        m_pCIMEData->InitImeData();
        }

    // Initialize Hangul Automata
    //GetAutomata()->InitState();

    //////////////////////////////////////////////////////////////////////////
    // Create All three IME Automata instances
    m_rgpHangulAutomata[KL_2BEOLSIK]        = new CHangulAutomata2;
    m_rgpHangulAutomata[KL_3BEOLSIK_390]   = new CHangulAutomata3;
    m_rgpHangulAutomata[KL_3BEOLSIK_FINAL] = new CHangulAutomata3Final;
}

/*----------------------------------------------------------------------------
    CIMECtx::CIMECtx

    Dtor
----------------------------------------------------------------------------*/
CIMECtx::~CIMECtx()
{
    if (m_pCIMEData)
        {
        delete m_pCIMEData;
        m_pCIMEData =  NULL;
        }

    // Release Cand info
    if (GetHCandInfo())
        OurImmUnlockIMCC(GetHCandInfo());
    m_pCandInfo = NULL;

    // Release Comp str
    if (GetHCompStr())
        OurImmUnlockIMCC(GetHCompStr());
    m_pCompStr = NULL;

    // Release Msg buffer
    ResetMessage();
    if (GetHMsgBuf())
        OurImmUnlockIMCC(GetHMsgBuf());
    m_pMessage = NULL;

    // Reset hIMC
    OurImmUnlockIMC(m_hIMC);
    m_pIMC = NULL;
    m_hIMC = NULL;

    // Free candidate private buffer
    if (m_pCandStr)
        {
        GlobalFree(m_pCandStr);
        m_pCandStr = NULL;
        }
        
    if (m_rgpCandMeaningStr)
        {
        ClearCandMeaningArray();
        GlobalFree(m_rgpCandMeaningStr);
        m_rgpCandMeaningStr = NULL;
        }

    // delete Automata 
    for (INT i=0; i<NUM_OF_IME_KL; i++)
        if (m_rgpHangulAutomata[i])
            delete m_rgpHangulAutomata[i];
}

/*----------------------------------------------------------------------------
    CIMECtx::InitCompStrStruct

    Initialize and reallocater composition string buffer
----------------------------------------------------------------------------*/
VOID CIMECtx::InitCompStrStruct()
{
    INT iAllocSize;

    if (m_pIMC == NULL)
        return;
    
    // Calc COMPOSITIONSTRING buffer size.
    iAllocSize = sizeof(COMPOSITIONSTRING) +
                // composition string plus NULL terminator
                nMaxCompStrLen   * sizeof(WCHAR) + sizeof(WCHAR) +
                // composition attribute
                nMaxCompStrLen   * sizeof(WORD) +
                // result string plus NULL terminator
                nMaxResultStrLen * sizeof(WCHAR) + sizeof(WCHAR);

    // For avoiding miss alignment
    iAllocSize += 2;

    // Reallocation COMPOSITION buffer
    m_pIMC->hCompStr = OurImmReSizeIMCC(GetHCompStr(), iAllocSize);
    AST_EX(m_pIMC->hCompStr != (HIMCC)0);
    if (m_pIMC->hCompStr == (HIMCC)0) 
        {
        DbgAssert(0);
        return;
        }
        
    if (m_pCompStr = (LPCOMPOSITIONSTRING)OurImmLockIMCC(GetHCompStr()))
        {
        // CONFIRM: Need to clear memory??
        ZeroMemory(m_pCompStr, iAllocSize);

        // Store total size
        m_pCompStr->dwSize = iAllocSize;

        // REVIEW: Does we need Null termination??
        // Store offset. All offset is static which will be calculated in compile time
        m_pCompStr->dwCompStrOffset   = sizeof(COMPOSITIONSTRING);
        m_pCompStr->dwCompAttrOffset  = sizeof(COMPOSITIONSTRING) + 
                                        nMaxCompStrLen * sizeof(WCHAR) + sizeof(WCHAR);     // length of comp str
        m_pCompStr->dwResultStrOffset = sizeof(COMPOSITIONSTRING) + 
                                        nMaxCompStrLen * sizeof(WCHAR) + sizeof(WCHAR) +     // length of comp str
                                        nMaxCompStrLen * sizeof(WORD)  +  2;                // length of comp str attr
        }

    Dbg(DBGID_CompChar, "InitCompStrStruct m_pIMC->hCompStr = 0x%x, m_pCompStr = 0x%x", m_pIMC->hCompStr, m_pCompStr);
}

/*----------------------------------------------------------------------------
    CIMECtx::StoreComposition

    Store all composition result to IME context buffer
----------------------------------------------------------------------------*/
VOID CIMECtx::StoreComposition()
{
    LPWSTR pwsz;
    LPSTR  psz;

    Dbg(DBGID_Key, "StoreComposition GCS = 0x%x", GetGCS());

    // Check composition handle validity
    if (GetHCompStr() == NULL || m_pCompStr == NULL)
        return ;

    //////////////////////////////////////////////////////////////////////////
    // Comp Str
    if (GetGCS() & GCS_COMPSTR)
        {
        Dbg(DBGID_Key, "StoreComposition - GCS_COMPSTR comp str = 0x%04X", m_wcComp);
        DbgAssert(m_wcComp != 0);
        // Composition string. dw*StrLen contains character count
        if (IsUnicodeEnv())
            {
            m_pCompStr->dwCompStrLen = 1;
            pwsz = (LPWSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset);
            *pwsz++ = m_wcComp;    // Store composition char
            *pwsz   = L'\0';
            }
        else
            {
            // Byte length
            m_pCompStr->dwCompStrLen = 2;
            // Convert to ANSI
            WideCharToMultiByte(CP_KOREA, 0, 
                                &m_wcComp, 1, (LPSTR)m_szComp, sizeof(m_szComp), 
                                NULL, NULL );
            psz = (LPSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset);
            *psz++ = m_szComp[0];
            *psz++ = m_szComp[1];
            *psz = '\0';
            }
            
        // Composition attribute. Always set
        m_pCompStr->dwCompAttrLen = 1;
        *((LPBYTE)m_pCompStr + m_pCompStr->dwCompAttrOffset) = ATTR_INPUT;
        } 
    else 
        {
        // Reset length
        m_pCompStr->dwCompStrLen = 0;
        m_pCompStr->dwCompAttrLen = 0;
        }

    //////////////////////////////////////////////////////////////////////////
    // Result Str
    if (GetGCS() & GCS_RESULTSTR)
        {
        Dbg(DBGID_Key, "StoreComposition - GCS_RESULTSTR comp str = 0x%04x, 0x%04X", m_wzResult[0], m_wzResult[1]);

        // Composition string. dw*StrLen contains character count
        if (IsUnicodeEnv())
            {
            // Result string length 1 or 2
            m_pCompStr->dwResultStrLen = m_wzResult[1] ? 2 : 1; // lstrlenW(m_wzResult); 
            pwsz = (LPWSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwResultStrOffset);
            *pwsz++ = m_wzResult[0]; // Store composition result string
            if (m_wzResult[1])
                *pwsz++ = m_wzResult[1]; // Store composition result string
            *pwsz = L'\0';
            }
        else
            {
            // Result string length 2 or 3
            m_pCompStr->dwResultStrLen = m_wzResult[1] ? 3 : 2; // lstrlenW(m_wzResult); 
            // Convert to ANSI
            WideCharToMultiByte(CP_KOREA, 0, 
                                m_wzResult, (m_wzResult[1] ? 2 : 1), 
                                (LPSTR)m_szResult, sizeof(m_szResult), 
                                NULL, NULL );
                                
            psz = (LPSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwResultStrOffset);
            *psz++ = m_szResult[0];
            *psz++ = m_szResult[1];
            if (m_wzResult[1])
                *psz++ = m_szResult[2];
            *psz = '\0';
            }
        }
    else 
        {
        m_pCompStr->dwResultStrLen = 0;
        }
}

/////////////////////////////////////////////////
//  CANDIDATEINFO STRUCTURE SUPPORT
/////////////////////////////////////////////////
VOID CIMECtx::AppendCandidateStr(WCHAR wcCand, LPWSTR wszMeaning)
{
    Dbg(DBGID_Hanja, "AppendCandidateStr");
    
    // Alocate cand string and meaning buffer
    if (m_pCandStr == NULL)
        {
        m_pCandStr =(LPWSTR)GlobalAlloc(GPTR, sizeof(WCHAR)*MAX_CANDSTR);
        DbgAssert(m_pCandStr != NULL);
        }

    if (m_rgpCandMeaningStr == NULL)
        {
        m_rgpCandMeaningStr = (LPWSTR*)GlobalAlloc(GPTR, sizeof(LPWSTR)*MAX_CANDSTR);
        DbgAssert(m_rgpCandMeaningStr != NULL);
        }

    if (m_pCandStr == NULL || m_rgpCandMeaningStr == NULL)
        return;

    // Append candidate char
    DbgAssert(m_iciCandidate < MAX_CANDSTR);
    if (m_iciCandidate >= MAX_CANDSTR)
        return;
        
    m_pCandStr[m_iciCandidate] = wcCand;

    // Append candidate meaning
    if (wszMeaning[0])
        {
        m_rgpCandMeaningStr[m_iciCandidate] = (LPWSTR)GlobalAlloc(GPTR, sizeof(WCHAR)*(lstrlenW(wszMeaning)+1));
        if (m_rgpCandMeaningStr[m_iciCandidate] == NULL)
            return;
        StrCopyW(m_rgpCandMeaningStr[m_iciCandidate], wszMeaning);
        }
    else
        m_rgpCandMeaningStr[m_iciCandidate] = NULL;

    m_iciCandidate++;
}

WCHAR CIMECtx::GetCandidateStr(INT iIdx)
{
    if (iIdx < 0 || iIdx >= MAX_CANDSTR)
        {
        DbgAssert(0);
        return L'\0';
        }
    if (iIdx >= m_iciCandidate)
        {
        DbgAssert(0);
        return L'\0';
        }
    return m_pCandStr[iIdx];
}

LPWSTR CIMECtx::GetCandidateMeaningStr(INT iIdx)
{
    if (m_rgpCandMeaningStr == NULL || 
        m_rgpCandMeaningStr[iIdx] == NULL || 
        iIdx >= MAX_CANDSTR || iIdx < 0)
        {
        // DbgAssert(0); It happen for symbol mapping
        return NULL;
        }
    else
        return m_rgpCandMeaningStr[iIdx];
}

VOID CIMECtx::StoreCandidate()
{
    INT                 iAllocSize;
    LPCANDIDATELIST        lpCandList;

    Dbg(DBGID_Key, "StoreCandidate");

    if (GetHCandInfo() == NULL)
        return ; // do nothing

    // Calc CANDIDATEINFO buffer size
    iAllocSize = sizeof(CANDIDATEINFO) +
                 sizeof(CANDIDATELIST) +                // candlist struct
                 m_iciCandidate * sizeof(DWORD) +        // cand index
                   m_iciCandidate * sizeof(WCHAR) * 2;    // cand strings with null termination

    // Alllocate buffer
    if (m_dwCandInfoSize < (DWORD)iAllocSize) // need to re-allocate
        {
        // reallocation COMPOSITION buffer
        OurImmUnlockIMCC(GetHCandInfo());
        m_pIMC->hCandInfo = OurImmReSizeIMCC(GetHCandInfo(), iAllocSize);
        AST_EX(m_pIMC->hCandInfo != (HIMCC)0);

        if (m_pIMC->hCandInfo == (HIMCC)0)
            return;

        m_pCandInfo = (CANDIDATEINFO*)OurImmLockIMCC(GetHCandInfo());
        m_dwCandInfoSize = (DWORD)iAllocSize;
        }

    // Check if m_pCandInfo is valid
    if (m_pCandInfo == NULL)
        return;

    // Fill cand info
    m_pCandInfo->dwSize = iAllocSize;
    m_pCandInfo->dwCount = 1;
    m_pCandInfo->dwOffset[0] = sizeof(CANDIDATEINFO);

    // Fill cand list
    lpCandList = (LPCANDIDATELIST)((LPBYTE)m_pCandInfo + m_pCandInfo->dwOffset[0]);
    lpCandList->dwSize = iAllocSize - sizeof(CANDIDATEINFO);
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = m_iciCandidate;
    lpCandList->dwPageStart = lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CAND_PAGE_SIZE;


    INT iOffset = sizeof(CANDIDATELIST) 
                  + sizeof(DWORD) * (m_iciCandidate); // for dwOffset array

    for (INT i = 0; i < m_iciCandidate; i++)
        {
        LPWSTR  wszCandStr;
        LPSTR   szCandStr;
        CHAR    szCand[4] = "\0\0";    // Cand string always 1 char(2 bytes) + extra one byte
        
        lpCandList->dwOffset[i] = iOffset;
        if (IsUnicodeEnv())
            {
            wszCandStr = (LPWSTR)((LPSTR)lpCandList + iOffset);
            *wszCandStr++ = m_pCandStr[i];
            *wszCandStr++ = L'\0';
            iOffset += sizeof(WCHAR) * 2;
            }
        else
            {
            // Convert to ANSI
            WideCharToMultiByte(CP_KOREA, 0, 
                                &m_pCandStr[m_iciCandidate], 1, (LPSTR)szCand, sizeof(szCand), 
                                NULL, NULL );

            szCandStr = (LPSTR)((LPSTR)lpCandList + iOffset);
            *szCandStr++ = szCand[0];
            *szCandStr++ = szCand[1];
            *szCandStr = '\0';
            iOffset += 3; // DBCS + NULL
            }
        }
}

/////////////////////////////////////////////////
//  MSGBUF STRUCTURE SUPPORT
BOOL CIMECtx::FinalizeMessage()
{
    DWORD  dwCurrentGCS;
    WPARAM wParam;

    Dbg(DBGID_Key, "FinalizeMessage");

    // support WM_IME_STARTCOMPOSITION
    if (m_fStartComposition == fTrue)
        {
        Dbg(DBGID_Key, "FinalizeMessage - WM_IME_STARTCOMPOSITION");
        AddMessage(WM_IME_STARTCOMPOSITION);
        }

    // support WM_IME_ENDCOMPOSITION
    if (m_fEndComposition == fTrue)
        {
        Dbg(DBGID_Key, "FinalizeMessage - WM_IME_ENDCOMPOSITION");

        AddMessage(WM_IME_ENDCOMPOSITION);

        // Clear all automata states
        if (GetAutomata() != NULL)
            {
            GetAutomata()->InitState();
            }
        }


    // GCS validation before set to IMC
    dwCurrentGCS = ValidateGCS();
    if (dwCurrentGCS & GCS_RESULTSTR)
        {
        Dbg(DBGID_Key, "FinalizeMessage - WM_IME_COMPOSITION - GCS_RESULTSTR 0x%04x", m_wzResult[0]);

        if (IsUnicodeEnv())
            AddMessage(WM_IME_COMPOSITION, m_wzResult[0], GCS_RESULTSTR);
        else
            {
            // Set ANSI code
            wParam = ((WPARAM)m_szResult[0] << 8) | m_szResult[1];
            AddMessage(WM_IME_COMPOSITION, wParam, GCS_RESULTSTR);
            }
        }

    if (dwCurrentGCS & GCS_COMP_KOR)
        {
        Dbg(DBGID_Key, "FinalizeMessage - WM_IME_COMPOSITION - GCS_COMP_KOR 0x%04x", m_wcComp);

        if (IsUnicodeEnv())
            AddMessage(WM_IME_COMPOSITION, m_wcComp, (GCS_COMP_KOR|GCS_COMPATTR|CS_INSERTCHAR|CS_NOMOVECARET));
        else
            {
            // Set ANSI code
            wParam = ((WPARAM)m_szComp[0] << 8) | m_szComp[1];
            AddMessage(WM_IME_COMPOSITION, wParam, (GCS_COMP_KOR|GCS_COMPATTR|CS_INSERTCHAR|CS_NOMOVECARET));
            }
        }

    ResetGCS();    // reset now

    // O10 Bug #150012
    // support WM_IME_ENDCOMPOSITION
    if (m_fEndComposition == fTrue)
        {
        ResetComposition();
        ResetCandidate();
        }

    FlushCandMessage();

    //////////////////////////////////////////////////////////////////////////
    // WM_IME_KEYDOWN: This should be added after all composition message
    if (m_fKeyDown)
        AddMessage(WM_IME_KEYDOWN, m_wParamKeyDown, (m_lParamKeyDown << 16) | 1UL);

    return TRUE;
}

VOID CIMECtx::FlushCandMessage()
{
    switch (m_uiSendCand)
        {
    case MSG_NONE:        // Do nothing
        break;
    case MSG_OPENCAND:
        AddMessage(WM_IME_NOTIFY, IMN_OPENCANDIDATE, 1);
        break;
    case MSG_CLOSECAND:
        AddMessage(WM_IME_NOTIFY, IMN_CLOSECANDIDATE, 1);
        ResetCandidate();
        break;
    case MSG_CHANGECAND:
        AddMessage(WM_IME_NOTIFY, IMN_CHANGECANDIDATE, 1);
        break;
    default:
        DbgAssert(0);    // Error
        break;
        }
        
    m_uiSendCand = MSG_NONE;
}


BOOL CIMECtx::GenerateMessage()
{
    BOOL fResult = fFalse;
    INT iMsgCount;

    Dbg(DBGID_Key, "GenerateMessage");

    if (IsProcessKeyStatus())
        return fFalse;    // Do nothing
        
    FinalizeMessage();
    iMsgCount = GetMessageCount();
    ResetMessage();
    
    if (iMsgCount > 0)
        fResult = OurImmGenerateMessage(m_hIMC);

    return fResult;
}

INT CIMECtx::AddMessage(UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    LPTRANSMSG pImeMsg;

    Dbg(DBGID_Key, "AddMessage uiMessage=0x%X, wParam=0x%04X, lParam=0x%08lX", uiMessage, wParam, lParam);

    if (GetHMsgBuf() == NULL)
        return m_uiMsgCount;

    m_uiMsgCount++;

    //////////////////////////////////////////////////////////////////////////
    // Check if this data stream created by ImeToAsciiEx()
    if (m_pTransMessage) 
        {    
        Dbg(DBGID_Key, "AddMessage - use Transbuffer(ImeToAscii)");
        
        // Check if need reallocate message buffer
        if (m_pTransMessage->uMsgCount >= m_uiMsgCount) 
            {
            // Fill msg buffer
            pImeMsg = &m_pTransMessage->TransMsg[m_uiMsgCount - 1];
            pImeMsg->message = uiMessage;
            pImeMsg->wParam = wParam;
            pImeMsg->lParam = lParam;
            } 
        else 
            {
            DbgAssert(0);
            // pre-allocated buffer is full - use hMsgBuf instead.
            UINT uiMsgCountOrg = m_uiMsgCount;          // backup
            m_uiMsgCount = 0;                          // reset anyway
            LPTRANSMSGLIST pHeader = m_pTransMessage; // backup
            SetTransMessage(NULL);                      // use hMsgBuf
            
            for (UINT i=0; i<uiMsgCountOrg; i++)
                AddMessage(pHeader->TransMsg[i].message, pHeader->TransMsg[i].wParam, pHeader->TransMsg[i].lParam);

            // finally adds current message
            AddMessage(uiMessage, wParam, lParam);
            }
        } 
    else  // m_pTransMessage. Not called from ImeToAsciiEx()
        {
        UINT  iMaxMsg = m_dwMessageSize / sizeof(TRANSMSG);
        DWORD dwNewSize;
        Dbg(DBGID_Key, "AddMessage - use hMsgBuf");    

        if (m_uiMsgCount > iMaxMsg) 
            {
            Dbg(DBGID_Key, "AddMessage - Reallocate");
            // Reallocation message buffer
            OurImmUnlockIMCC(GetHMsgBuf());
            dwNewSize = max(16, m_uiMsgCount) * sizeof(TRANSMSG);    // At least 16 cand list

            m_pIMC->hMsgBuf = OurImmReSizeIMCC(GetHMsgBuf(), dwNewSize);
            AST_EX(m_pIMC->hMsgBuf != (HIMCC)0);

            if (m_pIMC->hMsgBuf == (HIMCC)0)
                return m_uiMsgCount;

            m_pMessage = (LPTRANSMSG)OurImmLockIMCC(GetHMsgBuf());
            m_dwMessageSize = dwNewSize;
            }

        // Fill msg buffer
        pImeMsg = m_pMessage + m_uiMsgCount - 1;
        pImeMsg->message = uiMessage;
        pImeMsg->wParam = wParam;
        pImeMsg->lParam = lParam;

        // set message count
        m_pIMC->dwNumMsgBuf = m_uiMsgCount;
        }
    
    return m_uiMsgCount;
}

/*----------------------------------------------------------------------------
    CIMECtx::GetCompBufStr

    Get current hCompStr comp str. If Win95, convert it to Unicode
----------------------------------------------------------------------------*/
WCHAR CIMECtx::GetCompBufStr()
{
    WCHAR wch;

    if (GetHCompStr() == NULL || m_pCompStr == NULL)
        return L'\0';

    if (IsUnicodeEnv())
        return *(LPWSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset);
    else
        {
        if (MultiByteToWideChar(CP_KOREA, MB_PRECOMPOSED, 
                                (LPSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset), 
                                2, 
                                &wch, 
                                1))
            return wch;
        else
            return L'\0';

        }
}

/*----------------------------------------------------------------------------
    CIMECtx::ClearCandMeaningArray
----------------------------------------------------------------------------*/
void CIMECtx::ClearCandMeaningArray() 
{
    if (m_rgpCandMeaningStr == NULL)
        return;

    for (int i=0; i<MAX_CANDSTR; i++) 
        {
        if (m_rgpCandMeaningStr[i] == NULL)
            break;

        GlobalFree(m_rgpCandMeaningStr[i]);
        m_rgpCandMeaningStr[i] = 0;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\imcsub.h ===
/****************************************************************************
	IMCSUB.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Subroutines related to HIMC.
	!!! NEED FULL REVIEW ALL FUNCTIONS NEED TO USE AND WORKS CORRECTLY !!!
	
	History:
	21-JUL-1999 cslim       Created(Borrowed almost part from KKIME)
*****************************************************************************/

#if !defined (_IMCSUB_H__INCLUDED_)
#define _IMCSUB_H__INCLUDED_

#include "ipoint.h"

//////////////////////////////////////////////////////////////////////////////
// IME private data for each context
typedef struct tagIMCPRIVATE 
{
	HIMC hIMC;
	// DWORD        fdwImeMsg;      // what messages should be generated
    // DWORD        dwCompChar;     // wParam of WM_IME_COMPOSITION
	// DWORD        dwCmpltChar;    // wParam of WM_IME_COMPOSITION with GCS_RESULTSTR
    // DWORD        fdwGcsFlag;     // lParam for WM_IME_COMPOSITION
    IImeIPoint1* pIPoint;
	CIMECtx*	 pImeCtx;         // same as pIPoint->GetImeCtx(x)
} IMCPRIVATE ;
typedef IMCPRIVATE	*PIMCPRIVATE;
typedef IMCPRIVATE	*LPIMCPRIVATE;

/*
typedef struct tagIMCPRIVATE 
{
	HIMC hIMC;
	IImeKbd*			pImeKbd;
	IImeIPoint*			pIPoint;
	IImeConvert*		pConvert;
	IImePadInternal* 	pImePad;
	IMECtx*				pImeCtx;	// same as pIPoint->GetImeCtx( x )
} IMCPRIVATE;
*/

PUBLIC VOID SetPrivateBuffer(HIMC hIMC, VOID* pv, DWORD dwSize);
PUBLIC BOOL CloseInputContext(HIMC hIMC);

//////////////////////////////////////////////////////////////////////////////
// Inline functions

PUBLIC CIMECtx* GetIMECtx(HIMC hIMC);	// in api.cpp

// CIMCPriv class Handle IME Private buffer
class CIMCPriv
{
public:
    CIMCPriv() { m_hIMC = NULL; m_inputcontext = NULL; m_priv = NULL; }
    CIMCPriv(HIMC hIMC);
    ~CIMCPriv() { UnLockIMC(); }

public:
    BOOL LockIMC(HIMC hIMC);
    void UnLockIMC();
    void ResetPrivateBuffer();

    operator LPIMCPRIVATE()      { return m_priv; }
    LPIMCPRIVATE operator->() { AST(m_priv != NULL); return m_priv; }

private:
    HIMC m_hIMC;
    LPINPUTCONTEXT m_inputcontext;
    LPIMCPRIVATE   m_priv;
};

//
// Inline functions
//
inline CIMCPriv::CIMCPriv(HIMC hIMC)
{
    AST(hIMC != NULL);
    m_hIMC = NULL;
    m_inputcontext = NULL;
    m_priv = NULL;

    LockIMC(hIMC);    
}

inline BOOL CIMCPriv::LockIMC(HIMC hIMC)
{
    if (hIMC != NULL)
        {
        m_hIMC = hIMC;
        m_inputcontext = (LPINPUTCONTEXT)OurImmLockIMC(hIMC);
        if (m_inputcontext)
            {
            // hIMC->hPrivate was not allocated properly. e.g ImeSelect(TRUE)was not called.
            if (OurImmGetIMCCSize(m_inputcontext->hPrivate) != sizeof(IMCPRIVATE))
                return fFalse;

            m_priv = (LPIMCPRIVATE)OurImmLockIMCC(m_inputcontext->hPrivate);
            }
        }

    return (hIMC != NULL && m_priv != NULL);
}

inline void CIMCPriv::UnLockIMC()
{
    if (m_hIMC != NULL && m_inputcontext != NULL)
        {
        OurImmUnlockIMCC(m_inputcontext->hPrivate);
        OurImmUnlockIMC(m_hIMC);
        }
}

inline void CIMCPriv::ResetPrivateBuffer()
{
    AST(m_hIMC != NULL);
    
    if (m_inputcontext && m_priv)
        {
        m_priv->hIMC = (HIMC)0;
        }
}

__inline IImeIPoint1* GetImeIPoint(HIMC hIMC)
{
    CIMCPriv ImcPriv;
    
	if (ImcPriv.LockIMC(hIMC) == fFalse) 
		{
		return NULL;
		}
	return ImcPriv->pIPoint;
}

#endif // _IMCSUB_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\hauto.cpp ===
/****************************************************************************
    HAUTO.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Hangul composition state machine class
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "hauto.h"
#include "debug.h"

// Code conversion table from Chosung to Jongsung.
const 
BYTE  CHangulAutomata::Cho2Jong[NUM_OF_CHOSUNG+1] = //(+ 1 means including fill code at 0)
    { 0, 
      1,  2,  4,  7,  0,  8, 16, 17,  0, 19,
     20, 21, 22,  0, 23, 24, 25, 26, 27
    };

// Code conversion table from Jongsung to Chosung.
const 
BYTE  CHangulAutomata::Jong2Cho[NUM_OF_JONGSUNG] = // Jongsung has inherent fill code
    {  0, 
        1,  2,  0,  3,  0,  0,  4,  6,  0,  0,
        0,  0,  0,  0,  0,  7,  8,  0, 10, 11,
       12, 13, 15, 16, 17, 18, 19  
    };

// Combination table for double jongsung.
BYTE  CHangulAutomata2::rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_2BEOL+1][3] = 
    {
        {  1, 19,  3 }, {  4, 22,  5 }, 
        {  4, 27,  6 },    {  8,  1,  9 }, 
        {  8, 16, 10 },    {  8, 17, 11 }, 
        {  8, 19, 12 },    {  8, 25, 13 }, 
        {  8, 26, 14 }, {  8, 27, 15 }, 
        { 17, 19, 18 },
        { 0,   0,  0 }
    };

BYTE  CHangulAutomata3::rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_3BEOL+1][3] = 
    {
        // 3Beolsik has two more Double Jongsung conditions.
        {  1,  1,  2 },    // KiYeok+KiYeok = Double KiYeok
        {  1, 19,  3 }, {  4, 22,  5 }, 
        {  4, 27,  6 },    {  8,  1,  9 }, 
        {  8, 16, 10 },    {  8, 17, 11 }, 
        {  8, 19, 12 },    {  8, 25, 13 }, 
        {  8, 26, 14 }, {  8, 27, 15 }, 
        { 17, 19, 18 },    
        { 19, 19, 20 },  // Sios+Sios = Double Sios
        { 0,   0,  0 }
    };


#if (NOT_USED)
static
WORD CHangulAutomata::DblJong2Cho(WORD DblJong)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    int i = NUM_OF_DOUBLE_JONGSUNG;
    
    for (; i>0; i--, pDbl--)
        if ( (*pDbl)[2] == DblJong ) 
            return Jong2Cho[(*pDbl)[1]];

    return 0;
}
#endif

///////////////////////////////////////////////////////////////////////////////
// 2 beolsik input state category
const WORD CHangulAutomata2::H_CONSONANT = 0x0000 | H_HANGUL;    // Consonant
const WORD CHangulAutomata2::H_VOWEL     = 0x0100 | H_HANGUL;    // Vowel
const WORD CHangulAutomata2::H_DOUBLE    = 0x0200 | H_HANGUL;    // Double combination possible
const WORD CHangulAutomata2::H_ONLYCHO   = 0x0400 | H_HANGUL;    // Chosung only

// 3 beolsik input state category
const WORD CHangulAutomata3::H_CHOSUNG   = 0x0000 | H_HANGUL;    // ChoSung
const WORD CHangulAutomata3::H_JUNGSUNG  = 0x0200 | H_HANGUL;   // JungSung
const WORD CHangulAutomata3::H_JONGSUNG  = 0x0400 | H_HANGUL;   // JongSung
const WORD CHangulAutomata3::H_DOUBLE    = 0x0100 | H_HANGUL;    // Double combination possible

///////////////////////////////////////////////////////////////////////////////
// bHTable[] structure
//
// 2 Beolsik
//     H I G H  B Y T E  L O W  B Y T E
//    7 6 5 4 3 2 1 0  7 6 5 4 3 2 1 0          
//   +-+-------+-----+---------------+
//   | |       |     |               |
//   +-+-------+-----+---------------+
//     High 8   : Hangul or English
//   High 2-0 : used for input state category field.
//   Low  4-0 : Hangul component code (internal code)
//

// ====-- SHARED SECTION START --====
#pragma data_seg(".MSIMESHR")
WORD  CHangulAutomata2::wHTable[256][2] =
{
//  { Hangul normal, Hangul shift, English normal, English shift }
    // 2 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 0x30, 0x29 }, //  48, 0x30: VK_0
    { 0x31, 0x21 }, //  49, 0x31: VK_1
    { 0x32, 0x40 }, //  50, 0x32: VK_2
    { 0x33, 0x23 }, //  51, 0x33: VK_3
    { 0x34, 0x24 }, //  52, 0x34: VK_4
    { 0x35, 0x25 }, //  53, 0x35: VK_5
    { 0x36, 0x5E }, //  54, 0x36: VK_6
    { 0x37, 0x26 }, //  55, 0x37: VK_7
    { 0x38, 0x2A }, //  56, 0x38: VK_8
    { 0x39, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    {  7 | H_CONSONANT,  7 | H_CONSONANT },                            //  65, 0x41: VK_A        
    { 18 | H_VOWEL, 18 | H_VOWEL },                                    //  66, 0x42: VK_B        
    { 15 | H_CONSONANT, 15 | H_CONSONANT },                            //  67, 0x43: VK_C        
    { 12 | H_CONSONANT, 12 | H_CONSONANT },                            //  68, 0x44: VK_D        
    {  4 | H_CONSONANT,  5 | H_ONLYCHO},                            //  69, 0x45: VK_E        
    {  6 | H_CONSONANT | H_DOUBLE,  6 | H_CONSONANT | H_DOUBLE },    //  70, 0x46: VK_F        
    { 19 | H_CONSONANT, 19 | H_CONSONANT },                            //  71, 0x47: VK_G        
    {  9 | H_VOWEL | H_DOUBLE,  9 | H_VOWEL | H_DOUBLE },            //  72, 0x48: VK_H        
    {  3 | H_VOWEL,  3 | H_VOWEL },                                    //  73, 0x49: VK_I        
    {  5 | H_VOWEL,  5 | H_VOWEL },                                    //  74, 0x4A: VK_J        
    {  1 | H_VOWEL,  1 | H_VOWEL },                                    //  75, 0x4B: VK_K        
    { 21 | H_VOWEL, 21 | H_VOWEL },                                    //  76, 0x4C: VK_L        
    { 19 | H_VOWEL | H_DOUBLE, 19 | H_VOWEL | H_DOUBLE },            //  77, 0x4D: VK_M        
    { 14 | H_VOWEL | H_DOUBLE, 14 | H_VOWEL | H_DOUBLE },            //  78, 0x4E: VK_N        
    {  2 | H_VOWEL,  4 | H_VOWEL },                                    //  79, 0x4F: VK_O        
    {  6 | H_VOWEL,  8 | H_VOWEL },                                    //  80, 0x50: VK_P        
    {  8 | H_CONSONANT | H_DOUBLE,  9 | H_ONLYCHO },                //  81, 0x51: VK_Q        
    {  1 | H_CONSONANT | H_DOUBLE,  2 | H_CONSONANT },                //  82, 0x52: VK_R        
    {  3 | H_CONSONANT | H_DOUBLE,  3 | H_CONSONANT | H_DOUBLE },    //  83, 0x53: VK_S        
    { 10 | H_CONSONANT, 11 | H_CONSONANT },                            //  84, 0x54: VK_T        
    {  7 | H_VOWEL, 7 | H_VOWEL },                                    //  85, 0x55: VK_U        
    { 18 | H_CONSONANT, 18 | H_CONSONANT },                            //  86, 0x56: VK_V        
    { 13 | H_CONSONANT, 14 | H_ONLYCHO },                            //  87, 0x57: VK_W        
    { 17 | H_CONSONANT, 17 | H_CONSONANT },                            //  88, 0x58: VK_X        
    { 13 | H_VOWEL, 13 | H_VOWEL },                                    //  89, 0x59: VK_Y        
    { 16 | H_CONSONANT, 16 | H_CONSONANT },                            //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    { 0x3B, 0x3A }, // 186, 0xBA:    ;    :
    { 0x3D, 0x2B }, // 187, 0xBB:    =    +
    { 0x2C, 0x3C }, // 188, 0xBC:    ,    <
    { 0x2D, 0x5F }, // 189, 0xBD:    -    _
    { 0x2E, 0x3E }, // 190, 0xBE:    .    >
    { 0x2F, 0x3F }, // 191, 0xBF:    /    ?
    { 0x60, 0x7E }, // 192, 0xC0:    `    ~
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:    [    {
    { 0x5C, 0x7C }, // 220, 0xDC:    \    |
    { 0x5D, 0x7D }, // 221, 0xDD:    ]    }
    { 0x27, 0x22 }, // 222, 0xDE:    '    "
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

WORD  CHangulAutomata3::wHTable[256][2] =
{
    // 3 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 16 | H_CHOSUNG, 0x29 },                    //  48, 0x30: VK_0        )
    { 27 | H_JONGSUNG, 22 | H_JONGSUNG },        //  49, 0x31: VK_1        
    { 20 | H_JONGSUNG, 0x40 },                    //  50, 0x32: VK_2        @
    { 17 | H_JONGSUNG | H_DOUBLE, 0x23 },        //  51, 0x33: VK_3        #
    { 13 | H_JUNGSUNG, 0x24 },                    //  52, 0x34: VK_4        $
    { 18 | H_JUNGSUNG, 0x25 },                    //  53, 0x35: VK_5        %
    {  3 | H_JUNGSUNG, 0x5E },                    //  54, 0x36: VK_6        ^
    {  8 | H_JUNGSUNG, 0x26 },                    //  55, 0x37: VK_7        &
    { 20 | H_JUNGSUNG, 0x2A },                    //  56, 0x38: VK_8        *
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 21 | H_JONGSUNG,  7 | H_JONGSUNG},    //  65, 0x41: VK_A        
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x21 },    //  66, 0x42: VK_B        !
    {  6 | H_JUNGSUNG, 10 | H_JONGSUNG},    //  67, 0x43: VK_C        
    { 21 | H_JUNGSUNG,  9 | H_JONGSUNG},    //  68, 0x44: VK_D        
    {  7 | H_JUNGSUNG, 24 | H_JONGSUNG},    //  69, 0x45: VK_E        
    {  1 | H_JUNGSUNG,  2 | H_JONGSUNG},    //  70, 0x46: VK_F        
    { 19 | H_JUNGSUNG | H_DOUBLE, 0x2F },    //  71, 0x47: VK_G        /
    {  3 | H_CHOSUNG, 0x27 },                //  72, 0x48: VK_H        ,
    {  7 | H_CHOSUNG, 0x38 },                //  73, 0x49: VK_I        8
    { 12 | H_CHOSUNG, 0x34 },                //  74, 0x4A: VK_J        4
    {  1 | H_CHOSUNG | H_DOUBLE, 0x35 },    //  75, 0x4B: VK_K        5
    { 13 | H_CHOSUNG | H_DOUBLE, 0x36 },    //  76, 0x4C: VK_L        6
    { 19 | H_CHOSUNG, 0x31 },        //  77, 0x4D: VK_M        1
    { 10 | H_CHOSUNG | H_DOUBLE, 0x30 },    //  78, 0x4E: VK_N        0
    { 15 | H_CHOSUNG, 0x39 },                //  79, 0x4F: VK_O        9
    { 18 | H_CHOSUNG, 0x3E },                //  80, 0x50: VK_P        >
    { 19 | H_JONGSUNG | H_DOUBLE,  26 | H_JONGSUNG},    //  81, 0x51: VK_Q        
    {  2 | H_JUNGSUNG, 4 | H_JUNGSUNG},                    //  82, 0x52: VK_R        
    {  4 | H_JONGSUNG | H_DOUBLE,  6 | H_JONGSUNG},        //  83, 0x53: VK_S        
    {  5 | H_JUNGSUNG, 0x3B },                            //  84, 0x54: VK_T        ;
    {  4 | H_CHOSUNG | H_DOUBLE, 0x37 },                //  85, 0x55: VK_U        7
    {  9 | H_JUNGSUNG | H_DOUBLE, 15 | H_JONGSUNG },    //  86, 0x56: VK_V        
    {  8 | H_JONGSUNG | H_DOUBLE, 25 | H_JONGSUNG},        //  87, 0x57: VK_W        
    {  1 | H_JONGSUNG | H_DOUBLE, 18 | H_JONGSUNG },    //  88, 0x58: VK_X        
    {  6 | H_CHOSUNG, 0x3C },                            //  89, 0x59: VK_Y        <
    { 16 | H_JONGSUNG,  23 | H_JONGSUNG },                //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    {  8 | H_CHOSUNG | H_DOUBLE, 0x3A },    // 186, 0xBA:        :
    { 0x3D, 0x2B },                            // 187, 0xBB:
    { 0x2C, 0x32 },                            // 188, 0xBC:    ,    2
    { 0x2D, 0x5F },                            // 189, 0xBD:
    { 0x2E, 0x33 },                            // 190, 0xBE:    .    3
    {  9 | H_JUNGSUNG | H_DOUBLE, 0x3F },    // 191, 0xBF:        ?
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:    [    {
    { 0x5C, 0x7C }, // 220, 0xDC:    \    |
    { 0x5D, 0x7D }, // 221, 0xDD:    ]    }
    { 17 | H_CHOSUNG, 0x22 }, // 222, 0xDE:        "
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

WORD  CHangulAutomata3Final::wHTable[256][2] =
{
    // 3 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 16 | H_CHOSUNG, 0x7E },                    //  48, 0x30: VK_0        ~
    { 27 | H_JONGSUNG,  2 | H_JONGSUNG },        //  49, 0x31: VK_1        
    { 20 | H_JONGSUNG,  9 | H_JONGSUNG },        //  50, 0x32: VK_2         
    { 17 | H_JONGSUNG|H_DOUBLE, 22 | H_JONGSUNG },    //  51, 0x33: VK_3        
    { 13 | H_JUNGSUNG, 14 | H_JONGSUNG },            //  52, 0x34: VK_4        
    { 18 | H_JUNGSUNG, 13 | H_JONGSUNG },            //  53, 0x35: VK_5        
    {  3 | H_JUNGSUNG, 0x3D },                    //  54, 0x36: VK_6        =
    {  8 | H_JUNGSUNG, 0x22 },                    //  55, 0x37: VK_7        "
    { 20 | H_JUNGSUNG, 0x22 },                    //  56, 0x38: VK_8        "
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x27 },        //  57, 0x39: VK_9  '
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 21 | H_JONGSUNG,  7 | H_JONGSUNG},    //  65, 0x41: VK_A        
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x3F },    //  66, 0x42: VK_B        ?
    {  6 | H_JUNGSUNG, 24 | H_JONGSUNG},    //  67, 0x43: VK_C        
    { 21 | H_JUNGSUNG, 11 | H_JONGSUNG},    //  68, 0x44: VK_D        
    {  7 | H_JUNGSUNG,  5 | H_JONGSUNG},    //  69, 0x45: VK_E        
    {  1 | H_JUNGSUNG, 10 | H_JONGSUNG},    //  70, 0x46: VK_F        
    { 19 | H_JUNGSUNG | H_DOUBLE, 4 | H_JUNGSUNG },    //  71, 0x47: VK_G        
    {  3 | H_CHOSUNG, 0x30 },                //  72, 0x48: VK_H        0
    {  7 | H_CHOSUNG, 0x37 },                //  73, 0x49: VK_I        7
    { 12 | H_CHOSUNG, 0x31 },                //  74, 0x4A: VK_J        1
    {  1 | H_CHOSUNG | H_DOUBLE, 0x32 },    //  75, 0x4B: VK_K        2
    { 13 | H_CHOSUNG | H_DOUBLE, 0x33 },    //  76, 0x4C: VK_L        3
    { 19 | H_CHOSUNG, 0x22},                //  77, 0x4D: VK_M        "
    { 10 | H_CHOSUNG | H_DOUBLE, 0x2D },    //  78, 0x4E: VK_N        -
    { 15 | H_CHOSUNG, 0x38 },                //  79, 0x4F: VK_O        8
    { 18 | H_CHOSUNG, 0x39 },                //  80, 0x50: VK_P        9
    { 19 | H_JONGSUNG | H_DOUBLE,  26 | H_JONGSUNG},    //  81, 0x51: VK_Q        
    {  2 | H_JUNGSUNG, 15 | H_JONGSUNG},                //  82, 0x52: VK_R        
    {  4 | H_JONGSUNG | H_DOUBLE,  6 | H_JONGSUNG},        //  83, 0x53: VK_S        
    {  5 | H_JUNGSUNG, 12 | H_JONGSUNG },                            //  84, 0x54: VK_T        
    {  4 | H_CHOSUNG | H_DOUBLE, 0x36 },                //  85, 0x55: VK_U        6
    {  9 | H_JUNGSUNG | H_DOUBLE,  3 | H_JONGSUNG },    //  86, 0x56: VK_V        
    {  8 | H_JONGSUNG | H_DOUBLE, 25 | H_JONGSUNG},        //  87, 0x57: VK_W        
    {  1 | H_JONGSUNG | H_DOUBLE, 18 | H_JONGSUNG },    //  88, 0x58: VK_X        
    {  6 | H_CHOSUNG, 0x35 },                            //  89, 0x59: VK_Y        5
    { 16 | H_JONGSUNG,  23 | H_JONGSUNG },                //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    {  8 | H_CHOSUNG | H_DOUBLE, 0x34 },    // 186, 0xBA:        4
    { 0x3E, 0x2B },                            // 187, 0xBB:    >    +
    { 0x2C, 0x2C },                            // 188, 0xBC:    ,    ,
    { 0x29, 0x3B },                            // 189, 0xBD:    )    ;
    { 0x2E, 0x2E },                            // 190, 0xBE:    .    .
    {  9 | H_JUNGSUNG | H_DOUBLE, 0x21 },    // 191, 0xBF:        !
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x28, 0x25 }, // 219, 0xDB:    (    %
    { 0x3A, 0x5C }, // 220, 0xDC:    :    '\'
    { 0x3C, 0x2F }, // 221, 0xDD:    <    /
    { 17 | H_CHOSUNG, 0x00 }, // 222, 0xDE:    
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

const 
BYTE  CHangulAutomata::bETable[256][2] =
{
    // English normal, English shift for Junja(Full shape) mode
    { 0x00, 0x00 }, //   0, 0x00: 
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 0x30, 0x29 }, //  48, 0x30: VK_0
    { 0x31, 0x21 }, //  49, 0x31: VK_1
    { 0x32, 0x40 }, //  50, 0x32: VK_2
    { 0x33, 0x23 }, //  51, 0x33: VK_3
    { 0x34, 0x24 }, //  52, 0x34: VK_4
    { 0x35, 0x25 }, //  53, 0x35: VK_5
    { 0x36, 0x5E }, //  54, 0x36: VK_6
    { 0x37, 0x26 }, //  55, 0x37: VK_7
    { 0x38, 0x2A }, //  56, 0x38: VK_8
    { 0x39, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 0x61, 0x41 }, //  65, 0x41: VK_A
    { 0x62, 0x42 }, //  66, 0x42: VK_B
    { 0x63, 0x43 }, //  67, 0x43: VK_C
    { 0x64, 0x44 }, //  68, 0x44: VK_D
    { 0x65, 0x45 }, //  69, 0x45: VK_E
    { 0x66, 0x46 }, //  70, 0x46: VK_F
    { 0x67, 0x47 }, //  71, 0x47: VK_G
    { 0x68, 0x48 }, //  72, 0x48: VK_H
    { 0x69, 0x49 }, //  73, 0x49: VK_I
    { 0x6A, 0x4A }, //  74, 0x4A: VK_J
    { 0x6B, 0x4B }, //  75, 0x4B: VK_K
    { 0x6C, 0x4C }, //  76, 0x4C: VK_L
    { 0x6D, 0x4D }, //  77, 0x4D: VK_M
    { 0x6E, 0x4E }, //  78, 0x4E: VK_N
    { 0x6F, 0x4F }, //  79, 0x4F: VK_O
    { 0x70, 0x50 }, //  80, 0x50: VK_P
    { 0x71, 0x51 }, //  81, 0x51: VK_Q
    { 0x72, 0x52 }, //  82, 0x52: VK_R
    { 0x73, 0x53 }, //  83, 0x53: VK_S
    { 0x74, 0x54 }, //  84, 0x54: VK_T
    { 0x75, 0x55 }, //  85, 0x55: VK_U
    { 0x76, 0x56 }, //  86, 0x56: VK_V
    { 0x77, 0x57 }, //  87, 0x57: VK_W
    { 0x78, 0x58 }, //  88, 0x58: VK_X
    { 0x79, 0x59 }, //  89, 0x59: VK_Y
    { 0x7A, 0x5A }, //  90, 0x5A: VK_Z
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    { 0x3B, 0x3A }, // 186, 0xBA:
    { 0x3D, 0x2B }, // 187, 0xBB:
    { 0x2C, 0x3C }, // 188, 0xBC:
    { 0x2D, 0x5F }, // 189, 0xBD:
    { 0x2E, 0x3E }, // 190, 0xBE:
    { 0x2F, 0x3F }, // 191, 0xBF:
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:
    { 0x5C, 0x7C }, // 220, 0xDC:
    { 0x5D, 0x7D }, // 221, 0xDD:
    { 0x27, 0x22 }, // 222, 0xDE:
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};


static 
WORD Int2UniCho[NUM_OF_CHOSUNG+1] = 
    {
    0,    // fill [0]
    UNICODE_HANGUL_COMP_JAMO_START + 0,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 1,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 3,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 6,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 7,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 8,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 16,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 17,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 18,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 20,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 21,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 22,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 23,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 24,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 25,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 26,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 27,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 28,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 29,    // 
    };

static 
WORD Int2UniJong[NUM_OF_JONGSUNG] = 
    {
    0,    // fill [0]
    UNICODE_HANGUL_COMP_JAMO_START + 0,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 1,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 2,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 3,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 4,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 5,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 6,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 8,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 9,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 10,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 11,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 12,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 13,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 14,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 15,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 16,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 17,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 19,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 20,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 21,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 22,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 23,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 25,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 26,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 27,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 28,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 29,    // 
    };

// Compatibility Jamo Consonant map
static
BYTE CompJamoMapTable[30][2] =
    {
        // Jamo code , Jongsung Flag : Only if it can't be chosung then make it jongsung
        { _KIYEOK_,                0 },
        { _SSANGKIYEOK_,        0 },
        { _JONG_KIYEOK_SIOS,    1 },
        { _NIEUN_,                0 },
        { _JONG_NIEUN_CHIEUCH_, 1 },
        { _JONG_NIEUN_HIEUH_,    1 },
        { _TIKEUT_,                0 },    
        { _SSANGTIKEUT_,        0 },
        { _RIEUL_,                0 },
        { _JONG_RIEUL_KIYEOK_,    1 },
        { _JONG_RIEUL_MIUM_,    1 },
        { _JONG_RIEUL_PIEUP_,    1 },
        { _JONG_RIEUL_SIOS_,    1 },
        { _JONG_RIEUL_THIEUTH_,    1 },
        { _JONG_RIEUL_PHIEUPH_,    1 },
        { _JONG_RIEUL_HIEUH_,    1 },
        { _MIEUM_,                0 },
        { _PIEUP_,                0 },
        { _SSANGPIEUP_,            0 },
        { _JONG_PIEUP_SIOS,        1 },
        { _SIOS_,                0 }, 
        { _SSANGSIOS_,            0 }, 
        { _IEUNG_,                0 },    
        { _CIEUC_,                0 },
        { _SSANGCIEUC_,            0 },
        { _CHIEUCH_,            0 },
        { _KHIEUKH_,            0 },
        { _THIEUTH_,            0 },
        { _PHIEUPH_,            0 },
        { _HIEUH_,                0 },
    };


static
BYTE JongSungSep[NUM_OF_JONGSUNG][2] =
    {
        {    0,    0    },
        { _JONG_KIYEOK_,            0        },    //_JONG_KIYEOK_        
        { _JONG_SSANGKIYEOK_,        0        },    //_JONG_SSANGKIYEOK_    
        { _JONG_KIYEOK_,    _JONG_SIOS_        },    //_JONG_KIYEOK_SIOS    
        { _JONG_NIEUN_,                0        },    //_JONG_NIEUN_        
        { _JONG_NIEUN_,        _JONG_CIEUC_    },    //_JONG_NIEUN_CIEUC_
        { _JONG_NIEUN_,        _JONG_HIEUH_    },    //_JONG_NIEUN_HIEUH_    
        { _JONG_TIKEUT_,            0        },    //_JONG_TIKEUT_        
        { _JONG_RIEUL_,                0        },    //_JONG_RIEUL_        
        { _JONG_RIEUL_,        _JONG_KIYEOK_    },    //_JONG_RIEUL_KIYEOK_
        { _JONG_RIEUL_,        _JONG_MIEUM_    },    //_JONG_RIEUL_MIUM_        
        { _JONG_RIEUL_,        _JONG_PIEUP_    },    //_JONG_RIEUL_PIEUP_
        { _JONG_RIEUL_,        _JONG_SIOS_        },    //_JONG_RIEUL_SIOS_    
        { _JONG_RIEUL_,        _JONG_THIEUTH_    },    //_JONG_RIEUL_THIEUTH_
        { _JONG_RIEUL_,        _JONG_PHIEUPH_    },    //_JONG_RIEUL_PHIEUPH_    
        { _JONG_RIEUL_,        _JONG_HIEUH_    },    //_JONG_RIEUL_HIEUH_
        { _JONG_MIEUM_,                0        },    //_JONG_MIEUM_        
        { _JONG_PIEUP_,                0        },    //_JONG_PIEUP_        
        { _JONG_PIEUP_,        _JONG_SIOS_        },    //_JONG_PIEUP_SIOS
        { _JONG_SIOS_,                0        },    //_JONG_SIOS_        
        { _JONG_SSANGSIOS_,            0        },    //_JONG_SSANGSIOS_    
        { _JONG_IEUNG_,                0        },    //_JONG_IEUNG_            
        { _JONG_CIEUC_,                0        },    //_JONG_CIEUC_            
        { _JONG_CHIEUCH_,            0        },    //_JONG_CHIEUCH_
        { _JONG_KHIEUKH_,            0        },    //_JONG_KHIEUKH_    
        { _JONG_THIEUTH_,            0        },    //_JONG_THIEUTH_    
        { _JONG_PHIEUPH_,            0        },    //_JONG_PHIEUPH_
        { _JONG_HIEUH_,                0        }    //_JONG_HIEUH_    
    };

static
BYTE JungSungSep[NUM_OF_JUNGSUNG+1][2] =
    {
        {    0,    0    },
        { _A_,                    0    },    // _A_,    
        { _AE_,                    0    },    //_AE_,    
        { _YA_,                    0    },    //_YA_,    
        { _YAE_,                0    },    //_YAE_,
        { _EO_,                    0    },    //_EO_,    
        { _E_,                    0    },    //_E_,    
        { _YEO_,                0    },    //_YEO_,
        { _YE_,                    0    },    //_YE_,    
        { _O_,                    0    },    //_O_,    
        { _O_,                _A_        },    //_WA_,    
        { _O_,                _AE_    },    //_WAE_,
        { _O_,                _I_        },    //_OE_,    
        { _YO_,                    0    },    //_YO_,    
        { _U_,                    0    },    //_U_,    
        { _U_,                _EO_    },    //_WEO_,
        { _U_,                _E_        },    //_WE_,    
        { _U_,                _I_        },    //_WI_,    
        { _YU_,                    0    },    //_YU_,    
        { _EU_,                    0    },    //_EU_,    
        { _EU_,                _I_        },    //_YI_,    
        { _I_,                    0    }    //_I_,    
    };
#pragma data_seg()
// ====-- SHARED SECTION END --====

///////////////////////////////////////////////////////////////////////////////
// CHangulAutomata class member function
BOOL CHangulAutomata::MakeComplete()
{
    if (m_wcComposition) 
        {
        m_wcComplete = m_wcComposition;
        
        // clear composition char
        m_wcComposition = 0;
        
        // Init interim stack
        InterimStack.Init();
        m_Chosung = m_Jungsung = m_Jongsung = 0;
        
        // Init state
        m_CurState = 0;
        return fTrue;
        }
    else
        return fFalse;
}

// Complete used when takeover occurs
BOOL CHangulAutomata::MakeComplete(WORD wcComplete)
{
    if (wcComplete) 
        {
        m_wcComplete = wcComplete;
        // clear composition char
        m_wcComposition = 0;
        // Init interim stack
        InterimStack.Init();
        m_Jungsung = m_Jongsung = 0;
        return fTrue;
        }
    else
        return fFalse;
}

void CHangulAutomata::MakeComposition()
{
    DbgAssert(m_Chosung || m_Jungsung || m_Jongsung);
    // if Hangul
    if (m_Chosung && m_Jungsung) 
        {
        m_wcComposition = UNICODE_HANGUL_BASE 
                            + (m_Chosung-1) * NUM_OF_JUNGSUNG * (NUM_OF_JONGSUNG)    // +1 : jongsung fill
                            + (m_Jungsung-1) * (NUM_OF_JONGSUNG)
                            + m_Jongsung;
        }
    else // Hangul jamo
         // Currently map to compatiblity area. This should be changed if jamo glyphs available.
        {
            if (m_Chosung)
                m_wcComposition = Int2UniCho[m_Chosung];
            else
                if (m_Jungsung)
                    m_wcComposition = UNICODE_HANGUL_COMP_JAMO_START + 30 + m_Jungsung-1;
                    else 
                    if (m_Jongsung)
                        m_wcComposition = Int2UniJong[m_Jongsung];
        }
    // Push to interim stack
    InterimStack.Push(m_wInternalCode, m_CurState, m_Chosung, m_Jungsung, m_Jongsung, 
                      m_wcComposition);
    Dbg(DBGID_Automata, TEXT("CHangulAutomata::MakeComposition(), m_CurState=%d, m_Chosung=%d, m_Jungsung=%d, m_Jongsung=%d, m_wcComposition = 0x%04X"), m_CurState,  m_Chosung, m_Jungsung, m_Jongsung, m_wcComposition);
    //
}

WORD CHangulAutomata::FindChosungComb(WORD wPrevCode)
{
    // Combination table for double chosung. (only for 3beolsik)
    static BYTE  rgbDChoTbl[NUM_OF_DOUBLE_CHOSUNG][3] = 
        {
            {  1,  1,  2 }, {  4,  4,  5 },        //   -> ,   -> 
            {  8,  8,  9 }, { 10, 10, 11 },        //   -> ,   -> 
            { 13, 13, 14 }                        //   -> 
        };

    BYTE (*pDbl)[3] = rgbDChoTbl;    // pointer a little bit faster than array access.
    int i = NUM_OF_DOUBLE_CHOSUNG;
    WORD wCurCode = m_wInternalCode & 0xFF;

    for (; i>0; i--, pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] == wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

WORD CHangulAutomata::FindJunsungComb(WORD wPrevCode)
{
    // Combination table for double jungsung.
    static BYTE  rgbDJungTbl[NUM_OF_DOUBLE_JUNGSUNG][3] = 
        {
            {  9,  1, 10 }, {  9,  2, 11 },        //   -> ,   -> 
            {  9, 21, 12 }, { 14,  5, 15 },        //   -> ,   -> 
            { 14,  6, 16 }, { 14, 21, 17 },        //   -> ,   -> 
            { 19, 21, 20 }                        //   -> 
        };
    BYTE (*pDbl)[3] = rgbDJungTbl;
    int i = NUM_OF_DOUBLE_JUNGSUNG;
    WORD wCurCode = m_wInternalCode & 0xFF;
    
    for (; i>0; i--, pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] == wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}


WORD CHangulAutomata2::FindJonsungComb(WORD wPrevCode)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    wPrevCode = Cho2Jong[wPrevCode];
    WORD wCurCode = Cho2Jong[m_wInternalCode & 0xFF];
    
    for (; (*pDbl)[0]; pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] ==  wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

WORD CHangulAutomata3::FindJonsungComb(WORD wPrevCode)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    // 3BeolSik internal code have Jongsung code
    WORD wCurCode = m_wInternalCode & 0xFF;
    
    for (; (*pDbl)[0]; pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] ==  wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

BOOL CHangulAutomata::BackSpace()
{
    InterimStackEntry*    pInterimEntry;

    if (InterimStack.IsEmpty())
        return fFalse;
    else 
        {
        InterimStack.Pop();
        if (!InterimStack.IsEmpty()) 
            {
            pInterimEntry = InterimStack.GetTop();
            m_wcComposition = pInterimEntry->m_wcCode;
            m_CurState = pInterimEntry->m_CurState;
            m_Chosung = pInterimEntry->m_Chosung;
            m_Jungsung = pInterimEntry->m_Jungsung;
            m_Jongsung = pInterimEntry->m_Jongsung;
            }
        else
            InitState();
        return fTrue;
        }    
}

void CHangulAutomata::SeparateDJung(LPWORD pJungSung)
{
    WORD wJungSung = pJungSung[0];
    pJungSung[0] = JungSungSep[wJungSung][0];
    pJungSung[1] = JungSungSep[wJungSung][1];
}

void CHangulAutomata::SeparateDJong(LPWORD pJongSung)
{
    WORD wJongSung = pJongSung[0];
    pJongSung[0] = JongSungSep[wJongSung][0];
    pJongSung[1] = JongSungSep[wJongSung][1];
}


///////////////////////////////////////////////////////////////////////////////
//
// Assume : Input wcComp has valid Unicode Hangul value
// (wcComp>0x3130 && wcComp<0x3164) || (wcComp>=0xAC00 && wcComp<0xD7A4)) 
//
BOOL CHangulAutomata2::SetCompositionChar(WCHAR wcComp)
{
    WORD wUnicodeHangulOffset;
    WORD wChosung;
    WORD wJungsung[2], wJongsung[2];

    Dbg(DBGID_SetComp, TEXT("CHangulAutomata2::SetCompositionChar: wcComp = %c(0x%X)"), wcComp, wcComp), 

    InitState();

    wChosung = wJungsung[0] = wJungsung[1] = wJongsung[0] = wJongsung[1] = 0;

    if (wcComp <= UNICODE_HANGUL_COMP_JAMO_END && wcComp >= UNICODE_HANGUL_COMP_JAMO_START) 
        {
        Dbg(DBGID_SetComp, TEXT("COMP_JAMO"));
        // Consonant or vowel ?
        if (wcComp < UNICODE_HANGUL_COMP_JAMO_VOWEL_START) 
            {
            wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_COMP_JAMO_START);
            // Jongsung or Chosung ?
            if (CompJamoMapTable[wUnicodeHangulOffset][1]) 
                {
                wJongsung[0] = CompJamoMapTable[wUnicodeHangulOffset][0];
                SeparateDJong(wJongsung);
                Dbg(DBGID_Automata, TEXT("SetCompositionChar() : wJongsung[0]=%04x, wJongsung[1]=%04x"), wJongsung[0], wJongsung[1]);
                }
            else 
                wChosung = CompJamoMapTable[wUnicodeHangulOffset][0];

            }
        else 
            {
            wJungsung[0] = wcComp - UNICODE_HANGUL_COMP_JAMO_VOWEL_START + 1;
            SeparateDJung(wJungsung);
            }
        } 
    else 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_BASE);
        wChosung = (WORD)( wUnicodeHangulOffset / 
                                    (NUM_OF_JONGSUNG*NUM_OF_JUNGSUNG)) + 1;    // +1 to skip fill code

        wJungsung[0] = (WORD)(wUnicodeHangulOffset / NUM_OF_JONGSUNG
                                                        % NUM_OF_JUNGSUNG) + 1;
        SeparateDJung(wJungsung);

        wJongsung[0] = (WORD)(wUnicodeHangulOffset % NUM_OF_JONGSUNG);    // jongsung already has fill code
        SeparateDJong(wJongsung);
        }

    ///////////////////////////////////////////////////////////////////////////
    // Push process
    if (wChosung) 
        {
        m_Chosung = m_wInternalCode = wChosung;
        m_CurState = 1; // Chosung state
        MakeComposition();
        }

    if (wJungsung[0]) 
        {
        m_Jungsung = m_wInternalCode  = wJungsung[0];
        if (m_Jungsung == _O_ || m_Jungsung == _U_ || m_Jungsung == _EU_) 
            m_CurState = 3; // Double Jungsung possible state
        else
            m_CurState = 2; // Single Jungsung state
        MakeComposition();
        }

    if (wJungsung[1]) 
        {
        DbgAssert(wJungsung[0] == _O_ || wJungsung[0] == _U_ || wJungsung[0] == _EU_);
        m_wInternalCode = wJungsung[1];
        m_Jungsung = FindJunsungComb(wJungsung[0]);
        DbgAssert(m_Jungsung);
        m_CurState = 2; // Jungsung state
        MakeComposition();
        }

    //
    if (wJongsung[0]) 
        {
        m_wInternalCode  = Jong2Cho[wJongsung[0]];
        m_Jongsung = wJongsung[0];

        // KiYeok, Nieun, Rieul and Pieup: Double jongsong possible chars.
        if (m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_)
            m_CurState = 5; // Double Jongsung possible state
        else
            m_CurState = 4; // Single Jongsung state
        MakeComposition();
        }

    if (wJongsung[1]) 
        {
        DbgAssert(m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
                || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_);
        m_wInternalCode = Jong2Cho[wJongsung[1]];
        m_Jongsung = FindJonsungComb(Jong2Cho[wJongsung[0]]);

        DbgAssert(m_Jongsung);
        m_CurState = 4; // Jongsung state
        MakeComposition();
        }
    return fTrue;
}



///////////////////////////////////////////////////////////////////////////////
//    Transition table of 2beolsik hangul automata
const WORD CHangulAutomata2::m_NextStateTbl[8][5] = 
    {
        /////////////////////////////////////////////////////
        //    Sa        Va            Sb        Vb            Sc            State
        {     1,         6,             1,         7,            1        },    // 0 : Start
        {    FIND,     2,            FIND,     3,            FINAL    },    // 1 : Chosung
        {     4,        FINAL,         5,        FINAL,        FINAL    },    // 2 : Single Jungsung
        {     4,        FIND,         5,        FINAL,        FINAL    },    // 3 : Double Jungsung possible
        {    FINAL,    TAKEOVER,    FINAL,    TAKEOVER,    FINAL    },    // 4 : Single Jongsung
        {    FIND,    TAKEOVER,    FIND,    TAKEOVER,    FINAL    },    // 5 : Double Jongsung possible
        {    FINAL,    FINAL,        FINAL,    FINAL,        FINAL    },    // 6 : Single Jungsung(without chosung)
        {    FINAL,    FIND,        FINAL,    FINAL,        FINAL    }    // 7 : Double Jungsung possible(without chosung)
    };
///////////////////////////////////////////////////////////////////////////////

HAutomataReturnState CHangulAutomata2::Input(WORD InternalCode)
{
    WORD wSymbol, wFind;
    InterimStackEntry*    pPrevInterim;

    // Check if hangul key
    if ( !(InternalCode & H_HANGUL) )
        return HAUTO_NONHANGULKEY;    // This keycode need not handled in automata.
                                    // Calling function should handle it properly.

    // Copy internal code to member data
    m_wInternalCode = InternalCode;
    wSymbol = (m_wInternalCode >> 8) & 0x7F;
    m_NextState = m_NextStateTbl[m_CurState][wSymbol];

    switch (m_NextState) 
        {
        // Chosung
        case 1 :    m_Chosung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jungsung
        case 2 : case 3 : case 6 : case 7 :
                    m_Jungsung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jongsung
        case 4 : case 5 :
                    m_Jongsung = Cho2Jong[m_wInternalCode & 0xFF];
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;

        case FINAL :
                    MakeComplete();
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case TAKEOVER :
                    pPrevInterim = InterimStack.Pop();
                    m_Chosung = pPrevInterim->m_wInternalCode & 0xFF;
                    pPrevInterim = InterimStack.Pop();
                    MakeComplete(pPrevInterim->m_wcCode);
                    m_CurState = 1;
                    // FIXED : should call MakeComposition() to push interim state
                    MakeComposition();    
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case FIND :
            switch (m_CurState) 
            {
            case 7 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jungsung = wFind;
                        m_CurState = 6;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else 
                        { 
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            
            case 3 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jungsung = wFind;
                        m_CurState = 2;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else 
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            
            case 5 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jongsung = wFind;
                        m_CurState = 4;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else  
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;

            // Only DJongsung case. same as case 5 except clearing chosung
            case 1: 
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Chosung = 0;
                        m_Jongsung = wFind;
                        m_CurState = 4;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else  
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            }
        }
    // impossible
    DbgAssert(0);
    return HAUTO_IMPOSSIBLE;
}


///////////////////////////////////////////////////////////////////////////////
//    Transition table of 3 beolsik 390 hangul automata
const WORD CHangulAutomata3::m_NextStateTbl[11][6] = 
    {
        ////////////////////////////////////////////////////////////
        //    Sa        Sb        Va            Vb            Sc        Sd            State
        {     1,         2,        7,             8,             9,         10        },    // 0 : Start
        {    FINAL,    FINAL,    3,             4,            FINAL,    FINAL    },    // 1 : Chosung
        {    FINAL,    FIND,    3,             4,            FINAL,    FINAL    },    // 2 : Double Chosung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,         5,         6        },    // 3 : Jungsung
        {    FINAL,    FINAL,    FIND,        FINAL,         5,         6        },    // 4 : Double Jungsung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 5 : Jongsung
        {    FINAL,    FINAL,    FINAL,        FINAL,        FIND,    FIND    },    // 6 : Double Jongsung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 7 : Single Jungsung (without chosung)
        {    FINAL,    FINAL,    FIND,        FINAL,        FINAL,    FINAL    },    // 8 : Double Jungsung possible(without chosung)
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 9 : Single Jongsung(without chosung)
        {    FINAL,    FINAL,    FINAL,        FINAL,        FIND,    FIND    }    // 10 : Double Jongsung possible(without chosung)

    };
///////////////////////////////////////////////////////////////////////////////

HAutomataReturnState CHangulAutomata3::Input(WORD InternalCode)
{
    WORD wSymbol, wFind;
    InterimStackEntry*    pPrevInterim;

    // Check if hangul key
    if (!(InternalCode & H_HANGUL))
        return HAUTO_NONHANGULKEY;    // This keycode need not handled in automata.
                                    // Calling function should handle it properly.

    // Get internal code from keycode
    m_wInternalCode = InternalCode;
    wSymbol = (m_wInternalCode >> 8) & 0x7F;
    m_NextState = m_NextStateTbl[m_CurState][wSymbol];

    switch (m_NextState) 
        {
        // Chosung
        case 1 : case 2 :    
                    m_Chosung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jungsung
        case 3 : case 4 : case 7 : case 8 :
                    m_Jungsung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jongsung
        case 5 : case 6 : case 9 : case 10 :
                    m_Jongsung = m_wInternalCode & 0xFF;
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        case FINAL :
                    MakeComplete();
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case FIND :
            switch (m_CurState) 
            {
            case 8 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jungsung = wFind;
                        m_CurState = 7;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else 
                    { 
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 4 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jungsung = wFind;
                        m_CurState = 3;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else 
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 6 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jongsung = wFind;
                        m_CurState = 5;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 10 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jongsung = wFind;
                        m_CurState = 7;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;

            case 2 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindChosungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Chosung = wFind;
                        m_CurState = 1;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            }
        }

    // impossible
    DbgAssert(0);
    return HAUTO_IMPOSSIBLE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Assume : Input wcComp has valid Unicode Hangul value
// (wcComp>0x3130 && wcComp<0x3164) || (wcComp>=0xAC00 && wcComp<0xD7A4)) 
//
BOOL CHangulAutomata3::SetCompositionChar(WCHAR wcComp)
{
    WORD wUnicodeHangulOffset;
    WORD wChosung;
    WORD wJungsung[2], wJongsung[2];

    wChosung = wJungsung[0] = wJungsung[1] = wJongsung[0] = wJongsung[1] = 0;
    InitState();

    if (wcComp <= UNICODE_HANGUL_COMP_JAMO_END && wcComp >= UNICODE_HANGUL_COMP_JAMO_START) 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_COMP_JAMO_START);
        
        // Consonant or vowel ?
        if (wcComp < UNICODE_HANGUL_COMP_JAMO_VOWEL_START) 
            {
            // Jongsung or Chosung ?
            if (CompJamoMapTable[wUnicodeHangulOffset][1]) 
                {
                wJongsung[0] = CompJamoMapTable[wUnicodeHangulOffset][0];
                SeparateDJong(wJongsung);
                }
            else 
                wChosung = CompJamoMapTable[wUnicodeHangulOffset][0];

            }
        else 
            {
            wJungsung[0] = wcComp - UNICODE_HANGUL_COMP_JAMO_VOWEL_START + 1;
            SeparateDJung(wJungsung);
            }
        } 
    else 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_BASE);
        wChosung = (WORD)( wUnicodeHangulOffset / 
                                    (NUM_OF_JONGSUNG*NUM_OF_JUNGSUNG)) + 1;

        wJungsung[0] = (WORD)(wUnicodeHangulOffset / NUM_OF_JONGSUNG
                                                        % NUM_OF_JUNGSUNG) + 1;
        SeparateDJung(wJungsung);

        wJongsung[0] = (WORD)(wUnicodeHangulOffset % NUM_OF_JONGSUNG);
        SeparateDJong(wJongsung);
        }

    ///////////////////////////////////////////////////////////////////////////
    // Push process
    if (wChosung) 
        {
        m_Chosung = m_wInternalCode = wChosung;
        // KiYeok, TiKeut, Pieup, Sios, Cieuc
        if (m_Chosung == _KIYEOK_ || m_Chosung == _TIKEUT_ 
           || m_Chosung == _PIEUP_|| m_Chosung == _SIOS_ || m_Chosung == _CIEUC_)
            m_CurState = 2; // Double Chosung possible state
        else
            m_CurState = 1; // Chosung state
        MakeComposition();
        }

    if (wJungsung[0]) 
        {
        m_Jungsung = m_wInternalCode  = wJungsung[0];
        if (m_Jungsung == _O_ || m_Jungsung == _U_ || m_Jungsung == _EU_) 
            m_CurState = 4; // Double Jungsung possible state
        else
            m_CurState = 3; // Single Jungsung state
        MakeComposition();
        }

    if (wJungsung[1]) 
        {
        DbgAssert(wJungsung[0] == _O_|| wJungsung[0] == _U_ || wJungsung[0] == _EU_);
        m_wInternalCode = wJungsung[1];
        m_Jungsung = FindJunsungComb(wJungsung[0]);
        DbgAssert(m_Jungsung);
        m_CurState = 3; // Jungsung state
        MakeComposition();
        }

    //
    if (wJongsung[0]) 
        {
        m_wInternalCode  = wJongsung[0];
        m_Jongsung = wJongsung[0];
        // KiYeok, Nieun, Rieul, Pieup and Sios: Double jongsong possible chars.
        if (m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_ || m_Jongsung == _JONG_SIOS_)
            m_CurState = 6; // Double Jongsung possible state
        else
            m_CurState = 5; // Single Jongsung state
        MakeComposition();
        }

    if (wJongsung[1]) 
        {
        DbgAssert(m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_ || m_Jongsung == _JONG_SIOS_);

        m_wInternalCode = wJongsung[1];
        m_Jongsung = FindJonsungComb(wJongsung[0]);

        DbgAssert(m_Jongsung);
        m_CurState = 5; // Jongsung state
        MakeComposition();
        }
    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\hjmode.cpp ===
/****************************************************************************
   HJMODE.CPP : HJMode class managing Hanja button on the Cicero Toolbar

   History:
      25-FEB-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "hjmode.h"
#include "gdata.h"
#include "winex.h"
#include "resource.h"

// {F7410340-28E0-4aeb-ADBC-C579FD00B43D}
const GUID GUID_LBI_KORIME_HJMODE = 
{
    0xf7410340, 
    0x28e0, 
    0x4aeb,
    { 0xad, 0xbc, 0xc5, 0x79, 0xfd, 0x0, 0xb4, 0x3d }
};

/*---------------------------------------------------------------------------
    HJMode::HJMode
---------------------------------------------------------------------------*/
HJMode::HJMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    szText[0] = L'\0';
    
    m_pTb = ptb;

    // Set Add/Remove text and tootip text
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_TT_HANJA_CONV, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_SYSTEMLANGBARITEM_KEYBOARD, 
                GUID_LBI_KORIME_HJMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_TEXTCOLORICON, 
                220, 
                szText);
    SetToolTip(szText);

    // Set button text
    szText[0] = L'\0';
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_BUTTON_HANJA_CONV, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}



/*---------------------------------------------------------------------------
    HJMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) HJMode::Release()
{
    long cr;

    cr = --m_cRef;
    DbgAssert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    HJMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI HJMode::GetIcon(HICON *phIcon)
{
    UINT uiIcon;

    if (IsHighContrastBlack())
        uiIcon = IDI_CMODE_HANJAW;
    else
        uiIcon = IDI_CMODE_HANJA;

    *phIcon = (HICON)LoadImage(vpInstData->hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);

    return S_OK;
}

/*---------------------------------------------------------------------------
    HJMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI HJMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    HJMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI HJMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
    HJMode::OnLButtonUp
---------------------------------------------------------------------------*/
HRESULT HJMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    keybd_event(VK_HANJA, 0, 0, 0);
    keybd_event(VK_HANJA, 0, KEYEVENTF_KEYUP, 0);

    return S_OK;
}


/*---------------------------------------------------------------------------
    HJMode::OnRButtonUp
---------------------------------------------------------------------------*/
HRESULT HJMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
/*
    HMENU hMenu;
    DWORD dwConvMode;

    hMenu = CreatePopupMenu();
    char *pszStatus = (GetCMode() & TIP_JUNJA_MODE) ? "Banja mode" : "Junja mode";
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 1, pszStatus);
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 0, "Cancel");

    int nRet = TrackPopupMenuEx(hMenu, 
                         TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                         pt.x, pt.y, m_pTb->GetOwnerWnd(), NULL);
    switch (nRet)
    {
        case 1: 
            dwConvMode = GetCMode();

            // Toggle Full/Half mode
            if (dwConvMode & TIP_JUNJA_MODE)
                dwConvMode &= ~TIP_JUNJA_MODE;
            else
                dwConvMode |= TIP_JUNJA_MODE;

            SetCMode(dwConvMode);
            break;
    }

    DestroyMenu(hMenu);
*/
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\immsec.h ===
#if !defined (_IMMSEC_H__INCLUDED_)
#define _IMMSEC_H__INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif
PSECURITY_ATTRIBUTES CreateSecurityAttributes(VOID);
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa);
BOOL IsNT(VOID);
PSECURITY_ATTRIBUTES GetIMESecurityAttributes(VOID);
PSECURITY_ATTRIBUTES GetIMESecurityAttributesEx(VOID);
VOID FreeIMESecurityAttributes(VOID);
PSECURITY_ATTRIBUTES CreateSecurityAttributesEx(VOID);
PSID MyCreateSidEx(VOID);
#ifdef __cplusplus
}
#endif

#endif // !_IMMSEC_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\hauto.h ===
/****************************************************************************
	HAUTO.CPP

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Hangul composition state machine class
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (__HAUTOMATA_H__)
#define __HAUTOMATA_H__

#include "debug.h"

// Number of each component
#define NUM_OF_CHOSUNG  19
#define NUM_OF_JUNGSUNG 21
#define NUM_OF_JONGSUNG 28

#define NUM_OF_DOUBLE_CHOSUNG   5
#define NUM_OF_DOUBLE_JUNGSUNG  7
#define NUM_OF_DOUBLE_JONGSUNG_2BEOL 11
#define NUM_OF_DOUBLE_JONGSUNG_3BEOL 13

#define UNICODE_HANGUL_BASE					0xAC00
#define UNICODE_HANGUL_END					0xD7A3
#define UNICODE_HANGUL_COMP_JAMO_START		0x3131
#define UNICODE_HANGUL_COMP_JAMO_VOWEL_START		0x314F
#define UNICODE_HANGUL_COMP_JAMO_END		0x3163
#define UNICODE_HANGUL_COMP_JAMO_START_FILL	0x3130
#define UNICODE_HANGUL_COMP_JAMO_SIOT		0x3145

///////////////////////////////////////////
// HANGUL Jaso inernal difinitions
// ChoSung
#define _KIYEOK_			1		// ''	
#define _SSANGKIYEOK_		2		// ''
#define _NIEUN_				3		// ''
#define _TIKEUT_			4		// ''
#define _SSANGTIKEUT_		5		// ''
#define _RIEUL_				6		// ''
#define _MIEUM_				7		// ''
#define _PIEUP_				8		// ''
#define _SSANGPIEUP_		9		// ''
#define _SIOS_				10		// ''
#define _SSANGSIOS_			11		// ''
#define _IEUNG_				12		// ''
#define _CIEUC_				13		// ''
#define _SSANGCIEUC_		14		// ''
#define _CHIEUCH_			15		// ''
#define _KHIEUKH_			16		// ''
#define _THIEUTH_			17		// ''
#define _PHIEUPH_			18		// ''
#define _HIEUH_				19		// ''

// JungSung
#define _A_					1		// ''
#define _AE_				2		// ''
#define _YA_				3		// ''
#define _YAE_				4		// ''
#define _EO_				5		// ''
#define _E_					6		// ''
#define _YEO_				7		// ''
#define _YE_				8		// ''
#define _O_					9		// ''
#define _WA_				10		// ''
#define _WAE_				11		// ''
#define _OE_				12		// ''
#define _YO_				13		// ''
#define _U_					14		// ''
#define _WEO_				15		// ''
#define _WE_				16		// ''
#define _WI_				17		// ''
#define _YU_				18		// ''
#define _EU_				19		// ''
#define _YI_				20		// ''
#define _I_					21		// ''
////////////////////////////////////////

// JongSung
#define _JONG_KIYEOK_			1		// ''	
#define _JONG_SSANGKIYEOK_		2		// ''
#define _JONG_KIYEOK_SIOS		3
#define _JONG_NIEUN_			4		// ''
#define _JONG_NIEUN_CHIEUCH_	5		// ''
#define _JONG_NIEUN_HIEUH_		6		// ''
#define _JONG_TIKEUT_			7		// ''
#define _JONG_RIEUL_			8		// ''
#define _JONG_RIEUL_KIYEOK_		9		// ''
#define _JONG_RIEUL_MIUM_		10		// ''
#define _JONG_RIEUL_PIEUP_		11		// ''
#define _JONG_RIEUL_SIOS_		12		// ''
#define _JONG_RIEUL_THIEUTH_	13		// ''
#define _JONG_RIEUL_PHIEUPH_	14		// ''
#define _JONG_RIEUL_HIEUH_		15		// ''
#define _JONG_MIEUM_			16		// ''
#define _JONG_PIEUP_			17		// ''
#define _JONG_PIEUP_SIOS		18		// ''
#define _JONG_SIOS_				19		// ''
#define _JONG_SSANGSIOS_		20		// ''
#define _JONG_IEUNG_			21		// ''
#define _JONG_CIEUC_			22		// ''
#define _JONG_CHIEUCH_			23		// ''
#define _JONG_KHIEUKH_			24		// ''
#define _JONG_THIEUTH_			25		// ''
#define _JONG_PHIEUPH_			26		// ''
#define _JONG_HIEUH_			27		// ''
//
const int MaxInterimStackSize = 6;		// Maximum stack size is 6.
										// At most 6 key input
										// to complete one Hangul Char.
										// ex) (3 beolsik)
enum HAutomataReturnState 
	{ 
	  HAUTO_NONHANGULKEY,
	  HAUTO_COMPOSITION,	// Hagul still in interim state.
	  HAUTO_COMPLETE,		// One hangul char completed and have chars 
							// will takeover as next input.
	  HAUTO_IMPOSSIBLE
	};

const WORD H_HANGUL = 0x8000;

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata Abstract Class
//
class CHangulAutomata
	{
public:
	CHangulAutomata() {	InitState(); }

// Attributes
public:

// Operations
public:
	void InitState() 
		{ 
		m_CurState = m_NextState = 0;
		m_wInternalCode = 0;
		m_Chosung = m_Jungsung = m_Jongsung = 0;
		m_wcComposition = m_wcComplete = L'\0';
		InterimStack.Init();
		}
	virtual HAutomataReturnState Machine(UINT KeyCode, int iShift) = 0;
	virtual BOOL IsInputKey(UINT KeyCode, int iShift) = 0;
	virtual BOOL IsHangulKey(UINT KeyCode, int iShift) = 0;
	virtual WORD GetKeyMap(UINT KeyCode, int iShift) = 0;
	virtual BOOL SetCompositionChar(WCHAR wcComp) = 0;
	
	static WORD GetEnglishKeyMap(UINT KeyCode, int iShift) { return bETable[KeyCode][iShift]; }
	BOOL BackSpace();
	BOOL MakeComplete();
	WCHAR GetCompositionChar() { return m_wcComposition; }
	WCHAR GetCompleteChar() { return m_wcComplete; }

// Implementation
public:
	virtual ~CHangulAutomata() {}

protected:
	void MakeComposition();
	BOOL MakeComplete(WORD wcComplete);
	WORD FindChosungComb(WORD wPrevCode);
	WORD FindJunsungComb(WORD wPrevCode);
	virtual WORD FindJonsungComb(WORD wPrevCode) = 0;
	void SeparateDJung(LPWORD pJungSung);
	void SeparateDJong(LPWORD pJongSung);

	virtual HAutomataReturnState Input(WORD InternalCode) = 0;
	//
	struct InterimStackEntry 
		{
		WORD	m_wInternalCode;
		WORD	m_CurState;
		WORD	m_Chosung, m_Jungsung, m_Jongsung;
		WCHAR	m_wcCode;
		};

	///////////////////////////////////////////////////////////////////////////
	//
	class CInterimStack 
		{
	protected:
		InterimStackEntry	m_StackBuffer[MaxInterimStackSize];	
		int	m_sp;		// Stack pointer

	public:
		CInterimStack() { m_sp = 0; }
		~CInterimStack() {}
		void Init() { m_sp = 0; }
		void Push(InterimStackEntry& InterimEntry);
		void Push(WORD wInternalCode, WORD CurState, 
				  WORD Chosung, WORD Jungsung, WORD Jongsung, WCHAR wcCode);

		InterimStackEntry* CInterimStack::Pop() 
			{
			DbgAssert(m_sp > 0);
			return &m_StackBuffer[--m_sp];
			}

		InterimStackEntry* CInterimStack::GetTop() 
			{
			DbgAssert(m_sp > 0);
			return &m_StackBuffer[m_sp-1];
			}

		BOOL IsEmpty() { return m_sp == 0; }
		};
	///////////////////////////////////////////////////////////////////////////
	CInterimStack InterimStack;

protected:
	WORD	m_CurState, m_NextState;
	WORD	m_wInternalCode, m_Chosung, m_Jungsung, m_Jongsung;
	WCHAR	m_wcComposition;
	WCHAR	m_wcComplete;
	//
	const static BYTE  bETable[256][2];
	const static BYTE  Cho2Jong[NUM_OF_CHOSUNG+1];
	const static BYTE  Jong2Cho[NUM_OF_JONGSUNG];
	};

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata2 Keyboard layout #1 (2 beolsik)
//
class CHangulAutomata2 : public CHangulAutomata
{
public:
	CHangulAutomata2() { }

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift);
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift);
	WORD GetKeyMap(UINT KeyCode, int iShift);
	BOOL SetCompositionChar(WCHAR wcComp);
	
// Implementation
public:
	~CHangulAutomata2() { }

protected:
	WORD FindJonsungComb(WORD wPrevCode);
	HAutomataReturnState Input(WORD InternalCode);
		
protected:
	// This enum should be matched with m_NextState
	// DO NOT change without changing _Transistion_state !
	enum _Transistion_state { FINAL=8, TAKEOVER=9, FIND=10 };
	static const WORD m_NextStateTbl[8][5];
	static const WORD H_CONSONANT, H_VOWEL, H_DOUBLE, H_ONLYCHO;
	static WORD wHTable[256][2];
	static BYTE  rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_2BEOL+1][3];
};


/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata3 Keyboard layout #2 (3 beolsik)
class CHangulAutomata3 : public CHangulAutomata
{
public:
	CHangulAutomata3() {}

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift);
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift);
	WORD GetKeyMap(UINT KeyCode, int iShift);
	BOOL SetCompositionChar(WCHAR wcComp);

// Implementation
public:
	~CHangulAutomata3() { }

protected:
	WORD FindJonsungComb(WORD wPrevCode);
	HAutomataReturnState Input(WORD InternalCode);
	
protected:
	enum _Transistion_state { FINAL=11, FIND=12 };
	static const WORD m_NextStateTbl[11][6];
	static const WORD H_CHOSUNG, H_JUNGSUNG, H_JONGSUNG, H_DOUBLE;
	static WORD wHTable[256][2];
	static BYTE  rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_3BEOL+1][3];
};

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata3 Keyboard layout #3 (3 beolsik final)
class CHangulAutomata3Final : public CHangulAutomata3
{
public:
	CHangulAutomata3Final() {}

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift) ;
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift); 
	WORD GetKeyMap(UINT KeyCode, int iShift);

// Implementation
public:
	~CHangulAutomata3Final() { }

protected:
	static WORD wHTable[256][2];
};

///////////////////////////////////////////////////////////////////////////////
// Inline functions

inline
void CHangulAutomata::CInterimStack::Push(InterimStackEntry& InterimEntry) 
	{
	DbgAssert(m_sp<MaxInterimStackSize);
	m_StackBuffer[m_sp++] =  InterimEntry;
	}

inline
void CHangulAutomata::CInterimStack::Push(WORD wInternalCode, WORD CurState, 
				  WORD Chosung, WORD Jungsung, WORD Jongsung, WCHAR wcCode) 
	{
	DbgAssert(m_sp<=5);
	m_StackBuffer[m_sp].m_wInternalCode =  wInternalCode;
	m_StackBuffer[m_sp].m_CurState =  CurState;
	m_StackBuffer[m_sp].m_Chosung =  Chosung;
	m_StackBuffer[m_sp].m_Jungsung =  Jungsung;
	m_StackBuffer[m_sp].m_Jongsung =  Jongsung;
	m_StackBuffer[m_sp++].m_wcCode =  wcCode;
	}

// CHangulAutomata2
inline
HAutomataReturnState CHangulAutomata2::Machine(UINT KeyCode, int iShift) 
	{
	return (Input(wHTable[KeyCode][iShift]));
	}

inline
BOOL CHangulAutomata2::IsInputKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata2::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata2::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}


// CHangulAutomata3
inline
HAutomataReturnState CHangulAutomata3::Machine(UINT KeyCode, int iShift) 
	{
	DbgAssert(KeyCode<256);
	return (Input(wHTable[KeyCode][iShift]));
	}

inline
BOOL CHangulAutomata3::IsInputKey(UINT KeyCode, int iShift)
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata3::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata3::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return 0;
	}

// CHangulAutomata3Final
inline 
HAutomataReturnState CHangulAutomata3Final::Machine(UINT KeyCode, int iShift) 
	{
	DbgAssert(KeyCode<256);
	return (Input(wHTable[KeyCode][iShift]));
	}

inline 
BOOL CHangulAutomata3Final::IsInputKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata3Final::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata3Final::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return 0;
	}

#endif // !defined (__HAUTOMATA_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\imemisc.h ===
/****************************************************************************
	IMEMISC.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	MISC utility functions
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_IMEMISC_H__INCLUDED_)
#define _IMEMISC_H__INCLUDED_

extern POSVERSIONINFO GetVersionInfo();
// extern BOOL IsHydra(void); For future version

#endif // _IMEMISC_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\imedefs.h ===
/****************************************************************************
	IMEDEFS.CPP

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Structure and const Definition for various functions
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_IMEDEFS_H__INCLUDED_)
#define _IMEDEFS_H__INCLUDED_

#include "hauto.h"
#include "debug.h"
#include "ui.h"

///////////////////////////////////////////////////////////////////////////////
#define IME_AUTOMATA        0x30
#define IME_HANJAMODE       0x31

///////////////////////////////////////////////////////////////////////////////
// Configuration const related to registry values

//
#define MAX_NAME_LENGTH         32
#define CAND_PER_PAGE			9	// Candidate per page

///////////////////////////////////////////////////////////////////////////////
// Max number of hangul composition chars
const WORD nMaxCompStrLen	=	1;
const WORD nMaxResultStrLen	=	2;	// #59, #78 Max result str can be 2 char
									// Hangul+Alphanumeric


///////////////////////////////////////////////////////////////////////////////
// window extra for UI windows
#define UI_MOVE_OFFSET          0
#define UI_MOVE_XY              4
// if UI_MOVE_OFFSET == WINDOW_NOT_DRAG, not in drag operation
#define WINDOW_NOT_DRAG         -1

///////////////////////////////////////////////////////////////////////////////
// IME Message processing status bits
///////////////////////////////////////////////////////////////////////////////
#define ISC_OPEN_STATUS_WINDOW          0x04000000
#define ISC_SHOW_UI_ALL                 (ISC_SHOWUIALL| /*ISC_SHOW_SOFTKBD|*/ISC_OPEN_STATUS_WINDOW)
#define ISC_SETCONTEXT_UI               (ISC_SHOWUIALL /*|ISC_SHOW_SOFTKBD*/)
#if !defined(_WIN64)
#define MAX_NUM_OF_STATUS_BUTTONS	4
#else
#define MAX_NUM_OF_STATUS_BUTTONS	3
#endif
#define NUM_OF_BUTTON_SIZE			3

class CToolBar;

// IME private UI data
typedef struct tagUIPRIV 
{          
	HWND    hCompWnd;           // composition window
    INT     nShowCompCmd;

	// Status Window
    HWND    hStatusWnd; 
    INT     nShowStatusCmd;
	HWND	hStatusTTWnd;
	LPARAM	uiShowParam;
	
	// Candidate window
    HWND    hCandWnd;
    INT     nShowCandCmd;
	HWND	hCandTTWnd;

	// Cicero Toolbar object
	CToolBar *m_pCicToolbar;
} UIPRIV;

typedef UIPRIV      *PUIPRIV;
typedef UIPRIV		*LPUIPRIV;

///////////////////////////////////////////////////////////////////////////////
#if 1 // MultiMonitor support
typedef HMONITOR (WINAPI *LPFNMONITORFROMWINDOW)(HWND, DWORD);
typedef HMONITOR (WINAPI *LPFNMONITORFROMPOINT)(POINT, DWORD);
typedef HMONITOR (WINAPI *LPFNMONITORFROMRECT)(LPRECT, DWORD);
typedef BOOL     (WINAPI *LPFNGETMONITORINFO)(HMONITOR, LPMONITORINFO);

// definition in init.cpp
extern LPFNMONITORFROMWINDOW g_pfnMonitorFromWindow;
extern LPFNMONITORFROMPOINT  g_pfnMonitorFromPoint;
extern LPFNMONITORFROMRECT   g_pfnMonitorFromRect;
extern LPFNGETMONITORINFO    g_pfnGetMonitorInfo;
#endif

#endif // !defined (_IMEDEFS_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\immsys.cpp ===
/****************************************************************************
    IMMSYS.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Load/Unload IMM Apis dynamically not link with imm32.lib
    Inlcude Immdev.h and Indicml.h
    
    History:
    14-JUL-1999 cslim       Copied from KKIME2001 source tree
*****************************************************************************/

#ifndef UNDER_CE // Windows CE does not use private way.

/* -- IMMSYS support as following APIs --
    OurImmSetOpenStatus
    OurImmGetOpenStatus
    OurImmGetContext
    OurImmGetConversionStatus
    OurImmSetConversionStatus
    OurImmSetStatusWindowPos
    OurImmConfigureIMEA
    OurImmEscapeA
    OurImmNotifyIME
    OurImmLockIMCC
    OurImmReSizeIMCC
    OurImmUnlockIMCC
    OurImmGetIMCCSize
    OurImmGenerateMessage
    OurImmLockIMC
    OurImmUnlockIMC
//    OurImmRequestMessageW: Commented becuase used only by KK IME(Reconversion, document feed)
    OurImmGetDefaultIMEWnd
    OurImmGetIMEFileNameA
    OutImmIsIME()
----------------------------------------*/


#define LIBNAME    TEXT("imm32.dll")
#include "precomp.h"


typedef BOOL(WINAPI* FPOurImmSetOpenStatus)(HIMC hIMC, BOOL fOpen);
typedef BOOL(WINAPI* FPOurImmGetOpenStatus)(HIMC hIMC);
typedef HIMC(WINAPI* FPOurImmGetContext)(HWND hWnd);
typedef BOOL(WINAPI* FPOurImmGetConversionStatus)(HIMC hIMC, LPDWORD pdwConv, LPDWORD pdwSent);
typedef BOOL(WINAPI* FPOurImmSetConversionStatus)(HIMC hIMC, DWORD dwConv, DWORD dwSent);
typedef BOOL(WINAPI* FPOurImmSetStatusWindowPos)(HIMC hIMC, LPPOINT pPt);
typedef BOOL(WINAPI* FPOurImmConfigureIME)(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);
typedef LRESULT(WINAPI* FPOurImmEscapeA)(HKL hKL, HIMC hIMC, UINT ui, LPVOID pv);
typedef BOOL(WINAPI* FPOurImmNotifyIME)(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);
typedef LPVOID(WINAPI* FPOurImmLockIMCC)(HIMCC hIMCC);
typedef HIMCC(WINAPI* FPOurImmReSizeIMCC)(HIMCC hIMCC, DWORD dw);
typedef BOOL(WINAPI* FPOurImmUnlockIMCC)(HIMCC hIMCC);
typedef DWORD(WINAPI* FPOurImmGetIMCCSize)(HIMCC hIMCC);
typedef BOOL(WINAPI* FPOurImmGenerateMessage)(HIMC hIMC);
typedef LPINPUTCONTEXT(WINAPI* FPOurImmLockIMC)(HIMC hIMC);
typedef BOOL(WINAPI* FPOurImmUnlockIMC)(HIMC hIMC);
//typedef LRESULT(WINAPI* FPOurImmRequestMessageW)(HIMC hIMC, WPARAM wParam, LPARAM lParam);
typedef HWND(WINAPI* FPOurImmGetDefaultIMEWnd)(HWND hWnd);
typedef UINT(WINAPI* FPOurImmGetIMEFileNameA)(HKL hKL, CHAR* psz, UINT uBufLen);
typedef BOOL(WINAPI* FPOurImmIsIME)(HKL hKL);

static FPOurImmSetOpenStatus pFPOurImmSetOpenStatus = 0;
static FPOurImmGetOpenStatus pFPOurImmGetOpenStatus = 0;
static FPOurImmGetContext pFPOurImmGetContext = 0;
static FPOurImmGetConversionStatus pFPOurImmGetConversionStatus = 0;
static FPOurImmSetConversionStatus pFPOurImmSetConversionStatus = 0;
static FPOurImmSetStatusWindowPos pFPOurImmSetStatusWindowPos = 0;
static FPOurImmConfigureIME pFPOurImmConfigureIME = 0;
static FPOurImmEscapeA pFPOurImmEscapeA = 0;
static FPOurImmNotifyIME pFPOurImmNotifyIME = 0;
static FPOurImmLockIMCC pFPOurImmLockIMCC = 0;
static FPOurImmReSizeIMCC pFPOurImmReSizeIMCC = 0;
static FPOurImmUnlockIMCC pFPOurImmUnlockIMCC = 0;
static FPOurImmGetIMCCSize pFPOurImmGetIMCCSize = 0;
static FPOurImmGenerateMessage pFPOurImmGenerateMessage = 0;
static FPOurImmLockIMC pFPOurImmLockIMC = 0;
static FPOurImmUnlockIMC pFPOurImmUnlockIMC = 0;
//static FPOurImmRequestMessageW pFPOurImmRequestMessageW = 0;
static FPOurImmGetDefaultIMEWnd pFPOurImmGetDefaultIMEWnd = 0;
static FPOurImmGetIMEFileNameA pFPOurImmGetIMEFileNameA = 0;
static FPOurImmIsIME pFPOurImmIsIME = 0;

static HMODULE hImmLib = (HMODULE)0;

BOOL StartIMM(VOID)
{
    if( hImmLib != (HANDLE)0 ) {
        return TRUE;
    }

    hImmLib = LoadLibrary( LIBNAME );
    if( hImmLib == (HANDLE)0 ) {
        return TRUE;
    }

    pFPOurImmSetOpenStatus = (FPOurImmSetOpenStatus)GetProcAddress( hImmLib, "ImmSetOpenStatus" );
    pFPOurImmGetOpenStatus = (FPOurImmGetOpenStatus)GetProcAddress( hImmLib, "ImmGetOpenStatus" );
    pFPOurImmGetContext = (FPOurImmGetContext)GetProcAddress( hImmLib, "ImmGetContext" );
    pFPOurImmGetConversionStatus = (FPOurImmGetConversionStatus)GetProcAddress( hImmLib, "ImmGetConversionStatus" );
    pFPOurImmSetConversionStatus = (FPOurImmSetConversionStatus)GetProcAddress( hImmLib, "ImmSetConversionStatus" );
    pFPOurImmSetStatusWindowPos = (FPOurImmSetStatusWindowPos)GetProcAddress( hImmLib, "ImmSetStatusWindowPos" );
    pFPOurImmConfigureIME = (FPOurImmConfigureIME)GetProcAddress( hImmLib, "ImmConfigureIMEA" );
    pFPOurImmEscapeA = (FPOurImmEscapeA)GetProcAddress( hImmLib, "ImmEscapeA" );
    pFPOurImmNotifyIME = (FPOurImmNotifyIME)GetProcAddress( hImmLib, "ImmNotifyIME" );
     pFPOurImmLockIMCC = (FPOurImmLockIMCC)GetProcAddress( hImmLib, "ImmLockIMCC" );
    pFPOurImmReSizeIMCC = (FPOurImmReSizeIMCC)GetProcAddress( hImmLib, "ImmReSizeIMCC" );
    pFPOurImmUnlockIMCC = (FPOurImmUnlockIMCC)GetProcAddress( hImmLib, "ImmUnlockIMCC" );
    pFPOurImmGetIMCCSize = (FPOurImmGetIMCCSize)GetProcAddress( hImmLib, "ImmGetIMCCSize" );
    pFPOurImmGenerateMessage = (FPOurImmGenerateMessage)GetProcAddress( hImmLib, "ImmGenerateMessage" );
    pFPOurImmLockIMC = (FPOurImmLockIMC)GetProcAddress( hImmLib, "ImmLockIMC" );
    pFPOurImmUnlockIMC = (FPOurImmUnlockIMC)GetProcAddress( hImmLib, "ImmUnlockIMC" );
//    pFPOurImmRequestMessageW = (FPOurImmRequestMessageW)GetProcAddress( hImmLib, "ImmRequestMessageW" );
    pFPOurImmGetDefaultIMEWnd = (FPOurImmGetDefaultIMEWnd)GetProcAddress( hImmLib, "ImmGetDefaultIMEWnd" );
    pFPOurImmGetIMEFileNameA = (FPOurImmGetIMEFileNameA)GetProcAddress( hImmLib, "ImmGetIMEFileNameA" );
    pFPOurImmIsIME = (FPOurImmIsIME)GetProcAddress( hImmLib, "ImmIsIME" );

    return FALSE;
}

VOID EndIMM(VOID)
{
    FreeLibrary( hImmLib );
}


//
// OurImmSetOpenStatus
//
BOOL OurImmSetOpenStatus(HIMC hIMC, BOOL fOpen)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->SetOpenStatus( hIMC, fOpen ) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmSetOpenStatus ) {
        return pFPOurImmSetOpenStatus(hIMC, fOpen );
    }
    return FALSE;
}

//
// OurImmGetOpenStatus
//
BOOL OurImmGetOpenStatus(HIMC hIMC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->GetOpenStatus( hIMC ) == S_OK ? TRUE : FALSE);
    }
#endif
    if( pFPOurImmGetOpenStatus ) {
        // * check *
        //
        // sometime IMM sets 0xffffffff as TRUE
        //
        return (pFPOurImmGetOpenStatus( hIMC ) ? TRUE : FALSE);
    }
    return FALSE;
}
    
//
// OurImmGetContext
//
HIMC OurImmGetContext(HWND hWnd)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        HIMC hIMC = (HIMC)0;
        vpAIMM->GetContext( hWnd, &hIMC );
        return hIMC;
    }
#endif
    if( pFPOurImmGetContext ) {
        return pFPOurImmGetContext(hWnd );
    }
    return NULL;
}

//
// OurImmGetConversionStatus
//
BOOL OurImmGetConversionStatus(HIMC hIMC, LPDWORD pdwConv, LPDWORD pdwSent)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->GetConversionStatus(hIMC, pdwConv, pdwSent ) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmGetConversionStatus ) {
        return pFPOurImmGetConversionStatus(hIMC, pdwConv, pdwSent );
    }
    return NULL;
}

//
// OurImmSetConversionStatus
//
BOOL OurImmSetConversionStatus(HIMC hIMC, DWORD dwConv, DWORD dwSent)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->SetConversionStatus(hIMC, dwConv, dwSent) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmSetConversionStatus ) {
        return pFPOurImmSetConversionStatus(hIMC, dwConv, dwSent);
    }
    return NULL;
}

//
// OurImmSetStatusWindowPos
//
BOOL OurImmSetStatusWindowPos(HIMC hIMC, LPPOINT pPt)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->SetStatusWindowPos( hIMC, pPt) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmSetStatusWindowPos ) {
        return pFPOurImmSetStatusWindowPos( hIMC, pPt);
    }
    return NULL;
}

//
// OurImmConfigureIME
//
BOOL OurImmConfigureIME(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->ConfigureIMEA(hKL, hWnd, dw, (REGISTERWORDA*)pv ) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmConfigureIME ) {
        return pFPOurImmConfigureIME(hKL, hWnd, dw, pv );
    }
    return NULL;
}

//
// OurImmEscapeA
//
LRESULT OurImmEscapeA(HKL hKL, HIMC hIMC, UINT ui, LPVOID pv)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        LRESULT lRet = 0;
        vpAIMM->EscapeA(hKL, hIMC, ui, pv, &lRet );
        return lRet;
    }
#endif
    if( pFPOurImmEscapeA ) {
        return pFPOurImmEscapeA(hKL, hIMC, ui, pv );
    }
    return NULL;
}

//
// OurImmNotifyIME
//
BOOL OurImmNotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->NotifyIME(hIMC, dwAction, dwIndex, dwValue ) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmNotifyIME ) {
        return pFPOurImmNotifyIME(hIMC, dwAction, dwIndex, dwValue );
    }
    return NULL;
}

//
// OurImmLockIMCC
//
LPVOID OurImmLockIMCC(HIMCC hIMCC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        VOID* pv = NULL;
        vpAIMM->LockIMCC( hIMCC, &pv);
        return pv;
    }
#endif
    if( pFPOurImmLockIMCC ) {
        return pFPOurImmLockIMCC( hIMCC);
    }
    return NULL;
}

//
// OurImmReSizeIMCC
//
HIMCC OurImmReSizeIMCC(HIMCC hIMCC, DWORD dw)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        HIMCC hIMCC2 = (HIMCC)0;
        vpAIMM->ReSizeIMCC(hIMCC, dw, &hIMCC2 );
        return hIMCC2;
    }
#endif
    if( pFPOurImmReSizeIMCC ) {
        return pFPOurImmReSizeIMCC(hIMCC, dw );
    }
    return NULL;
}

//
// OurImmUnlockIMCC
//
BOOL OurImmUnlockIMCC(HIMCC hIMCC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->UnlockIMCC(hIMCC )  == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmUnlockIMCC ) {
        return pFPOurImmUnlockIMCC(hIMCC );
    }
    return NULL;
}

//
// OurImmGetIMCCSize
//
DWORD OurImmGetIMCCSize(HIMCC hIMCC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        DWORD dwSize = 0;
        vpAIMM->GetIMCCSize(hIMCC, &dwSize );
        return dwSize;
    }
#endif
    if( pFPOurImmGetIMCCSize ) {
        return pFPOurImmGetIMCCSize(hIMCC );
    }
    return NULL;
}

//
// OurImmGenerateMessage
//
BOOL OurImmGenerateMessage(HIMC hIMC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->GenerateMessage( hIMC) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmGenerateMessage ) {
        return pFPOurImmGenerateMessage( hIMC);
    }
    return NULL;
}

//
// OurImmLockIMC
//
LPINPUTCONTEXT OurImmLockIMC(HIMC hIMC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        LPINPUTCONTEXT pI = NULL;
        vpAIMM->LockIMC( hIMC, &pI);
        return pI;
    }
#endif
    if( pFPOurImmLockIMC ) {
        return pFPOurImmLockIMC( hIMC);
    }
    return NULL;
}

//
// OurImmUnlockIMC
//
BOOL OurImmUnlockIMC(HIMC hIMC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->UnlockIMC( hIMC ) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmUnlockIMC ) {
        return pFPOurImmUnlockIMC( hIMC );
    }
    return NULL;
}

#if NOTUSED
//
// OurImmRequestMessageW
//
LRESULT OurImmRequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return 0;    //vpAIMM->UnlockIMC( hIMC );
    }
#endif
    if( pFPOurImmRequestMessageW ) {
        return pFPOurImmRequestMessageW( hIMC, wParam, lParam );
    }
    return NULL;
}
#endif

//
// OurImmGetDefaultIMEWnd
//
HWND OurImmGetDefaultIMEWnd(HWND hWnd )
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        HWND hWndDef = (HWND)0;
        vpAIMM->GetDefaultIMEWnd(hWnd, &hWndDef);
        return hWndDef;
    }
#endif
    if( pFPOurImmGetDefaultIMEWnd ) {
        return pFPOurImmGetDefaultIMEWnd(hWnd);
    }
    return NULL;
}

UINT OurImmGetIMEFileNameA(HKL hKL, LPSTR pszName, UINT uBufLen)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        UINT ui = 0;
        vpAIMM->GetIMEFileNameA(hKL, uBufLen, pszName, &ui);
        return ui;
    }
#endif
    if( pFPOurImmGetIMEFileNameA ) {
        return pFPOurImmGetIMEFileNameA(hKL, pszName, uBufLen);
    }
    return NULL;
}

//
// OurImmIsIME
//
BOOL OurImmIsIME(HKL hKL)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        // why? BOOL fRet = FALSE;
        return (vpAIMM->IsIME(hKL) == S_OK) ? TRUE : FALSE;
        //return fRet;
    }
#endif
    if( pFPOurImmIsIME ) {
        return pFPOurImmIsIME(hKL );
    }
    return FALSE;
}
#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\imemisc.cpp ===
/****************************************************************************
    IMEMISC.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    MISC utility functions
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "imedefs.h"

static BOOL ValidateProductSuite(LPTSTR SuiteName);

#if (FUTURE_VERSION)
// Currently this IME will run on the NT5 only. We don't need to check Hydra in NT4
// Even we have no plan to create Korean NT4 TS
BOOL IsHydra(void)
{
    static DWORD fTested = fFalse, fHydra = fFalse;

    if (!fTested) 
        {
        fHydra = ValidateProductSuite(TEXT("Terminal Server"));
        fTested = fTrue;
        }
        
    return(fHydra);
}

BOOL ValidateProductSuite(LPTSTR SuiteName)
{
    BOOL rVal = fFalse;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPTSTR ProductSuite = NULL;
    LPTSTR p;

    Rslt = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                &hKey
                );
    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueEx( hKey, TEXT("ProductSuite"), NULL, &Type, NULL, &Size );
    if (Rslt != ERROR_SUCCESS || !Size)
        goto exit;

    ProductSuite = (LPTSTR) LocalAlloc( LPTR, Size );
    if (!ProductSuite)
        goto exit;

    Rslt = RegQueryValueEx( hKey, TEXT("ProductSuite"), NULL, &Type, (LPBYTE) ProductSuite, &Size );
    if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    p = ProductSuite;
    while (*p) 
        {
        if (lstrcmpi( p, SuiteName ) == 0) 
            {
            rVal = fTrue;
            break;
            }
        p += (lstrlen( p ) + 1);
        }

exit:
    if (ProductSuite)
        LocalFree( ProductSuite );

    if (hKey)
        RegCloseKey( hKey );

    return rVal;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\indicml.h ===
/**********************************************************************/
/*      INDICML.H - Indicator Service Manager definitions             */
/*                                                                    */
/*      Copyright (c) 1993-1997  Microsoft Corporation                */
/**********************************************************************/

#ifndef _INDICML_
#define _INDICML_        // defined if INDICML.H has been included

#ifdef __cplusplus
extern "C" {
#endif

//---------------------------------------------------------------------
//
// The messages for Indicator Window.
//
//---------------------------------------------------------------------
#define INDICM_SETIMEICON         (WM_USER+100)
#define INDICM_SETIMETOOLTIPS     (WM_USER+101)
#define INDICM_REMOVEDEFAULTMENUITEMS     (WM_USER+102)
#define RDMI_LEFT         0x0001
#define RDMI_RIGHT        0x0002


//---------------------------------------------------------------------
//
// INDICATOR_WND will be used by the IME to find indicator window.
// IME should call FindWindow(INDICATOR_WND) to get it.
//
//---------------------------------------------------------------------
#ifdef _WIN32

#define INDICATOR_CLASSW         L"Indicator"
#define INDICATOR_CLASSA         "Indicator"

#ifdef UNICODE
#define INDICATOR_CLASS          INDICATOR_CLASSW
#else
#define INDICATOR_CLASS          INDICATOR_CLASSA
#endif

#else
#define INDICATOR_CLASS          "Indicator"
#endif

#ifdef __cplusplus
}
#endif

#endif  // _INDICML_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\immsec.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    immsec.c

Abstract:

    security code called by IMEs 

Author:

    Chae Seong Lim [cslim] 23-Dec-1997
    Takao Kitano [takaok] 01-May-1996

Revision History:
    Chae Seong Lim [cslim] 971223 Korean IME version
    Hiroaki Kanokogi [hiroakik] 960624  Modified for MSIME96
    Hiroaki Kanokogi [hiroakik] 960911  NT #11911

--*/

#include "precomp.h"
#include "immsec.h"
#include "winex.h"


#define MEMALLOC(x)      LocalAlloc(LMEM_FIXED, x)
#define MEMFREE(x)       LocalFree(x)

//
// internal functions
//
PSID MyCreateSid( DWORD dwSubAuthority );

//
// debug functions
//
#ifdef DEBUG
#define ERROROUT(x)      ErrorOut( x )
#define WARNOUT(x)       WarnOut( x )
#else
#define ERROROUT(x) 
#define WARNOUT(x)       
#endif

#ifdef DEBUG
VOID WarnOut( PTSTR pStr )
{
    OutputDebugString( pStr );
}

VOID ErrorOut( PTSTR pStr )
{
    DWORD dwError;
    DWORD dwResult;
    static TCHAR buf1[512];
    static TCHAR buf2[512];

    dwError = GetLastError();
    dwResult = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwError,
                              MAKELANGID( LANG_ENGLISH, LANG_NEUTRAL ),
                              buf1,
                              512,
                              NULL );                                   
    
    if (dwResult > 0)
    {
        wsprintfA(buf2, "%s:%s(0x%x)", pStr, buf1, dwError);
    }
    else
    {
        wsprintfA(buf2, "%s:(0x%x)", pStr, dwError);
    }
    OutputDebugString( buf2 );
}
#endif


//
// GetIMESecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access to the following users:
//      
//          o Users who log on for interactive operation
//          o The user account used by the operating system
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeIMESecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//

static PSECURITY_ATTRIBUTES g_pSAIME = NULL;

PSECURITY_ATTRIBUTES GetIMESecurityAttributes(VOID)
{
    if (IsWinNT())
        return (g_pSAIME == NULL) ? (g_pSAIME = CreateSecurityAttributes()) : g_pSAIME;
    else
        return NULL;
}

//
// FreeIMESecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      GetIMESecurityAttributes() call.
//

VOID FreeIMESecurityAttributes()
{
    if (g_pSAIME != NULL)
        FreeSecurityAttributes(g_pSAIME);

    g_pSAIME = NULL;
}


//
// CreateSecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access to the following users:
//      
//          o Users who log on for interactive operation
//          o The user account used by the operating system
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//
PSECURITY_ATTRIBUTES CreateSecurityAttributes()
{
    PSECURITY_ATTRIBUTES psa;
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    ULONG                AclSize;

    PSID                 psid1, psid2, psid3, psid4;
    BOOL                 fResult;

    psid1 = MyCreateSid(SECURITY_INTERACTIVE_RID);
    if (psid1 == NULL)
        return NULL;

    psid2 = MyCreateSid(SECURITY_LOCAL_SYSTEM_RID);
    if (psid2 == NULL)
        goto Fail5;

    psid3 = MyCreateSid(SECURITY_SERVICE_RID);
    if (psid3 == NULL)
        goto Fail4;

    psid4 = MyCreateSid(SECURITY_NETWORK_RID);
    if (psid4 == NULL)
        goto Fail3;

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SIDs we've just created.
    //
    AclSize =  sizeof(ACL) + 
               (4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) + 
               GetLengthSid(psid1) + 
               GetLengthSid(psid2) + 
               GetLengthSid(psid3) + 
               GetLengthSid(psid4);

    pacl = (PACL)MEMALLOC(AclSize);
    if (pacl == NULL)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:LocalAlloc for ACL failed"));
        goto Fail2;
    }

    fResult = InitializeAcl(pacl, AclSize, ACL_REVISION);
    if (!fResult)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:InitializeAcl failed"));
        goto Fail;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid1);

    if (!fResult)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed"));
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid2);

    if (!fResult)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed"));
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid3);

    if (!fResult)
    {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid4);

    if (!fResult)
    {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        goto Fail;
    }

    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid(psid1);
    FreeSid(psid2);
    FreeSid(psid3);
    FreeSid(psid4);

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl))
    {
        WARNOUT(TEXT("CreateSecurityAttributes:IsValidAcl returns fFalse!"));
        MEMFREE(pacl);
        return NULL;
    }

    //
    // allocate security attribute
    //
    psa = (PSECURITY_ATTRIBUTES)MEMALLOC(sizeof(SECURITY_ATTRIBUTES));
    if (psa == NULL)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:LocalAlloc for psa failed"));
        MEMFREE(pacl);
        return NULL;
    }
    
    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC(SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (psd == NULL)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:LocalAlloc for psd failed"));
        MEMFREE(pacl);
        MEMFREE(psa);
        return NULL;
    }

    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
    {
        ERROROUT(TEXT("CreateSecurityAttributes:InitializeSecurityDescriptor failed"));
        MEMFREE(pacl);
        MEMFREE(psa);
        MEMFREE(psd);
        return NULL;
    }


    fResult = SetSecurityDescriptorDacl(psd, fTrue, pacl, fFalse );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if (!fResult)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:SetSecurityDescriptorDacl failed"));
        MEMFREE(pacl);
        MEMFREE(psa);
        MEMFREE(psd);
        return NULL;
    } 

    if (!IsValidSecurityDescriptor(psd))
    {
        WARNOUT(TEXT("CreateSecurityAttributes:IsValidSecurityDescriptor failed!"));
        MEMFREE(pacl);
        MEMFREE(psa);
        MEMFREE(psd);
        return NULL;
    }

    //
    // everything is done
    //
    psa->nLength = sizeof(SECURITY_ATTRIBUTES);
    psa->lpSecurityDescriptor = (PVOID)psd;
    psa->bInheritHandle = fTrue;

    return psa;

Fail:
    MEMFREE(pacl);
Fail2:
    FreeSid(psid4);
Fail3:
    FreeSid(psid3);
Fail4:
    FreeSid(psid2);
Fail5:
    FreeSid(psid1);
    return NULL;
}

PSID MyCreateSid(DWORD dwSubAuthority)
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid(&SidAuthority,
                                       1,
                                       dwSubAuthority,
                                       0,0,0,0,0,0,0,
                                       &psid );
    if (!fResult)
    {
        ERROROUT(TEXT("MyCreateSid:AllocateAndInitializeSid failed"));
        return NULL;
    }

    if (!IsValidSid(psid))
    {
        WARNOUT(TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid(psid);
        return NULL;
    }

    return psid;
}

//
// FreeSecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      CreateSecurityAttributes() call.
//
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa )
{
    BOOL fResult;
    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    PACL pacl;

    fResult = GetSecurityDescriptorDacl(psa->lpSecurityDescriptor,
                                        &fDaclPresent,
                                        &pacl,
                                        &fDaclDefaulted);
    if (fResult)
    {

        if (pacl != NULL)
            MEMFREE(pacl);
    }
    else
    {
        ERROROUT( TEXT("FreeSecurityAttributes:GetSecurityDescriptorDacl failed") );
    }

    MEMFREE(psa->lpSecurityDescriptor);
    MEMFREE(psa);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\inlines.h ===
//	Inline functions

#if !defined (_INLINES_H__INCLUDED_)
#define _INLINES_H__INCLUDED_

#include "debug.h"
#include "imemisc.h"

#ifndef DEBUG
/////////////////////////////////////////////////////////////////////////////
// New and Delete operator overloading
/*---------------------------------------------------------------------------
	operator new
	Unicode String compare
---------------------------------------------------------------------------*/
__inline void* __cdecl operator new(size_t size)
{
	return (void*)GlobalAllocPtr(GMEM_FIXED, size);
}

/*---------------------------------------------------------------------------
	operator new
	Unicode String compare
---------------------------------------------------------------------------*/
__inline void __cdecl operator delete(void* pv)
{
	if (pv)
		GlobalFreePtr(pv);
}
#endif

// DATA.CPP
__inline BOOL DoEnterCriticalSection(HANDLE hMutex)
{
	if(WAIT_FAILED==WaitForSingleObject(hMutex, 3000))	// Wait 3 seconds
		return(fFalse);
	return(fTrue);
}
    

__inline 
LRESULT OurSendMessage( HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	DWORD_PTR 	dwptResult;
	LRESULT		lResult;
	
	DbgAssert( hWnd != (HWND)0 );
	Dbg( DBGID_SendMsg, TEXT("SendMsg - hW=%x uiMsg=%x wP=%x lP=%x"), hWnd, uiMsg, wParam, lParam );

	lResult = SendMessageTimeout( hWnd, uiMsg, wParam, lParam, SMTO_NORMAL, 8000, &dwptResult );
	if( lResult == 0 ) // application didn't respond
		{ 
		AST( lResult != 0 );
		Dbg( DBGID_SendMsg, TEXT("SendMsg - *TIMEOUT*"));
		PostMessage( hWnd, uiMsg, wParam, lParam );		// post anyway
		}
	Dbg( DBGID_SendMsg, TEXT("SendMsg - Exit = %x hW=%x uiMsg=%x wP=%x lP=%x"), dwptResult, hWnd, uiMsg, wParam, lParam );

	return (LRESULT)dwptResult;
}

/////////////////////////////////////////////////////////////////////////////
// Wide String Functions 
// Win95 does not support lstrcmpW, lstrcpyW, lstrcatW

/*---------------------------------------------------------------------------
	StrCmpW
	Unicode String compare
---------------------------------------------------------------------------*/
__inline INT StrCmpW(WCHAR* pwSz1, WCHAR* pwSz2)
{
	INT cch1 = lstrlenW( pwSz1 );
	INT cch2 = lstrlenW( pwSz2 );

	if( cch1 != cch2 ) {
		return cch2 - cch1;
	}

	INT i;
	for( i=0; i<cch1; i++ ) {
		if( pwSz1[i] != pwSz2[i] ) {
			return i+1;
		}
	}
	return 0;

}

/*---------------------------------------------------------------------------
	StrCopyW
	Unicode String copy
---------------------------------------------------------------------------*/
__inline INT StrCopyW(LPWSTR pwSz1, LPCWSTR pwSz2)
{
	INT cch = 0;
	while( *pwSz2 ) {
		*pwSz1 = *pwSz2;
		pwSz1 ++;
		pwSz2 ++;
		cch++;
	}
	*pwSz1 = L'\0';
	return cch;
}


/*---------------------------------------------------------------------------
	StrnCopyW
	Unicode String copy
---------------------------------------------------------------------------*/
__inline LPWSTR StrnCopyW(LPWSTR pwDest, LPCWSTR pwSrc, UINT uiCount)
{
	LPWSTR pwStart = pwDest;

	while (uiCount && (*pwDest++ = *pwSrc++))	// copy string 
		uiCount--;

	if (uiCount)							    // pad out with zeroes
		while (--uiCount)
			*pwDest++ = 0;

	return (pwStart);
}

__inline 
LRESULT OurSendMessageNoPost( HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	DWORD_PTR 	dwptResult;
	LRESULT		lResult;

	Dbg( DBGID_SendMsg, TEXT("SendMsgNoPost - hW=%x uiMsg=%x wP=%x lP=%x"), hWnd, uiMsg, wParam, lParam );
	lResult = SendMessageTimeout( hWnd, uiMsg, wParam, lParam, SMTO_NORMAL, 100, &dwptResult );
	Dbg( DBGID_SendMsg, TEXT("SendMsgNoPost - Exit = %x hW=%x uiMsg=%x wP=%x lP=%x"), dwptResult, hWnd, uiMsg, wParam, lParam );
	return (LRESULT)dwptResult;
}

__inline 
BOOL IsWin( HWND hWnd )
{
	return (hWnd && IsWindow(hWnd));
}

__inline 
LRESULT OurPostMessage( HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	LRESULT lResult;

	Dbg( DBGID_SendMsg, TEXT("PostMsg - hW=%x uiMsg=%x wP=%x lP=%x"), hWnd, uiMsg, wParam, lParam );
	lResult = PostMessage( hWnd, uiMsg, wParam, lParam);
	return (LRESULT)lResult;
}

__inline 
BOOL	IsShiftKeyPushed( LPBYTE lpbKeyState )
{
	return lpbKeyState[VK_SHIFT] & 0x80;
}

__inline 
BOOL IsControlKeyPushed( LPBYTE lpbKeyState )
{
	return lpbKeyState[VK_CONTROL] & 0x80;
}

#endif // __INLINES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\immsys.h ===
/****************************************************************************
	IMMSYS.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Load/Unload IMM Apis dynamically not link with imm32.lib
	Inlcude Immdev.h and Indicml.h
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/
#if !defined (_IMMSYS_H__INCLUDED_)
#define _IMMSYS_H__INCLUDED_

#ifndef UNDER_CE 

// include Win32 immdev.h (copied from nt\public\oak\inc\immdev.h)
#include "immdev.h"
// include indicator Service Manager definitions 
#include "indicml.h"

// IMM.DLL Load/Unload functions
BOOL StartIMM();
VOID EndIMM();

// Internal IMM functions
BOOL OurImmSetOpenStatus(HIMC hIMC, BOOL fOpen);
BOOL OurImmGetOpenStatus(HIMC hIMC);
HIMC OurImmGetContext(HWND hWnd);
BOOL OurImmGetConversionStatus(HIMC hIMC, LPDWORD pdwConv, LPDWORD pdwSent);
BOOL OurImmSetConversionStatus(HIMC hIMC, DWORD dwConv, DWORD dwSent);
BOOL OurImmSetStatusWindowPos(HIMC hIMC, LPPOINT pPt);
BOOL OurImmConfigureIME(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);
LRESULT OurImmEscapeA(HKL hKL, HIMC hIMC, UINT ui, LPVOID pv);
BOOL OurImmNotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

LPVOID OurImmLockIMCC(HIMCC hIMCC);
HIMCC  OurImmReSizeIMCC(HIMCC hIMCC, DWORD dw);
BOOL   OurImmUnlockIMCC(HIMCC hIMCC);
DWORD  OurImmGetIMCCSize(HIMCC hIMCC);

BOOL OurImmGenerateMessage(HIMC hIMC);
LPINPUTCONTEXT OurImmLockIMC(HIMC hIMC);
BOOL OurImmUnlockIMC(HIMC hIMC);
//LRESULT OurImmRequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam);
HWND OurImmGetDefaultIMEWnd(HWND);
UINT OurImmGetIMEFileNameA(HKL, LPSTR, UINT uBufLen);
BOOL OurImmIsIME(HKL hKL);

#else
///////////////////////////////////////////////////////////////////////////////
// !!! START OF WINCE !!!
#ifndef _IMM_CE
#define _IMM_CE

#include	<imm.h>
#include	<stub_ce.h> // Windows CE Stub for unsupported APIs / kill other define

// the data structure used for WM_SYSCOPYDATA message
typedef struct tagLMDATA
{
        DWORD   dwVersion;
        DWORD   flags;
        DWORD   cnt;
        DWORD   dwOffsetSymbols;
        DWORD   dwOffsetSkip;
        DWORD   dwOffsetScore;
        BYTE    ab[1];
} LMDATA, *PLMDATA;

// flags in LMDATA
#define LMDATA_SYMBOL_BYTE  0x00000001
#define LMDATA_SYMBOL_WORD  0x00000002
#define LMDATA_SYMBOL_DWORD 0x00000004
#define LMDATA_SYMBOL_QWORD 0x00000008
#define LMDATA_SKIP_BYTE    0x00000010
#define LMDATA_SKIP_WORD    0x00000020
#define LMDATA_SCORE_BYTE   0x00000040
#define LMDATA_SCORE_WORD   0x00000080
#define LMDATA_SCORE_DWORD  0x00000100
#define LMDATA_SCORE_QWORD  0x00000200
#define LMDATA_SCORE_FLOAT  0x00000400
#define LMDATA_SCORE_DOUBLE 0x00000800

// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW      0x0001
#define IMR_CANDIDATEWINDOW        0x0002
#define IMR_COMPOSITIONFONT        0x0003
#define IMR_RECONVERTSTRING        0x0004
#define IMR_CONFIRMRECONVERTSTRING 0x0005
#define IMR_QUERYPOSITION          0x0006
#define IMR_DOCUMENTFEED           0x0007

typedef struct tagIMEPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMEPOSITION, *PIMEPOSITION, NEAR *NPIMEPOSITION, FAR *LPIMEPOSITION;

#define IME_SMODE_CONVERSATION          0x0010

#define NI_IMEMENUSELECTED              0x0018

#define IME_ESC_GETHELPFILENAME         0x100b

#ifdef IMFS_GRAYED
#undef IMFS_GRAYED
#endif
#define IMFS_GRAYED          MF_GRAYED

#define IME_CONFIG_DICTIONARYEDIT     20

// ID for dwIndex of GUIDELINE Structure
#define GL_ID_TOOMANYRECONV                   0x00008001

#define	IMNPRIVATESIGN		(0x98A)
typedef struct tagIMNPRIVATE {
	UINT uSign;		// magic ID : IME98=98
	UINT uId;		// private id
	LPARAM lParam; // lParam
} IMNPRIVATE, * PIMNPRIVATE;

/**********************************************************************/
/*      INDICML.H - Indicator Service Manager definitions             */
/*                                                                    */
/*      Copyright (c) 1993-1997  Microsoft Corporation                */
/**********************************************************************/

#ifndef _INDICML_
#define _INDICML_        // defined if INDICML.H has been included

#ifdef __cplusplus
extern "C" {
#endif

//---------------------------------------------------------------------
//
// The messages for Indicator Window.
//
//---------------------------------------------------------------------
#define INDICM_SETIMEICON         (WM_USER+100)
#define INDICM_SETIMETOOLTIPS     (WM_USER+101)

//---------------------------------------------------------------------
//
// INDICATOR_WND will be used by the IME to find indicator window.
// IME should call FindWindow(INDICATOR_WND) to get it.
//
//---------------------------------------------------------------------
#ifdef _WIN32

#define INDICATOR_CLASSW         L"Indicator"
#define INDICATOR_CLASSA         "Indicator"

#ifdef UNICODE
#define INDICATOR_CLASS          INDICATOR_CLASSW
#else
#define INDICATOR_CLASS          INDICATOR_CLASSA
#endif

#else
#define INDICATOR_CLASS          "Indicator"
#endif

#define INDICM_REMOVEDEFAULTMENUITEMS     (WM_USER+102)
#define RDMI_LEFT         0x0001
#define RDMI_RIGHT        0x0002


#ifdef __cplusplus
}
#endif

#endif  // _INDICML_

//
// NT5 enhanvce
//
#ifndef VK_PACKET
	#define IME_PROP_ACCEPT_WIDE_VKEY 	0x20
	#define	VK_PACKET		0xe7
#endif // VK_PACKET

// Just maps private IMM functions into originals
#define OurImmSetOpenStatus 		ImmSetOpenStatus
#define OurImmGetOpenStatus 		ImmGetOpenStatus
#define OurImmGetContext 		ImmGetContext
#define OurImmGetConversionStatus	ImmGetConversionStatus
#define OurImmSetConversionStatus	ImmSetConversionStatus
#define OurImmSetStatusWindowPos	ImmSetStatusWindowPos
#define OurImmConfigureIME		ImmConfigureIMEW
#define OurImmEscapeA			ImmEscapeW
#define OurImmNotifyIME			ImmNotifyIME
#define OurImmLockIMCC			ImmLockIMCC
#define OurImmReSizeIMCC		ImmReSizeIMCC
#define OurImmUnlockIMCC		ImmUnlockIMCC
#define OurImmGetIMCCSize		ImmGetIMCCSize
#define OurImmGenerateMessage		ImmGenerateMessage
#define OurImmLockIMC			ImmLockIMC
#define OurImmUnlockIMC			ImmUnlockIMC
#define OurImmGetDefaultIMEWnd 		ImmGetDefaultIMEWnd
//#define OurImmRequestMessageW		ImmRequestMessageW

#endif // _IMM_CE
// !!! END OF WINCE !!!
///////////////////////////////////////////////////////////////////////////////
#endif // UNDER_CE

#endif // _IMMSYS_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\ipoint.cpp ===
/****************************************************************************
    IPOINT.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IImeIPoint1 interface
    
    History:
    20-JUL-1999 cslim       Created
*****************************************************************************/

#include "precomp.h"
#include "ipoint.h"
#include "imepad.h"    // IImeIPoint
#include "debug.h"

/*----------------------------------------------------------------------------
    CImeIPoint::CImeIPoint

    Ctor
----------------------------------------------------------------------------*/
CIImeIPoint::CIImeIPoint()
{
    m_cRef           = 0;
    m_pCIMECtx    = NULL;
    m_hIMC        = (HIMC)0;
    //m_pfnCallback = (IPUIControlCallBack)NULL;
    m_dwCharNo      = 1;
}

/*----------------------------------------------------------------------------
    CImeIPoint::~CIImeIPoint

    Dtor
----------------------------------------------------------------------------*/
CIImeIPoint::~CIImeIPoint()
{
    if (m_pCIMECtx)
        {
        delete m_pCIMECtx;
        m_pCIMECtx = NULL;
        m_hIMC = (HIMC)0;
        }
}

/*----------------------------------------------------------------------------
    CImeIPoint::QueryInterface
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::QueryInterface(REFIID riid, LPVOID * ppv)
{
    if(riid == IID_IUnknown) 
        {
        Dbg(DBGID_IMEPAD, ("IID_IUnknown\n"));
        *ppv = static_cast<IImeIPoint1 *>(this);
        }
    else 
    if(riid == IID_IImeIPoint1) 
        {
        Dbg(DBGID_IMEPAD, TEXT("IID_IImeIPoint1\n"));
        *ppv = static_cast<IImeIPoint1 *>(this);
        }
    else 
        {
        Dbg(DBGID_IMEPAD, ("Unknown Interface ID\n"));
        *ppv = NULL;
        return E_NOINTERFACE;
        }

    // Increase ref counter
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();

    return S_OK;
}

/*----------------------------------------------------------------------------
    CImeIPoint::AddRef
----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CIImeIPoint::AddRef(VOID)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/*----------------------------------------------------------------------------
    CImeIPoint::Release
----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CIImeIPoint::Release(VOID)
{
    ULONG res = InterlockedDecrement((LPLONG)&m_cRef);
    if (res == 0L)
        delete this;
    return res;
}

/*----------------------------------------------------------------------------
    CImeIPoint::Initialize
----------------------------------------------------------------------------*/
HRESULT CIImeIPoint::Initialize(HIMC hIMC)
{
    m_hIMC = hIMC;

    if (hIMC)
        m_pCIMECtx = new CIMECtx(hIMC);

    return (S_OK);
}

#ifndef DEBUG
    #define DumpFEInfo    /##/
#else
/*----------------------------------------------------------------------------
    DumpFEInfo

    Dump LPIMEFAREASTINFO. Debug only
----------------------------------------------------------------------------*/
VOID DumpFEInfo(LPIMEFAREASTINFO lpInfo, INT count)
{
    Dbg(DBGID_IMEPAD, "DumpFEInfo Start\n");
    Dbg(DBGID_IMEPAD, "lpInfo [0x%08x]\n", lpInfo);
    Dbg(DBGID_IMEPAD, "lpInfo->dwSize [%d]\n",     lpInfo->dwSize);
    Dbg(DBGID_IMEPAD, "lpInfo->dwType [0x%08x]\n", lpInfo->dwType);

    LPWSTR lpwstr;

    switch(lpInfo->dwType) 
        {
    case IMEFAREASTINFO_TYPE_COMMENT:
        Dbg(DBGID_IMEPAD, ("-->dwType is IMEFAREASTINFO_TYPE_COMMENT\n"));
        lpwstr = (LPWSTR)lpInfo->dwData;
        for(int i=0;i < count; i++) 
            {
            //DbgW(DBGID_IMEPAD, L"%d [%s]\n", i, lpwstr);
            lpwstr = lpwstr + lstrlenW(lpwstr)+1;
            }
        break;
        }


    Dbg(DBGID_IMEPAD, ("DumpFEInfo End\n"));
}
#endif // _DEBUG

/*----------------------------------------------------------------------------
    CImeIPoint::InsertImeItem

    Multibox input call this method
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::InsertImeItem(IPCANDIDATE* pImeItem, INT iPos, DWORD *lpdwCharId)
{
    DWORD dwCharId;

    // Check Parameters
    DbgAssert(pImeItem != NULL && pImeItem->dwSize > 0);
    
    if (pImeItem == NULL || pImeItem->dwSize <= 0 || m_pCIMECtx == NULL)
        return S_FALSE;

    Dbg(DBGID_IMEPAD, "CImeIPoint::InsertImeItem\n");
    Dbg(DBGID_IMEPAD, "pImeItem [0x%08x]\n", pImeItem);
    Dbg(DBGID_IMEPAD, "pImeItem->dwSize    [%d]\n", pImeItem->dwSize);
    Dbg(DBGID_IMEPAD, "pImeItem->iSelIndex [%d]\n", pImeItem->iSelIndex);
    Dbg(DBGID_IMEPAD, "pImeItem->nCandidate[%d]\n", pImeItem->nCandidate);
    Dbg(DBGID_IMEPAD, "pImeItem->dwPrivateDataOffset[%d]\n", pImeItem->dwPrivateDataOffset);
    Dbg(DBGID_IMEPAD, "pImeItem->dwPrivateDataSize  [%d]\n", pImeItem->dwPrivateDataSize);
    DumpFEInfo((LPIMEFAREASTINFO)((LPBYTE)pImeItem + pImeItem->dwPrivateDataOffset), pImeItem->nCandidate);

    Dbg(DBGID_IMEPAD, "lpdwCharId [0x%08x] [%d]\n", lpdwCharId, lpdwCharId ? *lpdwCharId : 0xFFFFF);


    //INT i;

    //for(i = 0; i < pImeItem->nCandidate; i++) 
    //    {
    //    LPWSTR lpwstr = (LPWSTR)((PBYTE)pImeItem + pImeItem->dwOffset[i]);
        //Dbg(DBGID_IMEPAD, (L"pImeItem->dwOffset[%d]=[%d] String[%s]\n", i, pImeItem->dwOffset[i], lpwstr));
    //    }

    // If interim state, finalize it first
    if (m_pCIMECtx->GetCompBufLen())
        {
        m_pCIMECtx->FinalizeCurCompositionChar();
        m_pCIMECtx->GenerateMessage();
        }

    // Just out first candidate. Discard all others
    // Access 2000 hangs if send only result string.
    m_pCIMECtx->SetStartComposition(fTrue);
    m_pCIMECtx->GenerateMessage();

    m_pCIMECtx->SetEndComposition(fTrue);
    m_pCIMECtx->SetResultStr(*(LPWSTR)((PBYTE)pImeItem + pImeItem->dwOffset[0]));
    m_pCIMECtx->StoreComposition();
    m_pCIMECtx->GenerateMessage();
    
    // Increase Char serial number
    m_dwCharNo++;
    dwCharId = m_dwCharNo;
    if (lpdwCharId)
        {
        dwCharId |= ((*lpdwCharId) & (~ IPCHARID_CHARNO_MASK));
        *lpdwCharId = dwCharId;
        }

    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ReplaceImeItem
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::ReplaceImeItem(
    INT             iPos,       // = IPINS_CURRENT:use current IP position and 
                           //                  set IP to the end of insert chars.
                           // = 0-n: The offset of all composition string to set 
                           //         IP position, before insert chars. 
                           //         and IP back to original position.
    INT             iTargetLen, 
    IPCANDIDATE* pImeItem,
    DWORD         *lpdwCharId)
{
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::InsertStringEx
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::InsertStringEx(WCHAR* pwSzInsert, INT cchSzInsert, DWORD *lpdwCharId)
{
    DWORD dwCharId;

    Dbg(DBGID_IMEPAD, TEXT("CIImeIPoint::InsertStringEx : *pwSzInsert=0x%04X, cchSzInsert=%d, *lpdwCharId = 0x%04X"), *pwSzInsert, cchSzInsert, *lpdwCharId);

    // Check Parameters
    DbgAssert(pwSzInsert != NULL && cchSzInsert > 0);
    
    if (pwSzInsert == NULL || cchSzInsert <= 0 || m_pCIMECtx == NULL)
        return S_FALSE;

    // Insert comp string to IME

    // If interim state, finalize it first
    if (m_pCIMECtx->GetCompBufLen())
        {
        m_pCIMECtx->FinalizeCurCompositionChar();
        m_pCIMECtx->GenerateMessage();
        }

    // Add all chars in string as finalized string
    for (INT i=0; i<cchSzInsert; i++)
        {
        // Access 2000 hangs if send only result string.
        m_pCIMECtx->SetStartComposition(fTrue);
        m_pCIMECtx->GenerateMessage();

        m_pCIMECtx->SetEndComposition(fTrue);
        m_pCIMECtx->SetResultStr(*(pwSzInsert + i));
        m_pCIMECtx->StoreComposition();
        m_pCIMECtx->GenerateMessage();
    
        // Increase Char serial number
        m_dwCharNo++;
        dwCharId = m_dwCharNo;
        if (lpdwCharId)
            {
            dwCharId |= ((*lpdwCharId) & (~ IPCHARID_CHARNO_MASK));
            *lpdwCharId = dwCharId;
            }
        }
    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::DeleteCompString
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::DeleteCompString(INT    iPos,
                             INT    cchSzDel)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::DeleteCompString\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ReplaceCompString
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::ReplaceCompString(INT     iPos,
                                              INT        iTargetLen, 
                                              WCHAR    *pwSzInsert,
                                              INT        cchSzInsert,
                                              DWORD    *lpdwCharId)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::ReplaceCompString\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ControlIME
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::ControlIME(DWORD dwIMEFuncID, LPARAM lpara)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::ControlIME, dwIMEFuncID=0x%04X, lpara=0x%08lX\n"), dwIMEFuncID, lpara);

    // TODO:
    
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::GetAllCompositionInfo
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::GetAllCompositionInfo(WCHAR**    ppwSzCompStr,
                                  DWORD**    ppdwCharID,
                                  INT        *pcchCompStr,
                                  INT        *piIPPos,
                                  INT        *piStartUndetStrPos,
                                  INT        *pcchUndetStr,
                                  INT        *piEditStart,
                                  INT        *piEditLen)
{
    // TODO:
    Dbg(DBGID_IMEPAD, ("CImeIPoint::GetAllCompositionInfo START\n"));

    if(ppwSzCompStr) 
        {
        *ppwSzCompStr = NULL; //(LPWSTR)CoTaskMemAlloc(sizeof(WCHAR)*10);
        //CopyMemory(*ppwSzCompStr, L"{ꏈ", sizeof(WCHAR)*6);
        }
        
    if(ppdwCharID) 
        {
        *ppdwCharID = NULL; //(DWORD *)CoTaskMemAlloc(sizeof(DWORD)*10);
        //for(int i = 0; i < 5; i++) 
        //    {
        //    (*ppdwCharID)[i] = i;
        //    }
        }

    if (pcchCompStr)
        *pcchCompStr = 0;
    if (piIPPos)
        *piIPPos = 0;
    if (piStartUndetStrPos)
        *piStartUndetStrPos = 0;
    if (pcchUndetStr)
        *pcchUndetStr = 0;
    if (piEditStart)
        *piEditStart = 0;
    if (piEditLen)
        *piEditLen = 0;
    Dbg(DBGID_IMEPAD, ("CImeIPoint::GetAllCompositionInfo END\n"));

    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::GetIpCandidate
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::GetIpCandidate(DWORD        dwCharId,
                           IPCANDIDATE **ppImeItem,
                           INT *        piColumn,
                           INT *        piCount)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::GetIpCandidate\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::SelectIpCandidate
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::SelectIpCandidate(DWORD dwCharId, INT iselno)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::SetIpCandidate\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::UpdateContext

    Update IME context and send it to the application
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::UpdateContext(BOOL fGenerateMessage)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::UpdateContext\n"));

    // TODO:
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\ipoint.h ===
/****************************************************************************
	IPOINT.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IImeIPoint1 interface
	
	History:
	20-JUL-1999 cslim       Created
*****************************************************************************/

#if !defined(_IPOINT_H__INCLUDED_)
#define _IPOINT_H__INCLUDED_

#include <objbase.h>
#include "ipoint1.h"
#include "imc.h"

class CIImeIPoint : public IImeIPoint1
{
// Ctor and Dtor
public:
	CIImeIPoint();
	~CIImeIPoint();

// IImePoint1 Methods
public:
	STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID * ppvObj);
	STDMETHODIMP_(ULONG) AddRef(VOID);
	STDMETHODIMP_(ULONG) Release(VOID);
	
	STDMETHODIMP InsertImeItem		(IPCANDIDATE* pImeItem, INT iPos, DWORD *lpdwCharId);
	STDMETHODIMP ReplaceImeItem		(INT iPos, INT iTargetLen, IPCANDIDATE* pImeItem, DWORD *lpdwCharId);
	STDMETHODIMP InsertStringEx		(WCHAR* pwSzInsert, INT cchSzInsert, DWORD *lpdwCharId);
	STDMETHODIMP DeleteCompString	(INT	iPos, INT cchSzDel);
	STDMETHODIMP ReplaceCompString	(INT	iPos,
									 INT	iTargetLen, 
									 WCHAR	*pwSzInsert, 
									 INT	cchSzInsert,
									 DWORD	*lpdwCharId);
	STDMETHODIMP ControlIME			(DWORD dwIMEFuncID, LPARAM lpara);
	STDMETHODIMP GetAllCompositionInfo(WCHAR	**ppwSzCompStr,
										DWORD	**ppdwCharID,
										INT		*pcchCompStr,
										INT		*piIPPos,
										INT		*piStartUndetStrPos,
										INT		*pcchUndetStr,
										INT		*piEditStart,
										INT		*piEditLen);
	STDMETHODIMP GetIpCandidate		(DWORD dwCharId,
										IPCANDIDATE **ppImeItem,
										INT *piColumn,
										INT *piCount);
	STDMETHODIMP SelectIpCandidate	(DWORD dwCharId, INT iselno);
	STDMETHODIMP UpdateContext		(BOOL fGenerateMessage);

// Helper functions
public:
	HRESULT Initialize(HIMC hIMC);
	VOID GetImeCtx(VOID** ppImeCtx )
	{
		*ppImeCtx = (VOID*)m_pCIMECtx;
	}

// Internal data
protected:
	ULONG		m_cRef;			// Ref count
	CIMECtx*	m_pCIMECtx;		// IME Input Context handle

	HIMC		m_hIMC;

	// char serial number
	DWORD		m_dwCharNo;
};
typedef CIImeIPoint* LPCImeIPoint;

#endif // _IPOINT_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\lexheader.h ===
#if !defined(_LEXHEADER_H__INCLUDED_)
#define _LEXHEADER_H__INCLUDED_

#define DEFAULT_LEX_FILE_NAME "IMEKR.LEX"	// if no reg found will use this name
#define DICT_HEADER_SIZE 512
#define COPYRIGHT_STR "(C) 1997 Hangul Engineering Team. Microsoft Corp. All rights reserved.\n"
#define LEX_VERSION					0x1100
#define LEX_COMPATIBLE_VERSION_LIMIT	0x2000
#define LEX_FILE_NAME _T("IMEKR.LEX")

#define TOTAL_NUMBER_OF_HANGUL_MAPPING	(484 + 18) // K0+K1 + # of symbols( - )
#define TOTAL_NUMBER_OF_HANJA			7744
#define MAX_NUMBER_OF_HANJA_SAME_PRONUNC 103
#define MAX_SENSE_LENGTH	50

struct  _DictHeader {
	char	COPYRIGHT_HEADER[150];
	WORD	Version;
	UINT	NumOfHangulEntry;
	UINT	MaxNumOfHanja;
	DWORD	Headersize;
	DWORD	iBufferStart;	// seek point
	UINT	uiNumofHanja;
	DWORD	reserved[10];
	_DictHeader() { 
		Version = 0;
		iBufferStart = Headersize= 0;

		ZeroMemory(reserved, sizeof(reserved));
		ZeroMemory(COPYRIGHT_HEADER, sizeof(COPYRIGHT_HEADER));
		lstrcpy(COPYRIGHT_HEADER, COPYRIGHT_STR);
		COPYRIGHT_HEADER[lstrlen(COPYRIGHT_HEADER)+1] = '\032';
	}
};

struct _LexIndex {
	WCHAR	wcHangul;
	WORD	wNumOfK0, wNumOfK1;
	UINT	iOffset;

	_LexIndex() {
		wcHangul = 0;
		wNumOfK0 = wNumOfK1 = 0;
		iOffset = 0;
	}
};

struct HanjaToHangulIndex 
{
	WCHAR	wchHanja;
	WCHAR	wchHangul;
	UINT	iOffset;

	HanjaToHangulIndex() 
	{
		wchHanja = wchHangul = 0;
		iOffset = 0;
	}
};


#endif // !defined(_LEXHEADER_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\pmode.h ===
//
// CMODE.H
//

#if !defined (__PMODE_H__INCLUDED_)
#define __PMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class PMode : public CCicButton
{
public:
    PMode(CToolBar *ptb);
    ~PMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:
	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __PMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\names.h ===
/****************************************************************************
	NAMES.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Const strings
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (__NAMES_H__)
#define __NAMES_H__

const CHAR szModuleName[] 	  = "IMEKR2002.IME";
const CHAR szUIClassName[]	  = "IMEKR2002_MAIN";
const WCHAR wszUIClassName[]	  = L"IMEKR2002_MAIN";
const CHAR szStatusClassName[]	  = "IMEKR2002_STAT";
const CHAR szCompClassName[]	  = "IMEKR2002_COMP";
const CHAR szCandClassName[]	  = "IMEKR2002_CAND";
const CHAR szTooltipClassName[]	  = "IMEKR2002_TOOLTIP";
const WCHAR wszTooltipClassName[] = L"IMEKR2002_TOOLTIP";

const WCHAR wzIMECompFont[] = { 0xAD74, 0xB9BC, 0x0000 };	// Gulim
const CHAR  szIMECompFont[] = "\xB1\xBC\xB8\xB2";

#endif //!defined (__NAMES_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\pad.cpp ===
/****************************************************************************
    PAD.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IME PAD wrapper functions

    History:
    10-APR-1999 cslim       Created
*****************************************************************************/

#include "precomp.h"
#include "cpadsvr.h"
#include "pad.h"
#include "cimecb.h"


BOOL BootPad(HWND hUIWnd, UINT uiType, LPARAM lParam)
{
    LPCImePadSvr lpCImePadSvr;
    HIMC         hIMC;
    IImeIPoint1* pIP;
    INT             iRet;
    BOOL         fVisible;
    BOOL          fRet = fFalse;
    
    Dbg(DBGID_IMEPAD, TEXT("BootPad() : hUIWnd = 0x%04X, uiType = 0x%04X, lParam = 0x%08lX"), hUIWnd, uiType, lParam);

    lpCImePadSvr = CImePadSvr::LoadCImePadSvr(CIMEPADSVR_SHAREDMEM);
    
    if(lpCImePadSvr)
        {
        // Check if already visible state. Toggle IME Pad
        lpCImePadSvr->IsVisible(&fVisible);
        if (fVisible)
            {
            lpCImePadSvr->ShowUI(fFalse);
            // CImePadSvr::DestroyCImePadSvr();
            return fTrue;
            }

        iRet = lpCImePadSvr->Initialize(MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), 0, NULL);
        DbgAssert(iRet == 0);
        if (iRet ==0) // Succeeded
            {
            hIMC = GethImcFromHwnd(hUIWnd);
            pIP = GetImeIPoint(hIMC);

            if (pIP)
                {
                lpCImePadSvr->SetIUnkIImeIPoint((IUnknown *)pIP);
                lpCImePadSvr->SetIUnkIImeCallback((IUnknown *)CImeCallback::Fetch());
                lpCImePadSvr->ShowUI(fTrue);
                }
            else
                {
                DbgAssert(0);
                return fFalse;
                }
                
            fRet = fTrue;
            }
        else
            CImePadSvr::DestroyCImePadSvr();
        }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\pad.h ===
/****************************************************************************
	PAD.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IME PAD wrapper functions

	History:
	10-APR-1999 cslim       Created
*****************************************************************************/

#if !defined (_PAD_H__INCLUDED_)
#define _PAD_H__INCLUDED_

BOOL BootPad(HWND hUIWnd, UINT uiType, LPARAM lParam);

#endif // _PAD_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\precomp.h ===
/****************************************************************************
	PRECOMP.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Precompiled header
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#define _IMM_
#include	<windows.h>
#include	<windowsx.h>
#undef _IMM_
#include <commctrl.h>
#include "immdev.h"
#include "immsys.h"
#include <ime.h>

// fTrue and fFalse
#ifndef fTrue
	#define fTrue 1
#endif
#ifndef fFalse
	#define fFalse 0
#endif

// PRIVATE and PUBLIC
#ifndef PRIVATE
	#define PRIVATE static
#endif
#ifndef PUBLIC
	#define PUBLIC extern
#endif

#define CP_KOREA (949)

// Project specific headers
#pragma hdrstop
#include "inlines.h"
#include "imedefs.h"
#include "imc.h"
#include "imcsub.h"
#include "gdata.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\propmode.cpp ===
/****************************************************************************
   PROPMODE.CPP : PropertyButton class managing Hanja button on the Cicero Toolbar

   History:
      25-FEB-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "propmode.h"
#include "ui.h"
#include "winex.h"
#include "resource.h"

extern const CLSID CLDSID_LBI_KORIME_IMM32; // {0198111B-FE89-4b4c-8619-8A5E015F29D8}

// {83DC4284-4BAC-4231-87F1-A4ADE98603B2}
const GUID GUID_LBI_KORIME_PROP_BUTTON = 
{ 
    0x83dc4284,
    0x4bac,
    0x4231,
    { 0x87, 0xf1, 0xa4, 0xad, 0xe9, 0x86, 0x3, 0xb2 }
};

/*---------------------------------------------------------------------------
    PropertyButton::PropertyButton
---------------------------------------------------------------------------*/
PropertyButton::PropertyButton(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    // Set Add/Remove text and tootip text
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_BUTTON_PROP, szText, sizeof(szText)/sizeof(WCHAR));
    InitNuiInfo(CLDSID_LBI_KORIME_IMM32, 
                GUID_LBI_KORIME_PROP_BUTTON,
                TF_LBI_STYLE_BTN_BUTTON, 
                1, 
                szText);
    SetToolTip(szText);

    // Set button text
    SetText(szText);
}

/*---------------------------------------------------------------------------
    PropertyButton::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI PropertyButton::GetIcon(HICON *phIcon)
{
    *phIcon = LoadIcon(vpInstData->hInst, MAKEINTRESOURCE(IDI_CMODE_PROP));
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    PropertyButton::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI PropertyButton::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    PropertyButton::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI PropertyButton::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
    PropertyButton::OnLButtonUp
---------------------------------------------------------------------------*/
HRESULT PropertyButton::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    OurPostMessage(GetActiveUIWnd(), WM_MSIME_PROPERTY, 0L, IME_CONFIG_GENERAL);

    return S_OK;
}


/*---------------------------------------------------------------------------
    PropertyButton::OnRButtonUp
---------------------------------------------------------------------------*/
HRESULT PropertyButton::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\propmode.h ===
//
// PROPBUT.H
//

#if !defined (__PROPBUT_H__INCLUDED_)
#define __PROPBUT_H__INCLUDED_

#include "buttoncc.h"
#include "toolbar.h"

class PropertyButton : public CLBarItemButtonBase
{
public:
    PropertyButton(CToolBar *ptb);
    ~PropertyButton() {}

    STDMETHODIMP GetIcon(HICON *phIcon);

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);

	CToolBar *m_pTb;
};

#endif // __PROPBUT_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\pmode.cpp ===
/****************************************************************************
   PMODE.CPP : PMode class implementation which manage conversion mode button
                  on the Cicero Toolbar

   History:
      10-JAN-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "pmode.h"
#include "gdata.h"
#include "ui.h"
#include "winex.h"
#include "resource.h"

// {9B34BF53-340A-45bd-9885-61B278EA454E}
const GUID GUID_LBI_KORIME_PMODE = 
{
    0x9b34bf53, 
    0x340a, 
    0x45bd, 
    { 0x98, 0x85, 0x61, 0xb2, 0x78, 0xea, 0x45, 0x4e }
};

/*---------------------------------------------------------------------------
    PMode::PMode
---------------------------------------------------------------------------*/
PMode::PMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    szText[0] = L'\0';
    
    m_pTb = ptb;

    // Set Add/Remove text and tootip text
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_TT_IME_PAD, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_SYSTEMLANGBARITEM_KEYBOARD, 
                GUID_LBI_KORIME_PMODE,
                TF_LBI_STYLE_BTN_BUTTON,
                230, 
                szText);
    SetToolTip(szText);

    // Set button text. Use tooltip text.
    // OurLoadStringW(vpInstData->hInst, IDS_STATUS_BUTTON_IME_PAD, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}

/*---------------------------------------------------------------------------
    PMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) PMode::Release()
{
    long cr;

    cr = --m_cRef;
    DbgAssert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    PMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI PMode::GetIcon(HICON *phIcon)
{
    DWORD dwCM   = GetCMode();
    UINT  uiIcon = IDI_CMODE_IMEPAD;
    
    *phIcon = LoadIcon(vpInstData->hInst, MAKEINTRESOURCE(uiIcon));
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    PMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI PMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    PMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI PMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT PMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{

    OurPostMessage(GetActiveUIWnd(), WM_MSIME_IMEPAD, 0, 0);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT PMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\syshelp.h ===
//
// syshelp.h
//

#ifndef _SYSHELP_H_
#define _SYSHELP_H_

#include "msctf.h"

//
// CSysHelpSink
//
typedef HRESULT (*SYSHELPINITMENU)(void *pv, ITfMenu *pMenu);
typedef HRESULT (*SYSHELPMENUSELECT)(void *pv, UINT wID);

//////////////////////////////////////////////////////////////////////////////
//
// CSysHelpSink
//
//////////////////////////////////////////////////////////////////////////////

class CSysHelpSink : public ITfSystemLangBarItemSink
{
public:
    CSysHelpSink(SYSHELPINITMENU pfnInitMenu, SYSHELPMENUSELECT pfnMenuSelect, void *pv);
    ~CSysHelpSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);

	HRESULT _Advise(ITfLangBarItemMgr *plbimgr, REFGUID rguid);
    HRESULT _Unadvise(ITfLangBarItemMgr *plbimgr);

private:
    SYSHELPINITMENU _pfnInitMenu;
    SYSHELPMENUSELECT _pfnMenuSelect;
    DWORD _dwCookie;
    void *_pv;
    GUID _guid;
    long _cRef;
};



#endif // _SYSHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IMEKOR.rc
//
#define IDS_ABOUT                       1
#define IDS_CONFIG                      2
#define IDS_PROGRAM                     3
#define IDS_DELBYJASO                   4
#define IDS_2BEOL                       5
#define IDS_3BEOL390                    6
#define IDS_3BEOLFINAL                  7
#define IDS_JUNJA                       8
#define IDS_BANJA                       9
#define IDS_HANGUL                      10
#define IDS_ENGLISH                    	11
#define IDS_STATUS_BUTTON_HAN_ENG		12
#define IDS_STATUS_BUTTON_JUN_BAN		13
#define IDS_STATUS_BUTTON_HANJA_CONV	14
#define IDS_STATUS_BUTTON_PROP			16
#define IDS_STATUS_TT_HAN_ENG           17
#define IDS_STATUS_TT_JUN_BAN           18
#define IDS_STATUS_TT_HANJA_CONV        19
#define IDS_STATUS_TT_IME_PAD           20
#define IDS_TT_DISABLE                  21
#define IDS_IME_HANGUL_FULL             22
#define IDS_IME_HANGUL_HALF             23
#define IDS_IME_ENG_FULL                24
#define IDS_IME_ENG_HALF                25
#define IDS_IME_DISABLE                 26
#define IDS_IME_TT_HANGUL_FULL          27
#define IDS_IME_TT_HANGUL_HALF          28
#define IDS_IME_TT_ENG_FULL             29
#define IDS_IME_TT_ENG_HALF             30
#define IDS_IME_TT_DISABLE              31
#define IDS_CONTEXTHELP_FILENAME        32
#define IDS_HELP_FILENAME				33
#define IDS_HELP_DISPLAYNAME			34


#define IDI_UNIKOR                      103
#define IDB_STAT_WINDOW                 104
#define TIMER_UIBUTTON                  105
#define IDB_STAT_HANGUL                 106
#define IDB_STAT_ENGLISH                107
#define IDB_STAT_BANJA                  108
#define IDB_STAT_JUNJA                  109
#define IDB_STAT_CHINESEOFF             110
#define IDB_STAT_CHINESEON              111
#define IDC_IME_HAND                    112
#define IDB_CAND_WIN                    114
#define IDB_CAND_NUM                    118
#define IDB_CAND_ARRY2                  119
#define IDB_CAND_ARRY1                  120
#define IDR_STATUS_POPUP                124
#define IDD_CONFIG_PAGE1                125
#define IDB_COMP_WIN                    131
#define IDB_STAT_ON_HANGUL              132
#define IDB_STAT_ON_ENGLISH             132
#define IDI_CM_BASE                     133
#define IDI_CM_HANGUL                   133
#define IDB_STAT_ON_JUNJA               133
#define IDI_CM_ENGLISH                  134
#define IDB_STAT_HANGUL_ONDOWN          134
#define IDB_STAT_ENGLISH_ONDOWN         134
#define IDI_CM_DISABLE                  135
#define IDB_STAT_JUNJA_ONDOWN           135
#define IDI_IME_HANGUL_HALF             139
#define IDI_IME_ENG_FULL                140
#define IDI_IME_ENG_HALF                141
#define IDI_IME_HANGUL_FULL             142
#define IDI_IME_DISABLE                 143
#define IDB_STAT_PADHWX                 157
#define IDB_STAT_IMEPAD                 157
#define IDB_STAT_IMEPAD_DOWN            158
// Cicero button Icons
#define IDI_CMODE_HANGUL				160
#define IDI_CMODE_HANGULW				161
#define IDI_CMODE_ENGLISH				162
#define IDI_CMODE_ENGLISHW				163
#define IDI_CMODE_BANJA					164
#define IDI_CMODE_BANJAW				165
#define IDI_CMODE_JUNJA					166
#define IDI_CMODE_JUNJAW				167
#define IDI_CMODE_HANJA					168
#define IDI_CMODE_HANJAW				169
#define IDI_CMODE_IMEPAD                170

#define IDC_GRP_KEYLAYOUT               1001
#define IDC_GRP_STATUSWIN               1002
#define IDC_JUNBAN_TOGGLE               1003
#define IDC_HANJA_CONV                  1004
#define IDC_2BEOLSIK                    1005
#define IDC_3BEOLSIK_390                1006
#define IDC_3BEOLSIK_FINAL              1007
#define IDC_DELJASO                     1008
#define IDC_K1HANJA                     1009
#define IDC_IMEPAD                      1010
#define IDC_IME_ICON                    1020
#define ID_CONFIG                       40001
#define ID_2BEOLSIK                     40003
#define ID_3BEOLSIK390                  40004
#define ID_3BEOLSIKFINAL                40005
#define ID_JASO_DELETION                40006
#define ID_HANGUL_MODE                  40007
#define ID_ENGLISH_MODE                 40008
#define ID_ABOUT                        40009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        159
#define _APS_NEXT_COMMAND_VALUE         40011
#define _APS_NEXT_CONTROL_VALUE         1021
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\statusui.cpp ===
/****************************************************************************
    STATUSUI.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Status window UI functions
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "ui.h"
#include "config.h"
#include "names.h"
#include "escape.h"
#include "winex.h"
#include "cpadsvr.h"
#include "debug.h"

#define ABS(A)      ((A) <  0  ? -(A) : (A))
inline BOOL IsValidButton(INT iButton)
{
    return (iButton>=0 && iButton<MAX_NUM_OF_STATUS_BUTTONS);
}

///////////////////////////////////////////////////////////////////////////////
PRIVATE VOID PASCAL FrameControl(HDC hDC, RECT* pRc, INT iState);
PRIVATE VOID PASCAL PaintStatusWindow(HWND hStatusWnd, HDC hDC);
PRIVATE BOOL StatusOnSetCursor(HWND, HWND, UINT, UINT);
PRIVATE VOID StatusOnLButtonUp(HWND, INT, INT, UINT);
PRIVATE VOID StatusOnMouseMove(HWND, INT, INT, UINT);

PRIVATE VOID PASCAL DestroyStatusWindow(HWND hStatusWnd);
PRIVATE VOID PASCAL AdjustStatusBoundary(LPPOINT lppt);
PRIVATE VOID PASCAL UpdateStatusTooltip(HWND hStatusWnd, HWND hStatusTTWnd);

PRIVATE BOOL    vfAnyButtonDown=fFalse;
PRIVATE BOOL    vfPrevButton=-1;
PRIVATE POINT vfptDown;

///////////////////////////////////////////////////////////////////////////////
struct _StatusButtonInfo 
    {
    int        m_Width, m_Height;
    WORD    m_BmpNormalID[MAX_NUM_OF_STATUS_BUTTONS];
    WORD    m_BmpOnMouseID[MAX_NUM_OF_STATUS_BUTTONS];
    WORD    m_BmpPushedID[MAX_NUM_OF_STATUS_BUTTONS];
    WORD    m_BmpDownOnMouseID[MAX_NUM_OF_STATUS_BUTTONS];
    WORD    m_ToolTipStrID[MAX_NUM_OF_STATUS_BUTTONS];
    };

static _StatusButtonInfo StatusButtonInfo[NUM_OF_BUTTON_SIZE] = 
    {
        // Small size button
        { 0, 0, },
        
        // Medium size button
        { 19, 19,  // Bitmap size
    #if !defined(_WIN64)
        // Normal buttons images
        {IDB_STAT_HANGUL,         IDB_STAT_BANJA,        IDB_STAT_CHINESEOFF,      IDB_STAT_IMEPAD}, 
        // Pushed and mouse hover images
        {IDB_STAT_ON_ENGLISH,     IDB_STAT_ON_JUNJA,     IDB_STAT_CHINESEOFF,      IDB_STAT_IMEPAD},
        // Pushed buttons
        {IDB_STAT_ENGLISH,        IDB_STAT_JUNJA,        IDB_STAT_CHINESEOFF,      IDB_STAT_IMEPAD_DOWN},
        // Pushed and mouse down images
        {IDB_STAT_ENGLISH_ONDOWN, IDB_STAT_JUNJA_ONDOWN, IDB_STAT_CHINESEOFF,      IDB_STAT_IMEPAD/*IDB_STAT_IMEPAD_DOWNHOVER*/},
        // Tooltips string
        {IDS_STATUS_TT_HAN_ENG,   IDS_STATUS_TT_JUN_BAN, IDS_STATUS_TT_HANJA_CONV, IDS_STATUS_TT_IME_PAD},
    #else
        // Normal buttons images
        {IDB_STAT_HANGUL,         IDB_STAT_BANJA,        IDB_STAT_CHINESEOFF }, 
        // Pushed and mouse hover images
        {IDB_STAT_ON_ENGLISH,     IDB_STAT_ON_JUNJA,     IDB_STAT_CHINESEOFF },
        // Pushed buttons
        {IDB_STAT_ENGLISH,        IDB_STAT_JUNJA,        IDB_STAT_CHINESEOFF },
        // Pushed and mouse down images
        {IDB_STAT_ENGLISH_ONDOWN, IDB_STAT_JUNJA_ONDOWN, IDB_STAT_CHINESEOFF },
        // Tooltips string
        {IDS_STATUS_TT_HAN_ENG,   IDS_STATUS_TT_JUN_BAN, IDS_STATUS_TT_HANJA_CONV },
    #endif
        },

        // Large size button
        { 0, 0, }
    };

void UpdateStatusButtons(CIMEData &ImeData)
{
    UINT i;
    INT iButtonSize;
    INT iButtonType;

    iButtonSize = ImeData->iCurButtonSize;

#ifdef DEBUG
    OutputDebugString(TEXT("UpdateStatusButtons():\r\n"));
#endif

    ImeData->xButtonWi = StatusButtonInfo[iButtonSize].m_Width;
    ImeData->yButtonHi = StatusButtonInfo[iButtonSize].m_Height;

    DbgAssert(ImeData->uNumOfButtons <= MAX_NUM_OF_STATUS_BUTTONS);
    for (i=0; i<ImeData->uNumOfButtons; i++) 
        {
        iButtonType = ImeData->StatusButtons[i].m_ButtonType;

        ImeData->StatusButtons[i].m_BmpNormalID  = StatusButtonInfo[iButtonSize].m_BmpNormalID[iButtonType];
        ImeData->StatusButtons[i].m_BmpOnMouseID = StatusButtonInfo[iButtonSize].m_BmpOnMouseID[iButtonType];
        ImeData->StatusButtons[i].m_BmpPushedID  = StatusButtonInfo[iButtonSize].m_BmpPushedID[iButtonType];
        ImeData->StatusButtons[i].m_BmpDownOnMouseID = StatusButtonInfo[iButtonSize].m_BmpDownOnMouseID[iButtonType];
        ImeData->StatusButtons[i].m_ToolTipStrID = StatusButtonInfo[iButtonSize].m_ToolTipStrID[iButtonType];
        // Default value is enabled
        ImeData->StatusButtons[i].m_fEnable = fTrue;
        }
}

void UpdateStatusWinDimension()
{
    CIMEData    ImeData(CIMEData::SMReadWrite);

    // Caculate status window size
    ImeData->xStatusWi =  ImeData->cxStatLeftMargin + ImeData->cxStatRightMargin
                          + ImeData->xButtonWi * ImeData->uNumOfButtons;
                          //+ ImeData->cxStatMargin*2;//62;
    ImeData->yStatusHi = ImeData->cyStatMargin*2
                          + ImeData->yButtonHi;
                          //+ pImeData->cyCaptionHeight;// + 2;
                          //+ pImeData->cyStatMargin; //24;

    // Caculate button area.
    ImeData->rcButtonArea.left   = ImeData->cxStatLeftMargin;
    ImeData->rcButtonArea.top    = ImeData->cyStatButton;
    
    ImeData->rcButtonArea.right  = ImeData->xButtonWi*ImeData->uNumOfButtons 
                                    + ImeData->rcButtonArea.left;
    ImeData->rcButtonArea.bottom = /*ImeData->cyStatMargin*2 +*/ ImeData->cyStatButton + ImeData->yButtonHi;
}


///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK StatusWndProc(HWND hStatusWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    POINT ptCursor;    

    Dbg(DBGID_UI, TEXT("StatusWndProc():uMessage = 0x%08lX, wParam = 0x%04X, lParam = 0x%08lX"), uMessage, wParam, lParam);

    switch (uMessage) 
        {
        case WM_IME_CHAR:            case WM_IME_COMPOSITIONFULL:
        case WM_IME_COMPOSITION:    case WM_IME_CONTROL:
        case WM_IME_SELECT:
        case WM_IME_SETCONTEXT:        case WM_IME_STARTCOMPOSITION:
        case WM_IME_ENDCOMPOSITION:
            return (0L);

        HANDLE_MSG(hStatusWnd, WM_SETCURSOR, StatusOnSetCursor);
        HANDLE_MSG(hStatusWnd, WM_LBUTTONUP, StatusOnLButtonUp);
        HANDLE_MSG(hStatusWnd, WM_MOUSEMOVE, StatusOnMouseMove);

        case WM_DESTROY:
            DestroyStatusWindow(hStatusWnd);
            break;

        case WM_PAINT:
            {
                HDC         hDC;
                PAINTSTRUCT ps;

                hDC = BeginPaint(hStatusWnd, &ps);
                PaintStatusWindow(hStatusWnd, hDC);
                EndPaint(hStatusWnd, &ps);
            }
            break;

        case WM_TIMER:
            {
            CIMEData    ImeData;

            GetCursorPos(&ptCursor);
            ScreenToClient(hStatusWnd, &ptCursor);
            if ( PtInRect(&ImeData->rcButtonArea, ptCursor) == fFalse )
                {
                InitButtonState();
                KillTimer( hStatusWnd, TIMER_UIBUTTON );
                InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
                }
            }
            break;
            
        default :
                return DefWindowProc(hStatusWnd, uMessage, wParam, lParam);
        }
    return (0L);
}

///////////////////////////////////////////////////////////////////////////////
// S T A T U S  W I N D O W  M S G  R O U T I N E S
BOOL StatusOnSetCursor(HWND hStatusWnd, HWND hWndCursor, UINT codeHitTest, UINT message)
{
    POINT ptCursor, ptSavCursor;
    RECT  rcWnd;
    BOOL  fDragArea = fFalse;
    int      iCurButton;
    HWND        hUIWnd;
    CIMEData       ImeData(CIMEData::SMReadWrite);

    GetCursorPos(&ptCursor);
    ptSavCursor = ptCursor;
    ScreenToClient(hStatusWnd, &ptCursor);

    Dbg(DBGID_UI, TEXT("StatusOnSetCursor():  ptCursor.x = %d, ptCursor.y = %d"), ptCursor.x, ptCursor.y);

    SetCursor(LoadCursor(NULL, IDC_ARROW));
    if (PtInRect(&ImeData->rcButtonArea, ptCursor)) 
        {
        //SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
    else 
        {
    //    SetCursor(LoadCursor(vpInstData->hInst, MAKEINTRESOURCE(IDC_IME_HAND)));
        fDragArea = fTrue;
        }

    switch (message)
        {
        case WM_LBUTTONDOWN:
            SetCapture(hStatusWnd);
            if (fDragArea) // if drag start
                {
                SystemParametersInfo(SPI_GETWORKAREA, 0, &ImeData->rcWorkArea, 0);
                SetWindowLong(hStatusWnd, UI_MOVE_XY, MAKELONG(ptSavCursor.x, ptSavCursor.y));
                GetWindowRect(hStatusWnd, &rcWnd);
                SetWindowLong(hStatusWnd, UI_MOVE_OFFSET, 
                                          MAKELONG(ptSavCursor.x - rcWnd.left, ptSavCursor.y - rcWnd.top));
                } 
            else 
                {
                InitButtonState();
                if (!ImeData->StatusButtons[(ptCursor.x-ImeData->cxStatLeftMargin)/ImeData->xButtonWi].m_fEnable)
                    {
                    ReleaseCapture();
                    break;
                    }
                vfPrevButton = (ptCursor.x-ImeData->cxStatLeftMargin)/ImeData->xButtonWi;
                vfptDown = ptSavCursor;
                ImeData->StatusButtons[vfPrevButton].m_uiButtonState = BTNSTATE_ONMOUSE | BTNSTATE_DOWN;
                vfAnyButtonDown = fTrue;
                InvalidateRect(hStatusWnd, &ImeData->rcButtonArea, fFalse);
                }

            break;

        case WM_LBUTTONUP:
//            if ((fdwUIFlags & UIF_CHIPRESS) && PtInRect((LPRECT)&rcChi, ptPos)) {
//                    keybd_event(VK_HANJA, 0, 0, 0);
//                    keybd_event(VK_HANJA, 0, KEYEVENTF_KEYUP, 0);
//                    fdwUIFlags &= ~UIF_CHIPRESS;
//            }
            break;

        case WM_RBUTTONDOWN:
            // if right button click, finalize interim
            HIMC hIMC;
    
            hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
            hIMC = GethImcFromHwnd(hUIWnd);
            if (hIMC)
                OurImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
            break;

        case WM_RBUTTONUP:
            //UIPopupMenu(GetWindow(hStatusWnd, GW_OWNER));
            OurPostMessage(GetWindow(hStatusWnd, GW_OWNER), WM_MSIME_OPENMENU, 0, 0);
            break;

        case WM_MOUSEMOVE:
            iCurButton = (ptCursor.x-ImeData->cxStatLeftMargin)/ImeData->xButtonWi;
            if (!IsValidButton(iCurButton))
                break;
                
            if (!ImeData->StatusButtons[iCurButton].m_fEnable)
                break;
                
            if (fDragArea) 
                {
                if (vfPrevButton != -1 &&
                    (ImeData->StatusButtons[vfPrevButton].m_uiButtonState & BTNSTATE_ONMOUSE))
                    {
                    ImeData->StatusButtons[vfPrevButton].m_uiButtonState &= ~BTNSTATE_ONMOUSE;
                    InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
                    }
                }
            else 
                {
                if (!(ImeData->StatusButtons[iCurButton].m_uiButtonState & BTNSTATE_ONMOUSE))
                    {
                    ImeData->StatusButtons[iCurButton].m_uiButtonState |= BTNSTATE_ONMOUSE;
                    if (vfPrevButton != -1) 
                        ImeData->StatusButtons[vfPrevButton].m_uiButtonState = BTNSTATE_NORMAL;
                    
                    vfPrevButton = iCurButton;
                    SetTimer(hStatusWnd, TIMER_UIBUTTON, 200, NULL);
                    InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
                    }
                }
            break;
        }

    if (hStatusWnd)
        {
        // Send Tooltip relay msg
        HGLOBAL            hUIPrivate;
        LPUIPRIV        lpUIPrivate;
        MSG                msg;

        hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
        hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
        if (!hUIPrivate)
            return fTrue;
        
        lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
        if (!lpUIPrivate) // can not draw candidate window
            return fTrue;
        
        if (lpUIPrivate->hStatusTTWnd) 
            {
            ZeroMemory(&msg, sizeof(MSG));
            msg.message = message;
            msg.hwnd = hStatusWnd; 
            msg.wParam = 0;
            msg.lParam = MAKELONG(ptCursor.x, ptCursor.y);
            OurSendMessage(lpUIPrivate->hStatusTTWnd, TTM_RELAYEVENT, 0, (LPARAM) (LPMSG) &msg);
            }
        
        GlobalUnlock(hUIPrivate);
        }

    return fTrue;
}

// if mouse down, and user move mouse cursor
void StatusOnMouseMove(HWND hStatusWnd, int xPos, int yPos, UINT wParam)
{
    POINT    ptCursor;
    int        iCurButton;
    RECT    rcWnd;
    LONG     lCursorOffset;
    CIMEData    ImeData(CIMEData::SMReadWrite);

    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) 
        {
        GetCursorPos(&ptCursor);
        SetWindowLong(hStatusWnd, UI_MOVE_XY, MAKELONG(ptCursor.x, ptCursor.y));

        lCursorOffset = GetWindowLong(hStatusWnd, UI_MOVE_OFFSET);

        // calculate the org by the offset
        ptCursor.x -= (*(LPPOINTS)&lCursorOffset).x;
        ptCursor.y -= (*(LPPOINTS)&lCursorOffset).y;
    
        fSetStatusWindowPos(hStatusWnd, &ptCursor);
        }
    else 
        {
        GetCursorPos(&ptCursor);
        if (vfAnyButtonDown && 
            (ABS(vfptDown.x - ptCursor.x)>3 || ABS(vfptDown.y - ptCursor.y)>3) ) 
            {
            SystemParametersInfo(SPI_GETWORKAREA, 0, &ImeData->rcWorkArea, 0);
            SetWindowLong(hStatusWnd, UI_MOVE_XY, MAKELONG(vfptDown.x, vfptDown.y));
            GetWindowRect(hStatusWnd, &rcWnd);
            SetWindowLong(hStatusWnd, UI_MOVE_OFFSET, 
                        MAKELONG(vfptDown.x - rcWnd.left, vfptDown.y - rcWnd.top));

            lCursorOffset = GetWindowLong(hStatusWnd, UI_MOVE_OFFSET);

            // calculate the org by the offset
            ptCursor.x -= (*(LPPOINTS)&lCursorOffset).x;
            ptCursor.y -= (*(LPPOINTS)&lCursorOffset).y;
    
            fSetStatusWindowPos(hStatusWnd, &ptCursor);

            InitButtonState();
            }
        else
            {
            ptCursor.x = xPos;    ptCursor.y = yPos;
            iCurButton = (ptCursor.x-ImeData->cxStatLeftMargin)/ImeData->xButtonWi;
            if (IsValidButton(iCurButton))
                {
                if (PtInRect(&ImeData->rcButtonArea, ptCursor)) 
                    {
                    if ( !(ImeData->StatusButtons[iCurButton].m_uiButtonState & BTNSTATE_ONMOUSE) ) 
                        {
                        ImeData->StatusButtons[iCurButton].m_uiButtonState |= BTNSTATE_ONMOUSE;
                        if (vfPrevButton != -1) 
                            {
                            ImeData->StatusButtons[vfPrevButton].m_uiButtonState = BTNSTATE_NORMAL;
                            vfPrevButton = iCurButton;
                            }
                        InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
                        }
                    }
                else 
                    {
                    InitButtonState();
                    InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
                    }
                }
            }
        }
}

void StatusOnLButtonUp(HWND hStatusWnd, int x, int y, UINT keyFlags)
{
    POINT    ptCursor;
    int        iCurButton;
    CIMEData    ImeData(CIMEData::SMReadWrite);

    Dbg(DBGID_UI, TEXT("StatusOnLButtonUp() : x=%d, y=%d"), x, y);
    vfAnyButtonDown = fFalse;
    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) 
        {
        Dbg(DBGID_UI, TEXT("StatusOnLButtonUp() : Dragging mode"));
        LPARAM lTmpCursor, lTmpOffset;
        
        lTmpCursor = GetWindowLong(hStatusWnd, UI_MOVE_XY);
        lTmpOffset = GetWindowLong(hStatusWnd, UI_MOVE_OFFSET);

        // calculate the org by the offset
        ptCursor.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
        ptCursor.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

        SetWindowLong(hStatusWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
        ReleaseCapture();

        fSetStatusWindowPos(hStatusWnd, &ptCursor);
        } 
    else 
        {
        Dbg(DBGID_UI, TEXT("StatusOnLButtonUp() : Non-Dragging mode. Button check"));

        ReleaseCapture();

        ptCursor.x = x;    ptCursor.y = y;
        if (!PtInRect(&ImeData->rcButtonArea, ptCursor)) 
            {
            InitButtonState();
            goto StatusOnLButtonUpExit;
            }

        iCurButton = (x-ImeData->cxStatLeftMargin)/ImeData->xButtonWi;
        if (IsValidButton(iCurButton))
            {
            ImeData->StatusButtons[vfPrevButton].m_uiButtonState &= ~BTNSTATE_DOWN;

            switch (ImeData->StatusButtons[iCurButton].m_ButtonType) 
                {
                case HAN_ENG_TOGGLE_BUTTON:
                    //if (lpIMC->fdwConversion & IME_CMODE_HANGUL)
                    //    ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
                    //fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_HANGUL;
                    //OurImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
                    keybd_event(VK_HANGUL, 0, 0, 0);
                    keybd_event(VK_HANGUL, 0, KEYEVENTF_KEYUP, 0);
                    //ImeData->StatusButtons[iCurButton].m_uiButtonState = BTNSTATE_ONMOUSE;
                    break;
                    
                case JUNJA_BANJA_TOGGLE_BUTTON:
                    //fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_FULLSHAPE;
                    //OurImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
                    keybd_event(VK_JUNJA, 0, 0, 0);
                    keybd_event(VK_JUNJA, 0, KEYEVENTF_KEYUP, 0);
                    break;
                    
                case HANJA_CONV_BUTTON:
                    //fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_HANJACONVERT;
                    keybd_event(VK_HANJA, 0, 0, 0);
                    keybd_event(VK_HANJA, 0, KEYEVENTF_KEYUP, 0);
                    break;
                    
                case IME_PAD_BUTTON:
                    OurPostMessage(GetWindow(hStatusWnd, GW_OWNER), WM_MSIME_IMEPAD, 0, 0);
                    break;

                default:
                    DbgAssert(0);    // impossible
                }
            }
        }

StatusOnLButtonUpExit:
    InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
}

///////////////////////////////////////////////////////////////////////////////
// Static functions
void PASCAL DestroyStatusWindow(HWND hStatusWnd)
{
    HWND     hUIWnd;
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate) // can not darw status window
        return;


    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) // can not draw status window
        return;
    
    lpUIPrivate->nShowStatusCmd = SW_HIDE;

    lpUIPrivate->hStatusWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

// open status window
void PASCAL OpenStatus(HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HIMC     hIMC;
    PCIMECtx pImeCtx;
    CIMEData ImeData(CIMEData::SMReadWrite);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate) // can not darw status window
        return;
    
    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) // can not draw status window
        return;

    if (ImeData->ptStatusPos.x == -1)
        GetRegValues(GETSET_REG_STATUSPOS|GETSET_REG_STATUS_BUTTONS);


    // if fail to read reg
    if (ImeData->ptStatusPos.x == -1) 
        {
        // DbgAssert(0);
        // Default position
        ImeData->ptStatusPos.x = ImeData->rcWorkArea.right - ImeData->xStatusWi;
        ImeData->ptStatusPos.y = ImeData->rcWorkArea.bottom - ImeData->yStatusHi;
        }

    hIMC = GethImcFromHwnd(hUIWnd);
    if (pImeCtx = GetIMECtx(hIMC))
        {
        // Adjust Status window position force to whithin work area
        AdjustStatusBoundary(&ImeData->ptStatusPos);
        pImeCtx->SetStatusWndPos(ImeData->ptStatusPos);
        } 

    if (lpUIPrivate->hStatusWnd) 
        {
        SetWindowPos(lpUIPrivate->hStatusWnd, 0,
                    ImeData->ptStatusPos.x, ImeData->ptStatusPos.y,
                    ImeData->xStatusWi, ImeData->yStatusHi,
                    SWP_NOACTIVATE|SWP_NOZORDER);
        } 
    else 
        {    // create status window
        lpUIPrivate->hStatusWnd = CreateWindowEx(
                                    0,
                                    szStatusClassName, TEXT("\0"),
                                    WS_POPUP|WS_DISABLED,
                                    ImeData->ptStatusPos.x, ImeData->ptStatusPos.y,
                                    ImeData->xStatusWi, ImeData->yStatusHi, 
                                    hUIWnd, (HMENU)NULL, vpInstData->hInst, NULL);

        if (!lpUIPrivate->hStatusWnd)
            goto OpenStatusUnlockUIPriv;

        SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
        SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_XY, 0L);

        // Create Tooltip window
        if (IsWinNT())
            lpUIPrivate->hStatusTTWnd = CreateWindowW(wszTooltipClassName, NULL,
                                            TTS_ALWAYSTIP|WS_DISABLED, 
                                            CW_USEDEFAULT, CW_USEDEFAULT, 
                                            CW_USEDEFAULT, CW_USEDEFAULT,
                                            lpUIPrivate->hStatusWnd, (HMENU) NULL, vpInstData->hInst, NULL);
        else
            lpUIPrivate->hStatusTTWnd = CreateWindow(szTooltipClassName, NULL,
                                            TTS_ALWAYSTIP|WS_DISABLED, 
                                            CW_USEDEFAULT, CW_USEDEFAULT, 
                                            CW_USEDEFAULT, CW_USEDEFAULT,
                                            lpUIPrivate->hStatusWnd, (HMENU) NULL, vpInstData->hInst, NULL);
    
        DbgAssert(lpUIPrivate->hStatusTTWnd != 0);
        }


    // Check if Pad button disable state
    for (UINT iButton=0; iButton<(ImeData->uNumOfButtons); iButton++)
        {
        if ((ImeData->StatusButtons[iButton].m_ButtonType == IME_PAD_BUTTON))
            {
            if ((vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON) != 0)
                ImeData->StatusButtons[iButton].m_fEnable = fFalse;
            else
                ImeData->StatusButtons[iButton].m_fEnable = fTrue;
            }
        }

    // Draw status button tooltip
    UpdateStatusTooltip(lpUIPrivate->hStatusWnd, lpUIPrivate->hStatusTTWnd);

    ShowStatus(hUIWnd, SW_SHOWNOACTIVATE);

OpenStatusUnlockUIPriv:
    GlobalUnlock(hUIPrivate);
    return;
}

// Show the status window
void ShowStatus(HWND hUIWnd, int nShowStatusCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    Dbg(DBGID_UI, TEXT("ShowStatus():  hUIWnd = 0x%X, nShowStatusCmd = %d"), hUIWnd, nShowStatusCmd);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)     // can not darw status window
        {
        DbgAssert(0);
        return;
        }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)    // can not draw status window
        {
        DbgAssert(0);
        return;
        }

    //
    if (nShowStatusCmd == SW_SHOWNOACTIVATE)
        nShowStatusCmd = vfWndOpen[STATE_WINDOW] ? SW_SHOWNOACTIVATE : SW_HIDE;

    if (!lpUIPrivate->hStatusWnd) 
        {
        // DbgAssert(0);    This occurs if IME status win hide mode
        // not in show status window mode
        } 
    else 
        if (lpUIPrivate->nShowStatusCmd == nShowStatusCmd) 
            {
            // Aleady show/hide status mode
            Dbg(DBGID_UI, TEXT("ShowStatus(): Already Show/Hide mode. No update"));
            } 
        else 
            {
            CIMEData ImeData;

            // Bug: In Win98. close/open status window msg sequence is cause problem 
            //      when IME config DLG popup
            AdjustStatusBoundary(&ImeData->ptStatusPos);            
            SetWindowPos(lpUIPrivate->hStatusWnd, 0,
                        ImeData->ptStatusPos.x, ImeData->ptStatusPos.y,
                        ImeData->xStatusWi, ImeData->yStatusHi,
                        SWP_NOACTIVATE|SWP_NOZORDER);
            ShowWindow(lpUIPrivate->hStatusWnd, nShowStatusCmd);                        
            lpUIPrivate->nShowStatusCmd = nShowStatusCmd;
            }
    
    GlobalUnlock(hUIPrivate);
    return;
}


void PASCAL FrameControl(HDC hDC, RECT* pRc, int iState)
{
    HPEN hPenHigh = 0;
    HPEN hPenShadow = 0;

    switch( iState ) 
        {
        case BTNSTATE_PUSHED:
        case BTNSTATE_HANJACONV:
            hPenHigh = CreatePen( PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW) );
            hPenShadow = CreatePen( PS_SOLID, 1, RGB(255,255,255) );
            break;
        case BTNSTATE_ONMOUSE:
            hPenHigh = CreatePen( PS_SOLID, 1, RGB(255,255,255) );
            hPenShadow = CreatePen( PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW) );
            break;
        default:
            break;
        }

    //FillRect( hDC, pRc, GetSysColorBrush(COLOR_3DFACE) );    // base
    if( iState == BTNSTATE_PUSHED || iState == BTNSTATE_ONMOUSE || iState == BTNSTATE_HANJACONV) 
        {
        HPEN hPenOld = (HPEN)SelectObject( hDC, hPenHigh );
        MoveToEx( hDC, pRc->left, pRc->bottom, NULL );
        LineTo( hDC, pRc->left, pRc->top );
        LineTo( hDC, pRc->right, pRc->top );
        SelectObject( hDC, hPenShadow );
        LineTo( hDC, pRc->right, pRc->bottom );
        LineTo( hDC, pRc->left-1, pRc->bottom );
        SelectObject( hDC, hPenOld );
        DeleteObject( hPenHigh );
        DeleteObject( hPenShadow );
        }
}

// Raster Ops
#define ROP_PSDPxax  0x00B8074AL

void PASCAL PaintStatusWindow(HWND   hStatusWnd, HDC    hDC)
{
    HWND     hUIWnd;
    HIMC     hIMC;
    PCIMECtx pImeCtx;
    //DWORD     dwCMode, dwSent;
    //BOOL     fOpen;
    UINT     uiButtonState, uiDrawButtonShape;
    //HBRUSH        hCaptionBrush;
    HBITMAP     /*hBMStatusWin, hBMOld,*/ hBMButtonOld, /*hBMClient,*/ hBMTmpButton;
    RECT     rcFrame, rcButton;//, rcCaption;
    int         ixButton, iyButton;
    CIMEData  ImeData;
    // to prevent blinking, use second buffer
    HDC         hDCMem = CreateCompatibleDC(hDC);
    HBITMAP     hBmpShow = CreateCompatibleBitmap(hDC, ImeData->xStatusWi, ImeData->yStatusHi);
    HBITMAP     hBmpOldShow = (HBITMAP)SelectObject( hDCMem, hBmpShow );
    HDC         hButtonMemDC = CreateCompatibleDC(hDC);
    LPCTSTR     lpszBtnResouceName;
    
    Dbg(DBGID_UI, TEXT("PaintStatusWindow():  hStatusWnd = 0x%X"), hStatusWnd);

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hIMC = GethImcFromHwnd(hUIWnd);
    //if (!hIMC)
    //    {
    //    DbgAssert(0);
    //    return;
    //    }

    if ((pImeCtx = GetIMECtx(hIMC))==NULL)
        return;

    // Get conversion and open status and
    // fOpen = OurImmGetOpenStatus(hIMC);
    // OurImmGetConversionStatus(hIMC, &dwCMode, &dwSent);

    // Draw Frame
    GetClientRect( hStatusWnd, &rcFrame );
    DbgAssert(ImeData->xStatusWi == rcFrame.right);
    FillRect(hDCMem, &rcFrame, GetSysColorBrush(COLOR_3DFACE));
    DrawEdge(hDCMem, &rcFrame, EDGE_RAISED, BF_RECT);

#if NOTUSED
    // Draw left two verticals
    ::SetRect(&rcButton, 2, ImeData->cyStatMargin-1, 4, ImeData->yStatusHi - ImeData->cyStatMargin);
    FrameControl(hDCMem, &rcButton, BTNSTATE_ONMOUSE);
    ::SetRect(&rcButton, 6, ImeData->cyStatMargin-1, 8, ImeData->yStatusHi - ImeData->cyStatMargin);
    FrameControl(hDCMem, &rcButton, BTNSTATE_ONMOUSE);
#endif

    // Button 1 : This button Always Han/Eng toggle button.
    ixButton = ImeData->cxStatLeftMargin; iyButton = ImeData->cyStatButton;

    for (UINT iButton=0; iButton<ImeData->uNumOfButtons; iButton++) 
        {
        uiButtonState = ImeData->StatusButtons[iButton].m_uiButtonState;
        uiDrawButtonShape = BTNSTATE_NORMAL;

        switch (ImeData->StatusButtons[iButton].m_ButtonType) 
            {
        case HAN_ENG_TOGGLE_BUTTON :
            // if English mode
            if (!(pImeCtx->GetConversionMode() & IME_CMODE_HANGUL))
                {
                // English button always pushed
                uiDrawButtonShape = BTNSTATE_PUSHED;
                // Down and hovering
                if (uiButtonState  & BTNSTATE_DOWN)  // if BTNSTATE_DOWN set, always BTNSTATE_ONMOUSE set too
                    lpszBtnResouceName = // Dented white gray GA
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpDownOnMouseID);
                else
                // If just mouse cursor hovering
                if (uiButtonState & BTNSTATE_ONMOUSE) 
                    {
                    lpszBtnResouceName = // Dented white gray GA
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpOnMouseID);
                    }
                // No mouse
                else
                    lpszBtnResouceName = // Dented gray GA
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                }
            else 
                {
                // Down and hovering
                if (uiButtonState & BTNSTATE_DOWN) // if BTNSTATE_DOWN set, always BTNSTATE_ONMOUSE set too
                    {
                    uiDrawButtonShape = BTNSTATE_PUSHED;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                    }
                else
                    {
                    // Down or hovering
                    if (uiButtonState & BTNSTATE_ONMOUSE)
                        uiDrawButtonShape = BTNSTATE_ONMOUSE;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpNormalID);
                    }
                }
            break;

        case JUNJA_BANJA_TOGGLE_BUTTON:
            if (pImeCtx->IsOpen() && (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE)) 
                {
                uiDrawButtonShape = BTNSTATE_PUSHED;
                if (uiButtonState  & BTNSTATE_DOWN) // if BTNSTATE_DOWN set, always BTNSTATE_ONMOUSE set too
                    lpszBtnResouceName = // Dented white gray GA
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpDownOnMouseID);
                else
                if (uiButtonState & BTNSTATE_ONMOUSE)
                    lpszBtnResouceName = 
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpOnMouseID);
                else
                    lpszBtnResouceName = 
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                }
            else 
                {
                if (uiButtonState & BTNSTATE_DOWN) 
                    {
                    uiDrawButtonShape = BTNSTATE_PUSHED;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                    }
                else 
                    {
                    if (uiButtonState & BTNSTATE_ONMOUSE)
                        uiDrawButtonShape = BTNSTATE_ONMOUSE;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpNormalID);
                    }
                }
            break;

        case HANJA_CONV_BUTTON:
            if ((pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)) 
                {
                uiDrawButtonShape = BTNSTATE_PUSHED;
                if (uiButtonState & BTNSTATE_ONMOUSE)
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpOnMouseID);
                else
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                }
            else 
                {
                if (uiButtonState & BTNSTATE_DOWN) 
                    {
                    uiDrawButtonShape = BTNSTATE_PUSHED;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                    }
                else 
                    {
                    if (uiButtonState & BTNSTATE_ONMOUSE)
                        uiDrawButtonShape = BTNSTATE_ONMOUSE;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpNormalID);
                    }
                }
            break;
            
        case IME_PAD_BUTTON:
            LPCImePadSvr lpCImePadSvr;
            BOOL fVisible;

            lpCImePadSvr = CImePadSvr::GetCImePadSvr();
            fVisible = fFalse;

            if (lpCImePadSvr) 
                lpCImePadSvr->IsVisible(&fVisible);

            if (lpCImePadSvr && fVisible)
                {
                uiDrawButtonShape = BTNSTATE_PUSHED;
                if (uiButtonState & BTNSTATE_ONMOUSE)
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpOnMouseID);
                else
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                }
            else
                {
                if (uiButtonState & BTNSTATE_DOWN) 
                    {
                    uiDrawButtonShape = BTNSTATE_PUSHED;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                    }
                else
                    {
                    if (uiButtonState & BTNSTATE_ONMOUSE)
                        uiDrawButtonShape = BTNSTATE_ONMOUSE;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpNormalID);
                    }
                }
            break;
        
        default:
            DbgAssert(0);
            }

        // use LoadImage instead LoadBitmap to change button face color according to system setting
        // LR_LOADMAP3DCOLORS flag does it.
        hBMTmpButton = (HBITMAP)OurLoadImage(lpszBtnResouceName, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );
        hBMButtonOld = (HBITMAP)SelectObject(hButtonMemDC, hBMTmpButton);

        if (ImeData->StatusButtons[iButton].m_fEnable)
            {
            if (   ImeData->StatusButtons[iButton].m_uiButtonState==BTNSTATE_PUSHED 
                || ImeData->StatusButtons[iButton].m_uiButtonState==BTNSTATE_HANJACONV) 
                {
                BitBlt(hDCMem, ixButton+1, iyButton+1, ImeData->xButtonWi, ImeData->yButtonHi, hButtonMemDC, 0, 0, SRCCOPY);
                }
            else
                BitBlt(hDCMem, ixButton, iyButton, ImeData->xButtonWi, ImeData->yButtonHi, hButtonMemDC, 0, 0, SRCCOPY);
            }
        else
            {
            BITMAP  bmp;
            HDC    hDCMono;
            HBITMAP hBmpMono, hBmpOldMono;
            HBRUSH hBr, hOldBr;

            GetObject(hBMTmpButton, sizeof(BITMAP), &bmp);
            // mono bitmap
            hDCMono     = CreateCompatibleDC(hDC);
            hBmpMono   = CreateBitmap(bmp.bmWidth/*-2*/, bmp.bmHeight/*-2*/, 1, 1, NULL);
            hBmpOldMono = (HBITMAP)SelectObject(hDCMono, hBmpMono);

            // initalize whole area with 0's
            PatBlt(hDCMono, 0, 0,  bmp.bmWidth-2,  bmp.bmHeight-2, WHITENESS);

            SetBkColor(hButtonMemDC, GetSysColor(COLOR_3DFACE));
            BitBlt(hDCMono, 0, 0,  bmp.bmWidth,  bmp.bmHeight, hButtonMemDC, 0, 0, SRCCOPY);
            
            SetBkColor(hButtonMemDC, GetSysColor(COLOR_3DHILIGHT));
            // OR in the new 1's
            BitBlt(hDCMono, 0, 0, bmp.bmWidth,  bmp.bmHeight, hButtonMemDC, 0, 0, SRCPAINT);

            // - mask proc end
            SetTextColor(hDCMem, 0L);                  // 0's in mono -> 0 (for ROP)
            SetBkColor(hDCMem, (COLORREF)0x00FFFFFFL); // 1's in mono -> 1

            // disabled - draw the hilighted shadow
            hBr    = GetSysColorBrush(COLOR_3DHILIGHT);
            hOldBr = (HBRUSH)SelectObject(hDCMem, hBr);
            if (hBr && hOldBr)
                {
                // draw hilight color where we have 0's in the mask
                BitBlt(hDCMem, ixButton, iyButton, ImeData->xButtonWi, ImeData->yButtonHi, hDCMono, 0, 0, ROP_PSDPxax);
                SelectObject(hDCMem, hOldBr);
                DeleteObject(hBr);
                }

            hBr    = GetSysColorBrush(COLOR_3DSHADOW);
            hOldBr = (HBRUSH)SelectObject(hDCMem, hBr);
            if (hBr && hOldBr)
                {
                // draw the shadow color where we have 0's in the mask
                BitBlt(hDCMem, ixButton-1, iyButton-1, ImeData->xButtonWi, ImeData->yButtonHi, hDCMono, 0, 0, ROP_PSDPxax);
                SelectObject(hDCMem, hOldBr);
                DeleteObject(hBr);
                }

            if (hBmpMono) 
                {
                SelectObject(hDCMono, hBmpOldMono);
                DeleteObject(hBmpMono);
                DeleteDC(hDCMono);
                }
            }
        
        SelectObject(hButtonMemDC, hBMButtonOld);
        DeleteObject(hBMTmpButton);
        //
        ::SetRect(&rcButton, ixButton, iyButton, ixButton+ImeData->xButtonWi-1, iyButton+ImeData->yButtonHi-1);
        FrameControl(hDCMem, &rcButton, uiDrawButtonShape);
        //
        ixButton += ImeData->xButtonWi;
        }

    BitBlt(hDC, 0, 0, ImeData->xStatusWi, ImeData->yStatusHi, hDCMem, 0, 0, SRCCOPY);

    DeleteObject(hButtonMemDC);
    SelectObject(hDCMem, hBmpOldShow);
    DeleteObject(hDCMem);
    DeleteObject(hBmpShow);
}

void PASCAL AdjustStatusBoundary(LPPOINT lppt)
{
    CIMEData    ImeData(CIMEData::SMReadWrite);
#if 1 // MultiMonitor support
    RECT rcWorkArea;//, rcMonitorWorkArea;

        {
        RECT rcStatusWnd;

        *(LPPOINT)&rcStatusWnd = *lppt;

        rcStatusWnd.right = rcStatusWnd.left + ImeData->xStatusWi;
        rcStatusWnd.bottom = rcStatusWnd.top + ImeData->yStatusHi;

        ImeMonitorWorkAreaFromRect(&rcStatusWnd, &rcWorkArea);
        }

    // display boundary check
    if (lppt->x < rcWorkArea.left) 
        lppt->x = rcWorkArea.left;
    else 
        if (lppt->x + ImeData->xStatusWi > rcWorkArea.right) 
        lppt->x = (rcWorkArea.right - ImeData->xStatusWi);

    if (lppt->y < rcWorkArea.top)
        lppt->y = rcWorkArea.top;
    else 
        if (lppt->y + ImeData->yStatusHi + 1 > rcWorkArea.bottom)
            lppt->y = rcWorkArea.bottom - ImeData->yStatusHi + 1;
    
    //rcMonitorWorkArea = rcWorkArea;
    //OffsetRect(&rcMonitorWorkArea, -rcMonitorWorkArea.left, -rcMonitorWorkArea.top);
    //DbgAssert(rcMonitorWorkArea.right!=0);
    //DbgAssert(rcMonitorWorkArea.bottom!=0);
    if (rcWorkArea.right-rcWorkArea.left != 0)
        ImeData->xStatusRel = ( ((long)(lppt->x+ImeData->xStatusWi-rcWorkArea.left))<<16 ) 
                                / (rcWorkArea.right-rcWorkArea.left);
    if (rcWorkArea.bottom-rcWorkArea.top != 0)
        ImeData->yStatusRel = ( ((long)(lppt->y+ImeData->yStatusHi-rcWorkArea.top))<<16 ) 
                                / (rcWorkArea.bottom-rcWorkArea.top);

#else
    // display boundary check
    if (lppt->x < ImeData->rcWorkArea.left)
        lppt->x = ImeData->rcWorkArea.left;
    else 
        if (lppt->x + ImeData->xStatusWi > ImeData->rcWorkArea.right)
        lppt->x = (ImeData->rcWorkArea.right - ImeData->xStatusWi);

    if (lppt->y < ImeData->rcWorkArea.top) 
        lppt->y = ImeData->rcWorkArea.top;
    else 
        if (lppt->y + ImeData->yStatusHi > ImeData->rcWorkArea.bottom)
            lppt->y = (ImeData->rcWorkArea.bottom - ImeData->yStatusHi);
#endif

    return;
}

BOOL fSetStatusWindowPos(HWND hStatusWnd, POINT *ptStatusWndPos)
{
    HWND     hUIWnd;
    HIMC     hIMC;
    PCIMECtx pImeCtx;
    // LPINPUTCONTEXT     lpIMC;
    POINT     ptCtxStatusWnd;
    RECT     rcStatusWnd;
    CIMEData ImeData(CIMEData::SMReadWrite);

    Dbg(DBGID_UI, TEXT("fSetStatusWindowPos(): hStatusWnd=0x%X, ptStatusWndPos = 0x%08lX"), hStatusWnd, ptStatusWndPos);

    DbgAssert(hStatusWnd != 0);
    if (hStatusWnd == 0)
        {
        DbgAssert(0);
        return fFalse;
        }
        
    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    GetWindowRect(hStatusWnd, &rcStatusWnd);

    hIMC = GethImcFromHwnd(hUIWnd);
    //if (hIMC == 0)
    //    {
    //    DbgAssert(0);
    //    return fFalse;
    //    }

    //lpIMC = (LPINPUTCONTEXT)OurImmLockIMC(hIMC);
    //if (lpIMC == 0)
    //    {
    //    DbgAssert(0);
    //    return fFalse;
    //    }

    if ((pImeCtx = GetIMECtx(hIMC))==NULL)
        return fFalse;

    pImeCtx->GetStatusWndPos(&ptCtxStatusWnd);
    // if ptStatusWndPos is NULL, Set current IMC value
    // IMN_SETSTATUSWINDOWPOS
    if (ptStatusWndPos == NULL)    
        {
        if (   ptCtxStatusWnd.x != rcStatusWnd.left 
            || ptCtxStatusWnd.y != rcStatusWnd.top) 
            {   
            // display boundary adjust
            AdjustStatusBoundary(&ptCtxStatusWnd);
            ImeData->ptStatusPos = ptCtxStatusWnd;
            }
        }
    else    // Set ptStatusWndPos to IMC. StatusOnLButtonUp() 
        {
        if (   ptStatusWndPos->x != rcStatusWnd.left 
            || ptStatusWndPos->y != rcStatusWnd.top) 
            {   
            // display boundary adjust
            AdjustStatusBoundary(ptStatusWndPos);
            ImeData->ptStatusPos = *ptStatusWndPos;
            pImeCtx->SetStatusWndPos(*ptStatusWndPos);
            }
        }

    ///////////////////////////////////////////////////////////////////////////
    SetWindowPos(hStatusWnd, 0,
                ImeData->ptStatusPos.x, ImeData->ptStatusPos.y,
                0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    // Set reg value
    SetRegValues(GETSET_REG_STATUSPOS);
    
    return (fTrue);
}


void InitButtonState()
{
    CIMEData    ImeData(CIMEData::SMReadWrite);
    for (int i=0; i<MAX_NUM_OF_STATUS_BUTTONS;i++)
        ImeData->StatusButtons[i].m_uiButtonState = BTNSTATE_NORMAL;
    vfPrevButton = -1;
}

void StatusDisplayChange(HWND hUIWnd)
{
    RECT     rcMonitorWorkArea, rcMonitorWorkArea2;
    POINT    ptNewStatus;
    HIMC     hIMC;
    PCIMECtx pImeCtx;
    CIMEData ImeData;

    hIMC = GethImcFromHwnd(hUIWnd);
    //if (hIMC == 0)
    //    {
    //    DbgAssert(0);
    //    return;
    //    }

    //lpIMC = OurImmLockIMC(hIMC);

    if ((pImeCtx = GetIMECtx(hIMC))==NULL)
        return;

    // If still not initialized, skip status win pos adjust.
    if (ImeData->ptStatusPos.x == -1)
        return;
        
    ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcMonitorWorkArea);
    
    rcMonitorWorkArea2 = rcMonitorWorkArea;
    OffsetRect(&rcMonitorWorkArea2, -rcMonitorWorkArea2.left, -rcMonitorWorkArea2.top);
    ptNewStatus.x = ((rcMonitorWorkArea2.right * ImeData->xStatusRel + 0x8000)>>16) + rcMonitorWorkArea.left
                    -ImeData->xStatusWi;
    if (ptNewStatus.x < 0)
        ptNewStatus.x = 0;
    ptNewStatus.y = ((rcMonitorWorkArea2.bottom * ImeData->yStatusRel + 0x8000)>>16) + rcMonitorWorkArea.top
                    -ImeData->yStatusHi;
    if (ptNewStatus.y < 0)
        ptNewStatus.y = 0;

    Dbg(DBGID_UI, TEXT("StatusDisplayChange() : xStatusRel = %d, yStatusRel=%d, newX=%d, newY=%d"),  (int)(ImeData->xStatusRel), (int)(ImeData->yStatusRel), ptNewStatus.x, ptNewStatus.y);
    ImeData->ptStatusPos = ptNewStatus;
    SetRegValues(GETSET_REG_STATUSPOS);
}


void PASCAL UpdateStatusTooltip(HWND hStatusWnd, HWND hStatusTTWnd)
{
    TOOLINFO    ti;
    CHAR        szTooltip[80];
    WCHAR        wszTooltip[80];
    CIMEData    ImeData;
    UINT         uiMsgAdd = TTM_ADDTOOLW;

    if (IsWin(hStatusWnd) && IsWin(hStatusTTWnd))
        {
        ZeroMemory(&ti, sizeof(TOOLINFO));
        ti.cbSize = sizeof(TOOLINFO);
        ti.uFlags = 0;
        ti.hwnd = hStatusWnd;
        ti.hinst = vpInstData->hInst;

        //
        ti.rect.left   = ImeData->cxStatLeftMargin; 
        ti.rect.right  = ti.rect.left + ImeData->xButtonWi;
        ti.rect.top    = ImeData->cyStatButton;
        ti.rect.bottom = ti.rect.top  + ImeData->yButtonHi;

        if (!IsWinNT())
            uiMsgAdd = TTM_ADDTOOL;
            
        // Set Button text
        for (UINT i=0; i<ImeData->uNumOfButtons; i++) 
            {
            ti.uId = i;

            if (IsWinNT())
                {
                OurLoadStringW(vpInstData->hInst, ImeData->StatusButtons[i].m_ToolTipStrID, 
                               wszTooltip, sizeof(wszTooltip)/sizeof(WCHAR));
                ti.lpszText = (LPSTR)wszTooltip;
                }
            else
                {
                OurLoadStringA(vpInstData->hInst, ImeData->StatusButtons[i].m_ToolTipStrID, 
                               szTooltip, sizeof(szTooltip)/sizeof(CHAR));
                ti.lpszText = szTooltip;
                }
                
            OurSendMessage(hStatusTTWnd, uiMsgAdd, 0, (LPARAM)(LPTOOLINFO)&ti);    

            // Next Button area
            ti.rect.left += ImeData->xButtonWi;
            ti.rect.right += ImeData->xButtonWi;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\syshelp.cpp ===
//
// syshelp.cpp
//

#include "precomp.h"
#include "syshelp.h"

#define SAFECASTLOCAL(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))
#define SafeReleaseLocal(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
    }                           \
}
#define SafeReleaseLocalClear(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
        punk = NULL;            \
    }                           \
}



STDAPI CSysHelpSink::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;
    
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfSystemLangBarItemSink))
    {
        *ppvObj = SAFECASTLOCAL(this, ITfSystemLangBarItemSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CSysHelpSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CSysHelpSink::Release()
{
    long cr;

    cr = --_cRef;

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSysHelpSink::CSysHelpSink(SYSHELPINITMENU pfnInitMenu, SYSHELPMENUSELECT pfnMenuSelect, void *pv)
{
    _pfnInitMenu = pfnInitMenu;
    _pfnMenuSelect = pfnMenuSelect;
    _pv = pv;
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSysHelpSink::~CSysHelpSink()
{
}

//+---------------------------------------------------------------------------
//
// Advise
//
//----------------------------------------------------------------------------

HRESULT CSysHelpSink::_Advise(ITfLangBarItemMgr *plbimgr, REFGUID rguid)
{
    HRESULT hr;
    ITfSource *source = NULL;
    ITfLangBarItem *plbi = NULL;

    hr = E_FAIL;

    if (plbimgr == NULL) {
        goto Exit;
    }

    if (plbimgr->GetItem(rguid, &plbi) != S_OK)
        goto Exit;

    // Satori#3713 ; plbi can be NULL
    if (plbi == NULL) {
        goto Exit;
    }

    if (FAILED(plbi->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfSystemLangBarItemSink, this, &_dwCookie)))
        goto Exit;

    hr = S_OK;
    _guid = rguid;

Exit:
    SafeReleaseLocal(source);
    SafeReleaseLocal(plbi);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Unadvise
//
//----------------------------------------------------------------------------

HRESULT CSysHelpSink::_Unadvise(ITfLangBarItemMgr *plbimgr)
{
    HRESULT hr;
    ITfSource *source = NULL;
    ITfLangBarItem *plbi = NULL;

    hr = E_FAIL;

    if (FAILED(plbimgr->GetItem(_guid, &plbi)))
        goto Exit;

    // Satori#3713 ; plbi can be NULL
    if (plbi == NULL) {
        goto Exit;
    }

    if (FAILED(plbi->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeReleaseLocal(source);
    SafeReleaseLocal(plbi);
    return hr;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CSysHelpSink::InitMenu(ITfMenu *pMenu)
{
    return _pfnInitMenu(_pv, pMenu);
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CSysHelpSink::OnMenuSelect(UINT wID)
{
    return _pfnMenuSelect(_pv, wID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\toolbar.h ===
//
//  TOOLBAR.H
//
//  History:
//      29-MAY-2000 CSLIM Adapted to IME
//      24-JAN-2000 CSLIM Created

#if !defined (__TOOLBAR_H__INCLUDED_)
#define __TOOLBAR_H__INCLUDED_

#include "imc.h"

class CMode;
class FMode;
class HJMode;
class PMode;
class PropertyButton;
class CSysHelpSink;

#define UPDTTB_NONE		0x00000000
#define UPDTTB_CMODE	0x00000001
#define UPDTTB_FHMODE	0x00000002  // Full/Half shape mode
#define UPDTTB_HJMODE	0x00000004  // Hanja mode
#define UPDTTB_PAD		0x00000008  // Pad button
#define UPDTTB_PROP		0x00000010  // Properties button

#define UPDTTB_ALL (UPDTTB_CMODE|UPDTTB_FHMODE|UPDTTB_HJMODE|UPDTTB_PAD|UPDTTB_PROP)

class CToolBar
{
public:
	CToolBar();
	~CToolBar();

	BOOL Initialize();
	void Terminate();

	void CheckEnable();
	void SetCurrentIC(PCIMECtx pImeCtx);

	DWORD SetConversionMode(DWORD dwConvMod);
	DWORD GetConversionMode(PCIMECtx pImeCtx = NULL);
//	UINT  GetConversionModeIDI(PCIMECtx pImeCtx = NULL);

	BOOL Update(DWORD dwUpdate = UPDTTB_NONE, BOOL fRefresh = fFalse);

	BOOL IsOn(PCIMECtx pImeCtx = NULL);
	BOOL SetOnOff(BOOL fOn);

	PCIMECtx GetImeCtx()	{ return m_pImeCtx;	}
	HWND GetOwnerWnd(PCIMECtx pImeCtx = NULL);

	// Syshelp callback (Cicero)
	static HRESULT SysInitMenu(void *pv, ITfMenu* pMenu);
	static HRESULT OnSysMenuSelect(void *pv, UINT uiCmd);

private:
	PCIMECtx m_pImeCtx;

	BOOL			  m_fToolbarInited;
	CMode  	 		  *m_pCMode;
	FMode  	 		  *m_pFMode;
	HJMode 	 		  *m_pHJMode;
#if !defined(_WIN64)
	PMode  	 		  *m_pPMode;
#endif
	CSysHelpSink       *m_pSysHelp;

	CMode *GetCMode()		{ return m_pCMode;  }
	FMode *GetFMode()		{ return m_pFMode;  }
	HJMode *GetHJMode()		{ return m_pHJMode; }
#if !defined(_WIN64)
	PMode  *GetPMode()      { return m_pPMode;  }
#endif
};

#endif	// __TOOLBAR_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\toolbar.cpp ===
/****************************************************************************
   TOOLBAR.CPP : Cicero Toolbar button management class

   History:
      24-JAN-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "common.h"
#include "cicero.h"
#include "cmode.h"
#include "fmode.h"
#include "hjmode.h"
#include "pmode.h"
#include "toolbar.h"
#include "ui.h"
#include "syshelp.h"
#include "winex.h"

/*---------------------------------------------------------------------------
    CToolBar::CToolBar
    Ctor
---------------------------------------------------------------------------*/
CToolBar::CToolBar()
{
    m_fToolbarInited = fFalse;
    m_pImeCtx        = NULL;
    m_pCMode         = NULL;
    m_pFMode         = NULL;
    m_pHJMode        = NULL;
#if !defined(_WIN64)
    m_pPMode         = NULL;
#endif
    m_pSysHelp       = NULL;
}

/*---------------------------------------------------------------------------
    CToolBar::~CToolBar
    Dtor
---------------------------------------------------------------------------*/
CToolBar::~CToolBar()
{
    m_pImeCtx = NULL;
}

/*---------------------------------------------------------------------------
    CToolBar::Initialize
    
    Initialize Toolbar buttons. Add to Cic main toolbar.
---------------------------------------------------------------------------*/
BOOL CToolBar::Initialize()
{
    ITfLangBarMgr     *pLMgr     = NULL;
    ITfLangBarItemMgr *pLItemMgr = NULL;
    DWORD              dwThread  = 0;
    HRESULT            hr;

    if (IsCicero() == fFalse)
        return fFalse;    // do nothing

    if (m_fToolbarInited) // already made it
        return fTrue;    // do nothing
        
    // initialization
    if (FAILED(Cicero_CreateLangBarMgr(&pLMgr)))
        return fFalse; // error to create a object

    // Get Lang bar manager
    if (FAILED(pLMgr->GetThreadLangBarItemMgr(GetCurrentThreadId(), &pLItemMgr, &dwThread)))
        {
        pLMgr->Release();
        DbgAssert(0);
        return fFalse; // error to create a object
        }

    // no need it.
    pLMgr->Release();

    //////////////////////////////////////////////////////////////////////////
    // Create Han/Eng toggle button
    if (!(m_pCMode = new CMode(this))) 
        {
        hr = E_OUTOFMEMORY;
        return fFalse;
        }
    pLItemMgr->AddItem(m_pCMode);

    //////////////////////////////////////////////////////////////////////////
    // Create Full/Half shape toggle button
    if (!(m_pFMode = new FMode(this))) 
        {
        hr = E_OUTOFMEMORY;
        return fFalse;
        }
    pLItemMgr->AddItem(m_pFMode);

    //////////////////////////////////////////////////////////////////////////
    // Create Hanja Conv button
    if (!(m_pHJMode = new HJMode(this))) 
        {
        hr = E_OUTOFMEMORY;
        return fFalse;
        }
    pLItemMgr->AddItem(m_pHJMode);

#if !defined(_WIN64)
    //////////////////////////////////////////////////////////////////////////
    // Create IME Pad button
    if (IsWin64() == fFalse)
    	{
	    if (!(m_pPMode = new PMode(this))) 
	        {
	        hr = E_OUTOFMEMORY;
	        return fFalse;
	        }
	    pLItemMgr->AddItem(m_pPMode);
    	}
#endif

    // Update all button
    CheckEnable();
    m_pCMode->UpdateButton();
    m_pFMode->UpdateButton();
    m_pHJMode->UpdateButton();
#if !defined(_WIN64)
    if (IsWin64() == fFalse)
	    m_pPMode->UpdateButton();
#endif
    // SYSHelp support
    m_pSysHelp = new CSysHelpSink(SysInitMenu, OnSysMenuSelect, (VOID*)this);
    if (m_pSysHelp && pLItemMgr)
        m_pSysHelp->_Advise(pLItemMgr, GUID_LBI_HELP);

    m_fToolbarInited = fTrue;
    
    return fTrue;
}

/*---------------------------------------------------------------------------
    CToolBar::CheckEnable
---------------------------------------------------------------------------*/
void CToolBar::CheckEnable()
{
    if (m_pCMode == NULL || m_pFMode == NULL || m_pHJMode == NULL)
        return;

#if !defined(_WIN64)
	if ((IsWin64() == fFalse) && m_pPMode == NULL)
		return;
#endif

    if (m_pImeCtx == NULL) // empty or disabled(exclude cand ui)
        {
        m_pCMode->Enable(fFalse);
        m_pFMode->Enable(fFalse);
        m_pHJMode->Enable(fFalse);
#if !defined(_WIN64)
	    if (IsWin64() == fFalse)
        	m_pPMode->Enable(fFalse);
#endif
        }
    else
        {
        m_pCMode->Enable(fTrue);
        m_pFMode->Enable(fTrue);
        m_pHJMode->Enable(fTrue);
#if !defined(_WIN64)
	    if (IsWin64() == fFalse)
    	   m_pPMode->Enable(fTrue);
#endif
        }
}
/*---------------------------------------------------------------------------
    CToolBar::SetCurrentIC
---------------------------------------------------------------------------*/
void CToolBar::SetCurrentIC(PCIMECtx pImeCtx)
{
    m_pImeCtx = pImeCtx;

    CheckEnable();    // enable or disable context

    // changed context - update all toolbar buttons
    Update(UPDTTB_ALL, fTrue);
}

/*---------------------------------------------------------------------------
    CToolBar::Terminate
    
    Delete toolbar buttonsfrom Cic main toolbar.
---------------------------------------------------------------------------*/
void CToolBar::Terminate()
{
    ITfLangBarMgr     *pLMgr     = NULL;
    ITfLangBarItemMgr *pLItemMgr = NULL;
    DWORD              dwThread  = 0;

    if (IsCicero() && m_fToolbarInited)
        {
        // initialization
        if (FAILED(Cicero_CreateLangBarMgr(&pLMgr)))
            return; // error to create a object

        if (FAILED(pLMgr->GetThreadLangBarItemMgr(GetCurrentThreadId(), &pLItemMgr, &dwThread)))
            {
            pLMgr->Release();
            DbgAssert(0);
            return; // error to create a object
            }

        // no need it.
        pLMgr->Release();

#if !defined(_WIN64)
        if (m_pPMode && (IsWin64() == fFalse)) 
            {
            pLItemMgr->RemoveItem(m_pPMode);
            SafeReleaseClear(m_pPMode);
            }
#endif
        if (m_pHJMode) 
            {
            pLItemMgr->RemoveItem(m_pHJMode);
            SafeReleaseClear(m_pHJMode);
            }
        
        if (m_pFMode) 
            {
            pLItemMgr->RemoveItem(m_pFMode);
            SafeReleaseClear(m_pFMode);
            }

        if (m_pCMode) 
            {
            pLItemMgr->RemoveItem(m_pCMode);
            SafeReleaseClear(m_pCMode);
            }

        // Release Syshelp
        if (m_pSysHelp)
            {
            m_pSysHelp->_Unadvise(pLItemMgr);
            SafeReleaseClear(m_pSysHelp);
            }

        pLItemMgr->Release();

        //Toolbar uninited.
        m_fToolbarInited = fFalse;
        }
}

/*---------------------------------------------------------------------------
    CToolBar::SetConversionMode
    
    Foward the call to CKorIMX
---------------------------------------------------------------------------*/
DWORD CToolBar::SetConversionMode(DWORD dwConvMode)
{
    if (m_pImeCtx)
        return m_pImeCtx->SetConversionMode(dwConvMode);

    return 0;
}

/*---------------------------------------------------------------------------
    CToolBar::GetConversionMode

    Foward the call to CKorIMX
---------------------------------------------------------------------------*/
DWORD CToolBar::GetConversionMode(PCIMECtx pImeCtx)
{
    if (pImeCtx == NULL)
        pImeCtx = m_pImeCtx;
        
    if (pImeCtx)
        return pImeCtx->GetConversionMode();

    return 0;
}

/*---------------------------------------------------------------------------
    CToolBar::IsOn

    Foward the call to CKorIMX
---------------------------------------------------------------------------*/
BOOL CToolBar::IsOn(PCIMECtx pImeCtx)
{
    if (pImeCtx == NULL)
        pImeCtx = m_pImeCtx;

    if (pImeCtx)
        return pImeCtx->IsOpen();

    return fFalse;
}

/*---------------------------------------------------------------------------
    CToolBar::SetOnOff

    Foward the call to CKorIMX
---------------------------------------------------------------------------*/
BOOL CToolBar::SetOnOff(BOOL fOn)
{
    if (m_pImeCtx) 
        {
        m_pImeCtx->SetOpen(fOn);
        return fOn;
        }
        
    return fFalse;
}

/*---------------------------------------------------------------------------
    CToolBar::GetOwnerWnd

    Foward the call to CKorIMX
---------------------------------------------------------------------------*/
HWND CToolBar::GetOwnerWnd(PCIMECtx pImeCtx)
{
#if 0
    if (pImeCtx == NULL)
        pImeCtx = m_pImeCtx;

    if (pImeCtx)
        return pImeCtx->GetUIWnd();

    return 0;
#endif
    return GetActiveUIWnd();
}

/*---------------------------------------------------------------------------
    CToolBar::GetOwnerWnd

    Update buttons. dwUpdate has update bits corresponding each button.
---------------------------------------------------------------------------*/
BOOL CToolBar::Update(DWORD dwUpdate, BOOL fRefresh)
{
    DWORD dwFlag = TF_LBI_BTNALL;

    if (!IsCicero())
        return fTrue;
        
    if (fRefresh)
        dwFlag |= TF_LBI_STATUS;

    if ((dwUpdate & UPDTTB_CMODE) && m_pCMode && m_pCMode->GetSink())
        m_pCMode->GetSink()->OnUpdate(dwFlag);

    if ((dwUpdate & UPDTTB_FHMODE) && m_pFMode && m_pFMode->GetSink())
        m_pFMode->GetSink()->OnUpdate(dwFlag);

    if ((dwUpdate & UPDTTB_HJMODE) && m_pHJMode && m_pHJMode->GetSink())
        m_pHJMode->GetSink()->OnUpdate(dwFlag);

#if !defined(_WIN64)
    if ((dwUpdate & UPDTTB_PAD) && m_pPMode && m_pPMode->GetSink())
        m_pPMode->GetSink()->OnUpdate(dwFlag);
#endif

    return fTrue;
}

/*---------------------------------------------------------------------------
    CToolBar::OnSysMenuSelect

    Cicero Help menu callback
---------------------------------------------------------------------------*/
HRESULT CToolBar::OnSysMenuSelect(void *pv, UINT uiCmd)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(uiCmd);

    CHAR szHelpFileName[MAX_PATH];
    CHAR szHelpCmd[MAX_PATH];

    szHelpFileName[0] = '\0';
        
    // Load Help display name
    OurLoadStringA(vpInstData->hInst, IDS_HELP_FILENAME, szHelpFileName, sizeof(szHelpFileName)/sizeof(CHAR));

    wsprintf(szHelpCmd, "hh.exe %s", szHelpFileName);
    WinExec(szHelpCmd, SW_NORMAL);
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    CToolBar::SysInitMenu

    Cicero Help menu callback
---------------------------------------------------------------------------*/
HRESULT CToolBar::SysInitMenu(void *pv, ITfMenu* pMenu)
{
    WCHAR    szText[MAX_PATH];
    HRESULT  hr;

    szText[0] = L'\0';
    
    if (pv == NULL || pMenu == NULL)
        return S_OK;

    // Load Help display name
    OurLoadStringW(vpInstData->hInst, IDS_HELP_DISPLAYNAME, szText, sizeof(szText)/sizeof(WCHAR));

    hr = pMenu->AddMenuItem(UINT(-1),  0, 
                            NULL /*hbmpColor*/, NULL /*hbmpMask*/, szText, lstrlenW(szText), NULL);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\ui.cpp ===
/****************************************************************************
    UI.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    UI functions
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "apientry.h"
#include "ui.h"
#include "imedefs.h"
#include "names.h"
#include "config.h"
#include "debug.h"
#include "shellapi.h"
#include "winex.h"
#include "imcsub.h"
#include "cpadsvr.h"
#include "pad.h"
#include "cicero.h"
#include "toolbar.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////////
PRIVATE LRESULT CALLBACK UIWndProc(HWND hUIWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
PRIVATE BOOL HandlePrivateMessage(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);

PRIVATE LRESULT PASCAL NotifyUI(HWND hUIWnd, WPARAM wParam, LPARAM lParam);
PRIVATE VOID PASCAL StatusWndMsg(HWND hUIWnd, BOOL fOn);
PRIVATE HWND PASCAL GetStatusWnd(HWND hUIWnd);
PRIVATE VOID PASCAL ShowUI(HWND hUIWnd, int nShowCmd);
PRIVATE VOID PASCAL OnImeSetContext(HWND hUIWnd, BOOL fOn, LPARAM lShowUI);
PRIVATE VOID PASCAL OnImeSelect(HWND hUIWnd, BOOL fOn);
PRIVATE HWND PASCAL GetCandWnd(HWND hUIWnd);
PRIVATE HWND PASCAL GetCompWnd(HWND hUIWnd);
PRIVATE LRESULT PASCAL GetCandPos(HWND hUIWnd, LPCANDIDATEFORM lpCandForm);
PRIVATE LRESULT PASCAL GetCompPos(HWND hUIWnd, LPCOMPOSITIONFORM lpCompForm);
PRIVATE VOID PASCAL UIWndOnCommand(HWND hUIWnd, int id, HWND hWndCtl, UINT codeNotify);

// Commented out SetIndicator because #199
PRIVATE BOOL PASCAL SetIndicator(PCIMECtx pImeCtx);

__inline
BOOL PASCAL SetIndicator(HIMC hIMC)
{
    PCIMECtx pImeCtx;
    
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;
    else
        return SetIndicator(pImeCtx);
}

//////////////////////////////////////////////////////////////////////////////
// TLS
#define UNDEF_TLSINDEX    -1                    
DWORD vdwTLSIndex = UNDEF_TLSINDEX;    // Thread Local Strage initial value.

//////////////////////////////////////////////////////////////////////////////
// Private UI messages
UINT WM_MSIME_PROPERTY = 0;         // Invoke property DLG
UINT WM_MSIME_UPDATETOOLBAR = 0; // Redraw status window(Toolbar)
UINT WM_MSIME_OPENMENU = 0;         // Pop up status window context menu
UINT WM_MSIME_IMEPAD = 0;         // Boot up IME Pad

// Message string
#define RWM_PROPERTY      "MSIMEProperty"
#define RWM_UPDATETOOLBAR "MSIMEUpdateToolbar"
#define RWM_OPENMENU      "MSIMEOpenMenu"
#define RWM_IMEPAD        "MSIMEIMEPAD"

/*----------------------------------------------------------------------------
    InitPrivateUIMsg

    Register all IME private UI messages
----------------------------------------------------------------------------*/
BOOL InitPrivateUIMsg()
{
    WM_MSIME_PROPERTY      = RegisterWindowMessageA(RWM_PROPERTY);
    WM_MSIME_UPDATETOOLBAR = RegisterWindowMessageA(RWM_UPDATETOOLBAR);
    WM_MSIME_OPENMENU      = RegisterWindowMessageA(RWM_OPENMENU);
    WM_MSIME_IMEPAD        = RegisterWindowMessageA(RWM_IMEPAD);

    return fTrue;
}

/*----------------------------------------------------------------------------
    RegisterImeUIClass

    Register all IME UI calsses
----------------------------------------------------------------------------*/
BOOL RegisterImeUIClass(HANDLE hInstance)
{
    WNDCLASSEXA     wc;
    HANDLE             hMod;
    BOOL            fRet = fTrue;

    // Init wc zero
    ZeroMemory(&wc, sizeof(WNDCLASSEXA));
    
    wc.cbSize           = sizeof(WNDCLASSEXW);
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = sizeof(LONG_PTR) * 2;        // for IMMGWLP_IMC and IMMGWLP_PRIVATE
                                                    // and for move offset of Status window
    wc.hIcon            = NULL; 
    wc.hInstance        = (HINSTANCE)hInstance;
    wc.hCursor          = LoadCursor((HINSTANCE)NULL, IDC_ARROW);
    wc.lpszMenuName     = NULL;
    wc.hbrBackground    = (HBRUSH)GetStockObject(NULL_BRUSH);
    wc.hIconSm          = NULL;

    // Assumption
    DbgAssert(sizeof(WNDCLASSEXA) == sizeof(WNDCLASSEXW));

    ///////////////////////////////////////////////////////////////////////////
    // IME UI server class

    wc.style         = CS_VREDRAW | CS_HREDRAW | CS_IME;
    wc.lpfnWndProc   = UIWndProc;
    
    // Create Unicode window when NT
    if (IsWinNT())
        {
        LPWNDCLASSEXW     pwcW = (LPWNDCLASSEXW)&wc;

        // IME UI class UNICODE name
        pwcW->lpszClassName = wszUIClassName;

        if ((fRet = RegisterClassExW(pwcW)) == fFalse)
            goto RegisterImeUIClassExit;

        }
    else
        {
        // IME UI class ANSI name
        wc.lpszClassName = szUIClassName;

        if ((fRet = RegisterClassEx(&wc)) == fFalse)
            goto RegisterImeUIClassExit;
        }

    ///////////////////////////////////////////////////////////////////////////
    // IME status class
    wc.style         = CS_VREDRAW | CS_HREDRAW | CS_IME;
    wc.lpfnWndProc   = StatusWndProc;
    wc.lpszClassName = szStatusClassName;
    if ((fRet = RegisterClassEx(&wc)) == fFalse)
        goto RegisterImeUIClassExit;

    // Cand and composition wnd do not need extra wnd bytes
    wc.cbWndExtra    = 0;    
    
    ///////////////////////////////////////////////////////////////////////////
    // IME candidate class
    wc.lpfnWndProc   = CandWndProc;
    wc.lpszClassName = szCandClassName;
    if ((fRet = RegisterClassEx(&wc)) == fFalse)
        goto RegisterImeUIClassExit;

    ///////////////////////////////////////////////////////////////////////////
    // IME composition class
    wc.lpfnWndProc   = CompWndProc;
    wc.lpszClassName = szCompClassName;
    if ((fRet = RegisterClassEx(&wc)) == fFalse)
        goto RegisterImeUIClassExit;

    ///////////////////////////////////////////////////////////////////////////
    // Register Our Tooltip class
    hMod = GetModuleHandle("comctl32.dll");
    DbgAssert(hMod != 0);
    // If NT, register W class for Unicode text display on tooltip
    if (IsWinNT())
        {
        WNDCLASSEXW wcw;
        // Init wcw
        ZeroMemory(&wcw, sizeof(WNDCLASSEXW));
        
        wcw.cbSize = sizeof(WNDCLASSEXW);
        
        if (!GetClassInfoExW(NULL, wszTooltipClassName, &wcw))
            {
            GetClassInfoExW(NULL, TOOLTIPS_CLASSW, &wcw);
            wcw.cbSize = sizeof(WNDCLASSEXW);
            wcw.style |= CS_IME;
            wcw.hInstance = (HINSTANCE)hMod;
            wcw.lpszClassName = wszTooltipClassName;
            if ((fRet = RegisterClassExW(&wcw)) == fFalse)
                goto RegisterImeUIClassExit;
            }
        }
    else
        {
        wc.cbSize = sizeof(WNDCLASSEX);
        
        if (!GetClassInfoEx(NULL, szTooltipClassName, &wc))
            {
            GetClassInfoEx(NULL, TOOLTIPS_CLASS, &wc);
            wc.cbSize = sizeof(WNDCLASSEX);
            wc.style |= CS_IME;
            wc.hInstance = (HINSTANCE)hMod;
            wc.lpszClassName = szTooltipClassName;
            if ((fRet = RegisterClassEx(&wc)) == fFalse)
                goto RegisterImeUIClassExit;
            }
        }
        
RegisterImeUIClassExit:
#ifdef DEBUG
    OutputDebugString("RegisterImeUIClass() : return\r\n");
#endif
    DbgAssert(fRet);
    return fRet;
}


BOOL UnregisterImeUIClass(HANDLE hInstance)
{
    BOOL    fRet = fTrue;

    // Unregister Status window class
    UnregisterClass(szStatusClassName, (HINSTANCE)hInstance);

    // Unregister Candidate window class
    UnregisterClass(szCandClassName, (HINSTANCE)hInstance);

    // Unregister Composition window class
    UnregisterClass(szCompClassName, (HINSTANCE)hInstance);

    // Unregister Tooltip window class
    UnregisterClass(szTooltipClassName, (HINSTANCE)hInstance);

    // Unregister UI class window class
    UnregisterClass(szUIClassName, (HINSTANCE)hInstance); 
    
    return fRet;
}

/*----------------------------------------------------------------------------
    UIWndProc

    IME UI wnd messgae proc
----------------------------------------------------------------------------*/
LRESULT CALLBACK UIWndProc(HWND hUIWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV    lpUIPrivate;
    LRESULT        lRet;
    LRESULT        lResult = 0;
    
    Dbg(DBGID_UI, TEXT("UIWndProc():uMessage = 0x%08lX, wParam = 0x%04X, lParam = 0x%08lX"), uMessage, wParam, lParam);

    switch (uMessage)
        {
    HANDLE_MSG(hUIWnd, WM_COMMAND, UIWndOnCommand);
    case WM_CREATE:
        Dbg(DBGID_UI, TEXT("UIWndProc(): WM_CREATE- UI window Created"));
        // create storage for UI setting
        hUIPrivate = GlobalAlloc(GHND, sizeof(UIPRIV));
        if (!hUIPrivate) 
            {
            DbgAssert(0);
            return 1L;
            }

        if ((lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate))==0)
            return 1L;

        // Set UI show default value. 
        lpUIPrivate->uiShowParam = ISC_SHOWUIALL;
        
        SetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE, (LONG_PTR)hUIPrivate);
        // set the default position for UI window, it is hide now
        //SetWindowPos(hUIWnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER);
        //ShowWindow(hUIWnd, SW_SHOWNOACTIVATE);

        // Chcek if this is Winlogon process in Win9x
        if (!IsWinNT())
            {
            if (IsExplorerProcess() == fFalse && IsExplorer() == fFalse)
                vpInstData->dwSystemInfoFlags |= IME_SYSINFO_WINLOGON;
            }

        // Init Cicero service
        CiceroInitialize();
        DbgAssert(lpUIPrivate->m_pCicToolbar == NULL);

        if (IsCicero())
            lpUIPrivate->m_pCicToolbar = new CToolBar();
        
        GlobalUnlock(hUIPrivate);
        return 0;

    case WM_DESTROY:
        Dbg(DBGID_UI, TEXT("UIWndProc(): WM_DESTROY- UI window destroyed"));

        // Destroy IME Pad if exist
        CImePadSvr::DestroyCImePadSvr();

        hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
        if (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate))
            {
            Dbg(DBGID_UI, TEXT("         - WM_DESTROY Destroy all UI windows"));

            if (lpUIPrivate->hStatusTTWnd) 
                DestroyWindow(lpUIPrivate->hCandTTWnd);

            if (lpUIPrivate->hStatusWnd)
                DestroyWindow(lpUIPrivate->hStatusWnd);

            if (lpUIPrivate->hCandTTWnd)
                DestroyWindow(lpUIPrivate->hCandTTWnd);
            
            if (lpUIPrivate->hCandWnd)
                DestroyWindow(lpUIPrivate->hCandWnd);
        
            if (lpUIPrivate->hCompWnd)
                DestroyWindow(lpUIPrivate->hCompWnd);

            // Terminate Cicero service
            if (IsCicero())
                {
                if (lpUIPrivate->m_pCicToolbar)
                    {
                    lpUIPrivate->m_pCicToolbar->Terminate();
                    delete lpUIPrivate->m_pCicToolbar;
                    lpUIPrivate->m_pCicToolbar = NULL;
                    }
                // Issue: This call causes AV on Win9x
                // CiceroTerminate();
                }
            
            GlobalUnlock(hUIPrivate);
            GlobalFree(hUIPrivate);
            SetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE, (LONG_PTR)0L);
            }

        return 0;

    case WM_IME_NOTIFY:
        return NotifyUI(hUIWnd, wParam, lParam);
    
    case WM_IME_SETCONTEXT:
        Dbg(DBGID_UI, TEXT("            - WM_IME_SETCONTEXT"));
        OnImeSetContext(hUIWnd, (BOOL)wParam, lParam);
        return 0;

    // WM_IME_CONTROL: Return Non-zero means failure otherwise 0
    case WM_IME_CONTROL:
        Dbg(DBGID_UI, TEXT("            - WM_IME_CONTROL"));
        switch (wParam) 
            {
        case IMC_GETCANDIDATEPOS:
            return GetCandPos(hUIWnd, (LPCANDIDATEFORM)lParam);

        case IMC_GETCOMPOSITIONWINDOW:
            return GetCompPos(hUIWnd, (LPCOMPOSITIONFORM)lParam);

        case IMC_GETSTATUSWINDOWPOS:
                {
                HWND        hStatusWnd;
                RECT        rcStatusWnd;

                Dbg(DBGID_UI, TEXT("UIWndProc() - WM_IME_CONTROL - IMC_GETSTATUSWINDOWPOS"));
                hStatusWnd = GetStatusWnd(hUIWnd);
                if (!hStatusWnd)
                    return (1L);

                if (!GetWindowRect(hStatusWnd, &rcStatusWnd))
                     return (1L);

                return (MAKELRESULT(rcStatusWnd.left, rcStatusWnd.top));
                }
            break;
            
        case IMC_GETCOMPOSITIONFONT:
                {
                HFONT        hFontFix;
                LPLOGFONT    lpLogFont;
                LOGFONT        lfFont;

                hFontFix = CreateFont(-16,0,0,0,0,0,0,0,129,OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, FIXED_PITCH, szIMECompFont);
                lpLogFont = (LPLOGFONT)lParam;
                if (GetObject(hFontFix, sizeof(lfFont), (LPVOID)&lfFont))
                    *lpLogFont = lfFont;
                DeleteObject(hFontFix);
                }
            break;

        default:
            return (1L);
            }
        return 0;

    //
    case WM_IME_STARTCOMPOSITION:
        OpenComp(hUIWnd);
        return 0;

    case WM_IME_COMPOSITION:
        HWND hCompWnd;
        hCompWnd = GetCompWnd(hUIWnd);
        if (hCompWnd)   // Do not use Update() !
            {
            ShowComp(hUIWnd, SW_SHOWNOACTIVATE);
            InvalidateRect(hCompWnd, NULL, fTrue);
            }
        return 0;

    case WM_IME_ENDCOMPOSITION:
        hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
        if (hUIPrivate && (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate))) 
            {
            // if comp wnd exist, destroy it.
            if (lpUIPrivate->hCompWnd)
                {
                ShowComp(hUIWnd, SW_HIDE);
                DestroyWindow(lpUIPrivate->hCompWnd);
                lpUIPrivate->hCompWnd = 0;
                }
            GlobalUnlock(hUIPrivate);
            }
        return 0;

    case WM_IME_SELECT:
        Dbg(DBGID_UI, TEXT("            - WM_IME_SELECT"));
        OnImeSelect(hUIWnd, (BOOL)wParam);
        return 0;
    
    case WM_DISPLAYCHANGE:
            {
            CIMEData    ImeData(CIMEData::SMReadWrite);

            Dbg(DBGID_UI, TEXT("            - WM_DISPLAYCHANGE"));
            SystemParametersInfo(SPI_GETWORKAREA, 0, &ImeData->rcWorkArea, 0);
            hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
            if ( lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate) ) 
                {
                StatusDisplayChange(hUIWnd);
                GlobalUnlock(hUIPrivate);
                }
            return 0;
            }
    default:
        if (vfUnicode == fTrue && IsWinNT() == fTrue)
            lResult = DefWindowProcW(hUIWnd, uMessage, wParam, lParam);
        else
            lResult = DefWindowProc(hUIWnd, uMessage, wParam, lParam);
        }

    // if Private msg
    if (uMessage >= 0xC000)
        {
        // if private msg proccessed return value
        if (HandlePrivateMessage(hUIWnd, uMessage, wParam, lParam, &lRet))
            return lRet;
        }

    return lResult;
}

/*----------------------------------------------------------------------------
    HandlePrivateMessage

    IME UI private messgae handler
----------------------------------------------------------------------------*/
PRIVATE BOOL HandlePrivateMessage(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    LRESULT     lRet = 0;
    BOOL         fProcessed = fFalse;

    if (msg == WM_MSIME_PROPERTY)
        {
        fProcessed = fTrue;
        hIMC = GethImcFromHwnd(hWnd);
        if (pImeCtx = GetIMECtx(hIMC))
            ImeConfigure(NULL, pImeCtx->GetAppWnd(), (DWORD)lParam, NULL);
        DbgAssert(pImeCtx != NULL);
        }
    else
    if (msg == WM_MSIME_UPDATETOOLBAR)
        {
        HWND hStatusWnd;

        fProcessed = fTrue;
        hStatusWnd = GetStatusWnd(hWnd);
        if (hStatusWnd) 
            {
            CIMEData    ImeData;
            InvalidateRect(hStatusWnd, &ImeData->rcButtonArea, fFalse);
            }
        }
    else
    if (msg == WM_MSIME_OPENMENU)
        {
        fProcessed = fTrue;
        UIPopupMenu(hWnd);
        }
    else
    if (msg == WM_MSIME_IMEPAD)
        {
        if ((vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON) == 0)
            {
            hIMC = GethImcFromHwnd(hWnd);
            if (pImeCtx = GetIMECtx(hIMC)) 
                SetForegroundWindow(pImeCtx->GetAppWnd()); // trick
            DbgAssert(pImeCtx != NULL);

            // Boot Pad
            BootPad(hWnd, (UINT)wParam, lParam);
            }
        }
        
    *plRet = lRet;
    return fProcessed;
}

//////////////////////////////////////////////////////////////////////////////
LRESULT PASCAL NotifyUI(HWND hUIWnd, WPARAM wParam, LPARAM lParam)
{
    HWND     hWnd;
    HGLOBAL     hUIPrivate;
    LPUIPRIV lpUIPrivate;
    LONG     lRet = 0;

    Dbg(DBGID_UI, TEXT("NotifyUI(): hUIWnd = 0x%X wParam = 0x%04X, lParam = 0x%08lX"), hUIWnd, wParam, lParam);

    switch (wParam) 
        {
    case IMN_OPENSTATUSWINDOW:
        Dbg(DBGID_UI, TEXT("NotifyUI(): IMN_OPENSTATUSWINDOW"));
        StatusWndMsg(hUIWnd, fTrue);
        break;

    case IMN_CLOSESTATUSWINDOW:
        Dbg(DBGID_UI, TEXT("NotifyUI(): IMN_CLOSESTATUSWINDOW"));
        StatusWndMsg(hUIWnd, fFalse);
        break;

    case IMN_SETSTATUSWINDOWPOS:
        Dbg(DBGID_UI, TEXT("NotifyUI(): IMN_SETSTATUSWINDOWPOS"));
        if (!IsCicero())
            {
            fSetStatusWindowPos(GetStatusWnd(hUIWnd), NULL);
            fSetCompWindowPos(GetCompWnd(hUIWnd));
            }
        break;

    // IMN_SETCOMPOSITIONWINDOW called for all user key press
    case IMN_SETCOMPOSITIONWINDOW:
        hWnd = GetCompWnd(hUIWnd);
        if (hWnd)
            fSetCompWindowPos(hWnd);
        break;

    case IMN_OPENCANDIDATE:
        Dbg(DBGID_UI, TEXT("         - IMN_OPENCANDIDATE"));
        OpenCand(hUIWnd);
        break;
        
    case IMN_CLOSECANDIDATE:
        Dbg(DBGID_UI, TEXT("         - IMN_CLOSECANDIDATE"));
        if (lParam & 0x00000001) 
            {
            hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
            if (hUIPrivate && (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate))) 
                {
                if (lpUIPrivate->hCandWnd) 
                    {
                    ShowCand(hUIWnd, SW_HIDE);
                    DestroyWindow(lpUIPrivate->hCandWnd);
                    lpUIPrivate->hCandWnd = 0;
                    }
                    
                if (lpUIPrivate->hCandTTWnd) 
                    {
                    DestroyWindow(lpUIPrivate->hCandTTWnd);
                    lpUIPrivate->hCandTTWnd = 0;
                    }
                GlobalUnlock(hUIPrivate);
                }
            }
        break;
    
    case IMN_SETCANDIDATEPOS:
        hWnd = GetCandWnd(hUIWnd);
        if (hWnd)
            fSetCandWindowPos(hWnd);
        break;

    case IMN_CHANGECANDIDATE:
        Dbg(DBGID_UI, TEXT("           - Redraw cand window"));
        hWnd = GetCandWnd(hUIWnd);
        //RedrawWindow(hStatusWnd, &ImeData->rcButtonArea, NULL, RDW_INVALIDATE);
        InvalidateRect(hWnd, NULL, fFalse);
        break;

    case IMN_SETOPENSTATUS:        
        SetIndicator(GethImcFromHwnd(hUIWnd));
        break;

    case IMN_SETCONVERSIONMODE:
        hWnd = GetStatusWnd(hUIWnd);
        if (hWnd) 
            {
            CIMEData    ImeData(CIMEData::SMReadWrite);
            Dbg(DBGID_UI, TEXT("           - Redraw status window"));
            //RedrawWindow(hWnd, &ImeData->rcButtonArea, NULL, RDW_INVALIDATE);
            InvalidateRect(hWnd, &ImeData->rcButtonArea, fFalse);
            }
        SetIndicator(GethImcFromHwnd(hUIWnd));

        // Update Cicero buttons
        if (IsCicero() && (hUIPrivate = GethUIPrivateFromHwnd(hUIWnd)) && 
                          (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate)) != NULL)
            {
            lpUIPrivate->m_pCicToolbar->Update(UPDTTB_CMODE|UPDTTB_FHMODE);
            GlobalUnlock(hUIPrivate);
            }
        break;

    default:
        Dbg(DBGID_UI, TEXT("NotifyUI(): Unhandled IMN = 0x%04X"), wParam);
        lRet = fTrue;
        }

    return lRet;
}


///////////////////////////////////////////////////////////////////////////////
// Called when IMN_OPENSTATUSWINDOW/IMN_CLOSESTATUSWINDOW occurs
// set the show hide state and
// show/hide the status window
void PASCAL StatusWndMsg(HWND hUIWnd, BOOL fOn)
{
    HGLOBAL  hUIPrivate;
    HIMC     hIMC;
    register LPUIPRIV lpUIPrivate;

    Dbg(DBGID_UI, TEXT("StatusWndMsg(): hUIWnd = 0x%X, fOn = %d"), hUIWnd, fOn);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);

    if (!hUIPrivate) 
        {
        DbgAssert(0);
        return;
        }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) 
        {
        DbgAssert(0);
        return;
        }

    hIMC = GethImcFromHwnd(hUIWnd);

    // if Cicero enabled, Init/Terminate Cicero toolbar.
    // Office 10 #249973: I moved init position to here from OnImeSetContext.
    // But make sure all user's "HKEY_CURRENT_USER\Control Panel\Input Method\Show Status" shuold be "1"
    // Setup will do this by enumerating HKEY_USERS
    if (IsCicero())
        {
        if (fOn)
            {
            if (lpUIPrivate->m_pCicToolbar)
                lpUIPrivate->m_pCicToolbar->Initialize();
            }
        else
            {
            if (lpUIPrivate->m_pCicToolbar)
                lpUIPrivate->m_pCicToolbar->Terminate();            
            }
        }
    else
        {
        if (fOn) 
            {
            InitButtonState();    // b#159
            OpenStatus(hUIWnd);
            } 

        if (lpUIPrivate->hStatusWnd == 0)
            {
            Dbg(DBGID_UI, TEXT("StatusWndMsg(): Null Status window handle"));
            GlobalUnlock(hUIPrivate);
            return;
            }

        if (fOn) 
            {
            if (hIMC)
                ShowStatus(hUIWnd, SW_SHOWNOACTIVATE);
            else
                {
                ShowStatus(hUIWnd, SW_HIDE);
                Dbg(DBGID_UI, TEXT("StatusWndMsg(): hIMC == 0, Call ShowStatus(HIDE)"));
                }
            }
        else 
            {
            DestroyWindow(lpUIPrivate->hStatusWnd);
            Dbg(DBGID_UI, TEXT("StatusWndMsg(): Call ShowStatus(HIDE)"));
            }
        }
    // Unlock UI private handle
    GlobalUnlock(hUIPrivate);
}

/*----------------------------------------------------------------------------
    OnUIProcessAttach
----------------------------------------------------------------------------*/
BOOL OnUIProcessAttach()
{
    DbgAssert(vdwTLSIndex == UNDEF_TLSINDEX);
    if (vdwTLSIndex == UNDEF_TLSINDEX)
        {
        vdwTLSIndex  = ::TlsAlloc();    //Get new TLS index.
        if (vdwTLSIndex == UNDEF_TLSINDEX)
            {
            Dbg(DBGID_UI, "-->SetActiveUIWnd ::TlsAlloc Error ret [%d]\n", GetLastError());
            return fFalse;
            }
        }
        
    return fTrue;
}

/*----------------------------------------------------------------------------
    OnUIProcessDetach
----------------------------------------------------------------------------*/
BOOL OnUIProcessDetach()
{
    if (TlsFree(vdwTLSIndex) == 0)
        {
        Dbg(DBGID_UI, "-->::TlsFree Error [%d]\n", GetLastError());
        return fFalse;
        }
    vdwTLSIndex = UNDEF_TLSINDEX;

    return fTrue;
}

/*----------------------------------------------------------------------------
    OnUIThreadDetach
----------------------------------------------------------------------------*/
BOOL OnUIThreadDetach()
{
    if (vdwTLSIndex != UNDEF_TLSINDEX)
        TlsSetValue(vdwTLSIndex, NULL);

    return fTrue;
}

/*----------------------------------------------------------------------------
    SetActiveUIWnd

    Save current Active UI wnd handle to TLS
----------------------------------------------------------------------------*/
VOID SetActiveUIWnd(HWND hWnd)
{
    Dbg(DBGID_UI, "SetActiveUIWnd(hWnd=%lx) \r\n", hWnd);

    if (IsWin(hWnd) == fFalse) 
        {
        Dbg(DBGID_UI, "SetActiveUIWnd( hWnd=%lx ) - no window\r\n", hWnd );
        return;
        }

    if (TlsSetValue(vdwTLSIndex, (LPVOID)hWnd) == 0)
        {
        Dbg(DBGID_UI, "-->LoadCImePadSvr() TlsSetValue Failed [%d]\n", GetLastError());
        TlsSetValue(vdwTLSIndex, NULL);
        return;
        }
}

/*----------------------------------------------------------------------------
    GetActiveUIWnd

    Retrieve  current Active UI wnd handle from TLS
----------------------------------------------------------------------------*/
HWND GetActiveUIWnd()
{
    return (HWND)TlsGetValue(vdwTLSIndex); 
}

// Called by OnImeSetContext() and OnImeSelect()
void PASCAL ShowUI(HWND   hUIWnd, int nShowCmd)
{
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;
    
    Dbg(DBGID_UI, TEXT("ShowUI() : nShowCmd=%d"), nShowCmd);

#if 0
    if (nShowCmd != SW_HIDE) 
        {
        // Check if hIMC and hPrivate is valid
        // If not valid hide all UI windows.
        hIMC = GethImcFromHwnd(hUIWnd);
        lpIMC = (LPINPUTCONTEXT)OurImmLockIMC(hIMC);
        lpImcP = (LPIMCPRIVATE)GetPrivateBuffer(hIMC);

        if (!(hIMC && lpIMC && lpImcP))
            nShowCmd = SW_HIDE;
        }
#else
    hIMC = GethImcFromHwnd(hUIWnd);
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
            nShowCmd = SW_HIDE;
#endif

    ///////////////////////////////////////////////////////////////////////////
    // Lock hUIPrivate
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);

    // can not draw status window
    if (!hUIPrivate)
        return;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    // can not draw status window
    if (!lpUIPrivate)
        return;

    // Hide all UI window and return immediately
    if (nShowCmd == SW_HIDE) 
        {
        Dbg(DBGID_UI, TEXT("ShowUI() : hiding all UI"));
        ShowStatus(hUIWnd, SW_HIDE);
        ShowComp(hUIWnd, SW_HIDE);
        ShowCand(hUIWnd, SW_HIDE);
        
        // FIXED : if (nShowCmd == SW_HIDE) hIMC and lpIMC->hPrivate not Locked
        // So you need not Unlock 
        goto ShowUIUnlockUIPrivate;
        }

    //////////////////
    // Status window
    if (lpUIPrivate->hStatusWnd)
        {
        // if currently hide, show it.
        if (lpUIPrivate->nShowStatusCmd == SW_HIDE)
            ShowStatus(hUIWnd, SW_SHOWNOACTIVATE);
        else
            {
            // sometime the WM_ERASEBKGND is eaten by the app
            RedrawWindow(lpUIPrivate->hStatusWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE/*|RDW_ERASE*/);
            }
        }
/*
    //////////////////////
    // Composition window
    if (lpUIPrivate->hCompWnd)
        {
        if (lpUIPrivate->nShowCompCmd == SW_HIDE)
            ShowComp(hUIWnd, SW_SHOWNOACTIVATE);
        else                
            {
            // sometime the WM_ERASEBKGND is eaten by the app
            RedrawWindow(lpUIPrivate->hCompWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }
        } 

    ////////////////////
    // Candidate window
    if (lpUIPrivate->hCandWnd) 
        {
        if (lpUIPrivate->nShowCandCmd == SW_HIDE)
            ShowCand(hUIWnd, SW_SHOWNOACTIVATE);
        else
            {
            // some time the WM_ERASEBKGND is eaten by the app
            RedrawWindow(lpUIPrivate->hCandWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }

        fSetCandWindowPos(lpUIPrivate->hCandWnd);
        } 
*/
ShowUIUnlockUIPrivate:
    GlobalUnlock(hUIPrivate);        
    return;
}

////////////////////////////////////////////////////////////////////////
// WM_IME_SETCONTEXT sent whenever user activated/deactivated a window
void PASCAL OnImeSetContext(HWND hUIWnd, BOOL fOn, LPARAM lShowUI)
{
    HGLOBAL      hUIPrivate;
    LPUIPRIV     lpUIPrivate;
    HWND        hwndIndicator = FindWindow(INDICATOR_CLASS, NULL);
    HIMC        hIMC = NULL;
    PCIMECtx     pImeCtx;

    Dbg(DBGID_UI, TEXT("OnImeSetContext(): hUIWnd = 0x%X fOn = %d"), hUIWnd, fOn);

    // Get UI private memory
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (hUIPrivate == 0 || (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate)) == 0)
        {
        ShowUI(hUIWnd, SW_HIDE);
        // Set disabled Pen Icon 
        if (fOn)
            SetIndicator((PCIMECtx)NULL);
        goto LOnImeSetContextExit;
        }

    // Init Cicero service
    CiceroInitialize();

    // If Cicero enabled, init toolbar
    if (IsCicero())
        {
        // Create Toolbar object and store it to private memory
        if (lpUIPrivate->m_pCicToolbar == NULL)
            lpUIPrivate->m_pCicToolbar = new CToolBar();

        DbgAssert(lpUIPrivate->m_pCicToolbar != NULL);
        }

    hIMC = GethImcFromHwnd(hUIWnd);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        {
        ShowUI(hUIWnd, SW_HIDE);
        // Set disabled Pen Icon 
        if (fOn)
            SetIndicator((PCIMECtx)NULL);

        // Disable cicero buttons
        if (IsCicero() && lpUIPrivate->m_pCicToolbar)
            lpUIPrivate->m_pCicToolbar->SetCurrentIC(NULL);
            
        goto LOnImeSetContextExit2;
        }

    if (fOn)
        {
        // Store UI Window handle to TLS
        SetActiveUIWnd(hUIWnd);
        
        // Keep lParam
        lpUIPrivate->uiShowParam = lShowUI;

        if (pImeCtx->GetCandidateFormIndex(0) != 0)
            pImeCtx->SetCandidateFormIndex(CFS_DEFAULT, 0);

        // Remove right Help menu item on Pen Icon 
        if (hwndIndicator)
            {
            PostMessage(hwndIndicator, 
                        INDICM_REMOVEDEFAULTMENUITEMS , 
                        RDMI_RIGHT, 
                        (LPARAM)GetKeyboardLayout(NULL));
            // Set Pen Icon
            SetIndicator(pImeCtx);
            }
            
        // For display Status window.
        ShowUI(hUIWnd, SW_SHOWNOACTIVATE);

        if (IsCicero() && lpUIPrivate->m_pCicToolbar)
            lpUIPrivate->m_pCicToolbar->SetCurrentIC(pImeCtx);
        }

LOnImeSetContextExit2:
    GlobalUnlock(hUIPrivate);

LOnImeSetContextExit:
    LPCImePadSvr lpCImePadSvr = CImePadSvr::GetCImePadSvr();
    if(lpCImePadSvr) 
        {
        BOOL fAct = (BOOL)(fOn && hIMC);
        if (fAct) 
            {
            IImeIPoint1* pIP = GetImeIPoint(hIMC);
            //HWND hWnd          = GetStatusWnd(hUIWnd);

            //ImePadSetCurrentIPoint(hWnd, pIp);
            lpCImePadSvr->SetIUnkIImeIPoint((IUnknown *)pIP);
            //UpdatePadButton(pUI->GetWnd());
            // Don't need to repaint. StatusOnPaint will do it
            //if (hWnd)
            //    InvalidateRect(hWnd, NULL, fFalse);
            }
        lpCImePadSvr->Notify(IMEPADNOTIFY_ACTIVATECONTEXT, fAct, 0);
        }

    return;
}

///////////////////////////////////////////////////////////////////////////////
// WM_IME_SELECT sent when user change IME
void PASCAL OnImeSelect(HWND hUIWnd, BOOL fOn)
{
    HGLOBAL      hUIPrivate;
    LPUIPRIV     lpUIPrivate;
    HWND        hwndIndicator = FindWindow(INDICATOR_CLASS, NULL);
    HIMC           hIMC;
    PCIMECtx     pImeCtx;

    Dbg(DBGID_UI, TEXT("OnImeSelect(): hUIWnd = 0x%Xm fOn = %d"), hUIWnd, fOn);

    // Get UI private memory
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (hUIPrivate == 0 || (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate)) == 0)
        {
        ShowUI(hUIWnd, SW_HIDE);
        // Set disabled Pen Icon 
        SetIndicator((PCIMECtx)NULL);
        return;
        }

    // Init Cicero service
    CiceroInitialize();

    // If Cicero enabled, init toolbar
    if (IsCicero())
        {
        // Create Toolbar object and store it to private memory
        if (lpUIPrivate->m_pCicToolbar == NULL)
            lpUIPrivate->m_pCicToolbar = new CToolBar();
            
        DbgAssert(lpUIPrivate->m_pCicToolbar != NULL);
        }

    hIMC = GethImcFromHwnd(hUIWnd);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        {
        ShowUI(hUIWnd, SW_HIDE);
        // Set disabled Pen Icon 
        SetIndicator((PCIMECtx)NULL);

        // Disable cicero buttons
        if (IsCicero() && lpUIPrivate->m_pCicToolbar)
            lpUIPrivate->m_pCicToolbar->SetCurrentIC(NULL);

        return;
        }

    if (fOn)
        {
        // Store UI Window handle to TLS. Sometimes when user switch IME only WM_IME_SELECT sent. No WM_IME_SETCONTEXT msg.
        SetActiveUIWnd(hUIWnd);

        if (pImeCtx->GetCandidateFormIndex(0) != 0)
            pImeCtx->SetCandidateFormIndex(CFS_DEFAULT, 0);

        // Remove right Help menu item on Pen Icon 
        if (hwndIndicator)
            {
            Dbg(DBGID_UI, TEXT("OnImeSelect(): Post indicator message"), hUIWnd, fOn);

            PostMessage(hwndIndicator, 
                        INDICM_REMOVEDEFAULTMENUITEMS , 
                        RDMI_RIGHT, 
                        (LPARAM)GetKeyboardLayout(NULL));
            // Set Pen Icon
            SetIndicator(pImeCtx);
            }

        // If Cicero enabled, init toolbar
        if (IsCicero() && lpUIPrivate->m_pCicToolbar)
            lpUIPrivate->m_pCicToolbar->SetCurrentIC(pImeCtx);
        }


    // IME PAD
    LPCImePadSvr lpCImePadSvr = CImePadSvr::GetCImePadSvr();
    if(lpCImePadSvr) 
        {
        BOOL fAct = (BOOL)(fOn && hIMC);
        if (fAct) 
            {
            IImeIPoint1* pIP = GetImeIPoint(hIMC);
            lpCImePadSvr->SetIUnkIImeIPoint((IUnknown *)pIP);
            }
        lpCImePadSvr->Notify(IMEPADNOTIFY_ACTIVATECONTEXT, fAct, 0);
        }

    // Close input sontext here
    // Because ImeSelect has not called from IMM on WIN95.
    if (fOn == fFalse)
        {
        DWORD dwCMode = 0, dwSent = 0;

        // If Hanja conversion mode when uninit, cancel it.
        OurImmGetConversionStatus(hIMC, &dwCMode, &dwSent);
        if (dwCMode & IME_CMODE_HANJACONVERT)
            OurImmSetConversionStatus(hIMC, dwCMode & ~IME_CMODE_HANJACONVERT, dwSent);

        // if interim state, make complete current comp string
        // But IMM sends CPS_CANCEL when user change layout
        if (pImeCtx->GetCompBufLen()) 
            {
            pImeCtx->FinalizeCurCompositionChar();
            pImeCtx->GenerateMessage();
            }

        CloseInputContext(hIMC);
        }
        
    GlobalUnlock(hUIPrivate);
}

HWND PASCAL GetStatusWnd(HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hStatusWnd;

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)           // can not darw status window
        return (HWND)NULL;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)         // can not draw status window
        return (HWND)NULL;

    hStatusWnd = lpUIPrivate->hStatusWnd;

    GlobalUnlock(hUIPrivate);
    return (hStatusWnd);
}

HWND PASCAL GetCandWnd(HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCandWnd;

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)          // can not darw candidate window
        return (HWND)NULL;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)         // can not draw candidate window
        return (HWND)NULL;

    hCandWnd = lpUIPrivate->hCandWnd;

    GlobalUnlock(hUIPrivate);
    return (hCandWnd);
}

HWND PASCAL GetCompWnd(HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCompWnd;

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)          // can not draw comp window
        return (HWND)NULL;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)         // can not draw comp window
        return (HWND)NULL;

    hCompWnd = lpUIPrivate->hCompWnd;
    GlobalUnlock(hUIPrivate);

    return (hCompWnd);
}

LRESULT PASCAL GetCandPos(HWND hUIWnd, LPCANDIDATEFORM lpCandForm)
{
    HWND        hCandWnd;
    RECT        rcCandWnd;
    HIMC         hIMC;
    PCIMECtx     pImeCtx;

    if (lpCandForm->dwIndex != 0)
        return (1L);

    hCandWnd = GetCandWnd(hUIWnd);

    if (!hCandWnd)
        return (1L);

    if (!GetWindowRect(hCandWnd, &rcCandWnd))
        return (1L);

    hIMC = GethImcFromHwnd(hUIWnd);
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return (1L);

    //*lpCandForm = lpIMC->cfCandForm[0];
    lpCandForm->dwIndex = pImeCtx->GetCandidateFormIndex(0);
    lpCandForm->dwStyle = pImeCtx->GetCandidateFormStyle(0);
    pImeCtx->GetCandidateForm(&lpCandForm->rcArea, 0);
    lpCandForm->ptCurrentPos = *(LPPOINT)&rcCandWnd;

    return (0L);
}

LRESULT PASCAL GetCompPos(HWND hUIWnd, LPCOMPOSITIONFORM lpCompForm)
{
    HWND        hCompWnd;
    RECT        rcCompWnd;
    HIMC         hIMC;
    PCIMECtx     pImeCtx;

    hCompWnd = GetCompWnd(hUIWnd);

    if (!hCompWnd)
        return (1L);

    if (!GetWindowRect(hCompWnd, &rcCompWnd))
        return (1L);

    hIMC = GethImcFromHwnd(hUIWnd);
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return (1L);

    lpCompForm->dwStyle = pImeCtx->GetCompositionFormStyle();
    pImeCtx->GetCompositionForm(&lpCompForm->ptCurrentPos);
    pImeCtx->GetCompositionForm(&lpCompForm->rcArea);

    return (0L);
}


///////////////////////////////////////////////////////////////////////////////
// Popup menu message handler
void PASCAL UIWndOnCommand(HWND hUIWnd, INT id, HWND hWndCtl, UINT codeNotify)
{
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    CHAR        szBuffer[256];
    CIMEData    ImeData(CIMEData::SMReadWrite);

    szBuffer[0] = '\0';
    
    hIMC = GethImcFromHwnd(hUIWnd);
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return;

    switch (id)
        {
    case ID_CONFIG:
        ImeConfigure(0, pImeCtx->GetAppWnd(), IME_CONFIG_GENERAL, NULL);
        break;

    case ID_ABOUT:
        OurLoadStringA(vpInstData->hInst, IDS_PROGRAM, szBuffer, sizeof(szBuffer));
        ShellAbout(pImeCtx->GetAppWnd(), szBuffer, NULL, (HICON)LoadImage((HINSTANCE)vpInstData->hInst,
                    MAKEINTRESOURCE(IDI_UNIKOR), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR));
        break;

    //////////////////////////////////////////////////////////////////////
    // IME internal Keyboard layout change message
    case ID_2BEOLSIK: 
    case ID_3BEOLSIK390: 
    case ID_3BEOLSIKFINAL :
        if (ImeData.GetCurrentBeolsik() != (UINT)(id - ID_2BEOLSIK))
            {
            if (pImeCtx->GetAutomata())
                pImeCtx->GetAutomata()->InitState();

            if (pImeCtx->GetGData())
                pImeCtx->GetGData()->SetCurrentBeolsik(id - ID_2BEOLSIK);

            if (pImeCtx->GetAutomata())
                pImeCtx->GetAutomata()->InitState();

            SetRegValues(GETSET_REG_IMEKL);
            }
        break;

    //////////////////////////////////////////////////////////////////////
    // Han/Eng Toggle
    case ID_HANGUL_MODE :
        if (!(pImeCtx->GetConversionMode() & IME_CMODE_HANGUL)) 
               {
            OurImmSetConversionStatus(hIMC, 
                                    pImeCtx->GetConversionMode() ^ IME_CMODE_HANGUL, 
                                    pImeCtx->GetSentenceMode());
            }
        break;

    case ID_ENGLISH_MODE :
        if (pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) 
               {
            OurImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
            OurImmSetConversionStatus(hIMC, 
                                    pImeCtx->GetConversionMode() ^ IME_CMODE_HANGUL, 
                                    pImeCtx->GetSentenceMode());
            }
        break;

    //////////////////////////////////////////////////////////////////////
    // Hangul deletion per jaso or char.
    case ID_JASO_DELETION:
        ImeData.SetJasoDel(!ImeData.GetJasoDel());
        SetRegValues(GETSET_REG_JASODEL);
        break;

    default :
        Dbg(DBGID_UI, TEXT("UIWndOnCommand() - Unknown command"));
        break;
        }
    return;
}

void UIPopupMenu(HWND hUIWnd)
{
    HMENU   hMenu, hPopupMenu;
    POINT   ptCurrent;
    UINT    uiCurSel;
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    CIMEData    ImeData;

    hIMC = GethImcFromHwnd(hUIWnd);
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return;

    GetCursorPos(&ptCurrent);
    hMenu = OurLoadMenu(vpInstData->hInst, MAKEINTRESOURCE(IDR_STATUS_POPUP));
    if (hMenu != NULL)
        {
        hPopupMenu = GetSubMenu(hMenu, 0);
        if (hPopupMenu == NULL)
            {
            DestroyMenu(hMenu);
            return;
            }
            
        // Keyboard type selection radio button
        uiCurSel = ID_2BEOLSIK + ImeData.GetCurrentBeolsik();
        CheckMenuRadioItem(hPopupMenu, ID_2BEOLSIK, ID_3BEOLSIKFINAL, uiCurSel, MF_BYCOMMAND);

        // Han/Eng mode selection radio button
        uiCurSel = ID_HANGUL_MODE + ((pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) ? 0 : 1);
        CheckMenuRadioItem(hPopupMenu, ID_HANGUL_MODE, ID_ENGLISH_MODE, uiCurSel, MF_BYCOMMAND);

        // Hangul jaso deletion
        if (ImeData.GetJasoDel())
            CheckMenuItem(hPopupMenu, ID_JASO_DELETION, MF_BYCOMMAND | MF_CHECKED);
        else
            CheckMenuItem(hPopupMenu, ID_JASO_DELETION, MF_BYCOMMAND | MF_UNCHECKED);

        // if Winlogon process, gray all config menu
        if (vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON) 
                {
            EnableMenuItem(hPopupMenu, ID_CONFIG, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hPopupMenu, ID_2BEOLSIK, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hPopupMenu, ID_3BEOLSIK390, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hPopupMenu, ID_3BEOLSIKFINAL, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hPopupMenu, ID_JASO_DELETION, MF_BYCOMMAND | MF_GRAYED);
            }
        TrackPopupMenu(hPopupMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
                        ptCurrent.x, ptCurrent.y, 0, hUIWnd, NULL);
        DestroyMenu(hMenu);
        }
}

BOOL PASCAL SetIndicator(PCIMECtx pImeCtx)
{
    ATOM        atomIndicator;
    CHAR        sztooltip[IMEMENUITEM_STRING_SIZE];
    int            nIconIndex;
    HWND        hwndIndicator;
    
    Dbg(DBGID_Tray, TEXT("SetIndicator Enter"));
    hwndIndicator = FindWindow(INDICATOR_CLASS, NULL);

    if (!hwndIndicator)
        {
        Dbg(DBGID_Tray, TEXT("!!! WARNING !!!: Indicator window not found"));
        return fFalse;
        }
        
    // init sztooltip
    sztooltip[0] = 0;
    
    // Default value is disabled.
    OurLoadStringA(vpInstData->hInst, IDS_IME_TT_DISABLE, sztooltip, IMEMENUITEM_STRING_SIZE);
    nIconIndex = 5;

    if (pImeCtx) 
        {
        // If IME closed, English half mode
        if (pImeCtx->IsOpen() == fFalse)
            {
            OurLoadStringA(vpInstData->hInst, IDS_IME_TT_ENG_HALF, sztooltip, IMEMENUITEM_STRING_SIZE);
            nIconIndex= 3;
            }
        else
            {
            // If Hangul mode
            if (pImeCtx->GetConversionMode()  & IME_CMODE_HANGUL) 
                {
                if (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE)
                    {
                    OurLoadStringA(vpInstData->hInst, IDS_IME_TT_HANGUL_FULL, sztooltip, IMEMENUITEM_STRING_SIZE);
                    nIconIndex = 4;
                    }
                else
                    {
                    OurLoadStringA(vpInstData->hInst, IDS_IME_TT_HANGUL_HALF, sztooltip, IMEMENUITEM_STRING_SIZE);
                    nIconIndex = 1;
                    }
                }
            else 
                // Non-Hangul mode
                if (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE)
                    {
                    OurLoadStringA(vpInstData->hInst, IDS_IME_TT_ENG_FULL, sztooltip, IMEMENUITEM_STRING_SIZE);
                    nIconIndex = 2;
                    }
            }
        }
    
    Dbg(DBGID_Tray, TEXT("SetIndicator: PostMessage: nIconIndex=%d"), nIconIndex);
    PostMessage(hwndIndicator, INDICM_SETIMEICON, nIconIndex, (LPARAM)GetKeyboardLayout(NULL));
    
    // Should use GlobalFindAtom b#57121
    atomIndicator = GlobalFindAtom(sztooltip);
    // If no global atom exist, add it
    if (!atomIndicator)
        atomIndicator = GlobalAddAtom(sztooltip);

    DbgAssert(atomIndicator);
    
    if (atomIndicator)
        {
        Dbg(DBGID_Tray, TEXT("SetIndicator: PostMessage: atomIndicator=%s"), sztooltip);
        PostMessage(hwndIndicator, INDICM_SETIMETOOLTIPS, atomIndicator, (LPARAM)GetKeyboardLayout(NULL));
        }
    
    return fTrue;;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\ui.h ===
/****************************************************************************
	UI.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	UI functions
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_UI_H__INCLUDED_)
#define _UI_H__INCLUDED_

// CIMEData class forward declaration.
class CIMEData;

// UI.CPP
PUBLIC UINT WM_MSIME_PROPERTY;		// Invoke property DLG
PUBLIC UINT WM_MSIME_UPDATETOOLBAR; // Redraw status window(Toolbar)
PUBLIC UINT WM_MSIME_OPENMENU;		// Pop up status window context menu
PUBLIC UINT WM_MSIME_IMEPAD;		// Boot up IME Pad

PUBLIC BOOL InitPrivateUIMsg();
PUBLIC BOOL RegisterImeUIClass(HANDLE hInstance);
PUBLIC BOOL UnregisterImeUIClass(HANDLE hInstance);
PUBLIC BOOL OnUIProcessAttach();
PUBLIC BOOL OnUIProcessDetach();
PUBLIC BOOL OnUIThreadDetach();
PUBLIC VOID SetActiveUIWnd(HWND hWnd);
PUBLIC HWND GetActiveUIWnd();
PUBLIC VOID UIPopupMenu(HWND hStatusWnd);
//PUBLIC VOID HideStatus();

///////////////////////////////////////////////////////////////////////////////
// StatusUI.Cpp
PUBLIC VOID PASCAL OpenStatus(HWND hUIWnd);
PUBLIC LRESULT CALLBACK StatusWndProc(HWND hStatusWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
PUBLIC VOID ShowStatus(HWND hUIWnd, INT nShowStatusCmd);
PUBLIC VOID UpdateStatusButtons(CIMEData &IMEData);
PUBLIC VOID UpdateStatusWinDimension();
PUBLIC VOID StatusDisplayChange(HWND hUIWnd);
PUBLIC VOID InitButtonState();
PUBLIC BOOL fSetStatusWindowPos(HWND hStatusWnd, POINT *ptStatusWndPos = NULL);


///////////////////////////////////////////////////////////////////////////////
// CandUI.Cpp
PUBLIC VOID PASCAL OpenCand(HWND hUIWnd);
PUBLIC LRESULT CALLBACK CandWndProc(HWND hCandWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
PUBLIC VOID ShowCand(HWND hUIWnd, INT nShowCandCmd);
PUBLIC BOOL fSetCandWindowPos(HWND hCandWnd);


///////////////////////////////////////////////////////////////////////////////
// CompUI.Cpp
#define COMP_SIZEX	22
#define COMP_SIZEY	22
#define UI_GAPX		10
PUBLIC VOID PASCAL OpenComp(HWND hUIWnd);
PUBLIC LRESULT CALLBACK CompWndProc(HWND hCompWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
PUBLIC VOID ShowComp(HWND hUIWnd, INT nShowCompCmd);
PUBLIC BOOL fSetCompWindowPos(HWND hCompWnd);

///////////////////////////////////////////////////////////////////////////////
// UISubs.CPP
enum StatusButtonTypes 
{ 
	HAN_ENG_TOGGLE_BUTTON, 
	JUNJA_BANJA_TOGGLE_BUTTON, 
	HANJA_CONV_BUTTON,
	IME_PAD_BUTTON,
	NULL_BUTTON = 0xFF
};

// Button status
#define BTNSTATE_NORMAL		0	// normal
#define BTNSTATE_ONMOUSE	1	// mouse cursor on the button
#define BTNSTATE_PUSHED		2	// pushed
#define BTNSTATE_DOWN		4	// pushed
#define BTNSTATE_HANJACONV  8	// If hanja conv mode, button always pushed

// Button size
#define BTN_SMALL			0
#define BTN_MIDDLE			1
#define BTN_LARGE			2

struct StatusButton 
{
	StatusButtonTypes m_ButtonType;
	WORD	m_BmpNormalID, m_BmpOnMouseID, m_BmpPushedID, m_BmpDownOnMouseID;
	WORD	m_ToolTipStrID;
	INT		m_uiButtonState;
	BOOL   m_fEnable;
};

PUBLIC VOID PASCAL FrameControl(HDC hDC, RECT* pRc, INT iState);
PUBLIC VOID PASCAL DrawBitmap(HDC hDC, LONG xStart, LONG yStart, HBITMAP hBitmap);
PUBLIC BOOL PASCAL SetIndicatorIcon(INT nIconIndex, ATOM atomToolTip);
PUBLIC VOID UpdateStatusButtonInfo();
PUBLIC HANDLE WINAPI OurLoadImage( LPCTSTR pszName, UINT uiType, INT cx, INT cy, UINT uiLoad);
PUBLIC BOOL WINAPI OurTextOutW(HDC hDC, INT x, INT y, WCHAR wch);

#if 1 // MultiMonitor support
PUBLIC void PASCAL ImeMonitorWorkAreaFromWindow(HWND hAppWnd, RECT* pRect);
PUBLIC void PASCAL ImeMonitorWorkAreaFromPoint(POINT, RECT* pRect);
PUBLIC void PASCAL ImeMonitorWorkAreaFromRect(LPRECT, RECT* pRect);
PUBLIC HMONITOR PASCAL ImeMonitorFromRect(LPRECT lprcRect);
#endif

///////////////////////////////////////////////////////////////////////////////
// Inline Functions
inline
HIMC GethImcFromHwnd(HWND hWnd)
{
	if (hWnd == (HWND)0 || IsWindow(hWnd) == fFalse) 
		return (HIMC)NULL;
	else
		return (HIMC)GetWindowLongPtr(hWnd, IMMGWLP_IMC);
}

inline
HGLOBAL GethUIPrivateFromHwnd(HWND hWnd)
{
	if (hWnd == (HWND)0 || IsWindow(hWnd) == fFalse) 
		return (HIMC)NULL;
	else
		return (HGLOBAL)GetWindowLongPtr(hWnd, IMMGWLP_PRIVATE);
}

#endif // !defined (_UI_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\ntmigexe\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\winex.cpp ===
/****************************************************************************
    WINEX.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Windows API extension functions
    
    History:
    19-JUL-1999 cslim       Created
*****************************************************************************/

#include "precomp.h"
#include "winex.h"

static LPSTR GetModuleName(BOOL fFullPath = fFalse);

BOOL vf16BitApps = fFalse;

POSVERSIONINFO GetVersionInfo()
{
    static BOOL fFirstCallVerInfo = fTrue;
    static OSVERSIONINFO os;

    if (fFirstCallVerInfo) 
        {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx( &os ) )
            fFirstCallVerInfo = fFalse;
        }
        
    return &os;
}

BOOL WINAPI IsWinNT() 
{ 
    static BOOL fFirstCallNT4 = fTrue;
    static BOOL fNT4 = fFalse;

    if (fFirstCallNT4 == fFalse)
        return fNT4;

    fFirstCallNT4 = fFalse;
    fNT4 = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (GetVersionInfo()->dwMajorVersion >= 4);

    return fNT4;
}

BOOL WINAPI IsWinNT5orUpper() 
{ 
    static BOOL fFirstCallNT5 = fTrue;
    static BOOL fNT5 = fFalse;

    if (fFirstCallNT5 == fFalse)
        return fNT5;

    fFirstCallNT5 = fFalse;
    fNT5 = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
             (GetVersionInfo()->dwMajorVersion >= 5);

    return fNT5;
}

BOOL WINAPI IsMemphis() 
{ 
    static BOOL fFirstCallMemphis = fTrue;
    static BOOL fMemphis = fFalse;

    if (fFirstCallMemphis == fFalse)
        return fMemphis;

    fFirstCallMemphis = fFalse;
    
    fMemphis = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
                (GetVersionInfo()->dwMajorVersion >= 4) &&
                (GetVersionInfo()->dwMinorVersion  >= 10);

    return fMemphis;
}

BOOL WINAPI IsWin95() 
{
    static BOOL fFirstCallIsWin95 = fTrue;
    static BOOL fIsWin95 = fFalse;

    if (fFirstCallIsWin95 == fFalse)
        return fIsWin95;

    fFirstCallIsWin95 = fFalse;
    
    fIsWin95 = !IsWinNT() && !IsMemphis();

    return fIsWin95;
}

#if !defined(_WIN64)
BOOL WINAPI IsWin64()
{
    static BOOL fFristCallIsWin64 = fTrue;
    static BOOL fIsWin64 = fFalse;
    SYSTEM_INFO sys;

    if (fFristCallIsWin64 == fFalse)
            return fIsWin64;

    GetNativeSystemInfo(&sys);
    
    fIsWin64 = (sys.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
    			||(sys.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64);

    fFristCallIsWin64 = fFalse;
    return fIsWin64;
}
#endif

LPSTR OurGetModuleFileName(BOOL fFullPath)
{
    LPSTR pch;
    LPSTR pchFilename;

    static CHAR szFile[MAX_PATH] = {0};

    if (szFile[0] == '\0')
        GetModuleFileName(NULL, szFile, MAX_PATH);

    if (fFullPath)
        return szFile;

    pch = szFile;
    pchFilename = NULL;
    
    while (*pch++) 
        {
        if (*pch == '\\')
            pchFilename = pch + 1;
        }

    return pchFilename;
}

inline Min(INT a, INT b) 
{
     return ((a)<(b)?(a):(b)) ;
}

//////////////////////////////////////////////////////////////////
// Function : OurLoadStringW
// Type     : INT
// Purpose  : Wrapper of LoadStrinW() API.
//              Load Unicode string with specified Language 
//              in any platform.
// Args     : 
//          : LANGID    lgid 
//          : HINSTANCE hInst 
//          : UINT        uID 
//          : LPWSTR    lpBuffer 
//          : INT        nBufferMax 
// Return   : 
// DATE     : 971028
//////////////////////////////////////////////////////////////////
INT WINAPI OurLoadStringW(HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, INT nBufferMax)
{
    INT     cchwstr = 0;
    UINT    block, num;
    HRSRC   hres;
    HGLOBAL hgbl;
    LPWSTR  lpwstr;

    if (!hInst || !lpBuffer)
        return 0;

    block = (uID >>4)+1;
    num   = uID & 0xf;

    hres = FindResourceEx(hInst,
                          RT_STRING,
                          MAKEINTRESOURCE(block),
                          GetSystemDefaultLangID());

    if (hres == NULL)
        hres = FindResourceEx(hInst,
                          RT_STRING,
                          MAKEINTRESOURCE(block),
                          MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));

    if (!hres)
        goto Error;

    if ((hgbl = LoadResource(hInst, hres)) == NULL)
        goto Error;

    if ((lpwstr = (LPWSTR)LockResource(hgbl)) == NULL)
        goto Error;

    for(UINT i = 0; i < num; i++)
        lpwstr += *lpwstr + 1;

    cchwstr = *lpwstr;
    CopyMemory(lpBuffer, lpwstr+1, Min(cchwstr, nBufferMax-1) * sizeof(WCHAR));
    
 Error:
     lpBuffer[Min(cchwstr, nBufferMax-1)]= (WCHAR)0x0000;
    return cchwstr;
}

//////////////////////////////////////////////////////////////////
// Function : ExLoadStringA
// Type     : INT
// Purpose  : Wrapper of LoadStringA().
// Args     : 
//          : LANGID    lgid
//          : HINSTANCE hInst 
//          : INT        uID 
//          : LPSTR        lpBuffer 
//          : INT        nBufferMax 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI OurLoadStringA(HINSTANCE hInst, INT uID, LPSTR lpBuffer, INT nBufferMax)
{
    INT cchstr;
    LPWSTR lpwstr;

    if (!hInst || !lpBuffer)
        return 0;

    if ((lpwstr = (LPWSTR)GlobalAllocPtr(GHND, nBufferMax*sizeof(WCHAR))) == NULL)
        return 0;

    // Call wide version
    OurLoadStringW(hInst, uID, lpwstr, nBufferMax/2);
    
    // W to A
    cchstr = WideCharToMultiByte(CP_ACP, 
                              0, 
                              lpwstr, -1,
                              lpBuffer, nBufferMax, 
                              NULL, NULL); 

    if (cchstr)
        cchstr--;    // remove NULL char

    GlobalFreePtr(lpwstr);
    return cchstr;
}


//////////////////////////////////////////////////////////////////
// Function : ExLoadMenuTemplate
// Type     : MENUTEMPLATE *
// Purpose  : 
// Args     : 
//          : LANGID lgid 
//          : HINSTANCE hInstance 
//          : LPCSTR pchTemplate 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static MENUTEMPLATE* ExLoadMenuTemplate(LANGID        lgid,
                                         HINSTANCE    hInstance,
                                         LPCSTR    pchTemplate)
{
    HRSRC  hResMenu;
    HANDLE hMenuTmpl;

    hResMenu = FindResourceEx(hInstance, RT_MENU, pchTemplate, lgid);

    if((hResMenu == NULL) && (lgid != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)))
        {
        hResMenu = FindResourceEx(hInstance,
                                 RT_MENU,
                                 pchTemplate,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
        }
        
    if (hResMenu == NULL)
        return NULL; 

    hMenuTmpl = LoadResource( hInstance, hResMenu );
    if(hMenuTmpl == NULL)
        return NULL; /* failed */

    return (MENUTEMPLATE *)LockResource( hMenuTmpl );
}

HMENU WINAPI OurLoadMenu(HINSTANCE hInstance, LPCSTR lpMenuName)
{
    MENUTEMPLATE* pMenuTmpl;
    pMenuTmpl = ExLoadMenuTemplate(GetSystemDefaultLangID(), hInstance, lpMenuName);
    if (pMenuTmpl)
        return LoadMenuIndirect(pMenuTmpl);
    else
        return (HMENU)NULL;
}

DLGTEMPLATE* WINAPI ExLoadDialogTemplate(LANGID lgid, HINSTANCE hInstance, LPCSTR pchTemplate)
{
    HRSRC  hResDlg;
    HANDLE hDlgTmpl;

    hResDlg = FindResourceExA(hInstance, RT_DIALOG, pchTemplate, lgid);

    if ((hResDlg == NULL) && (lgid != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)))
        hResDlg = FindResourceExA(hInstance,
                                  RT_DIALOG,
                                  pchTemplate,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

    if (hResDlg == NULL)
        return NULL; 

    hDlgTmpl = LoadResource(hInstance, hResDlg);

    if(hDlgTmpl == NULL)
        return NULL; /* failed */

    return (DLGTEMPLATE *)LockResource(hDlgTmpl);
}

BOOL WINAPI OurGetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
{
    if (IsWinNT())
        return ::GetMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    else
        return ::GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
}

LPSTR GetModuleName(BOOL fFullPath)
{
    static CHAR szFile[MAX_PATH] = {0};

    if (szFile[0] == '\0' )
        GetModuleFileName( NULL, szFile, MAX_PATH );

    if (fFullPath)
        return szFile;

    LPSTR pch = szFile;
    LPSTR pchFilename = NULL;

    while(*pch++) 
        {
        if (*pch == '\\')
            pchFilename = pch + 1;
        }

    return pchFilename;
}

BOOL IsExplorerProcess()
{
    static BOOL fExplorer = FALSE;
    static BOOL fFirst = TRUE;

    if (fFirst == fFalse)
        return fExplorer;

    fFirst = fFalse;

    LPSTR pchFilename = GetModuleName();
    
    if (pchFilename && lstrcmpi(pchFilename, "EXPLORER.EXE") == 0) 
        { // if this process is MSIME9xM.EXE
        fExplorer = fTrue;
        }

    return fExplorer;
}

BOOL IsExplorer()
{
    if (FindWindow("Progman", NULL) != (HWND)0)
        return fTrue;
    else
        return fFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\uisubs.cpp ===
/****************************************************************************
    UISUBS.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    UI subfunctions
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "ui.h"
#include "imedefs.h"
#include "winex.h"
#include "debug.h"

// For OurLoadImage()
typedef struct tagCOLORRPL 
    {
    COLORREF    cColOrg;
    COLORREF    cColRpl;
    } COLORRPL;

VOID PASCAL DrawBitmap(
    HDC hDC, 
    LONG xStart, 
    LONG yStart, 
    HBITMAP hBitmap)
    {
    HDC     hMemDC;
    HBITMAP hBMOld;
    BITMAP  bm;
    POINT   pt;

    if (hDC == 0 || hBitmap == 0)
        return;
        
    hMemDC = CreateCompatibleDC(hDC);
    hBMOld = (HBITMAP)SelectObject(hMemDC, hBitmap);
    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
    DbgAssert(&bm != NULL);
    pt.x = bm.bmWidth;
    pt.y = bm.bmHeight;
    BitBlt(hDC, xStart, yStart, pt.x, pt.y, hMemDC, 0, 0, SRCCOPY);
    SelectObject(hMemDC, hBMOld);
    DeleteDC(hMemDC);

    return;
    }

HBITMAP WINAPI ReplaceBitmapColor( HBITMAP hBmp, UINT uiColor, COLORRPL* pColOrg )
{
    BITMAP  bmp;
    HBITMAP hBmpNew;
    HDC     hDC, hDCNew, hDCBmp;
    HBITMAP hBmpOld1;
    
    if (GetObject(hBmp, sizeof(BITMAP), &bmp) == 0)
        return 0;

    hBmpNew = CreateBitmap( bmp.bmWidth, bmp.bmHeight, 1, bmp.bmBitsPixel, (VOID*)NULL );

    hDC = GetDC( 0 );
    
    if ((hDCNew = CreateCompatibleDC(hDC)) == 0)
        return 0;
        
    if ((hDCBmp = CreateCompatibleDC(hDC)) == 0)
        {
        DeleteDC(hDCNew);
        return 0;
        }
    
    hBmpOld1 = (HBITMAP)SelectObject(hDCBmp, hBmpNew);

    //
    // Special case : LIGHT GRAY COLOR on WinNT
    //
    COLORRPL* pCol = (COLORRPL*)GlobalAlloc(GPTR, uiColor * sizeof(COLORRPL) );
    INT x = 0;
    INT y = 0;
    UINT iCol = 0;
    COLORREF col = {0};

    for( iCol = 0; iCol < uiColor; iCol++ ) {
        pCol[iCol].cColOrg = SetPixel( hDCBmp, 0, 0, pColOrg[iCol].cColOrg);    // #IMPORTANT# - copy
        pCol[iCol].cColRpl= pColOrg[iCol].cColRpl;    // copy
    }

    // master copy
    HBITMAP hBmpOld  = (HBITMAP)SelectObject(hDCNew, hBmp);
    BitBlt(hDCBmp, 0, 0, bmp.bmWidth, bmp.bmHeight, hDCNew, 0, 0, SRCCOPY); // Fxx
    SelectObject(hDCNew, hBmpOld);
    DeleteObject(hBmp);
    DeleteDC(hDCNew);

    // replace color
    for( y=0; y<bmp.bmHeight; y++ ) {
        for( x=0; x<bmp.bmWidth; x++ ) {
            col = GetPixel( hDCBmp, x, y );
            for( iCol = 0; iCol < uiColor; iCol++ ) {
                if( col == pCol[iCol].cColOrg ) {
                    SetPixel( hDCBmp, x, y, pCol[iCol].cColRpl );
                }
            }
        }
    }

    GlobalFree(pCol);

    SelectObject(hDCBmp, hBmpOld1);

    DeleteDC(hDCBmp);

    ReleaseDC(0, hDC);

    hBmp = hBmpNew;
    return hBmp;
}


HANDLE WINAPI OurLoadImage( LPCTSTR pszName, UINT uiType, INT cx, INT cy, UINT uiLoad)
{
    #define    MAXREPL    3
    HBITMAP hBmp = (HBITMAP)0;

    if (vpInstData->hInst == NULL)
        return NULL;
    
    if (GetSysColor(COLOR_3DFACE) == RGB(0,0,0))
        {
        static COLORRPL colRpl[MAXREPL] = 
            {
            RGB(0,0,0), RGB(255,255,255),
            RGB(192,192,192), RGB(0,0,0),
            RGB(0,0,128), RGB(0,192,192),
            };
        HBITMAP hBmpNew;
        
        uiLoad &= ~LR_LOADMAP3DCOLORS;
        hBmp = (HBITMAP)LoadImage(vpInstData->hInst, pszName, uiType, cx, cy, uiLoad);
        if (hBmp == 0)
            return 0;
        hBmpNew = ReplaceBitmapColor(hBmp, MAXREPL, (COLORRPL*)&colRpl);
        DeleteObject(hBmp);
        hBmp = hBmpNew;
        } 
    else 
        {
        hBmp = (HBITMAP)LoadImage(vpInstData->hInst, pszName, uiType, cx, cy, uiLoad);
        }
        
    return hBmp;
}


BOOL WINAPI OurTextOutW(HDC hDC, INT x, INT y, WCHAR wch)
{
    CHAR szOut[4]; // For one DBCS plus one SBCS NULL + extra one byte
    INT cch;
    
    if (IsWinNT() || IsMemphis())
        return TextOutW( hDC, x, y, &wch, 1);

    // Convert to ANSI
    cch = WideCharToMultiByte(CP_KOREA, 0, 
                        &wch, 1, (LPSTR)szOut, sizeof(szOut), 
                        NULL, NULL );
    DbgAssert(cch == 2);
    return TextOutA(hDC, x, y, szOut, cch);
}

#if 1 // MultiMonitor support
/**********************************************************************/
/* ImeMonitorFromWindow()                                             */
/**********************************************************************/
HMONITOR PASCAL ImeMonitorFromWindow(
    HWND hAppWnd)
{
    if (!g_pfnMonitorFromWindow) { return NULL; }

    return (*g_pfnMonitorFromWindow)(hAppWnd, MONITOR_DEFAULTTONEAREST);
}

/**********************************************************************/
/* ImeMonitorWorkAreaFromWindow()                                     */
/**********************************************************************/
void PASCAL ImeMonitorWorkAreaFromWindow(HWND hAppWnd, RECT* pRect)
{
    HMONITOR hMonitor;
    CIMEData    ImeData;
    RECT        rect;
    
    hMonitor = ImeMonitorFromWindow(hAppWnd);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = ImeData->rcWorkArea;

        (*g_pfnGetMonitorInfo)(hMonitor, &sMonitorInfo);
        *pRect = sMonitorInfo.rcWork;
    } else {
        *pRect = ImeData->rcWorkArea;
    }
}

/**********************************************************************/
/* ImeMonitorFromPoint()                                             */
/**********************************************************************/
HMONITOR PASCAL ImeMonitorFromPoint(
    POINT ptPoint)
{
    if (!g_pfnMonitorFromPoint) { return NULL; }

    return (*g_pfnMonitorFromPoint)(ptPoint, MONITOR_DEFAULTTONEAREST);
}

/**********************************************************************/
/* ImeMonitorWorkAreaFromPoint()                                      */
/**********************************************************************/
void PASCAL ImeMonitorWorkAreaFromPoint(POINT ptPoint, RECT* pRect)
{
    HMONITOR hMonitor;
    CIMEData    ImeData;

    hMonitor = ImeMonitorFromPoint(ptPoint);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = ImeData->rcWorkArea;

        (*g_pfnGetMonitorInfo)(hMonitor, &sMonitorInfo);

        *pRect = sMonitorInfo.rcWork;
    } else {
        *pRect = ImeData->rcWorkArea;
    }
}

/**********************************************************************/
/* ImeMonitorFromRect()                                               */
/**********************************************************************/
HMONITOR PASCAL ImeMonitorFromRect(
    LPRECT lprcRect)
{
    if (!g_pfnMonitorFromRect) { return NULL; }

    return (*g_pfnMonitorFromRect)(lprcRect, MONITOR_DEFAULTTONEAREST);
}

/**********************************************************************/
/* ImeMonitorWorkAreaFromRect()                                       */
/**********************************************************************/
void PASCAL ImeMonitorWorkAreaFromRect(LPRECT lprcRect, RECT* pRect)
{
    HMONITOR hMonitor;
    CIMEData    ImeData;

    hMonitor = ImeMonitorFromRect(lprcRect);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = ImeData->rcWorkArea;

        (*g_pfnGetMonitorInfo)(hMonitor, &sMonitorInfo);

        *pRect = sMonitorInfo.rcWork;
    } else {
        *pRect = ImeData->rcWorkArea;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\ntmigexe\hklhelp.h ===
#define MAX_NAME 100

#ifdef __cplusplus
extern "C" {
#endif

HKL  GetHKLfromHKLM(LPSTR argszIMEFile);
HKL  GetDefaultIMEFromHKCU(HKEY hKeyCU);
BOOL HKLHelpExistInPreload(HKEY hKeyCU, HKL hKL);
BOOL HKLHelp412ExistInPreload(HKEY hKeyCU);
void HKLHelpRemoveFromPreload(HKEY hKeyCU, HKL hKL);
void HKLHelpRemoveFromControlSet(HKL hKL);
void HKLHelpRegisterIMEwithForcedHKL(HKL hKL, LPSTR szIMEFile, LPSTR szTitle);
void HKLHelpGetLayoutString(HKL hKL, LPSTR szLayoutString, DWORD *pcbSize);
void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault);
void SetDefaultKeyboardLayoutForDefaultUser(const HKL hKL);
BOOL AddPreload(HKEY hKeyCU, HKL hKL);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\ntmigexe\hklhelp.cpp ===
#include "private.h"
#include <stdio.h>
#include <stdlib.h>
#include "HKLHelp.h"

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

extern BOOL WINAPI IsNT();

typedef char KeyNameType[MAX_NAME];

// Forward decls.
static void SortRegKeys(KeyNameType *hKLKeyList, KeyNameType *hKLList, INT Num);
static void RenumberPreload(HKEY hKeyCU);
static void SwitcHKLtoIME61();
static BOOL CALLBACK EnumChildProcForSwitchKL(HWND hWnd, LPARAM lParam);
static BOOL CALLBACK EnumProcForSwitchKL(HWND hWnd, LPARAM lParam);

/*---------------------------------------------------------------------------
	GetHKLfromHKLM
---------------------------------------------------------------------------*/
HKL GetHKLfromHKLM(LPSTR argszIMEFile)
{
    HKL  hklAnswer = 0;
    HKEY hKey, hSubKey;
    DWORD i, cbSubKey, cbIMEFile;
    TCHAR szSubKey[MAX_PATH], szIMEFile[MAX_PATH];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\Keyboard Layouts", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    	{
        for (i=0; ;i++)
        	{
        	cbSubKey = MAX_PATH;
			if (RegEnumKeyEx(hKey, i, szSubKey, &cbSubKey, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
				break;
        	
            RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey);

            cbIMEFile=MAX_PATH;
            if (RegQueryValueEx(hSubKey,"IME File",NULL,NULL,(LPBYTE)szIMEFile, &cbIMEFile) == ERROR_SUCCESS)
            	{
                if (lstrcmpi(argszIMEFile, szIMEFile) == 0)
                	{
                    RegCloseKey(hSubKey);
                    sscanf(szSubKey, "%08x", &hklAnswer);
                    break;
                	}
            	}
            RegCloseKey(hSubKey);
        	}
        	
        RegCloseKey(hKey);
    	}
    	
    return(hklAnswer);
}

/*---------------------------------------------------------------------------
	GetDefaultIMEFromHKCU
---------------------------------------------------------------------------*/
HKL GetDefaultIMEFromHKCU(HKEY hKeyCU)
{
    HKEY hKey;
    DWORD cbData;
    BYTE Data[MAX_NAME];
    HKL hKL = 0;

    cbData=sizeof(Data);
    
    if (IsNT())
    	{
        RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_READ, &hKey);
        RegQueryValueEx(hKey, "1", 0, NULL, Data, &cbData);
        RegCloseKey(hKey);
    	}
    else
    	{          // Case of non-NT
        RegOpenKeyEx(hKeyCU, "keyboard layout\\preload\\1", 0, KEY_READ, &hKey);
        RegQueryValueEx(hKey, "", 0, NULL, Data, &cbData);
        RegCloseKey(hKey);
    	}

    sscanf((const char *)Data,"%08x",&hKL);
    return(hKL);
}


/*---------------------------------------------------------------------------
	HKLHelpExistInPreload
---------------------------------------------------------------------------*/
BOOL HKLHelpExistInPreload(HKEY hKeyCU, HKL hKL)
{
    HKEY hKey,hSubKey;
    CHAR szKL[20];
    int i,j;
    DWORD cbName,cbData;
    CHAR Name[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;
    BOOL fResult = FALSE;

    wsprintf(szKL,"%08x",hKL);
    if (IsNT())
    	{
		if (RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
			for (j=0; cbName=MAX_NAME, cbData=MAX_NAME, RegEnumValue(hKey, j, Name, &cbName, NULL, NULL, Data, &cbData) != ERROR_NO_MORE_ITEMS; j++)
				{
				if (lstrcmpi((LPCSTR)Data, szKL) == 0)
					{
					fResult = TRUE;
					break;
					}
				}
	        RegCloseKey(hKey);
	        }
    	}
    else
    	{          // Case of non-NT
        if (RegOpenKeyEx(hKeyCU, "keyboard layout\\preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        	{
			for (i=0; cbName=MAX_NAME, RegEnumKeyEx(hKey, i, Name, &cbName, 0, NULL, NULL, &ftLastWriteTime) != ERROR_NO_MORE_ITEMS; i++)
				{
				RegOpenKeyEx(hKey, Name, 0, KEY_ALL_ACCESS, &hSubKey);
				cbData=MAX_NAME;
				RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
				RegCloseKey(hSubKey);
				
				if (lstrcmpi((LPCSTR)Data, szKL) == 0)
					{
					fResult = TRUE;
					break;
					}
				}
        	RegCloseKey(hKey);
			}
    	}

    return(fResult);
}


/*---------------------------------------------------------------------------
	HKLHelp412ExistInPreload
---------------------------------------------------------------------------*/
BOOL HKLHelp412ExistInPreload(HKEY hKeyCU)
{
    HKEY hKey, hSubKey;
    int i ,j;
    DWORD cbName, cbData;
    CHAR szName[MAX_NAME];
    CHAR szData[MAX_NAME];
    HKL  hkl;
    FILETIME ftLastWriteTime;
    BOOL fResult = FALSE;

    if (IsNT())
    	{
		if (RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
			for (j=0; cbName=MAX_NAME, cbData=MAX_NAME, RegEnumValue(hKey, j, szName, &cbName, NULL, NULL, (LPBYTE)szData, &cbData) != ERROR_NO_MORE_ITEMS; j++)
				{
				// See If Korean KL exist. Just compare last LCID part if it's 0x412.
				// IME hkl set 0xE000 on hiword.
				sscanf(szData, "%08x", &hkl);
				if ((HIWORD(hkl) & 0xe000) && LOWORD(hkl) == 0x0412)
					{
					fResult = TRUE;
					break;
					}
				}
	        RegCloseKey(hKey);
	        }
    	}
    else
    	{          // Case of non-NT
        if (RegOpenKeyEx(hKeyCU, "keyboard layout\\preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        	{
			for (i=0; cbName=MAX_NAME, RegEnumKeyEx(hKey, i, szName, &cbName, 0, NULL, NULL, &ftLastWriteTime) != ERROR_NO_MORE_ITEMS; i++)
				{
				RegOpenKeyEx(hKey, szName, 0, KEY_ALL_ACCESS, &hSubKey);
				cbData=MAX_NAME;
				RegQueryValueEx(hSubKey, "", 0, NULL, (LPBYTE)szData, &cbData);
				RegCloseKey(hSubKey);

				sscanf(szData, "%08x", &hkl);
				if ((HIWORD(hkl) & 0xe000) && LOWORD(hkl) == 0x0412)
					{
					fResult = TRUE;
					break;
					}
				}
        	RegCloseKey(hKey);
			}
    	}

    return(fResult);
}

/*---------------------------------------------------------------------------
	HKLHelpRemoveFromPreload
---------------------------------------------------------------------------*/
void HKLHelpRemoveFromPreload(HKEY hKeyCU, HKL hKL)
{
    HKEY hKey,hSubKey;
    char szKL[20];
    int  i, j;
    DWORD cbName,cbData;
    CHAR szName[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;

    wsprintf(szKL, "%08x", hKL);
    
    if (IsNT())
    	{
        if (RegOpenKeyEx(hKeyCU,"Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
	        for (j=0; ; j++)
	        	{
	        	cbName = MAX_NAME;
	        	cbData = MAX_NAME;
	        	if (RegEnumValue(hKey, j, szName, &cbName, NULL, NULL, Data, &cbData) == ERROR_NO_MORE_ITEMS )
	        		break;
	        	
	            if (lstrcmpi((const char *)Data,szKL) == 0)
	            	{
	                RegDeleteValue(hKey, szName);
	                break;
	            	}
	        	}
	        RegCloseKey(hKey);
	        }
    	}
    else
    	{
    	if (RegOpenKeyEx(hKeyCU,"keyboard layout\\preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    		{
	        for (i=0; ; i++)
	        	{
	        	cbName = MAX_NAME;
	        	if (RegEnumKeyEx(hKey, i, szName, &cbName, 0, NULL, NULL, &ftLastWriteTime) == ERROR_NO_MORE_ITEMS)
	        		break;
	        	
	            RegOpenKeyEx(hKey, szName, 0, KEY_ALL_ACCESS, &hSubKey);
	            cbData = MAX_NAME;
	            RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
	            RegCloseKey(hSubKey);
	            
	            if (lstrcmpi((const char *)Data,szKL) == 0)
	            	{
	                RegDeleteKey(hKey, szName);
	                break;
	            	}
	        	}
	        	
	        RegCloseKey(hKey);
	        }
    	}

    RenumberPreload(hKeyCU);
}

/*---------------------------------------------------------------------------
	HKLHelpRemoveFromControlSet
---------------------------------------------------------------------------*/
void HKLHelpRemoveFromControlSet(HKL hKL)
{
    HKEY hKey;
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,"System\\CurrentControlSet\\control\\keyboard layouts",0,KEY_ALL_ACCESS,&hKey) == ERROR_SUCCESS)
    	{
        CHAR szKeyName[10];
        wsprintf(szKeyName, "%08x", hKL);
        RegDeleteKey(hKey, szKeyName);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpRegisterIMEwithForcedHKL
---------------------------------------------------------------------------*/
void HKLHelpRegisterIMEwithForcedHKL(HKL hKL, LPSTR szIMEFile, LPSTR szTitle)
{
    CHAR szRegPath[MAX_PATH];
    DWORD dwDisposition;
    HKEY hKey;
    CHAR szIMEFileUpper[MAX_PATH];
    
    for (INT i = 0; szIMEFile[i] != 0; i++)
        szIMEFileUpper[i] = (CHAR)toupper(szIMEFile[i]);

    szIMEFileUpper[i] = 0;
    
    wsprintf(szRegPath, "System\\CurrentControlSet\\Control\\Keyboard Layouts\\%08x", hKL);
    
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
    	{
        RegSetValueEx(hKey, "Ime File", 0, REG_SZ, (LPBYTE)szIMEFileUpper, lstrlen(szIMEFile)+1);
        RegSetValueEx(hKey, "Layout Text", 0, REG_SZ, (LPBYTE)szTitle, lstrlen(szTitle)+1);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpGetLayoutString
---------------------------------------------------------------------------*/
void HKLHelpGetLayoutString(HKL hKL, LPSTR szLayoutString, DWORD *pcbSize)
{
    CHAR szRegPath[MAX_PATH];
    HKEY hKey;

    wsprintf(szRegPath, "System\\CurrentControlSet\\Control\\Keyboard Layouts\\%08x", hKL);

    if(ERROR_SUCCESS==RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_READ, &hKey))
    	{
        RegQueryValueEx(hKey, "Layout Text", NULL, NULL, (LPBYTE)szLayoutString, pcbSize);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpSetDefaultKeyboardLayout
---------------------------------------------------------------------------*/
void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault)
{
	char szKL[20];
	BYTE Data[MAX_PATH];
	DWORD cbData;
	char szSubKey[MAX_PATH];
	HKEY hKey,hSubKey;
	DWORD NumKL;

	wsprintf(szKL, "%08x", hKL);

	if (IsNT())
		{
		RegOpenKeyEx(hKeyHKCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
		if (hKey != NULL)
			{
			RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumKL, NULL, NULL, NULL, NULL);
			
			for (DWORD i=0; i<NumKL; i++)
				{
				wsprintf(szSubKey, "%d", i+1);
				cbData = MAX_PATH;
				RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

				if (lstrcmpi((const char *)Data, szKL) == 0)
					break;
				}

			// if hKL is not exist create it.
			if (NumKL == i)
				{
				wsprintf(szSubKey,"%d",i+1);
				RegSetValueEx(hKey, szSubKey, 0, REG_SZ, (const unsigned char *)szKL, lstrlen(szKL)+1);
				NumKL++;
				}

			// Set hKL as first, Shift down other.
	        if(fSetToDefault)
	        	{
				for(int j=i; j>0; j--)
					{
					wsprintf(szSubKey,"%d",j);

					cbData = MAX_PATH;
					RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

					wsprintf(szSubKey,"%d",j+1);
					RegSetValueEx(hKey, szSubKey, 0, REG_SZ, Data, cbData);
					}
				RegSetValueEx(hKey, "1", 0, REG_SZ, (const unsigned char *)szKL, lstrlen(szKL)+1);
				}
			RegCloseKey(hKey);
			}
		}
	else
		{
		RegOpenKeyEx(hKeyHKCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
		if (hKey != NULL)
			{
			RegQueryInfoKey(hKey, NULL, NULL, NULL, &NumKL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
			
			for (DWORD i=0; i<NumKL; i++)
				{
				wsprintf(szSubKey, "%d", i+1);
				RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

				cbData = MAX_PATH;
				RegQueryValueEx(hSubKey, "", NULL, NULL, Data, &cbData);

				if (lstrcmpi((const char *)Data, szKL) == 0)
					break;

				RegCloseKey(hSubKey);
				}

			if (NumKL == i)
				{
				wsprintf(szSubKey,"%d",i+1);
				RegCreateKeyEx(hKey,szSubKey,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hSubKey,NULL);
				RegSetValueEx(hSubKey,"",0,REG_SZ,(const unsigned char *)szKL,lstrlen(szKL)+1);
				RegCloseKey(hSubKey);
				NumKL++;
				}

	        if(fSetToDefault)
	        	{
				for (int j=i; j>0; j--)
					{
					wsprintf(szSubKey, "%d", j);
					RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

					cbData = MAX_PATH;
					RegQueryValueEx(hSubKey, "", NULL, NULL, Data, &cbData);
					RegCloseKey(hSubKey);

					wsprintf(szSubKey,"%d",j+1);
					RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

					cbData = MAX_PATH;
					RegSetValueEx(hSubKey, "", 0, REG_SZ, Data, cbData);
					RegCloseKey(hSubKey);
					}
				
				RegOpenKeyEx(hKey, "1", 0, KEY_ALL_ACCESS, &hSubKey);
				RegSetValueEx(hSubKey, "", 0, REG_SZ, (const LPBYTE)szKL, lstrlen(szKL)+1);
				RegCloseKey(hSubKey);
				}
			RegCloseKey(hKey);
			}
	}

	(void)LoadKeyboardLayout(szKL, KLF_ACTIVATE | KLF_SETFORPROCESS);
	// To activate IME2002 right now without reboot.
	if(fSetToDefault)
	    {
		(void)SystemParametersInfo(SPI_SETDEFAULTINPUTLANG, 0, (HKL*)&hKL, SPIF_SENDCHANGE);
		SwitcHKLtoIME61();
	    }
}

/*---------------------------------------------------------------------------
	SetDefaultKeyboardLayout
---------------------------------------------------------------------------*/
void SetDefaultKeyboardLayoutForDefaultUser(const HKL hKL)
{
    char szKL[20];
    HKEY hKey, hSubKey;

    wsprintf(szKL,"%08x",hKL);

    if (!IsNT())
    	{
    	// Win9x has only one preload.
        RegOpenKeyEx(HKEY_USERS, ".Default\\Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
        RegOpenKeyEx(hKey, "1", 0, KEY_ALL_ACCESS, &hSubKey);
        RegSetValueEx(hSubKey, "", 0, REG_SZ, (const LPBYTE)szKL, lstrlen(szKL)+1);
        RegCloseKey(hSubKey);
        RegCloseKey(hKey);
    	}
}


/*---------------------------------------------------------------------------
	AddPreload
	
	Add IME2002 to preload in given HKCU tree. 
	If there's other old MS-IMEs, remove them from preload. 
	If Korean keyboard layout was the default keyboard layout, 
									set IME2002 as default keyboard layout. 

	Given HKCU usually can be HKEY_CURRENT_USER or HKEY_USERS\.Default.
---------------------------------------------------------------------------*/
BOOL AddPreload(HKEY hKeyCU, HKL hKL)
{
	BOOL fKoreanWasDefault = fFalse;
	HKL  hDefaultKL, hKLOldMSIME;

	// If there is no Kor IME exist in preload, we shouldn't add Kor IME.
	if (!HKLHelp412ExistInPreload(hKeyCU))
		return FALSE;

	hDefaultKL = GetDefaultIMEFromHKCU(hKeyCU);
	
	if (LOWORD(hDefaultKL) == 0x0412)
		fKoreanWasDefault = fTrue;

	// Win95 IME
	hKLOldMSIME = GetHKLfromHKLM("msime95.ime");
	if (hKLOldMSIME)
		{
		HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
		RegFlushKey(hKeyCU);
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	// NT4 IME
	hKLOldMSIME = GetHKLfromHKLM("msime95k.ime");
	if(NULL != hKLOldMSIME)
		{
		HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
		RegFlushKey(hKeyCU);
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	// Win98, ME, NT4 SP6 & W2K IME
	hKLOldMSIME = GetHKLfromHKLM("imekr98u.ime");
	if(NULL != hKLOldMSIME)
		{
		HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
		RegFlushKey(hKeyCU);
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	// Office 10 IME(6.0)
	hKLOldMSIME = GetHKLfromHKLM("imekr.ime");
	if(NULL != hKLOldMSIME)
		{
		HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
		RegFlushKey(hKeyCU);
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	if (hKL && hKL != hDefaultKL)
		HKLHelpSetDefaultKeyboardLayout(hKeyCU, hKL, fKoreanWasDefault);

	return (fKoreanWasDefault);
}

//////////////////////////////////////////////////////////////////////////////
// Private functions
void SortRegKeys(KeyNameType *hKLKeyList, KeyNameType *hKLList, INT Num)
{
    KeyNameType hKeyTmp;
    INT PhaseCur, PhaseEnd;

    for (PhaseEnd=0; PhaseEnd < Num-1; PhaseEnd++)
    	{
        for (PhaseCur = Num-1; PhaseCur > PhaseEnd; PhaseCur--)
        	{
            if(atoi(hKLKeyList[PhaseCur]) < atoi(hKLKeyList[PhaseCur-1]))
            	{
                StringCchCopy(hKeyTmp, MAX_NAME, hKLKeyList[PhaseCur-1]);
                StringCchCopy(hKLKeyList[PhaseCur-1], MAX_NAME, hKLKeyList[PhaseCur]);
                StringCchCopy(hKLKeyList[PhaseCur], MAX_NAME, hKeyTmp);
                StringCchCopy(hKeyTmp, MAX_NAME, hKLList[PhaseCur-1]);
                StringCchCopy(hKLList[PhaseCur-1], MAX_NAME, hKLList[PhaseCur]);
                StringCchCopy(hKLList[PhaseCur], MAX_NAME, hKeyTmp);
            	}
        	}
    	}
}

void RenumberPreload(HKEY hKeyCU)
{
    int i, j, k;
    DWORD cbName,cbData;
    char Name[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;
    HKEY hKey,hSubKey;
    char szNum[10];
    DWORD dwDisposition,MaxValue;
    KeyNameType *hKLKeyList,*hKLList;

    if(IsNT())
    	{
        RegOpenKeyEx(hKeyCU,"keyboard layout\\preload",0,KEY_ALL_ACCESS,&hKey);

        if (RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &MaxValue, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
        	{
            RegCloseKey(hKey);
            return;
        	}

        hKLKeyList = (KeyNameType *)GlobalAllocPtr(GHND, sizeof(KeyNameType)*MaxValue);
        if (hKLKeyList == NULL)
            {
            RegCloseKey(hKey);
        	return;
            }
        hKLList = (KeyNameType *)GlobalAllocPtr(GHND, sizeof(KeyNameType)*MaxValue);
        if (hKLList == NULL)
        	{
        	GlobalFreePtr(hKLKeyList);
            RegCloseKey(hKey);
            return;
        	}

        for (j=0; ;j++)
        	{
        	cbName = MAX_NAME;
        	cbData = MAX_NAME;
        	if (RegEnumValue(hKey, j, Name, &cbName, NULL, NULL, Data, &cbData) == ERROR_NO_MORE_ITEMS)
        		break;
        	
            StringCchCopy(hKLList[j], MAX_NAME, (const char *)Data);
            StringCchCopy(hKLKeyList[j], MAX_NAME, Name);
        	}
        	
        for (k=0; k<j; k++)
            RegDeleteValue(hKey, hKLKeyList[k]);
        	
        SortRegKeys(hKLKeyList, hKLList, j);

        for (k=0; k<j; k++)
        	{
            wsprintf(szNum,"%d",k+1);
            RegSetValueEx(hKey, szNum, 0, REG_SZ, (const unsigned char *)hKLList[k], lstrlen(hKLList[k])+1);
        	}

        RegCloseKey(hKey);
        GlobalFreePtr(hKLList);
        GlobalFreePtr(hKLKeyList);
    	}
    else
    	{
        RegOpenKeyEx(hKeyCU,"keyboard layout\\preload",0,KEY_ALL_ACCESS,&hKey);

        if (RegQueryInfoKey(hKey, NULL, NULL, NULL, &MaxValue, NULL, NULL,NULL,NULL,NULL,NULL,NULL) != ERROR_SUCCESS)
        	{
            RegCloseKey(hKey);
            return;
        	}

        hKLKeyList = (KeyNameType *)GlobalAllocPtr(GHND,sizeof(KeyNameType)*MaxValue);
        hKLList = (KeyNameType *)GlobalAllocPtr(GHND,sizeof(KeyNameType)*MaxValue);

        if (hKLKeyList == NULL || hKLList == NULL)
            return;

        for (i=0; ;i++)
        	{
        	cbName = MAX_NAME;
        	if (RegEnumKeyEx(hKey, i, Name, &cbName, 0, NULL, NULL, &ftLastWriteTime) == ERROR_NO_MORE_ITEMS)
        		break;
        	
            RegOpenKeyEx(hKey, Name, 0, KEY_ALL_ACCESS, &hSubKey);
            
            cbData = MAX_NAME;
            RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
            RegCloseKey(hSubKey);

            StringCchCopy(hKLList[i], MAX_NAME, (const char *)Data);
            StringCchCopy(hKLKeyList[i], MAX_NAME, Name);
        	}
        
        for(k=0; k<i; k++)
	        RegDeleteKey(hKey, hKLKeyList[k]);
    
        SortRegKeys(hKLKeyList, hKLList, i);

        for(k=0; k<i; k++)
        	{
            wsprintf(szNum,"%d",k+1);
            RegCreateKeyEx(hKey, szNum, 0, "",REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisposition);
            RegSetValueEx(hSubKey, "", 0, REG_SZ, (const unsigned char *)hKLList[k], lstrlen(hKLList[k])+1);
            RegCloseKey(hSubKey);
        	}
        	
        RegCloseKey(hKey);
        GlobalFreePtr(hKLList);
        GlobalFreePtr(hKLKeyList);
    }
}

BOOL CALLBACK EnumChildProcForSwitchKL(HWND hWnd, LPARAM lParam)
{
    if (TRUE/*IsWindowVisible( hWnd )*/)
        {
        HKL hKL = (HKL)lParam;
        PostMessage(hWnd, WM_INPUTLANGCHANGEREQUEST, 1/*INPUTLANGCHANGE_SYSCHARSET*/, (LPARAM)hKL);   // change kl to IME8.1
        }
    return TRUE;
}

BOOL CALLBACK EnumProcForSwitchKL(HWND hWnd, LPARAM lParam)
{
    if (TRUE/*IsWindowVisible( hWnd )*/)
        {
        HKL hKL = (HKL)lParam;
        PostMessage(hWnd, WM_INPUTLANGCHANGEREQUEST, 1/*INPUTLANGCHANGE_SYSCHARSET*/, (LPARAM)hKL);

        // try child windows
        EnumChildWindows(hWnd, EnumChildProcForSwitchKL, lParam);
        }
    return TRUE;
}


void SwitcHKLtoIME61()
{
    HKL hKL = NULL;
    HWND hWnd = NULL;
    
    //
    // switch hKL to IME6.1
    //
    hKL = GetHKLfromHKLM(TEXT("imekr61.ime"));   // find IME6.1 kl

    if (hKL != NULL)
        {
        //
        // desktop (special)
        //
        hWnd = FindWindow("Progman", NULL);       // find desktop window

        if (hWnd!= NULL)
            PostMessage(hWnd, WM_INPUTLANGCHANGEREQUEST, 1/*INPUTLANGCHANGE_SYSCHARSET*/, (LPARAM)hKL);

        //
        // generic enum
        //
        EnumWindows(EnumProcForSwitchKL, (LPARAM)hKL);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\imm32\winex.h ===
/****************************************************************************
	WINEX.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Windows API extension functions
	
	History:
	19-JUL-1999 cslim       Created
*****************************************************************************/

#if !defined (_WINEX_H__INCLUDED_)
#define _WINEX_H__INCLUDED_

// Global variable

// Function declare
PUBLIC BOOL WINAPI IsWinNT();
PUBLIC BOOL WINAPI IsWinNT5orUpper() ;
PUBLIC BOOL WINAPI IsMemphis();
PUBLIC BOOL WINAPI IsWin95();
PUBLIC BOOL WINAPI IsWin64();
PUBLIC LPSTR OurGetModuleFileName(BOOL fFullPath);
PUBLIC INT WINAPI OurLoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, INT nBufferMax);
PUBLIC INT WINAPI OurLoadStringA(HINSTANCE hInst, INT uID, LPSTR lpBuffer, INT nBufferMax);
PUBLIC HMENU WINAPI OurLoadMenu(HINSTANCE hInstance, LPCSTR lpMenuName);
PUBLIC DLGTEMPLATE* WINAPI ExLoadDialogTemplate(LANGID lgid, HINSTANCE hInstance, LPCSTR pchTemplate);
PUBLIC BOOL WINAPI OurGetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
PUBLIC BOOL IsExplorerProcess();
PUBLIC BOOL IsExplorer();

__inline BOOL IsUnicodeUI(VOID)
{
	return (IsWinNT() || IsMemphis());
}

/*---------------------------------------------------------------------------
	IsHighContrast
---------------------------------------------------------------------------*/
inline
BOOL IsHighContrastBlack()
{
	// high contrast black
	return (GetSysColor(COLOR_3DFACE) == RGB(0,0,0));
}

#endif // _WINEX_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\inc\common.h ===
//
//   Common.h : Common const and defines
//
//   History:
//   14-DEC-2000 CSLim Created

#if !defined (__COMMON_H__INCLUDED_)
#define __COMMON_H__INCLUDED_

// IME6.1 Root reg key location
const TCHAR g_szIMERootKey[] 		 = TEXT("Software\\Microsoft\\IMEKR\\6.1");
const TCHAR g_szIMEDirectoriesKey[]  = TEXT("Software\\Microsoft\\IMEKR\\6.1\\Directories");
const TCHAR g_szDictionary[]  	= TEXT("Dictionary");  // Basic Hanja lex full path with file name "IMEKR.LEX"
const TCHAR g_szDicPath[]  	= TEXT("DictionaryPath"); // Extended lex path
const TCHAR g_szHelpPath[] 	= TEXT("HelpPath");

// IME Properties reg values
const TCHAR g_szXWEnable[]		 	  = TEXT("ISO10646");
const TCHAR g_szIMEKL[]		 		  = TEXT("InputMethod");
const TCHAR g_szCompDel[]		 	  = TEXT("CompDel");
const TCHAR g_szStatusPos[]			  = TEXT("StatusPos");
const TCHAR g_szCandPos[]		 	  = TEXT("CandPos");
const TCHAR g_szStatusButtons[]  	  = TEXT("StatusButtons");
const TCHAR g_szLexFileNameKey[] 	  = TEXT("LexFile");
const TCHAR g_szEnableK1Hanja[]  	  = TEXT("KSC5657");
const TCHAR g_szEnableCandUnicodeTT[] = TEXT("CandUnicodeTT");

// IME Main version key
const TCHAR g_szVersionKey[] 		  = TEXT("Software\\Microsoft\\IMEKR");
const TCHAR g_szVersion[]             = TEXT("version");

#ifdef _DEBUG
#define SZ_TIPSERVERNAME	TEXT("DBGKRCIC")
#define SZ_TIPNAME			L"DBGKRCIC"
#define SZ_TIPDISPNAME		L"Korean Input System (IME 2002) (Debug)"
#define SZ_TIPMODULENAME   L"imekrcic.dll"
#else /* !DEBUG */
#define SZ_TIPSERVERNAME	TEXT("IMEKRCIC")
#define SZ_TIPNAME			L"IMEKRCIC"
#define SZ_TIPDISPNAME		L"Korean Input System (IME 2002)"
#define SZ_TIPMODULENAME   L"imekrcic.dll"
#endif /* !DEBUG */

// Korean TIP CLSID
// {766A2C15-B226-4fd6-B52A-867B3EBF38D2}
DEFINE_GUID(CLSID_KorIMX, 0x766A2C15, 0xB226, 0x4FD6, 0xb5, 0x2a, 0x86, 0x7b, 0x3e, 0xbf, 0x38, 0xd2);

// Korean TIP profile
// {83C18F16-5DD8-4157-A34A-3C5AB2089E11}
DEFINE_GUID(GUID_Profile, 0x83c18f16, 0x5dd8, 0x4157, 0xa3, 0x4a, 0x3c, 0x5a, 0xb2, 0x8, 0x9e, 0x11);


//
// generic COM stuff
//
#define SafeRelease(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
    }                           \
}                   

#define SafeReleaseClear(punk)  \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
        (punk) = NULL;          \
    }                           \
}  

//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

#endif // !defined (__COMMON_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\ntmigexe\private.h ===
//
//  Private.h
//
//  Contents:   Private header for korimx project.
//

#if !defined (__PRIVATE_H__INCLUDED_)
#define __PRIVATE_H__INCLUDED_

#include <windows.h>
#include <windowsx.h>
#include <msi.h>
#include <msiquery.h>

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#define fTrue   1
#define fFalse  0

#endif  // __PRIVATE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\ntmigexe\winmain.cpp ===
/****************************************************************************
   WINMAIN.CPP : Per-user migration and reg install

   History:
      22-SEP-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include <shlobj.h>
#include "hklhelp.h"
#include "msctf.h"

#include <initguid.h>
#include "common.h"

#define MEMALLOC(x)      LocalAlloc(LMEM_FIXED, x)
#define MEMFREE(x)       LocalFree(x)

// Current Major version. Whistler has IME 6.1
#define MAJORVER "6.1"

// IME 6.1 main module
#define SZMODULENAME_MAIN              "imekr61.ime"
#define IME_REGISTRY_MIGRATION          "IMEKRMIG6.1"
extern BOOL WINAPI IsNT();

// Private functions
static void MigrateUserData(HKEY hKeyCurrentUser);
static void WriteHKCUData(HKEY hKeyCurrentUser);
static BOOL IsNewerAppsIMEExist();
static VOID EnableTIPByDefault(GUID clsidTIP, GUID guidProfile, BOOL fEnable);
static VOID EnableTIP(GUID clsidTIP, GUID guidProfile, BOOL fEnable);
static VOID DisableTIP61();
static VOID DisableTIP60();
static PSID KYGetCurrentSID();
static BOOL GetTextualSid(PSID pSid, LPSTR TextualSid, LPDWORD dwBufferLen);
static void GetSIDString(LPSTR tszBuffer, SIZE_T cbBuffLen);
static POSVERSIONINFO GetVersionInfo();
static void CheckForDeleteRunReg();
static DWORD OpenUserKeyForWin9xUpgrade(LPSTR pszUserKeyA, HKEY *phKey);
static void RestoreMajorVersionRegistry();
static PSECURITY_DESCRIPTOR CreateSD();
static PSID MyCreateSid(DWORD dwSubAuthority);

    
/*---------------------------------------------------------------------------
    WinMain
---------------------------------------------------------------------------*/
INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
    HKEY  hKeyCurrentUser = NULL, hKey = NULL;
    TCHAR szMigrateUserKey[MAX_PATH];
    TCHAR szBuffer[500];
    HKL   hKL;
    BOOL  fMigrationAlreadyDone = FALSE;
    BOOL  fWin9xMig = FALSE;

    if (lpCmdLine)
        {
        LPSTR sz_Arg1 = NULL;
		LPSTR sz_Arg2 = NULL;

		sz_Arg1 = strtok(lpCmdLine, " \t");
		sz_Arg2 = strtok(NULL, " \t");
		if (lstrcmpi(sz_Arg1, "Win9xMig") == 0)
		    {
		    OpenUserKeyForWin9xUpgrade(sz_Arg2, &hKeyCurrentUser);
    		if (hKeyCurrentUser != NULL)
	    	    fWin9xMig = TRUE;
		    }
        }

    if (hKeyCurrentUser == NULL)
        hKeyCurrentUser = HKEY_CURRENT_USER;
    
    StringCchCopy(szMigrateUserKey, ARRAYSIZE(szMigrateUserKey), g_szIMERootKey);
    StringCchCat(szMigrateUserKey, ARRAYSIZE(szMigrateUserKey), "\\MigrateUser");

    // Check Migrated flag
    if (RegOpenKeyEx(hKeyCurrentUser, g_szIMERootKey, 0, KEY_ALL_ACCESS, &hKey)== ERROR_SUCCESS )
        {
        if (RegQueryValueEx(hKey, "Migrated", NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            fMigrationAlreadyDone = TRUE;
        else
            fMigrationAlreadyDone = FALSE;

        RegCloseKey(hKey);
    }
    
    // if sid exists under HKLM\Software\Microsoft\IMEKR\6.1\MigrateUser migrate and delete sid from reg
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMigrateUserKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        GetSIDString(szBuffer, sizeof(szBuffer)); // get the sid of the current user

        if (RegQueryValueEx(hKey, szBuffer, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
            HKEY  hKeyRW;
            // Get R/W access again.
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMigrateUserKey, 0, KEY_ALL_ACCESS, &hKeyRW) == ERROR_SUCCESS)
                {
                // Delete current user's sid
                RegDeleteValue(hKeyRW, szBuffer);

                // Change MigrateUser List security settings
                PSECURITY_DESCRIPTOR pSD = CreateSD();
                if (pSD)
                    {
                    RegSetKeySecurity(hKeyRW, DACL_SECURITY_INFORMATION, pSD);
                    MEMFREE(pSD);
                    }                        
                RegCloseKey(hKeyRW);
                }
            }
        else
            fMigrationAlreadyDone = TRUE;
        RegCloseKey(hKey);
        }

    // If no more user list for migration, delete run reg.
    if (!fWin9xMig)
        CheckForDeleteRunReg();

    // in, Lab06 2643 build Profilelist NULL when IMKRINST.EXE run.
    //if (fMigrationAlreadyDone)
    //    return (0);

    if (!IsNewerAppsIMEExist())
        {
        if (!fMigrationAlreadyDone || fWin9xMig)
            {
            // 1. Do migrate
            MigrateUserData(hKeyCurrentUser);

            // 2. Write any HKCU data
            WriteHKCUData(hKeyCurrentUser);

            // 3. Clean up HKCU preload reg. (Remove old IME)
            hKL = GetHKLfromHKLM(SZMODULENAME_MAIN);
            if (hKL && HKLHelp412ExistInPreload(hKeyCurrentUser))
                {
                AddPreload(hKeyCurrentUser, hKL);
                // Enable TIP
                EnableTIP(CLSID_KorIMX, GUID_Profile, fTrue);
                }

            // Set migrated reg
            if (RegOpenKeyEx(hKeyCurrentUser, g_szIMERootKey, 0, KEY_ALL_ACCESS, &hKey)== ERROR_SUCCESS )
                {
                DWORD dwMigrated = 1;
                RegSetValueEx(hKey, "Migrated", 0, REG_DWORD, (BYTE *)&dwMigrated, sizeof(DWORD));
                RegCloseKey(hKey);
                }
            }
        
        // !!! WORKAROUND CODE !!!
        // Check if IME HKL exist in HKU\.Default, then enable the TIP by default.
        // In US Whistler, IME HKL added to "HKU\.Default\KeyboarLayout\Preload" after IMKRINST.EXE run
        // But IMKRINST disable KOR TIP if there is no Kor IME in the preload.
        // So this code reenable the default setting. Only work when admin right user first logon.
        if (RegOpenKeyEx(HKEY_USERS, TEXT(".DEFAULT"), 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
            {
            if (HKLHelp412ExistInPreload(hKey))
                EnableTIPByDefault(CLSID_KorIMX, GUID_Profile, fTrue);
            RegCloseKey(hKey);
            }
        // !!! End of WORKAROUND CODE !!!
    
        // If IME 6.0 TIP(Office 10 IME) exist in system, Disable it.
        DisableTIP60();
        }
    else
        {
        // Remove IME 6.1 from Preload
        hKL = GetHKLfromHKLM(SZMODULENAME_MAIN);
        HKLHelpRemoveFromPreload(hKeyCurrentUser, hKL);
        DisableTIP61();
        }

    if (hKeyCurrentUser != HKEY_CURRENT_USER)
        RegCloseKey(hKeyCurrentUser);

    return(0);
}


//////////////////////////////////////////////////////////////////////////////
// Private functions
//////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    MigrateUserData

    This function migrate BeolSik and K1 Hanja setting
    Search IME98, Win95 IME, NT4 IME and AIME reg.
---------------------------------------------------------------------------*/
void MigrateUserData(HKEY hKeyCurrentUser)
{
    const INT iMaxIMERegKeys = 5;
    static LPSTR rgszOldIMERegKeys[iMaxIMERegKeys] = 
            {
            // IME 2002(6.0)
            "Software\\Microsoft\\IMEKR\\6.0",
            // IME98
            "Software\\Microsoft\\Windows\\CurrentVersion\\IME\\Korea\\IMEKR98U",
            // Win95 IME
            "Software\\Microsoft\\Windows\\CurrentVersion\\MSIME95",
            // Kor NT4 IME
            "Software\\Microsoft\\Windows\\CurrentVersion\\MSIME95K",
            // Korean AIME
            "Software\\Microsoft\\Windows\\CurrentVersion\\Wansung"
            };

    // Beolsik value
    static CHAR szBeolsik[]    = "InputMethod";
    // K1 Hanja enable(IME98 only)
    static CHAR szEnableK1Hanja[] = "KSC5657";

    HKEY    hKey;
    DWORD    dwCb, dwIMEKL, dwKSC5657;

    // Set default values
    dwIMEKL = dwKSC5657 = 0;

    for (INT i=0; i<iMaxIMERegKeys; i++)
        {
        if (RegOpenKeyEx(hKeyCurrentUser, rgszOldIMERegKeys[i], 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
            {
            ///////////////////////////////////////////////////////////////////
            // Get Beolsik
            dwCb = sizeof(dwIMEKL);
            if (RegQueryValueEx(hKey, szBeolsik, NULL, NULL, (LPBYTE)&dwIMEKL, &dwCb) != ERROR_SUCCESS) 
                {
                dwIMEKL = 0;
                }

            ///////////////////////////////////////////////////////////////////
            // Get K1 Hanja Setting
            dwCb = sizeof(dwKSC5657);
            if (RegQueryValueEx(hKey, szEnableK1Hanja, NULL, NULL, (LPBYTE)&dwKSC5657, &dwCb) != ERROR_SUCCESS) 
                {
                dwKSC5657 = 0;
                }

            RegCloseKey(hKey);
            // Break for loop
            break;
            }
        }

    // Set values to IME2002 reg
    if (RegCreateKey(hKeyCurrentUser, g_szIMERootKey, &hKey) == ERROR_SUCCESS) 
        {
        // 1. BeolSik
        dwCb = sizeof(dwIMEKL);
        if (dwIMEKL >= 100 && dwIMEKL <= 102)
            dwIMEKL -= 100;
        else
        if (dwIMEKL > 2) // Only accept 0, 1, 2
            dwIMEKL = 0;
        RegSetValueEx(hKey, szBeolsik, 0, REG_DWORD, (LPBYTE)&dwIMEKL, dwCb);

        // K1 Hanja flag
        if (dwKSC5657 != 0 && dwKSC5657 != 1) // Only accept 0 or 1
            dwKSC5657 = 0;
        RegSetValueEx(hKey, szEnableK1Hanja, 0, REG_DWORD, (LPBYTE)&dwKSC5657, dwCb);

        RegCloseKey(hKey);
        }
}

/*---------------------------------------------------------------------------
    WriteHKCUData
---------------------------------------------------------------------------*/
void WriteHKCUData(HKEY hKeyCurrentUser)
{
    HKEY hKey;
    
    // Set default Tip as for Cicero.
    CoInitialize(NULL);

    ITfInputProcessorProfiles *pProfile;
    HRESULT hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (SUCCEEDED(hr)) 
        {
        pProfile->SetDefaultLanguageProfile(MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), 
                                            CLSID_KorIMX, GUID_Profile);
        pProfile->Release();
        }

    CoUninitialize();

    // Reset Show Status
    if (RegOpenKeyEx(hKeyCurrentUser, "Control Panel\\Input Method", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        LPSTR szStatus = "1";
        
           RegSetValueEx(hKey, "Show Status", 0, REG_SZ, (BYTE *)szStatus, (sizeof(CHAR)*lstrlen(szStatus)));
        RegCloseKey(hKey);
        }
}
    
/*---------------------------------------------------------------------------
    IsNewerAppsIMEExist
---------------------------------------------------------------------------*/
BOOL IsNewerAppsIMEExist()
{
    HKEY  hKey;
    float flInstalledVersion, flVersion;
    CHAR  szVersion[MAX_PATH];
    DWORD cbVersion = MAX_PATH;
    BOOL  fNewer = FALSE;

    RestoreMajorVersionRegistry();
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        if (RegQueryValueEx(hKey, "version", NULL, NULL, (BYTE *)szVersion, &cbVersion) == ERROR_SUCCESS)
            {
            flInstalledVersion = (float)atof(szVersion);
            flVersion = (float)atof(MAJORVER);
            
            if (flVersion < flInstalledVersion)
                fNewer = TRUE;
            }
        RegCloseKey(hKey);
        }
    
    return fNewer;
}

/*---------------------------------------------------------------------------
    DisableTIP60ByDefault
---------------------------------------------------------------------------*/
VOID EnableTIPByDefault(GUID clsidTIP, GUID guidProfile, BOOL fEnable)
{
    // Set default Tip as for Cicero.
    CoInitialize(NULL);

    ITfInputProcessorProfiles *pProfile;
    HRESULT hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (SUCCEEDED(hr)) 
        {
        pProfile->EnableLanguageProfileByDefault(clsidTIP, 
                                        MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), guidProfile, fEnable);
                                        
        pProfile->Release();
        }

    CoUninitialize();
}

/*---------------------------------------------------------------------------
    EnableTip
---------------------------------------------------------------------------*/
VOID EnableTIP(GUID clsidTIP, GUID guidProfile, BOOL fEnable)
{
    // Set default Tip as for Cicero.
    CoInitialize(NULL);

    ITfInputProcessorProfiles *pProfile;
    HRESULT hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (SUCCEEDED(hr)) 
        {
        BOOL fCurEnabled = FALSE;
        pProfile->IsEnabledLanguageProfile(clsidTIP, 
                                        MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), guidProfile, &fCurEnabled);
        if (fCurEnabled != fEnable)
            pProfile->EnableLanguageProfile(clsidTIP, 
                                        MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), guidProfile, fEnable);
                                        
        pProfile->Release();
        }

    CoUninitialize();
}

/*---------------------------------------------------------------------------
    DisableTip61
---------------------------------------------------------------------------*/
VOID DisableTIP61()
{
    // Disable from HKLM
    EnableTIPByDefault(CLSID_KorIMX, GUID_Profile, fFalse);   // Actually mig exe was not registered by IMKRINST.EXE if newer apps IME exist.
    // Dsiable from HKCU to make sure
    EnableTIP(CLSID_KorIMX, GUID_Profile, fFalse);
}

/*---------------------------------------------------------------------------
    DisableTip60
---------------------------------------------------------------------------*/
VOID DisableTIP60()
{
    // KorIMX CLSID
    // {766A2C14-B226-4fd6-B52A-867B3EBF38D2}
    const static CLSID CLSID_KorTIP60  =  
    {
        0x766A2C14,
        0xB226,
        0x4FD6,
        {0xb5, 0x2a, 0x86, 0x7b, 0x3e, 0xbf, 0x38, 0xd2}
      };

      const static GUID g_guidProfile60 = 
    // {E47ABB1E-46AC-45f3-8A89-34F9D706DA83}
    {    0xe47abb1e,
        0x46ac,
        0x45f3,
        {0x8a, 0x89, 0x34, 0xf9, 0xd7, 0x6, 0xda, 0x83}
    };
    // Disable from HKLM
    EnableTIPByDefault(CLSID_KorTIP60, g_guidProfile60, fFalse);  // Actually already done by IMKRINST.EXE
    // Dsiable from HKCU to make sure
    EnableTIP(CLSID_KorTIP60, g_guidProfile60, fFalse);
}

/*---------------------------------------------------------------------------
    GetTextualSid
---------------------------------------------------------------------------*/
BOOL GetTextualSid(PSID pSid, LPSTR TextualSid, LPDWORD dwBufferLen)
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    if (!IsValidSid(pSid)) 
        return FALSE;

    // SidIdentifierAuthority ???
    psia=GetSidIdentifierAuthority(pSid);

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    if (*dwBufferLen < dwSidSize)
        {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
        }

    // S-SID_REVISION
    dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    // SidIdentifierAuthority
    if ((psia->Value[0] != 0) || (psia->Value[1] != 0))
        {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                        TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                        (USHORT)psia->Value[0],
                        (USHORT)psia->Value[1],
                        (USHORT)psia->Value[2],
                        (USHORT)psia->Value[3],
                        (USHORT)psia->Value[4],
                        (USHORT)psia->Value[5]);
        }
    else
        {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                        TEXT("%lu"),
                        (ULONG)(psia->Value[5]      )   +
                        (ULONG)(psia->Value[4] <<  8)   +
                        (ULONG)(psia->Value[3] << 16)   +
                        (ULONG)(psia->Value[2] << 24)   );
        }

    // SidSubAuthorities
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
        {
        dwSidSize += wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                            *GetSidSubAuthority(pSid, dwCounter) );
        }

    return fTrue;
}


/*---------------------------------------------------------------------------
    KYGetCurrentSID
---------------------------------------------------------------------------*/
PSID KYGetCurrentSID()
{
    HANDLE hToken = NULL;
    BOOL bSuccess;
    #define MY_BUFSIZE 512  // highly unlikely to exceed 512 bytes
    static UCHAR InfoBuffer[MY_BUFSIZE];
    DWORD cbInfoBuffer = MY_BUFSIZE;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) 
            return(NULL);
    
    bSuccess = GetTokenInformation(
                        hToken,
                        TokenUser,
                        InfoBuffer,
                        cbInfoBuffer,
                        &cbInfoBuffer
                        );

    if (!bSuccess)
        {
        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
            //
            // alloc buffer and try GetTokenInformation() again
            //

            CloseHandle(hToken);
            return(NULL);
            }
        else
            {
            //
            // error getting token info
            //

            CloseHandle(hToken);
            return(NULL);
            }
        }

    CloseHandle(hToken);

    return(((PTOKEN_USER)InfoBuffer)->User.Sid);
}


/*---------------------------------------------------------------------------
    GetSIDString
---------------------------------------------------------------------------*/
void GetSIDString(LPSTR tszBuffer, SIZE_T cbBuffLen)
{
    DWORD cbBuffer = (DWORD)cbBuffLen;
    
    if (!GetTextualSid(KYGetCurrentSID(), tszBuffer, &cbBuffer))
        tszBuffer[0] = 0;
}

/*---------------------------------------------------------------------------
    GetVersionInfo
---------------------------------------------------------------------------*/
POSVERSIONINFO GetVersionInfo()
{
    static BOOL fFirstCall = fTrue;
    static OSVERSIONINFO os;

    if (fFirstCall)
        {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&os))
            fFirstCall = fFalse;
        }

    return &os;
}

/*---------------------------------------------------------------------------
    IsNT
---------------------------------------------------------------------------*/
BOOL WINAPI IsNT()
{ 
    BOOL fResult;
    fResult = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT);

    return fResult;
}

/*---------------------------------------------------------------------------
    CheckForDeleteRunReg
---------------------------------------------------------------------------*/
void CheckForDeleteRunReg()
{
    HKEY   hKey, hRunKey;
    TCHAR  szValueName[MAX_PATH];
    TCHAR  szMigUserKey[MAX_PATH];
    DWORD cbValueName   = MAX_PATH;
    BOOL   fRemoveRunKey = FALSE;

    StringCchCopy(szMigUserKey, ARRAYSIZE(szMigUserKey), g_szIMERootKey);
    StringCchCat(szMigUserKey, ARRAYSIZE(szMigUserKey), TEXT("\\MigrateUser"));
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMigUserKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        if (RegEnumValue(hKey, 0, szValueName, &cbValueName, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
            fRemoveRunKey = TRUE;
        
        RegCloseKey(hKey);
        }
    else
        fRemoveRunKey = TRUE;


    if (fRemoveRunKey && 
        (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_ALL_ACCESS, &hRunKey)) == ERROR_SUCCESS)
        {
        RegDeleteValue(hRunKey, IME_REGISTRY_MIGRATION);
        RegCloseKey(hRunKey);
        }
}

//
// On upgrades from Win9x we are passed a string value representing the 
// key under which we'll find the user's Control Panel\Appearance subkey.
// The string is in the form "HKCU\$$$".  We first translate the root key
// descriptor into a true root key then pass that root and the "$$$" 
// part onto RegOpenKeyEx.  This function takes that string and opens
// the associated hive key.
//
DWORD OpenUserKeyForWin9xUpgrade(LPSTR pszUserKeyA, HKEY *phKey)
{
    DWORD dwResult = ERROR_INVALID_PARAMETER;

    if (NULL != pszUserKeyA && NULL != phKey)
    {
        typedef struct {
            char *pszRootA;
            HKEY hKeyRoot;

        } REGISTRY_ROOTS, *PREGISTRY_ROOTS;

        static REGISTRY_ROOTS rgRoots[] = {
            { "HKLM",                 HKEY_LOCAL_MACHINE   },
            { "HKEY_LOCAL_MACHINE",   HKEY_LOCAL_MACHINE   },
            { "HKCC",                 HKEY_CURRENT_CONFIG  },
            { "HKEY_CURRENT_CONFIG",  HKEY_CURRENT_CONFIG  },
            { "HKU",                  HKEY_USERS           },
            { "HKEY_USERS",           HKEY_USERS           },
            { "HKCU",                 HKEY_CURRENT_USER    },
            { "HKEY_CURRENT_USER",    HKEY_CURRENT_USER    },
            { "HKCR",                 HKEY_CLASSES_ROOT    },
            { "HKEY_CLASSES_ROOT",    HKEY_CLASSES_ROOT    }
          };

        char szUserKeyA[MAX_PATH];      // For a local copy.
        LPSTR pszSubKeyA = szUserKeyA;

        //
        // Make a local copy that we can modify.
        //
        lstrcpynA(szUserKeyA, pszUserKeyA, ARRAYSIZE(szUserKeyA));

        *phKey = NULL;
        //
        // Find the backslash.
        //
        while(*pszSubKeyA && '\\' != *pszSubKeyA)
            pszSubKeyA++;

        if ('\\' == *pszSubKeyA)
        {
            HKEY hkeyRoot = NULL;
            int i;
            //
            // Replace backslash with nul to separate the root key and
            // sub key strings in our local copy of the original argument 
            // string.
            //
            *pszSubKeyA++ = '\0';
            //
            // Now find the true root key in rgRoots[].
            //
            for (i = 0; i < ARRAYSIZE(rgRoots); i++)
            {
                if (0 == lstrcmpiA(rgRoots[i].pszRootA, szUserKeyA))
                {
                    hkeyRoot = rgRoots[i].hKeyRoot;
                    break;
                }
            }
            if (NULL != hkeyRoot)
            {
                //
                // Open the key.
                //
                dwResult = RegOpenKeyExA(hkeyRoot,
                                         pszSubKeyA,
                                         0,
                                         KEY_ALL_ACCESS,
                                         phKey);
            }
        }
    }
    return dwResult;
}

/*---------------------------------------------------------------------------
    RestoreMajorVersionRegistry

    Restore IME major version reg value. 
    It could be overwritten during Win9x to NT upgrade.
---------------------------------------------------------------------------*/
void RestoreMajorVersionRegistry()
{
    HKEY  hKey;
    
    ///////////////////////////////////////////////////////////////////////////
    // Restore IME major version reg value. 
    // It could be overwritten during Win9x to NT upgrading.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        CHAR  szVersion[MAX_PATH];
        DWORD cbVersion = MAX_PATH;
    	CHAR szMaxVersion[MAX_PATH];
		FILETIME time;
		float flVersion, flMaxVersion;

        StringCchCopy(szMaxVersion, ARRAYSIZE(szMaxVersion),  "0");
 		for (int i=0; cbVersion = MAX_PATH, RegEnumKeyEx(hKey, i, szVersion, &cbVersion, NULL, NULL, NULL, &time) != ERROR_NO_MORE_ITEMS; i++)
            {
            if (lstrcmp(szVersion, szMaxVersion) > 0)
                StringCchCopy(szMaxVersion, ARRAYSIZE(szMaxVersion), szVersion);
            }

        StringCchCopy(szVersion, ARRAYSIZE(szVersion), "0");
        RegQueryValueEx(hKey, g_szVersion, NULL, NULL, (BYTE *)szVersion, &cbVersion);
        flVersion = (float)atof(szVersion);
        flMaxVersion = (float)atof(szMaxVersion);

        if (flVersion < flMaxVersion)
            RegSetValueEx(hKey, g_szVersion, 0, REG_SZ, (BYTE *)szMaxVersion, (sizeof(CHAR)*lstrlen(szMaxVersion)));

        RegCloseKey(hKey);
	}
    ///////////////////////////////////////////////////////////////////////////
}

/*---------------------------------------------------------------------------
    CreateSecurityAttributes
---------------------------------------------------------------------------*/
PSECURITY_DESCRIPTOR CreateSD()
{
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    ULONG                AclSize;

    PSID                 psid1, psid2, psid3, psid4;
    BOOL                 fResult;

    psid1 = MyCreateSid(SECURITY_INTERACTIVE_RID);
    if (psid1 == NULL)
        return NULL;

    psid2 = MyCreateSid(SECURITY_LOCAL_SYSTEM_RID);
    if (psid2 == NULL)
        goto Fail4;

    psid3 = MyCreateSid(SECURITY_SERVICE_RID);
    if (psid3 == NULL)
        goto Fail3;

    psid4 = MyCreateSid(SECURITY_NETWORK_RID);
    if (psid4 == NULL)
        goto Fail2;

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SIDs we've just created.
    //
    AclSize =  sizeof(ACL) + 
               (4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) + 
               GetLengthSid(psid1) + 
               GetLengthSid(psid2) + 
               GetLengthSid(psid3) + 
               GetLengthSid(psid4);

    //
    // allocate and initialize a new security descriptor plus ACL
    //
    psd = MEMALLOC(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);
    if (psd == NULL)
    {
        return NULL;
    }

    pacl = (PACL)((LPBYTE)psd + SECURITY_DESCRIPTOR_MIN_LENGTH);

    fResult = InitializeAcl(pacl, AclSize, ACL_REVISION);
    if (!fResult)
    {
        goto Fail;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid1);

    if (!fResult)
    {
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid2);

    if (!fResult)
    {
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid3);

    if (!fResult)
    {
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid4);

    if (!fResult)
    {
        goto Fail;
    }

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl))
    {
        goto Fail;
    }


    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
    {
        goto Fail;
    }

    fResult = SetSecurityDescriptorDacl(psd, fTrue, pacl, fFalse );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if (!fResult)
    {
        goto Fail;
    } 

    if (!IsValidSecurityDescriptor(psd))
    {
        goto Fail;
    }

    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid(psid1);
    FreeSid(psid2);
    FreeSid(psid3);
    FreeSid(psid4);

    return psd;

Fail:
    MEMFREE(psd);
    FreeSid(psid4);
Fail2:
    FreeSid(psid3);
Fail3:
    FreeSid(psid2);
Fail4:
    FreeSid(psid1);
    
    return NULL;
}

PSID MyCreateSid(DWORD dwSubAuthority)
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid(&SidAuthority,
                                       1,
                                       dwSubAuthority,
                                       0,0,0,0,0,0,0,
                                       &psid );
    if (!fResult)
    {
        return NULL;
    }

    if (!IsValidSid(psid))
    {
        FreeSid(psid);
        return NULL;
    }

    return psid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\candkey.cpp ===
//
// candkey.cpp
//

#include "private.h"
#include "candkey.h"

/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  K E Y  T A B L E                                        */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIKeyTable::CCandUIKeyTable( int nDataMax )
{
    m_cRef = 1;

    m_pData    = new CANDUIKEYDATA[ nDataMax ];
    m_nData    = 0;
    m_nDataMax = nDataMax;
}


/*   ~  C  C A N D  U I  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIKeyTable::~CCandUIKeyTable( void )
{
    delete m_pData;
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

    Query interface
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIKeyTable::QueryInterface( REFIID riid, void **ppvObj )
{
    if (ppvObj == NULL) {
        return E_POINTER;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIKeyTable )) {
        *ppvObj = SAFECAST( this, ITfCandUIKeyTable* );
    }


    if (*ppvObj == NULL) {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

    Increment reference count
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIKeyTable::AddRef( void )
{
    m_cRef++;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

    Decrement reference count and release object
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIKeyTable::Release( void )
{
    m_cRef--;
    if (0 < m_cRef) {
        return m_cRef;
    }

    delete this;
    return 0;    
}


/*   G E T  K E Y  D A T A  N U M   */
/*------------------------------------------------------------------------------

    Get count of key data
    (ITfCandUIKeyTable method)

------------------------------------------------------------------------------*/
HRESULT CCandUIKeyTable::GetKeyDataNum( int *piNum )
{
    if (piNum == NULL) {
        return E_INVALIDARG;
    }

    *piNum = m_nData;
    return S_OK;
}


/*   G E T  K E Y  D A T A   */
/*------------------------------------------------------------------------------

    Get key data
    (ITfCandUIKeyTable method)

------------------------------------------------------------------------------*/
HRESULT CCandUIKeyTable::GetKeyData( int iData, CANDUIKEYDATA *pData )
{
    *pData = m_pData[iData];
    return S_OK;
}


/*   A D D  K E Y  D A T A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIKeyTable::AddKeyData(const CANDUIKEYDATA *pData)
{
    if (m_nDataMax <= m_nData) {
        return E_FAIL;
    }

    if (pData == NULL) {
        Assert(FALSE);
        return E_INVALIDARG;
    }

    m_pData[ m_nData ] = *pData;
    m_nData++;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\candkey.h ===
//
// candkey.h
//

#if !defined (__CANDKEY_H__INCLUDED_)
#define __CANDKEY_H__INCLUDED_

#include "private.h"
#include "mscandui.h"

//
// CCandUIKeyTable
//

class CCandUIKeyTable : public ITfCandUIKeyTable
{
public:
	CCandUIKeyTable(int nData);
	~CCandUIKeyTable();

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//
	// ITfCandUIKeyTable
	//
	STDMETHODIMP GetKeyDataNum(int *piNum);
	STDMETHODIMP GetKeyData(int iData, CANDUIKEYDATA *pData);

	//
	//
	//
	HRESULT AddKeyData(const CANDUIKEYDATA *pData);

protected:
	long          m_cRef;
	CANDUIKEYDATA *m_pData;
	int           m_nData;
	int           m_nDataMax;
};

#endif // __CANDKEY_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\callbacks.cpp ===
#include "private.h"
#include "korimx.h"
#include "timsink.h"
#include "immxutil.h"
#include "fnrecon.h"
#include "helpers.h"
#include "skbdmode.h"
#include "osver.h"

// REVIEW
/*---------------------------------------------------------------------------
    CKorIMX::_EditSessionCallback
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_EditSessionCallback2(TfEditCookie ec, CEditSession2 *pes)
{
    ITfContext*    pic     = pes->GetContext();
    CKorIMX*    pKorTip = pes->GetTIP();
    ESSTRUCT*    pess    = pes->GetStruct();
    ITfRange*    pRange;
    CHangulAutomata*    pAutomata;
    LPWSTR     pszCand  = NULL;

    Assert(pic != NULL);
    Assert(pKorTip != NULL);

    
    if ((pKorTip == NULL) || (pic == NULL))
        return E_FAIL;

    switch (pess->id)
    {
    case ESCB_FINALIZECONVERSION:
        {
        CCandidateListEx   *pCandList;
        CCandidateStringEx *pCandItem;

        pCandList = pess->pCandList;
        pCandItem = pess->pCandStr;
        pRange    = pess->pRange;
        
        pszCand   = pCandItem->m_psz;
        
        if (pszCand)
            {
            size_t cchCand = 0;
            StringCchLengthW(pszCand, CIC_KOR_CANDSTR_MAX, &cchCand);
            // Set Reading text
            SetTextAndReading(pKorTip->_GetLibTLS(), ec, pic, pRange,
                      pszCand, 
                      cchCand,
                      pCandItem->m_langid, pCandItem->m_pszRead);
            }

        pCandList->Release();

        // First complete current comp string
        if (pAutomata = pKorTip->GetAutomata(pic))
            pAutomata->MakeComplete();

        pKorTip->MakeResultString(ec, pic, pRange);

        pKorTip->CloseCandidateUIProc();
        break;
        }

    case ESCB_COMPLETE:
        {
        BOOL fReleaseRange = fFalse;
        
        // If No composition exist, nothing to complete
        if (pKorTip->GetIPComposition(pic) == NULL)
            break;

        pRange    = pess->pRange;
        pAutomata = pKorTip->GetAutomata(pic);

        // Close cand UI if exist.
        pKorTip->CloseCandidateUIProc();

        if (pRange == NULL)
            {
            GetSelectionSimple(ec, pic, &pRange);
            fReleaseRange = fTrue;
            }

        if (pRange)
            {
            if (pAutomata)
                pAutomata->MakeComplete();
            pKorTip->MakeResultString(ec, pic, pRange);
            }
            
        if (fReleaseRange)
            {
            SafeRelease(pRange);
            }

        //return pKorTip->_MultiRangeConversion(ec, pes->_state.u, pic, pRange);
        break;
        }

    case ESCB_INSERT_PAD_STRING:
        {
        WCHAR szText[2];

        GetSelectionSimple(ec, pic, &pRange);
        szText[0] = (WCHAR)pess->wParam;
        szText[1] = L'\0';

        if (FAILED(pKorTip->SetInputString(ec, pic, pRange, szText, CKorIMX::GetLangID())))
            break;

        pKorTip->MakeResultString(ec, pic, pRange);
        
        SafeRelease(pRange);
        break;
        }
    
    case ESCB_KEYSTROKE:
        {
        WPARAM wParam = pess->wParam;
        LPARAM lParam = pess->lParam;
        return pKorTip->_Keystroke(ec, pic, wParam, lParam, (const BYTE *)pess->pv1);
        break;
        }

    // Complete and Selection range changed
    case ESCB_TEXTEVENT: 
        if (pKorTip->IsKeyFocus() && (GetSelectionSimple(ec, pic, &pRange) == S_OK)) 
            {
            ITfComposition  *pComposition;
            ITfRange        *pRangeOldComp;
            //IEnumTfRanges   *pEnumText = pess->pEnumRange;
            BOOL            fChanged = fFalse;
            BOOL            fEmpty;
            
            // Check modebias here
            if (pess->fBool)
                fChanged = pKorTip->CheckModeBias(ec, pic, pRange);
            
            //////////////////////////////////////////////////////////////////
            // To complete on mouse click we using Range change notification.
            // In future version, we could remove this code and use custom property
            // or reading string. Cutom property can hold Hangul Automata object.
            //
            // Office apps explicitly call complete but this for unknown Cicero apps.
            //////////////////////////////////////////////////////////////////
            pComposition = pKorTip->GetIPComposition(pic);
            if (pComposition == NULL)
                goto ExitTextEvent;

            // Office apps are not going through here.
            pComposition->GetRange(&pRangeOldComp);
            if (pRangeOldComp == NULL)
                goto ExitTextEvent;

            pRange->IsEmpty(ec, &fEmpty);
            if (fEmpty && (CR_EQUAL != CompareRanges(ec, pRange, pRangeOldComp)))
                {
                ITfProperty *pPropAttr;
                TfGuidAtom   attr;

                // Clear attrib
                if (SUCCEEDED(pic->GetProperty(GUID_PROP_ATTRIBUTE, &pPropAttr)))
                    {
                    if (SUCCEEDED(GetAttrPropertyData(ec, pPropAttr, pRangeOldComp, &attr)))
                        {
                        if (pKorTip->IsKorIMX_GUID_ATOM(attr))
                            {
                            pPropAttr->Clear(ec, pRangeOldComp);
                            }
                        }
                    pPropAttr->Release();
                    }
                    
                pAutomata = pKorTip->GetAutomata(pic);
                if (pAutomata)
                    pAutomata->MakeComplete();
                pKorTip->EndIPComposition(ec, pic); 
                // pKorTip->MakeResultString(ec, pic, pRangeOldComp);

                fChanged = fTrue;
                }

            SafeRelease(pRangeOldComp);

ExitTextEvent:
            pRange->Release();

            // Close cand UI if exist.
            if (fChanged)
                   pKorTip->CloseCandidateUIProc();
            }
        break;

//    case ESCB_RANGEBROKEN:
//        pKorTip->FlushIPRange(ec, pic);
//        break;

    case ESCB_CANDUI_CLOSECANDUI: 
        // u      : ESCB_CANDUI_CLOSECANDUI
        // pv     : this
        // hwnd   : - (not used)
        // wParam : - (not used)
        // lParam : - (not used)
        // pv1    : - (not used)
        // pv2    : - (not used)
        // pic    : - (not used)
        // pRange : - (not used)
        // fBool  : - (not used)
        pKorTip->CloseCandidateUIProc();
        break;

    // Hanja conv button up
    case ESCB_HANJA_CONV:
        // u      : ESCB_HANJA_CONV
        // pv     : this
        // hwnd   : - (not used)
        // wParam : - (not used)
        // lParam : - (not used)
        // pv1    : - (not used)
        // pv2    : - (not used)
        // pic    : - pic
        // pRange : - (not used)
        // fBool  : - (not used)

        // O10 #220177: Simulate VK_HANJA key to invoke HHC
        if (GetAIMM(pic) && (IsOnNT5() || PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) != LANG_JAPANESE))
            {
            keybd_event(VK_HANJA, 0, 0, 0);
            keybd_event(VK_HANJA, 0, KEYEVENTF_KEYUP, 0);
            }
        else
        if (GetSelectionSimple(ec, pic, &pRange) == S_OK)
            {
            if (pKorTip->GetIPComposition(pic))
                pKorTip->DoHanjaConversion(ec, pic, pRange);
            else
                pKorTip->Reconvert(pRange);

            SafeRelease(pRange);
            }
        // Update Hanja button
        if (pKorTip->m_pToolBar != NULL)
            pKorTip->m_pToolBar->Update(UPDTTB_HJMODE);
        break;

    ///////////////////////////////////////////////////////////////////////////
    // Reconversion Callbacks
    case ESCB_FINALIZERECONVERSION:
        {
        CCandidateListEx   *pCandList = pess->pCandList;
        CCandidateStringEx *pCandItem = pess->pCandStr;

        pRange       = pess->pRange;
        pszCand   = pCandItem->m_psz;

        Assert(pRange != NULL);
        pKorTip->CloseCandidateUI(pic);
        
        if (GetAIMM(pic) == fFalse)
            {
            if (pszCand)
                {
                size_t cchCand = 0;
                StringCchLengthW(pszCand, CIC_KOR_CANDSTR_MAX, &cchCand);
                //ITfRange *pRangeTmp;
                SetTextAndReading(pKorTip->_GetLibTLS(), ec, pic, pRange,
                          pszCand, 
                          cchCand,
                          pCandItem->m_langid, pCandItem->m_pszRead);
                }

            // To clear current selection and composition
            pKorTip->MakeResultString(ec, pic, pRange);
            }
        else
            {
            if (pszCand)
                {
                pRange->SetText(ec, 0, pszCand, 1/* wcslen(pszCand)*/);
                SetSelectionSimple(ec, pic, pRange);
                }
            pKorTip->EndIPComposition(ec, pic); 
            }

        // if hit reconversion on composition string, we need to clear automata.
        pAutomata = pKorTip->GetAutomata(pic);
        if (pRange && pAutomata && pAutomata->GetCompositionChar())
            pAutomata->MakeComplete();
            
        SafeRelease(pRange);
        break;
        }
        
    case ESCB_ONSELECTRECONVERSION:
        break;

    case ESCB_ONCANCELRECONVERSION:
        pRange     = pess->pRange;

        pKorTip->CancelCandidate(ec, pic);

        if (GetAIMM(pic) == fFalse)
            {
            // To clear current selection and composition
            pKorTip->MakeResultString(ec, pic, pRange);
            }
        else
            pKorTip->EndIPComposition(ec, pic); 

        // if hit reconversion on composition string, we need to clear automata.
        pAutomata = pKorTip->GetAutomata(pic);
        if (pRange && pAutomata && pAutomata->GetCompositionChar())
            pAutomata->MakeComplete();

        SafeRelease(pRange);
       break;

    case ESCB_RECONV_QUERYRECONV:
        {
        CFnReconversion    *pReconv   = (CFnReconversion *)pess->pv1;
        if (pKorTip->IsCandUIOpen())
            return E_FAIL;
        return pReconv->_QueryRange(ec, pic, pess->pRange, (ITfRange **)pess->pv2);
        }

    case ESCB_RECONV_GETRECONV:
        {
        CFnReconversion    *pReconv   = (CFnReconversion *)pess->pv1;
        if (pKorTip->IsCandUIOpen())
            return E_FAIL;
        return pReconv->_GetReconversion(ec, pic, pess->pRange, (CCandidateListEx **)pess->pv2, pess->fBool);
        }

    case ESCB_RECONV_SHOWCAND:
        {
        ITfComposition* pComposition;
        GUID attr;
        ITfProperty*    pProp = NULL;

        pRange     = pess->pRange;

        pComposition = pKorTip->GetIPComposition(pic);
        if (/*GetAIMM(pic) == fFalse && */ pComposition == NULL)
            {
            pKorTip->CreateIPComposition(ec, pic, pRange);

            // Set input attr and composing state.
            if (SUCCEEDED(pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp)))
                {
                attr = GUID_ATTR_KORIMX_INPUT;
                SetAttrPropertyData(pKorTip->_GetLibTLS(), ec, pProp, pRange, attr);
                pProp->Release();
                }
            }

        pKorTip->OpenCandidateUI(ec, pic, pess->pRange, pess->pCandList);

        break;
        }

    case ESCB_INIT_MODEBIAS:
        // Check mode bias
        //
        //  id         : ESCB_INIT_MODEBIAS
        //  ptip       : this
        //  pic        : pic
        pKorTip->InitializeModeBias(ec, pic);
        break;
    }

    return S_OK;
}

/*---------------------------------------------------------------------------
    CKorIMX::_DIMCallback
---------------------------------------------------------------------------*/
/* static */
HRESULT CKorIMX::_DIMCallback(UINT uCode, ITfDocumentMgr *pdimNew, ITfDocumentMgr *pdimPrev, void *pv)
{
    ITfContext    *pic = NULL;
    CKorIMX       *pKorImx = (CKorIMX *)pv;

    Assert(pKorImx != NULL);
    
    switch (uCode)
        {
    case TIM_CODE_SETFOCUS: 
        if (pdimPrev)
            {
            TraceMsg(DM_TRACE, TEXT("TIM_CODE_SETFOCUS: pdimPrev"));

            pdimPrev->GetTop(&pic);
            pKorImx->OnFocusChange(pic, fFalse);
            
            SafeRelease(pic);
            SafeReleaseClear(pKorImx->m_pCurrentDim);
            }

        if (pdimNew)
            {
            TraceMsg(DM_TRACE, TEXT("TIM_CODE_SETFOCUS: pdimNew"));

            SafeReleaseClear(pKorImx->m_pCurrentDim);

            // Set New dim
            pKorImx->m_pCurrentDim = pdimNew;
            pKorImx->m_pCurrentDim->AddRef();

            pdimNew->GetTop(&pic);
            pKorImx->OnFocusChange(pic, fTrue);

            if (pic)
                pic->Release();
            }
        break;
        }

    return S_OK;
}


/*---------------------------------------------------------------------------
    CKorIMX::_ICCallback

    Document Input Manager callback. ITfThreadMgrEventSink
---------------------------------------------------------------------------*/
/* static */
HRESULT CKorIMX::_ICCallback(UINT uCode, ITfContext *pic, void *pv)
{
    CKorIMX  *_this = (CKorIMX *)pv;

    switch (uCode)
        {
    case TIM_CODE_INITIC:
        if (!_this->IsPendingCleanup())  // ignore new ic's if we're being shutdown.
            {
            _this->_InitICPriv(pic);
            }
        break;

    case TIM_CODE_UNINITIC:
        _this->_DeleteICPriv(pic);
        break;
        }

    return S_OK;
}



/*---------------------------------------------------------------------------
    CKorIMX::_CompEventSinkCallback
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_CompEventSinkCallback(void *pv, REFGUID rguid)
{
    CICPriv* picp = (CICPriv*)pv;
    ITfContext* pic;
    CKorIMX *_this;
    
    if (picp == NULL)
        return S_OK;    // error

    pic = picp->GetIC();

    if (pic == NULL)
        return S_OK;    // error
    
    _this = picp->GetIMX();
    
    if (_this == NULL || _this->m_pToolBar == NULL)
        return S_OK;    // do nothinig

    // if Open/Close compartment
    if (IsEqualGUID(rguid, GUID_COMPARTMENT_KEYBOARD_OPENCLOSE))
        {
        _this->m_pToolBar->Update(UPDTTB_CMODE|UPDTTB_FHMODE);
        }
    else
    // if conversion mode compartment
    if (IsEqualGUID(rguid, GUID_COMPARTMENT_KORIMX_CONVMODE))
        {
        DWORD dwConvMode = _this->GetConvMode(pic);
        BOOL fIsOn = _this->IsOn(pic);

        // We just open for Hangul mode do not close for Alphanumeric mode for Cicero full aware apps.
        // This will prevent redundant Open/Close compartment call.
        if (dwConvMode == TIP_ALPHANUMERIC_MODE && fIsOn)
            _this->SetOnOff(pic, fFalse);
        else
        if (dwConvMode != TIP_ALPHANUMERIC_MODE && fIsOn == fFalse)
            _this->SetOnOff(pic, fTrue);
        _this->m_pToolBar->Update(UPDTTB_CMODE|UPDTTB_FHMODE);
        }
    else
    // if SoftKeyboard compartmemnt
    if (IsEqualGUID(rguid, GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE))
        {
        BOOL fSkbdOn = _this->GetSoftKBDOnOff();

        _this->ShowSoftKBDWindow(fSkbdOn);
        if (_this->m_pToolBar && _this->m_pToolBar->GetSkbdMode())
            _this->m_pToolBar->GetSkbdMode()->UpdateToggle();
        }
    else
    // if SoftKeyboard compartmemnt
    if (IsEqualGUID(rguid, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT))
        {
        DWORD   dwSoftLayout, dwCurLabel;
        HRESULT hr;
        
        if (_this->m_pSoftKbd == NULL)
            return E_FAIL;

        dwSoftLayout = _this->GetSoftKBDLayout();
        dwCurLabel   = _this->GetHangulSKbd()->dwCurLabel;
           
           hr = _this->m_pSoftKbd->SelectSoftKeyboard(dwSoftLayout);
           if (FAILED(hr))
               return hr;

        if (dwSoftLayout == _this->m_KbdStandard.dwSoftKbdLayout)
            hr = _this->m_pSoftKbd->SetKeyboardLabelText(GetKeyboardLayout(0));
        else
            hr = _this->m_pSoftKbd->SetKeyboardLabelTextCombination(dwCurLabel);
           if (FAILED(hr))
               return hr;

        if (_this->GetSoftKBDOnOff()) 
            {
            hr = _this->m_pSoftKbd->ShowSoftKeyboard(fTrue);
            return hr;
            }
        }

    return S_OK;
}


/*---------------------------------------------------------------------------
    CKorIMX::_PreKeyCallback
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_PreKeyCallback(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv)
{
    CKorIMX *_this = (CKorIMX *)pv;

    if (_this == NULL)
        return S_OK;
        
    if (IsEqualGUID(rguid, GUID_KOREAN_HANGULSIMULATE))
        {
        DWORD dwConvMode;

        // Toggle Hangul mode
        dwConvMode = _this->GetConvMode(pic);
        dwConvMode ^= TIP_HANGUL_MODE;
        _this->SetConvMode(pic, dwConvMode);

        *pfEaten = fTrue;
        }
    else if (IsEqualGUID(rguid, GUID_KOREAN_HANJASIMULATE))
        {
        // O10 #317983
        if (PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) != LANG_JAPANESE)
            {
            keybd_event(VK_HANJA, 0, 0, 0);
            keybd_event(VK_HANJA, 0, KEYEVENTF_KEYUP, 0);
            *pfEaten = fTrue;
            }
        else
            *pfEaten = fFalse;
        }
        
    return S_OK;
}


/*   O N  E N D  E D I T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CKorIMX::OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord)
{
    UNREFERENCED_PARAMETER(ecReadOnly);
    static const GUID *rgModeBiasProperties[] =
        {
        &GUID_PROP_MODEBIAS 
        };

    static const GUID *rgAttrProperties[] =
        {
        &GUID_PROP_ATTRIBUTE, 
        };

    CEditSession2 *pes;
    ESSTRUCT ess;
    HRESULT  hr;
    BOOL fInWriteSession;
    CICPriv *picp;
    IEnumTfRanges *pEnumText = NULL;
    ITfRange *pRange = NULL;
    ULONG     ulFetched = 0;
    BOOL      fCallES = fFalse;
    BOOL      fSelChanged = fFalse;

    Assert(pic != NULL);
    if (pic == NULL)
        return S_OK;    // error


    pic->InWriteSession(GetTID(), &fInWriteSession);
    if (fInWriteSession)
        return S_OK;                // own change.

    picp = GetInputContextPriv(pic);
    if (picp == NULL)
        return S_OK;    // error

    if (picp->GetfTransaction())
        return S_OK;                // skip in transaction.

    //////////////////////////////////////////////////////////////////////////
    // Init to call ESCB_TEXTEVENT
    ESStructInit(&ess, ESCB_TEXTEVENT);

    // Call ESCB_TEXTEVENT callback only if GUID_PROP_MODEBIAS changed.
    hr = pEditRecord->GetTextAndPropertyUpdates(0/*TF_GTP_INCL_TEXT*/, rgModeBiasProperties, ARRAYSIZE(rgModeBiasProperties), &pEnumText);
    if (FAILED(hr) || pEnumText == NULL)
        return S_OK;
    if (pEnumText->Next(1, &pRange, &ulFetched) == S_OK)
        {
        SafeRelease(pRange);
        // ModeBias changed.
        ess.fBool = fTrue;
        }
    pEnumText->Release();

    // Selection changed?
    pEditRecord->GetSelectionStatus(&fSelChanged);

    // If Attribute changed, set selection change true.
    if (fSelChanged == fFalse)
        {
        hr = pEditRecord->GetTextAndPropertyUpdates(0/*TF_GTP_INCL_TEXT*/, rgAttrProperties, ARRAYSIZE(rgAttrProperties), &pEnumText);
        if (FAILED(hr) || pEnumText == NULL)
            return S_OK;
        if (pEnumText->Next(1, &pRange, &ulFetched) == S_OK)
            {
            SafeRelease(pRange);
            fSelChanged = fTrue;
            }
        pEnumText->Release();
        }
    
    // Perf: Call ES only if (ModeBias change) or (Selection changed and comp object exist)
    //       I guess calling ES is pretty much costing since sel change occurs for ever cursor move.
    if (fSelChanged)
        fSelChanged = (GetIPComposition(pic) != NULL) ? fTrue : fFalse;

    // If ModeBias changed or Selection changed, then call ESCB_TEXTEVENT sink
    if (ess.fBool || fSelChanged)
        {
        if ((pes = new CEditSession2( pic, this, &ess, _EditSessionCallback2 )) != NULL)
            {
            pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
            pes->Release();
            }
        }

    return S_OK;
}


/*   O N  S T A R T  E D I T  T R A N S A C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CKorIMX::OnStartEditTransaction(ITfContext *pic)
{
    CICPriv *picp;

    if (pic == NULL)
        return S_OK;    // error

    picp = GetInputContextPriv(pic);
    if (picp)
        picp->SetfTransaction(fTrue);

    return S_OK;
}


/*   O N  E N D  E D I T  T R A N S A C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CKorIMX::OnEndEditTransaction(ITfContext *pic)
{
    BOOL ftran;
    CICPriv *picp;

    if (pic == NULL)
        return S_OK;    // error

    picp = GetInputContextPriv(pic);
    if (picp)
        {
        ftran = picp->GetfTransaction();
        if (ftran)
            {
            CEditSession2    *pes;
            ESSTRUCT        ess;
            HRESULT            hr;

            picp->SetfTransaction(fFalse);

            ESStructInit(&ess, ESCB_TEXTEVENT);
            ess.pEnumRange = NULL;

            if ((pes = new CEditSession2( pic, this, &ess, _EditSessionCallback2 )) != NULL)
                {
                pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
                pes->Release();
                }
            }
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\candlstx.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       candlst.cpp
//
//  Contents:   candidate list classes
//
//----------------------------------------------------------------------------

#include "private.h"
#include "candlstx.h"
#include "hanja.h"

//
// CCandidateStringEx
//

/*   C  C A N D I D A T E  S T R I N G  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandidateStringEx::CCandidateStringEx(int nIndex, LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk)
{
    size_t cch = 0;
    StringCchLengthW((LPWSTR)psz, CIC_KOR_CANDSTR_MAX, &cch);

    m_psz = new WCHAR[cch+1];
    if (m_psz)
        StringCchCopyW(m_psz, cch+1, psz);
    m_langid = langid;
    m_pv = pv;

    m_punk = punk;
    if (m_punk)
       m_punk->AddRef();
    m_pszRead = NULL;
    m_pszInlineComment = NULL;
#if 0
    m_pszPopupComment = NULL;
    m_dwPopupCommentGroupID = 0;
    m_pszPrefix = NULL;
    m_pszSuffix = NULL;
#endif
    m_nIndex = nIndex;
    m_cRef = 1;
}


/*   ~  C  C A N D I D A T E  S T R I N G  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandidateStringEx::~CCandidateStringEx()
{
    if (m_punk)
       m_punk->Release();
    delete m_psz;
    delete m_pszRead;
    if (m_pszInlineComment != NULL) {
        delete m_pszInlineComment;
    }
    
#if 0
    if (m_pszPopupComment != NULL) {
        delete m_pszPopupComment;
    }

    if (m_pszPrefix != NULL) {
        delete m_pszPrefix;
    }

    if (m_pszSuffix != NULL) {
        delete m_pszSuffix;
    }
#endif
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandidateStringEx::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfCandidateString))
        *ppvObj = SAFECAST(this, ITfCandidateString*);
    else 
        if (IsEqualGUID(riid, IID_ITfCandidateStringInlineComment))
            *ppvObj = SAFECAST(this, ITfCandidateStringInlineComment*);
    else 
        if (IsEqualGUID( riid, IID_ITfCandidateStringColor))
            *ppvObj = SAFECAST(this, ITfCandidateStringColor*);
#if 0
    else 
        if (IsEqualGUID( riid, IID_ITfCandidateStringPopupComment))
            *ppvObj = SAFECAST(this, ITfCandidateStringPopupComment*);
    else 
        if (IsEqualGUID( riid, IID_ITfCandidateStringFixture))
            *ppvObj = SAFECAST( this, ITfCandidateStringFixture*);
    else 
        if (IsEqualGUID( riid, IID_ITfCandidateStringIcon))
            *ppvObj = SAFECAST( this, ITfCandidateStringIcon*);
#endif

    if (*ppvObj == NULL)
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandidateStringEx::AddRef()
{
    m_cRef++;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandidateStringEx::Release()
{
    m_cRef--;
    if (0 < m_cRef) {
        return m_cRef;
    }

    delete this;
    return 0;    
}


/*   G E T  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetString(BSTR *pbstr)
{
    *pbstr = SysAllocString(m_psz);
    return S_OK;
}


/*   G E T  I N D E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetIndex(ULONG *pnIndex)
{
    *pnIndex = m_nIndex;
    return S_OK;
}


/*   G E T  I N L I N E  C O M M E N T  S T R I N G  */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetInlineCommentString(BSTR *pbstr)
{
    if (m_pszInlineComment == NULL) {
        return S_FALSE;
    }

    *pbstr = SysAllocString(m_pszInlineComment);
    return S_OK;
}

#if 0
/*   G E T  P O P U P  C O M M E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetPopupCommentString(BSTR *pbstr)
{
    if (m_pszPopupComment == NULL) {
        return S_FALSE;
    }

    *pbstr = SysAllocString(m_pszPopupComment);
    return S_OK;
}


/*   G E T  P O P U P  C O M M E N T  G R O U P  I  D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetPopupCommentGroupID(DWORD *pdwGroupID)
{
    *pdwGroupID = m_dwPopupCommentGroupID;
    return S_OK;
}

#endif

/*   G E T  C O L O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetColor(CANDUICOLOR *pcol)
{
    // TODO: Set diferent color according to the Hanja category
    if (m_bHanjaCat == HANJA_K0)
        {
        pcol->type = CANDUICOL_SYSTEM;
        pcol->cr = COLOR_MENUTEXT;
        }
    else
        {
        pcol->type = CANDUICOL_COLORREF;

        // If button face is black
        if (GetSysColor(COLOR_3DFACE) == RGB(0,0,0)) 
            pcol->cr = RGB(0, 128, 255);
        else
            pcol->cr = RGB(0, 0, 255);
        }
    return S_OK;
}

#if 0
/*   G E T  P R E F I X  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetPrefixString(BSTR *pbstr)
{
    if (m_pszPrefix == NULL) {
        return S_FALSE;
    }

    *pbstr = SysAllocString(m_pszPrefix);
    return S_OK;
}


/*   G E T  S U F F I X  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetSuffixString(BSTR *pbstr)
{
    if (m_pszSuffix == NULL) {
        return S_FALSE;
    }

    *pbstr = SysAllocString(m_pszSuffix);
    return S_OK;
}

/*   G E T  I C O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetIcon( HICON *phIcon )
{
    if (m_hIcon == NULL) {
        return S_FALSE;
    }

    *phIcon = m_hIcon;
    return S_OK;
}

#endif

/*   S E T  R E A D I N G  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetReadingString(LPCWSTR psz)
{
    if (psz == NULL)
        return S_FALSE;
    
    if (m_pszRead != NULL) {
        delete m_pszRead;
    }

    size_t cch = 0;
    StringCchLengthW((LPWSTR)psz, CIC_KOR_CANDSTR_MAX, &cch);
    m_pszRead = new WCHAR[cch+1];
    if (m_pszRead == NULL)
        return E_OUTOFMEMORY;
    StringCchCopyW(m_pszRead, cch+1, psz);

    return S_OK;
}

/*   S E T  I N L I N E  C O M M E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetInlineComment(LPCWSTR psz)
{
    if (m_pszInlineComment != NULL)
        delete m_pszInlineComment;

    if (psz != NULL)
        {
        size_t cch = 0;
        StringCchLengthW((LPWSTR)psz, CIC_KOR_CANDSTR_MAX, &cch);
        m_pszInlineComment = new WCHAR[cch+1];
        if (m_pszInlineComment == NULL)
            return E_OUTOFMEMORY;
        StringCchCopyW(m_pszInlineComment, cch+1, psz);
        } 
    else 
        m_pszInlineComment = NULL;

    return S_OK;
}

#if 0
/*   S E T  P O P U P  C O M M E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetPopupComment( LPCWSTR psz, DWORD dwGroupID )
{
    if (m_pszPopupComment != NULL) {
        delete m_pszPopupComment;
    }

    m_dwPopupCommentGroupID = 0;
    if (psz != NULL) {
        UINT cch = 0;
        StringCchLengthW((LPWSTR)psz, CIC_KOR_CANDSTR_MAX, &cch);
        m_pszPopupComment = new WCHAR[cch+1];
        if (m_pszPopupComment == NULL)
            return E_OUTOFMEMORY;
        StringCchCopyW(m_pszPopupComment, cch+1, psz);
        
        m_dwPopupCommentGroupID = dwGroupID;
    } 
    else {
        m_pszPopupComment = NULL;
    }
    return S_OK;
}


/*   S E T  P R E F I X  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetPrefixString( LPCWSTR psz )
{
    if (m_pszPrefix != NULL) {
        delete m_pszPrefix;
    }

    if (psz != NULL) {
        UINT cch = 0;
        StringCchLengthW((LPWSTR)psz, CIC_KOR_CANDSTR_MAX, &cch);
        m_pszPrefix = new WCHAR[cch+1];
        if (m_pszPrefix == NULL)
            return E_OUTOFMEMORY;
        StringCchCopyW(m_pszPrefix, cch+1, psz);
    } 
    else {
        m_pszPrefix = NULL;
    }
    return S_OK;
}


/*   S E T  S U F F I X  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetSuffixString( LPCWSTR psz )
{
    if (m_pszSuffix != NULL) {
        delete m_pszSuffix;
    }

    if (psz != NULL) {
        UINT cch = 0;
        StringCchLengthW((LPWSTR)psz, CIC_KOR_CANDSTR_MAX, &cch);
        m_pszSuffix = new WCHAR[cch+1];
        if (m_pszSuffix == NULL)
            return E_OUTOFMEMORY;
        StringCchCopyW(m_pszSuffix, cch+1, psz);
    } 
    else {
        m_pszSuffix = NULL;
    }
    return S_OK;
}

/*   S E T  I C O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetIcon( HICON hIcon )
{
    m_hIcon = hIcon;
    return S_OK;
}

#endif

//
// CCandidateListEx
//

/*   C  C A N D I D A T E  L I S T  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandidateListEx::CCandidateListEx(CANDLISTCALLBACKEX pfnCallback, ITfContext *pic, ITfRange *pRange)
{
    m_pfnCallback = pfnCallback;
    m_pic = pic;
    m_pic->AddRef();
    m_pRange = pRange;
    m_pRange->AddRef();
    m_cRef = 1;
    m_iInitialSelection = 0;
    m_pExtraCand = NULL;
}


/*   ~  C  C A N D I D A T E  L I S T  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandidateListEx::~CCandidateListEx()
{
    m_pic->Release();
    m_pRange->Release();

    while(m_rgCandStr.Count())
        {
        CCandidateStringEx *pCandStringEx;
        
        pCandStringEx = m_rgCandStr.Get(0);
        pCandStringEx->Release();
        
        m_rgCandStr.Remove(0, 1);
        }

    if (m_pExtraCand != NULL)
        m_pExtraCand->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandidateListEx::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfCandidateList))
        *ppvObj = SAFECAST(this, ITfCandidateList *);
    else 
    if (IsEqualIID(riid, IID_ITfCandidateListExtraCandidate))
        *ppvObj = SAFECAST(this, ITfCandidateListExtraCandidate *);


    if (*ppvObj == NULL) {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandidateListEx::AddRef()
{
    m_cRef++;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandidateListEx::Release()
{
    m_cRef--;
    if (0 < m_cRef) {
        return m_cRef;
    }

    delete this;
    return 0;    
}


/*   E N U M  C A N D I D A T E S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::EnumCandidates(IEnumTfCandidates **ppEnum)
{
    HRESULT hr = S_OK;

    if (!(*ppEnum = new CEnumCandidatesEx(this))) {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


/*   G E T  C A N D I D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::GetCandidate(ULONG nIndex, ITfCandidateString **ppCand)
{
    CCandidateStringEx *pCandString;
    UINT nCnt = m_rgCandStr.Count();
    if (nIndex >= nCnt)
        return E_FAIL;

    pCandString = m_rgCandStr.Get(nIndex);
    return pCandString->QueryInterface(IID_ITfCandidateString, (void **)ppCand
);
}


/*   G E T  C A N D I D A T E  N U M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::GetCandidateNum(ULONG *pnCnt)
{
    *pnCnt = m_rgCandStr.Count();
    return S_OK;
}


/*   S E T  R E S U L T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::SetResult(ULONG nIndex, TfCandidateResult imcr)
{
    if (m_pExtraCand && (nIndex == IEXTRACANDIDATE))
        {
        if (m_pfnCallback == NULL)
            return S_OK;

        return (m_pfnCallback)(m_pic, m_pRange, this, m_pExtraCand, imcr);
        }

    if (nIndex >= (UINT)m_rgCandStr.Count())
        return E_FAIL;

    if (m_pfnCallback == NULL)
        return S_OK;

    return (m_pfnCallback)(m_pic, m_pRange, this, m_rgCandStr.Get(nIndex), imcr);
}

/*   G E T  E X T R A  C A N D I D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::GetExtraCandidate(ITfCandidateString **ppCand)
{
    if (ppCand == NULL)
        return E_POINTER;

    if (m_pExtraCand != NULL)
        return m_pExtraCand->QueryInterface(IID_ITfCandidateString, (void **)ppCand);

    return S_FALSE;
}


/*   A D D  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::AddString( LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk, CCandidateStringEx **ppCandStr )
{
    int nCnt = m_rgCandStr.Count();
    CCandidateStringEx *pCand = new CCandidateStringEx(nCnt, psz, langid, pv, punk);

    if (!pCand)
        return E_OUTOFMEMORY;

    m_rgCandStr.Insert(nCnt, 1);
    m_rgCandStr.Set(nCnt, pCand);

    if (ppCandStr) {
        *ppCandStr = pCand;
        (*ppCandStr)->AddRef();
    }
    return S_OK;
}



/*   S E T  I N I T I A L  S E L E C T I O N   */
/*------------------------------------------------------------------------------

    Set initial selection to open candidate UI
    (internal use method)

------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::SetInitialSelection(ULONG iSelection)
{
    m_iInitialSelection = iSelection;
    return S_OK;
}



/*   G E T  I N I T I A L  S E L E C T I O N   */
/*------------------------------------------------------------------------------

    Get initial selection to open candidate UI
    (internal use method)

------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::GetInitialSelection(ULONG *piSelection)
{
    if (piSelection == NULL) {
        return E_POINTER;
    }

    *piSelection = m_iInitialSelection;
    return S_OK;
}

/*   A D D  E X T R A  S T R I N G   */
/*------------------------------------------------------------------------------

    Create extra candidate string ("0-Ban Kouho")
    (internal use method)

------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::AddExtraString(LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk, CCandidateStringEx **ppCandStr)
{
    if (m_pExtraCand != NULL)
        return E_FAIL;

    m_pExtraCand = new CCandidateStringEx(IEXTRACANDIDATE, psz, langid, pv, punk);

    if (!m_pExtraCand)
        return E_OUTOFMEMORY;

    if (ppCandStr)
        {
        *ppCandStr = m_pExtraCand;
        (*ppCandStr)->AddRef();
        }
        
    return S_OK;
}

//
// CEnumCandidateEx
//

/*   C  E N U M  C A N D I D A T E S  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CEnumCandidatesEx::CEnumCandidatesEx(CCandidateListEx *pList)
{
    m_pList = pList;
    m_pList->AddRef();
    m_nCur = 0;

    m_cRef = 1;
}


/*   ~  C  E N U M  C A N D I D A T E S  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CEnumCandidatesEx::~CEnumCandidatesEx()
{
    m_pList->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CEnumCandidatesEx::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumTfCandidates)) {
        *ppvObj = SAFECAST(this, IEnumTfCandidates *);
    }

    if (*ppvObj == NULL) {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

/*   A D D  R E F   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CEnumCandidatesEx::AddRef()
{
    m_cRef++;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CEnumCandidatesEx::Release()
{
    m_cRef--;
    if (0 < m_cRef) {
        return m_cRef;
    }

    delete this;
    return 0;    
}


/*   C L O N E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CEnumCandidatesEx::Clone(IEnumTfCandidates **ppEnum)
{
    return E_NOTIMPL;
}


/*   N E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CEnumCandidatesEx::Next(ULONG ulCount, ITfCandidateString **ppCand, ULONG *pcFetched)
{
    ULONG cFetched = 0;

    while (cFetched < ulCount) {
        CCandidateStringEx *pCand;

        if (m_nCur >= m_pList->m_rgCandStr.Count())
            break;

        pCand = m_pList->m_rgCandStr.Get(m_nCur);
        if (FAILED(pCand->QueryInterface(IID_ITfCandidateString, (void **)ppCand)))
            break;

        ppCand++;
        cFetched++;
        m_nCur++;
    }

    if (pcFetched)
        *pcFetched = cFetched;

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}


/*   R E S E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CEnumCandidatesEx::Reset()
{
    m_nCur = 0;
    return S_OK;
}


/*   S K I P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CEnumCandidatesEx::Skip(ULONG ulCount)
{
    while (ulCount) {
        if (m_nCur >= m_pList->m_rgCandStr.Count())
            break;

        m_nCur++;
        ulCount--;
    }

    return ulCount ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\activate.cpp ===
/****************************************************************************
   ACTIVATE.CPP : Init/Uninit Cicero services on the thread

   History:
      24-JAN-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "immxutil.h"
#include "globals.h"
#include "kes.h"
#include "timsink.h"
#include "funcprv.h"
#include "insert.h"
#include "pad.h"
#include "helpers.h"
#include "osver.h"


// Hangul and Hanja key simulation for Non-Korean Win9x and NT4
static const KESPRESERVEDKEY g_prekeyList[] = 
{
       { &GUID_KOREAN_HANGULSIMULATE, { VK_MENU,     TF_MOD_RALT },       L"Hangul" },
       { &GUID_KOREAN_HANJASIMULATE,  { VK_CONTROL,  TF_MOD_RCONTROL },   L"Hanja"  },
       { NULL,  { 0,    0}, NULL }
};

/*---------------------------------------------------------------------------
    CKorIMX::Activate
    
    Initialize Cicero services on the thread
---------------------------------------------------------------------------*/
STDAPI CKorIMX::Activate(ITfThreadMgr *ptim, TfClientId tid)
{
    ITfKeystrokeMgr   *pIksm = NULL;
    ITfSource         *pISource;
    ITfSourceSingle   *pISourceSingle;
    BOOL              fThreadFocus;    
    HRESULT           hr = E_FAIL;

    // Keep current Thread ID
    m_tid = tid;

    // Get ITfThreadMgr and ITfDocumentMgr
    Assert(GetTIM() == NULL);
    m_ptim = ptim;
    m_ptim->AddRef();

    //////////////////////////////////////////////////////////////////////////
    // Get key stroke manager(ITfKeystrokeMgr) in current TIM
    if (FAILED(hr = GetService(GetTIM(), IID_ITfKeystrokeMgr, (IUnknown **)&pIksm)))
        goto Exit;

    //////////////////////////////////////////////////////////////////////////
    // Create ITfThreadMgrEventSink and set Call back function as _DocInputMgrCallback
    if ((m_ptimEventSink = new CThreadMgrEventSink(_DIMCallback, _ICCallback, this)) == NULL)
        {
        Assert(0); // bugbug
        hr = E_OUTOFMEMORY;
        goto Exit;
        }
    m_ptimEventSink->_Advise(GetTIM());
    
    //////////////////////////////////////////////////////////////////////////
    // Get IID_ITfThreadFocusSink cookie
    if (GetTIM()->QueryInterface(IID_ITfSource, (void **)&pISource) == S_OK)
        {
        pISource->AdviseSink(IID_ITfThreadFocusSink, (ITfThreadFocusSink *)this, &m_dwThreadFocusCookie);
        pISource->AdviseSink(IID_ITfActiveLanguageProfileNotifySink, (ITfActiveLanguageProfileNotifySink *)this, &m_dwProfileNotifyCookie);
        pISource->Release();
        }

    // ITfCleanupContextDurationSink
    if (GetTIM()->QueryInterface(IID_ITfSourceSingle, (void **)&pISourceSingle) == S_OK)
        {
        pISourceSingle->AdviseSingleSink(m_tid, IID_ITfCleanupContextDurationSink, (ITfCleanupContextDurationSink *)this);
        pISourceSingle->Release();
        }

    // Set conversion mode compartment to null status.
    SetCompartmentDWORD(m_tid, m_ptim, GUID_COMPARTMENT_KORIMX_CONVMODE, TIP_NULL_CONV_MODE, fFalse);
        
    // Korean Kbd driver does not exist in system(Non Korean NT4, Non Korean WIN9X)
    m_fNoKorKbd = (g_uACP != 949) && (IsOn95() || IsOn98() || (IsOnNT() && !IsOnNT5()));

    //////////////////////////////////////////////////////////////////////////
    // Create Keyboard Sink(ITfKeyEventSink)
    // From Cicero Doc: Keyboard TIP must provide this KeyEventSink interface to get the key event.
    //                  Using this sink, TIPs can get the notification of getting or losing keyboard focus
    if (m_fNoKorKbd)
        m_pkes = new CKeyEventSink(_KeyEventCallback, _PreKeyCallback, this);
    else
        m_pkes = new CKeyEventSink(_KeyEventCallback, this);
    
    if (m_pkes == NULL)
        {    
        hr = E_OUTOFMEMORY;
        goto Exit;
        }

    hr = pIksm->AdviseKeyEventSink(GetTID(), m_pkes, fTrue);
    if (FAILED(hr))
        goto Exit;

    if (m_fNoKorKbd)
        {
        hr = m_pkes->_Register(GetTIM(), GetTID(), g_prekeyList);
        if (FAILED(hr))
            {
            goto Exit;
            }
        }

    //////////////////////////////////////////////////////////////////////////
    // Create status window
    m_hOwnerWnd = CreateWindowEx(0, c_szOwnerWndClass, TEXT(""), WS_DISABLED, 0, 0, 0, 0, NULL, 0, g_hInst, this);

    //////////////////////////////////////////////////////////////////////////
    // Register Function Provider. Reconversion etc.
    m_pFuncPrv = new CFunctionProvider(this);
    if (m_pFuncPrv == NULL)
        {
        hr = E_OUTOFMEMORY;
        goto Exit;
        }
    m_pFuncPrv->_Advise(GetTIM());

    // Create Pad Core
	m_pPadCore = new CPadCore(this);
	if (m_pPadCore == NULL)
	    {
	    hr = E_OUTOFMEMORY;
		goto Exit;
	    }
    //////////////////////////////////////////////////////////////////////////
    // Create Toolbar
    m_pToolBar = new CToolBar(this);
    if (m_pToolBar == NULL)
        {
        hr = E_OUTOFMEMORY;
        goto Exit;
        }

    if (!m_pToolBar->Initialize())
        {
        hr = E_OUTOFMEMORY;
        goto Exit;
        }

    hr = m_ptimEventSink->_InitDIMs(fTrue);
    if (FAILED(hr))
        {
        goto Exit;
        }

    //////////////////////////////////////////////////////////////////////////
    // Init UI
    if (GetTIM()->IsThreadFocus(&fThreadFocus) == S_OK && fThreadFocus)
        {
        // init any UI
        OnSetThreadFocus();
        }

    if (m_pInsertHelper = new CCompositionInsertHelper)
        {
        // optional, default is DEF_MAX_OVERTYPE_CCH in insert.h
        // use 0 to avoid allocating any memory
        // set the limit on number of overtype chars that
        // the helper will backup
        m_pInsertHelper->Configure(0);
        }
    else
        {
        hr = E_OUTOFMEMORY;
	    goto Exit;
        }


    m_pToolBar->CheckEnable();                // update toolbar

    // Clear SoftKbd On/Off status backup
    // m_fSoftKbdOnOffSave = fFalse;
    // Clear SoftKbd On/Off status backup
    // m_fSoftKbdOnOffSave = GetSoftKBDOnOff();
    if (m_fSoftKbdOnOffSave)
        {
        SetSoftKBDOnOff(fTrue);
        }

    hr = S_OK;

Exit:
    SafeRelease(pIksm);

    return hr;
}

/*---------------------------------------------------------------------------
    CKorIMX::Deactivate
    
    Uninitialize Cicero services on the thread
---------------------------------------------------------------------------*/
STDAPI CKorIMX::Deactivate()
{
    ITfKeystrokeMgr   *pksm = NULL;
    ITfSource         *pISource;
    ITfSourceSingle      *pISourceSingle = NULL;    
    BOOL              fThreadFocus;
    HRESULT           hr = E_FAIL;

    // close candidate UI
    if (m_pCandUI != NULL) 
        {
        CloseCandidateUIProc();
        m_pCandUI->Release();
        m_pCandUI = NULL;
        }

    // pad core
	if (m_pPadCore)
	    {
		delete m_pPadCore;
		m_pPadCore = NULL;
	    }

    // toolbar
    if (m_pToolBar) 
        {
        m_pToolBar->Terminate();
        delete m_pToolBar;
        m_pToolBar = NULL;
        }
    
    if (GetTIM()->IsThreadFocus(&fThreadFocus) == S_OK && fThreadFocus)
        {
        // shutdown any UI
        OnKillThreadFocus();
        }

    ///////////////////////////////////////////////////////////////////////////
    // Unadvise IID_ITfThreadFocusSink cookie
    if (GetTIM()->QueryInterface(IID_ITfSource, (void **)&pISource) == S_OK)
        {
        pISource->UnadviseSink(m_dwThreadFocusCookie);
        pISource->UnadviseSink(m_dwProfileNotifyCookie);
        pISource->Release();
        }

    if (GetTIM()->QueryInterface(IID_ITfSourceSingle, (void **)&pISourceSingle) == S_OK)
        {
        pISourceSingle->UnadviseSingleSink(m_tid, IID_ITfCleanupContextDurationSink);
        pISourceSingle->Release();
        }
        
    if (FAILED(hr = GetService(GetTIM(), IID_ITfKeystrokeMgr, (IUnknown **)&pksm)))
        goto Exit;

    // Release TIM event sink
    if (m_ptimEventSink != NULL)
        {
        m_ptimEventSink->_InitDIMs(fFalse);        
        m_ptimEventSink->_Unadvise();
        SafeReleaseClear(m_ptimEventSink);
        }

    // Release Key event sink
    if (m_pkes)
        {
        if (m_fNoKorKbd)
            m_pkes->_Unregister(GetTIM(), GetTID(), g_prekeyList);
        SafeReleaseClear(m_pkes);
        }

    // Delete SoftKbd
    if (IsSoftKbdEnabled())
        TerminateSoftKbd();
    
    // Release Key Event Sink
    pksm->UnadviseKeyEventSink(GetTID());
    DestroyWindow(m_hOwnerWnd);

    m_pFuncPrv->_Unadvise(GetTIM());

    SafeReleaseClear(m_pFuncPrv);
    SafeReleaseClear(m_ptim);

    //
    // Free per-thread object that lib uses.
    //
    TFUninitLib_Thread(&m_libTLS);

    SafeReleaseClear(m_pInsertHelper);
    
    hr = S_OK;

Exit:
    SafeRelease(pksm);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\candlstx.h ===
//
// candlst.h
//

#ifndef CANDLST_H
#define CANDLST_H

#include "private.h"
#include "mscandui.h"
#include "ptrary.h"

#define IEXTRACANDIDATE		(UINT)(-2)
#define CIC_KOR_CANDSTR_MAX     512

class CCandidateStringEx;
class CCandidateListEx;

typedef HRESULT (*CANDLISTCALLBACKEX)(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandLst, CCandidateStringEx *pCand, TfCandidateResult imcr);

//
// CCandidateStringEx
//

class CCandidateStringEx : public ITfCandidateString,
						   public ITfCandidateStringInlineComment,
						   public ITfCandidateStringColor
{
public:
	CCandidateStringEx(int nIndex, LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk);
	~CCandidateStringEx();

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	//
	// ITfCandidateString
	//
	STDMETHODIMP GetString(BSTR *pbstr);
	STDMETHODIMP GetIndex(ULONG *pnIndex);

	//
	// ITfCandidateStringInlineComment
	//
	STDMETHODIMP GetInlineCommentString(BSTR *pbstr);

	//
	// ITfCandidateStringColor
	//
	STDMETHODIMP GetColor(CANDUICOLOR *pcol);

#if 0
	//
	// ITfCandidateStringPopupComment
	//
	STDMETHODIMP GetPopupCommentString( BSTR *pbstr );
	STDMETHODIMP GetPopupCommentGroupID( DWORD *pdwGroupID );

	//
	// ITfCandidateStringFixture
	//
	STDMETHODIMP GetPrefixString( BSTR *pbstr );
	STDMETHODIMP GetSuffixString( BSTR *pbstr );

	// 
	// ITfCandidateStringIcon
	//
	STDMETHODIMP GetIcon( HICON *phIcon );
#endif

	//
	// internal
	//
	HRESULT SetReadingString(LPCWSTR psz);
	HRESULT SetInlineComment(LPCWSTR psz);
#if 0
	HRESULT SetPopupComment(LPCWSTR psz, DWORD dwGroupID);
	HRESULT SetPrefixString(LPCWSTR psz);
	HRESULT SetSuffixString(LPCWSTR psz);
#endif

	void 		*m_pv;
	IUnknown 	*m_punk;
	LPWSTR 		m_psz;
	LPWSTR 		m_pszRead;
	LANGID 		m_langid;
	WORD  		m_bHanjaCat;

protected:
	int 		m_cRef;
	int 		m_nIndex;
	LPWSTR		m_pszInlineComment;
#if 0
	LPWSTR		m_pszPopupComment;
	DWORD		m_dwPopupCommentGroupID;
	LPWSTR		m_pszPrefix;
	LPWSTR		m_pszSuffix;
#endif
};


//
// CCandidateListEx
//

class CCandidateListEx : public ITfCandidateList,
						 public ITfCandidateListExtraCandidate
{
public:
	CCandidateListEx(CANDLISTCALLBACKEX pfnCallback, ITfContext *pic, ITfRange *pRange);
	~CCandidateListEx();

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	//
	// ITfCandidateList
	//
	STDMETHODIMP EnumCandidates(IEnumTfCandidates **ppEnum);
	STDMETHODIMP GetCandidate(ULONG nIndex, ITfCandidateString **ppCand);
	STDMETHODIMP GetCandidateNum(ULONG *pnCnt);
	STDMETHODIMP SetResult(ULONG nIndex, TfCandidateResult imcr);

	//
	// ITfCandidateListExtraCandidate
	//
	STDMETHODIMP GetExtraCandidate(ITfCandidateString **ppCand);

  	//
	// internal
	//
	HRESULT AddString(LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk, CCandidateStringEx **ppCandStr);
	HRESULT SetInitialSelection(ULONG iSelection);
	HRESULT GetInitialSelection(ULONG *piSelection);
	HRESULT AddExtraString( LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk, CCandidateStringEx **ppCandStr );

	CPtrArray<CCandidateStringEx> 	m_rgCandStr;

protected:
	int 				m_cRef;
	ITfContext 			*m_pic;
	ITfRange 			*m_pRange;
	ITfFnReconversion 	*m_pReconv;
	CANDLISTCALLBACKEX 	m_pfnCallback;
	int					m_iInitialSelection;
	CCandidateStringEx	*m_pExtraCand;
};


//
// CEnumCandidatesEx
//

class CEnumCandidatesEx : public IEnumTfCandidates
{
public:
	CEnumCandidatesEx(CCandidateListEx *pList);
	~CEnumCandidatesEx();

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	//
	// ITfEnumCandidates
	//
	STDMETHODIMP Clone(IEnumTfCandidates **ppEnum);
	STDMETHODIMP Next(ULONG ulCount, ITfCandidateString **ppCand, ULONG *pcFetched);
	STDMETHODIMP Reset();
	STDMETHODIMP Skip(ULONG ulCount);

private:
	int 			 m_cRef;
	CCandidateListEx *m_pList;
	int 			 m_nCur;
};

#endif // CCANDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\canduies.cpp ===
//
// canduies.cpp
//

#include "private.h"
#include "canduies.h"


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  E X T  B U T T O N  E V E N T  S I N K                  */
/*                                                                            */
/*============================================================================*
/

/*   C  C A N D  U I  E X T  B U T T O N  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Constructor of CCandUIExtButtonEventSink

------------------------------------------------------------------------------*/
CCandUIExtButtonEventSink::CCandUIExtButtonEventSink(PFNONBUTTONPRESSED pfnOnButtonPressed, ITfContext *pic, void *pVoid)
{
    m_cRef = 1;
    m_pic  = pic;
    m_pic->AddRef();
    m_pv   = pVoid;
    m_pfnOnButtonPressed = pfnOnButtonPressed;
}


/*   ~  C  C A N D  U I  E X T  B U T T O N  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Destructor of CCandUIExtButtonEventSink

------------------------------------------------------------------------------*/
CCandUIExtButtonEventSink::~CCandUIExtButtonEventSink()
{
    m_pic->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

    QueryInterface
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtButtonEventSink::QueryInterface( REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfCandUIExtButtonEventSink))
        *ppvObj = SAFECAST(this, ITfCandUIExtButtonEventSink*);

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

    Increment reference count
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtButtonEventSink::AddRef()
{
    ++m_cRef;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

    Decrement reference count and release
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtButtonEventSink::Release()
{
    --m_cRef;

    if (0 < m_cRef)
        return m_cRef;

    delete this;
    return 0;
}


/*   O N  B U T T O N  P R E S S E D   */
/*------------------------------------------------------------------------------

    Callback function of CandUI button event
    (ITfCandUIExtButtonEventSink method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtButtonEventSink::OnButtonPressed(LONG id)
{
    return (*m_pfnOnButtonPressed)(id, m_pic, m_pv);
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  A U T O  F I L T E R  E V E N T  S I N K                */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  A U T O  F I L T E R  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Constructor of CCandUIFilterEventSink

------------------------------------------------------------------------------*/
CCandUIAutoFilterEventSink::CCandUIAutoFilterEventSink(PFNONFILTEREVENT pfnOnFilterEvent, ITfContext *pic, void *pVoid)
{
    m_cRef = 1;
    m_pic  = pic;
    m_pic->AddRef();
    m_pv   = pVoid;
    m_pfnOnFilterEvent = pfnOnFilterEvent;
}


/*   ~  C  C A N D  U I  A U T O  F I L T E R  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Destructor of CCandUIFilterEventSink

------------------------------------------------------------------------------*/
CCandUIAutoFilterEventSink::~CCandUIAutoFilterEventSink()
{
    m_pic->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

    QueryInterface
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIAutoFilterEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfCandUIAutoFilterEventSink))
        *ppvObj = SAFECAST(this, ITfCandUIAutoFilterEventSink*);

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

    Increment reference count
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIAutoFilterEventSink::AddRef()
{
    ++m_cRef;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

    Decrement reference count and release
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIAutoFilterEventSink::Release()
{
    --m_cRef;

    if (0 < m_cRef)
        return m_cRef;

    delete this;
    return 0;
}


/*   O N  F I L T E R  E V E N T   */
/*------------------------------------------------------------------------------

    Callback function of CandUI filtering event
    (ITfCandUIAutoFilterEventSink method)

------------------------------------------------------------------------------*/
STDAPI CCandUIAutoFilterEventSink::OnFilterEvent(CANDUIFILTEREVENT ev)
{
    return (*m_pfnOnFilterEvent)(ev, m_pic, m_pv);
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  M E N U  E V E N T  S I N K                             */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  M E N U  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Constructor of CCandUIMenuEventSink

------------------------------------------------------------------------------*/
CCandUIMenuEventSink::CCandUIMenuEventSink(PFNINITMENU pfnInitMenu, PFNONCANDUIMENUCOMMAND pfnOnCandUIMenuCommand, ITfContext *pic, void *pVoid)
{
    m_cRef = 1;
    m_pic  = pic;
    m_pic->AddRef();
    m_pv   = pVoid;
    m_pfnInitMenu            = pfnInitMenu;
    m_pfnOnCandUIMenuCommand = pfnOnCandUIMenuCommand;
}


/*   ~  C  C A N D  U I  M E N U  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Destructor of CCandUIMenuEventSink

------------------------------------------------------------------------------*/
CCandUIMenuEventSink::~CCandUIMenuEventSink( void )
{
    m_pic->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

    QueryInterface
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfCandUIMenuEventSink))
        *ppvObj = SAFECAST(this, CCandUIMenuEventSink*);

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

    Increment reference count
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIMenuEventSink::AddRef()
{
    ++m_cRef;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

    Decrement reference count and release
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIMenuEventSink::Release()
{
    --m_cRef;

    if (0 < m_cRef)
        return m_cRef;

    delete this;
    return 0;
}


/*   I N I T  C A N D I D A T E  M E N U   */
/*------------------------------------------------------------------------------

    Callback function to initialize candidate menu
    (ITfCandUIMenuEventSink method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuEventSink::InitMenu(ITfMenu *pMenu)
{
    return (*m_pfnInitMenu)(pMenu, m_pic, m_pv);
}


/*   O N  C A N D  U I  M E N U  C O M M A N D   */
/*------------------------------------------------------------------------------

    Callback function of candidate menu event
    (ITfCandUIMenuEventSink method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuEventSink::OnMenuCommand(UINT uiCmd)
{
    return (*m_pfnOnCandUIMenuCommand)(uiCmd, m_pic, m_pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\canduies.h ===
//
// canduies.h
//

#ifndef CANDUIES_H
#define CANDUIES_H

#include "private.h"
#include "korimx.h"
#include "globals.h"
#include "mscandui.h"


//
// Callback functions
//

typedef HRESULT (*PFNONBUTTONPRESSED)(LONG id, ITfContext *pic, void *pVoid);
typedef HRESULT (*PFNONFILTEREVENT)(CANDUIFILTEREVENT ev, ITfContext *pic, void *pVoid);
typedef HRESULT (*PFNINITMENU)(ITfMenu *pMenu, ITfContext *pic, void *pVoid);
typedef HRESULT (*PFNONCANDUIMENUCOMMAND)( UINT uiCmd, ITfContext *pic, void *pVoid);


//
// CCandUIExtButtonEventSink
//

class CCandUIExtButtonEventSink : public ITfCandUIExtButtonEventSink
{
public:
	CCandUIExtButtonEventSink(PFNONBUTTONPRESSED pfnOnButtonPressed, ITfContext *pic, void *pVoid);
	~CCandUIExtButtonEventSink();
	
	//
	// IUnknown
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIExtButtonEventSink
	//
	STDMETHODIMP OnButtonPressed(LONG id);

protected:
	long 				m_cRef;
	ITfContext			*m_pic;
	void				*m_pv;
	PFNONBUTTONPRESSED	m_pfnOnButtonPressed;
};


//
// CCandUIAutoFilterEventSink
//

class CCandUIAutoFilterEventSink : public ITfCandUIAutoFilterEventSink
{
public:
	CCandUIAutoFilterEventSink(PFNONFILTEREVENT pfnOnFilterEvent, ITfContext *pic, void *pVoid);
	~CCandUIAutoFilterEventSink();
	
	//
	// IUnknown
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//
	// ITfCandUIAutoFilterEventSink
	//
	STDMETHODIMP OnFilterEvent(CANDUIFILTEREVENT ev);

protected:
	long		m_cRef;
	ITfContext	*m_pic;
	void		*m_pv;
	PFNONFILTEREVENT m_pfnOnFilterEvent;
};


//
// CCandUIMenuEventSink
//

class CCandUIMenuEventSink : public ITfCandUIMenuEventSink
{
public:
	CCandUIMenuEventSink(PFNINITMENU pfnInitMenu, PFNONCANDUIMENUCOMMAND pfnOnCandUIMenuCommand, ITfContext *pic, void *pVoid);
	~CCandUIMenuEventSink();

	//
	// IUnknown
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//
	// ITfCandUIMenuEventSink
	//
	STDMETHODIMP InitMenu(ITfMenu *pMenu);
	STDMETHODIMP OnMenuCommand(UINT uiCmd);

protected:
	long		m_cRef;
	ITfContext	*m_pic;
	void		*m_pv;
	PFNINITMENU				m_pfnInitMenu;
	PFNONCANDUIMENUCOMMAND	m_pfnOnCandUIMenuCommand;
};

#endif // CANDUIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\cicbtn.h ===
//
// cicbtn.h
//

#ifndef _CICBTN_H_
#define _CICBTN_H_

#include <initguid.h>
#include "slbarid.h"

#define CICBTN_TOOLTIP_MAX	256
#define CICBTN_TEXT_MAX	256

class __declspec(novtable) CCicButton : public ITfSource, public ITfLangBarItemButton
{
public:
    CCicButton()
    {
		m_uid       = (UINT)-1;
		m_dwStatus  = 0;
		m_fShown    = FALSE;
		m_fEnable   = TRUE;
		m_szText[0] = L'\0';
		m_cRef      = 1;
	}
    ~CCicButton();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
	//virtual STDMETHODIMP_(ULONG) Release(void);

    void InitInfo(REFCLSID clsid, REFGUID rguid, DWORD dwStyle, ULONG ulSort, LPWSTR pszDesc);
    virtual STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    virtual STDMETHODIMP GetStatus(DWORD *pdwStatus);
    virtual STDMETHODIMP Show(BOOL fShow);
    virtual STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);
    virtual STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    virtual STDMETHODIMP UnadviseSink(DWORD dwCookie);
	virtual STDMETHODIMP OnClick( /* [in] */ TfLBIClick click, /* [in] */ POINT pt, /* [in] */ const RECT __RPC_FAR *prcArea);
	virtual STDMETHODIMP InitMenu( /* [in] */ ITfMenu __RPC_FAR *pMenu);
	virtual STDMETHODIMP OnMenuSelect( /* [in] */ UINT wID);
	virtual STDMETHODIMP GetIcon( /* [out] */ HICON __RPC_FAR *phIcon);
	virtual STDMETHODIMP GetText( /* [out] */ BSTR __RPC_FAR *pbstrText);

    virtual HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    virtual HRESULT OnRButtonUp(const POINT pt, const RECT *prcArea);

    DWORD GetStyle() {return m_lbiInfo.dwStyle;}
    void SetStyle(DWORD dwStyle) {m_lbiInfo.dwStyle = dwStyle;}

    GUID* GetGuidItem() {return &m_lbiInfo.guidItem;}

    DWORD GetStatusInternal() {return m_dwStatus;}
    void SetStatusInternal(DWORD dw) {m_dwStatus = dw;}
    HRESULT ShowInternal(BOOL fShow, BOOL fNotify = FALSE);

    void SetOrClearStatus(DWORD dw, BOOL fSet);

    ITfLangBarItemSink *GetSink() { return m_plbiSink; }

    void SetText(WCHAR *psz);
    void SetToolTip(WCHAR *psz);
	void SetStatus(DWORD dwStatus);
	void Enable(BOOL fEnable);
	BOOL IsEnable() { return m_fEnable;	}
	void ShowDefault(BOOL fShowDefault);

	void SetID(UINT uid) { m_uid = uid;  }
	UINT GetID()	     { return m_uid; }


protected:
    //DWORD _dwStatus;
    TF_LANGBARITEMINFO m_lbiInfo;
    WCHAR m_szToolTip[CICBTN_TOOLTIP_MAX];
    long m_cRef;
    ITfLangBarItemSink *m_plbiSink;

private:
    DWORD m_dwCookie;
	DWORD m_dwStatus;
	BOOL m_fShown;
	BOOL m_fEnable;
	UINT m_uid;
    WCHAR m_szText[CICBTN_TEXT_MAX];
};

inline
void CCicButton::SetOrClearStatus(DWORD dw, BOOL fSet)
{
    if (fSet)
        m_dwStatus |= dw;
    else
        m_dwStatus &= ~dw;
}

inline
void CCicButton::SetToolTip(WCHAR *psz)
{
    wcsncpy(m_szToolTip, psz, CICBTN_TOOLTIP_MAX);
}


inline
void CCicButton::SetStatus(DWORD dwStatus)
{
	BOOL fShown = m_fShown;
	m_dwStatus = dwStatus;
	ShowInternal(fShown);
}

inline
void CCicButton::Enable(BOOL fEnable)
{
	m_fEnable = fEnable;
	if(fEnable) {	// enable?
		m_dwStatus &= ~TF_LBI_STATUS_DISABLED;
	} else {
		m_dwStatus |= TF_LBI_STATUS_DISABLED;
	}
}

inline
void CCicButton::ShowDefault(BOOL fShowDefault)
{
	if( fShowDefault == FALSE ) {
		m_lbiInfo.dwStyle |= TF_LBI_STYLE_HIDDENBYDEFAULT;
	} else {
		m_lbiInfo.dwStyle &= ~TF_LBI_STYLE_HIDDENBYDEFAULT;
	}
}

inline
void CCicButton::SetText(WCHAR *psz)
{
	wcsncpy(m_szText, psz, CICBTN_TEXT_MAX);
}

#endif // _CICBTN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\cmode.h ===
//
// CMODE.H
//

#if !defined (__CMODE_H__INCLUDED_)
#define __CMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class CMode : public CCicButton
{
public:
    CMode(CToolBar *ptb);
    ~CMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    //HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:

	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __CMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\cmode.cpp ===
/****************************************************************************
   CMODE.CPP : CMode class implementation which manage conversion mode button
                  on the Cicero Toolbar

   History:
      10-JAN-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "cmode.h"
#include "userex.h"
#include "resource.h"

// {951549C6-9752-4b7d-9B0E-35AEBFF9E446}
const GUID GUID_LBI_KORIMX_CMODE = 
{   
    0x951549c6, 
    0x9752, 
    0x4b7d, 
    { 0x9b, 0xe, 0x35, 0xae, 0xbf, 0xf9, 0xe4, 0x46 }
};

/*---------------------------------------------------------------------------
    CMode::CMode
---------------------------------------------------------------------------*/
CMode::CMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    // Set Add/Remove and tootip text
    LoadStringExW(g_hInst, IDS_TT_HAN_ENG, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_KorIMX, 
                GUID_LBI_KORIMX_CMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_SHOWNINTRAY | TF_LBI_STYLE_TEXTCOLORICON,
                100, 
                szText);
    SetToolTip(szText);

    // Set button text
    LoadStringExW(g_hInst, IDS_BUTTON_HAN_ENG, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}

/*---------------------------------------------------------------------------
    CMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CMode::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    CMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI CMode::GetIcon(HICON *phIcon)
{
    UINT uiIcon = 0;
    static const UINT uidIcons[2][2] = 
    {
        { IDI_CMODE_ENGLISH, IDI_CMODE_ENGLISHW },
        { IDI_CMODE_HANGUL,  IDI_CMODE_HANGULW }
    };

    
    if (m_pTb->IsOn() && (m_pTb->GetConversionMode() & TIP_HANGUL_MODE))
        uiIcon = 1;

    if (IsHighContrastBlack())
        uiIcon = uidIcons[uiIcon][1];
    else
        uiIcon = uidIcons[uiIcon][0];
    
    *phIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);;
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    CMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    CMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    DWORD dwConvMode;

    dwConvMode = m_pTb->GetConversionMode();

    // Toggle Hangul mode
    dwConvMode ^= TIP_HANGUL_MODE;
    
    SetCMode(dwConvMode);
    
    return S_OK;
}

#if 0
//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT CMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    HMENU hMenu;
    DWORD dwConvMode;
    CHAR  szText[256];
    UINT  uiId;
    int   nRet;
    
    hMenu = CreatePopupMenu();
    
    dwConvMode = GetCMode();
    if (dwConvMode & TIP_HANGUL_MODE)
        uiId = IDS_ENGLISH_MODE;
    else
        uiId = IDS_HANGUL_MODE;

    // Add Hangul/English mode menu
    LoadStringExA(g_hInst, uiId, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 1, szText);

    // Add Cancel menu
    LoadStringExA(g_hInst, IDS_CANCEL, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 0, szText);

    nRet = TrackPopupMenuEx(hMenu, 
                         TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                         pt.x, pt.y, m_pTb->GetOwnerWnd(), NULL);
    switch (nRet)
        {
    case 1: 
        dwConvMode = GetCMode();

        // Toggle Hangul mode
        if (dwConvMode & TIP_HANGUL_MODE)
            dwConvMode &= ~TIP_HANGUL_MODE;
        else
            dwConvMode |= TIP_HANGUL_MODE;

        SetCMode(dwConvMode);
        break;
        }

    DestroyMenu(hMenu);

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\cicbtn.cpp ===
//
// cicbtn.cpp
//
// base code: nuibase sample
//

#include "private.h"
#include "globals.h"
#include "cicbtn.h"
#include "helpers.h"

#define CICBTN_ITEMSINK_COOKIE 0x80000003

//////////////////////////////////////////////////////////////////////////////
//
// CCicButton
//
//////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCicButton::~CCicButton()
{
    SafeRelease(m_plbiSink);
}

//+---------------------------------------------------------------------------
//
// InitInfo
//
//----------------------------------------------------------------------------

void CCicButton::InitInfo(REFCLSID rclsid, 
                                REFGUID rguid, 
                                DWORD dwStyle, 
                                ULONG ulSort,
                                LPWSTR pszDesc)
{
    // init nuiInfo.
    m_lbiInfo.clsidService = rclsid;
    m_lbiInfo.guidItem = rguid;
    m_lbiInfo.dwStyle = dwStyle;
    m_lbiInfo.ulSort = ulSort;
    StringCchCopyW(m_lbiInfo.szDescription, ARRAYSIZE(m_lbiInfo.szDescription), pszDesc);
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    *pInfo = m_lbiInfo;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetStatus(DWORD *pdwStatus)
{
    *pdwStatus = m_dwStatus;
    
    if (m_fEnable)    // enable?
        {
        // do nothing
        }
    else
        *pdwStatus |= TF_LBI_STATUS_DISABLED;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CCicButton::Show(BOOL fShow)
{
    ITfLangBarItemSink* pSink;

    ShowInternal(fShow);
    pSink = GetSink();
    if (pSink)
        pSink->OnUpdate(TF_LBI_STATUS);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

HRESULT CCicButton::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    HRESULT hr;

    if (IsEqualIID(IID_ITfLangBarItemSink, riid))
        {
        if (m_plbiSink)
            hr = CONNECT_E_CANNOTCONNECT;
        else
            {
            hr = punk->QueryInterface(IID_ITfLangBarItemSink, (void **)&m_plbiSink);
            if (SUCCEEDED(hr))
                *pdwCookie = CICBTN_ITEMSINK_COOKIE;
            }
        }
    else
        hr = CONNECT_E_CANNOTCONNECT;
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

HRESULT CCicButton::UnadviseSink(DWORD dwCookie)
{
    if (CICBTN_ITEMSINK_COOKIE  != dwCookie)
        return E_FAIL;

    if (!m_plbiSink)
        return E_UNEXPECTED;

    m_plbiSink->Release();
    m_plbiSink = NULL;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

HRESULT CCicButton::ShowInternal(BOOL fShow, BOOL fNotify)
{
    m_fShown = fShow;
    DWORD dwOldStatus = m_dwStatus;

    if (fShow)
        m_dwStatus &= ~TF_LBI_STATUS_HIDDEN;
    else
        m_dwStatus |= TF_LBI_STATUS_HIDDEN;

    if (fNotify && (dwOldStatus != m_dwStatus) && m_plbiSink)
         m_plbiSink->OnUpdate(TF_LBI_STATUS);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemButtonBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCicButton::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
        {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
        }
    else if (IsEqualIID(riid, IID_ITfLangBarItemButton))
        {
        *ppvObj = SAFECAST(this, ITfLangBarItemButton *);
        }
    else if (IsEqualIID(riid, IID_ITfSource))
        {
        *ppvObj = SAFECAST(this, ITfSource *);
        }

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CCicButton::AddRef()
{
    return ++m_cRef;
}

#ifdef NEVER // each button object has this
STDAPI_(ULONG) CCicButton::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}
#endif // NEVER


//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CCicButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    switch (click)
        {
        case TF_LBI_CLK_RIGHT:
            return OnRButtonUp(pt, prcArea);
        case TF_LBI_CLK_LEFT:
            return OnLButtonUp(pt, prcArea);
        }
        
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CCicButton::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    pt, prcArea; // no ref
   return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT CCicButton::OnRButtonUp(const POINT pt, const RECT *prcArea)
{
    pt, prcArea; // no ref
   return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CCicButton::InitMenu(ITfMenu *pMenu)
{
    pMenu; // no ref
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CCicButton::OnMenuSelect(UINT uID)
{
    uID; // no ref
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetIcon(HICON *phIcon)
{
    phIcon; // no ref
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetText(BSTR *pbstrText)
{
    if (!pbstrText)
        return E_INVALIDARG;

    *pbstrText = SysAllocString(m_szText);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetTooltipString(BSTR *pbstrToolTip)
{
    if (!pbstrToolTip)
        return E_INVALIDARG;

    *pbstrToolTip = SysAllocString(m_szToolTip);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\config.h ===
/****************************************************************************
	CONFIG.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IME Configuration DLG and registry access functions

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_CONFIG_H__INCLUDED_)
#define _CONFIG_H__INCLUDED_

//////////////////////////////////////////////////////////////////////////////
// Bit const for SetRegValues
#define GETSET_REG_STATUSPOS		0x0001
#define GETSET_REG_IMEKL			0x0002
#define GETSET_REG_JASODEL			0x0004
#define GETSET_REG_ISO10646			0x0008
#define GETSET_REG_STATUS_BUTTONS	0x0010
#define GETSET_REG_KSC5657			0x0020
#define GETSET_REG_CANDUNICODETT	0x0040
#define GETSET_REG_ALL				0xFFFF

extern BOOL ConfigDLG(HWND hWnd);
extern BOOL GetRegValues(UINT uGetBits);	// get configuration info from reg. and set it to pImeData
extern BOOL GetStatusWinPosReg(POINT *pptStatusWinPosReg);
extern BOOL SetRegValues(UINT uSetBits); // set configuration info to reg.


#endif //!defined (_CONFIG_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\config.cpp ===
/****************************************************************************
    CONFIG.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IME Configuration DLG and registry access functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "gdata.h"
#include "debug.h"
#include "config.h"
#include "prsht.h"
#include "osver.h"
#include "userex.h"
#include "resource.h"

// Config DLG Help ID
#define IDH_GRP_STATUSWIN               1001
#define IDH_JUNBAN_TOGGLE               1002
#define IDH_HANJA_CONV                  1003
#define IDH_GRP_KEYLAYOUT               1004
#define IDH_2BEOLSIK                    1005
#define IDH_3BEOLSIK_390                1006
#define IDH_3BEOLSIK_FINAL              1007
#define IDH_DELJASO                     1008
#define IDH_K1HANJA                        1009

// Private functions
static void PASCAL AddPage(LPPROPSHEETHEADERW ppsh, UINT id, DLGPROC pfn);
static INT_PTR CALLBACK ConfigDLGProc1(HWND hDlg, UINT message, 
                                   WPARAM wParam, LPARAM lParam);
static int *GetContextHelpList();
static BOOL IsValidCtrlIdForHelp(INT *helpList, INT ctrlId);
static void GetHelpFileName();

int *GetContextHelpList()
{
    // Context Help Ids of PropertySheet
    static int ProDlgCtxHelpList[] = 
        {
        IDC_GRP_KEYLAYOUT,  IDH_GRP_KEYLAYOUT,
        IDC_2BEOLSIK,       IDH_2BEOLSIK,   
        IDC_3BEOLSIK_390,   IDH_3BEOLSIK_390,
        IDC_3BEOLSIK_FINAL, IDH_3BEOLSIK_FINAL,
        IDC_DELJASO,        IDH_DELJASO,
        IDC_K1HANJA,        IDH_K1HANJA,
        0,      0
        };
    return ProDlgCtxHelpList;
}

BOOL IsValidCtrlIdForHelp(INT *helpList, INT ctrlId)
{
    INT *p;
    for(p = helpList; *p != 0;  p+=2) 
        {
        if(ctrlId == *p)
            return fTrue;
        }
    return fFalse;
}

void GetHelpFileName(LPTSTR szHelpFileNameFull, int cchszHelpFileNameFull)
{
    // WARNING: This only will work for NT or Win98. For Win95 need to check system locale
    LoadStringExA(g_hInst, IDS_CONTEXTHELP_FILENAME, szHelpFileNameFull, MAX_PATH);
}

static HWND hwndPropSheet = (HWND)0;
static BOOL g_fDestroyPropNow = FALSE;

BOOL ConfigDLG(HWND hwndParent)
{
    static HPROPSHEETPAGE  rPages[1];
    static PROPSHEETHEADERW psh;
       static WCHAR szCaption[64];
    MSG    msg = {0};
    BOOL   fRet = fFalse;

    // If config DLG already created
    if (IsWindow(hwndPropSheet))
        {
        SetForegroundWindow(hwndPropSheet);
        return fTrue;
        }

    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_NOAPPLYNOW | PSH_USEICONID | PSH_MODELESS | PSH_USEPAGELANG;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hInst;
    if (IsOnNT())
        LoadStringExW(g_hInst, IDS_PROGRAM, szCaption, sizeof(szCaption)/sizeof(WCHAR));
       else
        LoadStringExA(g_hInst, IDS_PROGRAM, (LPSTR)szCaption, sizeof(szCaption));
    psh.pszCaption = szCaption;
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = rPages;

    AddPage(&psh, IDD_CONFIG_PAGE1, ConfigDLGProc1);

    if (IsOnNT())
        hwndPropSheet = (HWND)PropertySheetW(&psh);
    else
        hwndPropSheet = (HWND)PropertySheetA((PROPSHEETHEADERA*)&psh);

    while (IsWindow(hwndPropSheet) && OurGetMessage(&msg, NULL, 0x00, 0x00))
        {
        // If the modeless guy is up and is ready to be destroyed
        // (PropSheet_GetCurrentPageHwnd returns NULL) then destroy the dialog.
        
        // PropSheet_GetCurrentPageHwnd will return NULL after the OK or Cancel 
        // button has been pressed and all of the pages have been notified. The 
        // Apply button doesn't cause this to happen.
        if(/*g_fDestroyPropNow == fTrue || */(hwndPropSheet && (NULL == PropSheet_GetCurrentPageHwnd(hwndPropSheet)))) 
            {
            //enable the parent first to prevent another window from becoming the foreground window
            //EnableWindow(hwndParent, TRUE);
            DestroyWindow(hwndPropSheet);
            //break;
        }

        //use PropSheet_IsDialogMessage instead of IsDialogMessage
        if(!PropSheet_IsDialogMessage(hwndPropSheet, &msg))
            {
            TranslateMessage(&msg);
            if (IsOnNT())
                DispatchMessageW(&msg);
            else
                DispatchMessageA(&msg);
            }
        }
    
    hwndPropSheet = (HWND)0;
    
    return fTrue;
}

void PASCAL AddPage(LPPROPSHEETHEADERW ppsh, UINT idDlg, DLGPROC pfn)
{
    //if (ppsh->nPages < 3)
    //{
    PROPSHEETPAGE psp;
    ZeroMemory(&psp, sizeof(psp));

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DLGINDIRECT;
    psp.hInstance = g_hInst;
    psp.pResource = LoadDialogTemplateEx(GetSystemDefaultLangID(), g_hInst, MAKEINTRESOURCE(idDlg));
    psp.pfnDlgProc = pfn;
    psp.lParam = 0;

    ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);
    if (ppsh->phpage[ppsh->nPages])
      ppsh->nPages++;
   //}
}

INT_PTR CALLBACK ConfigDLGProc1(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    static UINT    uPrevKeyboardType;
    static BOOL    fPrevJasoDel;
    static BOOL fK1Hanja;
    BOOL fFound = fFalse;
    TCHAR  szHelpFileNameFull[MAX_PATH];
    CIMEData    ImeData(CIMEData::SMReadWrite);

    DebugMsg(DM_TRACE, TEXT("ConfigDLGProc"));

    // If Properties DLG invoked from Setting in Toolbar and no Tip instance exist in the system,
    // IMEData is not init. So make sure we load reg values here.
    ImeData.InitImeData();

    switch(message)
        {
        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
                {
            case PSN_APPLY:
                ImeData.SetCurrentBeolsik(uPrevKeyboardType);
                ImeData.SetJasoDel(fPrevJasoDel);
                ImeData.SetKSC5657Hanja(fK1Hanja);
                SetRegValues(GETSET_REG_STATUS_BUTTONS|GETSET_REG_IMEKL|GETSET_REG_JASODEL|GETSET_REG_KSC5657);
                break;
                    
            default:
                return fFalse;
                }
            break;

        case WM_INITDIALOG:
            uPrevKeyboardType = ImeData.GetCurrentBeolsik();
            CheckRadioButton(hDlg, IDC_2BEOLSIK, IDC_3BEOLSIK_FINAL, IDC_2BEOLSIK+uPrevKeyboardType);
            fPrevJasoDel = ImeData.GetJasoDel();
            if (fPrevJasoDel)
                CheckDlgButton(hDlg, IDC_DELJASO, BST_CHECKED);
            else
                CheckDlgButton(hDlg, IDC_DELJASO, BST_UNCHECKED);

            // KSC-5657 Hanja
            fK1Hanja = ImeData.GetKSC5657Hanja() && !IsOn95();
            if (fK1Hanja)
                CheckDlgButton(hDlg, IDC_K1HANJA, BST_CHECKED);
            else
                CheckDlgButton(hDlg, IDC_K1HANJA, BST_UNCHECKED);

            // If Win95, disable K1 Hanja
            if (IsOn95())
                EnableWindow(GetDlgItem(hDlg, IDC_K1HANJA), fFalse);
            return fTrue;

        case WM_COMMAND:
            switch (wParam)
               {
            case IDC_2BEOLSIK:
                //if (IsDlgButtonChecked(hDlg, IDC_2BEOLSIK)) {
                    uPrevKeyboardType = KL_2BEOLSIK;
                //}
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_3BEOLSIK_390:
                uPrevKeyboardType = KL_3BEOLSIK_390;
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_3BEOLSIK_FINAL:
                uPrevKeyboardType = KL_3BEOLSIK_FINAL;
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;
                
            case IDC_DELJASO:
                if (IsDlgButtonChecked(hDlg, IDC_DELJASO))
                    fPrevJasoDel = fTrue;
                else
                    fPrevJasoDel = fFalse;

                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_K1HANJA:
                if (IsDlgButtonChecked(hDlg, IDC_K1HANJA))
                    fK1Hanja = fTrue;
                else
                    fK1Hanja = fFalse;
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            default:
                return fFalse;
               }
            break;

        case WM_CONTEXTMENU:
            GetHelpFileName(szHelpFileNameFull, MAX_PATH);
            WinHelp((HWND)wParam, 
                    szHelpFileNameFull, 
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)(LPVOID)GetContextHelpList());
            return 0;

        case WM_HELP:
            INT *pHelpList;
            pHelpList = GetContextHelpList();
            if(IsValidCtrlIdForHelp(pHelpList, ((LPHELPINFO)lParam)->iCtrlId)) 
                {
                GetHelpFileName(szHelpFileNameFull, MAX_PATH);
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                        szHelpFileNameFull,
                        HELP_WM_HELP,
                        (ULONG_PTR)pHelpList);
                }
            return 0;

        default:
            return fFalse;
        }
    return fTrue;
}

#ifdef NEVER
BOOL GetStatusWinPosReg(POINT *pptStatusWinPosReg)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb;
    BOOL    fSuccess = fFalse;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, g_szIMERootKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        dwCb = sizeof(dwBuf);
        if (RegQueryValueEx(hKey, g_szStatusPos, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS)
            {
            pptStatusWinPosReg->x = HIWORD(dwBuf);
            pptStatusWinPosReg->y = LOWORD(dwBuf);
            fSuccess = fTrue;
            }
            
        RegCloseKey(hKey);
        }

    return fSuccess;
}
#endif
///////////////////////////////////////////////////////////////////////////////
//
BOOL GetRegValues(UINT uGetBits)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb, dwType;
    CIMEData    ImeData(CIMEData::SMReadWrite);
    BOOL    fSuccess = fTrue;

    DebugMsg(DM_TRACE, "GetRegValues()");

    if (RegOpenKeyEx(HKEY_CURRENT_USER, g_szIMERootKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        ///////////////////////////////////////////////////////////////////
        // IME Keyboard Layout
        if (uGetBits & GETSET_REG_IMEKL) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szIMEKL, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS) 
                {
                if (/*dwBuf >= KL_2BEOLSIK &&*/ dwBuf <= KL_3BEOLSIK_FINAL)
                    ImeData.SetCurrentBeolsik(dwBuf);
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Status window pos
        if (uGetBits & GETSET_REG_STATUSPOS) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szStatusPos, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS)
                {
                ImeData->ptStatusPos.x = HIWORD(dwBuf);
                ImeData->ptStatusPos.y = LOWORD(dwBuf);
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Status window button setting
        if (uGetBits & GETSET_REG_STATUS_BUTTONS) 
            {
            BYTE ButtonReg[MAX_NUM_OF_STATUS_BUTTONS+1];
            int        nButton;

            dwCb = sizeof(ButtonReg);
            dwType = REG_BINARY;
            if (RegQueryValueEx(hKey, g_szStatusButtons, NULL, &dwType, (LPBYTE)&ButtonReg, &dwCb) == ERROR_SUCCESS)
                {
                if (ButtonReg[0] == 0)
                    ButtonReg[0] = 1;
                    
                if (ButtonReg[0]<=MAX_NUM_OF_STATUS_BUTTONS) 
                    {
                    for (nButton=0; nButton<ButtonReg[0]; nButton++) 
                        {
                        // button data validity check
                        if (ButtonReg[nButton+1] <= IME_PAD_BUTTON && ButtonReg[nButton+1] != NULL_BUTTON)
                            ImeData->StatusButtons[nButton].m_ButtonType = (StatusButtonTypes)ButtonReg[nButton+1];
                        else
                            break;
                        }
                    ImeData->uNumOfButtons = nButton;
                    }
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Deletion by Jaso
        if (uGetBits & GETSET_REG_JASODEL) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szCompDel, NULL, NULL, (LPBYTE)&dwBuf, &dwCb)    == ERROR_SUCCESS)
                ImeData.SetJasoDel(dwBuf);
            }

#if 0
            // REVIEW: Do we still need for TIP?

        if (uGetBits & GETSET_REG_ISO10646) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szXWEnable, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS)
                vpInstData->fISO10646 = dwBuf;
            else
                fSuccess = fFalse;

            // For Win95 and Win98 lookup INI file for ISO10646 setting.
            // ISO10646.EXE set registry
            if (!IsWinNT())
                vpInstData->fISO10646 = GetProfileInt(g_szXWEnable, 
                                                OurGetModuleFileName(fFalse), 
                                                vpInstData->fISO10646);
            }
#endif

        // Get KSC5657 K1 Hanja flag
        if (uGetBits & GETSET_REG_KSC5657) 
            {
            dwCb = sizeof(dwBuf);
            dwType = REG_DWORD;
            if (RegQueryValueEx(hKey, g_szEnableK1Hanja, NULL, &dwType, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS) 
                ImeData->fKSC5657Hanja = dwBuf;
            else
                ImeData->fKSC5657Hanja = fFalse;
            }

        // Get Unicode Tooltip Cand window flag
        // Currently this has no UI part which means hidden spec so no need SetReg now.
        if (uGetBits & GETSET_REG_CANDUNICODETT) 
            {
            dwCb = sizeof(dwBuf);
            dwType = REG_DWORD;
            if (RegQueryValueEx(hKey, g_szEnableCandUnicodeTT, NULL, &dwType, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS) 
                ImeData->fCandUnicodeTT = dwBuf;
            else
                ImeData->fCandUnicodeTT = fFalse;
            }

        RegCloseKey(hKey);
        }
    else
        {
        fSuccess = fFalse;
        Assert(0);
        }

    return fSuccess;
}

BOOL SetRegValues(UINT uSetBits)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb;
    int        nButton;
    CIMEData    ImeData;

    ///////////////////////////////////////////////////////////////////////////
    // Set status pos
    if (RegCreateKeyEx(HKEY_CURRENT_USER, g_szIMERootKey, 0, NULL, REG_OPTION_NON_VOLATILE, 
        KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS) 
        {
        if (uSetBits & GETSET_REG_STATUSPOS) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = (ImeData->ptStatusPos.x << 16) | (ImeData->ptStatusPos.y & 0xFFFF);  // HIWORD : X, LOWORD : Y
            RegSetValueEx(hKey, g_szStatusPos, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);

            }

        if (uSetBits & GETSET_REG_STATUS_BUTTONS) 
            {
            BYTE ButtonReg[MAX_NUM_OF_STATUS_BUTTONS+1];
            dwCb = sizeof(ButtonReg);

            Assert(ImeData->uNumOfButtons <= MAX_NUM_OF_STATUS_BUTTONS);
            // set number of button as the first element of array
            if (ImeData->uNumOfButtons<=MAX_NUM_OF_STATUS_BUTTONS)
                ButtonReg[0] = (BYTE)ImeData->uNumOfButtons;

            for (nButton=0; nButton < (INT)ImeData->uNumOfButtons; nButton++) 
                ButtonReg[nButton+1] = ImeData->StatusButtons[nButton].m_ButtonType;
                
            // clear
            for (; nButton<MAX_NUM_OF_STATUS_BUTTONS; nButton++)
                ButtonReg[nButton+1] = NULL_BUTTON;

            RegSetValueEx(hKey, g_szStatusButtons, 0, REG_BINARY, (LPBYTE)&ButtonReg, dwCb);
            }


        if (uSetBits & GETSET_REG_IMEKL) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetCurrentBeolsik();
            RegSetValueEx(hKey, g_szIMEKL, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }
        
        if (uSetBits & GETSET_REG_JASODEL) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetJasoDel();
            RegSetValueEx(hKey, g_szCompDel, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }

        // Get KSC5657 K1 Hanja flag
        if (uSetBits & GETSET_REG_KSC5657) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetKSC5657Hanja();
            RegSetValueEx(hKey, g_szEnableK1Hanja, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }

        RegCloseKey(hKey);
        }
    else 
        return fFalse;
        
    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\crtfree.h ===
//
//   CrtFree.h
//
//   History:
//      18-NOV-1999 CSLim Created

#if !defined (__CRTFREE_H__INCLUDED_) && defined(NOCLIB)
#define __CRTFREE_H__INCLUDED_

extern LPWSTR ImeRtl_StrCopyW(LPWSTR pwDest, LPCWSTR pwSrc);
extern LPWSTR ImeRtl_StrnCopyW(LPWSTR pwDest, LPCWSTR pwSrc, UINT uiCount);
extern INT ImeRtl_StrCmpW(LPCWSTR pwSz1, LPCWSTR pwSz2);
extern INT ImeRtl_StrnCmpW(LPCWSTR wszFirst, LPCWSTR wszLast, UINT uiCount);

// Since immxlib.lib call memmove internaly, we should define this function
// specifically ptrary.cpp, strary.cpp and fontlink.cpp
extern void * __cdecl memmove(void * dst, const void * src, size_t count);

#endif // __CRTFREE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\crtfree.cpp ===
#include "private.h"

// Thi is not working since ATL uses CRT dll. we should not use ATL to remove CRT bondage
#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries

#ifdef NOCLIB

#if defined(_M_IX86)

extern "C" int _fltused = 1;

/*----------------------------------------------------------------------------
    _ftol - convert a float value to an __int64.  The argument is on the top of
    the stack, the result is returned in EAX (low) and EDX (high).  Note that
    this is used for all float to integral convertion and deals with both
    signed and unsigned values - the compiler just ignores the EDX value.  The
    LongFromDouble and UlongFromDouble functions check the range, so this
    cavlier bitwise truncation doesn't matter.
------------------------------------------------------------------- JohnBo -*/
extern "C" __declspec(naked) void __cdecl _ftol(void)
{
   // A simple FISTP is all that is required (so why is this out of line?
    // possible the CRT version handles overflow differently?)
    __asm PUSH EDX;              // Just to make room on the stack
    __asm PUSH EAX;
    __asm FISTP QWORD PTR [ESP]; // Pop long off top of FP stack
    __asm POP EAX;               // And put back into EDX/EAX - tedious eh?
    __asm POP EDX;               // Stack grows downwards, so EDX is high.
    __asm RET;
}

#endif

/*
 *    memmove
 */
void * __cdecl memmove(void * dst, const void * src, size_t count)
{
    void * ret = dst;

    if (dst <= src || (char *)dst >= ((char *)src + count)) {
        /*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
        // memcpy is intrinsic
        memcpy(dst, src, count);
    } else {
        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        dst = (char *)dst + count - 1;
        src = (char *)src + count - 1;
        while (count--) {
            *(char *)dst = *(char *)src;
            dst = (char *)dst - 1;
            src = (char *)src - 1;
        }
    }
    return(ret);
}

/*---------------------------------------------------------------------------
    StrCopyW
    Unicode String copy
---------------------------------------------------------------------------*/
LPWSTR ImeRtl_StrCopyW(LPWSTR pwDest, LPCWSTR pwSrc)
{
    LPWSTR pwStart = pwDest;

    while (*pwDest++ = *pwSrc++)
            ;
            
    return (pwStart);
}

/*---------------------------------------------------------------------------
    StrnCopyW
    Unicode String copy
---------------------------------------------------------------------------*/
LPWSTR ImeRtl_StrnCopyW(LPWSTR pwDest, LPCWSTR pwSrc, UINT uiCount)
{
    LPWSTR pwStart = pwDest;

    while (uiCount && (*pwDest++ = *pwSrc++))    // copy string 
        uiCount--;

    if (uiCount)                                // pad out with zeroes
        while (--uiCount)
            *pwDest++ = 0;

    return (pwStart);
}


/*---------------------------------------------------------------------------
    StrCmpW
    Unicode String compare
---------------------------------------------------------------------------*/
INT ImeRtl_StrCmpW(LPCWSTR pwSz1, LPCWSTR pwSz2)
{
    INT cch1 = lstrlenW(pwSz1);
    INT cch2 = lstrlenW(pwSz2);

    if (cch1 != cch2)
        return cch2 - cch1;

    for (INT i=0; i<cch1; i++)
        {
        if (pwSz1[i] != pwSz2[i])
            return i+1;
        }

    return 0;
}

/*---------------------------------------------------------------------------
    StrnCmpW
    Unicode String compare
---------------------------------------------------------------------------*/
INT ImeRtl_StrnCmpW(LPCWSTR wszFirst, LPCWSTR wszLast, UINT uiCount)
{
    if (!uiCount)
        return(0);

    while (--uiCount && *wszFirst && *wszFirst == *wszLast) 
        {
        wszFirst++;
        wszLast++;
        }
    return (*wszFirst - *wszLast);
}

/*---------------------------------------------------------------------------
    StrnCatW
    Unicode String concatenation
---------------------------------------------------------------------------*/
WCHAR * __cdecl Imertl_StrCatW(WCHAR *wszDest, const WCHAR *wszSource)
{
    WCHAR *wszStart = wszDest;
    WCHAR *pwch;

    for (pwch = wszDest; *pwch; pwch++);
    while (*pwch++ = *wszSource++);

    return(wszStart);
}

wchar_t * __cdecl wcscpy(wchar_t *a, const wchar_t *b)
{
    return ImeRtl_StrCopyW(a,b);
}

wchar_t * __cdecl wcsncpy(wchar_t *a, const wchar_t *b, size_t c)
{
    return ImeRtl_StrnCopyW(a,b,c);
}

size_t __cdecl wcslen(const wchar_t *a)
{
    return lstrlenW(a);
}

int __cdecl wcscmp(const wchar_t *a, const wchar_t *b)
{
    return ImeRtl_StrCmpW(a, b);
}

int __cdecl wcsncmp(const wchar_t *a, const wchar_t *b, size_t c)
{
    return ImeRtl_StrnCmpW(a, b, c);
}

wchar_t * __cdecl wcscat(wchar_t *pwSz1, const wchar_t *pwSz2)
{
    return Imertl_StrCatW(pwSz1, pwSz2);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "IMEKRCIC"
#define SZ_MODULE       "IMEKRCIC"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\fnconfig.cpp ===
//
// fnconfig.cpp
//

#include "private.h"
#include "fnconfig.h"
#include "funcprv.h"
#include "config.h"
#include "globals.h"
#include "helpers.h"
#include "userex.h"
#include "resource.h"
#include "immxutil.h"

//////////////////////////////////////////////////////////////////////////////
//
// CFnConfigure
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnConfigure::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfFnConfigure))
        *ppvObj = SAFECAST(this, CFnConfigure *);

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnConfigure::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDAPI_(ULONG) CFnConfigure::Release()
{
    long cr;

    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);

    if (cr == 0)
        delete this;

    return cr;
}


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnConfigure::CFnConfigure(CFunctionProvider *pFuncPrv)
{
    m_pFuncPrv = pFuncPrv;
    m_pFuncPrv->AddRef();
    m_cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnConfigure::~CFnConfigure()
{
    SafeRelease(m_pFuncPrv);
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnConfigure::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Microsoft Korean Keyboard Input Configure");
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CFnConfigure::Show(HWND hwnd, LANGID langid, REFGUID rguidProfile)
{
    if (ConfigDLG(hwnd))
        return S_OK;
    else
        return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CFnConfigure::Show(HWND hwnd, LANGID langid, REFGUID rguidProfile, BSTR bstrRegistered)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnShowHelp
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnShowHelp::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnShowHelp))
    {
        *ppvObj = SAFECAST(this, CFnShowHelp *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnShowHelp::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDAPI_(ULONG) CFnShowHelp::Release()
{
    long cr;

    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnShowHelp::CFnShowHelp(CFunctionProvider *pFuncPrv)
{
    m_pFuncPrv = pFuncPrv;
    m_pFuncPrv->AddRef();
    m_cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnShowHelp::~CFnShowHelp()
{
    SafeRelease(m_pFuncPrv);
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnShowHelp::GetDisplayName(BSTR *pbstrName)
{
    WCHAR  szText[MAX_PATH];

    // Load Help display name
    LoadStringExW(g_hInst, IDS_HELP_DISPLAYNAME, szText, sizeof(szText)/sizeof(WCHAR));

    *pbstrName = SysAllocString(szText);
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CFnShowHelp::Show(HWND hwnd)
{
    CHAR szHelpFileName[MAX_PATH];
    CHAR szHelpCmd[MAX_PATH];
    CHAR c_szHHEXE[] = "hh.exe";
    
    // Load Help display name
    LoadStringExA(g_hInst, IDS_HELP_FILENAME, szHelpFileName, sizeof(szHelpFileName)/sizeof(CHAR));

    StringCchCopyA(szHelpCmd, ARRAYSIZE(szHelpCmd), c_szHHEXE);
    StringCchCatA(szHelpCmd, ARRAYSIZE(szHelpCmd), " ");
    StringCchCatA(szHelpCmd, ARRAYSIZE(szHelpCmd), szHelpFileName);
    FullPathExec(c_szHHEXE, szHelpCmd, SW_SHOWNORMAL, TRUE);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\fmode.h ===
//
// FMODE.H
//

#if !defined (__FMODE_H__INCLUDED_)
#define __FMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class FMode : public CCicButton
{
public:
    FMode(CToolBar *ptb);
    ~FMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
//    HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:
    
	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __FMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\editssn.cpp ===
//
// editssn.cpp
//
// CEditSession2
//
#include "private.h"
#include "korimx.h"
#include "editssn.h"
#include "helpers.h"

#define SafeAddRef(x)        { if ((x)) { (x)->AddRef(); } }


/*   C  E D I T  S E S S I O N 2   */
/*------------------------------------------------------------------------------

    Constructor

------------------------------------------------------------------------------*/
CEditSession2::CEditSession2(ITfContext *pic, CKorIMX *ptip, ESSTRUCT *pess, PFNESCALLBACK pfnCallback)
{
    Assert(pic  != NULL);
    Assert(ptip != NULL);
    Assert(pess != NULL);

    m_cRef        = 1;
    m_pic         = pic;
    m_ptip        = ptip;
    m_ess         = *pess;
    m_pfnCallback = pfnCallback;

    // add reference count in the struct
    SafeAddRef(m_pic);
    SafeAddRef(m_ptip);
    SafeAddRef(m_ess.ptim);
    SafeAddRef(m_ess.pRange);
    SafeAddRef(m_ess.pEnumRange);
    SafeAddRef(m_ess.pCandList);
    SafeAddRef(m_ess.pCandStr);
}


/*   ~  C  E D I T  S E S S I O N 2   */
/*------------------------------------------------------------------------------

    Destructor

------------------------------------------------------------------------------*/
CEditSession2::~CEditSession2( void )
{
    SafeRelease(m_pic);
    SafeRelease(m_ptip);
    SafeRelease(m_ess.ptim);
    SafeRelease(m_ess.pRange);
    SafeRelease(m_ess.pEnumRange);
    SafeRelease(m_ess.pCandList);
    SafeRelease(m_ess.pCandStr);
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

    Query interface of object
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CEditSession2::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID(riid, IID_ITfEditSession)) 
        *ppvObj = SAFECAST(this, ITfEditSession*);

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

    Add reference count
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CEditSession2::AddRef()
{
    return ++m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

    Release object
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CEditSession2::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
        delete this;

    return cr;
}


/*   E D I T  S E S S I O N   */
/*------------------------------------------------------------------------------

    Callback function of edit session
    (ITfEditSession method)

------------------------------------------------------------------------------*/
STDAPI CEditSession2::DoEditSession(TfEditCookie ec)
{
    return m_pfnCallback(ec, this);
}


/*   I N V O K E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CEditSession2::Invoke(DWORD dwFlag, HRESULT *phrSession)
{
    HRESULT hr;
    DWORD dwFlagES = 0;

    if ((m_pic == NULL) || (m_ptip == NULL))
        return E_FAIL;

    // read/readwrite flag

    switch (dwFlag & ES2_READWRITEMASK)
        {
    default:
    case ES2_READONLY: 
        dwFlagES |= TF_ES_READ;
        break;

    case ES2_READWRITE:
        dwFlagES |= TF_ES_READWRITE;
        break;
        }

    // sync/async flag

    switch (dwFlag & ES2_SYNCMASK)
        {
    default:
        Assert(fFalse);
    // fall through

    case ES2_ASYNC:
        dwFlagES |= TF_ES_ASYNC;
        break;

    case ES2_SYNC:
        dwFlagES |= TF_ES_SYNC;
        break;

    case ES2_SYNCASYNC:
        dwFlagES |= TF_ES_ASYNCDONTCARE;
        break;
        }

    // invoke

    m_fProcessed = FALSE;
    hr = m_pic->RequestEditSession(m_ptip->GetTID(), this, dwFlagES, phrSession);

    // try ASYNC session when SYNC session failed

    // NOTE: KOJIW:
    // How can we know if the edit session has been processed synchronously?

    // Satori#2409 - do not invoke callback twice
    //    if (!m_fProcessed && ((dwFlag & ES2_SYNCMASK) == ES2_SYNCASYNC)) { 
    //        hr = m_pic->EditSession( m_ptip->GetTID(), this, (dwFlagES & ~TF_ES_SYNC), phrSession );
    //    }

return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\editssn.h ===
//
// editssn.h
//
// CEditSession2
//

#ifndef EDITSES_H
#define EDITSES_H

class CKorIMX;
class CEditSession2;


//
// structure
//

typedef struct _ESSTRUCT
{
	DWORD				id;
	ITfThreadMgr		*ptim;
	ITfRange			*pRange;
	IEnumTfRanges		*pEnumRange;
	CCandidateListEx	*pCandList;
	CCandidateStringEx	*pCandStr;
	VOID				*pv1;
	VOID				*pv2;
	WPARAM				wParam;
	LPARAM				lParam;
	BOOL				fBool;
} ESSTRUCT;


//
// flags
//

/* read/readwrite flag */
#define ES2_READONLY			0x00000000
#define ES2_READWRITE			0x00000001

/* sync/async flag */
#define ES2_ASYNC				0x00000010
#define ES2_SYNC				0x00000020
#define ES2_SYNCASYNC			0x00000030

/* mask bits */
#define ES2_READWRITEMASK		0x0000000F
#define ES2_SYNCMASK			0x000000F0


//
// callback function
// 

typedef HRESULT (*PFNESCALLBACK)( TfEditCookie ec, CEditSession2 *pes );


//
// misc function
//

__inline void ESStructInit( ESSTRUCT *pess, DWORD id )
{
	ZeroMemory(pess, sizeof(ESSTRUCT));
	pess->id = id;
}


//
// CEditSession2
//

class CEditSession2 : public ITfEditSession
{
public:
	CEditSession2(ITfContext *pic, CKorIMX *ptip, ESSTRUCT *pess, PFNESCALLBACK pfnCallback);
	virtual ~CEditSession2();

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//
	// ITfEditSession
	//
	STDMETHODIMP DoEditSession(TfEditCookie ec);

	//
	//
	//
	HRESULT Invoke(DWORD dwFlag, HRESULT *phrSession);

	__inline ITfContext *GetContext()
	{
		return m_pic;
	}

	__inline CKorIMX *GetTIP()
	{
		return m_ptip;
	}

	__inline ESSTRUCT *GetStruct()
	{
		return &m_ess;
	}

	__inline void Processed() 
	{ 
		m_fProcessed = TRUE; 
	}

private:
	ULONG			m_cRef;
	ITfContext		*m_pic;
	CKorIMX			*m_ptip;
	ESSTRUCT		m_ess;
	PFNESCALLBACK	m_pfnCallback;

	BOOL			m_fProcessed;
};

#endif // EDITSES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\fmode.cpp ===
/****************************************************************************
   FMODE.CPP : FMode class implementation which manage Full/Half shape mode 
                   button on the Cicero Toolbar

   History:
      23-FEB-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "fmode.h"
#include "userex.h"
#include "resource.h"

// {D96498AF-0E46-446e-8F00-E113236FD22D}
const GUID GUID_LBI_KORIMX_FMODE = 
{   
    0xd96498af, 
    0x0e46, 
    0x446e, 
    { 0x8f, 0x0, 0xe1, 0x13, 0x23, 0x6f, 0xd2, 0x2d }
};

/*---------------------------------------------------------------------------
    FMode::FMode
---------------------------------------------------------------------------*/
FMode::FMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    // Set Add/Remove and tootip text
    LoadStringExW(g_hInst, IDS_TT_JUN_BAN, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_KorIMX, 
                GUID_LBI_KORIMX_FMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_HIDDENBYDEFAULT | TF_LBI_STYLE_TEXTCOLORICON,
                110, 
                szText);
    SetToolTip(szText);

    // Set button text
    LoadStringExW(g_hInst, IDS_BUTTON_JUN_BAN, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}

/*---------------------------------------------------------------------------
    FMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) FMode::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    FMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI FMode::GetIcon(HICON *phIcon)
{
    DWORD dwCM = GetCMode();
    UINT uiIcon = 0;
    static const UINT uidIcons[2][2] = 
    {
        { IDI_CMODE_BANJA, IDI_CMODE_BANJAW },
        { IDI_CMODE_JUNJA,  IDI_CMODE_JUNJAW }
    };

    if (m_pTb->IsOn() && (m_pTb->GetConversionMode() & TIP_JUNJA_MODE))
        uiIcon = 1;

    if (IsHighContrastBlack())
        uiIcon = uidIcons[uiIcon][1];
    else
        uiIcon = uidIcons[uiIcon][0];

    *phIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    FMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI FMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    FMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI FMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT FMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    DWORD dwConvMode;

    dwConvMode = GetCMode();

    // Toggle Full/Half mode
    if (dwConvMode & TIP_JUNJA_MODE)
        dwConvMode &= ~TIP_JUNJA_MODE;
    else
        dwConvMode |= TIP_JUNJA_MODE;

    SetCMode(dwConvMode);
    
    return S_OK;
}


#if 0
//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT FMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    HMENU hMenu;
    DWORD dwConvMode;
    CHAR  szText[256];
    UINT  uiId;
    int   nRet;

    hMenu = CreatePopupMenu();

    dwConvMode = GetCMode();
    if (dwConvMode & TIP_JUNJA_MODE)
        uiId = IDS_BANJA_MODE;
    else
        uiId = IDS_JUNJA_MODE;

    // Add Hangul/English mode menu
    LoadStringExA(g_hInst, uiId, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 1, szText);

    // Add Cancel menu
    LoadStringExA(g_hInst, IDS_CANCEL, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 0, szText);

    nRet = TrackPopupMenuEx(hMenu, 
                         TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                         pt.x, pt.y, m_pTb->GetOwnerWnd(), NULL);

    switch (nRet)
        {
    case 1: 
        dwConvMode = GetCMode();

        // Toggle Full/Half mode
        if (dwConvMode & TIP_JUNJA_MODE)
            dwConvMode &= ~TIP_JUNJA_MODE;
        else
            dwConvMode |= TIP_JUNJA_MODE;

        SetCMode(dwConvMode);
        break;
        }

    DestroyMenu(hMenu);

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\fnconfig.h ===
//
// config.h
//

#ifndef FNCONFIG_H
#define FNCONFIG_H

#include "private.h"
#include "ctffunc.h"

class CFunctionProvider;

//////////////////////////////////////////////////////////////////////////////
//
// CFnConfigure
//
//////////////////////////////////////////////////////////////////////////////

class CFnConfigure : public ITfFnConfigure,
                     public ITfFnConfigureRegisterWord
{
public:
    CFnConfigure(CFunctionProvider *pFuncPrv);
    ~CFnConfigure();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnConfigure
    //
    STDMETHODIMP Show(HWND hwnd, LANGID langid, REFGUID rguidProfile);

    //
    // ITfFnConfigureRegisterWord
    //
    STDMETHODIMP Show(HWND hwnd, LANGID langid, REFGUID rguidProfile, BSTR bstrRegistered);
    
private:
    CFunctionProvider *m_pFuncPrv;

    LONG m_cRef;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnShowHelp
//
//////////////////////////////////////////////////////////////////////////////

class CFnShowHelp : public ITfFnShowHelp
{
public:
    CFnShowHelp(CFunctionProvider *pFuncPrv);
    ~CFnShowHelp();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnShowHelp
    //
    STDMETHODIMP Show(HWND hwnd);

private:
    CFunctionProvider *m_pFuncPrv;

    LONG m_cRef;
};


#endif // FNCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\fnrecon.cpp ===
//
// reconv.cpp
//

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "candlstx.h"
#include "fnrecon.h"
#include "funcprv.h"
#include "helpers.h"
#include "immxutil.h"
#include "editcb.h"
#include "hanja.h"
#include "ucutil.h"

//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunction::CFunction(CFunctionProvider *pFuncPrv)
{
    _pFuncPrv = pFuncPrv;
    _pFuncPrv->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFunction::~CFunction()
{
    SafeRelease(_pFuncPrv);
}

#if 1

//+---------------------------------------------------------------------------
//
// CFunction::GetTarget
//
//----------------------------------------------------------------------------

HRESULT CFunction::GetTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp, WCHAR **ppszText, ULONG *pcch)
{
    ITfProperty*    pProp;
    ITfRange*       pRangeTmp = NULL;

    // init
    *pcch = 0;
    
    // AIMM?
    if (CKorIMX::GetAIMM(pic))
        {
        // Allocate just one char string buffer
        *ppszText = new WCHAR[2];
        Assert(*ppszText != NULL);
        if (*ppszText == NULL)
            return E_OUTOFMEMORY;

        pRange->Clone(&pRangeTmp);

        *pcch = 1;
        pRangeTmp->GetText(ec, 0, *ppszText, sizeof(WCHAR), pcch);
        *((*ppszText) + 1) = L'\0';

        *ppRangeTmp = pRangeTmp;
        return S_OK;
        }

    // if reading prop exist.
    if (SUCCEEDED(pic->GetProperty(GUID_PROP_READING, &pProp)))
        {
        ITfRange *pPropRange;
        HRESULT hr = pProp->FindRange(ec, pRange, &pPropRange, TF_ANCHOR_START);
        
        if (SUCCEEDED(hr) && pPropRange)
            {
            BSTR bstr;

            if (SUCCEEDED(GetBSTRPropertyData(ec, pProp, pPropRange, &bstr)))
                {
                pPropRange->Clone(&pRangeTmp);
                if (bAdjust || CompareRanges(ec, pRange, pRangeTmp) == CR_EQUAL)
                    {
                    *pcch = SysStringLen(bstr);
                    *ppszText = new WCHAR[*pcch + 1];
                    if (*ppszText)
                        StringCchCopyW(*ppszText, *pcch + 1, bstr);
                    }
                }
            SysFreeString(bstr);
            pPropRange->Release();
            }
        pProp->Release();
        }

    // If no reading property
    if (!(*ppszText))
        {
        LONG cch;
        BOOL fEmpty;

        pRange->IsEmpty(ec, &fEmpty);
        
        pRange->Clone(&pRangeTmp);
        // Select only one char
        if (!fEmpty)
            {
            pRangeTmp->Collapse(ec, TF_ANCHOR_START);
            pRangeTmp->ShiftEnd(ec, 1, &cch, NULL);
            }
        else
            {
            pRangeTmp->ShiftEnd(ec, 1, &cch, NULL);
            if (cch==0)
                pRangeTmp->ShiftStart(ec, -1, &cch, NULL);
            }
            
        Assert(cch != 0);
        
        if (cch)
            {
            // Allocate just one char string buffer
            *ppszText = new WCHAR[2];
            Assert(*ppszText != NULL);
            if (*ppszText == NULL)
                return E_OUTOFMEMORY;
            
            *pcch = 1;
            pRangeTmp->GetText(ec, 0, *ppszText, sizeof(WCHAR), pcch);
            *((*ppszText) + 1) = L'\0';

            // Office #154974
            // If there is any embedded char exist, skip it forward.
            while (**ppszText == TS_CHAR_EMBEDDED)
                {
                pRangeTmp->ShiftStart(ec, 1, &cch, NULL);
                if (cch == 0)
                    break;
                pRangeTmp->ShiftEnd(ec, 1, &cch, NULL);
                if (cch == 0)
                    break;

                *pcch = 1;
                pRangeTmp->GetText(ec, 0, *ppszText, sizeof(WCHAR), pcch);
                *((*ppszText) + 1) = L'\0';
                }
            }

        }

    *ppRangeTmp = pRangeTmp;

    return S_OK;
}
#else
//+---------------------------------------------------------------------------
//
// CFunction::GetTarget
//
//----------------------------------------------------------------------------

HRESULT CFunction::GetTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp, WCHAR **ppszText, ULONG *pcch)
{
    ITfRange *pRangeTmp = NULL;
    LONG  cch;
    BOOL fEmpty;

    *pcch = 0;
    pRange->IsEmpty(ec, &fEmpty);
    
    if (!fEmpty)
        {
        pRange->Clone(&pRangeTmp);
        pRangeTmp->Collapse(ec, TF_ANCHOR_START);
        pRangeTmp->ShiftEnd(ec, 1, &cch, NULL);
        if (cch)
            {
            *ppszText = new WCHAR[2];
            *pcch = 1;
            pRangeTmp->GetText(ec, 0, *ppszText, sizeof(WCHAR), pcch);
            *((*ppszText) + 1) = L'\0';
            }
        }
    else
        {
        pRange->Clone(&pRangeTmp);
        pRangeTmp->ShiftEnd(ec, 1, &cch, NULL);
        if (cch)
            {
            *ppszText = new WCHAR[2];
            *pcch = 1;
            pRangeTmp->GetText(ec, 0, *ppszText, sizeof(WCHAR), pcch);
            *((*ppszText) + 1) = L'\0';
            }
        }
        
    *ppRangeTmp = pRangeTmp;
    
    return S_OK;
}
#endif

//+---------------------------------------------------------------------------
//
// CFunction::GetFocusedTarget
//
//----------------------------------------------------------------------------

BOOL CFunction::GetFocusedTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp)
{
    ITfRange *pRangeTmp = NULL;
    ITfRange *pRangeTmp2 = NULL;
    IEnumTfRanges *pEnumTrack = NULL;
    ITfRange *pPropRange;
    ITfReadOnlyProperty *pProp = NULL;
    BOOL bRet = FALSE;
    BOOL fWholeDoc = FALSE;

    if (!pRange)
    {
        fWholeDoc = TRUE;

        if (FAILED(GetRangeForWholeDoc(ec, pic, &pRange)))
            return FALSE;
    }

    if (bAdjust)
    {
        //
        // multi owner and PF_FOCUS range support.
        //

        if (FAILED(AdjustRangeByTextOwner(ec, pic,
                                          pRange, 
                                          &pRangeTmp2,
                                          CLSID_KorIMX))) 
            goto Exit;

        GUID rgGuid[1]; 
        rgGuid[0] = GUID_ATTR_KORIMX_INPUT;

        if (FAILED(AdjustRangeByAttribute(_pFuncPrv->_pime->_GetLibTLS(), 
                                          ec, pic,
                                          pRangeTmp2, 
                                          &pRangeTmp,
                                          rgGuid, 1))) 
            goto Exit;
    }
    else
    {
        pRange->Clone(&pRangeTmp);
    }

    //
    // check if there is an intersection of PF_FOCUS range and owned range.
    // if there is no such range, we return FALSE.
    //
    if (FAILED(EnumTrackTextAndFocus(ec, pic, pRangeTmp, &pProp, &pEnumTrack)))
        goto Exit;

    while(pEnumTrack->Next(1, &pPropRange,  0) == S_OK)
    {
        if (IsOwnerAndFocus(_pFuncPrv->_pime->_GetLibTLS(), ec, CLSID_KorIMX, pProp, pPropRange))
            bRet = TRUE;

        pPropRange->Release();
    }
    pProp->Release();

    if (bRet)
    {
        *ppRangeTmp = pRangeTmp;
        (*ppRangeTmp)->AddRef();
    }

Exit:
    SafeRelease(pEnumTrack);
    SafeRelease(pRangeTmp);
    SafeRelease(pRangeTmp2);
    if (fWholeDoc)
        pRange->Release();
    return bRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnReconversion
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::QueryInterface(REFIID riid, void **ppvObj)
{
#if NEVER
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnReconversion))
    {
        *ppvObj = SAFECAST(this, CFnReconversion *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }
#endif 
    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnReconversion::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFnReconversion::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnReconversion::CFnReconversion(CKorIMX *pKorImx, CFunctionProvider *pFuncPrv) : CFunction(pFuncPrv)
{
    m_pKorImx = pKorImx;
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnReconversion::~CFnReconversion()
{
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Hanja Conv");
    return S_OK;
}
//+---------------------------------------------------------------------------
//
// CFnReconversion::IsEnabled
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::IsEnabled(BOOL *pfEnable)
{
    *pfEnable = TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::QueryRange
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfConvertable)
{
    CEditSession2 *pes;
    ITfContext    *pic;
    ESSTRUCT       ess;
    HRESULT       hr = E_OUTOFMEMORY;

    if (!pRange || !ppNewRange || !pfConvertable)
        return E_INVALIDARG;

    if (FAILED(pRange->GetContext(&pic)))
        goto Exit;

    ESStructInit(&ess, ESCB_RECONV_QUERYRECONV);
    
    ess.pRange = pRange;
    ess.pv1    = this;
    ess.pv2    = ppNewRange;

    if ((pes = new CEditSession2(pic, m_pKorImx, &ess, CKorIMX::_EditSessionCallback2)) != NULL)
        {
        pes->Invoke(ES2_READONLY | ES2_SYNC, &hr);
        pes->Release();
        }

    *pfConvertable = (hr == S_OK);
    if (hr == S_FALSE)
        hr = S_OK;
 
    pic->Release();

Exit:

    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::_QueryRange
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::_QueryRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppNewRange)
{
    ULONG cch = 0;
    WCHAR *pszText = NULL;
    HRESULT hr = E_FAIL;
    ITfRange *pRangeTmp = NULL;

    //
    // KIMX doesn't support entire document reconversion.
    //
    if (!pRange)
        return hr;

    GetTarget(ec, pic, pRange, ppNewRange ? TRUE : FALSE, &pRangeTmp, &pszText, &cch);

    if (cch)
    {
        if (ppNewRange)
            pRangeTmp->Clone(ppNewRange);

        hr = S_OK;

        // In case of AIMM we should return error if the input char can't be coverted.
        if (CKorIMX::GetAIMM(pic))
            {
            HANJA_CAND_STRING_LIST     CandStrList;
            if (GetConversionList(*pszText, &CandStrList))
                {
                // free buffer and return
                cicMemFree(CandStrList.pwsz);
                cicMemFree(CandStrList.pHanjaString);
                }
            else
                hr = S_FALSE;
            }
    }
    else
        hr = S_FALSE;
    
    if (pszText)
        delete pszText;

    SafeRelease(pRangeTmp);
    return hr;
}


//+---------------------------------------------------------------------------
//
// CFnReconversion::GetReconversion
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList)
{
    ITfContext *pic;
    CCandidateListEx *pCandList;
    HRESULT hr;

    if (!pRange || !ppCandList)
        return E_INVALIDARG;

    if (FAILED(pRange->GetContext(&pic)))
        return E_FAIL;

    hr = GetReconversionProc(pic, pRange, &pCandList, fFalse);
    
    if (pCandList != NULL)
        {
        pCandList->QueryInterface( IID_ITfCandidateList, (void**)ppCandList );
        pCandList->Release();
        }
    
    pic->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::_GetReconversion
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::_GetReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, CCandidateListEx **ppCandList, BOOL fSelection)
{
    ULONG cch = 0;
    WCHAR *pszReading = NULL;
    HRESULT hr = E_FAIL;
    ITfRange *pRangeTmp = NULL;
    CCandidateStringEx *pCandExtraStr;
    
    GetTarget(ec, pic, pRange, TRUE, &pRangeTmp, &pszReading, &cch);

    if (cch)
        {
        CCandidateListEx          *pCandList;
        HANJA_CAND_STRING_LIST     CandStrList;
        WCHAR                       szCand[2];
        WCHAR                    wch = 0;
        ULONG                    cch;
        
        // build candidate list
        pCandList = new CCandidateListEx(SetResult, pic, pRangeTmp);
        Assert(pCandList != NULL);
        if (pCandList == NULL)
            return E_OUTOFMEMORY;

        // Copy reading string
        StringCchCopyW(_szReading, ARRAYSIZE(_szReading), pszReading);

        // Get conv list from Hanja dict
        if (GetConversionList(*pszReading, &CandStrList))
            {
            // If AIMM, don't select coversion char.
            if (!CKorIMX::GetAIMM(pic))
                {
                // If there candidate exist, Set selection converting char
                if (fSelection)
                    SetSelectionSimple(ec, pic, pRangeTmp);

                // if it is Hanja already converted, Add Hangul pronoun as extra cand str.
                pRangeTmp->GetText(ec, 0, &wch, sizeof(WCHAR), &cch);

                if (cch && !fIsHangul(wch))
                    {
                    pCandList->AddExtraString(pszReading, MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), NULL, this, &pCandExtraStr);
                    pCandExtraStr->Release();
                    }
                }

            for (UINT i=0; i<CandStrList.csz; i++)
                {
                //LANGID langid = GetLangIdFromCand(pszReading, pchCand);
                CCandidateStringEx *pCandStr;
                 
                szCand[0] = CandStrList.pHanjaString[i].wchHanja;
                szCand[1] = L'\0';
                pCandList->AddString(szCand,
                                       MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), 
                                       NULL, this, &pCandStr);

                pCandStr->SetInlineComment(CandStrList.pHanjaString[i].wzMeaning);
                pCandStr->m_bHanjaCat = CandStrList.pHanjaString[i].bHanjaCat;
                pCandStr->SetReadingString(_szReading);

                pCandStr->Release();
                }
            // free buffer and return
            cicMemFree(CandStrList.pwsz);
            cicMemFree(CandStrList.pHanjaString);
            *ppCandList = pCandList;

            hr = S_OK;
            }
        }

    if (pszReading)
        delete pszReading;

    SafeRelease(pRangeTmp);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::Reconvert
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::Reconvert(ITfRange *pRange)
{
    CCandidateListEx *pCandList = NULL;
    ITfRange   *pRangeTmp = NULL;
    ITfContext *pic;
    HRESULT hr;

    if (!pRange)
        return E_INVALIDARG;

    hr = E_FAIL;

    if (FAILED(pRange->Clone(&pRangeTmp)))
        goto Exit;

    if (FAILED(pRange->GetContext(&pic)))
        goto Exit;

    if (SUCCEEDED(hr = GetReconversionProc(pic, pRange, &pCandList, fTrue))) 
        {
        hr = ShowCandidateList(pic, pRange, pCandList);
        SafeRelease(pCandList);
        }

    SafeRelease(pRangeTmp);
    SafeRelease(pic);

Exit:
    return hr;
}




/*   G E T  R E C O N V E R S I O N  P R O C   */
/*------------------------------------------------------------------------------

    Get candidate list of reconversion 

------------------------------------------------------------------------------*/
HRESULT CFnReconversion::GetReconversionProc(ITfContext *pic, ITfRange *pRange, CCandidateListEx **ppCandList, BOOL fSelection)
{
    CEditSession2 *pes;
    ESSTRUCT        ess;
    HRESULT        hr;

    if (!ppCandList)
        return E_INVALIDARG;

    *ppCandList = NULL;

    ESStructInit(&ess, ESCB_RECONV_GETRECONV);
    ess.pRange    = pRange;
    ess.pv1       = this;
    ess.pv2       = ppCandList;
    ess.fBool      = fSelection;

    hr = E_OUTOFMEMORY;
    
    if ((pes = new CEditSession2(pic, m_pKorImx, &ess, CKorIMX::_EditSessionCallback2)))
        {
        if (fSelection)
            pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
        else
            pes->Invoke(ES2_READONLY | ES2_SYNC, &hr);
        
        pes->Release();
        }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::ShowCandidateList
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::ShowCandidateList(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList)
{
    CEditSession2 *pes;
    ESSTRUCT        ess;
    HRESULT        hr;

    hr = E_OUTOFMEMORY;

    ESStructInit(&ess, ESCB_RECONV_SHOWCAND);
    ess.pRange    = pRange;
    ess.pv1       = this;
    ess.pCandList = pCandList;

    if ((pes = new CEditSession2(pic, m_pKorImx, &ess, CKorIMX::_EditSessionCallback2)))
        {
        pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
        pes->Release();
        }
        
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::SetResult 
// (Static function)
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::SetResult(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList, CCandidateStringEx *pCand, TfCandidateResult imcr)
{
    CEditSession2   *pes;
    ESSTRUCT         ess;
    CFnReconversion *pReconv = (CFnReconversion *)(pCand->m_punk);
    ITfRange        *pRangeTmp;
    HRESULT         hr;

    hr = E_OUTOFMEMORY;
    
    if (SUCCEEDED(pRange->Clone(&pRangeTmp)))
        {
        if (imcr == CAND_FINALIZED)
            {
            ESStructInit(&ess, ESCB_FINALIZERECONVERSION);
            ess.pCandList = pCandList;
            ess.pCandStr  = pCand;
            //pCandList->AddRef();        // be released in edit session callback
            //pCand->AddRef();
            }
        else
        if (imcr == CAND_SELECTED)
            ESStructInit(&ess, ESCB_ONSELECTRECONVERSION);
        else 
        if (imcr == CAND_CANCELED)
            ESStructInit(&ess, ESCB_ONCANCELRECONVERSION);

        // Save useful parameters
        ess.pv1       = pReconv;
        ess.lParam       = pReconv->_pFuncPrv->_pime->GetTID();
        ess.pRange       = pRangeTmp;

        if ((pes = new CEditSession2(pic, pReconv->m_pKorImx, &ess, CKorIMX::_EditSessionCallback2)))
            {
            pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
            pes->Release();
            }
        // Call back function must release pRangeTmp
        // pRangeTmp->Release();
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\funcprv.h ===
//
//   funcprv.h : CFunctionProvider class declaration
//
//   History:
//      15-NOV-1999 CSLim Created

#if !defined (__FUNCPRV_H__INCLUDED_)
#define __FUNCPRV_H__INCLUDED_

#include "private.h"
#include "fnprbase.h"

class CKorIMX;

class CFunctionProvider :  public CFunctionProviderBase
{
public:
    CFunctionProvider(CKorIMX *pime);

    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

    CKorIMX *_pime;
};

#endif // __FUNCPRV_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\fnrecon.h ===
//
// fnrecon.h
//

#ifndef FNRECON_H
#define FNRECON_H

#include "private.h"
#include "candlstx.h"

class CFunctionProvider;

//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

class CFunction
{
public:
    CFunction(CFunctionProvider *pFuncPrv);
    ~CFunction();

protected:
    HRESULT GetTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp, WCHAR **ppszText, ULONG *pcch);
    BOOL GetFocusedTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp);

friend CKorIMX;
    CFunctionProvider *_pFuncPrv;
};


//////////////////////////////////////////////////////////////////////////////
//
// CFnRecovnersion
//
//////////////////////////////////////////////////////////////////////////////

// !!! WARNING !!! 
// This is temp code should be removed in the future
#define MAXREADING 256

class CFnReconversion : public ITfFnReconversion,
                        public CFunction
{
public:
    CFnReconversion(CKorIMX* pKorImx, CFunctionProvider *pFuncPrv);
    ~CFnReconversion();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);
    STDMETHODIMP IsEnabled(BOOL *pfEnable);

    //
    // ITfFnReconversion
    //
    STDMETHODIMP QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfConvertable);
	STDMETHODIMP GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList);
    STDMETHODIMP Reconvert(ITfRange *pRange);

    static HRESULT SetResult(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList, CCandidateStringEx *pCand, TfCandidateResult imcr);

	HRESULT _QueryRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppNewRange);
	HRESULT _GetReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, CCandidateListEx **ppCandList, BOOL fSelection);

private:
	HRESULT GetReconversionProc( ITfContext *pic, ITfRange *pRange, CCandidateListEx **ppCandList, BOOL fSelection);
    HRESULT ShowCandidateList(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList);
//    static HRESULT _EditSessionCallback2(TfEditCookie ec, CEditSession2 *pes);

    WCHAR _szReading[MAXREADING];
    CKorIMX* m_pKorImx;
    long _cRef;
};

#endif // FNRECON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\gdata.h ===
/****************************************************************************
	GDATA.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Instance data and Shared memory data management functions

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_GDATA_H__INCLUDED_)
#define _GDATA_H__INCLUDED_


class CIMEData;

extern BOOL InitSharedData();
VOID InitImeData(CIMEData& ImeData);
extern BOOL CloseSharedMemory();

#define IMEDATA_MAGIC_NUMBER 		0x12345678	// This will repesent whether IMEDATA initialized or not

// Type of IME Hangul keyboard layout
enum _KeyBoardType 
{ 
	KL_2BEOLSIK = 0, KL_3BEOLSIK_390 = 1, KL_3BEOLSIK_FINAL = 2
};

#define NUM_OF_IME_KL			3



///////////////////////////////////////////////////////////////////////////////
// UI Decls
enum StatusButtonTypes 
{ 
	HAN_ENG_TOGGLE_BUTTON, 
	JUNJA_BANJA_TOGGLE_BUTTON, 
	HANJA_CONV_BUTTON,
	IME_PAD_BUTTON,
	NULL_BUTTON = 0xFF
};

#define MAX_NUM_OF_STATUS_BUTTONS	4

// Button status
#define BTNSTATE_NORMAL		0	// normal
#define BTNSTATE_ONMOUSE	1	// mouse cursor on the button
#define BTNSTATE_PUSHED		2	// pushed
#define BTNSTATE_DOWN		4	// pushed
#define BTNSTATE_HANJACONV  8	// If hanja conv mode, button always pushed

// Button size
#define BTN_SMALL			0
#define BTN_MIDDLE			1
#define BTN_LARGE			2

struct StatusButton 
{
	StatusButtonTypes m_ButtonType;
	WORD	m_BmpNormalID, m_BmpOnMouseID, m_BmpPushedID, m_BmpDownOnMouseID;
	WORD	m_ToolTipStrID;
	INT		m_uiButtonState;
	BOOL	m_fEnable;
};


///////////////////////////////////////////////////////////////////////////////
// Global data  S H A R E D  to all IME instance
struct IMEDATA 
    {
    ULONG		ulMagic;

	// Workarea
	RECT		rcWorkArea;
	
	// Configuration of the IME: TIP uses following data to share user setting.
	UINT		uiCurrentKeylayout;
	BOOL		fJasoDel;		// Backspace : delete per jaso or char
								// which means All ISO-10646 hangul.
	BOOL		fKSC5657Hanja;	// K1(KSC-5657) Hanja enable
	BOOL		fCandUnicodeTT;

	// Status window data: Not used by TIP
	UINT		uNumOfButtons;
	INT			iCurButtonSize;

    INT         xStatusWi;      // width of status window
    INT         yStatusHi;      // high of status window

	LONG		xStatusRel, yStatusRel;

	INT			xButtonWi;
	INT			yButtonHi;
	INT			cxStatLeftMargin, cxStatRightMargin,
				cyStatMargin, cyStatButton;
	RECT		rcButtonArea;
	POINT       ptStatusPos;

	// Candidate window
    INT         xCandWi;
    INT         yCandHi;

	// Comp window pos
	POINT       ptCompPos;

	// This should be last - ia64 alignment issue
	StatusButton StatusButtons[MAX_NUM_OF_STATUS_BUTTONS];
};

typedef IMEDATA	*LPIMEDATA;

/////////////////////////////////////////////////////////////////////////////
// Class CIMEData
//
// Purpose : Shared memory handling across process boundary.
//           This use MapViewOfFile() to mapping local process memory and Unlock 
//           automatically when reference count become zero
// Note    : Currently Read only flag behaves same as R/W flag.
class CIMEData
    {
    public:
        enum LockType { SMReadOnly, SMReadWrite };
       
        CIMEData(LockType lockType=SMReadWrite);
        ~CIMEData() { UnlockSharedMemory(); }

        static BOOL InitSharedData();
        static BOOL CloseSharedMemory();

		void InitImeData();

        LPIMEDATA LockROSharedData();
        LPIMEDATA LockRWSharedData();
        BOOL UnlockSharedMemory();
        LPIMEDATA operator->() { Assert(m_pImedata != 0); return m_pImedata; }
        LPIMEDATA GetGDataRaw() { Assert(m_pImedata != 0); return m_pImedata; }
        UINT GetCurrentBeolsik() { return m_pImedata->uiCurrentKeylayout; }
		VOID SetCurrentBeolsik(UINT icurBeolsik);		
		BOOL GetJasoDel() { return m_pImedata->fJasoDel; }
		VOID SetJasoDel(BOOL fJasoDel) { m_pImedata->fJasoDel = fJasoDel; }
		BOOL GetKSC5657Hanja() { return m_pImedata->fKSC5657Hanja; }
		VOID SetKSC5657Hanja(BOOL f5657) { m_pImedata->fKSC5657Hanja = f5657; }

		
    private:
        LPIMEDATA m_pImedata;
        static IMEDATA m_ImeDataDef;
        static HANDLE m_vhSharedData;
    };

inline
CIMEData::CIMEData(LockType lockType)
    {
    Assert(m_vhSharedData != 0);
    DebugMsg(DM_TRACE, TEXT("CIMEData(): Const"));
    m_pImedata = 0;
    LockRWSharedData();
    ZeroMemory(&m_ImeDataDef, sizeof(IMEDATA));
	// If failed to allocate or map shared memory, use static default data instead.
    if (m_pImedata == NULL)
        {
        m_pImedata = &m_ImeDataDef;
        return;
        }
    }

inline
LPIMEDATA CIMEData::LockROSharedData()
    {
    Assert(m_vhSharedData != 0);
    DebugMsg(DM_TRACE, TEXT("CIMEData::LockROSharedData()"));

    if (m_vhSharedData)
	    m_pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ, 0, 0, 0);
    Assert(m_pImedata != 0);
    return m_pImedata;
    }

inline    
LPIMEDATA CIMEData::LockRWSharedData()
    {
    Assert(m_vhSharedData != 0);
    DebugMsg(DM_TRACE, TEXT("CIMEData::LockRWSharedData()"));
    
    if (m_vhSharedData)
    	{
		DebugMsg(DM_TRACE, TEXT("CIMEData::LockRWSharedData(): m_vhSharedData is null call MapViewOfFile"));
	    m_pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
	    }
    Assert(m_pImedata != 0);
	return m_pImedata;
    }

// For unlocking shared memory
inline
BOOL CIMEData::UnlockSharedMemory()
    {
    DebugMsg(DM_TRACE, TEXT("CIMEData::UnlockSharedMemory(): Lock count zero UnmapViewOfFile"));
    if (m_pImedata != &m_ImeDataDef)
    	{
	    UnmapViewOfFile(m_pImedata);
    	}
	m_pImedata = 0;
	return fTrue;
    }

inline
VOID CIMEData::SetCurrentBeolsik(UINT uicurBeolsik) 
{ 
	Assert(uicurBeolsik<=KL_3BEOLSIK_FINAL);
	if (uicurBeolsik <= KL_3BEOLSIK_FINAL)
		m_pImedata->uiCurrentKeylayout = uicurBeolsik; 
}

#endif // _GDATA_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\focus.cpp ===
/****************************************************************************
   FOCUS.CPP : CKorIMX's Candidate UI member functions implementation
   
   History:
      08-FEB-2000 CSLim Created
****************************************************************************/
#include "private.h"
#include "korimx.h"
#include "immxutil.h"
#include "globals.h"

/*---------------------------------------------------------------------------
    CKorIMX::OnSetThreadFocus    (Called from Activate)
    
    This methods is called when the user switches focus between threads.  
    TIP should restore its ui (status windows, etc.) in this case.
---------------------------------------------------------------------------*/
STDAPI CKorIMX::OnSetThreadFocus()
{
    TraceMsg(TF_GENERAL, "ActivateUI: (%x) fActivate = %x, wnd thread = %x",
                GetCurrentThreadId(), TRUE, GetWindowThreadProcessId(GetOwnerWnd(), NULL));

    if (m_pCandUI != NULL)
        {
        ITfCandUICandWindow *pCandWindow;
        
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUICandWindow, (IUnknown**)&pCandWindow)))
            {
            pCandWindow->Show(fTrue);
            pCandWindow->Release();
            }
        }

    if (m_pToolBar)
        m_pToolBar->SetUIFocus(fTrue);

    if (IsSoftKbdEnabled())
        SoftKbdOnThreadFocusChange(fTrue);
        
    return S_OK;
}


/*---------------------------------------------------------------------------
    CKorIMX::OnKillThreadFocus   (Called from Deactivate)

    This methods is called when the user switches focus between threads.  
    TIP should hide its ui (status windows, etc.) in this case.
---------------------------------------------------------------------------*/
STDAPI CKorIMX::OnKillThreadFocus()
{
    TraceMsg(TF_GENERAL, "DeactivateUI: (%x) wnd thread = %x",
             GetCurrentThreadId(), GetWindowThreadProcessId(GetOwnerWnd(), NULL));

    if (m_pCandUI != NULL)
        {
        ITfCandUICandWindow *pCandWindow;
        
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUICandWindow, (IUnknown**)&pCandWindow)))
            {
            pCandWindow->Show(fFalse);
            pCandWindow->Release();
            }
        }

#if 0
    m_pStatusWnd->Show(FALSE);
#endif

    if (m_pToolBar)
        m_pToolBar->SetUIFocus(fFalse);

    if (IsSoftKbdEnabled())
        SoftKbdOnThreadFocusChange(fFalse);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\funcprv.cpp ===
/****************************************************************************
   funcprv.cpp : CFunctionProvider class implementation

   History:
      15-NOV-1999 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "funcprv.h"
#include "fnrecon.h"
#include "fnconfig.h"
#include "helpers.h"
#include "immxutil.h"


//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////


/*---------------------------------------------------------------------------
    CFunctionProvider::CFunctionProvider
    
    Ctor
---------------------------------------------------------------------------*/
CFunctionProvider::CFunctionProvider(CKorIMX *pime) : CFunctionProviderBase(pime->GetTID())
{
    Init(CLSID_KorIMX, L"Kor TFX");
    _pime = pime;
}

/*---------------------------------------------------------------------------
    CFunctionProvider::GetFunction
    
    Get Fuction object
---------------------------------------------------------------------------*/
STDAPI CFunctionProvider::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    *ppunk = NULL;

    if (!IsEqualIID(rguid, GUID_NULL))
        return E_NOINTERFACE;

    if (IsEqualIID(riid, IID_ITfFnReconversion))
    {
        // ITfFnReconversion is used for correction. Through this function, the 
        // applications can get the simple alternative lists or ask the function to show 
        // the alternative list UI.
        *ppunk = new CFnReconversion(_pime, this);
    }
    else if (IsEqualIID(riid, IID_ITfFnConfigure))
    {
        CFnConfigure *pconfig = new CFnConfigure(this);
        *ppunk = SAFECAST(pconfig, ITfFnConfigure *);
    }
    else if (IsEqualIID(riid, IID_ITfFnConfigureRegisterWord))
    {
        CFnConfigure *pconfig = new CFnConfigure(this);
        *ppunk = SAFECAST(pconfig, ITfFnConfigureRegisterWord *);
    }
    else if (IsEqualIID(riid, IID_ITfFnShowHelp))
    {
        CFnShowHelp *phelp = new CFnShowHelp(this);
        *ppunk = SAFECAST(phelp, ITfFnShowHelp *);
    }
    
    if (*ppunk)
        return S_OK;

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\globals.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       globals.cpp
//
//  Contents:   Global variables.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "ciccs.h"

HINSTANCE g_hInst = NULL;

CCicCriticalSectionStatic g_cs;

#ifdef DEBUG
// for tracking last owner of g_cs
const TCHAR *g_szMutexEnterFile = NULL;
int g_iMutexEnterLine = -1;
#endif // DEBUG


// {12E86EF3-4A16-46d6-A56C-3B887DB16E22}
extern const GUID GUID_ATTR_KORIMX_INPUT = 
{
    0x12e86ef3, 
    0x4a16, 
    0x46d6, 
    { 0xa5, 0x6c, 0x3b, 0x88, 0x7d, 0xb1, 0x6e, 0x22 } 
};

// {12A9B212-9463-49bb-85E0-D6CBF9A85F99}
extern const GUID GUID_IC_PRIVATE = 
{
    0x12a9b212, 
    0x9463, 
    0x49bb, 
    { 0x85, 0xe0, 0xd6, 0xcb, 0xf9, 0xa8, 0x5f, 0x99 } 
};

// {91656349-4BA9-4143-A1AE-7FBC20B631BC}
extern const GUID GUID_COMPARTMENT_KORIMX_CONVMODE = 
{ 
    0x91656349, 
    0x4ba9, 
    0x4143, 
    { 0xa1, 0xae, 0x7f, 0xbc, 0x20, 0xb6, 0x31, 0xbc } 
};

// {91656350-4BA9-4143-A1AE-7FBC20B631BC}
extern const GUID GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE = 
{ 
    0x91656350, 
    0x4ba9, 
    0x4143, 
    { 0xa1, 0xae, 0x7f, 0xbc, 0x20, 0xb6, 0x31, 0xbc } 
};

// {2232E454-03BA-482E-A0D4-5DCDD99DFF68}
extern const GUID GUID_KOREAN_HANGULSIMULATE =
{
    0x2232E454,
    0x03BA,
    0x482E,
    { 0xA0, 0xD4, 0x5D, 0xCD, 0xD9, 0x9D, 0xFF, 0x68 }
};

// {2232E455-03BA-482E-A0D4-5DCDD99DFF68}
extern const GUID GUID_KOREAN_HANJASIMULATE =
{
    0x2232E455,
    0x03BA,
    0x482E,
    { 0xA0, 0xD4, 0x5D, 0xCD, 0xD9, 0x9D, 0xFF, 0x68 }
};

// ac72b67f-d965-4b78-99fc-6547c2f62064 
extern const GUID GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT = 
{
    0xac72b67f,
    0xd965,
    0x4b78,
    {0x99, 0xfc, 0x65, 0x47, 0xc2, 0xf6, 0x20, 0x64}
};

// ac72b680-d965-4b78-99fc-6547c2f62064
extern const GUID GUID_COMPARTMENT_SOFTKBD_WNDPOSITION = 
{
    0xac72b680,
    0xd965,
    0x4b78,
    {0x99, 0xfc, 0x65, 0x47, 0xc2, 0xf6, 0x20, 0x64}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\gdata.cpp ===
/****************************************************************************
    GDATA.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Instance data and Shared memory data management functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "private.h"
#include "hanja.h"
#include "immsec.h"
#include "debug.h"
#include "config.h"
#include "gdata.h"
#include "lexheader.h"

// CIMEData static variables
HANDLE       CIMEData::m_vhSharedData = 0;
IMEDATA      CIMEData::m_ImeDataDef;

static const CHAR IMEKR_IME_SHAREDDATA_MUTEX_NAME[] =  "{E12875A0-C3F1-4273-AB6D-9B9948804271}";
static const CHAR IMEKR_IME_SHAREDDATA_NAME[] = "{F6AE3B77-65B1-4181-993C-701461C8F982}";

__inline BOOL DoEnterCriticalSection(HANDLE hMutex)
{
    if(WAIT_FAILED==WaitForSingleObject(hMutex, 3000))    // Wait 3 seconds
        return(FALSE);
    return(TRUE);
}

BOOL CIMEData::InitSharedData()
{
    HANDLE hMutex;
    BOOL fRet = fFalse;
    LPIMEDATA pImedata;

    DebugMsg(DM_TRACE, TEXT("InitSharedData"));

       hMutex = CreateMutex(GetIMESecurityAttributes(), fFalse, IMEKR_IME_SHAREDDATA_MUTEX_NAME);
       if (hMutex != NULL)
           {
           // *** Begin Critical Section ***
           DoEnterCriticalSection(hMutex);

        if((m_vhSharedData = OpenFileMapping(FILE_MAP_READ|FILE_MAP_WRITE, fTrue, IMEKR_IME_SHAREDDATA_NAME)))
            {
            DebugMsg(DM_TRACE, TEXT("InitSharedData - IME shared data already exist"));
            fRet = fTrue;
            }
        else    // if shared memory does not exist
            {
            m_vhSharedData = CreateFileMapping(INVALID_HANDLE_VALUE, GetIMESecurityAttributes(), PAGE_READWRITE, 
                                0, sizeof(IMEDATA),
                                IMEKR_IME_SHAREDDATA_NAME);
            Assert(m_vhSharedData != 0);
            // if shared memory not exist create it
            if (m_vhSharedData) 
                {
                  DebugMsg(DM_TRACE, TEXT("InitSharedData::InitSharedData() - File mapping Created"));
                pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);

                if (!pImedata)
                    {
                    Assert(0);
                    goto ExitCreateSharedData;
                    }

                // initialize the data to zero
                ZeroMemory(pImedata, sizeof(IMEDATA));
                // Unint value of status and comp window position
                pImedata->ptStatusPos.x = pImedata->ptStatusPos.y = -1;
                pImedata->ptCompPos.x = pImedata->ptCompPos.y = -1;

                // Unmap memory
                UnmapViewOfFile(pImedata);
                DebugMsg(DM_TRACE, TEXT("IME shared data handle created successfully"));
                fRet = fTrue;
                }
            }
            
    ExitCreateSharedData:
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
           // *** End Critical Section ***
           }
       
    FreeIMESecurityAttributes();

    return fRet;
}

// Close shared memory handle. This called when process detach time.
BOOL CIMEData::CloseSharedMemory()
{
    HANDLE hMutex;
    BOOL fRet = fTrue;

    DebugMsg(DM_TRACE, TEXT("CloseSharedMemory"));

    hMutex = CreateMutex(GetIMESecurityAttributes(), fFalse, IMEKR_IME_SHAREDDATA_MUTEX_NAME);
       // *** Begin Critical Section ***
       DoEnterCriticalSection(hMutex);
    if (m_vhSharedData)
        {
        if (fRet = CloseHandle(m_vhSharedData))
            m_vhSharedData = 0;
        Assert(fRet);
        }
    ReleaseMutex(hMutex);
    CloseHandle(hMutex);
       // *** End Critical Section ***
       FreeIMESecurityAttributes();

    return fTrue;
}

///////////////////////////////////////////////////////////////////////////////
void CIMEData::InitImeData()
{
    if (m_pImedata == NULL)
        return;

    // Get Work Area
    SystemParametersInfo(SPI_GETWORKAREA, 0, &(m_pImedata->rcWorkArea), 0);

    // If IMEDATA is not initialized ever, fill it with default value first,
    // and then try to read from registry.
    // If IMEDATA overwritten by any reason, it will recover to initial data.
    if (m_pImedata->ulMagic != IMEDATA_MAGIC_NUMBER)
        {
        m_pImedata->ulMagic = IMEDATA_MAGIC_NUMBER;

        // Default option setting. It can be changed according to registry in ImeSelect
        SetCurrentBeolsik(KL_2BEOLSIK);
        m_pImedata->fJasoDel = fTrue;
        m_pImedata->fKSC5657Hanja = fFalse;

        // Default status Buttons
#if !defined(_WIN64)
        m_pImedata->uNumOfButtons = 3;
#else
        m_pImedata->uNumOfButtons = 2;
#endif
        m_pImedata->iCurButtonSize = BTN_MIDDLE;
        m_pImedata->StatusButtons[0].m_ButtonType = HAN_ENG_TOGGLE_BUTTON;
        m_pImedata->StatusButtons[1].m_ButtonType = HANJA_CONV_BUTTON;
#if !defined(_WIN64)
        m_pImedata->StatusButtons[2].m_ButtonType = IME_PAD_BUTTON;
        m_pImedata->StatusButtons[3].m_ButtonType = NULL_BUTTON;
#else
        m_pImedata->StatusButtons[2].m_ButtonType = NULL_BUTTON;
#endif

        // Get all regstry info
        GetRegValues(GETSET_REG_ALL);

        //
        m_pImedata->xCandWi = 320;
        m_pImedata->yCandHi = 30;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\globals.h ===
//
//   Globals.h : Global variable declarations.
//
//   History:
//      15-NOV-1999 CSLim Created

#if !defined (__GLOBALS_H__INCLUDED_)
#define __GLOBALS_H__INCLUDED_

#include "ciccs.h"

///////////////////////////////////////////////////////////////////////////////
// Global variables
extern HINSTANCE g_hInst;
extern LONG g_cRefDll;

extern const GUID GUID_ATTR_KORIMX_INPUT;
extern const GUID GUID_IC_PRIVATE;
extern const GUID GUID_COMPARTMENT_KORIMX_CONVMODE;
extern const GUID GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE;

extern const GUID GUID_KOREAN_HANGULSIMULATE;
extern const GUID GUID_KOREAN_HANJASIMULATE;

// SoftKbd
extern const GUID GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE;
extern const GUID GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT;
extern const GUID GUID_COMPARTMENT_SOFTKBD_WNDPOSITION;

extern DWORD g_dwThreadDllMain;
extern CCicCriticalSectionStatic g_cs;
extern CCicCriticalSectionStatic g_csInDllMain;

#ifndef DEBUG

#define CicEnterCriticalSection(lpCriticalSection)  EnterCriticalSection(lpCriticalSection)

#else // DEBUG

extern const TCHAR *g_szMutexEnterFile;
extern int g_iMutexEnterLine;

//
// In debug, you can see the file/line number where g_cs was last entered
// by checking g_szMutexEnterFile and g_iMutexEnterLine.
//
#define CicEnterCriticalSection(lpCriticalSection)              \
{                                                               \
    Assert(g_dwThreadDllMain != GetCurrentThreadId());			\
                                                                \
    EnterCriticalSection(lpCriticalSection);               		\
                                                                \
    if (lpCriticalSection == (CRITICAL_SECTION *)g_cs)          \
    {                                                           \
        g_szMutexEnterFile = __FILE__;                          \
        g_iMutexEnterLine = __LINE__;                           \
        /* need the InterlockedXXX to keep retail from optimizing away the assignment */ \
        InterlockedIncrement((long *)&g_szMutexEnterFile);      \
        InterlockedDecrement((long *)&g_szMutexEnterFile);      \
        InterlockedIncrement((long *)&g_iMutexEnterLine);       \
        InterlockedDecrement((long *)&g_iMutexEnterLine);       \
    }                                                           \
}

#endif // DEBUG

inline void CicLeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
    Assert(g_dwThreadDllMain != GetCurrentThreadId());

    LeaveCriticalSection(lpCriticalSection);
}

///////////////////////////////////////////////////////////////////////////////
// Window class names
const TCHAR c_szOwnerWndClass[]  = TEXT("KorIMX OwnerWndClass");

///////////////////////////////////////////////////////////////////////////////
// Inline functions

// Shift and Ctrl key check helper functions
inline
BOOL IsShiftKeyPushed(const BYTE lpbKeyState[256])
{
	return ((lpbKeyState[VK_SHIFT] & 0x80) != 0);
}

inline 
BOOL IsControlKeyPushed(const BYTE lpbKeyState[256])
{
	return ((lpbKeyState[VK_CONTROL] & 0x80) != 0);
}

inline 
BOOL IsAltKeyPushed(const BYTE lpbKeyState[256])
{
	return ((lpbKeyState[VK_MENU] & 0x80) != 0);
}

#endif // __GLOBALS_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\hanja.h ===
/****************************************************************************
	HANJA.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Hanja conversion and dictionary lookup functions. Dictionary index is 
	stored as globally shared memory.
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_HANJA_H__INCLUDED_)
#define _HANJA_H__INCLUDED_

#include "LexHeader.h"

enum HANJA_CAT { HANJA_K0, HANJA_K1, HANJA_K2 };

typedef
struct tagHANJA_CAND_STRING
{
	WCHAR   wchHanja;   // Hanja char
	LPWSTR  wzMeaning;  // Hanja meaning
	BYTE	bHanjaCat;  // Hanja category
} HANJA_CAND_STRING;


typedef
struct tagHANJA_CAND_STRING_LIST
{
	LPWSTR				pwsz;	// Null terminated string list (Allocated by GetConversionList)
	HANJA_CAND_STRING	*pHanjaString;  // (Allocated by GetConversionList)

	DWORD		csz;			// Count of wsz's in pwsz 
	DWORD       cszAlloc;       // Number of entries allocated in pHanjaString (set by GetConversionList) 
	DWORD       cchMac;			// Current chars used in pwsz (incl all trailing nulls) 
	DWORD		cchAlloc;		// Size in chars of pwsz (Set by GetConversionList) 
} HANJA_CAND_STRING_LIST;

extern BOOL EnsureHanjaLexLoaded();
extern BOOL CloseLex();
extern BOOL GetMeaningAndProunc(WCHAR wch, LPWSTR lpwstrTip, INT cchMax);
extern BOOL GetConversionList(WCHAR wcReading, HANJA_CAND_STRING_LIST *pCandList);



#endif // !defined (_HANJA_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\hauto.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Hangul automata Class definition
//
// Author: cslim@microsoft.com
// 
// Copyright 1997 Microsoft Corporation.

#include "private.h"
#include "HAuto.h"

// Code conversion table from Chosung to Jongsung.
const 
BYTE  CHangulAutomata::Cho2Jong[NUM_OF_CHOSUNG+1] = //(+ 1 means including fill code at 0)
    { 0, 
      1,  2,  4,  7,  0,  8, 16, 17,  0, 19,
     20, 21, 22,  0, 23, 24, 25, 26, 27
    };

// Code conversion table from Jongsung to Chosung.
const 
BYTE  CHangulAutomata::Jong2Cho[NUM_OF_JONGSUNG] = // Jongsung has inherent fill code
    {  0, 
        1,  2,  0,  3,  0,  0,  4,  6,  0,  0,
        0,  0,  0,  0,  0,  7,  8,  0, 10, 11,
       12, 13, 15, 16, 17, 18, 19  
    };

// Combination table for double jongsung.
BYTE  CHangulAutomata2::rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_2BEOL+1][3] = 
    {
        {  1, 19,  3 }, {  4, 22,  5 }, 
        {  4, 27,  6 },    {  8,  1,  9 }, 
        {  8, 16, 10 },    {  8, 17, 11 }, 
        {  8, 19, 12 },    {  8, 25, 13 }, 
        {  8, 26, 14 }, {  8, 27, 15 }, 
        { 17, 19, 18 },
        { 0,   0,  0 }
    };

BYTE  CHangulAutomata3::rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_3BEOL+1][3] = 
    {
        // 3Beolsik has two more Double Jongsung conditions.
        {  1,  1,  2 },    // KiYeok+KiYeok = Double KiYeok
        {  1, 19,  3 }, {  4, 22,  5 }, 
        {  4, 27,  6 },    {  8,  1,  9 }, 
        {  8, 16, 10 },    {  8, 17, 11 }, 
        {  8, 19, 12 },    {  8, 25, 13 }, 
        {  8, 26, 14 }, {  8, 27, 15 }, 
        { 17, 19, 18 },    
        { 19, 19, 20 },  // Sios+Sios = Double Sios
        { 0,   0,  0 }
    };


#if (NOT_USED)
static
WORD CHangulAutomata::DblJong2Cho(WORD DblJong)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    int i = NUM_OF_DOUBLE_JONGSUNG;
    
    for (; i>0; i--, pDbl--)
        if ( (*pDbl)[2] == DblJong ) 
            return Jong2Cho[(*pDbl)[1]];

    return 0;
}
#endif

///////////////////////////////////////////////////////////////////////////////
// 2 beolsik input state category
const WORD CHangulAutomata2::H_CONSONANT = 0x0000 | H_HANGUL;    // Consonant
const WORD CHangulAutomata2::H_VOWEL     = 0x0100 | H_HANGUL;    // Vowel
const WORD CHangulAutomata2::H_DOUBLE    = 0x0200 | H_HANGUL;    // Double combination possible
const WORD CHangulAutomata2::H_ONLYCHO   = 0x0400 | H_HANGUL;    // Chosung only

// 3 beolsik input state category
const WORD CHangulAutomata3::H_CHOSUNG   = 0x0000 | H_HANGUL;    // ChoSung
const WORD CHangulAutomata3::H_JUNGSUNG  = 0x0200 | H_HANGUL;   // JungSung
const WORD CHangulAutomata3::H_JONGSUNG  = 0x0400 | H_HANGUL;   // JongSung
const WORD CHangulAutomata3::H_DOUBLE    = 0x0100 | H_HANGUL;    // Double combination possible

///////////////////////////////////////////////////////////////////////////////
// bHTable[] structure
//
// 2 Beolsik
//     H I G H  B Y T E  L O W  B Y T E
//    7 6 5 4 3 2 1 0  7 6 5 4 3 2 1 0          
//   +-+-------+-----+---------------+
//   | |       |     |               |
//   +-+-------+-----+---------------+
//     High 8   : Hangul or English
//   High 2-0 : used for input state category field.
//   Low  4-0 : Hangul component code (internal code)
//

// ====-- SHARED SECTION START --====
#pragma data_seg(".MSIMESHR")
WORD  CHangulAutomata2::wHTable[256][2] =
{
//  { Hangul normal, Hangul shift, English normal, English shift }
    // 2 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 0x30, 0x29 }, //  48, 0x30: VK_0
    { 0x31, 0x21 }, //  49, 0x31: VK_1
    { 0x32, 0x40 }, //  50, 0x32: VK_2
    { 0x33, 0x23 }, //  51, 0x33: VK_3
    { 0x34, 0x24 }, //  52, 0x34: VK_4
    { 0x35, 0x25 }, //  53, 0x35: VK_5
    { 0x36, 0x5E }, //  54, 0x36: VK_6
    { 0x37, 0x26 }, //  55, 0x37: VK_7
    { 0x38, 0x2A }, //  56, 0x38: VK_8
    { 0x39, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    {  7 | H_CONSONANT,  7 | H_CONSONANT },                            //  65, 0x41: VK_A        
    { 18 | H_VOWEL, 18 | H_VOWEL },                                    //  66, 0x42: VK_B        
    { 15 | H_CONSONANT, 15 | H_CONSONANT },                            //  67, 0x43: VK_C        
    { 12 | H_CONSONANT, 12 | H_CONSONANT },                            //  68, 0x44: VK_D        
    {  4 | H_CONSONANT,  5 | H_ONLYCHO},                            //  69, 0x45: VK_E        
    {  6 | H_CONSONANT | H_DOUBLE,  6 | H_CONSONANT | H_DOUBLE },    //  70, 0x46: VK_F        
    { 19 | H_CONSONANT, 19 | H_CONSONANT },                            //  71, 0x47: VK_G        
    {  9 | H_VOWEL | H_DOUBLE,  9 | H_VOWEL | H_DOUBLE },            //  72, 0x48: VK_H        
    {  3 | H_VOWEL,  3 | H_VOWEL },                                    //  73, 0x49: VK_I        
    {  5 | H_VOWEL,  5 | H_VOWEL },                                    //  74, 0x4A: VK_J        
    {  1 | H_VOWEL,  1 | H_VOWEL },                                    //  75, 0x4B: VK_K        
    { 21 | H_VOWEL, 21 | H_VOWEL },                                    //  76, 0x4C: VK_L        
    { 19 | H_VOWEL | H_DOUBLE, 19 | H_VOWEL | H_DOUBLE },            //  77, 0x4D: VK_M        
    { 14 | H_VOWEL | H_DOUBLE, 14 | H_VOWEL | H_DOUBLE },            //  78, 0x4E: VK_N        
    {  2 | H_VOWEL,  4 | H_VOWEL },                                    //  79, 0x4F: VK_O        
    {  6 | H_VOWEL,  8 | H_VOWEL },                                    //  80, 0x50: VK_P        
    {  8 | H_CONSONANT | H_DOUBLE,  9 | H_ONLYCHO },                //  81, 0x51: VK_Q        
    {  1 | H_CONSONANT | H_DOUBLE,  2 | H_CONSONANT },                //  82, 0x52: VK_R        
    {  3 | H_CONSONANT | H_DOUBLE,  3 | H_CONSONANT | H_DOUBLE },    //  83, 0x53: VK_S        
    { 10 | H_CONSONANT, 11 | H_CONSONANT },                            //  84, 0x54: VK_T        
    {  7 | H_VOWEL, 7 | H_VOWEL },                                    //  85, 0x55: VK_U        
    { 18 | H_CONSONANT, 18 | H_CONSONANT },                            //  86, 0x56: VK_V        
    { 13 | H_CONSONANT, 14 | H_ONLYCHO },                            //  87, 0x57: VK_W        
    { 17 | H_CONSONANT, 17 | H_CONSONANT },                            //  88, 0x58: VK_X        
    { 13 | H_VOWEL, 13 | H_VOWEL },                                    //  89, 0x59: VK_Y        
    { 16 | H_CONSONANT, 16 | H_CONSONANT },                            //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    { 0x3B, 0x3A }, // 186, 0xBA:    ;    :
    { 0x3D, 0x2B }, // 187, 0xBB:    =    +
    { 0x2C, 0x3C }, // 188, 0xBC:    ,    <
    { 0x2D, 0x5F }, // 189, 0xBD:    -    _
    { 0x2E, 0x3E }, // 190, 0xBE:    .    >
    { 0x2F, 0x3F }, // 191, 0xBF:    /    ?
    { 0x60, 0x7E }, // 192, 0xC0:    `    ~
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:    [    {
    { 0x5C, 0x7C }, // 220, 0xDC:    \    |
    { 0x5D, 0x7D }, // 221, 0xDD:    ]    }
    { 0x27, 0x22 }, // 222, 0xDE:    '    "
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

WORD  CHangulAutomata3::wHTable[256][2] =
{
    // 3 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 16 | H_CHOSUNG, 0x29 },                    //  48, 0x30: VK_0        )
    { 27 | H_JONGSUNG, 22 | H_JONGSUNG },        //  49, 0x31: VK_1        
    { 20 | H_JONGSUNG, 0x40 },                    //  50, 0x32: VK_2        @
    { 17 | H_JONGSUNG | H_DOUBLE, 0x23 },        //  51, 0x33: VK_3        #
    { 13 | H_JUNGSUNG, 0x24 },                    //  52, 0x34: VK_4        $
    { 18 | H_JUNGSUNG, 0x25 },                    //  53, 0x35: VK_5        %
    {  3 | H_JUNGSUNG, 0x5E },                    //  54, 0x36: VK_6        ^
    {  8 | H_JUNGSUNG, 0x26 },                    //  55, 0x37: VK_7        &
    { 20 | H_JUNGSUNG, 0x2A },                    //  56, 0x38: VK_8        *
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 21 | H_JONGSUNG,  7 | H_JONGSUNG},    //  65, 0x41: VK_A        
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x21 },    //  66, 0x42: VK_B        !
    {  6 | H_JUNGSUNG, 10 | H_JONGSUNG},    //  67, 0x43: VK_C        
    { 21 | H_JUNGSUNG,  9 | H_JONGSUNG},    //  68, 0x44: VK_D        
    {  7 | H_JUNGSUNG, 24 | H_JONGSUNG},    //  69, 0x45: VK_E        
    {  1 | H_JUNGSUNG,  2 | H_JONGSUNG},    //  70, 0x46: VK_F        
    { 19 | H_JUNGSUNG | H_DOUBLE, 0x2F },    //  71, 0x47: VK_G        /
    {  3 | H_CHOSUNG, 0x27 },                //  72, 0x48: VK_H        ,
    {  7 | H_CHOSUNG, 0x38 },                //  73, 0x49: VK_I        8
    { 12 | H_CHOSUNG, 0x34 },                //  74, 0x4A: VK_J        4
    {  1 | H_CHOSUNG | H_DOUBLE, 0x35 },    //  75, 0x4B: VK_K        5
    { 13 | H_CHOSUNG | H_DOUBLE, 0x36 },    //  76, 0x4C: VK_L        6
    { 19 | H_CHOSUNG, 0x31 },        //  77, 0x4D: VK_M        1
    { 10 | H_CHOSUNG | H_DOUBLE, 0x30 },    //  78, 0x4E: VK_N        0
    { 15 | H_CHOSUNG, 0x39 },                //  79, 0x4F: VK_O        9
    { 18 | H_CHOSUNG, 0x3E },                //  80, 0x50: VK_P        >
    { 19 | H_JONGSUNG | H_DOUBLE,  26 | H_JONGSUNG},    //  81, 0x51: VK_Q        
    {  2 | H_JUNGSUNG, 4 | H_JUNGSUNG},                    //  82, 0x52: VK_R        
    {  4 | H_JONGSUNG | H_DOUBLE,  6 | H_JONGSUNG},        //  83, 0x53: VK_S        
    {  5 | H_JUNGSUNG, 0x3B },                            //  84, 0x54: VK_T        ;
    {  4 | H_CHOSUNG | H_DOUBLE, 0x37 },                //  85, 0x55: VK_U        7
    {  9 | H_JUNGSUNG | H_DOUBLE, 15 | H_JONGSUNG },    //  86, 0x56: VK_V        
    {  8 | H_JONGSUNG | H_DOUBLE, 25 | H_JONGSUNG},        //  87, 0x57: VK_W        
    {  1 | H_JONGSUNG | H_DOUBLE, 18 | H_JONGSUNG },    //  88, 0x58: VK_X        
    {  6 | H_CHOSUNG, 0x3C },                            //  89, 0x59: VK_Y        <
    { 16 | H_JONGSUNG,  23 | H_JONGSUNG },                //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    {  8 | H_CHOSUNG | H_DOUBLE, 0x3A },    // 186, 0xBA:        :
    { 0x3D, 0x2B },                            // 187, 0xBB:
    { 0x2C, 0x32 },                            // 188, 0xBC:    ,    2
    { 0x2D, 0x5F },                            // 189, 0xBD:
    { 0x2E, 0x33 },                            // 190, 0xBE:    .    3
    {  9 | H_JUNGSUNG | H_DOUBLE, 0x3F },    // 191, 0xBF:        ?
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:    [    {
    { 0x5C, 0x7C }, // 220, 0xDC:    \    |
    { 0x5D, 0x7D }, // 221, 0xDD:    ]    }
    { 17 | H_CHOSUNG, 0x22 }, // 222, 0xDE:        "
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

WORD  CHangulAutomata3Final::wHTable[256][2] =
{
    // 3 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 16 | H_CHOSUNG, 0x7E },                    //  48, 0x30: VK_0        ~
    { 27 | H_JONGSUNG,  2 | H_JONGSUNG },        //  49, 0x31: VK_1        
    { 20 | H_JONGSUNG,  9 | H_JONGSUNG },        //  50, 0x32: VK_2         
    { 17 | H_JONGSUNG|H_DOUBLE, 22 | H_JONGSUNG },    //  51, 0x33: VK_3        
    { 13 | H_JUNGSUNG, 14 | H_JONGSUNG },            //  52, 0x34: VK_4        
    { 18 | H_JUNGSUNG, 13 | H_JONGSUNG },            //  53, 0x35: VK_5        
    {  3 | H_JUNGSUNG, 0x3D },                    //  54, 0x36: VK_6        =
    {  8 | H_JUNGSUNG, 0x22 },                    //  55, 0x37: VK_7        "
    { 20 | H_JUNGSUNG, 0x22 },                    //  56, 0x38: VK_8        "
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x27 },        //  57, 0x39: VK_9  '
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 21 | H_JONGSUNG,  7 | H_JONGSUNG},    //  65, 0x41: VK_A        
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x3F },    //  66, 0x42: VK_B        ?
    {  6 | H_JUNGSUNG, 24 | H_JONGSUNG},    //  67, 0x43: VK_C        
    { 21 | H_JUNGSUNG, 11 | H_JONGSUNG},    //  68, 0x44: VK_D        
    {  7 | H_JUNGSUNG,  5 | H_JONGSUNG},    //  69, 0x45: VK_E        
    {  1 | H_JUNGSUNG, 10 | H_JONGSUNG},    //  70, 0x46: VK_F        
    { 19 | H_JUNGSUNG | H_DOUBLE, 4 | H_JUNGSUNG },    //  71, 0x47: VK_G        
    {  3 | H_CHOSUNG, 0x30 },                //  72, 0x48: VK_H        0
    {  7 | H_CHOSUNG, 0x37 },                //  73, 0x49: VK_I        7
    { 12 | H_CHOSUNG, 0x31 },                //  74, 0x4A: VK_J        1
    {  1 | H_CHOSUNG | H_DOUBLE, 0x32 },    //  75, 0x4B: VK_K        2
    { 13 | H_CHOSUNG | H_DOUBLE, 0x33 },    //  76, 0x4C: VK_L        3
    { 19 | H_CHOSUNG, 0x22},                //  77, 0x4D: VK_M        "
    { 10 | H_CHOSUNG | H_DOUBLE, 0x2D },    //  78, 0x4E: VK_N        -
    { 15 | H_CHOSUNG, 0x38 },                //  79, 0x4F: VK_O        8
    { 18 | H_CHOSUNG, 0x39 },                //  80, 0x50: VK_P        9
    { 19 | H_JONGSUNG | H_DOUBLE,  26 | H_JONGSUNG},    //  81, 0x51: VK_Q        
    {  2 | H_JUNGSUNG, 15 | H_JONGSUNG},                //  82, 0x52: VK_R        
    {  4 | H_JONGSUNG | H_DOUBLE,  6 | H_JONGSUNG},        //  83, 0x53: VK_S        
    {  5 | H_JUNGSUNG, 12 | H_JONGSUNG },                            //  84, 0x54: VK_T        
    {  4 | H_CHOSUNG | H_DOUBLE, 0x36 },                //  85, 0x55: VK_U        6
    {  9 | H_JUNGSUNG | H_DOUBLE,  3 | H_JONGSUNG },    //  86, 0x56: VK_V        
    {  8 | H_JONGSUNG | H_DOUBLE, 25 | H_JONGSUNG},        //  87, 0x57: VK_W        
    {  1 | H_JONGSUNG | H_DOUBLE, 18 | H_JONGSUNG },    //  88, 0x58: VK_X        
    {  6 | H_CHOSUNG, 0x35 },                            //  89, 0x59: VK_Y        5
    { 16 | H_JONGSUNG,  23 | H_JONGSUNG },                //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    {  8 | H_CHOSUNG | H_DOUBLE, 0x34 },    // 186, 0xBA:        4
    { 0x3E, 0x2B },                            // 187, 0xBB:    >    +
    { 0x2C, 0x2C },                            // 188, 0xBC:    ,    ,
    { 0x29, 0x3B },                            // 189, 0xBD:    )    ;
    { 0x2E, 0x2E },                            // 190, 0xBE:    .    .
    {  9 | H_JUNGSUNG | H_DOUBLE, 0x21 },    // 191, 0xBF:        !
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x28, 0x25 }, // 219, 0xDB:    (    %
    { 0x3A, 0x5C }, // 220, 0xDC:    :    '\'
    { 0x3C, 0x2F }, // 221, 0xDD:    <    /
    { 17 | H_CHOSUNG, 0x00 }, // 222, 0xDE:    
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

const 
BYTE  CHangulAutomata::bETable[256][2] =
{
    // English normal, English shift for Junja(Full shape) mode
    { 0x00, 0x00 }, //   0, 0x00: 
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 0x30, 0x29 }, //  48, 0x30: VK_0
    { 0x31, 0x21 }, //  49, 0x31: VK_1
    { 0x32, 0x40 }, //  50, 0x32: VK_2
    { 0x33, 0x23 }, //  51, 0x33: VK_3
    { 0x34, 0x24 }, //  52, 0x34: VK_4
    { 0x35, 0x25 }, //  53, 0x35: VK_5
    { 0x36, 0x5E }, //  54, 0x36: VK_6
    { 0x37, 0x26 }, //  55, 0x37: VK_7
    { 0x38, 0x2A }, //  56, 0x38: VK_8
    { 0x39, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 0x61, 0x41 }, //  65, 0x41: VK_A
    { 0x62, 0x42 }, //  66, 0x42: VK_B
    { 0x63, 0x43 }, //  67, 0x43: VK_C
    { 0x64, 0x44 }, //  68, 0x44: VK_D
    { 0x65, 0x45 }, //  69, 0x45: VK_E
    { 0x66, 0x46 }, //  70, 0x46: VK_F
    { 0x67, 0x47 }, //  71, 0x47: VK_G
    { 0x68, 0x48 }, //  72, 0x48: VK_H
    { 0x69, 0x49 }, //  73, 0x49: VK_I
    { 0x6A, 0x4A }, //  74, 0x4A: VK_J
    { 0x6B, 0x4B }, //  75, 0x4B: VK_K
    { 0x6C, 0x4C }, //  76, 0x4C: VK_L
    { 0x6D, 0x4D }, //  77, 0x4D: VK_M
    { 0x6E, 0x4E }, //  78, 0x4E: VK_N
    { 0x6F, 0x4F }, //  79, 0x4F: VK_O
    { 0x70, 0x50 }, //  80, 0x50: VK_P
    { 0x71, 0x51 }, //  81, 0x51: VK_Q
    { 0x72, 0x52 }, //  82, 0x52: VK_R
    { 0x73, 0x53 }, //  83, 0x53: VK_S
    { 0x74, 0x54 }, //  84, 0x54: VK_T
    { 0x75, 0x55 }, //  85, 0x55: VK_U
    { 0x76, 0x56 }, //  86, 0x56: VK_V
    { 0x77, 0x57 }, //  87, 0x57: VK_W
    { 0x78, 0x58 }, //  88, 0x58: VK_X
    { 0x79, 0x59 }, //  89, 0x59: VK_Y
    { 0x7A, 0x5A }, //  90, 0x5A: VK_Z
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    { 0x3B, 0x3A }, // 186, 0xBA:
    { 0x3D, 0x2B }, // 187, 0xBB:
    { 0x2C, 0x3C }, // 188, 0xBC:
    { 0x2D, 0x5F }, // 189, 0xBD:
    { 0x2E, 0x3E }, // 190, 0xBE:
    { 0x2F, 0x3F }, // 191, 0xBF:
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:
    { 0x5C, 0x7C }, // 220, 0xDC:
    { 0x5D, 0x7D }, // 221, 0xDD:
    { 0x27, 0x22 }, // 222, 0xDE:
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};


static 
WORD Int2UniCho[NUM_OF_CHOSUNG+1] = 
    {
    0,    // fill [0]
    UNICODE_HANGUL_COMP_JAMO_START + 0,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 1,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 3,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 6,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 7,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 8,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 16,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 17,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 18,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 20,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 21,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 22,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 23,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 24,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 25,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 26,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 27,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 28,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 29,    // 
    };

static 
WORD Int2UniJong[NUM_OF_JONGSUNG] = 
    {
    0,    // fill [0]
    UNICODE_HANGUL_COMP_JAMO_START + 0,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 1,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 2,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 3,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 4,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 5,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 6,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 8,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 9,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 10,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 11,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 12,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 13,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 14,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 15,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 16,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 17,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 19,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 20,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 21,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 22,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 23,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 25,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 26,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 27,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 28,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 29,    // 
    };

// Compatibility Jamo Consonant map
static
BYTE CompJamoMapTable[30][2] =
    {
        // Jamo code , Jongsung Flag : Only if it can't be chosung then make it jongsung
        { _KIYEOK_,                0 },
        { _SSANGKIYEOK_,        0 },
        { _JONG_KIYEOK_SIOS,    1 },
        { _NIEUN_,                0 },
        { _JONG_NIEUN_CHIEUCH_, 1 },
        { _JONG_NIEUN_HIEUH_,    1 },
        { _TIKEUT_,                0 },    
        { _SSANGTIKEUT_,        0 },
        { _RIEUL_,                0 },
        { _JONG_RIEUL_KIYEOK_,    1 },
        { _JONG_RIEUL_MIUM_,    1 },
        { _JONG_RIEUL_PIEUP_,    1 },
        { _JONG_RIEUL_SIOS_,    1 },
        { _JONG_RIEUL_THIEUTH_,    1 },
        { _JONG_RIEUL_PHIEUPH_,    1 },
        { _JONG_RIEUL_HIEUH_,    1 },
        { _MIEUM_,                0 },
        { _PIEUP_,                0 },
        { _SSANGPIEUP_,            0 },
        { _JONG_PIEUP_SIOS,        1 },
        { _SIOS_,                0 }, 
        { _SSANGSIOS_,            0 }, 
        { _IEUNG_,                0 },    
        { _CIEUC_,                0 },
        { _SSANGCIEUC_,            0 },
        { _CHIEUCH_,            0 },
        { _KHIEUKH_,            0 },
        { _THIEUTH_,            0 },
        { _PHIEUPH_,            0 },
        { _HIEUH_,                0 },
    };


static
BYTE JongSungSep[NUM_OF_JONGSUNG][2] =
    {
        {    0,    0    },
        { _JONG_KIYEOK_,            0        },    //_JONG_KIYEOK_        
        { _JONG_SSANGKIYEOK_,        0        },    //_JONG_SSANGKIYEOK_    
        { _JONG_KIYEOK_,    _JONG_SIOS_        },    //_JONG_KIYEOK_SIOS    
        { _JONG_NIEUN_,                0        },    //_JONG_NIEUN_        
        { _JONG_NIEUN_,        _JONG_CIEUC_    },    //_JONG_NIEUN_CIEUC_
        { _JONG_NIEUN_,        _JONG_HIEUH_    },    //_JONG_NIEUN_HIEUH_    
        { _JONG_TIKEUT_,            0        },    //_JONG_TIKEUT_        
        { _JONG_RIEUL_,                0        },    //_JONG_RIEUL_        
        { _JONG_RIEUL_,        _JONG_KIYEOK_    },    //_JONG_RIEUL_KIYEOK_
        { _JONG_RIEUL_,        _JONG_MIEUM_    },    //_JONG_RIEUL_MIUM_        
        { _JONG_RIEUL_,        _JONG_PIEUP_    },    //_JONG_RIEUL_PIEUP_
        { _JONG_RIEUL_,        _JONG_SIOS_        },    //_JONG_RIEUL_SIOS_    
        { _JONG_RIEUL_,        _JONG_THIEUTH_    },    //_JONG_RIEUL_THIEUTH_
        { _JONG_RIEUL_,        _JONG_PHIEUPH_    },    //_JONG_RIEUL_PHIEUPH_    
        { _JONG_RIEUL_,        _JONG_HIEUH_    },    //_JONG_RIEUL_HIEUH_
        { _JONG_MIEUM_,                0        },    //_JONG_MIEUM_        
        { _JONG_PIEUP_,                0        },    //_JONG_PIEUP_        
        { _JONG_PIEUP_,        _JONG_SIOS_        },    //_JONG_PIEUP_SIOS
        { _JONG_SIOS_,                0        },    //_JONG_SIOS_        
        { _JONG_SSANGSIOS_,            0        },    //_JONG_SSANGSIOS_    
        { _JONG_IEUNG_,                0        },    //_JONG_IEUNG_            
        { _JONG_CIEUC_,                0        },    //_JONG_CIEUC_            
        { _JONG_CHIEUCH_,            0        },    //_JONG_CHIEUCH_
        { _JONG_KHIEUKH_,            0        },    //_JONG_KHIEUKH_    
        { _JONG_THIEUTH_,            0        },    //_JONG_THIEUTH_    
        { _JONG_PHIEUPH_,            0        },    //_JONG_PHIEUPH_
        { _JONG_HIEUH_,                0        }    //_JONG_HIEUH_    
    };

static
BYTE JungSungSep[NUM_OF_JUNGSUNG+1][2] =
    {
        {    0,    0    },
        { _A_,                    0    },    // _A_,    
        { _AE_,                    0    },    //_AE_,    
        { _YA_,                    0    },    //_YA_,    
        { _YAE_,                0    },    //_YAE_,
        { _EO_,                    0    },    //_EO_,    
        { _E_,                    0    },    //_E_,    
        { _YEO_,                0    },    //_YEO_,
        { _YE_,                    0    },    //_YE_,    
        { _O_,                    0    },    //_O_,    
        { _O_,                _A_        },    //_WA_,    
        { _O_,                _AE_    },    //_WAE_,
        { _O_,                _I_        },    //_OE_,    
        { _YO_,                    0    },    //_YO_,    
        { _U_,                    0    },    //_U_,    
        { _U_,                _EO_    },    //_WEO_,
        { _U_,                _E_        },    //_WE_,    
        { _U_,                _I_        },    //_WI_,    
        { _YU_,                    0    },    //_YU_,    
        { _EU_,                    0    },    //_EU_,    
        { _EU_,                _I_        },    //_YI_,    
        { _I_,                    0    }    //_I_,    
    };
#pragma data_seg()
// ====-- SHARED SECTION END --====

///////////////////////////////////////////////////////////////////////////////
// CHangulAutomata class member function
BOOL CHangulAutomata::MakeComplete()
{
    if (m_wcComposition) 
        {
        m_wcComplete = m_wcComposition;
        
        // clear composition char
        m_wcComposition = 0;
        
        // Init interim stack
        InterimStack.Init();
        m_Chosung = m_Jungsung = m_Jongsung = 0;
        
        // Init state
        m_CurState = 0;
        return fTrue;
        }
    else
        return fFalse;
}

// Complete used when takeover occurs
BOOL CHangulAutomata::MakeComplete(WORD wcComplete)
{
    if (wcComplete) 
        {
        m_wcComplete = wcComplete;
        // clear composition char
        m_wcComposition = 0;
        // Init interim stack
        InterimStack.Init();
        m_Jungsung = m_Jongsung = 0;
        return fTrue;
        }
    else
        return fFalse;
}

void CHangulAutomata::MakeComposition()
{
    Assert(m_Chosung || m_Jungsung || m_Jongsung);
    // if Hangul
    if (m_Chosung && m_Jungsung) 
        {
        m_wcComposition = UNICODE_HANGUL_BASE 
                            + (m_Chosung-1) * NUM_OF_JUNGSUNG * (NUM_OF_JONGSUNG)    // +1 : jongsung fill
                            + (m_Jungsung-1) * (NUM_OF_JONGSUNG)
                            + m_Jongsung;
        }
    else // Hangul jamo
         // Currently map to compatiblity area. This should be changed if jamo glyphs available.
        {
            if (m_Chosung)
                m_wcComposition = Int2UniCho[m_Chosung];
            else
                if (m_Jungsung)
                    m_wcComposition = UNICODE_HANGUL_COMP_JAMO_START + 30 + m_Jungsung-1;
                    else 
                    if (m_Jongsung)
                        m_wcComposition = Int2UniJong[m_Jongsung];
        }
    // Push to interim stack
    InterimStack.Push(m_wInternalCode, m_CurState, m_Chosung, m_Jungsung, m_Jongsung, 
                      m_wcComposition);
    // Dbg(DBGID_Automata, _T("CHangulAutomata::MakeComposition(), m_CurState=%d, m_Chosung=%d, m_Jungsung=%d, m_Jongsung=%d, m_wcComposition = 0x%04X"), m_CurState,  m_Chosung, m_Jungsung, m_Jongsung, m_wcComposition);
    //
}

WORD CHangulAutomata::FindChosungComb(WORD wPrevCode)
{
    // Combination table for double chosung. (only for 3beolsik)
    static BYTE  rgbDChoTbl[NUM_OF_DOUBLE_CHOSUNG][3] = 
        {
            {  1,  1,  2 }, {  4,  4,  5 },        //   -> ,   -> 
            {  8,  8,  9 }, { 10, 10, 11 },        //   -> ,   -> 
            { 13, 13, 14 }                        //   -> 
        };

    BYTE (*pDbl)[3] = rgbDChoTbl;    // pointer a little bit faster than array access.
    int i = NUM_OF_DOUBLE_CHOSUNG;
    WORD wCurCode = m_wInternalCode & 0xFF;

    for (; i>0; i--, pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] == wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

WORD CHangulAutomata::FindJunsungComb(WORD wPrevCode)
{
    // Combination table for double jungsung.
    static BYTE  rgbDJungTbl[NUM_OF_DOUBLE_JUNGSUNG][3] = 
        {
            {  9,  1, 10 }, {  9,  2, 11 },        //   -> ,   -> 
            {  9, 21, 12 }, { 14,  5, 15 },        //   -> ,   -> 
            { 14,  6, 16 }, { 14, 21, 17 },        //   -> ,   -> 
            { 19, 21, 20 }                        //   -> 
        };
    BYTE (*pDbl)[3] = rgbDJungTbl;
    int i = NUM_OF_DOUBLE_JUNGSUNG;
    WORD wCurCode = m_wInternalCode & 0xFF;
    
    for (; i>0; i--, pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] == wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}


WORD CHangulAutomata2::FindJonsungComb(WORD wPrevCode)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    wPrevCode = Cho2Jong[wPrevCode];
    WORD wCurCode = Cho2Jong[m_wInternalCode & 0xFF];
    
    for (; (*pDbl)[0]; pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] ==  wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

WORD CHangulAutomata3::FindJonsungComb(WORD wPrevCode)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    // 3BeolSik internal code have Jongsung code
    WORD wCurCode = m_wInternalCode & 0xFF;
    
    for (; (*pDbl)[0]; pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] ==  wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

BOOL CHangulAutomata::BackSpace()
{
    InterimStackEntry*    pInterimEntry;

    if (InterimStack.IsEmpty())
        return fFalse;
    else 
        {
        InterimStack.Pop();
        if (!InterimStack.IsEmpty()) 
            {
            pInterimEntry = InterimStack.GetTop();
            m_wcComposition = pInterimEntry->m_wcCode;
            m_CurState = pInterimEntry->m_CurState;
            m_Chosung = pInterimEntry->m_Chosung;
            m_Jungsung = pInterimEntry->m_Jungsung;
            m_Jongsung = pInterimEntry->m_Jongsung;
            }
        else
            InitState();
        return fTrue;
        }    
}

void CHangulAutomata::SeparateDJung(LPWORD pJungSung)
{
    WORD wJungSung = pJungSung[0];
    pJungSung[0] = JungSungSep[wJungSung][0];
    pJungSung[1] = JungSungSep[wJungSung][1];
}

void CHangulAutomata::SeparateDJong(LPWORD pJongSung)
{
    WORD wJongSung = pJongSung[0];
    pJongSung[0] = JongSungSep[wJongSung][0];
    pJongSung[1] = JongSungSep[wJongSung][1];
}


///////////////////////////////////////////////////////////////////////////////
//
// Assume : Input wcComp has valid Unicode Hangul value
// (wcComp>0x3130 && wcComp<0x3164) || (wcComp>=0xAC00 && wcComp<0xD7A4)) 
//
BOOL CHangulAutomata2::SetCompositionChar(WCHAR wcComp)
{
    WORD wUnicodeHangulOffset;
    WORD wChosung;
    WORD wJungsung[2], wJongsung[2];

    // Dbg(DBGID_SetComp, _T("CHangulAutomata2::SetCompositionChar: wcComp = %c(0x%X)"), wcComp, wcComp), 

    InitState();

    wChosung = wJungsung[0] = wJungsung[1] = wJongsung[0] = wJongsung[1] = 0;

    if (wcComp <= UNICODE_HANGUL_COMP_JAMO_END && wcComp >= UNICODE_HANGUL_COMP_JAMO_START) 
        {
        // Dbg(DBGID_SetComp, _T("COMP_JAMO"));
        // Consonant or vowel ?
        if (wcComp < UNICODE_HANGUL_COMP_JAMO_VOWEL_START) 
            {
            wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_COMP_JAMO_START);
            // Jongsung or Chosung ?
            if (CompJamoMapTable[wUnicodeHangulOffset][1]) 
                {
                wJongsung[0] = CompJamoMapTable[wUnicodeHangulOffset][0];
                SeparateDJong(wJongsung);
                // Dbg(DBGID_Automata, _T("SetCompositionChar() : wJongsung[0]=%04x, wJongsung[1]=%04x"), wJongsung[0], wJongsung[1]);
                }
            else 
                wChosung = CompJamoMapTable[wUnicodeHangulOffset][0];

            }
        else 
            {
            wJungsung[0] = wcComp - UNICODE_HANGUL_COMP_JAMO_VOWEL_START + 1;
            SeparateDJung(wJungsung);
            }
        } 
    else 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_BASE);
        wChosung = (WORD)( wUnicodeHangulOffset / 
                                    (NUM_OF_JONGSUNG*NUM_OF_JUNGSUNG)) + 1;    // +1 to skip fill code

        wJungsung[0] = (WORD)(wUnicodeHangulOffset / NUM_OF_JONGSUNG
                                                        % NUM_OF_JUNGSUNG) + 1;
        SeparateDJung(wJungsung);

        wJongsung[0] = (WORD)(wUnicodeHangulOffset % NUM_OF_JONGSUNG);    // jongsung already has fill code
        SeparateDJong(wJongsung);
        }

    ///////////////////////////////////////////////////////////////////////////
    // Push process
    if (wChosung) 
        {
        m_Chosung = m_wInternalCode = wChosung;
        m_CurState = 1; // Chosung state
        MakeComposition();
        }

    if (wJungsung[0]) 
        {
        m_Jungsung = m_wInternalCode  = wJungsung[0];
        if (m_Jungsung == _O_ || m_Jungsung == _U_ || m_Jungsung == _EU_) 
            m_CurState = 3; // Double Jungsung possible state
        else
            m_CurState = 2; // Single Jungsung state
        MakeComposition();
        }

    if (wJungsung[1]) 
        {
        Assert(wJungsung[0] == _O_ || wJungsung[0] == _U_ || wJungsung[0] == _EU_);
        m_wInternalCode = wJungsung[1];
        m_Jungsung = FindJunsungComb(wJungsung[0]);
        Assert(m_Jungsung);
        m_CurState = 2; // Jungsung state
        MakeComposition();
        }

    //
    if (wJongsung[0]) 
        {
        m_wInternalCode  = Jong2Cho[wJongsung[0]];
        m_Jongsung = wJongsung[0];

        // KiYeok, Nieun, Rieul and Pieup: Double jongsong possible chars.
        if (m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_)
            m_CurState = 5; // Double Jongsung possible state
        else
            m_CurState = 4; // Single Jongsung state
        MakeComposition();
        }

    if (wJongsung[1]) 
        {
        Assert(m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
                || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_);
        m_wInternalCode = Jong2Cho[wJongsung[1]];
        m_Jongsung = FindJonsungComb(Jong2Cho[wJongsung[0]]);

        Assert(m_Jongsung);
        m_CurState = 4; // Jongsung state
        MakeComposition();
        }
    return fTrue;
}



///////////////////////////////////////////////////////////////////////////////
//    Transition table of 2beolsik hangul automata
const WORD CHangulAutomata2::m_NextStateTbl[8][5] = 
    {
        /////////////////////////////////////////////////////
        //    Sa        Va            Sb        Vb            Sc            State
        {     1,         6,             1,         7,            1        },    // 0 : Start
        {    FIND,     2,            FIND,     3,            FINAL    },    // 1 : Chosung
        {     4,        FINAL,         5,        FINAL,        FINAL    },    // 2 : Single Jungsung
        {     4,        FIND,         5,        FINAL,        FINAL    },    // 3 : Double Jungsung possible
        {    FINAL,    TAKEOVER,    FINAL,    TAKEOVER,    FINAL    },    // 4 : Single Jongsung
        {    FIND,    TAKEOVER,    FIND,    TAKEOVER,    FINAL    },    // 5 : Double Jongsung possible
        {    FINAL,    FINAL,        FINAL,    FINAL,        FINAL    },    // 6 : Single Jungsung(without chosung)
        {    FINAL,    FIND,        FINAL,    FINAL,        FINAL    }    // 7 : Double Jungsung possible(without chosung)
    };
///////////////////////////////////////////////////////////////////////////////

HAutomataReturnState CHangulAutomata2::Input(WORD InternalCode)
{
    WORD wSymbol, wFind;
    InterimStackEntry*    pPrevInterim;

    // Check if hangul key
    if ( !(InternalCode & H_HANGUL) )
        return HAUTO_NONHANGULKEY;    // This keycode need not handled in automata.
                                    // Calling function should handle it properly.

    // Copy internal code to member data
    m_wInternalCode = InternalCode;
    wSymbol = (m_wInternalCode >> 8) & 0x7F;
    m_NextState = m_NextStateTbl[m_CurState][wSymbol];

    switch (m_NextState) 
        {
        // Chosung
        case 1 :    m_Chosung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jungsung
        case 2 : case 3 : case 6 : case 7 :
                    m_Jungsung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jongsung
        case 4 : case 5 :
                    m_Jongsung = Cho2Jong[m_wInternalCode & 0xFF];
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;

        case FINAL :
                    MakeComplete();
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case TAKEOVER :
                    pPrevInterim = InterimStack.Pop();
                    m_Chosung = pPrevInterim->m_wInternalCode & 0xFF;
                    pPrevInterim = InterimStack.Pop();
                    MakeComplete(pPrevInterim->m_wcCode);
                    m_CurState = 1;
                    // FIXED : should call MakeComposition() to push interim state
                    MakeComposition();    
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case FIND :
            switch (m_CurState) 
            {
            case 7 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jungsung = wFind;
                        m_CurState = 6;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else 
                        { 
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            
            case 3 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jungsung = wFind;
                        m_CurState = 2;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else 
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            
            case 5 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jongsung = wFind;
                        m_CurState = 4;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else  
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;

            // Only DJongsung case. same as case 5 except clearing chosung
            case 1: 
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Chosung = 0;
                        m_Jongsung = wFind;
                        m_CurState = 4;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else  
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            }
        }
    // impossible
    Assert(0);
    return HAUTO_IMPOSSIBLE;
}


///////////////////////////////////////////////////////////////////////////////
//    Transition table of 3 beolsik 390 hangul automata
const WORD CHangulAutomata3::m_NextStateTbl[11][6] = 
    {
        ////////////////////////////////////////////////////////////
        //    Sa        Sb        Va            Vb            Sc        Sd            State
        {     1,         2,        7,             8,             9,         10        },    // 0 : Start
        {    FINAL,    FINAL,    3,             4,            FINAL,    FINAL    },    // 1 : Chosung
        {    FINAL,    FIND,    3,             4,            FINAL,    FINAL    },    // 2 : Double Chosung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,         5,         6        },    // 3 : Jungsung
        {    FINAL,    FINAL,    FIND,        FINAL,         5,         6        },    // 4 : Double Jungsung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 5 : Jongsung
        {    FINAL,    FINAL,    FINAL,        FINAL,        FIND,    FIND    },    // 6 : Double Jongsung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 7 : Single Jungsung (without chosung)
        {    FINAL,    FINAL,    FIND,        FINAL,        FINAL,    FINAL    },    // 8 : Double Jungsung possible(without chosung)
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 9 : Single Jongsung(without chosung)
        {    FINAL,    FINAL,    FINAL,        FINAL,        FIND,    FIND    }    // 10 : Double Jongsung possible(without chosung)

    };
///////////////////////////////////////////////////////////////////////////////

HAutomataReturnState CHangulAutomata3::Input(WORD InternalCode)
{
    WORD wSymbol, wFind;
    InterimStackEntry*    pPrevInterim;

    // Check if hangul key
    if (!(InternalCode & H_HANGUL))
        return HAUTO_NONHANGULKEY;    // This keycode need not handled in automata.
                                    // Calling function should handle it properly.

    // Get internal code from keycode
    m_wInternalCode = InternalCode;
    wSymbol = (m_wInternalCode >> 8) & 0x7F;
    m_NextState = m_NextStateTbl[m_CurState][wSymbol];

    switch (m_NextState) 
        {
        // Chosung
        case 1 : case 2 :    
                    m_Chosung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jungsung
        case 3 : case 4 : case 7 : case 8 :
                    m_Jungsung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jongsung
        case 5 : case 6 : case 9 : case 10 :
                    m_Jongsung = m_wInternalCode & 0xFF;
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        case FINAL :
                    MakeComplete();
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case FIND :
            switch (m_CurState) 
            {
            case 8 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jungsung = wFind;
                        m_CurState = 7;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else 
                    { 
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 4 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jungsung = wFind;
                        m_CurState = 3;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else 
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 6 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jongsung = wFind;
                        m_CurState = 5;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 10 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jongsung = wFind;
                        m_CurState = 7;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;

            case 2 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindChosungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Chosung = wFind;
                        m_CurState = 1;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            }
        }

    // impossible
    Assert(0);
    return HAUTO_IMPOSSIBLE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Assume : Input wcComp has valid Unicode Hangul value
// (wcComp>0x3130 && wcComp<0x3164) || (wcComp>=0xAC00 && wcComp<0xD7A4)) 
//
BOOL CHangulAutomata3::SetCompositionChar(WCHAR wcComp)
{
    WORD wUnicodeHangulOffset;
    WORD wChosung;
    WORD wJungsung[2], wJongsung[2];

    wChosung = wJungsung[0] = wJungsung[1] = wJongsung[0] = wJongsung[1] = 0;
    InitState();

    if (wcComp <= UNICODE_HANGUL_COMP_JAMO_END && wcComp >= UNICODE_HANGUL_COMP_JAMO_START) 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_COMP_JAMO_START);
        
        // Consonant or vowel ?
        if (wcComp < UNICODE_HANGUL_COMP_JAMO_VOWEL_START) 
            {
            // Jongsung or Chosung ?
            if (CompJamoMapTable[wUnicodeHangulOffset][1]) 
                {
                wJongsung[0] = CompJamoMapTable[wUnicodeHangulOffset][0];
                SeparateDJong(wJongsung);
                }
            else 
                wChosung = CompJamoMapTable[wUnicodeHangulOffset][0];

            }
        else 
            {
            wJungsung[0] = wcComp - UNICODE_HANGUL_COMP_JAMO_VOWEL_START + 1;
            SeparateDJung(wJungsung);
            }
        } 
    else 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_BASE);
        wChosung = (WORD)( wUnicodeHangulOffset / 
                                    (NUM_OF_JONGSUNG*NUM_OF_JUNGSUNG)) + 1;

        wJungsung[0] = (WORD)(wUnicodeHangulOffset / NUM_OF_JONGSUNG
                                                        % NUM_OF_JUNGSUNG) + 1;
        SeparateDJung(wJungsung);

        wJongsung[0] = (WORD)(wUnicodeHangulOffset % NUM_OF_JONGSUNG);
        SeparateDJong(wJongsung);
        }

    ///////////////////////////////////////////////////////////////////////////
    // Push process
    if (wChosung) 
        {
        m_Chosung = m_wInternalCode = wChosung;
        // KiYeok, TiKeut, Pieup, Sios, Cieuc
        if (m_Chosung == _KIYEOK_ || m_Chosung == _TIKEUT_ 
           || m_Chosung == _PIEUP_|| m_Chosung == _SIOS_ || m_Chosung == _CIEUC_)
            m_CurState = 2; // Double Chosung possible state
        else
            m_CurState = 1; // Chosung state
        MakeComposition();
        }

    if (wJungsung[0]) 
        {
        m_Jungsung = m_wInternalCode  = wJungsung[0];
        if (m_Jungsung == _O_ || m_Jungsung == _U_ || m_Jungsung == _EU_) 
            m_CurState = 4; // Double Jungsung possible state
        else
            m_CurState = 3; // Single Jungsung state
        MakeComposition();
        }

    if (wJungsung[1]) 
        {
        Assert(wJungsung[0] == _O_|| wJungsung[0] == _U_ || wJungsung[0] == _EU_);
        m_wInternalCode = wJungsung[1];
        m_Jungsung = FindJunsungComb(wJungsung[0]);
        Assert(m_Jungsung);
        m_CurState = 3; // Jungsung state
        MakeComposition();
        }

    //
    if (wJongsung[0]) 
        {
        m_wInternalCode  = wJongsung[0];
        m_Jongsung = wJongsung[0];
        // KiYeok, Nieun, Rieul, Pieup and Sios: Double jongsong possible chars.
        if (m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_ || m_Jongsung == _JONG_SIOS_)
            m_CurState = 6; // Double Jongsung possible state
        else
            m_CurState = 5; // Single Jongsung state
        MakeComposition();
        }

    if (wJongsung[1]) 
        {
        Assert(m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_ || m_Jongsung == _JONG_SIOS_);

        m_wInternalCode = wJongsung[1];
        m_Jongsung = FindJonsungComb(wJongsung[0]);

        Assert(m_Jongsung);
        m_CurState = 5; // Jongsung state
        MakeComposition();
        }
    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\hauto.h ===
///////////////////////////////////////////////////////////////////////////////
// Hangul automata Class
//
// Author: cslim@microsoft.com

#if !defined (__HAUTOMATA_H__)
#define __HAUTOMATA_H__

// Number of each component
#define NUM_OF_CHOSUNG  19
#define NUM_OF_JUNGSUNG 21
#define NUM_OF_JONGSUNG 28

#define NUM_OF_DOUBLE_CHOSUNG   5
#define NUM_OF_DOUBLE_JUNGSUNG  7
#define NUM_OF_DOUBLE_JONGSUNG_2BEOL 11
#define NUM_OF_DOUBLE_JONGSUNG_3BEOL 13

#define UNICODE_HANGUL_BASE					0xAC00
#define UNICODE_HANGUL_END					0xD7A3
#define UNICODE_HANGUL_COMP_JAMO_START		0x3131
#define UNICODE_HANGUL_COMP_JAMO_VOWEL_START		0x314F
#define UNICODE_HANGUL_COMP_JAMO_END		0x3163
#define UNICODE_HANGUL_COMP_JAMO_START_FILL	0x3130
#define UNICODE_HANGUL_COMP_JAMO_SIOT		0x3145

///////////////////////////////////////////
// HANGUL Jaso inernal difinitions
// ChoSung
#define _KIYEOK_			1		// ''	
#define _SSANGKIYEOK_		2		// ''
#define _NIEUN_				3		// ''
#define _TIKEUT_			4		// ''
#define _SSANGTIKEUT_		5		// ''
#define _RIEUL_				6		// ''
#define _MIEUM_				7		// ''
#define _PIEUP_				8		// ''
#define _SSANGPIEUP_		9		// ''
#define _SIOS_				10		// ''
#define _SSANGSIOS_			11		// ''
#define _IEUNG_				12		// ''
#define _CIEUC_				13		// ''
#define _SSANGCIEUC_		14		// ''
#define _CHIEUCH_			15		// ''
#define _KHIEUKH_			16		// ''
#define _THIEUTH_			17		// ''
#define _PHIEUPH_			18		// ''
#define _HIEUH_				19		// ''

// JungSung
#define _A_					1		// ''
#define _AE_				2		// ''
#define _YA_				3		// ''
#define _YAE_				4		// ''
#define _EO_				5		// ''
#define _E_					6		// ''
#define _YEO_				7		// ''
#define _YE_				8		// ''
#define _O_					9		// ''
#define _WA_				10		// ''
#define _WAE_				11		// ''
#define _OE_				12		// ''
#define _YO_				13		// ''
#define _U_					14		// ''
#define _WEO_				15		// ''
#define _WE_				16		// ''
#define _WI_				17		// ''
#define _YU_				18		// ''
#define _EU_				19		// ''
#define _YI_				20		// ''
#define _I_					21		// ''
////////////////////////////////////////

// JongSung
#define _JONG_KIYEOK_			1		// ''	
#define _JONG_SSANGKIYEOK_		2		// ''
#define _JONG_KIYEOK_SIOS		3
#define _JONG_NIEUN_			4		// ''
#define _JONG_NIEUN_CHIEUCH_	5		// ''
#define _JONG_NIEUN_HIEUH_		6		// ''
#define _JONG_TIKEUT_			7		// ''
#define _JONG_RIEUL_			8		// ''
#define _JONG_RIEUL_KIYEOK_		9		// ''
#define _JONG_RIEUL_MIUM_		10		// ''
#define _JONG_RIEUL_PIEUP_		11		// ''
#define _JONG_RIEUL_SIOS_		12		// ''
#define _JONG_RIEUL_THIEUTH_	13		// ''
#define _JONG_RIEUL_PHIEUPH_	14		// ''
#define _JONG_RIEUL_HIEUH_		15		// ''
#define _JONG_MIEUM_			16		// ''
#define _JONG_PIEUP_			17		// ''
#define _JONG_PIEUP_SIOS		18		// ''
#define _JONG_SIOS_				19		// ''
#define _JONG_SSANGSIOS_		20		// ''
#define _JONG_IEUNG_			21		// ''
#define _JONG_CIEUC_			22		// ''
#define _JONG_CHIEUCH_			23		// ''
#define _JONG_KHIEUKH_			24		// ''
#define _JONG_THIEUTH_			25		// ''
#define _JONG_PHIEUPH_			26		// ''
#define _JONG_HIEUH_			27		// ''
//
const int MaxInterimStackSize = 6;		// Maximum stack size is 6.
										// At most 6 key input
										// to complete one Hangul Char.
										// ex) (3 beolsik)
enum HAutomataReturnState 
	{ 
	  HAUTO_NONHANGULKEY,
	  HAUTO_COMPOSITION,	// Hagul still in interim state.
	  HAUTO_COMPLETE,		// One hangul char completed and have chars 
							// will takeover as next input.
	  HAUTO_IMPOSSIBLE
	};

const WORD H_HANGUL = 0x8000;

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata Abstract Class
//
class CHangulAutomata
	{
public:
	CHangulAutomata() {	InitState(); }

// Attributes
public:

// Operations
public:
	void InitState() 
		{ 
		m_CurState = m_NextState = 0;
		m_wInternalCode = 0;
		m_Chosung = m_Jungsung = m_Jongsung = 0;
		m_wcComposition = m_wcComplete = L'\0';
		InterimStack.Init();
		}
	virtual HAutomataReturnState Machine(UINT KeyCode, int iShift) = 0;
	virtual BOOL IsInputKey(UINT KeyCode, int iShift) = 0;
	virtual BOOL IsHangulKey(UINT KeyCode, int iShift) = 0;
	virtual WORD GetKeyMap(UINT KeyCode, int iShift) = 0;
	virtual BOOL SetCompositionChar(WCHAR wcComp) = 0;
	
	static WORD GetEnglishKeyMap(UINT KeyCode, int iShift) { return bETable[KeyCode][iShift]; }
	BOOL BackSpace();
	BOOL MakeComplete();
	WCHAR GetCompositionChar() { return m_wcComposition; }
	WCHAR GetCompleteChar() { return m_wcComplete; }

// Implementation
public:
	virtual ~CHangulAutomata() {}

protected:
	void MakeComposition();
	BOOL MakeComplete(WORD wcComplete);
	WORD FindChosungComb(WORD wPrevCode);
	WORD FindJunsungComb(WORD wPrevCode);
	virtual WORD FindJonsungComb(WORD wPrevCode) = 0;
	void SeparateDJung(LPWORD pJungSung);
	void SeparateDJong(LPWORD pJongSung);

	virtual HAutomataReturnState Input(WORD InternalCode) = 0;
	//
	struct InterimStackEntry 
		{
		WORD	m_wInternalCode;
		WORD	m_CurState;
		WORD	m_Chosung, m_Jungsung, m_Jongsung;
		WCHAR	m_wcCode;
		};

	///////////////////////////////////////////////////////////////////////////
	//
	class CInterimStack 
		{
	protected:
		InterimStackEntry	m_StackBuffer[MaxInterimStackSize];	
		int	m_sp;		// Stack pointer

	public:
		CInterimStack() { m_sp = 0; }
		~CInterimStack() {}
		void Init() { m_sp = 0; }
		void Push(InterimStackEntry& InterimEntry);
		void Push(WORD wInternalCode, WORD CurState, 
				  WORD Chosung, WORD Jungsung, WORD Jongsung, WCHAR wcCode);

		InterimStackEntry* CInterimStack::Pop() 
			{
			Assert(m_sp > 0);
			return &m_StackBuffer[--m_sp];
			}

		InterimStackEntry* CInterimStack::GetTop() 
			{
			Assert(m_sp > 0);
			return &m_StackBuffer[m_sp-1];
			}

		BOOL IsEmpty() { return m_sp == 0; }
		};
	///////////////////////////////////////////////////////////////////////////
	CInterimStack InterimStack;

protected:
	WORD	m_CurState, m_NextState;
	WORD	m_wInternalCode, m_Chosung, m_Jungsung, m_Jongsung;
	WCHAR	m_wcComposition;
	WCHAR	m_wcComplete;
	//
	const static BYTE  bETable[256][2];
	const static BYTE  Cho2Jong[NUM_OF_CHOSUNG+1];
	const static BYTE  Jong2Cho[NUM_OF_JONGSUNG];
	};

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata2 Keyboard layout #1 (2 beolsik)
//
class CHangulAutomata2 : public CHangulAutomata
{
public:
	CHangulAutomata2() { }

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift);
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift);
	WORD GetKeyMap(UINT KeyCode, int iShift);
	BOOL SetCompositionChar(WCHAR wcComp);
	
// Implementation
public:
	~CHangulAutomata2() { }

protected:
	WORD FindJonsungComb(WORD wPrevCode);
	HAutomataReturnState Input(WORD InternalCode);
		
protected:
	// This enum should be matched with m_NextState
	// DO NOT change without changing _Transistion_state !
	enum _Transistion_state { FINAL=8, TAKEOVER=9, FIND=10 };
	static const WORD m_NextStateTbl[8][5];
	static const WORD H_CONSONANT, H_VOWEL, H_DOUBLE, H_ONLYCHO;
	static WORD wHTable[256][2];
	static BYTE  rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_2BEOL+1][3];
};


/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata3 Keyboard layout #2 (3 beolsik)
class CHangulAutomata3 : public CHangulAutomata
{
public:
	CHangulAutomata3() {}

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift);
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift);
	WORD GetKeyMap(UINT KeyCode, int iShift);
	BOOL SetCompositionChar(WCHAR wcComp);

// Implementation
public:
	~CHangulAutomata3() { }

protected:
	WORD FindJonsungComb(WORD wPrevCode);
	HAutomataReturnState Input(WORD InternalCode);
	
protected:
	enum _Transistion_state { FINAL=11, FIND=12 };
	static const WORD m_NextStateTbl[11][6];
	static const WORD H_CHOSUNG, H_JUNGSUNG, H_JONGSUNG, H_DOUBLE;
	static WORD wHTable[256][2];
	static BYTE  rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_3BEOL+1][3];
};

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata3 Keyboard layout #3 (3 beolsik final)
class CHangulAutomata3Final : public CHangulAutomata3
{
public:
	CHangulAutomata3Final() {}

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift) ;
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift); 
	WORD GetKeyMap(UINT KeyCode, int iShift);

// Implementation
public:
	~CHangulAutomata3Final() { }

protected:
	static WORD wHTable[256][2];
};

///////////////////////////////////////////////////////////////////////////////
// Inline functions

inline
void CHangulAutomata::CInterimStack::Push(InterimStackEntry& InterimEntry) 
	{
	Assert(m_sp<MaxInterimStackSize);
	m_StackBuffer[m_sp++] =  InterimEntry;
	}

inline
void CHangulAutomata::CInterimStack::Push(WORD wInternalCode, WORD CurState, 
				  WORD Chosung, WORD Jungsung, WORD Jongsung, WCHAR wcCode) 
	{
	Assert(m_sp<=5);
	m_StackBuffer[m_sp].m_wInternalCode =  wInternalCode;
	m_StackBuffer[m_sp].m_CurState =  CurState;
	m_StackBuffer[m_sp].m_Chosung =  Chosung;
	m_StackBuffer[m_sp].m_Jungsung =  Jungsung;
	m_StackBuffer[m_sp].m_Jongsung =  Jongsung;
	m_StackBuffer[m_sp++].m_wcCode =  wcCode;
	}

// CHangulAutomata2
inline
HAutomataReturnState CHangulAutomata2::Machine(UINT KeyCode, int iShift) 
	{
	return (Input(wHTable[KeyCode][iShift]));
	}

inline
BOOL CHangulAutomata2::IsInputKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata2::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata2::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}


// CHangulAutomata3
inline
HAutomataReturnState CHangulAutomata3::Machine(UINT KeyCode, int iShift) 
	{
	Assert(KeyCode<256);
	return (Input(wHTable[KeyCode][iShift]));
	}

inline
BOOL CHangulAutomata3::IsInputKey(UINT KeyCode, int iShift)
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata3::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata3::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return 0;
	}

// CHangulAutomata3Final
inline 
HAutomataReturnState CHangulAutomata3Final::Machine(UINT KeyCode, int iShift) 
	{
	Assert(KeyCode<256);
	return (Input(wHTable[KeyCode][iShift]));
	}

inline 
BOOL CHangulAutomata3Final::IsInputKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata3Final::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata3Final::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return 0;
	}

#endif // !defined (__HAUTOMATA_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\hanja.cpp ===
/****************************************************************************
    HANJA.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Hanja conversion and dictionary lookup functions. Dictionary index is 
    stored as globally shared memory.
    
    History:
    26-APR-1999 cslim       Modified for Multibox Applet Tooltip display
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "private.h"
#include "common.h"
#include "lexheader.h"
#include "hanja.h"
#include "gdata.h"
#include "immsec.h"
#include "osver.h"
#include "debug.h"

// NT5 Globally shared memory. 
const TCHAR IMEKR_SHAREDDATA_MUTEX[]            = TEXT("{C5AFBBF9-8383-490c-AA9E-4FE93FA05512}");
const TCHAR IMEKR_LEX_HANGUL2HANJA[]            = TEXT("ImeKrLexHangul2Hanja.SharedMemory");
const TCHAR IMEKR_LEX_HANJA2HANGUL[]            = TEXT("ImeKrLexHanjaToHangul.SharedMemory");


// Initial and grow clump size of HANJA_CAND_STRING_LIST's pointers
#define HANJA_LIST_PWSZ_INITIAL_SIZE        512
#define HANJA_LIST_PWSZ_CLUMP_SIZE            256

UINT   vuNumofK0=0, vuNumofK1=0;
WCHAR  vwcHangul=0;

// Private data
static BOOL   vfLexOpen = FALSE;
static HANDLE vhLex=0;
static HANDLE vhHangul2Hanja_IndexTbl=0;
static HANDLE vhHanja2Hangul_IndexTbl=0;
static DWORD  viBufferStart=0;    // seek point
static _DictHeader *vpLexHeader;

// Private functions
static BOOL OpenLex();
static INT SearchHanjaIndex(WCHAR wHChar, _LexIndex *pLexIndexTbl);
static INT SearchHanjaIndex(WCHAR wHChar, HanjaToHangulIndex *pLexIndexTbl);

BOOL EnsureHanjaLexLoaded()
{
    HKEY        hKey;
    DWORD         dwReadBytes;
    CHAR         szLexFileName[MAX_PATH], szLexPathExpanded[MAX_PATH];
    DWORD        dwCb, dwType;
    
    if (vfLexOpen)
        return TRUE;

    // Get Lex file path
    szLexFileName[0] = 0;
    szLexPathExpanded[0] = 0;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szIMERootKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        dwCb = sizeof(szLexFileName);
        dwType = REG_SZ;

        if (RegQueryValueEx(hKey, g_szDictionary, NULL, &dwType, (LPBYTE)szLexFileName, &dwCb) == ERROR_SUCCESS)
            ExpandEnvironmentStrings(szLexFileName, szLexPathExpanded, sizeof(szLexPathExpanded));
        RegCloseKey(hKey);
        }

    Assert(szLexPathExpanded[0] != 0);
    if (szLexPathExpanded[0] == 0)
        return fFalse;

    vhLex = CreateFile(szLexPathExpanded, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL);
    if (vhLex==INVALID_HANDLE_VALUE) 
        {
        Assert(0);
        return FALSE;
        }

    vpLexHeader = new _DictHeader;
    Assert(vpLexHeader);
    if (!vpLexHeader)
        return FALSE;

    if (ReadFile(vhLex, vpLexHeader, sizeof(_DictHeader), &dwReadBytes, 0) == 0 
        || (dwReadBytes != sizeof(_DictHeader)))
        {
        Assert(0);
        return FALSE;
        }

    // Set member vars
    //vuNumOfHangulEntry = pLexHeader->NumOfHangulEntry;
    //vuNumOfHanjaEntry  = pLexHeader->uiNumofHanja;
    //viBufferStart      = pLexHeader->iBufferStart;

    if (vpLexHeader->Version < LEX_VERSION || vpLexHeader->Version > LEX_COMPATIBLE_VERSION_LIMIT ) 
        {
        delete vpLexHeader;
        vpLexHeader = 0;
        Assert(0);
        return FALSE;
        }
        
    if (lstrcmpA(vpLexHeader->COPYRIGHT_HEADER, COPYRIGHT_STR)) 
        {
        delete vpLexHeader;
        vpLexHeader = 0;
        Assert(0);
        return FALSE;
        }

    return OpenLex();
}

__inline BOOL DoEnterCriticalSection(HANDLE hMutex)
{
    if(WAIT_FAILED==WaitForSingleObject(hMutex, 3000))    // Wait 3 seconds
        return(FALSE);
    return(TRUE);
}

BOOL OpenLex()
{
    BOOL                  fRet = FALSE;
    HANDLE                 hMutex;
    DWORD                 dwReadBytes;
    
    ///////////////////////////////////////////////////////////////////////////
    // Mapping Lex file
    // The dictionary index is shared data between all IME instance
    hMutex=CreateMutex(GetIMESecurityAttributes(), FALSE, IMEKR_SHAREDDATA_MUTEX);

    if (hMutex != NULL)
        {
        if (DoEnterCriticalSection(hMutex) == FALSE)
            goto ExitOpenLexCritSection;

        vhHangul2Hanja_IndexTbl = OpenFileMapping(FILE_MAP_READ, TRUE, IMEKR_LEX_HANGUL2HANJA);
        vhHanja2Hangul_IndexTbl = OpenFileMapping(FILE_MAP_READ, TRUE, IMEKR_LEX_HANJA2HANGUL);

        if (vhHangul2Hanja_IndexTbl && vhHanja2Hangul_IndexTbl)
            {
            TraceMsg(TF_GENERAL, "CHanja::OpenLex() - File mapping already exists");
            fRet = TRUE;
            }
        else
            {
            // if no file mapping exist
            vhHangul2Hanja_IndexTbl = CreateFileMapping(INVALID_HANDLE_VALUE, 
                                                GetIMESecurityAttributes(), 
                                                PAGE_READWRITE, 
                                                0,
                                                sizeof(_LexIndex)*(vpLexHeader->NumOfHangulEntry),
                                                IMEKR_LEX_HANGUL2HANJA);
                                                
            vhHanja2Hangul_IndexTbl = CreateFileMapping(INVALID_HANDLE_VALUE, 
                                                GetIMESecurityAttributes(), 
                                                PAGE_READWRITE, 
                                                0, 
                                                sizeof(HanjaToHangulIndex)*(vpLexHeader->uiNumofHanja),
                                                IMEKR_LEX_HANJA2HANGUL);
                
            if (vhHangul2Hanja_IndexTbl && vhHanja2Hangul_IndexTbl) 
                {
                _LexIndex     *pLexIndexTbl;
                HanjaToHangulIndex* pHanjaToHangulIndex;

                TraceMsg(TF_GENERAL, "CHanja::OpenLex() - File mapping Created");

                // Copy Hangul to Hanja index
                pLexIndexTbl = (_LexIndex*)MapViewOfFile(vhHangul2Hanja_IndexTbl, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
                if (!pLexIndexTbl)
                    goto ExitOpenLexCritSection;

                // Read Index table
                SetFilePointer(vhLex, vpLexHeader->Headersize, 0, FILE_BEGIN);    
                if (ReadFile(vhLex, pLexIndexTbl, vpLexHeader->NumOfHangulEntry*sizeof(_LexIndex), &dwReadBytes, 0) == 0
                    || dwReadBytes != vpLexHeader->NumOfHangulEntry*sizeof(_LexIndex))
                    {
                    UnmapViewOfFile(pLexIndexTbl);
                    goto ExitOpenLexCritSection;
                    }

                UnmapViewOfFile(pLexIndexTbl);

                // Copy Hanja to Hangul index
                pHanjaToHangulIndex = (HanjaToHangulIndex*)MapViewOfFile(vhHanja2Hangul_IndexTbl, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
                if (!pHanjaToHangulIndex)
                    goto ExitOpenLexCritSection;

                // Read Hanja to Hangul Index table
                SetFilePointer(vhLex, vpLexHeader->iHanjaToHangulIndex, 0, FILE_BEGIN);    
                if (ReadFile(vhLex, pHanjaToHangulIndex, sizeof(HanjaToHangulIndex)*(vpLexHeader->uiNumofHanja), &dwReadBytes, 0) == 0
                    || dwReadBytes != sizeof(HanjaToHangulIndex)*(vpLexHeader->uiNumofHanja))
                    {
                    UnmapViewOfFile(pLexIndexTbl);
                    goto ExitOpenLexCritSection;
                    }
                
                UnmapViewOfFile(pHanjaToHangulIndex);
                fRet = TRUE;
                }
                
        #ifdef DEBUG
            else
                Assert(0);
        #endif
            }
            
    ExitOpenLexCritSection:
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
        }
    
    FreeIMESecurityAttributes();

    vfLexOpen = fRet;
    return fRet;
}

BOOL CloseLex()
{
    //ClearHanjaSenseArray();
    
    if (vhHangul2Hanja_IndexTbl) 
        {
        CloseHandle(vhHangul2Hanja_IndexTbl);
        vhHangul2Hanja_IndexTbl = 0;
        }

    if (vhHanja2Hangul_IndexTbl) 
        {
        CloseHandle(vhHanja2Hangul_IndexTbl);
        vhHanja2Hangul_IndexTbl = 0;
        }

    if (vhLex) 
        {
        CloseHandle(vhLex);
        vhLex = 0;
        }

    if (vpLexHeader)
        {
        delete vpLexHeader;
        vpLexHeader = 0;
        }

    vfLexOpen =  FALSE;
    return TRUE;
}

/*---------------------------------------------------------------------------
    fInitHanjaStringList

    Allocate nested pointer of HANJA_CAND_STRING_LIST and initialize it.
------------------------------------------------------------------ CSLim -*/
BOOL fInitHanjaList(HANJA_CAND_STRING_LIST *pHanjaList, UINT uiNumofHanjaStr)
{
    Assert(pHanjaList != NULL);
    if ((pHanjaList->pwsz = (LPWSTR)cicMemAlloc(HANJA_LIST_PWSZ_INITIAL_SIZE*sizeof(WCHAR))) == 0)
        return fFalse;

    if ((pHanjaList->pHanjaString = (HANJA_CAND_STRING*)cicMemAlloc(
                                sizeof(HANJA_CAND_STRING)*uiNumofHanjaStr)) == 0)
        {
        cicMemFree(pHanjaList->pwsz);
        return fFalse;
        }

    pHanjaList->cchMac = 0; // Current chars used in pwsz (incl all trailing nulls) 
    pHanjaList->cchAlloc = HANJA_LIST_PWSZ_INITIAL_SIZE; // WCHAR size

    pHanjaList->csz = 0;
    pHanjaList->cszAlloc = uiNumofHanjaStr;
    
    return fTrue;
}

/*---------------------------------------------------------------------------
    fGrowHanjaList

    Reallocate nested pointer of HANJA_CAND_STRING_LIST after increasing the size
------------------------------------------------------------------ CSLim -*/
BOOL fGrowHanjaList(HANJA_CAND_STRING_LIST *pHanjaList)
{
    LPWSTR pwsz;
    
    TBOOL(pHanjaList != NULL);
    pwsz = (LPWSTR)cicMemReAlloc(pHanjaList->pwsz, 
                                (pHanjaList->cchAlloc+HANJA_LIST_PWSZ_CLUMP_SIZE)*sizeof(WCHAR));
    if (pwsz == NULL)
        return fFalse;

    if (pHanjaList->pwsz != pwsz)
        {
        INT_PTR offset = pwsz - pHanjaList->pwsz;
        for (UINT i=0; i<pHanjaList->csz; i++)
            pHanjaList->pHanjaString[i].wzMeaning += offset;
        }

    pHanjaList->pwsz = pwsz;
    pHanjaList->cchAlloc += HANJA_LIST_PWSZ_CLUMP_SIZE;

    return fTrue;
}


BOOL GetMeaningAndProunc(WCHAR wch, LPWSTR lpwstrTip, INT cchMax)
{
    HanjaToHangulIndex* pHanjaToHangulIndex;
    INT                 iMapHanjaInfo;
    WCHAR               wcHanja = 0;
    BYTE                cchMeaning = 0;
    WCHAR                wszMeaning[MAX_SENSE_LENGTH+1];
    DWORD                dwReadBytes;
    BOOL                   fRet = FALSE;

    TraceMsg(TF_GENERAL, "GetMeaningAndProunc");

    if (!EnsureHanjaLexLoaded()) 
        return FALSE;

    pHanjaToHangulIndex = (HanjaToHangulIndex*)MapViewOfFile(vhHanja2Hangul_IndexTbl, FILE_MAP_READ, 0, 0, 0);
    if (!pHanjaToHangulIndex) 
        {
        Assert(0);    
        return FALSE;
        }

    // Search index
    if ((iMapHanjaInfo = SearchHanjaIndex(wch, pHanjaToHangulIndex)) >= 0)
        {
        // Seek to mapping Hanja
        SetFilePointer(vhLex, vpLexHeader->iBufferStart + pHanjaToHangulIndex[iMapHanjaInfo].iOffset, 0, FILE_BEGIN);    

        // Read Hanja Info
        if (ReadFile(vhLex, &wcHanja, sizeof(WCHAR), &dwReadBytes, 0) == 0)
            goto LError;
        Assert(wch == wcHanja);
        if (ReadFile(vhLex, &cchMeaning, sizeof(BYTE), &dwReadBytes, 0) == 0)
            goto LError;
        if (wcHanja && (cchMeaning < MAX_SENSE_LENGTH*sizeof(WCHAR)))
            {
            if (cchMeaning)
                {
                if (ReadFile(vhLex, wszMeaning, cchMeaning, &dwReadBytes, 0) == 0)
                    goto LError;
                }
            wszMeaning[cchMeaning>>1] = L'\0';
            wsprintfW(lpwstrTip, L"%s %c\nU+%04X", wszMeaning, pHanjaToHangulIndex[iMapHanjaInfo].wchHangul, wch);
        
            fRet = TRUE;
            }
        else
            fRet = FALSE;
        }

LError:
    UnmapViewOfFile(pHanjaToHangulIndex);

    return fRet;
}


// For ImeConversionList.
BOOL GetConversionList(WCHAR wcReading, HANJA_CAND_STRING_LIST *pCandList)
    {
    _LexIndex   *pLexIndexTbl = NULL;
    INT         iMapCandStr;
    UINT        uNumOfCandStr;
    DWORD       cwch, readBytes;
    BYTE        senseLen;
    WCHAR       szSense[MAX_SENSE_LENGTH] = L"";
    CIMEData    ImeData;
    BOOL        fRet = fFalse;
    
    // Chcek validity of params
    Assert(wcReading != 0);
    Assert(pCandList != NULL);
    
    if (pCandList == NULL)
        goto ConversionExit1;

    if (!EnsureHanjaLexLoaded())
        return (0L);


    pLexIndexTbl = (_LexIndex*)MapViewOfFile(vhHangul2Hanja_IndexTbl, FILE_MAP_READ, 0, 0, 0);
    if (!pLexIndexTbl) 
        {
        Assert(0);    
        return (0L);
        }

    cwch = 0;

    if ((iMapCandStr = SearchHanjaIndex(wcReading, pLexIndexTbl)) < 0) 
        goto ConversionExit1;
    else
        {
        vuNumofK0 = pLexIndexTbl[iMapCandStr].wNumOfK0;

        if (ImeData->fKSC5657Hanja && !IsOn95())
            vuNumofK1 = pLexIndexTbl[iMapCandStr].wNumOfK1;
        else
            vuNumofK1 = 0;

        uNumOfCandStr = vuNumofK0 + vuNumofK1;
        if (uNumOfCandStr == 0)    // if no Hanja found
            goto ConversionExit1;

        if (!fInitHanjaList(pCandList, uNumOfCandStr))
            goto ConversionExit1;
        
        //cwch = uNumOfCandStr*2; // including NULL
                    
        //
        SetFilePointer(vhLex, vpLexHeader->iBufferStart + pLexIndexTbl[iMapCandStr].iOffset, 0, FILE_BEGIN);    

        for (UINT i = 0; i < uNumOfCandStr; i++)
            {
            WCHAR    wchHanja;

            if (ReadFile(vhLex, &wchHanja, sizeof(WCHAR), &readBytes, 0) == 0)
                goto ConversionExit1;

            //*lpwchCand++ = wchHanja;
            //*lpwchCand++ = L'\0';

            // Skip meaning
            if (ReadFile(vhLex, &senseLen, sizeof(BYTE), &readBytes, 0) == 0)
                goto ConversionExit1;
            if (senseLen && senseLen < MAX_SENSE_LENGTH*sizeof(WCHAR))
                {
                if (ReadFile(vhLex, szSense, senseLen, &readBytes, 0) == 0)
                    goto ConversionExit1;
                szSense[senseLen/2] = L' ';
                szSense[senseLen/2 + 1] = wcReading;
                szSense[senseLen/2 + 2] = L'\0';
                senseLen += 2*sizeof(WCHAR);
                }
            ///////////////////////////////////////////////////////////////////
            // Fill Hanja String List struct

            // Grow memory if neccessary
            if (pCandList->cchAlloc <= pCandList->cchMac + (senseLen/2))
                {
                TraceMsg(TF_GENERAL, "Try to grow pCandList");
                if (fGrowHanjaList(pCandList) == fFalse)
                    {
                    Assert(0);
                    goto ConversionExit1;
                    }
                }
                
            pCandList->pHanjaString[pCandList->csz].wchHanja = wchHanja;
            if (i < vuNumofK0)
                pCandList->pHanjaString[pCandList->csz].bHanjaCat = HANJA_K0;
            else
                pCandList->pHanjaString[pCandList->csz].bHanjaCat = HANJA_K1;

            if (senseLen)
                {
                pCandList->pHanjaString[pCandList->csz].wzMeaning = pCandList->pwsz + pCandList->cchMac;
                wcscpy(pCandList->pwsz + pCandList->cchMac, szSense);
                }
            else
                pCandList->pHanjaString[pCandList->csz].wzMeaning = L"";
                
            pCandList->csz++;
            pCandList->cchMac += (senseLen/2)+1;
            }
           fRet = fTrue;
        }


ConversionExit1:
    UnmapViewOfFile(pLexIndexTbl);

    return fRet;
}


INT SearchHanjaIndex(WCHAR wHChar, _LexIndex *pLexIndexTbl)
{
    int iHead = 0, iTail = vpLexHeader->NumOfHangulEntry-1, iMid;

    while (iHead <= iTail)
        {
        iMid = (iHead + iTail) >> 1;

        if (pLexIndexTbl[iMid].wcHangul > wHChar)
            iTail = iMid - 1;
        else 
            if (pLexIndexTbl[iMid].wcHangul < wHChar)
                iHead = iMid + 1;
            else 
                return (iMid);
        }

    return (-1);
}

INT SearchHanjaIndex(WCHAR wHChar, HanjaToHangulIndex *pLexIndexTbl)
{
    int iHead = 0, iTail = vpLexHeader->uiNumofHanja-1, iMid;

    while (iHead <= iTail)
        {
        iMid = (iHead + iTail) >> 1;

        TraceMsg(TF_GENERAL, "SearchHanjaIndex iMid=%d, pLexIndexTbl[iMid].wchHanja = 0x%04X", iMid, pLexIndexTbl[iMid].wchHanja);

        if (pLexIndexTbl[iMid].wchHanja > wHChar)
            iTail = iMid - 1;
        else 
            if (pLexIndexTbl[iMid].wchHanja < wHChar)
                iHead = iMid + 1;
            else 
                return (iMid);
        }

    return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\hjmode.h ===
//
// HJMODE.H
//

#if !defined (__HJMODE_H__INCLUDED_)
#define __HJMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class HJMode : public CCicButton
{
public:
    HJMode(CToolBar *ptb);
    ~HJMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    //HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);
    
private:

	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __HJMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\immsec.h ===
#if !defined (_IMMSEC_H__INCLUDED_)
#define _IMMSEC_H__INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif
PSECURITY_ATTRIBUTES CreateSecurityAttributes(VOID);
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa);
BOOL IsNT(VOID);
PSECURITY_ATTRIBUTES GetIMESecurityAttributes(VOID);
PSECURITY_ATTRIBUTES GetIMESecurityAttributesEx(VOID);
VOID FreeIMESecurityAttributes(VOID);
PSECURITY_ATTRIBUTES CreateSecurityAttributesEx(VOID);
PSID MyCreateSidEx(VOID);
#ifdef __cplusplus
}
#endif

#endif // !_IMMSEC_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\icpriv.cpp ===
//
// icpriv.cpp
//

#include "private.h"
#include "korimx.h"
#include "gdata.h"
#include "icpriv.h"
#include "helpers.h"
#include "funcprv.h"
#include "editcb.h"

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CICPriv::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CICPriv::AddRef()
{
    return ++m_cRef;
}

STDAPI_(ULONG) CICPriv::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CICPriv::CICPriv()
{
    m_fInitialized       = fFalse;
    m_pimx               = NULL;
    m_pic                = NULL;
    m_pActiveCompositon  = NULL;
#if 0
    m_pActiveRange       = NULL;
    m_pBackupRange       = NULL;
#endif
    m_pCompartmentSink   = NULL;
    m_guidMBias          = NULL;
    m_fTransaction       = fFalse;
    m_pMouseSink         = NULL;
    m_pIP                = NULL;
    m_fInitializedIPoint = fFalse;
    m_cRef               = 1;

    // initialize Shared memory. If this is only IME in the system
    // Shared memory will be created as file mapping object.
    //////////////////////////////////////////////////////////////////////
    m_pCIMEData = new CIMEData;
    Assert(m_pCIMEData != 0);
    if (m_pCIMEData)
        {
        m_pCIMEData->InitImeData();
        }

    //////////////////////////////////////////////////////////////////////////
    // Create All three IME Automata instances
    m_rgpHangulAutomata[KL_2BEOLSIK]        = new CHangulAutomata2;
    Assert(m_rgpHangulAutomata[KL_2BEOLSIK] != NULL);
    m_rgpHangulAutomata[KL_3BEOLSIK_390]   = new CHangulAutomata3;
    Assert(m_rgpHangulAutomata[KL_3BEOLSIK_390] != NULL);
    m_rgpHangulAutomata[KL_3BEOLSIK_FINAL] = new CHangulAutomata3Final;
    Assert(m_rgpHangulAutomata[KL_3BEOLSIK_FINAL] != NULL);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CICPriv::~CICPriv()
{
    if (m_pCIMEData)
        {
        delete m_pCIMEData;
        m_pCIMEData =  NULL;
        }

    // Delete Automata array
    for (INT i=0; i<NUM_OF_IME_KL; i++)
        {
        if (m_rgpHangulAutomata[i])
            delete m_rgpHangulAutomata[i];
        }
}

#if 0
/*---------------------------------------------------------------------------
    CKorIMX::_TextEventCallback
---------------------------------------------------------------------------*/
HRESULT CICPriv::_TextEventCallback(UINT uCode, VOID *pv, VOID *pvData)
{
    CICPriv            *picp = (CICPriv*)pv;
    CKorIMX            *pKorIMX;
    CEditSession2    *pes;
    ESSTRUCT          ess;
    ITfContext        *pic;
    BOOL             fInWriteSession;
    TESENDEDIT *pTESEndEdit = (TESENDEDIT*)pvData;
    IEnumTfRanges *pEnumText = NULL;
    HRESULT         hr;
    static const GUID *rgProperties[] = {     &GUID_PROP_TEXTOWNER, &GUID_PROP_LANGID,
                                            &GUID_PROP_ATTRIBUTE, /* &GUID_PROP_READING,*/
                                            &GUID_PROP_MODEBIAS };

    if (picp == NULL)
        return S_OK;

    pKorIMX = picp->GetIMX();
    if (pKorIMX == NULL) 
        return S_OK;

    if (uCode != ICF_TEXTDELTA)
        return S_OK;

    pic = picp->GetIC();

    pic->InWriteSession(pKorIMX->GetTID(), &fInWriteSession);
    if (fInWriteSession)
        return S_OK;                // own change.


    hr = pTESEndEdit->pEditRecord->GetTextAndPropertyUpdates(0 /*TF_GTP_INCL_TEXT*/, rgProperties, ARRAYSIZE(rgProperties), &pEnumText );

    if (FAILED(hr))
        return hr;
        
    if (pEnumText == NULL)
        return S_OK;

    ESStructInit(&ess, ESCB_TEXTEVENT);
    ess.pEnumRange = pEnumText;

    hr = E_OUTOFMEMORY;

    if (pes = new CEditSession2(pic, pKorIMX, &ess, CKorIMX::_EditSessionCallback2)) 
        {
         pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
        pes->Release();
        }

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\hjmode.cpp ===
/****************************************************************************
   HJMODE.CPP : HJMode class managing Hanja button on the Cicero Toolbar

   History:
      25-FEB-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "hjmode.h"
#include "userex.h"
#include "editcb.h"
#include "immxutil.h"
#include "helpers.h"
#include "resource.h"

// {61F9F0AA-3D61-4077-B177-43E1422D8348}
const GUID GUID_LBI_KORIMX_HJMODE = 
{
    0x61f9f0aa, 
    0x3d61, 
    0x4077, 
    { 0xb1, 0x77, 0x43, 0xe1, 0x42, 0x2d, 0x83, 0x48 }
};

/*---------------------------------------------------------------------------
    HJMode::HJMode
---------------------------------------------------------------------------*/
HJMode::HJMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    // Set Add/Remove text and tootip text
    LoadStringExW(g_hInst, IDS_TT_HANJA_CONV, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_KorIMX, 
                GUID_LBI_KORIMX_HJMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_TEXTCOLORICON, 
                120, 
                szText);
    SetToolTip(szText);

    // Set button text
    LoadStringExW(g_hInst, IDS_BUTTON_HANJA_CONV, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}


/*---------------------------------------------------------------------------
    HJMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) HJMode::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    HJMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI HJMode::GetIcon(HICON *phIcon)
{
    UINT uiIcon;
    
    if (IsHighContrastBlack())
        uiIcon = IDI_CMODE_HANJAW;
    else
        uiIcon = IDI_CMODE_HANJA;

    *phIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);

    return S_OK;
}

/*---------------------------------------------------------------------------
    HJMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI HJMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    HJMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI HJMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
    HJMode::OnLButtonUp
---------------------------------------------------------------------------*/
HRESULT HJMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    CEditSession2  *pes;
    ESSTRUCT        ess;
    ITfDocumentMgr *pdim;
    ITfContext     *pic;
    HRESULT         hr;

    pdim = m_pTb->m_pimx->GetDIM();
    if (pdim == NULL)
        {
        m_pTb->m_pimx->GetFocusDIM(&pdim);
        }

    Assert(pdim != NULL);

    if (pdim == NULL)
        {
        return E_FAIL;
        }
        
    GetTopIC(pdim, &pic);
    
    Assert(pic != NULL);
    if (pic == NULL)
        {
        return E_FAIL;
        }
    
    hr = E_OUTOFMEMORY;


    // If CandUI windows is not open, do Hanja conversion
    // Otherwise, send VK_ESCAPE to close Cand UI. (Office.net #141147)
    if (m_pTb->m_pimx->IsDisabledIC(pic) == fFalse)
        {
        ESStructInit(&ess, ESCB_HANJA_CONV);
        if (pes = new CEditSession2(pic, m_pTb->m_pimx, &ess, CKorIMX::_EditSessionCallback2))
            {
            pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
            pes->Release();
            }
        }
    else if (m_pTb->m_pimx->IsCandidateIC(pic))
        {
        keybd_event(VK_ESCAPE, 0, 0, 0);
        keybd_event(VK_ESCAPE, 0, KEYEVENTF_KEYUP, 0);
        }
    
    SafeRelease(pic);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\ic.cpp ===
//
// ic.cpp
//

#include "private.h"
#include "common.h"
#include "korimx.h"
#include "icpriv.h"
#include "ipointcic.h"
#include "cleanup.h"
#include "helpers.h"

//+---------------------------------------------------------------------------
//
// OnStartCleanupContext
//
//----------------------------------------------------------------------------

HRESULT CKorIMX::OnStartCleanupContext()
{
    // nb: a real tip, for performace, should skip input contexts it knows
    // it doesn't need a lock and callback on.  For instance, kimx only
    // cares about ic's with ongoing compositions.  We could remember which ic's
    // have compositions, then return FALSE for all but the ic's with compositions.
    // It is really bad perf to have the library make a lock request for every
    // ic!
    m_fPendingCleanup = fTrue;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnEndCleanupContext
//
// Called after all ic's with cleanup sinks have been called.
//----------------------------------------------------------------------------

HRESULT CKorIMX::OnEndCleanupContext()
{
    // our profile just changed or we are about to be deactivated
    // in either case we don't have to worry about anything interrupting ic cleanup
    // callbacks anymore
    m_fPendingCleanup = fFalse;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnCleanupContext
//
// This method is a callback for the library helper CleanupAllContexts.
// We have to be very careful here because we may be called _after_ this tip
// has been deactivated, if the app couldn't grant a lock right away.
//----------------------------------------------------------------------------

HRESULT CKorIMX::OnCleanupContext(TfEditCookie ecWrite, ITfContext *pic)
{
    // all kimx cares about is finalizing compositions
    CleanupAllCompositions(ecWrite, pic, CLSID_KorIMX, _CleanupCompositionsCallback, this);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ITfActiveLanguageProfileNotifySink::OnActivated
//
//----------------------------------------------------------------------------
STDAPI CKorIMX::OnActivated(REFCLSID clsid, REFGUID guidProfile, BOOL bActivated)
{
    // our profile just changed or we are about to be deactivated
    // in either case we don't have to worry about anything interrupting ic cleanup
    // callbacks anymore
    m_fPendingCleanup = fFalse;

    //if (IsSoftKbdEnabled())
    //    OnActivatedSoftKbd(bActivated);
        
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CleanupCompositionsCallback
//
//----------------------------------------------------------------------------

/* static */
void CKorIMX::_CleanupCompositionsCallback(TfEditCookie ecWrite, ITfRange *rangeComposition, void *pvPrivate)
{
    CKorIMX* pKorTip = (CKorIMX*)pvPrivate;
    ITfContext *pic;

    if (rangeComposition->GetContext(&pic) != S_OK)
        return;
        
    if (pKorTip)
        pKorTip->MakeResultString(ecWrite, pic, rangeComposition);
    // _FinalizeRange(ecWrite, pic, rangeComposition);

    pic->Release();
}

/*---------------------------------------------------------------------------
    CKorIMX::_InitICPriv

    Init IC private data
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_InitICPriv(ITfContext *pic)
{
    CICPriv *picp;
    CCompartmentEventSink* pCompartmentSink;
    ITfSourceSingle *pSourceSingle;
    TF_STATUS dcs;

    // Check pic
    if (pic == NULL)
        return E_FAIL;
    //
    // check enable/disable (Candidate stack)
    //
    if (IsDisabledIC(pic) || IsEmptyIC(pic))
        return S_OK;

    // Initialize Private data members
    if ((picp = GetInputContextPriv(pic)) == NULL)
        {
        IUnknown *punk;

        if ((picp = new CICPriv) == NULL)
               return E_OUTOFMEMORY;

        // IC
        picp->RegisterIC(pic);
        // IMX
        picp->RegisterIMX(this);

    	if (picp->IsInitializedIPoint() == FALSE)
    	    {
    		//struct _GUID RefID={0}; // dummy id
    		IImeIPoint1 *pIP;
            LPCIPointCic pCIPointCic = NULL;

            //////////////////////////////////////////////////////////////////////
            // Create IImeIPoint1 instance
            //////////////////////////////////////////////////////////////////////
            if ((pCIPointCic = new CIPointCic(this)) == NULL)
                {
                return E_OUTOFMEMORY;
                }

            // This increments the reference count
            if (FAILED(pCIPointCic->QueryInterface(IID_IImeIPoint1, (VOID **)&pIP)))
                {
                delete pCIPointCic;
                return E_OUTOFMEMORY;
                }

    		// initialize kernel
    		pCIPointCic->Initialize(pic);

    		// register ic depended objects.
    		picp->RegisterIPoint(pIP);
    		picp->InitializedIPoint(fTrue);
    	    }
    	
        //
        // text edit sink/edit transaction sink
        //
        ITfSource *pSource;
        DWORD dwCookieForTextEditSink = 0;
        //DWORD dwCookieForTransactionSink = 0;
        if (pic->QueryInterface(IID_ITfSource, (void **)&pSource ) == S_OK)
            {
            pSource->AdviseSink(IID_ITfTextEditSink, (ITfTextEditSink *)this, &dwCookieForTextEditSink);
            //pSource->AdviseSink(IID_ITfEditTransactionSink, (ITfEditTransactionSink *)this, &dwCookieForTransactionSink);

            pSource->Release();

            picp->RegisterCookieForTextEditSink(dwCookieForTextEditSink);
            //picp->RegisterCookieForTransactionSink(dwCookieForTransactionSink);
            }

        // compartment event sink
        if ((pCompartmentSink = new CCompartmentEventSink(_CompEventSinkCallback, picp)) != NULL )
            {
            picp->RegisterCompartmentEventSink(pCompartmentSink);

            // On/Off - compartment
            pCompartmentSink->_Advise(GetTIM(), GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, FALSE);
            
            // Conversion mode - compartment
            pCompartmentSink->_Advise(GetTIM(), GUID_COMPARTMENT_KORIMX_CONVMODE, FALSE);

            // SoftKeyboard Open/Close
            pCompartmentSink->_Advise(GetTIM(), GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE, FALSE);

            // Soft Keyboard layout change
            pCompartmentSink->_Advise(GetTIM(), GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, FALSE);
            }

        Assert(pCompartmentSink != NULL);

        if (pic->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
            {
            // setup a cleanup callback
            // nb: a real tip doesn't need to be this aggressive, for instance
                // kimx probably only needs this sink on the focus ic.
            pSourceSingle->AdviseSingleSink(GetTID(), IID_ITfCleanupContextSink, (ITfCleanupContextSink *)this);
            pSourceSingle->Release();
            }

        // Initialized kernel
        picp->Initialized(fTrue);

        // Set to compartment GUID
        GetCompartmentUnknown(pic, GUID_IC_PRIVATE, &punk);
        if (!punk)
            {
            SetCompartmentUnknown(GetTID(), pic, GUID_IC_PRIVATE, picp);
            picp->Release();
            }
        else
            {
            // Praive data already exist.
            punk->Release();
            return E_FAIL;
            }

        }

        // Set AIMM1.2
        picp->SetAIMM(fFalse);
        pic->GetStatus(&dcs);

        if (dcs.dwStaticFlags & TF_SS_TRANSITORY)
            picp->SetAIMM(fTrue);

    return S_OK;
}


/*---------------------------------------------------------------------------
    CKorIMX::_DeleteICPriv

    Delete IC private data
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_DeleteICPriv(ITfContext *pic)
{
    CICPriv        *picp;
    IUnknown        *punk;
    CCompartmentEventSink* pCompartmentSink;
    ITfSource         *pSource;
    ITfSourceSingle *pSourceSingle;
    
    if (pic == NULL)
        return E_FAIL;

    picp = GetInputContextPriv(pic);

#ifdef DBG
    Assert(IsDisabledIC(pic) || picp != NULL );
#endif
    
    if (picp == NULL)
         return S_FALSE;

    //
    // Compartment event sink
    //
    pCompartmentSink = picp->GetCompartmentEventSink();
    if (pCompartmentSink)
        {
        pCompartmentSink->_Unadvise();
        pCompartmentSink->Release();
        }

    //
    // text edit sink
    //
    if (pic->QueryInterface( IID_ITfSource, (void **)&pSource) == S_OK)
        {
        pSource->UnadviseSink(picp->GetCookieForTextEditSink());
        //pSource->UnadviseSink(picp->GetCookieForTransactionSink());
        pSource->Release();
        }
    picp->RegisterCookieForTextEditSink(0);

    // Clear ITfCleanupContextSink
    if (pic->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
        {
        pSourceSingle->UnadviseSingleSink(GetTID(), IID_ITfCleanupContextSink);
        pSourceSingle->Release();
        }

	// UnInitialize IPoint
	IImeIPoint1 *pIP = GetIPoint(pic);
	// IImeIPoint
	if (pIP)
	    {
		pIP->Release();
	    }
	picp->RegisterIPoint(NULL);
	picp->InitializedIPoint(fFalse);	// reset
	
    // Reset init flag
    picp->Initialized(fFalse);

    // We MUST clear out the private data before cicero is free 
    // to release the ic
    GetCompartmentUnknown(pic, GUID_IC_PRIVATE, &punk);
    if (punk)
        punk->Release();
    ClearCompartment(GetTID(), pic, GUID_IC_PRIVATE, fFalse);

    return S_OK;
}

/*---------------------------------------------------------------------------
    CKorIMX::GetInputContextPriv

    Get IC private data
---------------------------------------------------------------------------*/
CICPriv *CKorIMX::GetInputContextPriv(ITfContext *pic)
{
    IUnknown *punk;

    if (pic == NULL)
        return NULL;
        
    GetCompartmentUnknown(pic, GUID_IC_PRIVATE, &punk);

    if (punk)
        punk->Release();

    return (CICPriv *)punk;
}


/*---------------------------------------------------------------------------
    CKorIMX::OnICChange
---------------------------------------------------------------------------*/
void CKorIMX::OnFocusChange(ITfContext *pic, BOOL fActivate)
{
    BOOL fReleaseIC     = fFalse;
    BOOL fDisabledIC     = IsDisabledIC(pic);
    BOOL fEmptyIC         = IsEmptyIC(pic);
    BOOL fCandidateIC     = IsCandidateIC(pic);

    BOOL fInEditSession;
    HRESULT hr;

    if (fEmptyIC)
        {
        if (m_pToolBar)
            m_pToolBar->SetCurrentIC(NULL);

        if (IsSoftKbdEnabled())
            SoftKbdOnThreadFocusChange(fFalse);
        return;    // do nothing
        }
        
    if (fDisabledIC == fTrue && fCandidateIC == fFalse )
        {
        if (m_pToolBar)
            m_pToolBar->SetCurrentIC(NULL);

        if (IsSoftKbdEnabled())
            SoftKbdOnThreadFocusChange(fFalse);
        return;    // do nothing
        }

    // O10 #278261: Restore Soft Keyboard winfow after switched from Empty Context to normal IC.
    if (IsSoftKbdEnabled())
        SoftKbdOnThreadFocusChange(fActivate);

    // Notify focus change to IME Pad svr
	if (m_pPadCore)
	    {
		m_pPadCore->SetFocus(fActivate);
	    }

    // Terminate
    if (fActivate == fFalse)
        {
        if (!fDisabledIC && pic && GetIPComposition(pic))
            {
            if (SUCCEEDED(pic->InWriteSession(GetTID(), &fInEditSession)) && !fInEditSession)
                {
                CEditSession2 *pes;
                ESSTRUCT ess;

                ESStructInit(&ess, ESCB_COMPLETE);
                
                if ((pes = new CEditSession2(pic, this, &ess, _EditSessionCallback2)))
                       {
                    pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
                    pes->Release();
                    }
                }
            }

        // Close cand UI if opened.
        if (m_fCandUIOpen)
            CloseCandidateUIProc();
            
        return;
        }

    // fActivate == TRUE
    if (fDisabledIC)
        {
        pic = GetRootIC();
        fReleaseIC = fTrue;
        }

    if (m_pToolBar)
        m_pToolBar->SetCurrentIC(pic);

	if (m_pPadCore)
	    {
		IImeIPoint1* pIP = GetIPoint(pic);
		m_pPadCore->SetIPoint(pIP);
	    }

    if (pic && !fDisabledIC)
        {
        CICPriv *picp;

        // Sync GUID_COMPARTMENT_KEYBOARD_OPENCLOSE with GUID_COMPARTMENT_KORIMX_CONVMODE
        // This for Word now but looks not good since we don't sync On/Off status with conv mode.
        // In future Apps should set GUID_MODEBIAS_HANGUL on boot and should be Korean specific code. 
        if (GetConvMode(pic) == TIP_NULL_CONV_MODE) // if this is first boot.
            {
            if (IsOn(pic))
                SetCompartmentDWORD(GetTID(), GetTIM(), GUID_COMPARTMENT_KORIMX_CONVMODE, TIP_HANGUL_MODE, fFalse);
            else
                SetCompartmentDWORD(GetTID(), GetTIM(), GUID_COMPARTMENT_KORIMX_CONVMODE, TIP_ALPHANUMERIC_MODE, fFalse);
            }
        else
            {
            // Reset ModeBias
            picp = GetInputContextPriv(pic);
            if (picp)
                picp->SetModeBias(NULL);
            }

        // Modebias check here
        CheckModeBias(pic);
        }

    if (fReleaseIC)
        SafeRelease(pic);
}


// REVIEW::
// tmp solution
ITfContext* CKorIMX::GetRootIC(ITfDocumentMgr* pDim)
{
    if (pDim == NULL)
        {
        pDim = m_pCurrentDim;
        if( pDim == NULL )
            return NULL;
        }

    IEnumTfContexts *pEnumIc = NULL;
    if (SUCCEEDED(pDim->EnumContexts(&pEnumIc)))
        {
        ITfContext *pic = NULL;
        while (pEnumIc->Next(1, &pic, NULL) == S_OK)
            break;
        pEnumIc->Release();

        return pic;
        }
        
    return NULL;    // error case
}

IImeIPoint1* CKorIMX::GetIPoint(ITfContext *pic)
{
    CICPriv *picp;
    
    if (pic == NULL)
        {
        return NULL;
        }
    
    picp = GetInputContextPriv(pic);

    if (picp)
        {
        return picp->GetIPoint();
        }
    
    return NULL;
}
BOOL CKorIMX::IsDisabledIC(ITfContext *pic)
{
    DWORD dwFlag;

    if (pic == NULL)
        return fFalse;
           
    GetCompartmentDWORD(pic, GUID_COMPARTMENT_KEYBOARD_DISABLED, &dwFlag, fFalse);

    if (dwFlag)
        return fTrue;    // do not create any kernel related info into ic.
    else
        return fFalse;
}

/*   I S  E M P T Y   I  C   */
BOOL CKorIMX::IsEmptyIC(ITfContext *pic)
{
    DWORD dwFlag;
    
    if (pic == NULL)
        return fFalse;
    
    GetCompartmentDWORD(pic, GUID_COMPARTMENT_EMPTYCONTEXT, &dwFlag, fFalse);

    if (dwFlag)
        return fTrue;    // do not create any kernel related info into ic.

    return fFalse;
}

/*   I S  C A N D I D A T E  I  C   */
/*------------------------------------------------------------------------------

    Check if the input context is one of candidate UI

------------------------------------------------------------------------------*/
BOOL CKorIMX::IsCandidateIC(ITfContext *pic)
{
    DWORD dwFlag;
    
    if (pic == NULL) 
        return fFalse;
    
    GetCompartmentDWORD( pic, GUID_COMPARTMENT_KEYBOARD_DISABLED, &dwFlag, fFalse);

    if (dwFlag)
        return fTrue;    // do not create any kernel related info into ic.

    return fFalse;
}


HWND CKorIMX::GetAppWnd(ITfContext *pic)
{
    ITfContextView* pView;
    HWND hwndApp = 0;

    if (pic == NULL)
        return 0;

    pic->GetActiveView(&pView);
    if (pView == NULL)
        return 0;

    pView->GetWnd(&hwndApp);
    pView->Release();
    
    return hwndApp;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\init.h ===
//
// init.h
//

#ifndef INIT_H
#define INIT_H

#include "private.h"

BOOL DllInit(void);
void DllUninit(void);

#endif // INIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\icpriv.h ===
//
// ICPRIV.H  CICPriv class (TIP private data handling class)
//
//   History:
//      20-DEC-1999 CSLim Created


#ifndef __ICPRIV_H__INCLUDED_
#define __ICPRIV_H__INCLUDED_

#include "korimx.h"
#include "hauto.h"
#include "tes.h"
#include "gdata.h"

class CMouseSink;

class CICPriv : public IUnknown
{
public:
    CICPriv();
    ~CICPriv();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

// Operations
public:
	// Initialize
	void Initialized(BOOL fInit) { m_fInitialized = fInit; }
	BOOL IsInitialized()	     { return m_fInitialized;  }

	// CKorIMX
	void RegisterIMX(CKorIMX* pIMX)	 { m_pimx = pIMX; }
	CKorIMX* GetIMX()                { return m_pimx; }

	// IC
	void RegisterIC(ITfContext* pic) { m_pic = pic;   }
	ITfContext* GetIC(VOID)          { return m_pic;  }

	// Active composition
	void SetActiveComposition(ITfComposition *pComposition) { m_pActiveCompositon = pComposition; }
    ITfComposition* GetActiveComposition() { return m_pActiveCompositon; }

    //
    // Text edit sink cookie
    //
    VOID RegisterCookieForTextEditSink(DWORD dwCookie)  { m_dwCookieForTextEditSink = dwCookie; }
    DWORD GetCookieForTextEditSink()	 				{ return m_dwCookieForTextEditSink; }

    //
    // transaction sink cookie
    //
    VOID RegisterCookieForTransactionSink(DWORD dwCookie) 	{ m_dwCookieForTransactionSink = dwCookie; }
    DWORD GetCookieForTransactionSink()						{ return m_dwCookieForTransactionSink;     }

	// Text event sink
	void RegisterCompartmentEventSink(CCompartmentEventSink* pCompartmentSink) { m_pCompartmentSink = pCompartmentSink; }
	CCompartmentEventSink* GetCompartmentEventSink() 		   { return m_pCompartmentSink; }
	static HRESULT _TextEventCallback(UINT uCode, VOID *pv, VOID *pvData);

	// Set AIMM
	void SetAIMM(BOOL fAIMM)		{ m_fAIMM = fAIMM; }
	BOOL GetAIMM()					{ return m_fAIMM; }
	
	// Hangul Automata
    // void RegisterAutomata(CHangulAutomata *pHangulMachine) { m_pHangulMachine = pHangulMachine; }
	CHangulAutomata *GetAutomata();
	BOOL fGetK1HanjaOn();

	// Modebias
	TfGuidAtom GetModeBias() 				{ return m_guidMBias; }
    void SetModeBias(TfGuidAtom guidMBias) 	{ m_guidMBias = guidMBias; }

	BOOL GetfTransaction()			 { return m_fTransaction; }
	void SetfTransaction(BOOL ftran) { m_fTransaction = ftran; }

	// Mouse Sink
	void SetMouseSink(CMouseSink *pMouseSink) { m_pMouseSink = pMouseSink; }
	CMouseSink* GetMouseSink() 				  { return m_pMouseSink; }
	static HRESULT _MouseCallback(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten, void *pv);

    // IImePoint
    void RegisterIPoint(IImeIPoint1* pIP) { m_pIP = pIP; }
    IImeIPoint1* GetIPoint() { return m_pIP; }
	void InitializedIPoint(BOOL fInit)	{ m_fInitializedIPoint = fInit;	}
	BOOL IsInitializedIPoint()	{ return m_fInitializedIPoint; }
	
// Internal data
protected:
	BOOL m_fInitialized;
	// CKorIMX
	CKorIMX*  m_pimx;
	// Context
	ITfContext* m_pic;
	// Active composition
	ITfComposition* m_pActiveCompositon;
    // On/Off Compartment
    CCompartmentEventSink* m_pCompartmentSink;
	// AIMM
	BOOL m_fAIMM;
	// Hangul Automata object
	CHangulAutomata* m_rgpHangulAutomata[NUM_OF_IME_KL];

	// Shared memory for user setting.
	CIMEData* 	m_pCIMEData;

	// Modebias Atom
    TfGuidAtom m_guidMBias;

	DWORD m_dwCookieForTextEditSink;
	DWORD m_dwCookieForTransactionSink;

	// If in transaction
	BOOL m_fTransaction;

	// Mouse Sink
	CMouseSink *m_pMouseSink;

    // IImePoint for IME PAD
	IImeIPoint1 *m_pIP;
	BOOL m_fInitializedIPoint;
	
	// ref count
	LONG m_cRef;
};

//////////////////////////////////////////////////////////////////////////////
// Inline functions
inline
CHangulAutomata *CICPriv::GetAutomata()
{
	Assert(m_pCIMEData != NULL);
	if (m_pCIMEData && m_rgpHangulAutomata[m_pCIMEData->GetCurrentBeolsik()])
		return m_rgpHangulAutomata[m_pCIMEData->GetCurrentBeolsik()];
	else
		return NULL;
}

inline
BOOL CICPriv::fGetK1HanjaOn()
{
	if (m_pCIMEData && m_pCIMEData->GetKSC5657Hanja())
		return fTrue;
	else
		return fFalse;
}
#endif // __ICPRIV_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\ipointcic.cpp ===
/****************************************************************************
    IPOINT.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IImeIPoint1 interface
    
    History:
    24-OCT-2001 cslim       Branched for Cicero TIP PAD support
    20-JUL-1999 cslim       Created
*****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "ipointcic.h"
#include "editssn.h"
#include "imepad.h"    // IImeIPoint
#include "debug.h"

/*----------------------------------------------------------------------------
    CImeIPoint::CImeIPoint

    Ctor
----------------------------------------------------------------------------*/
CIPointCic::CIPointCic(CKorIMX *pImx)
{
    Assert(m_pImx != NULL);
    
    m_cRef          = 0;
    m_pImx          = pImx;
    m_pic           = NULL;
    m_dwCharNo      = 1;
}

/*----------------------------------------------------------------------------
    CImeIPoint::~CIPointCic

    Dtor
----------------------------------------------------------------------------*/
CIPointCic::~CIPointCic()
{
    SafeReleaseClear(m_pic);
}

/*----------------------------------------------------------------------------
    CImeIPoint::QueryInterface
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::QueryInterface(REFIID riid, LPVOID * ppv)
{
    if(riid == IID_IUnknown) 
        {
        TraceMsg(DM_TRACE, TEXT("IID_IUnknown\n"));
        *ppv = static_cast<IImeIPoint1 *>(this);
        }
    else 
    if(riid == IID_IImeIPoint1) 
        {
        TraceMsg(DM_TRACE, TEXT("IID_IImeIPoint1\n"));
        *ppv = static_cast<IImeIPoint1 *>(this);
        }
    else 
        {
        TraceMsg(DM_TRACE, TEXT("Unknown Interface ID\n"));
        *ppv = NULL;
        return E_NOINTERFACE;
        }

    // Increase ref counter
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();

    return S_OK;
}

/*----------------------------------------------------------------------------
    CImeIPoint::AddRef
----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CIPointCic::AddRef(VOID)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/*----------------------------------------------------------------------------
    CImeIPoint::Release
----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CIPointCic::Release(VOID)
{
    ULONG res = InterlockedDecrement((LPLONG)&m_cRef);
    if (res == 0L)
        delete this;
    return res;
}

/*----------------------------------------------------------------------------
    CImeIPoint::Initialize
----------------------------------------------------------------------------*/
HRESULT CIPointCic::Initialize(ITfContext *pic)
{
    SafeReleaseClear(m_pic);
    
	m_pic = pic;
	if (m_pic)
	    {
        m_pic->AddRef();
	    }

    return (S_OK);
}

#ifndef DEBUG
    #define DumpFEInfo    /##/
#else
/*----------------------------------------------------------------------------
    DumpFEInfo

    Dump LPIMEFAREASTINFO. Debug only
----------------------------------------------------------------------------*/
VOID DumpFEInfo(LPIMEFAREASTINFO lpInfo, INT count)
{
    TraceMsg(DM_TRACE, TEXT("DumpFEInfo Start\n"));
    TraceMsg(DM_TRACE, TEXT("lpInfo [0x%08x]\n"), lpInfo);
    TraceMsg(DM_TRACE, TEXT("lpInfo->dwSize [%d]\n"),     lpInfo->dwSize);
    TraceMsg(DM_TRACE, TEXT("lpInfo->dwType [0x%08x]\n"), lpInfo->dwType);

    LPWSTR lpwstr;

    switch(lpInfo->dwType) 
        {
    case IMEFAREASTINFO_TYPE_COMMENT:
        TraceMsg(DM_TRACE, TEXT("-->dwType is IMEFAREASTINFO_TYPE_COMMENT\n"));
        lpwstr = (LPWSTR)lpInfo->dwData;
        for(int i=0;i < count; i++) 
            {
            //DbgW(DBGID_IMEPAD, L"%d [%s]\n", i, lpwstr);
            lpwstr = lpwstr + lstrlenW(lpwstr)+1;
            }
        break;
        }


    TraceMsg(DM_TRACE, TEXT("DumpFEInfo End\n"));
}
#endif // _DEBUG

/*----------------------------------------------------------------------------
    CImeIPoint::InsertImeItem

    Multibox input call this method
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::InsertImeItem(IPCANDIDATE* pImeItem, INT iPos, DWORD *lpdwCharId)
{
    DWORD dwCharId;
    CEditSession2 *pes;
    ESSTRUCT ess;
    HRESULT hr;

    // Check Parameters
    Assert(pImeItem != NULL && pImeItem->dwSize > 0);
    
    if (pImeItem == NULL || pImeItem->dwSize <= 0 || m_pImx == NULL || m_pic == NULL)
        return S_FALSE;

    TraceMsg(DM_TRACE, TEXT("CImeIPoint::InsertImeItem\n"));
    TraceMsg(DM_TRACE, TEXT("pImeItem [0x%08x]\n"), pImeItem);
    TraceMsg(DM_TRACE, TEXT("pImeItem->dwSize    [%d]\n"), pImeItem->dwSize);
    TraceMsg(DM_TRACE, TEXT("pImeItem->iSelIndex [%d]\n"), pImeItem->iSelIndex);
    TraceMsg(DM_TRACE, TEXT("pImeItem->nCandidate[%d]\n"), pImeItem->nCandidate);
    TraceMsg(DM_TRACE, TEXT("pImeItem->dwPrivateDataOffset[%d]\n"), pImeItem->dwPrivateDataOffset);
    TraceMsg(DM_TRACE, TEXT("pImeItem->dwPrivateDataSize  [%d]\n"), pImeItem->dwPrivateDataSize);
    DumpFEInfo((LPIMEFAREASTINFO)((LPBYTE)pImeItem + pImeItem->dwPrivateDataOffset), pImeItem->nCandidate);

    TraceMsg(DM_TRACE, TEXT("lpdwCharId [0x%08x] [%d]\n"), lpdwCharId, lpdwCharId ? *lpdwCharId : 0xFFFFF);

    // Finalize current comp string
    ESStructInit(&ess, ESCB_COMPLETE);

    if ((pes = new CEditSession2(m_pic, m_pImx, &ess, CKorIMX::_EditSessionCallback2)))
        {
        pes->Invoke(ES2_READWRITE | ES2_SYNCASYNC, &hr);
        pes->Release();
        }

    ESStructInit(&ess, ESCB_INSERT_PAD_STRING);
    ess.wParam = *(LPWSTR)((PBYTE)pImeItem + pImeItem->dwOffset[0]);
           
    if ((pes = new CEditSession2(m_pic, m_pImx, &ess, CKorIMX::_EditSessionCallback2)))
        {
        pes->Invoke(ES2_READWRITE | ES2_SYNCASYNC, &hr);
        pes->Release();
        }

    // Increase Char serial number
    m_dwCharNo++;
    dwCharId = m_dwCharNo;
    if (lpdwCharId)
        {
        dwCharId |= ((*lpdwCharId) & (~ IPCHARID_CHARNO_MASK));
        *lpdwCharId = dwCharId;
        }

    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ReplaceImeItem
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::ReplaceImeItem(
    INT             iPos,       // = IPINS_CURRENT:use current IP position and 
                           //                  set IP to the end of insert chars.
                           // = 0-n: The offset of all composition string to set 
                           //         IP position, before insert chars. 
                           //         and IP back to original position.
    INT             iTargetLen, 
    IPCANDIDATE* pImeItem,
    DWORD         *lpdwCharId)
{
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::InsertStringEx
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::InsertStringEx(WCHAR* pwSzInsert, INT cchSzInsert, DWORD *lpdwCharId)
{
    DWORD dwCharId;
    CEditSession2 *pes;
    ESSTRUCT ess;
    HRESULT hr;
    
    TraceMsg(DM_TRACE, TEXT("CIPointCic::InsertStringEx : *pwSzInsert=0x%04X, cchSzInsert=%d, *lpdwCharId = 0x%04X"), *pwSzInsert, cchSzInsert, *lpdwCharId);

    // Check Parameters
    Assert(pwSzInsert != NULL && cchSzInsert > 0);
    
    if (pwSzInsert == NULL || cchSzInsert <= 0 || m_pImx == NULL || m_pic == NULL)
        return S_FALSE;

    // Finalize current comp string
    ESStructInit(&ess, ESCB_COMPLETE);

    if ((pes = new CEditSession2(m_pic, m_pImx, &ess, CKorIMX::_EditSessionCallback2)))
        {
        pes->Invoke(ES2_READWRITE | ES2_SYNCASYNC, &hr);
        pes->Release();
        }

    // Add all chars in string as finalized string
    for (INT i=0; i<cchSzInsert; i++)
        {
        ESStructInit(&ess, ESCB_INSERT_PAD_STRING);
        ess.wParam = *(pwSzInsert + i);
           
        if ((pes = new CEditSession2(m_pic, m_pImx, &ess, CKorIMX::_EditSessionCallback2)))
            {
            pes->Invoke(ES2_READWRITE | ES2_SYNCASYNC, &hr);
            pes->Release();
            }
    
        // Increase Char serial number
        m_dwCharNo++;
        dwCharId = m_dwCharNo;
        if (lpdwCharId)
            {
            dwCharId |= ((*lpdwCharId) & (~ IPCHARID_CHARNO_MASK));
            *lpdwCharId = dwCharId;
            }
        }


    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::DeleteCompString
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::DeleteCompString(INT    iPos,
                             INT    cchSzDel)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::DeleteCompString\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ReplaceCompString
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::ReplaceCompString(INT     iPos,
                                              INT        iTargetLen, 
                                              WCHAR    *pwSzInsert,
                                              INT        cchSzInsert,
                                              DWORD    *lpdwCharId)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::ReplaceCompString\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ControlIME
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::ControlIME(DWORD dwIMEFuncID, LPARAM lpara)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::ControlIME, dwIMEFuncID=0x%04X, lpara=0x%08lX\n"), dwIMEFuncID, lpara);

    // TODO:
    
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::GetAllCompositionInfo
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::GetAllCompositionInfo(WCHAR**    ppwSzCompStr,
                                  DWORD**    ppdwCharID,
                                  INT        *pcchCompStr,
                                  INT        *piIPPos,
                                  INT        *piStartUndetStrPos,
                                  INT        *pcchUndetStr,
                                  INT        *piEditStart,
                                  INT        *piEditLen)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::GetAllCompositionInfo START\n"));

    // Return nothing for now.
    if(ppwSzCompStr) 
        {
        *ppwSzCompStr = NULL;
        }
        
    if(ppdwCharID) 
        {
        *ppdwCharID = NULL;
        }
        
    *pcchCompStr = 0;
    *piIPPos     = 0;
    *piStartUndetStrPos = 0;
    *pcchUndetStr =0;
    *piEditStart = 0;
    *piEditLen = 0;
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::GetAllCompositionInfo END\n"));

    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::GetIpCandidate
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::GetIpCandidate(DWORD        dwCharId,
                           IPCANDIDATE **ppImeItem,
                           INT *        piColumn,
                           INT *        piCount)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::GetIpCandidate\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::SelectIpCandidate
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::SelectIpCandidate(DWORD dwCharId, INT iselno)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::SetIpCandidate\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::UpdateContext

    Update IME context and send it to the application
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::UpdateContext(BOOL fGenerateMessage)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::UpdateContext\n"));

    // TODO:
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\immsec.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    immsec.c

Abstract:

    security code called by IMEs 

Author:

    Chae Seong Lim [cslim] 23-Dec-1997
    Takao Kitano [takaok] 01-May-1996

Revision History:
    Chae Seong Lim [cslim] 971223 Korean IME version
    Hiroaki Kanokogi [hiroakik] 960624  Modified for MSIME96
    Hiroaki Kanokogi [hiroakik] 960911  NT #11911

--*/

#include "private.h"
#include "immsec.h"
#include "osver.h"

#define MEMALLOC(x)      LocalAlloc(LMEM_FIXED, x)
#define MEMFREE(x)       LocalFree(x)

//
// internal functions
//
PSID MyCreateSid( DWORD dwSubAuthority );

//
// debug functions
//
#ifdef DEBUG
#define ERROROUT(x)      ErrorOut( x )
#define WARNOUT(x)       WarnOut( x )
#else
#define ERROROUT(x) 
#define WARNOUT(x)       
#endif

#ifdef DEBUG
VOID WarnOut( PTSTR pStr )
{
    OutputDebugString( pStr );
}

VOID ErrorOut( PTSTR pStr )
{
    DWORD dwError;
    DWORD dwResult;
    static TCHAR buf1[512];
    static TCHAR buf2[512];

    dwError = GetLastError();
    dwResult = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwError,
                              MAKELANGID( LANG_ENGLISH, LANG_NEUTRAL ),
                              buf1,
                              512,
                              NULL );                                   
    
    if (dwResult > 0)
    {
        wsprintfA(buf2, "%s:%s(0x%x)", pStr, buf1, dwError);
    }
    else
    {
        wsprintfA(buf2, "%s:(0x%x)", pStr, dwError);
    }
    OutputDebugString( buf2 );
}
#endif


//
// GetIMESecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access to the following users:
//      
//          o Users who log on for interactive operation
//          o The user account used by the operating system
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeIMESecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//

static PSECURITY_ATTRIBUTES g_pSAIME = NULL;

PSECURITY_ATTRIBUTES GetIMESecurityAttributes(VOID)
{
    if (IsOnNT())
        return (g_pSAIME == NULL) ? (g_pSAIME = CreateSecurityAttributes()) : g_pSAIME;
    else
        return NULL;
}

//
// FreeIMESecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      GetIMESecurityAttributes() call.
//

VOID FreeIMESecurityAttributes()
{
    if (g_pSAIME != NULL)
        FreeSecurityAttributes(g_pSAIME);

    g_pSAIME = NULL;
}


//
// CreateSecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access to the following users:
//      
//          o Users who log on for interactive operation
//          o The user account used by the operating system
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//
PSECURITY_ATTRIBUTES CreateSecurityAttributes()
{
    PSECURITY_ATTRIBUTES psa;
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    ULONG                AclSize;

    PSID                 psid1, psid2, psid3, psid4;
    BOOL                 fResult;

    psid1 = MyCreateSid(SECURITY_INTERACTIVE_RID);
    if (psid1 == NULL)
        return NULL;

    psid2 = MyCreateSid(SECURITY_LOCAL_SYSTEM_RID);
    if (psid2 == NULL)
        goto Fail5;

    psid3 = MyCreateSid(SECURITY_SERVICE_RID);
    if (psid3 == NULL)
        goto Fail4;

    psid4 = MyCreateSid(SECURITY_NETWORK_RID);
    if (psid4 == NULL)
        goto Fail3;

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SIDs we've just created.
    //
    AclSize =  sizeof(ACL) + 
               (4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) + 
               GetLengthSid(psid1) + 
               GetLengthSid(psid2) + 
               GetLengthSid(psid3) + 
               GetLengthSid(psid4);

    pacl = (PACL)MEMALLOC(AclSize);
    if (pacl == NULL)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:LocalAlloc for ACL failed"));
        goto Fail2;
    }

    fResult = InitializeAcl(pacl, AclSize, ACL_REVISION);
    if (!fResult)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:InitializeAcl failed"));
        goto Fail;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid1);

    if (!fResult)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed"));
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid2);

    if (!fResult)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed"));
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid3);

    if (!fResult)
    {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                  ACL_REVISION,
                                  GENERIC_ALL,
                                  psid4);

    if (!fResult)
    {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        goto Fail;
    }

    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid(psid1);
    FreeSid(psid2);
    FreeSid(psid3);
    FreeSid(psid4);

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl))
    {
        WARNOUT(TEXT("CreateSecurityAttributes:IsValidAcl returns fFalse!"));
        MEMFREE(pacl);
        return NULL;
    }

    //
    // allocate security attribute
    //
    psa = (PSECURITY_ATTRIBUTES)MEMALLOC(sizeof(SECURITY_ATTRIBUTES));
    if (psa == NULL)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:LocalAlloc for psa failed"));
        MEMFREE(pacl);
        return NULL;
    }
    
    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC(SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (psd == NULL)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:LocalAlloc for psd failed"));
        MEMFREE(pacl);
        MEMFREE(psa);
        return NULL;
    }

    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
    {
        ERROROUT(TEXT("CreateSecurityAttributes:InitializeSecurityDescriptor failed"));
        MEMFREE(pacl);
        MEMFREE(psa);
        MEMFREE(psd);
        return NULL;
    }


    fResult = SetSecurityDescriptorDacl(psd, fTrue, pacl, fFalse );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if (!fResult)
    {
        ERROROUT(TEXT("CreateSecurityAttributes:SetSecurityDescriptorDacl failed"));
        MEMFREE(pacl);
        MEMFREE(psa);
        MEMFREE(psd);
        return NULL;
    } 

    if (!IsValidSecurityDescriptor(psd))
    {
        WARNOUT(TEXT("CreateSecurityAttributes:IsValidSecurityDescriptor failed!"));
        MEMFREE(pacl);
        MEMFREE(psa);
        MEMFREE(psd);
        return NULL;
    }

    //
    // everything is done
    //
    psa->nLength = sizeof(SECURITY_ATTRIBUTES);
    psa->lpSecurityDescriptor = (PVOID)psd;
    psa->bInheritHandle = fTrue;

    return psa;

Fail:
    MEMFREE(pacl);
Fail2:
    FreeSid(psid4);
Fail3:
    FreeSid(psid3);
Fail4:
    FreeSid(psid2);
Fail5:
    FreeSid(psid1);
    return NULL;
}

PSID MyCreateSid(DWORD dwSubAuthority)
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid(&SidAuthority,
                                       1,
                                       dwSubAuthority,
                                       0,0,0,0,0,0,0,
                                       &psid );
    if (!fResult)
    {
        ERROROUT(TEXT("MyCreateSid:AllocateAndInitializeSid failed"));
        return NULL;
    }

    if (!IsValidSid(psid))
    {
        WARNOUT(TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid(psid);
        return NULL;
    }

    return psid;
}

//
// FreeSecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      CreateSecurityAttributes() call.
//
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa )
{
    BOOL fResult;
    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    PACL pacl;

    fResult = GetSecurityDescriptorDacl(psa->lpSecurityDescriptor,
                                        &fDaclPresent,
                                        &pacl,
                                        &fDaclDefaulted);
    if (fResult)
    {

        if (pacl != NULL)
            MEMFREE(pacl);
    }
    else
    {
        ERROROUT( TEXT("FreeSecurityAttributes:GetSecurityDescriptorDacl failed") );
    }

    MEMFREE(psa->lpSecurityDescriptor);
    MEMFREE(psa);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\init.cpp ===
//
// init.cpp
//

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "osver.h"

DECLARE_OSVER();


//+---------------------------------------------------------------------------
//
// DllInit
//
// Called on our first CoCreate.  Use this function to do initialization that
// would be unsafe during process attach, like anything requiring a LoadLibrary.
//
//----------------------------------------------------------------------------
BOOL DllInit(void)
{
    BOOL fRet = TRUE;

    CicEnterCriticalSection(g_cs);

    if (g_cRefDll != 1)
        goto Exit;
        
    fRet = TFInitLib();

    InitOSVer();    

Exit:
    CicLeaveCriticalSection(g_cs);

    return fRet;
}

//+---------------------------------------------------------------------------
//
// DllUninit
//
// Called after the dll ref count drops to zero.  Use this function to do
// uninitialization that would be unsafe during process deattach, like
// FreeLibrary calls.
//
//----------------------------------------------------------------------------

void DllUninit(void)
{
    CicEnterCriticalSection(g_cs);

    if (g_cRefDll != 0)
        goto Exit;
        
    TFUninitLib();

Exit:
    CicLeaveCriticalSection(g_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\kimxatl.h ===
#ifndef _KIMXATL_H_
#define _KIMXATL_H_

#define _ATL_FREE_THREADED
#define _ATL_STATIC_REGISTRY
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "atlsub.h"

#endif //_KIMXATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\ipointcic.h ===
/****************************************************************************
	IPOINT.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IImeIPoint1 interface
	
	History:
	20-JUL-1999 cslim       Created
*****************************************************************************/

#if !defined(_IPOINT_H__INCLUDED_)
#define _IPOINT_H__INCLUDED_

class CKorIMX;

class CIPointCic : public IImeIPoint1
{
// Ctor and Dtor
public:
	CIPointCic(CKorIMX *pImx);
	~CIPointCic();

// IImePoint1 Methods
public:
	STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID * ppvObj);
	STDMETHODIMP_(ULONG) AddRef(VOID);
	STDMETHODIMP_(ULONG) Release(VOID);
	
	STDMETHODIMP InsertImeItem		(IPCANDIDATE* pImeItem, INT iPos, DWORD *lpdwCharId);
	STDMETHODIMP ReplaceImeItem		(INT iPos, INT iTargetLen, IPCANDIDATE* pImeItem, DWORD *lpdwCharId);
	STDMETHODIMP InsertStringEx		(WCHAR* pwSzInsert, INT cchSzInsert, DWORD *lpdwCharId);
	STDMETHODIMP DeleteCompString	(INT	iPos, INT cchSzDel);
	STDMETHODIMP ReplaceCompString	(INT	iPos,
									 INT	iTargetLen, 
									 WCHAR	*pwSzInsert, 
									 INT	cchSzInsert,
									 DWORD	*lpdwCharId);
	STDMETHODIMP ControlIME			(DWORD dwIMEFuncID, LPARAM lpara);
	STDMETHODIMP GetAllCompositionInfo(WCHAR	**ppwSzCompStr,
										DWORD	**ppdwCharID,
										INT		*pcchCompStr,
										INT		*piIPPos,
										INT		*piStartUndetStrPos,
										INT		*pcchUndetStr,
										INT		*piEditStart,
										INT		*piEditLen);
	STDMETHODIMP GetIpCandidate		(DWORD dwCharId,
										IPCANDIDATE **ppImeItem,
										INT *piColumn,
										INT *piCount);
	STDMETHODIMP SelectIpCandidate	(DWORD dwCharId, INT iselno);
	STDMETHODIMP UpdateContext		(BOOL fGenerateMessage);

// Helper functions
public:
	HRESULT Initialize(ITfContext *pic);

// Internal data
protected:
	CKorIMX    *m_pImx;
    ITfContext *m_pic;
	ULONG		m_cRef;			// Ref count

	// char serial number
	DWORD		m_dwCharNo;
};
typedef CIPointCic* LPCIPointCic;

#endif // _IPOINT_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\korimx.cpp ===
/****************************************************************************
   KORIMX.CPP : CKorIMX class implementation(TIP Main functions)

   History:
      15-NOV-1999 CSLim Created
****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "hanja.h"
#include "globals.h"
#include "immxutil.h"
#include "proputil.h"
#include "kes.h"
#include "helpers.h"
#include "editcb.h"
#include "timsink.h"
#include "icpriv.h"
#include "funcprv.h"
#include "fnrecon.h"
#include "dispattr.h"
#include "insert.h"
#include "statsink.h"
#include "mes.h"
#include "config.h"
#include "osver.h"

/*---------------------------------------------------------------------------
    CKorIMX::CKorIMX
    
    Ctor
---------------------------------------------------------------------------*/
CKorIMX::CKorIMX()
{
    extern void DllAddRef(void);

    // Init member vars
    m_pToolBar = NULL;
    m_pPadCore = NULL;
    
    m_pCurrentDim = NULL;
    m_ptim = NULL;
    m_tid = 0;
    m_ptimEventSink = NULL;
    m_pkes = NULL;
    
    m_hOwnerWnd  = 0;
    m_fKeyFocus  = fFalse;

    m_fPendingCleanup = fFalse;
    m_pFuncPrv        = NULL;
    m_pInsertHelper   = NULL;
    
    // Init Cand UI member vars
    m_pCandUI = NULL;
    m_fCandUIOpen = fFalse;

    // SoftKbd
    m_psftkbdwndes = NULL;
    m_pSoftKbd = NULL;
    m_fSoftKbdEnabled = fFalse;

    ZeroMemory(&m_libTLS, sizeof(m_libTLS));

    // Korean Kbd driver does not exist in system(Non Korean NT4, Non Korean WIN9X)
    m_fNoKorKbd = fFalse;

    m_fSoftKbdOnOffSave = fFalse;
    
    // Increase dll ref count
    DllAddRef();
    m_cRef = 1;
    
    ///////////////////////////////////////////////////////////////////////////
    // init CDisplayAttributeProvider
    //
    // Tip can add one or more TF_DISPLAYATTRIBUTE info here.
    //
    TF_DISPLAYATTRIBUTE dattr;
    StringCchCopyW(szProviderName, ARRAYSIZE(szProviderName), L"Korean Keyboard TIP");
        
    // Input string attr
       dattr.crText.type = TF_CT_NONE;
    dattr.crText.nIndex = 0;
    dattr.crBk.type = TF_CT_NONE;
    dattr.crBk.nIndex = 0;
    dattr.lsStyle = TF_LS_NONE;
    dattr.fBoldLine = fFalse;
    ClearAttributeColor(&dattr.crLine);
    dattr.bAttr = TF_ATTR_INPUT;
    Add(GUID_ATTR_KORIMX_INPUT, L"Korean TIP Input String", &dattr);
}

/*---------------------------------------------------------------------------
    CKorIMX::~CKorIMX
    
    Dtor
---------------------------------------------------------------------------*/
CKorIMX::~CKorIMX()
{
    extern void DllRelease(void);

    if (IsSoftKbdEnabled())
        TerminateSoftKbd();

    DllRelease();
}


/*---------------------------------------------------------------------------
    CKorIMX::CreateInstance
    
    Class Factory's CreateInstance
---------------------------------------------------------------------------*/
/* static */
HRESULT CKorIMX::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    HRESULT hr;
    CKorIMX *pimx;

    TraceMsg(DM_TRACE, TEXT("CKorIMX_CreateInstance called."));

    *ppvObj = NULL;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    pimx = new CKorIMX;

    if (pimx == NULL)
        return E_OUTOFMEMORY;

    hr = pimx->QueryInterface(riid, ppvObj);
    pimx->Release();

    return hr;
}

/*---------------------------------------------------------------------------
    CKorIMX::QueryInterface
---------------------------------------------------------------------------*/
STDAPI CKorIMX::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfTextInputProcessor))
        {
        *ppvObj = SAFECAST(this, ITfTextInputProcessor *);
        }
    else if (IsEqualIID(riid, IID_ITfDisplayAttributeProvider))
        {
        *ppvObj = SAFECAST(this, ITfDisplayAttributeProvider *);
        }
    else if (IsEqualIID(riid, IID_ITfThreadFocusSink))
        {
        *ppvObj = SAFECAST(this, ITfThreadFocusSink *);
        }
    else if(IsEqualIID(riid, IID_ITfFnConfigure))
        {
        *ppvObj = SAFECAST(this, ITfFnConfigure *);
        }
    else if(IsEqualIID(riid, IID_ITfCleanupContextSink))
        {
        *ppvObj = SAFECAST(this, ITfCleanupContextSink *);
        }
    else if(IsEqualIID(riid, IID_ITfActiveLanguageProfileNotifySink))
        {
        *ppvObj = SAFECAST(this, ITfActiveLanguageProfileNotifySink *);
        }
    else if(IsEqualIID(riid, IID_ITfTextEditSink))
        {
        *ppvObj = SAFECAST(this, ITfTextEditSink *);
        }
    else if( IsEqualIID(riid, IID_ITfEditTransactionSink ))
        {
		*ppvObj = SAFECAST(this, ITfEditTransactionSink* );
        }
    
    if (*ppvObj == NULL)
        {
        return E_NOINTERFACE;
        }

    AddRef();
    return S_OK;
}

/*---------------------------------------------------------------------------
    CKorIMX::AddRef
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CKorIMX::AddRef()
{
    m_cRef++;
    return m_cRef;
}

/*---------------------------------------------------------------------------
    CKorIMX::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CKorIMX::Release()
{
    m_cRef--;

    if (0 < m_cRef)
        return m_cRef;

    delete this;
    return 0;    
}

/*---------------------------------------------------------------------------
    CKorIMX::_KeyEventCallback
    
    ITfKeyEventSink call this function back whenever keyboard event occurs
    or test key down and up.
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_KeyEventCallback(UINT uCode, ITfContext *pic, 
                                   WPARAM wParam, LPARAM lParam, BOOL *pfEaten, void *pv)
{
    CKorIMX             *pimx;
    CEditSession2         *pes;
    ESSTRUCT             ess;
    BYTE                 abKeyState[256];
    UINT                 uVKey = (UINT)LOWORD(wParam);
    HRESULT             hr;

    Assert(pv != NULL);
    
    pimx = (CKorIMX *)pv;
    if (pimx == NULL)
        {
        return E_FAIL;
        }

    // !!! IME or Tip switched !!!
    // if ITfKeyEventSink->OnSetFocus called
    if (uCode == KES_CODE_FOCUS)
        {
        // wParam: fForeground
        if (!wParam && pic && pimx->GetIPComposition(pic))
            {
            ESStructInit(&ess, ESCB_COMPLETE);

            // clear display attribute only if current composition exits
            if (pes = new CEditSession2(pic, pimx, &ess, CKorIMX::_EditSessionCallback2))
                {
                pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
                pes->Release();
                }
            if (pimx->m_pToolBar != NULL)
                {
                pimx->m_pToolBar->Update(UPDTTB_ALL);
                }
            }

        pimx->m_fKeyFocus = (BOOL)wParam;

        return S_OK;
        }

    // Set default return values
    *pfEaten = fFalse;     // Default is not eaten
    hr = S_OK;

    if (pic == NULL)
        goto ExitKesCallback;

    // Do not process shift and ctrl key
    if (uVKey == VK_SHIFT || uVKey == VK_CONTROL)
        goto ExitKesCallback;

    // Off 10 #127987
    // NT4 workaround: NT4 IMM does not send WM_KEYDOWN::VK_HANGUL to application message queue.
    // Unfortunately VK_JUNJA sent as WM_SYSKEYDOWN/UP, so it's useless check here.
    if (IsOnNT() && !IsOnNT5())
        {
        if ((UINT)LOWORD(wParam) == VK_HANGUL /* || (UINT)LOWORD(wParam) == VK_JUNJA*/)
            goto AcceptThisKey;
        }

    // Ignore all Key up message
    if ((uCode & KES_CODE_KEYDOWN) == 0)
        goto ExitKesCallback;

AcceptThisKey:
    if (GetKeyboardState(abKeyState) == fFalse)
        goto ExitKesCallback;
    
    // Ignore all key events while candidate UI is opening except cand keys.
    // Added Alt check: Bug #525842 - If Alt key pressed, always complete current interim.
    //                                This will be handled in the _IsKeyEaten function.
    if (pimx->IsDisabledIC(pic) && !IsAltKeyPushed(abKeyState))
        {
        if (!IsCandKey(wParam, abKeyState))
            *pfEaten = fTrue;
        goto ExitKesCallback;
        }

    // Check if we need to handle this key
    if (pimx->_IsKeyEaten(pic, pimx, wParam, lParam, abKeyState) == fFalse)
        goto ExitKesCallback;

    // if key is eaten
    // ITfKeyEventSink->TestKeyDown sets (KES_CODE_KEYDOWN | KES_CODE_TEST)
    // ITfKeyEventSink->TestKeyUp   sets (KES_CODE_KEYUP   | KES_CODE_TEST)
    // Response only for OnKeyDown and OnKeyUp
    if ((uCode & KES_CODE_TEST) == 0)
        {
        ESStructInit(&ess, ESCB_KEYSTROKE);

        ess.wParam = wParam;
        ess.lParam = lParam;
        ess.pv1 = abKeyState;
            
        if (pes = new CEditSession2(pic, pimx, &ess, CKorIMX::_EditSessionCallback2))
            {
            pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
            pes->Release();
            }
        }

    if (hr == S_OK)
        *pfEaten = fTrue;

ExitKesCallback:
    return hr;
}

/*---------------------------------------------------------------------------
    CKorIMX::GetIC
    
    Get the input context at the top of the stack
---------------------------------------------------------------------------*/
ITfContext *CKorIMX::GetIC()
{
    ITfContext     *pic = NULL;
    ITfDocumentMgr *pdim = NULL;

    if (m_ptim == 0)
        {
        Assert(0);
        return NULL;
        }
        
    if (SUCCEEDED(m_ptim->GetFocus(&pdim)) && pdim)
        {
        pdim->GetTop(&pic);
        pdim->Release();
        }

    return pic;
}


/*---------------------------------------------------------------------------
    CKorIMX::SetConvMode
---------------------------------------------------------------------------*/
DWORD CKorIMX::SetConvMode(ITfContext *pic, DWORD dwConvMode)
{
    DWORD dwCurConvMode = GetConvMode(pic);

    if (dwConvMode == dwCurConvMode)
        return dwConvMode;
        
    SetCompartmentDWORD(m_tid, GetTIM(), GUID_COMPARTMENT_KORIMX_CONVMODE, dwConvMode, fFalse);

    // SoftKeyboard
    if (IsSoftKbdEnabled())
        {
        DWORD dwSoftKbdLayout, dwNewSoftKbdLayout;
        
        dwSoftKbdLayout = GetSoftKBDLayout();
        
        if (dwConvMode & TIP_HANGUL_MODE)
            dwNewSoftKbdLayout = m_KbdHangul.dwSoftKbdLayout;
        else
            dwNewSoftKbdLayout = m_KbdStandard.dwSoftKbdLayout;
        
        if (dwSoftKbdLayout != dwNewSoftKbdLayout)
            SetSoftKBDLayout(dwNewSoftKbdLayout);
        }

    // if Comp string exist, finalize it.
    if (GetIPComposition(pic))
        {
        CEditSession2 *pes;
        ESSTRUCT        ess;
        HRESULT        hr;

        hr = E_OUTOFMEMORY;

        ESStructInit(&ess, ESCB_COMPLETE);

        if (pes = new CEditSession2(pic, this, &ess, CKorIMX::_EditSessionCallback2))
            {
            // Word will not allow synchronous lock at this point.
            pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
            pes->Release();
            }
        }

    return dwConvMode;
}

/*---------------------------------------------------------------------------
    CKorIMX::_IsKeyEaten
    
    Return fTrue if this key need to be eaten
---------------------------------------------------------------------------*/
BOOL CKorIMX::_IsKeyEaten(ITfContext *pic, CKorIMX *pimx, WPARAM wParam, LPARAM lParam, const BYTE abKeyState[256])
{
    CHangulAutomata     *pAutomata;
    BOOL fCompStr       = fFalse;
    UINT uVKey          = (UINT)LOWORD(wParam);
    CEditSession2       *pes;
    ESSTRUCT            ess;

    // Hangul and Junja key
    if (uVKey == VK_HANGUL || uVKey == VK_JUNJA)
        return fTrue;

    // Hanja key
    if (uVKey == VK_HANJA)
        {
        CICPriv *picp;
        
        if ((picp = GetInputContextPriv(pic)) == NULL)
            {
            Assert(0);
            return fTrue;
            }

        // Do not eat VK_HANJA for AIMM 1.2 IME_HANJAMODE .
        if (picp->GetAIMM() && GetIPComposition(pic) == NULL)
            return fFalse;
        else
            return fTrue;
        }
    
    // if Tip is off do nothing
    if (IsOn(pic) == fFalse || GetConvMode(pic) == TIP_ALPHANUMERIC_MODE)
        return fFalse;

    // Should handle Backspace in interim state
    if (uVKey == VK_BACK)
        {
        if (GetIPComposition(pic))
            return fTrue;
        else
            return fFalse;
        }

    // Get Hangul Automata
    if ((pAutomata = GetAutomata(pic)) == NULL)
        return fFalse;

    // Alt+xx or Ctrl+xx processing. TIP should not eat.
    // Ctrl or Alt pushed with other key and comp str exist we should eat and complete the comp str.
    if (IsAltKeyPushed(abKeyState) || IsControlKeyPushed(abKeyState))
        {
        pAutomata->MakeComplete();
        }
    else
        {
        DWORD dwConvMode = GetConvMode(pic);

        // If Hangul mode
        if (dwConvMode & TIP_HANGUL_MODE) 
            {    
            // Start of hangul composition
            WORD     wcCur;
            CIMEData ImeData;

            wcCur = pAutomata->GetKeyMap(uVKey, IsShiftKeyPushed(abKeyState) ? 1 : 0 );
            // 2beolsik Alphanumeric keys have same layout as English key
            // So we don't need process when user pressed Alphanumeric key under 2beolsik
            if ((wcCur && ImeData.GetCurrentBeolsik() != KL_2BEOLSIK) || (wcCur & H_HANGUL) )
                return fTrue;
            }

        // if IME_CMODE_FULLSHAPE
        if (dwConvMode & TIP_JUNJA_MODE) 
            {
            if (CHangulAutomata::GetEnglishKeyMap(uVKey, IsShiftKeyPushed(abKeyState) ? 1 : 0))
                return fTrue;
            }        
        }

    //
    // Skipped all key matching condition mean this is no handle key.
    // We just complete current composition if exist.
    //
    if (GetIPComposition(pic) != NULL)
        {
        // No need to handle this key for current Automata.
        // Complete composition, if exist.
        ESStructInit(&ess, ESCB_COMPLETE);
        HRESULT hr;
        
           // Complete current comp char if exist
        if ((pes = new CEditSession2(pic, pimx, &ess, CKorIMX::_EditSessionCallback2)) == NULL)
            return fFalse;

        pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
        pes->Release();
        }

    return fFalse;
}


/*----------------------------------------------------------------------------
    Banja2Junja

    Convert Ascii Half shape to Full shape character
----------------------------------------------------------------------------*/
/* static */
WCHAR CKorIMX::Banja2Junja(WCHAR bChar) 
{
    WCHAR wcJunja;

    if (bChar == L' ')
        wcJunja = 0x3000;    // FullWidth space
    else 
        if (bChar == L'~')
            wcJunja = 0xFF5E;
        else
            if (bChar == L'\\')
                wcJunja = 0xFFE6;   // FullWidth WON sign
            else
                   wcJunja = 0xFF00 + (WORD)(bChar - (BYTE)0x20);

    return wcJunja;
}

/*---------------------------------------------------------------------------
    CKorIMX::_Keystroke
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_Keystroke(TfEditCookie ec, ITfContext *pic, WPARAM wParam, LPARAM lParam, 
                        const BYTE abKeyState[256])
{
    ITfRange *pSelection = NULL;
    WORD  wVKey = LOWORD(wParam) & 0x00FF;
    DWORD dwConvMode;
    HRESULT hResult = S_OK;
    
    // find the extent of the comp string
    if (GetSelectionSimple(ec, pic, &pSelection) != S_OK)
        {
        hResult = S_FALSE;
        goto Exit;
        }

    dwConvMode = GetConvMode(pic);
    
    switch (wVKey)
        {
    case VK_HANGUL:
        dwConvMode ^= TIP_HANGUL_MODE;
        SetConvMode(pic, dwConvMode);
        break;
        
    case VK_JUNJA:
        dwConvMode ^= TIP_JUNJA_MODE;
        SetConvMode(pic, dwConvMode);
        break;

    case VK_HANJA:
        if (GetIPComposition(pic))
            DoHanjaConversion(ec, pic, pSelection);
        else
            Reconvert(pSelection);
        // Update Hanja button
        if (m_pToolBar != NULL)
            {
            m_pToolBar->Update(UPDTTB_HJMODE);
            }
        break;
        
    default:
        ///////////////////////////////////////////////////////////////////////////
        // Run Hangul Automata
        if (dwConvMode & TIP_HANGUL_MODE)
            {
            HAutoMata(ec, pic, pSelection, (LPBYTE)abKeyState, wVKey);
            }
        else
        if (dwConvMode & TIP_JUNJA_MODE) // Junja handling
            {
            WCHAR pwchKeyCode[2];

            // Numeric or English key?
            if (pwchKeyCode[0] = CHangulAutomata::GetEnglishKeyMap(wVKey, (abKeyState[VK_SHIFT] & 0x80) ? 1:0))
                {
                if (wVKey >= 'A' && wVKey <= 'Z') 
                    {
                    pwchKeyCode[0] = CHangulAutomata::GetEnglishKeyMap(wVKey, (abKeyState[VK_SHIFT] & 0x80) ? 1:0 ^ ((abKeyState[VK_CAPITAL] & 0x01) ? 1:0));
                    }

                // Get Junja code
                pwchKeyCode[0] = Banja2Junja(pwchKeyCode[0]);
                pwchKeyCode[1] = L'\0';

                // Finalize a Junja char
                if (SUCCEEDED(SetInputString(ec, pic, pSelection, pwchKeyCode, GetLangID())))
                    MakeResultString(ec, pic, pSelection);
                }
            }
        break;        
        }

Exit:
    if (pSelection)
        pSelection->Release();

    return hResult;
}


/*---------------------------------------------------------------------------
    CKorIMX::HAutoMata
    
    Run Hangul Automata
---------------------------------------------------------------------------*/
void CKorIMX::HAutoMata(TfEditCookie ec, ITfContext    *pic, ITfRange *pIRange, 
                         LPBYTE lpbKeyState, WORD wVKey)
{
    WORD              wcCur;
    ULONG              cch;
    LPWSTR           pwstr;
    CHangulAutomata    *pAutomata;
    WCHAR            pwchText[256];

    if ((pAutomata = GetAutomata(pic)) == NULL)
        return;
    
    cch = ARRAYSIZE(pwchText);
    pIRange->GetText(ec, 0, pwchText, ARRAYSIZE(pwchText) - 1, &cch);

    pwstr = pwchText;

    switch (wVKey) 
        {
    ///////////////////////////////////////////////////////////
    // Back space processing
    case VK_BACK :
        if (pAutomata->BackSpace()) 
            {
            CIMEData ImeData;

            if (ImeData.GetJasoDel()) 
                {
                *pwstr++ = pAutomata->GetCompositionChar();
                *pwstr = L'\0';
                SetInputString(ec, pic, pIRange, pwchText, GetLangID());
                }
            else
                {
                pAutomata->InitState();
                *pwstr = L'\0';
                SetInputString(ec, pic, pIRange, pwchText, GetLangID());
                }

            // All composition deleted.
            if (pAutomata->GetCompositionChar() == 0)
                {
                EndIPComposition(ec, pic); 

                // Collapse current selection to end and reset block cursor
                pIRange->Collapse(ec, TF_ANCHOR_END);
                SetSelectionSimple(ec, pic, pIRange);
                }
            }
        else 
            {
            // BUG : impossible
            Assert(0);
            }
        break;

    default :
        WCHAR wchPrev = pAutomata->GetCompositionChar();
        switch (pAutomata->Machine(wVKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 ) ) 
            {
        case HAUTO_COMPOSITION:
            // 
            pwchText[0] = pAutomata->GetCompositionChar();
            pwchText[1] = L'\0';

            SetInputString(ec, pic, pIRange, pwchText, GetLangID());
            break;

        case HAUTO_COMPLETE:
            pwchText[0] = pAutomata->GetCompleteChar();
            pwchText[1] = L'\0';
            if (FAILED(SetInputString(ec, pic, pIRange, pwchText, GetLangID())))
                break;

            MakeResultString(ec, pic, pIRange);
            //
            pwchText[0] = pAutomata->GetCompositionChar();
            pwchText[1] = L'\0';
            SetInputString(ec, pic, pIRange, pwchText, GetLangID());
            break;

        ////////////////////////////////////////////////////////
        // User pressed Alphanumeric key.
        // When user type alphanumeric char in interim state.
        // ImeProcessKey should guarantee return fTrue only if 
        // hangul key pressed or alphanumeric key(including special keys) 
        // pressed in interim state or Fullshape mode.
        case HAUTO_NONHANGULKEY:
            wcCur = pAutomata->GetKeyMap(wVKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 );

            if (GetConvMode(pic) & TIP_JUNJA_MODE)
                wcCur = Banja2Junja(wcCur);

            if (pAutomata->GetCompositionChar())
                {
                pAutomata->MakeComplete();
                MakeResultString(ec, pic, pIRange);
                }

            if (wcCur)
                {
                pwchText[0] = wcCur;
                pwchText[1] = 0;

                if (SUCCEEDED(SetInputString(ec, pic, pIRange, pwchText, GetLangID())))
                    MakeResultString(ec, pic, pIRange);
                }
            break;

        default :
        Assert(0);
            } // switch (pInstData->pMachine->Machine(uVirKey, (lpbKeyState[VK_SHIFT] & 0x80) ? 1 : 0 ) ) 
        } // switch (uVirKey) 

}


/*---------------------------------------------------------------------------
    CKorIMX::DoHanjaConversion
---------------------------------------------------------------------------*/
HRESULT CKorIMX::DoHanjaConversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    ULONG cch;
    CCandidateListEx *pCandList;
    WCHAR pwchText[256];

    Assert(pic != NULL);
    Assert(pRange != NULL);

    cch = ARRAYSIZE(pwchText);
    pRange->GetText(ec, 0, pwchText, ARRAYSIZE(pwchText) - 1, &cch);
    // REVIEW: Assume composition string is one char
    Assert(cch == 1);
    pwchText[1] = 0;

    if ((pCandList = CreateCandidateList(pic, pRange, pwchText)) == NULL)
        return E_FAIL;

    OpenCandidateUI(ec, pic, pRange, pCandList);
    pCandList->Release();
        
    return S_OK;
}

/*---------------------------------------------------------------------------
    CKorIMX::Reconvert
---------------------------------------------------------------------------*/
HRESULT CKorIMX::Reconvert(ITfRange *pSelection)
{
    ITfFnReconversion *pReconv = NULL;
    ITfRange           *pRangeReconv = NULL;

    BOOL fConvertable;
    
    if (FAILED(GetFunctionProvider()->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)&pReconv)))
        return E_FAIL;

    if (pReconv->QueryRange(pSelection, &pRangeReconv, &fConvertable) != S_OK)
        goto Exit;

    if (fConvertable)
        pReconv->Reconvert(pRangeReconv);

Exit:
    SafeRelease(pReconv);
    return S_OK;
}

// REVIEW
/*---------------------------------------------------------------------------
    CKorIMX::SetInputString
---------------------------------------------------------------------------*/
HRESULT CKorIMX::SetInputString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, 
                                WCHAR *psz, LANGID langid)
{
    GUID              attr;
       ITfComposition     *pComposition;
       ITfRange         *ppCompRange = NULL;
       LONG             cch;
//    BOOL              fInsertOK;

    cch = wcslen(psz);
    pComposition = GetIPComposition(pic);

    // If start composition
    if (pComposition == NULL)
        {
        // if new selection, Set overtype.
        Assert(m_pInsertHelper != NULL);
        if (m_pInsertHelper)
            {
            HRESULT hr;
            CHangulAutomata    *pAutomata;

            hr = m_pInsertHelper->InsertAtSelection(ec, pic, psz, cch, &ppCompRange);
            if (FAILED(hr))
                {
                if ((pAutomata = GetAutomata(pic)) != NULL)
                    pAutomata->InitState();
                return hr;
                }
            
            /* InsertOK = (pRange != NULL);*/
            if (ppCompRange == NULL)
                {
                Assert(0);
                return S_FALSE;
                }
            cch = -1; // flag to avoid a SetText call below
            pRange = ppCompRange;
            }

        CreateIPComposition(ec, pic, pRange);
        }

    // Set Korean input property
    attr = GUID_ATTR_KORIMX_INPUT;
    // Use MySetText instead of SetTextAndProperty
    // if cch == -1, set only attribute
    MySetText(ec, pic, pRange, psz , cch, langid, &attr);
    
    // Always call SetSelection for block cursor
    SetSelectionBlock(ec, pic, pRange);

    SafeRelease(ppCompRange);

    return S_OK;
}

// REVIEW
/*---------------------------------------------------------------------------
    CKorIMX::MakeResultString
---------------------------------------------------------------------------*/
HRESULT CKorIMX::MakeResultString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    ITfRange    *pRangeTmp;
    ITfProperty *pPropAttr;
#if 0
    ITfProperty *pProp;
#endif
    TfGuidAtom   attr;

    // Clone Range
    pRange->Clone(&pRangeTmp);

    // Collapse current selection to end and reset block cursor
    pRange->Collapse(ec, TF_ANCHOR_END);
    SetSelectionSimple(ec, pic, pRange);

#if 0
    // Flush IP Range
    FlushIPRange(ec, pic);
#endif

    if (SUCCEEDED(pic->GetProperty(GUID_PROP_ATTRIBUTE, &pPropAttr)))
        {
        if (SUCCEEDED(GetAttrPropertyData(ec, pPropAttr, pRangeTmp, &attr)))
            {
            if (IsKorIMX_GUID_ATOM(attr))
                {
                pPropAttr->Clear(ec, pRangeTmp);
                }
            }
        pPropAttr->Release();

#if 1
        EndIPComposition(ec, pic); 
#else
        // clear the composition property
        if (SUCCEEDED(pic->GetProperty(GUID_PROP_COMPOSING, &pProp)))
            {
            pProp->Clear(ec, pRangeTmp);
            pProp->Release();
            }
#endif
        // clear any overtype
        if (m_pInsertHelper != NULL)
            {
            m_pInsertHelper->ReleaseBlobs(ec, pic, NULL);
            }
        }

    pRangeTmp->Release();

    return S_OK;
}

#if 0
/*---------------------------------------------------------------------------
    CKorIMX::_MultiRangeConversion
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_MultiRangeConversion(TfEditCookie ec, UINT_PTR u, ITfContext *pic, ITfRange *pRange)
{
    IEnumTfRanges *pEnumTrack = NULL;
    ITfReadOnlyProperty *pProp = NULL;
    ITfRange *pPropRange = NULL;
    HRESULT hr = E_FAIL;

    if (FAILED(EnumTrackTextAndFocus(ec, pic, pRange, &pProp, &pEnumTrack)))
        goto Exit;

    while(pEnumTrack->Next(1, &pPropRange,  0) == S_OK)
        {
        ITfRange *pRangeTmp = NULL;

        if (!IsOwnerAndFocus(ec, CLSID_KorIMX, pProp, pPropRange))
            goto Next;

        if (FAILED(pPropRange->Clone(&pRangeTmp)))
            goto Next;

        switch (u)
            {
        case ESCB_COMPLETE:
            MakeResultString(ec, pic, pRangeTmp);
            break;
            }
        SafeRelease(pRangeTmp);
    Next:
        SafeRelease(pPropRange);
        }


Exit:
    SafeRelease(pEnumTrack);
    SafeRelease(pProp);
    
    return hr;
}
#endif

/*---------------------------------------------------------------------------
    CKorIMX::_OwnerWndProc
---------------------------------------------------------------------------*/
LRESULT CALLBACK CKorIMX::_OwnerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
#if 0
    switch (uMsg)
        {
    case WM_CREATE:
        SetThis(hWnd, lParam);
        return 0;

    case (WM_USER+WM_COMMAND):    // local commands
        return GetThis(hWnd)->OnCommand((UINT)wParam, lParam);

    case WM_DRAWITEM: 
        {
        CKorIMX* pThis = GetThis(hWnd);
        if( pThis )
            return pThis->OnDrawItem( wParam, lParam );
        break;
        }
        
    case WM_MEASUREITEM: 
        {
        CKBDTip* pThis = GetThis(hWnd);
        if( pThis )
            return pThis->OnMeasureItem( wParam, lParam );
        break;
        }
        }
#endif

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CKorIMX::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Korean Keyboard TIP Configure");
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CKorIMX::Show(HWND hwnd, LANGID langid, REFGUID rguidProfile)
{
    if (ConfigDLG(hwnd))
        return S_OK;
    else
        return E_FAIL;
}

/*---------------------------------------------------------------------------
    CKorIMX::GetAIMM
---------------------------------------------------------------------------*/
BOOL CKorIMX::GetAIMM(ITfContext *pic)
{
       CICPriv*        picp;

    if ((picp = GetInputContextPriv(pic)) == NULL)
        {
        Assert(0);
        return fFalse;
        }

    // AIMM?
    return picp->GetAIMM();
}


/*---------------------------------------------------------------------------
    CKorIMX::MySetText
---------------------------------------------------------------------------*/
BOOL CKorIMX::MySetText(TfEditCookie ec, ITfContext *pic, ITfRange *pRange,
                        const WCHAR *psz, LONG cchText, LANGID langid, GUID *pattr)
{
    // bugbug: sometimes we want to set TFST_CORRECTION
    if (cchText != -1) // sometimes we just want to set a property value
        pRange->SetText(ec, 0, psz, cchText);

    if (cchText != 0)
        {
        HRESULT hr;
        ITfProperty *pProp = NULL;

        // set langid 
        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LANGID, &pProp)))
            {
            SetLangIdPropertyData(ec, pProp, pRange, langid);
            pProp->Release();
            }
  
        if (pattr)
            {
            // set attr 
            if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp)))
                {
                hr = SetAttrPropertyData(&m_libTLS, ec, pProp, pRange, *pattr);
                pProp->Release();
                }
            }
        }

    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\lexheader.h ===
#if !defined(_LEXHEADER_H__INCLUDED_)
#define _LEXHEADER_H__INCLUDED_

#define DEFAULT_LEX_FILE_NAME "IMEKR.LEX"	// if no reg found will use this name
#define DICT_HEADER_SIZE 512
#define COPYRIGHT_STR "(C) 1997 Hangul Engineering Team. Microsoft Corp. All rights reserved.\n"
#define LEX_VERSION					0x1100
#define LEX_COMPATIBLE_VERSION_LIMIT	0x2000
#define LEX_FILE_NAME TEXT("IMEKR.LEX")

#define TOTAL_NUMBER_OF_HANGUL_MAPPING	(484 + 18) // K0+K1 + # of symbols( - )
#define TOTAL_NUMBER_OF_HANJA			7744
#define MAX_NUMBER_OF_HANJA_SAME_PRONUNC 103
#define MAX_SENSE_LENGTH	50

struct  _DictHeader {
	char	COPYRIGHT_HEADER[150];
	WORD	Version;
	UINT	NumOfHangulEntry;
	UINT	MaxNumOfHanja;
	DWORD	Headersize;
	DWORD	iBufferStart;	      // seek point of HnagulToHanja Index
	UINT	uiNumofHanja;
	DWORD   iHanjaToHangulIndex;  // seek point of HanjaToHangul Index
	DWORD	reserved[10];
	_DictHeader() { 
		Version = 0;
		iBufferStart = Headersize= 0;

		ZeroMemory(reserved, sizeof(reserved));
		ZeroMemory(COPYRIGHT_HEADER, sizeof(COPYRIGHT_HEADER));
		lstrcpy(COPYRIGHT_HEADER, COPYRIGHT_STR);
		COPYRIGHT_HEADER[lstrlen(COPYRIGHT_HEADER)+1] = '\032';
	}
};

struct _LexIndex {
	WCHAR	wcHangul;
	WORD	wNumOfK0, wNumOfK1;
	UINT	iOffset;

	_LexIndex() {
		wcHangul = 0;
		wNumOfK0 = wNumOfK1 = 0;
		iOffset = 0;
	}
};

struct HanjaToHangulIndex 
{
	WCHAR	wchHanja;
	WCHAR	wchHangul;
	UINT	iOffset;

	HanjaToHangulIndex() 
	{
		wchHanja = wchHangul = 0;
		iOffset = 0;
	}
};


#endif // !defined(_LEXHEADER_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\korimx.h ===
//
//   KORIMX.H : CKorIMX class declaration
//
//   History:
//      15-NOV-1999 CSLim Created

#if !defined (__KORIMX_H__INCLUDED_)
#define __KORIMX_H__INCLUDED_

#include "globals.h"
#include "proputil.h"
#include "computil.h"
#include "dap.h"
#include "tes.h"
#include "kes.h"
#include "hauto.h"
#include "candlstx.h"
#include "mscandui.h"
#include "toolbar.h"
#include "editssn.h"
#include "immxutil.h"
#include "softkbd.h"
#include "skbdkor.h"
#include "pad.h"
#include "resource.h"

///////////////////////////////////////////////////////////////////////////////
// Class forward declarations
class CEditSession;
class CICPriv;
class CThreadMgrEventSink;
class CFunctionProvider;
class CHanja;
class CCompositionInsertHelper;

///////////////////////////////////////////////////////////////////////////////
// Edit callback state values
#define ESCB_FINALIZECONVERSION         1
#define ESCB_COMPLETE                   2
#define ESCB_INSERT_PAD_STRING          3
#define ESCB_KEYSTROKE                  4
#define ESCB_TEXTEVENT                  5
//#define ESCB_RANGEBROKEN              6
#define ESCB_CANDUI_CLOSECANDUI         6
#define ESCB_HANJA_CONV                 7
#define ESCB_FINALIZERECONVERSION       8
#define ESCB_ONSELECTRECONVERSION       9
#define ESCB_ONCANCELRECONVERSION       10
#define ESCB_RECONV_QUERYRECONV         11
#define ESCB_RECONV_GETRECONV           12
#define ESCB_RECONV_SHOWCAND            13
#define ESCB_INIT_MODEBIAS              14

// Conversion modes(bit field for bit op)
#define TIP_ALPHANUMERIC_MODE        0
#define TIP_HANGUL_MODE              1
#define TIP_JUNJA_MODE               2
#define TIP_NULL_CONV_MODE           0x8000

//
// Text Direction
//
typedef enum 
{
    TEXTDIRECTION_TOPTOBOTTOM = 1,
    TEXTDIRECTION_RIGHTTOLEFT,
    TEXTDIRECTION_BOTTOMTOTOP,
    TEXTDIRECTION_LEFTTORIGHT,
} TEXTDIRECTION;

    
///////////////////////////////////////////////////////////////////////////////
// CKorIMX class
class CKorIMX :  public ITfTextInputProcessor,
                 public ITfFnConfigure,
                 public ITfThreadFocusSink,
                 public ITfCompositionSink,
                 public ITfCleanupContextSink,
                 public ITfCleanupContextDurationSink,
                 public ITfActiveLanguageProfileNotifySink,
                 public ITfTextEditSink,
                 public ITfEditTransactionSink,
                 public CDisplayAttributeProvider
{
public:
    CKorIMX();
    ~CKorIMX();

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    
    //
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

private:
    long m_cRef;

public:
    //
    // ITfX methods
    //
    STDMETHODIMP Activate(ITfThreadMgr *ptim, TfClientId tid);
    STDMETHODIMP Deactivate();

    // ITfThreadFocusSink
    STDMETHODIMP OnSetThreadFocus();
    STDMETHODIMP OnKillThreadFocus();

    // ITfCompositionSink
    STDMETHODIMP OnCompositionTerminated(TfEditCookie ecWrite, ITfComposition *pComposition);

    // ITfCleanupContextDurationSink
    STDMETHODIMP OnStartCleanupContext();
    STDMETHODIMP OnEndCleanupContext();

    // ITfCleanupContextSink
    STDMETHODIMP OnCleanupContext(TfEditCookie ecWrite, ITfContext *pic);

    // ITfActiveLanguageProfileNotifySink
    STDMETHODIMP OnActivated(REFCLSID clsid, REFGUID guidProfile, BOOL fActivated);

    // ITFFnConfigure
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);
    STDMETHODIMP Show(HWND hwnd, LANGID langid, REFGUID rguidProfile);

      // ITfTextEditSink
    STDMETHODIMP OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    // ITfEditTransactionSink
    STDMETHODIMP OnStartEditTransaction(ITfContext *pic);
    STDMETHODIMP OnEndEditTransaction(ITfContext *pic);

// Operations
public:
    // Get/Set On off status
    BOOL IsOn(ITfContext *pic);
    void SetOnOff(ITfContext *pic, BOOL fOn);

    static HRESULT _EditSessionCallback2(TfEditCookie ec, CEditSession2 *pes);
    HRESULT MakeResultString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);

    // REVIEW: IC related functions
    ITfContext* GetRootIC(ITfDocumentMgr* pDim = NULL);
    static BOOL IsDisabledIC(ITfContext *pic);
    static BOOL IsEmptyIC(ITfContext *pic);
    static BOOL IsCandidateIC(ITfContext *pic);

    static HWND GetAppWnd(ITfContext *pic);
    BOOL IsPendingCleanup();

    // Get AIMM or not?
    static BOOL GetAIMM(ITfContext *pic);

    // Get/Set conversion mode
    DWORD GetConvMode(ITfContext *pic);
    DWORD SetConvMode(ITfContext *pic, DWORD dwConvMode);

    // Retun current Automata object
    CHangulAutomata* GetAutomata(ITfContext *pic);

    // Cand UI functions
    void OpenCandidateUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList);
    void CloseCandidateUI(ITfContext *pic);
    void CancelCandidate(TfEditCookie ec, ITfContext *pic);

    // Soft Kbd functions
    HRESULT InitializeSoftKbd();
    BOOL IsSoftKbdEnabled()    { return m_fSoftKbdEnabled; }
    void  TerminateSoftKbd();
    BOOL GetSoftKBDOnOff();
    void SetSoftKBDOnOff(BOOL fOn);
    DWORD GetSoftKBDLayout();
    void SetSoftKBDLayout(DWORD  dwKbdLayout);
    HRESULT GetSoftKBDPosition(int *xWnd, int *yWnd);
    void SetSoftKBDPosition(int  xWnd, int yWnd);
    SOFTLAYOUT* GetHangulSKbd() { return &m_KbdHangul; }
    
    // Data access functins
    ITfDocumentMgr* GetDIM() { return m_pCurrentDim; }
    HRESULT         GetFocusDIM(ITfDocumentMgr **ppdim);
    ITfThreadMgr*    GetTIM() { return m_ptim; }
    TfClientId        GetTID() { return m_tid;  }
    ITfContext*        GetIC();
    CThreadMgrEventSink* GetTIMEventSink() { return m_ptimEventSink; }
    static CICPriv*    GetInputContextPriv(ITfContext *pic);
    void             OnFocusChange(ITfContext *pic, BOOL fActivate);

    // Window object member access functions
    HWND GetOwnerWnd()          { return m_hOwnerWnd; }

    // Get IImeIPoint
    IImeIPoint1* GetIPoint              (ITfContext *pic);

    // KES_CODE_FOCUS set fForeground?
    BOOL IsKeyFocus()            { return m_fKeyFocus; }

    // Get Pad Core
    CPadCore* GetPadCore()      { return m_pPadCore; }


    // Update Toolbar button
    void UpdateToolbar(DWORD dwUpdate)  { m_pToolBar->Update(dwUpdate); }
    static LRESULT CALLBACK _OwnerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    CFunctionProvider*     GetFunctionProvider() { return m_pFuncPrv; }

    // Cand UI helper
    BOOL IsCandUIOpen() { return m_fCandUIOpen; }

    // Get TLS
    LIBTHREAD *_GetLibTLS() { return &m_libTLS; }

// Implementation
protected:
// Helper functions
    HRESULT SetInputString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, WCHAR *psz, LANGID langid);
    static LANGID GetLangID();
    static WCHAR Banja2Junja(WCHAR bChar);

    // Cand UI function
    void GetCandidateFontInternal(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LOGFONTW *plf, LONG lFontPoint, BOOL fCandList);

//////////////////////////////////////////////////////////////////////////////
// Internal functions
private:
    // Callbacks
    static HRESULT _KeyEventCallback(UINT uCode, ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, void *pv);
    static HRESULT _PreKeyCallback(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv);
    static HRESULT _DIMCallback(UINT uCode, ITfDocumentMgr *pdimNew, ITfDocumentMgr *pdimPrev, void *pv);
    static HRESULT _ICCallback(UINT uCode, ITfContext *pic, void *pv);
    static HRESULT _CompEventSinkCallback(void *pv, REFGUID rguid);
    static void _CleanupCompositionsCallback(TfEditCookie ecWrite, ITfRange *rangeComposition, void *pvPrivate);

    void HAutoMata(TfEditCookie ec, ITfContext    *pIIC, ITfRange *pIRange, LPBYTE lpbKeyState, WORD wVKey);
    BOOL _IsKeyEaten(ITfContext *pic, CKorIMX *pimx, WPARAM wParam, LPARAM lParam, const BYTE abKeyState[256]);
    HRESULT _Keystroke(TfEditCookie ec, ITfContext *pic, WPARAM wParam, LPARAM lParam, const BYTE abKeyState[256]);

    // IC helpers
    HRESULT _InitICPriv(ITfContext *pic);
    HRESULT _DeleteICPriv(ITfContext *pic);

    // Hanja conversion
    HRESULT DoHanjaConversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);
    HRESULT Reconvert(ITfRange *pSelection);

    // Composition
    ITfComposition *GetIPComposition(ITfContext *pic);
    ITfComposition *CreateIPComposition(TfEditCookie ec, ITfContext *pic, ITfRange* pRangeComp);
    void SetIPComposition(ITfContext *pic, ITfComposition *pComposition);
    BOOL EndIPComposition(TfEditCookie ec, ITfContext *pic);

    // Candidate list
    CCandidateListEx *CreateCandidateList(ITfContext *pic, ITfRange *pRange, LPWSTR wchHangul);
    TEXTDIRECTION GetTextDirection(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);
    CANDUIUIDIRECTION GetCandUIDirection(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);
    void CloseCandidateUIProc();
    void SelectCandidate(TfEditCookie ec, ITfContext *pic, INT idxCand, BOOL fFinalize);
    HMENU CreateCandidateMenu(ITfContext *pic);
    static HRESULT CandidateUICallBack(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList, CCandidateStringEx *pCand, TfCandidateResult imcr);

    // Cand key
    void SetCandidateKeyTable(ITfContext *pic, CANDUIUIDIRECTION dir);
    static BOOL IsCandKey(WPARAM wParam, const BYTE abKeyState[256]);

#if 0
    // Range functions
    void BackupRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRange );
    void RestoreRange(TfEditCookie ec, ITfContext *pic );
    ITfRange* CreateIPRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRangeOrg);
    void SetIPRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRange);
    ITfRange* GetIPRange(TfEditCookie ec, ITfContext *pic);
    BOOL FlushIPRange(TfEditCookie ec, ITfContext *pic);
#endif

    // Modebias(ImmSetConversionStatus() API AIMM compatebility)
    BOOL InitializeModeBias(TfEditCookie ec, ITfContext *pic);
    void CheckModeBias(ITfContext* pic);
    BOOL CheckModeBias(TfEditCookie ec, ITfContext *pic, ITfRange *pSelection);

    // SoftKeyboard 
    //void OnActivatedSoftKbd(BOOl bActivated);
    HRESULT ShowSoftKBDWindow(BOOL fShow);
    void SoftKbdOnThreadFocusChange(BOOL fSet);
    
    // Helpers
    BOOL MySetText(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, const WCHAR *psz, LONG cchText, LANGID langid, GUID *pattr);

    BOOL IsKorIMX_GUID_ATOM(TfGuidAtom attr);

///////////////////////////////////////////////////////////////////////////////
// Internal data
private:
    ITfDocumentMgr           *m_pCurrentDim;
    ITfThreadMgr             *m_ptim;
    TfClientId                m_tid;
    CThreadMgrEventSink      *m_ptimEventSink;
    CKeyEventSink            *m_pkes;
    
    HWND                      m_hOwnerWnd;
    BOOL                      m_fKeyFocus;  
    CPadCore                 *m_pPadCore;
    CToolBar                 *m_pToolBar;

    DWORD                     m_dwThreadFocusCookie;
    DWORD                     m_dwProfileNotifyCookie;
    BOOL                      m_fPendingCleanup;

    CFunctionProvider*        m_pFuncPrv;

    // For overtyping
    CCompositionInsertHelper *m_pInsertHelper;

    // Candidate UI
    ITfCandidateUI*           m_pCandUI;
    BOOL                      m_fCandUIOpen;

    // SoftKbd
    BOOL                      m_fSoftKbdEnabled;
    ISoftKbd                 *m_pSoftKbd;
    SOFTLAYOUT                m_KbdStandard;
    SOFTLAYOUT                m_KbdHangul;
    CSoftKbdWindowEventSink  *m_psftkbdwndes;
    DWORD                     m_dwSftKbdwndesCookie;
    BOOL                      m_fSoftKbdOnOffSave;
    
    // Tls for our helper library, we're apt threaded so tls can live in this object
    LIBTHREAD                 m_libTLS; 

    BOOL                      m_fNoKorKbd;
};

/*---------------------------------------------------------------------------
    CKorIMX::IsPendingCleanup
---------------------------------------------------------------------------*/
inline
BOOL CKorIMX::IsPendingCleanup()
{
    return m_fPendingCleanup;
}

/*---------------------------------------------------------------------------
    CKorIMX::GetFocusDIM
---------------------------------------------------------------------------*/
inline
HRESULT CKorIMX::GetFocusDIM(ITfDocumentMgr **ppdim)
{
    Assert(ppdim);
    *ppdim = NULL;
    if (m_ptim != NULL)
        m_ptim->GetFocus(ppdim);

    return *ppdim ? S_OK : E_FAIL;
}

#include "icpriv.h"
/*---------------------------------------------------------------------------
    CKorIMX::GetAutomata
---------------------------------------------------------------------------*/
inline
CHangulAutomata* CKorIMX::GetAutomata(ITfContext *pic)
{
    CICPriv* picp = GetInputContextPriv(pic);
    return (picp) ?    GetInputContextPriv(pic)->GetAutomata() : NULL;
}

/*---------------------------------------------------------------------------
    CKorIMX::IsOn
---------------------------------------------------------------------------*/
inline
BOOL  CKorIMX::IsOn(ITfContext *pic)
{
    DWORD dw = 0;
    
    if (pic == NULL)
        return fFalse;

    GetCompartmentDWORD(GetTIM(), GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, &dw, fFalse);

    return dw ? fTrue : fFalse;
}

/*---------------------------------------------------------------------------
    CKorIMX::GetConvMode
---------------------------------------------------------------------------*/
inline
DWORD CKorIMX::GetConvMode(ITfContext *pic)
{
    DWORD dw = 0;

    if (pic == NULL)
        return TIP_ALPHANUMERIC_MODE;

    GetCompartmentDWORD(GetTIM(), GUID_COMPARTMENT_KORIMX_CONVMODE, &dw, fFalse);
        
    return dw;
}



/*---------------------------------------------------------------------------
    CKorIMX::SetOnOff
---------------------------------------------------------------------------*/
inline
void CKorIMX::SetOnOff(ITfContext *pic, BOOL fOn)
{
    if (pic)
        SetCompartmentDWORD(m_tid, GetTIM(), GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, fOn ? 0x01 : 0x00, fFalse);
}

/*---------------------------------------------------------------------------
    CKorIMX::GetLangID
---------------------------------------------------------------------------*/
inline 
LANGID CKorIMX::GetLangID()
{
    return MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT);
}

/*---------------------------------------------------------------------------
    CKorIMX::IsKorIMX_GUID_ATOM
---------------------------------------------------------------------------*/
inline
BOOL CKorIMX::IsKorIMX_GUID_ATOM(TfGuidAtom attr)
{
    if (IsEqualTFGUIDATOM(&m_libTLS, attr, GUID_ATTR_KORIMX_INPUT))
        return fTrue;

    return fFalse;
}

/////////////////////////////////////////////////////////////////////////////
// S O F T  K E Y B O A R D  F U N C T I O N S
/////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    CKorIMX::GetSoftKBDOnOff
---------------------------------------------------------------------------*/
inline
BOOL CKorIMX::GetSoftKBDOnOff()
{

     DWORD dw;

    if (GetTIM() == NULL)
       return fFalse;

    GetCompartmentDWORD(GetTIM(), GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE , &dw, fFalse);
    return dw ? TRUE : fFalse;
}

/*---------------------------------------------------------------------------
    CKorIMX::SetSoftKBDOnOff
---------------------------------------------------------------------------*/
inline
void CKorIMX::SetSoftKBDOnOff(BOOL fOn)
{

    // check to see if the m_pSoftKbd and soft keyboard related members are initialized.
    if (m_fSoftKbdEnabled == fFalse)
        InitializeSoftKbd();

    if (m_pSoftKbd == NULL || GetTIM() == NULL)
        return;

    if (fOn == GetSoftKBDOnOff())
       return;

    SetCompartmentDWORD(GetTID(), GetTIM(), GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE, 
                        fOn ? 0x01 : 0x00 , fFalse);
}

/*---------------------------------------------------------------------------
    CKorIMX::GetSoftKBDLayout
---------------------------------------------------------------------------*/
inline
DWORD  CKorIMX::GetSoftKBDLayout( )
{

   DWORD dw;

    if (m_pSoftKbd == NULL || GetTIM() == NULL)
       return NON_LAYOUT;

   GetCompartmentDWORD(GetTIM(), GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, &dw, fFalse);

   return dw;

}


/*---------------------------------------------------------------------------
    CKorIMX::SetSoftKBDLayout
---------------------------------------------------------------------------*/
inline
void  CKorIMX::SetSoftKBDLayout(DWORD  dwKbdLayout)
{
    // check to see if the _SoftKbd and soft keyboard related members are initialized.
    if (m_fSoftKbdEnabled == fFalse )
        InitializeSoftKbd();

    if ((m_pSoftKbd == NULL) || (GetTIM() == NULL))
        return;

    SetCompartmentDWORD(GetTID(), GetTIM(), GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, 
                        dwKbdLayout , fFalse);
}

/*---------------------------------------------------------------------------
    CKorIMX::GetSoftKBDPosition
---------------------------------------------------------------------------*/
inline
HRESULT CKorIMX::GetSoftKBDPosition(int *xWnd, int *yWnd)
{
    DWORD    dwPos;
    HRESULT  hr = S_OK;

    if ((m_pSoftKbd == NULL) || (GetTIM() == NULL))
        return E_FAIL;

    if (!xWnd  || !yWnd)
        return E_FAIL;

   hr = GetCompartmentDWORD(GetTIM(), GUID_COMPARTMENT_SOFTKBD_WNDPOSITION, &dwPos, TRUE);

   if (hr == S_OK)
        {
        *xWnd = dwPos & 0x0000ffff;
        *yWnd = (dwPos >> 16) & 0x0000ffff;
        hr = S_OK;
        }
   else
        {
        *xWnd = 0;
        *yWnd = 0;
        hr = E_FAIL;
        }

   return hr;
}

/*---------------------------------------------------------------------------
    CKorIMX::SetSoftKBDPosition
---------------------------------------------------------------------------*/
inline
void CKorIMX::SetSoftKBDPosition(int  xWnd, int yWnd )
{
    DWORD  dwPos;
    DWORD  left, top;

    if ((m_pSoftKbd == NULL) || (GetTIM() == NULL))
        return;

    if (xWnd < 0)
        left = 0;
    else
        left = (WORD)xWnd;

    if (yWnd < 0)
        top = 0;
    else
        top = (WORD)yWnd;

    dwPos = ((DWORD)top << 16) + left;

    SetCompartmentDWORD(GetTID(), GetTIM(), GUID_COMPARTMENT_SOFTKBD_WNDPOSITION, 
                        dwPos, TRUE);
}
    

/////////////////////////////////////////////////////////////////////////////
// H E L P E R  F U N C T I O N S
/////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    SetSelectionBlock

    Wrapper for SetSelection that takes only a single range and sets default style values.
---------------------------------------------------------------------------*/
inline 
HRESULT SetSelectionBlock(TfEditCookie ec, ITfContext *pic, ITfRange *range)
{
    TF_SELECTION sel;

    sel.range = range;
    sel.style.ase = TF_AE_NONE;
    sel.style.fInterimChar = fTrue;

    return pic->SetSelection(ec, 1, &sel);
}

/*---------------------------------------------------------------------------
    SetThis
---------------------------------------------------------------------------*/
inline
void SetThis(HWND hWnd, LPARAM lParam)
{
    SetWindowLongPtr(hWnd, GWLP_USERDATA, 
                (LONG_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
}

/*---------------------------------------------------------------------------
    GetThis
---------------------------------------------------------------------------*/
inline
CKorIMX *GetThis(HWND hWnd)
{
    CKorIMX *p = (CKorIMX *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    Assert(p != NULL);
    return p;
}

#endif // __KORIMX_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\pad.h ===
//
//	%%Title: UI IMEPad Button
//	%%Unit: UI
//	%%Contact: TakeshiF
//	%%Date: 97/04/14
//	%%File: pad.h
//
//	UI IMEPad Button support
//

#ifndef __PAD_H__
#define __PAD_H__

#include "cicbtn.h"
#include "toolbar.h"
#include "padcb.h"

#include "../fecommon/srcuim/cpadsvu.h"

class CKorIMX;
class CImePadSvrUIM;

class CPadCore
{
public:
	BOOL m_fShown;
	BOOL m_fCurrentlyShown;
	CPadCore(CKorIMX *pTip);
	~CPadCore();

	void PadBoot(IImeIPoint1* pIP, IID* piid);
#if 0
	void PadBoot( IImeIPoint* pIP, UINT uiType );
#endif
	BOOL InitializePad();
	void SetIPoint(IImeIPoint1* pIP);
	void IMEPadNotify(BOOL fShown);
	void SetFocus(BOOL fFocus);
	void ShowPad(BOOL fShow);
	BOOL IsShown()
	{
		return m_fShown;
	}
	BOOL IsCurrentlyShown(void)
	{
		return m_fCurrentlyShown;
	}
    UINT MakeAppletMenu(UINT uidStart, UINT uidEnd, ITfMenu *pMenu, LPIMEPADAPPLETCONFIG *ppCfg);

#if 0
	BOOL GetHWInfo( BSTR* pbsz, HICON* phIcon );
	BOOL InvokeHWTIP(void);
	BOOL IsHWTIP(void);
#endif

	CPadCB* m_pPadCB;
	CImePadSvrUIM* m_pPadSvr;

private:
	CKorIMX *m_pImx;
};

class CPad : public CCicButton
{
public:

	CPad(CToolBar *ptb, CPadCore* pPadCore);
	~CPad();

	void Reset(void);

	STDMETHODIMP GetIcon(HICON *phIcon);
	STDMETHODIMP InitMenu(ITfMenu *pMenu);
	STDMETHODIMP OnMenuSelect(UINT uID);
    STDMETHODIMP_(ULONG) Release(void);

#if 0
    static BOOL __declspec(dllexport) HWDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
	static BOOL OnProcessAttach(HINSTANCE hInst);
	static BOOL OnProcessDetach(void);
	static BOOL OnThreadAttach(void);
	static BOOL OnThreadDetach(void);

	void UnloadImePad(void);
	void LoadImePad(HWND hWndUI);
#endif
	void ShowItem(BOOL fShow);
	UINT MakeAppletMenu( void** ppcmh );
	void CleanAppletCfg(void);

private:

	UINT m_ciApplets;
	CToolBar *m_pTb;
	CPadCore *m_pPadCore;
	IMEPADAPPLETCONFIG *m_pCfg;

};

#endif // __PAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\mouse.cpp ===
/****************************************************************************
   MOUSE.CPP : Mouse callback

   History:
      02-OCT-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "icpriv.h"
#include "mes.h"

//+---------------------------------------------------------------------------
//
// _MouseCallback
//
//----------------------------------------------------------------------------

#define IMEMOUSE_NONE       0x00    // no mouse button was pushed
#define IMEMOUSE_LDOWN      0x01
#define IMEMOUSE_RDOWN      0x02
#define IMEMOUSE_MDOWN      0x04
#define IMEMOUSE_WUP        0x10    // wheel up
#define IMEMOUSE_WDOWN      0x20    // wheel down

/* static */
HRESULT CICPriv::_MouseCallback(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten, void *pv)
{
    CEditSession2     *pes;
    ESSTRUCT         ess;
    HRESULT            hr;
    CICPriv         *pCicPriv = (CICPriv *)pv;

    if ((dwBtnStatus & (IMEMOUSE_LDOWN |IMEMOUSE_RDOWN | IMEMOUSE_MDOWN | IMEMOUSE_WDOWN)) && pCicPriv)
        {
        ESStructInit(&ess, ESCB_COMPLETE);

        if (pes = new CEditSession2(pCicPriv->GetIC(), pCicPriv->GetIMX(), &ess, CKorIMX::_EditSessionCallback2))
            {
            pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
            pes->Release();
            }
        }

    *pfEaten = fFalse;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\modebias.cpp ===
/****************************************************************************
   MODEBIAS.CPP : Handling ModeBias. Sync conversion mode with Cicero's ModeBias

   History:
      2-JUL-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "immxutil.h"
#include "helpers.h"

/*---------------------------------------------------------------------------
    CKorIMX::SyncModeBias
---------------------------------------------------------------------------*/
BOOL CKorIMX::CheckModeBias(TfEditCookie ec, ITfContext *pic, ITfRange *pSelection)
{
    BOOL fChanged = fFalse;
    ITfReadOnlyProperty *pProp = NULL;
    ITfRange* pRange = NULL;
    VARIANT var;
    CICPriv* pPriv;
    HRESULT hr;

    if (pSelection == NULL)
        return fFalse;

    if (FAILED(hr = pic->GetAppProperty(GUID_PROP_MODEBIAS, &pProp)))
        return fFalse;

    pRange = pSelection;

    QuickVariantInit(&var);
    hr = pProp->GetValue(ec, pRange, &var);
    pProp->Release();

    if (!SUCCEEDED(hr))
        goto lEnd;

    Assert(var.vt == VT_I4);
    if (var.vt != VT_I4)
        goto lEnd;

    if ((pPriv = GetInputContextPriv(pic)) == NULL)
        goto lEnd;

    // check if changed
    if (pPriv->GetModeBias() != (TfGuidAtom)var.lVal)
        {
        GUID guidModeBias;

        fChanged = TRUE;

        // Keep modebias update
        pPriv->SetModeBias(var.lVal);

        // ISSUE: !!! WARNING !!!
        // Yutakas said, Aimm should handle this.
        // Kor IME set Open status automatically when conversion mode to Hangul or Full shape.
        // GUID_COMPARTMENT_KEYBOARD_OPENCLOSE  has higher priority than modebias

        GetGUIDFromGUIDATOM(&m_libTLS, (TfGuidAtom)var.lVal, &guidModeBias);

        // Multiple bias will bot be allowed.
        // GUID_MODEBIAS_NONE == ignore modebias
        if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_NONE))
            goto lEnd;

        // Office 10 #182239
        if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_HANGUL))
            {
            Assert(IsOn(pic) == fTrue);
            SetConvMode(pic, TIP_HANGUL_MODE);
            goto lEnd;
            }

        if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_FULLWIDTHHANGUL))
            {
            Assert(IsOn(pic) == fFalse);
            SetConvMode(pic, TIP_HANGUL_MODE | TIP_JUNJA_MODE);
            goto lEnd;
            }

        if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_FULLWIDTHALPHANUMERIC))
            {
            Assert(IsOn(pic) == fTrue);
            SetConvMode(pic, TIP_JUNJA_MODE);
            goto lEnd;
            }

        if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_HALFWIDTHALPHANUMERIC))
            {
            Assert(IsOn(pic) == fFalse);
            SetConvMode(pic, TIP_ALPHANUMERIC_MODE);
            goto lEnd;
            }
        
        }

lEnd:
    VariantClear(&var);
    return fChanged;
}

/*---------------------------------------------------------------------------
    CKorIMX::InitializeModeBias
---------------------------------------------------------------------------*/
BOOL CKorIMX::InitializeModeBias(TfEditCookie ec, ITfContext *pic)
{
    ITfRange* pSelection;
    
    if (pic == NULL)
        return fFalse;

    //
    // current selection is in the pRangeIP?
    //
    if (FAILED(GetSelectionSimple(ec, pic, &pSelection)))
        return fFalse;

    //
    // check mode bias
    //
    CheckModeBias(ec, pic, pSelection);

    SafeRelease(pSelection);    // release it

    return fTrue;
}

/*---------------------------------------------------------------------------
    CKorIMX::CheckModeBias

    This will submit async call of InitializeModeBias
---------------------------------------------------------------------------*/
void CKorIMX::CheckModeBias(ITfContext* pic)
{
    CEditSession2 *pes;
    ESSTRUCT ess;
    HRESULT  hr;

    ESStructInit(&ess, ESCB_INIT_MODEBIAS);
    
    if ((pes = new CEditSession2(pic, this, &ess, _EditSessionCallback2)) != NULL)
        {
        pes->Invoke(ES2_READONLY | ES2_SYNC, &hr);
        pes->Release();
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\padcb.h ===
#ifndef __PADCB_H__
#define __PADCB_H__

#include "../../fecommon/include/iimecb.h"

class CPadCB : public IImeCallback
{
public:    
    //----------------------------------------------------------------
    //IUnknown
    //----------------------------------------------------------------
    virtual HRESULT __stdcall QueryInterface(REFIID riid, LPVOID* ppvObj);
    virtual ULONG    __stdcall AddRef();
    virtual ULONG   __stdcall Release();
    //----------------------------------------------------------------
    //IImeConnectionPoint method
    //----------------------------------------------------------------
    virtual HRESULT __stdcall GetApplicationHWND(HWND *pHWND);
    virtual HRESULT __stdcall Notify(UINT notify, WPARAM wParam, LPARAM lParam);


    CPadCB();
    ~CPadCB();

    void Initialize(void* pPad);

private:    
    void *m_pPad;
    LONG  m_cRef; 
};

typedef CPadCB*  LPCPadCB;

//----------------------------------------------------------------
// IImeCallback::Notify()'s notify
// IMECBNOTIFY_IMEPADOPENED
// WPARAM wParam: not used. always 0
// LPARAM lParam: not used. always 0
//----------------------------------------------------------------
#define IMECBNOTIFY_IMEPADOPENED	0

//----------------------------------------------------------------
// IImeCallback::Notify()'s notify
// IMECBNOTIFY_IMEPADCLOSED
// WPARAM wParam: not used. always 0
// LPARAM lParam: not used. always 0
//----------------------------------------------------------------
#define IMECBNOTIFY_IMEPADCLOSED	1

#endif //__PADCB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\padcb.cpp ===
#include "private.h"
#include "pad.h"
#include "padcb.h"

void CPadCB::Initialize(void *pPad)
{
    m_pPad = pPad;
}

CPadCB::CPadCB()
{
    m_cRef = 1;
    m_pPad = NULL;
}

CPadCB::~CPadCB()
{

}

HRESULT __stdcall CPadCB::QueryInterface(REFIID refiid, LPVOID* ppv)
{
    if(refiid == IID_IUnknown)
        {
        *ppv = static_cast<IUnknown *>(this);
        }
    else if(refiid == IID_IImeCallback) 
        {
        *ppv = static_cast<IImeCallback *>(this);
        }
    else
        {
        *ppv = NULL;
        return E_NOINTERFACE;
        }
    
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall CPadCB::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall CPadCB::Release()
{
    if(InterlockedDecrement(&m_cRef) == 0)
        {
        //delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT __stdcall CPadCB::GetApplicationHWND(HWND *pHwnd)
{
    //----------------------------------------------------------------
    //Get Application's Window Handle.
    //----------------------------------------------------------------
    if(pHwnd)
        {
        *pHwnd = GetFocus();    // tmp tmp UI::GetActiveAppWnd();
        return S_OK;
        }
    return S_FALSE;
}

HRESULT __stdcall CPadCB::Notify(UINT notify, WPARAM wParam, LPARAM lParam)
{
#ifdef _DEBUG
    CHAR szBuf[256];
    wsprintf(szBuf, "CPadCB::NOtify notify [%d]\n", notify);
    OutputDebugString(szBuf);
#endif
    switch(notify) 
        {
    case IMECBNOTIFY_IMEPADOPENED:
    case IMECBNOTIFY_IMEPADCLOSED:
        //----------------------------------------------------------------
        //ImePad has Closed. repaint toolbar...
        //----------------------------------------------------------------
        //CPad::IMEPadNotify();
        if (m_pPad)
            {
            CPadCore* pPad = (CPadCore*)m_pPad;
            pPad->IMEPadNotify((notify == IMECBNOTIFY_IMEPADCLOSED) ? FALSE : TRUE);
            }
        break;
        
    default:
        break;
    }
    return S_OK;
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\pad.cpp ===
/****************************************************************************
    PAD.CPP

    Owner: cslim
    Copyright (c) 1997-2001 Microsoft Corporation

    IME PAD button and helper functions

    History:
    24-OCT-2001 CSLim       Ported for Korean TIP
    05-OCT-1999 TakeshiF    Created
*****************************************************************************///
#include "private.h"
#include "pad.h"
#include "padcb.h"
#include "globals.h"
#include "nuibase.h"
#include "userex.h"
#include "resource.h"

#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)

//
// menu id range
//
#define PADMENUSTART  IDR_PAD_FIRST
#define PADMENUEND    IDR_PAD_END


// {02D7474B-2EEA-4ebb-927A-779D9A201D02}
static const GUID GUID_LBI_KORIMX_CPAD = 
{
    0x2d7474b, 
    0x2eea, 
    0x4ebb, 
    { 0x92, 0x7a, 0x77, 0x9d, 0x9a, 0x20, 0x1d, 0x2 } 
};


/*---------------------------------------------------------------------------
    CPad::CPad
---------------------------------------------------------------------------*/
CPad::CPad(CToolBar *ptb, CPadCore* pPadCore)
{
    WCHAR  szText[256];
    
    m_pTb = ptb;

    // Set button tooltip
    LoadStringExW(g_hInst, IDS_TT_IME_PAD, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_KorIMX, 
                GUID_LBI_KORIMX_CPAD,
                TF_LBI_STYLE_BTN_MENU | TF_LBI_STYLE_SHOWNINTRAY,
                140, 
                szText);
    SetToolTip(szText);

    // Set button text
    LoadStringExW(g_hInst, IDS_BUTTON_IME_PAD, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);

    m_pPadCore = pPadCore;
    m_ciApplets = 0;

    m_pCfg = NULL;    // applet list
}

/*---------------------------------------------------------------------------
    CPad::~CPad
---------------------------------------------------------------------------*/
CPad::~CPad()
{
    CleanAppletCfg();
}

/*---------------------------------------------------------------------------
    CPad::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CPad::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
        {
        delete this;
        }

    return cr;
}

/*---------------------------------------------------------------------------
    CPad::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI CPad::GetIcon(HICON *phIcon)
{
    UINT uiIcon = IDI_PAD;
    
    *phIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);
    return S_OK;
}


/*---------------------------------------------------------------------------
    CPad::InitMenu
---------------------------------------------------------------------------*/
STDAPI CPad::InitMenu(ITfMenu *pMenu)
{
    CleanAppletCfg();
    if (m_pPadCore == NULL)
        {
        return E_FAIL;
        }
    
    m_ciApplets = m_pPadCore->MakeAppletMenu(PADMENUSTART, PADMENUEND, pMenu, &m_pCfg);

    if (m_pCfg == NULL || m_ciApplets == 0)
        {
        return E_FAIL;
        }

    return S_OK;
}
 
/*---------------------------------------------------------------------------
    CPad::OnMenuSelect
---------------------------------------------------------------------------*/
STDAPI CPad::OnMenuSelect(UINT uiCmd)
{
    ITfContext  *pic;
    IImeIPoint1 *pIP;
    IID iidApplet;
    BOOL fLaunch;
    
    if (m_pTb == NULL)
        {
        return E_FAIL;
        }
    
    pic = m_pTb->GetIC();
    if (pic == NULL)
        {
        return S_OK;
        }
    
    pIP = m_pTb->GetIPoint(pic);

    fLaunch = FALSE;
    if (uiCmd >= PADMENUSTART && uiCmd <= PADMENUEND)
        {
        fLaunch = TRUE;
        INT iidIndex = uiCmd - PADMENUSTART;
        Assert(m_pCfg != NULL);
        CopyMemory(&iidApplet, &(m_pCfg+iidIndex)->iid, sizeof(IID));    // make a copy
        }

    //
    // launch IMEPad with GUID
    //
    if (fLaunch)
        {
        m_pPadCore->PadBoot(pIP, &iidApplet);
        ShowItem(TRUE);
        }

    CleanAppletCfg();

#if 0
    //
    // HW TIP navigation
    //
    if (uiCmd == IDC_PAD_HW)
        {
        //
        // Invoke HW TIP
        //
        m_pPadCore->InvokeHWTIP();

        //
        // show HW TIP
        //
        SetCompartmentDWORD(m_pTb->GetTIP()->GetTID(), m_pTb->GetTIP()->GetTIM(), GUID_COMPARTMENT_HANDWRITING_OPENCLOSE, 0x01, FALSE);
        }
#endif
    return S_OK;
}

/*---------------------------------------------------------------------------
    CPad::ShowItem
---------------------------------------------------------------------------*/
void CPad::ShowItem(BOOL fShow)
{
    m_pPadCore->ShowPad(fShow);

    if (GetSink())
        {
        GetSink()->OnUpdate(TF_LBI_BTNALL);
        }
}

/*---------------------------------------------------------------------------
    CPad::Reset
---------------------------------------------------------------------------*/
void CPad::Reset()
{
    CleanAppletCfg();
    m_pTb = NULL;
    m_pPadCore = NULL;
}

/*---------------------------------------------------------------------------
    CPad::CleanAppletCfg
---------------------------------------------------------------------------*/
void CPad::CleanAppletCfg()
{
    if (m_pCfg)
        {
        //
        // release resouced that created by Pad server
        //
        UINT i;
        for (i = 0; i < m_ciApplets; i++)
            {
            if((m_pCfg+i)->hIcon)
                {
                ::DestroyIcon((HICON)(m_pCfg+i)->hIcon);
                }
            }


        MemFree(m_pCfg);
        m_pCfg = NULL;
        }
    
    m_ciApplets = 0;    // reset
}

#if 0
//
// HW TIP navigation dialog
//
BOOL __declspec(dllexport) CPad::HWDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (message){
        case WM_INITDIALOG: {
            SetMyClass( hDlg, 0, lParam );    // register this

            CPad* pPad = (CPad*)lParam;
            //
            // special menu item for HW TIP
            //
            HICON hIcon;
            BSTR bsz;
            if( pPad->m_pPadCore->GetHWInfo( &bsz, &hIcon ) ) {

                SysFreeString( bsz );

                OurSendMessage( GetDlgItem(hDlg, IDC_PAD_HW), STM_SETICON, (WPARAM)hIcon, (LPARAM)0 );

                DestroyIcon( hIcon );
            }



            return(TRUE);
        }

        case WM_COMMAND: {
            WORD wID = LOWORD(wParam);
            if (wID == IDOK || wID == IDCANCEL) {
                EndDialog(hDlg,0);
            }
            return(TRUE);
        }
    }
    return(FALSE);
}
#endif

/*---------------------------------------------------------------------------
    CPadCore::CPadCore
---------------------------------------------------------------------------*/
CPadCore::CPadCore(CKorIMX* pTip)
{
    m_pImx = pTip;

    //
    // Pad callback
    //
    m_pPadCB = new CPadCB;
    if (m_pPadCB)
        {
        m_pPadCB->Initialize((void *)this);
        }
    Assert(m_pPadCB != 0);
    
    //
    // Pad server
    //
    HRESULT hr;
    hr = CImePadSvrUIM::CreateInstance(g_hInst,    //Your IME module's instance handle.
                                       &m_pPadSvr,        //CImePadSvrUIM's pointer's pointer
                                       0,                        //Reserved. must be zero.
                                       0);                        //Reserved. must be zero.
    Assert(SUCCEEDED(hr));

    m_fShown = FALSE;

}

/*---------------------------------------------------------------------------
    CPadCore::~CPadCore
---------------------------------------------------------------------------*/
CPadCore::~CPadCore()
{
    if (m_pPadSvr)
        {
        m_pPadSvr->Terminate(NULL);
        CImePadSvrUIM::DeleteInstance(m_pPadSvr, 0);
        m_pPadSvr = NULL;
        }
    
    if (m_pPadCB)
        {
        delete m_pPadCB;
        m_pPadCB = NULL;
        }
}

/*---------------------------------------------------------------------------
    CPadCore::SetIPoint
---------------------------------------------------------------------------*/
void CPadCore::SetIPoint(IImeIPoint1* pIP)
{
    if (m_pPadSvr == NULL)
        {
        return; // error
        }
    
    if (m_pPadSvr)
        {
        m_pPadSvr->SetIUnkIImeIPoint((IUnknown *)pIP);
        }
}

/*---------------------------------------------------------------------------
    CPadCore::InitializePad
---------------------------------------------------------------------------*/
BOOL CPadCore::InitializePad()
{
    INT iRet;
    
    if (m_pPadSvr == NULL)
        {
        return FALSE;    // do nothing
        }
    
    iRet = m_pPadSvr->Initialize(MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), 0, NULL);

    if (iRet != 0)
        {
        return FALSE;
        }
    
    //990525:ToshiaK. callback interface pointer is temporary
    m_pPadSvr->SetIUnkIImeCallback((IUnknown *)m_pPadCB);
    
    return TRUE;
}

/*---------------------------------------------------------------------------
    CPadCore::PadBoot
---------------------------------------------------------------------------*/
void CPadCore::PadBoot(IImeIPoint1* pIP, IID* piid)
{
    if (m_pPadSvr)
        {
        if (InitializePad())
            {
            SetIPoint(pIP);
            UINT_PTR uiParam = (UINT_PTR)piid;
            m_pPadSvr->ActivateApplet(IMEPADACTID_ACTIVATEBYIID, uiParam, NULL, NULL);
            }
        }
}

#if 0
void CPadCore::PadBoot(IImeIPoint* pIP, UINT uiType)
{
    HRESULT hr;
    
    if (pIP == NULL)
        {
        return;
        }
    
    if (m_pPadSvr == NULL)
        {
        return;
        }
    
    InitializePad();    // initialize PAD engine
    SetIPoint(pIP);

    switch( uiType ) {
        case JCONV_C_SKF: {
            m_pPadSvr->ShowUI(TRUE);
        }
        break;
        case JCONV_C_SYMBOLPAD: {
            m_pPadSvr->ActivateApplet(IMEPADACTID_ACTIVATEBYIID,
                                             (UINT_PTR)&IID_SymbolList,    //IPACID_SYMBOLSEARCH,
                                             NULL, 
                                             NULL);
        }
        break;
        case JCONV_C_CONVPART: {
            IImePhrase* pPhrase;
            WCHAR wszCompStr[128];
            WCHAR wszTypeStr[128];
            INT cwchComp = 127;
            INT cwchType = 127;
            //
            // type str
            //
            hr = pIP->GetPhrase( IPCURRENTPHRASE, &pPhrase, wszTypeStr, &cwchType );
            if( hr!= S_OK ) {
                cwchType = 0;
            }
            if( hr != S_OK ) {
                cwchType = 0;
            }
            wszTypeStr[cwchType] = L'\0';
            //
            // reading
            //
            if( pPhrase && cwchType != 0) {
                INT iIdx = IMEPCA_CURRENT;
                pPhrase->GetPhraseReadingString( &iIdx, wszCompStr, &cwchComp ); // get size
                wszCompStr[cwchComp] = L'\0';    // terminator
            }
            if(IsHiraString(wszCompStr)) {
                //for #2808
                //for #4824
                if(IsKigo(wszCompStr) || IsGaiji(wszCompStr)) { 
                    m_pPadSvr->ActivateApplet(IMEPADACTID_ACTIVATEBYIID,
                                                 (UINT_PTR)&IID_SymbolList,    //IPACID_SYMBOLSEARCH,
                                                 wszTypeStr,
                                                 wszCompStr);
                }
                else {
                    m_pPadSvr->ActivateApplet(IMEPADACTID_ACTIVATEBYIID,
                                                 (UINT_PTR)&IID_RadicalStrokeList,    //IPACID_RADICALSEARCH,
                                                 wszTypeStr,
                                                 wszCompStr);
                }
            }
            else {
                m_pPadSvr->ActivateApplet(IMEPADACTID_ACTIVATEBYIID,
                                             (UINT_PTR)&IID_SymbolList,    //IPACID_SYMBOLSEARCH,
                                             wszTypeStr,
                                             wszCompStr);
            }
        }
        break;
        default:
            break;
    }
}
#endif

/*---------------------------------------------------------------------------
    CPadCore::ShowPad
---------------------------------------------------------------------------*/
void CPadCore::ShowPad(BOOL fShow)
{
    if (m_pPadSvr)
        {
        m_pPadSvr->ShowUI( fShow );
        }
    m_fShown = fShow;
}


/*---------------------------------------------------------------------------
    CPadCore::IMEPadNotify
    Notification callback from IMEPad
---------------------------------------------------------------------------*/
void CPadCore::IMEPadNotify(BOOL fShown)
{
    m_fShown = fShown;
}

/*---------------------------------------------------------------------------
    CPadCore::SetFocus
---------------------------------------------------------------------------*/
void CPadCore::SetFocus(BOOL fFocus)
{
    if (m_pPadSvr)
        {
        m_pPadSvr->Notify(IMEPADNOTIFY_ACTIVATECONTEXT, fFocus, 0);
        }
}

#if 0
/*---------------------------------------------------------------------------
    CPadCore::GetHWInfo
    Get HW category icon stuff
---------------------------------------------------------------------------*/
BOOL CPadCore::GetHWInfo( BSTR* pbsz, HICON* phIcon )
{
    ITfThreadMgr         *ptim  = m_pImx->GetTIM();
    ITfLangBarItemMgr    *plbim = NULL;
    ITfLangBarItem       *pCat;
    ITfLangBarItemButton *pCatBtn;
    HRESULT hr;

    if (IsHWTIP() == FALSE)
        {
        return FALSE;
        }

    if (FAILED(hr = GetService(ptim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim)))
        {
        return FALSE;
        }
    
    hr = plbim->GetItem(GUID_TFCAT_TIP_HANDWRITING, &pCat);
    if (SUCCEEDED(hr))
        {
        hr = pCat->QueryInterface(IID_ITfLangBarItemButton, (void **)&pCatBtn);
        if (SUCCEEDED(hr))
            {
            pCatBtn->GetIcon(phIcon);
            pCatBtn->GetTooltipString(pbsz);
            pCatBtn->Release();
            }
        pCat->Release();
        }
    plbim->Release();
    
    return TRUE;
}
#endif

/*---------------------------------------------------------------------------
    CPadCore::MakeAppletMenu
---------------------------------------------------------------------------*/
UINT CPadCore::MakeAppletMenu(UINT uidStart, UINT uidEnd, ITfMenu *pMenu, LPIMEPADAPPLETCONFIG *ppCfg)
{
    LPIMEPADAPPLETCONFIG pCfgOrg, pCfgNew = NULL;
    int ci, ciApplets;
    WCHAR szText[256];
    HRESULT hr;

    if (m_pImx == NULL)
        {
        return 0;
        }
    
    if (!InitializePad())
        {
        return 0;
        }

    pCfgOrg = NULL;
   
    hr = m_pPadSvr->GetAppletConfigList(IMEPADAPPLETCFGMASK_ALL, &ci, &pCfgOrg);
    if ((S_OK != hr) || pCfgOrg == NULL)
        {
        return 0;
        }

    //
    // Copy CoTaskMemAlloced to MemAlloc version
    //
    pCfgNew = (LPIMEPADAPPLETCONFIG)MemAlloc(ci * sizeof(IMEPADAPPLETCONFIG));
    if (pCfgNew == NULL)
        {
        return 0;
        }
    CopyMemory(pCfgNew, pCfgOrg, ci*sizeof(IMEPADAPPLETCONFIG));

    //
    // release if previous data is existing
    // pCfgOrg->hIcon should be deleted by client (CPad class)
    //
    CoTaskMemFree(pCfgOrg);

    *ppCfg = pCfgNew;

#if 0
    CMenuHelperCic* pcmh = new CMenuHelperCic(g_hInst, m_pImx);

    //
    // special menu item for HW TIP
    //
    HICON hIcon;
    BSTR bsz;
    if (GetHWInfo(&bsz, &hIcon))
        {
        pcmh->AppendItem(IDC_PAD_HW, MDS_TYPE_ICONDATA|MDS_TYPE_TEXTDATA, (ULONG_PTR)bsz, (ULONG_PTR)hIcon);

        SysFreeString(bsz);
        DestroyIcon(hIcon);

        //
        // separator
        //
        pcmh->AppendItem(MDS_VID_SEPARATOR, 0, (ULONG_PTR)0, (ULONG_PTR)0);
        }
#endif

    // Add Applet menu
    ciApplets = min(ci, (INT)(uidEnd-uidStart));
    
    for (int i = 0; i < ciApplets; i++)
        {
        LangBarInsertMenu(pMenu, uidStart + i, (pCfgNew+i)->wchTitle, FALSE, (HICON)(pCfgNew+i)->hIcon);
        }

    // Insert separator
    LangBarInsertSeparator(pMenu);

    // Insert Cancel
    LoadStringExW(g_hInst, IDS_CANCEL, szText, sizeof(szText)/sizeof(WCHAR));
    LangBarInsertMenu(pMenu, IDCANCEL, szText);
    
    return ciApplets;
}

#if 0
BOOL CPadCore::IsHWTIP(void)
{
    return FALSE;
#ifdef SPEC_CHANGE
    HRESULT hr;

    CLSID clsidHWTip;
    hr = CLSIDFromProgID( TEXT(L"MS.Handwriting.TIP"), &clsidHWTip );
    if( FAILED(hr) ) {
        return FALSE;
    }

    GUID guidWritingPad;
    hr = CLSIDFromProgID( TEXT(L"MS.Handwriting.WritingPad"), &guidWritingPad );
    if( FAILED(hr) ) {
        return FALSE;
    }

    
    ITfInputProcessorProfiles *pProfile;
    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (FAILED(hr)) {
        return FALSE;
    }
    //
    // enum tips
    //
    IEnumTfLanguageProfiles* pEnum;
    hr = pProfile->EnumLanguageProfiles( CKBDTip::GetLanguage(), &pEnum );
    if (FAILED(hr)) {
        pProfile->Release();
        return S_FALSE;
    }

    TF_LANGUAGEPROFILE lp;
    ULONG ulFetched;
    BOOL fExist = FALSE;

    while (pEnum->Next(1, &lp,  &ulFetched) == S_OK) {
        if( IsEqualCLSID( lp.clsid, clsidHWTip ) && IsEqualCLSID( lp.guidProfile, guidWritingPad) ) {
            fExist = TRUE;
            break;
        }
    }

    pEnum->Release();
    pProfile->Release();

    return fExist;
#endif // SPEC_CHANGE
}

BOOL CPadCore::InvokeHWTIP(void)
{
    if (IsHWTIP() == FALSE)
        {
        return FALSE;
        }

    HRESULT hr;
    CLSID clsidHWTip;
    hr = CLSIDFromProgID( TEXT(L"MS.Handwriting.TIP"), &clsidHWTip);
    if( FAILED(hr) ) {
        return FALSE;
    }

    GUID guidWritingPad;
    hr = CLSIDFromProgID( TEXT(L"MS.Handwriting.WritingPad"), &guidWritingPad );
    if( FAILED(hr) ) {
        return FALSE;
    }


    ITfInputProcessorProfiles *pProfile;
    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (FAILED(hr)) {
        return FALSE;
    }

    hr = pProfile->ActivateLanguageProfile(clsidHWTip, CKBDTip::GetLanguage(), guidWritingPad);

    pProfile->Release();

    return (SUCCEEDED(hr) ? TRUE : FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\private.h ===
//
//  Private.h
//
//  Contents:   Private header for korimx project.
//

#if !defined (__PRIVATE_H__INCLUDED_)
#define __PRIVATE_H__INCLUDED_

#define _OLEAUT32_

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>
#include <olectl.h>
#include <debug.h>
#include <initguid.h>
#include "common.h"
#include "crtfree.h"
#include "msctf.h"
#include "ipoint1.h"

#include "mem.h" // must be last

#define fTrue   1
#define fFalse  0

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#endif  // __PRIVATE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\range.cpp ===
//
// range.cpp
//

#include "private.h"
#include "globals.h"
#include "korimx.h"
#include "xstring.h"
#include "immxutil.h"
#include "helpers.h"
#include "kes.h"
#include "mes.h"
#include "editcb.h"

#if 0
void CKorIMX::BackupRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRange)
{
    CICPriv *picp = GetICPriv(pic);
    
    if (pic && picp && pRange) 
        {
        ITfRangeBackup* pBackupRange = NULL;

        //
        // release previuos
        //
        pBackupRange = picp->GetBackupRange();
        if (pBackupRange) 
            SafeReleaseClear(pBackupRange);

        //
        // create new backup range
        //
        pic->CreateRangeBackup(ec, pRange, &pBackupRange);
        picp->SetBackupRange(pBackupRange);

        if (pBackupRange == NULL)
            return;
        }
}

VOID CKorIMX::RestoreRange(TfEditCookie ec, ITfContext *pic)
{
    CICPriv *picp = GetICPriv(pic);

    if (pic && picp) 
        {
        ITfRangeBackup *pBackupRange = picp->GetBackupRange();
        ITfRange       *pRange;

        if (pBackupRange == NULL)
            return; // no backup is exist

        pBackupRange->GetRange(&pRange);
        pBackupRange->Restore(ec, pRange);        // restore to original
        pRange->Release();
        }
}

VOID CKorIMX::SetIPRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRange)
{
    CICPriv *picp = GetInputContextPriv(pic);
    
    if (picp)
        {
        ITfRange* pClone = NULL;
        // delete previous IPRange
        SafeRelease(picp->GetActiveRange());

        if (pRange)
            {
            Assert(m_ptim != NULL);
            pRange->Clone(&pClone);
            pClone->SetGravity(ec, TF_GRAVITY_FORWARD, TF_GRAVITY_BACKWARD);
            } 
        else 
            {
            // delete property store
            // ResetDiscard();
            }

        picp->SetActiveRange(pClone);
        }
}


ITfRange* CKorIMX::GetIPRange(TfEditCookie ec, ITfContext *pic)
{
    CICPriv *picp = GetInputContextPriv(pic);
    
    if (picp) 
        {
        ITfRange* pRange;
        ITfRange* pClone = NULL;

        pRange = picp->GetActiveRange();

        if (pRange)
            {
            pRange->Clone(&pClone);
            pClone->SetGravity(ec, TF_GRAVITY_BACKWARD, TF_GRAVITY_FORWARD);
            }

        return pClone;
        }

    return NULL;
}

ITfRange* CKorIMX::CreateIPRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRangeOrg)
{
    ITfRange* pRangeIP;

    if (pRangeOrg == NULL)
        return NULL;

    Assert(m_ptim != NULL);

    pRangeOrg->Clone(&pRangeIP);

    SetIPRange(ec, pic, pRangeIP);    // register
    pRangeIP->SetGravity(ec, TF_GRAVITY_BACKWARD, TF_GRAVITY_FORWARD);
    
    return pRangeIP;
}

BOOL CKorIMX::FlushIPRange(TfEditCookie ec, ITfContext *pic)
{
    // reset range
    SetIPRange(ec, pic, NULL);    // reset

    // clear attribute range
    // ClearAttr(ec, pic, pIPRange);

    return FALSE;
}
#endif


//+---------------------------------------------------------------------------
//
// OnCompositionTerminated
//
// Cicero calls this method when one of our compositions is terminated.
//----------------------------------------------------------------------------
STDAPI CKorIMX::OnCompositionTerminated(TfEditCookie ec, ITfComposition *pComposition)
{
    ITfRange         *pRange;
    ITfContext         *pic;
    CEditSession2     *pes;
    ESSTRUCT            ess;
    HRESULT            hr;

    // finalize the covered text.
    // nb:  there are no rules about what a tip has to do when it recevies this
    // callback.  We will clear out the display attributes arbirarily and because
    // it provides visual feedback for testing.

    pComposition->GetRange(&pRange);
    pRange->GetContext(&pic);


    hr = E_OUTOFMEMORY;

    ESStructInit(&ess, ESCB_COMPLETE);

    ess.pRange = pRange;
    
    if (pes = new CEditSession2(pic, this, &ess, CKorIMX::_EditSessionCallback2))
        {
        // Word will not allow synchronous lock at this point.
        pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
        pes->Release();
        }

    pRange->Release();
    pic->Release();

    return S_OK;
}

ITfComposition * CKorIMX::GetIPComposition(ITfContext *pic)
{
    CICPriv *picp = GetInputContextPriv(pic);
    
    if (picp)
        return picp->GetActiveComposition();

    return NULL;
}

ITfComposition * CKorIMX::CreateIPComposition(TfEditCookie ec, ITfContext *pic, ITfRange* pRangeComp)
{
    ITfContextComposition *picc;
    ITfComposition     *pComposition;
    CICPriv          *pICPriv;    
    HRESULT hr;

    if (pRangeComp == NULL)
        return NULL;
    
    hr = pic->QueryInterface(IID_ITfContextComposition, (void **)&picc);
    Assert(hr == S_OK);

    if (picc->StartComposition(ec, pRangeComp, this, &pComposition) == S_OK)
        {
        if (pComposition != NULL) // NULL if the app rejects the composition
            {
            CICPriv *picp = GetInputContextPriv(pic);

            if (picp)
                SetIPComposition(pic, pComposition);
            else 
                {
                pComposition->Release();
                pComposition = NULL;
                }
            }
        }
    picc->Release();

    // Create Mouse sink only for AIMM
       if (GetAIMM(pic) && (pICPriv = GetInputContextPriv(pic)) != NULL)
        {
        CMouseSink *pMouseSink;

        // Create Mouse sink
        if ((pMouseSink = pICPriv->GetMouseSink()) != NULL)
            {
            pMouseSink->_Unadvise();
            pMouseSink->Release();
            pICPriv->SetMouseSink(NULL);
            }
            
        if (pMouseSink = new CMouseSink(CICPriv::_MouseCallback, pICPriv))
            {
            pICPriv->SetMouseSink(pMouseSink);
            // set inward gravity to hug the text
            pRangeComp->SetGravity(ec, TF_GRAVITY_FORWARD, TF_GRAVITY_BACKWARD);
            pMouseSink->_Advise(pRangeComp, pic);
            }
        }

    return pComposition;
}


void CKorIMX::SetIPComposition(ITfContext *pic, ITfComposition *pComposition)
{
    CICPriv *picp = GetInputContextPriv(pic);
    
    if (picp)
        picp->SetActiveComposition(pComposition);
}


BOOL CKorIMX::EndIPComposition(TfEditCookie ec, ITfContext *pic)
{
    ITfComposition *pComposition;
    
    pComposition = GetIPComposition(pic);
    
    if (pComposition)
        {
        CICPriv  *pICPriv;
        
        SetIPComposition(pic, NULL);
        pComposition->EndComposition(ec);
        pComposition->Release();

        // kill any mouse sinks
        if (GetAIMM(pic) && (pICPriv = GetInputContextPriv(pic)) != NULL)
            {
            CMouseSink *pMouseSink;

            if ((pMouseSink = pICPriv->GetMouseSink()) != NULL)
                {
                pMouseSink->_Unadvise();
                pMouseSink->Release();
                pICPriv->SetMouseSink(NULL);
                }
            }
        
        return TRUE;
        }
    return FALSE;
}


#if 0
VOID CKorIMX::RestoreRangeRequest(ITfContext* pic)
{
    CEditSession *pes;
    HRESULT hr;

    if (pic == NULL)
        return;

    if (pes = new CEditSession(_EditSessionCallback))
        {
        pes->_state.u = ESCB_RESTORERANGE;
        pes->_state.pv = (VOID*)this;
        pes->_state.wParam = (WPARAM)0;
        pes->_state.pRange = NULL;
        pes->_state.pic = pic;

        pic->EditSession( m_tid, pes, TF_ES_READWRITE | TF_ES_SYNC, &hr);

        SafeRelease(pes);
        }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by korimx.rc
//
#define IDS_PROGRAM                     1
#define IDS_DELBYJASO					2
#define IDS_2BEOL						3
#define IDS_3BEOL390					4
#define IDS_3BEOLFINAL					5
#define IDS_BUTTON_HAN_ENG          	6
#define IDS_BUTTON_JUN_BAN           	7
#define IDS_BUTTON_HANJA_CONV        	8
#define IDS_BUTTON_IME_PAD           	9
#define IDS_BUTTON_SOFTKBD				10
#define IDS_TT_HAN_ENG					11
#define IDS_TT_JUN_BAN					12
#define IDS_TT_HANJA_CONV				13
#define IDS_TT_IME_PAD                  14
#define IDS_HELP_DISPLAYNAME			15
#define IDS_HELP_FILENAME				16
/*
#define IDS_HANGUL_MODE					13
#define IDS_ENGLISH_MODE				14
#define IDS_JUNJA_MODE					15
#define IDS_BANJA_MODE					16
*/
#define IDS_CANCEL						20
#define IDS_CONTEXTHELP_FILENAME        21
#define IDS_PROFILEDESC                  22

#define IDI_ICONBASE                    100
#define IDI_UNIKOR                      100
#define IDI_ICON_OPEN                   101
#define IDI_ICON_CLOSE                  102
#define IDI_ICON_CANDMENU               103
#define IDI_CMODE_HANGUL				104
#define IDI_CMODE_HANGULW				105
#define IDI_CMODE_ENGLISH				106
#define IDI_CMODE_ENGLISHW				107
#define IDI_CMODE_BANJA					108
#define IDI_CMODE_BANJAW				109
#define IDI_CMODE_JUNJA					110
#define IDI_CMODE_JUNJAW				111
#define IDI_CMODE_HANJA					112
#define IDI_CMODE_HANJAW				113
#define IDI_SOFTKBD						114
#define IDI_PAD                         115

#define IDD_CONFIG_PAGE1                200

#define IDC_GRP_KEYLAYOUT               1001
#define IDC_2BEOLSIK                    1005
#define IDC_3BEOLSIK_390                1006
#define IDC_3BEOLSIK_FINAL              1007
#define IDC_DELJASO                     1008
#define IDC_IMEPAD                      1010
#define IDC_IME_ICON                    1011
#define IDC_K1HANJA                     1012

// For IME Pad Applet menu list. Max 100 applets
#define IDR_PAD_FIRST                   2200
#define IDR_PAD_END                     2299
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\server.cpp ===
/****************************************************************************
   SERVER.CPP : COM server functionality

   History:
      15-NOV-1999 CSLim Created
****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "regsvr.h"
#include "regimx.h"
#include "init.h"
#include "gdata.h"
#include "catutil.h"
#include "insert.h"
#include "immxutil.h"
#include "hanja.h"

#if !defined(NOCLIB) && defined(_M_IX86)
extern "C" BOOL WINAPI _CRT_INIT(HINSTANCE, DWORD, LPVOID);
#endif


#ifdef DEBUG
DWORD g_dwThreadDllMain = 0;
#endif

void DllAddRef(void);
void DllRelease(void);

LONG g_cRefDll = 0;

//
//  CClassFactory declaration with IClassFactory Interface
//
class CClassFactory : public IClassFactory
{
public:
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory methods
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    virtual STDMETHODIMP LockServer(BOOL fLock);

    // Constructor & Destructor
    CClassFactory(REFCLSID rclsid, HRESULT (*pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj));
    ~CClassFactory();

public:
    REFCLSID _rclsid;
    HRESULT (*_pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
};

CClassFactory::CClassFactory(REFCLSID rclsid, HRESULT (*pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj))
    : _rclsid( rclsid ), _pfnCreateInstance( pfnCreateInstance )
{
    DebugMsg(DM_TRACE, TEXT("constructor of CClassFactory 0x%08x"), this);
}

CClassFactory::~CClassFactory()
{
    DebugMsg(DM_TRACE, TEXT("destructor of CClassFactory 0x%08x"), this);
}

STDAPI CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("CClassFactory::QueryInterface called."));
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IClassFactory*);
        DllAddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDAPI_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    DebugMsg(DM_TRACE, TEXT("CClassFactory::AddRef called. g_cRefDll=%d"), g_cRefDll);
    return g_cRefDll;
}

STDAPI_(ULONG) CClassFactory::Release()
{
    DllRelease();
    DebugMsg(DM_TRACE, TEXT("CClassFactory::Release called. g_cRefDll=%d"), g_cRefDll);
    return g_cRefDll;
}

STDAPI CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("CClassFactory::CreateInstance called."));
    return this->_pfnCreateInstance(pUnkOuter, riid, ppvObj);
}

STDAPI CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    DebugMsg(DM_TRACE, TEXT("CClassFactory::LockServer(%s) to %d"), fLock ? TEXT("LOCK") : TEXT("UNLOCK"), g_cRefDll);
    return S_OK;
}

//
//  Build Global Objects
//

CClassFactory *g_ObjectInfo[1] = { NULL };

void BuildGlobalObjects(void)
{
    DebugMsg(DM_TRACE, TEXT("BuildGlobalObjects called."));

    // Build CClassFactory Objects
    g_ObjectInfo[0] = new CClassFactory(CLSID_KorIMX, CKorIMX::CreateInstance);

    // You can add more object info here.
    // Don't forget to increase number of item for g_ObjectInfo[],
    // and add function prototype to private.h
}

void FreeGlobalObjects(void)
{
    DebugMsg(DM_TRACE, TEXT("FreeGlobalObjects called."));
    // Free CClassFactory Objects
    for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
    {
        if (NULL != g_ObjectInfo[i])
        {
            delete g_ObjectInfo[i];
            g_ObjectInfo[i] = NULL;
        }
    }
}

/*---------------------------------------------------------------------------
    DllMain
---------------------------------------------------------------------------*/
STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    WNDCLASSEX  wndclass;

#if DEBUG
    g_dwThreadDllMain = GetCurrentThreadId();
#endif
    
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
#if !defined(NOCLIB) && defined(_M_IX86)
            _CRT_INIT(hInstance, dwReason, pvReserved);
#endif
            CcshellGetDebugFlags();
            Dbg_MemInit(TEXT("KORIMX"), NULL);
           
            g_hInst = hInstance;

            g_cs.Init();

            ZeroMemory(&wndclass, sizeof(wndclass));
            wndclass.cbSize        = sizeof(wndclass);
            wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
            wndclass.hInstance     = hInstance;
            wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);

            wndclass.lpfnWndProc   = CKorIMX::_OwnerWndProc;
            wndclass.lpszClassName = c_szOwnerWndClass;
            RegisterClassEx(&wndclass);

            // Initialize Shared memory
            CIMEData::InitSharedData();

            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            UnregisterClass(c_szOwnerWndClass, g_hInst);

            g_cs.Delete();

#if !defined(NOCLIB) && defined(_M_IX86)
            _CRT_INIT(hInstance, dwReason, pvReserved);
#endif
            // Close lex file if has opened ever.
            CloseLex();
            
            // Close shared memory
            CIMEData::CloseSharedMemory();

            // This should be last.
            Dbg_MemUninit();
            break;

        case DLL_THREAD_DETACH:
            break;
    }

#if DEBUG
    g_dwThreadDllMain = 0;
#endif

    return TRUE;
}

/*---------------------------------------------------------------------------
    DllAddRef
---------------------------------------------------------------------------*/
void DllAddRef(void)
{
    InterlockedIncrement(&g_cRefDll);
    ASSERT(1000 > g_cRefDll);   // reasonable upper limit
    DllInit();
}

/*---------------------------------------------------------------------------
    DllRelease
---------------------------------------------------------------------------*/
void DllRelease(void)
{
    InterlockedDecrement(&g_cRefDll);
    if (0 == g_cRefDll)
        FreeGlobalObjects();
    ASSERT(0 <= g_cRefDll);     // don't underflow
    DllUninit();
}

/*---------------------------------------------------------------------------
    DllGetClassObject
---------------------------------------------------------------------------*/
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("DllGetClassObject called."));
    if (0 == g_cRefDll)
        BuildGlobalObjects();

    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
        {
            if (NULL != g_ObjectInfo[i] && IsEqualGUID(rclsid, g_ObjectInfo[i]->_rclsid))
            {
                *ppvObj = (void *)g_ObjectInfo[i];
                DllAddRef();    // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }
    *ppvObj = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}

/*---------------------------------------------------------------------------
    DllCanUnloadNow
---------------------------------------------------------------------------*/
STDAPI DllCanUnloadNow(void)
{
    if (0 < g_cRefDll)
        return S_FALSE;
    DebugMsg(DM_TRACE, TEXT("DllCanUnloadNow returning S_OK"));
    return S_OK;
}

// TIP Categories to be added
const REGISTERCAT c_rgRegCat[] =
{
    {&GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER,     &CLSID_KorIMX},
    {&GUID_TFCAT_TIP_KEYBOARD,                 &CLSID_KorIMX},
    {&GUID_TFCAT_PROPSTYLE_CUSTOM,             &GUID_PROP_OVERTYPE},
    {NULL, NULL}
};


// TIP Profile name
const REGTIPLANGPROFILE c_rgProf[] =
{
    { MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), &GUID_Profile, SZ_TIPDISPNAME, SZ_TIPMODULENAME, (IDI_UNIKOR-IDI_ICONBASE), IDS_PROFILEDESC },
    {0, &GUID_NULL, L"", L"", 0, 0}
};

BOOL FIsAvailable( REFCLSID refclsid, BOOL fLocalSvr );

/*---------------------------------------------------------------------------
    DllRegisterServer
---------------------------------------------------------------------------*/
STDAPI DllRegisterServer(void)
{
    TCHAR achPath[MAX_PATH+1];
    HRESULT hr = E_FAIL;

    TFInitLib();
    
    if (GetModuleFileName(g_hInst, achPath, ARRAYSIZE(achPath)) == 0)
        goto Exit;

    if (!RegisterServer(CLSID_KorIMX, SZ_TIPSERVERNAME, achPath, TEXT("Apartment"), NULL))
        goto Exit;

    if (!RegisterTIP(g_hInst, CLSID_KorIMX, SZ_TIPNAME, c_rgProf))
        goto Exit;

    if (FAILED(RegisterCategories(CLSID_KorIMX, c_rgRegCat)))
        goto Exit;

    hr = S_OK;

Exit:
    TFUninitLib();
    return hr;
}

/*---------------------------------------------------------------------------
    DllUnregisterServer
---------------------------------------------------------------------------*/
STDAPI DllUnregisterServer(void)
{
    HRESULT hr = E_FAIL;

    TFInitLib();

    if (FAILED(hr = RegisterServer(CLSID_KorIMX, NULL, NULL, NULL, NULL) ? S_OK : E_FAIL))
        goto Exit;

    if (FAILED(UnregisterCategories(CLSID_KorIMX, c_rgRegCat)))
        goto Exit;

    if (!UnregisterTIP(CLSID_KorIMX))
        goto Exit;

    hr = S_OK;

Exit:
    TFUninitLib();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\skbdkor.cpp ===
/****************************************************************************
   SOFTKBD.CPP : 
   
   History:
      19-SEP-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "korimx.h"
#include "softkbd.h"
#include "skbdkor.h"
#include "softkbdes.h"
#include "gdata.h"
#include "helpers.h"

PICTUREKEY  gPictureKeys[NUM_PICTURE_KEYS+1] = 
{
    // uScanCode,    uVKey
    { KID_LWINLOGO,  VK_LWIN    },
    { KID_RWINLOGO,  VK_RWIN    },
    { KID_APPS,      VK_APPS    },

    { KID_LEFT,      VK_LEFT    },
    { KID_RIGHT,     VK_RIGHT   },
    { KID_UP,        VK_UP      },
    { KID_DOWN,      VK_DOWN    },

    { KID_ESC,       VK_ESCAPE  },

    { KID_BACK,      VK_BACK    },
    { KID_TAB,       VK_TAB     },
    { KID_CAPS,      VK_CAPITAL },
    { KID_ENTER,     VK_RETURN  },
    { KID_LSHFT,     VK_SHIFT   },
    { KID_RSHFT,     VK_SHIFT   },
    { KID_CTRL,      VK_CONTROL },
    { KID_RCTRL,     VK_CONTROL },
    { KID_ALT,       VK_MENU    },
    { KID_RALT,      VK_RMENU   },
    { KID_DELETE,    VK_DELETE  },

    { 0,0 }
};

/*---------------------------------------------------------------------------
    CKorIMX::InitializeSoftKbd
---------------------------------------------------------------------------*/
HRESULT CKorIMX::InitializeSoftKbd()
{
    DWORD    dwFileLen;
    WCHAR    wszModuleFile[MAX_PATH];
    CHAR     szModuleFile[MAX_PATH];
    INT         wScreenWidth, wScreenHeight;
    INT         left, top, width, height;  
    RECT     rcWork;
    CIMEData ImeData;
    UINT     uiCurBeolSik;
    // SKD resoulrce ID string
    static   LPWSTR rgwzKorXMLResStr[3] = { L"IDSKD_2BEOLSIK", L"IDSKD_3BEOLSIK390", L"IDSKD_3BEOLSIKFINAL" };

    HRESULT  hr;
    
    // if Already initialized
    if (m_fSoftKbdEnabled)
        return S_OK;

    // Create SoftKbd object
    hr = CoCreateInstance(CLSID_SoftKbd, NULL, CLSCTX_INPROC_SERVER, IID_ISoftKbd, (void**)&m_pSoftKbd);
    if (FAILED(hr))
        {
        // assert(0);
        return hr;
        }

    m_pSoftKbd->Initialize();

    // initialize Standard soft layout and Symbol Soft Layout.
    m_KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
    m_KbdStandard.fStandard       = TRUE;
    m_KbdStandard.dwNumLabels     = 0;   // for standard, this field is not really used.
    m_KbdStandard.dwCurLabel      = 0;
    m_KbdStandard.pskbdes         = NULL; // standard layout doesn't supply sftkbd event sink.
    m_KbdStandard.dwSkbdESCookie  = 0;

    // Get current user selection
    uiCurBeolSik = ImeData.GetCurrentBeolsik();

    // US Standard layout
    m_KbdHangul.fStandard   = fFalse;
    m_KbdHangul.dwNumLabels = 2;
    m_KbdHangul.dwCurLabel  = 0;

    // Load Keyboard layout file from resource
    dwFileLen = GetModuleFileNameA(g_hInst, szModuleFile, MAX_PATH);
    if (dwFileLen == 0)
        {
        hr = E_FAIL;
        goto Exit3;
        }

    MultiByteToWideChar(CP_ACP, 0, szModuleFile, -1, wszModuleFile, MAX_PATH);

    hr = m_pSoftKbd->CreateSoftKeyboardLayoutFromResource(wszModuleFile, L"SKDFILE", rgwzKorXMLResStr[uiCurBeolSik], 
                                                        &(m_KbdHangul.dwSoftKbdLayout));
    if (FAILED(hr))
        goto Exit3;

    // Create ISoftKeyboardEventSink for Hangul layout
    m_KbdHangul.pskbdes = new CSoftKeyboardEventSink(this, m_KbdHangul.dwSoftKbdLayout);
    if (m_KbdHangul.pskbdes == NULL )
        {
        hr = E_FAIL;
        goto Exit3;
        }

    hr = m_pSoftKbd->AdviseSoftKeyboardEventSink(m_KbdHangul.dwSoftKbdLayout,
                                                  IID_ISoftKeyboardEventSink,
                                                  m_KbdHangul.pskbdes,
                                                  &(m_KbdHangul.dwSkbdESCookie));

    if (FAILED(hr))
        goto Exit2;

    m_psftkbdwndes = new CSoftKbdWindowEventSink(this);

    if (m_psftkbdwndes == NULL)
        {
        hr = E_FAIL;
        goto Exit2;
        }

    // To handle softkbd window Open/Close event
    hr = m_pSoftKbd->AdviseSoftKeyboardEventSink(0, IID_ISoftKbdWindowEventSink, m_psftkbdwndes, &m_dwSftKbdwndesCookie);
    if (FAILED(hr))
        goto Exit1;

    width  = 400;
    height = 172;

    if (FAILED(GetSoftKBDPosition(&left, &top)))
        {
        // the compartment is not initialize.
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0 );
        wScreenWidth = (INT)(rcWork.right - rcWork.left + 1);
        wScreenHeight = (INT)(rcWork.bottom - rcWork.top + 1);
        left = wScreenWidth - width -2;
        top = wScreenHeight - height - 1;
        }
 
    hr = m_pSoftKbd->CreateSoftKeyboardWindow(m_hOwnerWnd,TITLEBAR_GRIPPER_BUTTON, left, top, width, height);
    if (FAILED(hr))
        goto Exit;

    SetSoftKBDPosition(left, top);

    m_fSoftKbdEnabled = fTrue;

    return hr;

// Error handling
Exit:
    delete m_psftkbdwndes;
    m_psftkbdwndes = 0;

Exit1:
    m_pSoftKbd->UnadviseSoftKeyboardEventSink(m_dwSftKbdwndesCookie);
Exit2:
    delete m_KbdHangul.pskbdes;
    m_KbdHangul.pskbdes = NULL;

Exit3:
       SafeReleaseClear(m_pSoftKbd);
    return hr;
}

/*---------------------------------------------------------------------------
    CKorIMX::TerminateSoftKbd
---------------------------------------------------------------------------*/
void  CKorIMX::TerminateSoftKbd()
{
    SetSoftKBDOnOff(fFalse);

    if (m_pSoftKbd)
       m_pSoftKbd->DestroySoftKeyboardWindow();

    m_fSoftKbdEnabled = fFalse;

    if (m_pSoftKbd)
        {
        if (m_KbdHangul.pskbdes)
            {
            m_pSoftKbd->UnadviseSoftKeyboardEventSink(m_KbdHangul.dwSkbdESCookie);
            delete m_KbdHangul.pskbdes;
            }

        m_pSoftKbd->UnadviseSoftKeyboardEventSink(m_dwSftKbdwndesCookie);
        
        delete m_psftkbdwndes;
        m_psftkbdwndes = 0;
        
        SafeReleaseClear(m_pSoftKbd);
        }
}

#if 0
/*---------------------------------------------------------------------------
    CKorIMX::ToggleSoftKbd
---------------------------------------------------------------------------*/
void CKorIMX::ToggleSoftKbd()
{
 if (m_fSoftKbdEnabled)
     TerminateSoftKbd();
 else
     InitializeSoftKbd();
}

/*---------------------------------------------------------------------------
    CKorIMX::OnActivatedSoftKbd
---------------------------------------------------------------------------*/
void CKorIMX::OnActivatedSoftKbd(BOOl fActivated)
{
    if (fActivated)
        {
        if (GetSoftKBDOnOff())
            m_pSoftKbd->ShowSoftKBDWindow(fTrue);
        }
    else
        {
        if (GetSoftKBDOnOff())
            m_pSoftKbd->ShowSoftKeyboard(fFalse);
        }
}
#endif



/*---------------------------------------------------------------------------
    CKorIMX::ShowSoftKBDWindow
    Show or Hide the soft keyboard window based on current setting.
---------------------------------------------------------------------------*/
HRESULT CKorIMX::ShowSoftKBDWindow(BOOL  fShow)
{
    HRESULT hr = S_OK;

       // call the initialize function to get the ISoftKbd.
    if (fShow && m_fSoftKbdEnabled == fFalse)
        InitializeSoftKbd( );

    if (m_pSoftKbd == NULL)
        return E_FAIL;

    if (fShow)
        {
        //DWORD   dwSoftLayout;

        if ((GetConvMode(GetIC()) & TIP_HANGUL_MODE) == 0)
            {
            // m_KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
            // if (FAILED(hr))
            //    return hr;
               // dwSoftLayout = m_KbdStandard.dwSoftKbdLayout;
            // _CurLayout = m_KbdStandard.dwSoftKbdLayout;

            hr = m_pSoftKbd->SelectSoftKeyboard(m_KbdStandard.dwSoftKbdLayout);
            if (FAILED(hr))
                return hr;

            m_pSoftKbd->SetKeyboardLabelText(GetKeyboardLayout(0));
            if (FAILED(hr))
                return hr;
            }
        else
            {
            hr = m_pSoftKbd->SelectSoftKeyboard(m_KbdHangul.dwSoftKbdLayout);
            if (FAILED(hr))
                return hr;
            m_pSoftKbd->SetKeyboardLabelTextCombination(m_KbdHangul.dwCurLabel);
            if (FAILED(hr))
                return hr;
            }
            
        hr = m_pSoftKbd->ShowSoftKeyboard(fTrue);
        if (FAILED(hr))
            return hr;
        }
    else
        {
        m_pSoftKbd->ShowSoftKeyboard(fFalse);
        }

#if 0
        if ( _CurKbdType  == KBDTYPE_STANDARD ) 
        {
            // Standard soft kbd was selected.
            WORD   prmlangid;

            prmlangid = PRIMARYLANGID(_langid);

            switch ( prmlangid ) {

            case LANG_JAPANESE  :
                // Lang JPN is activated.
                // select the standard layout to J 106-k.
                _KbdStandard.dwSoftKbdLayout = SOFTKBD_JPN_STANDARD;
                break;

            case LANG_AZERI   :
            case LANG_BELARUSIAN :
            case LANG_CHINESE :
            case LANG_KOREAN  :
            case LANG_RUSSIAN :
            case LANG_THAI    :
            case LANG_URDU    :
            case LANG_UZBEK   :
                _KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
                break;

            case LANG_ENGLISH :
                if ( SUBLANGID(_langid) != SUBLANG_ENGLISH_US )
                    _KbdStandard.dwSoftKbdLayout = SOFTKBD_EURO_STANDARD;
                else
                    _KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
                break;

            default           :
                _KbdStandard.dwSoftKbdLayout = SOFTKBD_EURO_STANDARD;
                break;
            }

            // the current layout is standard layout.
            // we need to set the correct standard layout id based on current lang profile.

            dwSoftLayout = _KbdStandard.dwSoftKbdLayout;
            _CurLayout = dwSoftLayout;

            CHECKHR(_SoftKbd->SelectSoftKeyboard(dwSoftLayout));
            CHECKHR(_SoftKbd->SetKeyboardLabelText(GetKeyboardLayout(0)));
        }
        else if ( _CurKbdType  == KBDTYPE_SYMBOL)
        {
            // This is symbol soft keyboard layout
            //
            DWORD   dwCurLabel;
            dwSoftLayout = _KbdSymbol.dwSoftKbdLayout;
            dwCurLabel = _KbdSymbol.dwCurLabel;
            CHECKHR(_SoftKbd->SelectSoftKeyboard(dwSoftLayout));
            CHECKHR(_SoftKbd->SetKeyboardLabelTextCombination(dwCurLabel));

        }

        // TIP is ON, so we need to show soft keyboard.
        CHECKHR(_SoftKbd->ShowSoftKeyboard(TRUE));
    }
    else
    {
        // TIP is going to close.
        // close the soft keyboard window also.
        CHECKHR(_SoftKbd->ShowSoftKeyboard(FALSE));
    }

CleanUp:
#endif

    return  hr;

}

/*---------------------------------------------------------------------------
    CKorIMX::SoftKbdOnThreadFocusChange
---------------------------------------------------------------------------*/
void CKorIMX::SoftKbdOnThreadFocusChange(BOOL fSet)
{
    if (fSet)
        {
        // Restore the ON/OFF status before KillThreadFocus( )
        if (m_pSoftKbd)
            {
            if (m_fSoftKbdOnOffSave) 
                {
                // adjust the window position.
                int     xWnd, yWnd;
                WORD    width=0, height=0;
                POINT   OldPoint;
                HRESULT hr;

                m_pSoftKbd->GetSoftKeyboardPosSize(&OldPoint, &width, &height);
                hr = GetSoftKBDPosition(&xWnd, &yWnd);

                if (hr == S_OK)
                    {
                    if ((xWnd != OldPoint.x) || (yWnd != OldPoint.y))
                        {
                        POINT  NewPoint;

                        NewPoint.x = xWnd;
                        NewPoint.y = yWnd;
                        m_pSoftKbd->SetSoftKeyboardPosSize(NewPoint, width, height);
                        }
                    }

                ShowSoftKBDWindow(fTrue);
                }
            else
                m_pSoftKbd->ShowSoftKeyboard(fFalse);
            }
        }
    else
        {
        // keep the ON/OFF status so that OnSetThreadFocus( ) can restore it later
        m_fSoftKbdOnOffSave = GetSoftKBDOnOff();

        if (m_pSoftKbd)
            m_pSoftKbd->ShowSoftKeyboard(fFalse);

        // release all the modifier keys  except lock keys.  that is , Shift, Alt, Ctrl, 
        keybd_event((BYTE)VK_SHIFT, (BYTE)KID_LSHFT, (DWORD)KEYEVENTF_KEYUP, 0);
        keybd_event((BYTE)VK_MENU,  (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);
        keybd_event((BYTE)VK_LMENU, (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);
        keybd_event((BYTE)VK_RMENU, (BYTE)KID_RALT, (DWORD)KEYEVENTF_KEYUP, 0);
        keybd_event((BYTE)VK_CONTROL, (BYTE)KID_CTRL, (DWORD)KEYEVENTF_KEYUP, 0);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\softkbdes.h ===
// SoftKbdES.h: interface for the SoftKeyboardEventSink class.
//
//////////////////////////////////////////////////////////////////////
#ifndef __SOFTKBDES_H__
#define __SOFTKBDES_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "softkbd.h"

class CKorIMX;


class CSoftKeyboardEventSink : public ISoftKeyboardEventSink  
{
public:
    CSoftKeyboardEventSink(CKorIMX *pKorIMX, DWORD dwSoftLayout);
    ~CSoftKeyboardEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ISoftKeyboardEventSink
    //

    STDMETHODIMP OnKeySelection(KEYID KeySelected, WCHAR  *lpszLabel);

//    void SetTidDim(TfClientId tid, ITfDocumentMgr *dim);
//    void ReleaseTidDim( );

private:

    long          _cRef;
    DWORD         _dwSoftLayout;
    CKorIMX       *m_pKorIMX;
    BOOL          _fCaps;
    BOOL          _fShift;
    BOOL		  _fAlt;
    BOOL	      _fCtrl;
    TfClientId    _tid;
    ITfThreadMgr *_tim;

};


class CSoftKbdWindowEventSink : public ISoftKbdWindowEventSink  
{
public:
    CSoftKbdWindowEventSink(CKorIMX *pKorIMX);
    ~CSoftKbdWindowEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ISoftKbdWindowEventSink
    //

    STDMETHODIMP OnWindowClose( );
    STDMETHODIMP OnWindowMove( int xWnd,int yWnd, int width, int height);

private:

    long     _cRef;
    CKorIMX  *m_pKorIMX;
};
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\skbdmode.h ===
//
// SKBDMODE.H
//

#if !defined (__SKBDMODE_H__INCLUDED_)
#define __SKBDMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class CSoftKbdMode : public CCicButton
{
public:
    CSoftKbdMode(CToolBar *ptb);
    ~CSoftKbdMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    //HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);
    void UpdateToggle();

private:

	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __SKBDMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\skbdkor.h ===
//
//  SOFTKBD.H
//
//  History:
//      19-SEP-2000 CSLim Created

#if !defined (__SKBDKOR_H__INCLUDED_)
#define __SKBDKOR_H__INCLUDED_

#include "softkbd.h"
#include "softkbdes.h"

typedef  struct tagSoftLayout
{
    DWORD   dwSoftKbdLayout;
    BOOL    fStandard;
    DWORD   dwNumLabels;  // Number of Label status. 
    DWORD   dwCurLabel;
    CSoftKeyboardEventSink  *pskbdes;
    DWORD   dwSkbdESCookie;
} SOFTLAYOUT;


// SoftKbd type list
#define  NON_LAYOUT                     	0

//#define  SOFTKBD_US_STANDARD    			1
// Korean customized keyboard layouts
//#define  SOFTKBD_KOR_HANGUL_2BEOLSIK		500
//#define  SOFTKBD_KOR_HANGUL_3BEOLSIK390		501
//#define  SOFTKBD_KOR_HANGUL_3BEOLSIKFINAL	502

#define   NUM_PICTURE_KEYS    19
// Type definition for picture keys in standard soft keyboards.
typedef struct  _tagPictureKey 
{
    UINT      uScanCode;   // same as KeyId in the XML file
    UINT      uVkey;
//    LPWSTR    PictBitmap;
}  PICTUREKEY,  *LPPICTUREKEY;

extern  PICTUREKEY  gPictureKeys[NUM_PICTURE_KEYS+1];

// Key IDs
#define  KID_LWINLOGO       0xE05B
#define  KID_RWINLOGO       0xE05C
#define  KID_APPS           0xE05D

#define  KID_LEFT           0xE04B
#define  KID_RIGHT          0xE04D
#define  KID_UP             0xE048
#define  KID_DOWN           0xE050

#define  KID_ESC            0x01
#define  KID_BACK           0x0E
#define  KID_TAB            0x0F
#define  KID_CAPS           0x3A
#define  KID_ENTER          0x1C
#define  KID_LSHFT          0x2A
#define  KID_RSHFT          0x36
#define  KID_CTRL           0x1D
#define  KID_RCTRL          0xE01D
#define  KID_ALT            0x38
#define  KID_RALT           0xE038
#define  KID_SPACE          0x39

#define  KID_DELETE         0xE053

#define  KID_F1             0x3B
#define  KID_F2             0x3C
#define  KID_F3             0x3D
#define  KID_F4             0x3E
#define  KID_F5             0x3F
#define  KID_F6             0x40
#define  KID_F7             0x41
#define  KID_F8             0x42
#define  KID_F9             0x43
#define  KID_F10            0x44
#define  KID_F11            0x57
#define  KID_F12            0x58

#define  KID_CONVERT        0x79
#define  KID_NONCONVERT     0x7B
#define  KID_KANA           0x70
#define  KID_FULLHALF       0x29    // special used by Japan 106 Key

#endif // __SKBDKOR_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\skbdmode.cpp ===
/****************************************************************************
   SKBDMODE.CPP : CSoftKbdMode class implementation which manage Soft Keyboard 
                     button on the Cicero Toolbar

   History:
      19-SEP-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "skbdmode.h"
#include "userex.h"
#include "immxutil.h"
#include "resource.h"

// {C7BAA1A7-5403-4596-8fe6-DC50C96B2FDD}
const GUID GUID_LBI_KORIMX_SKBDMODE = 
{   
    0xC7BAA1A7, 
    0x5403, 
    0x4596, 
    { 0x8f, 0xe6, 0xdc, 0x50, 0xc9, 0x6b, 0x2f, 0xdd }
};

/*---------------------------------------------------------------------------
    CSoftKbdMode::CSoftKbdMode
---------------------------------------------------------------------------*/
CSoftKbdMode::CSoftKbdMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    // Set Add/Remove and tootip text
    LoadStringExW(g_hInst, IDS_BUTTON_SOFTKBD, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_KorIMX,
                GUID_LBI_KORIMX_SKBDMODE,
                TF_LBI_STYLE_BTN_TOGGLE | TF_LBI_STYLE_HIDDENBYDEFAULT,
                130,
                szText);
    SetToolTip(szText);
    SetText(szText);
}

/*---------------------------------------------------------------------------
    CSoftKbdMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CSoftKbdMode::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    CSoftKbdMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI CSoftKbdMode::GetIcon(HICON *phIcon)
{
    *phIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_SOFTKBD), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);;
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    CSoftKbdMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CSoftKbdMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    CSoftKbdMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CSoftKbdMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
    CSoftKbdMode::OnLButtonUp
---------------------------------------------------------------------------*/
HRESULT CSoftKbdMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    return ToggleCompartmentDWORD(m_pTb->m_pimx->GetTID(), 
                                   m_pTb->m_pimx->GetTIM(), 
                                   GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE, 
                                   FALSE);

}


/*---------------------------------------------------------------------------
    CSoftKbdMode::UpdateToggle
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
void CSoftKbdMode::UpdateToggle()
{
    DWORD dwState = 0;

    GetCompartmentDWORD(m_pTb->m_pimx->GetTIM(), 
                        GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE, 
                        &dwState,
                        FALSE);

    SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED, dwState);
    if (m_plbiSink)
        m_plbiSink->OnUpdate(TF_LBI_STATUS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\softkbdes.cpp ===
/**************************************************************************\
* Module Name: softkbdes.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Soft Keyboard Event Sink for the Symbol layout 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "proputil.h"
#include "kes.h"
#include "helpers.h"
#include "editcb.h"
#include "dispattr.h"
#include "computil.h"
#include "regsvr.h"

#include "korimx.h"
#include "SoftKbdES.h"
#include "osver.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftKeyboardEventSink::CSoftKeyboardEventSink(CKorIMX *pKorIMX, DWORD dwSoftLayout)
{
     m_pKorIMX     = pKorIMX;
     _dwSoftLayout = dwSoftLayout;

     _fCaps  = fFalse;
     _fShift = fFalse;
     _fAlt   = fFalse;
     _fCtrl  = fFalse;
     
     _tid = pKorIMX->GetTID();
     _tim = pKorIMX->GetTIM();

     _tim->AddRef( );
    
     _cRef = 1;
}

CSoftKeyboardEventSink::~CSoftKeyboardEventSink()
{
    SafeReleaseClear(_tim);
}


//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CSoftKeyboardEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ISoftKeyboardEventSink))
    {
        *ppvObj = SAFECAST(this, CSoftKeyboardEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CSoftKeyboardEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CSoftKeyboardEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
//  ISoftKeyboardEventSink
//


STDAPI CSoftKeyboardEventSink::OnKeySelection(KEYID KeySelected, WCHAR  *lpszLabel)
{
    KEYID       keyId;
    BYTE        bVk, bScan;
    BOOL        fModifierSpecial = fFalse;
    HKL            hKL;
    INT_PTR        iHKL;
    HRESULT     hr;

    hr = S_OK;

    bScan = (BYTE)KeySelected;

    hKL = GetKeyboardLayout(0);

    if (!IsOnNT())
        {
        // We have to handle IME hkl specially on Win9x.
        // For some reason, Win9x cannot receive IME HKL as parameter in MapVirtualKeyEx and ToAsciiEx.
        iHKL = (INT_PTR)hKL;

        if ((iHKL & 0xF0000000) == 0xE0000000)
            {
            // this is FE IME HKL.
            iHKL = iHKL & 0x0000FFFF;
            hKL = (HKL)iHKL;
            }
        }
        
    bVk = (BYTE)MapVirtualKeyEx((UINT)bScan, 1, hKL);

    switch (KeySelected)
        {
    case  KID_CTRL  :
        _fCtrl = !_fCtrl;
        
        // Generate proper key msg
        if (_fCtrl)
            keybd_event(bVk, bScan, 0, 0);
        else
            keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
        break;
        
    case  KID_ALT   :
        _fAlt = !_fAlt;

        // Generate proper key msg
        if (_fAlt)
            keybd_event(bVk, bScan, 0, 0);
        else
            keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
        break;

    case  KID_CAPS  :
        if (m_pKorIMX->GetConvMode(m_pKorIMX->GetIC()) == TIP_ALPHANUMERIC_MODE)
            {
            _fCaps = !_fCaps;
            if (_fCaps == _fShift)
                // use state 0
                m_pKorIMX->GetHangulSKbd()->dwCurLabel = 0; 
            else
                // use state 1
                m_pKorIMX->GetHangulSKbd()->dwCurLabel = 1;

            hr = SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, _dwSoftLayout, fFalse);
            }
            
        // specially handle Caps Lock
        // this is a togglable key
        keybd_event(bVk, bScan, 0, 0);
        keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
        break;

    case  KID_LSHFT :
    case  KID_RSHFT :
        _fShift = !_fShift;
        if (_fCaps == _fShift)
            // use state 0
            m_pKorIMX->GetHangulSKbd()->dwCurLabel = 0;
        else
            // use state 1
            m_pKorIMX->GetHangulSKbd()->dwCurLabel = 1;

        hr = SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, _dwSoftLayout, fFalse);

        // Generate proper key msg
        if (_fShift)
            keybd_event(bVk, bScan, 0, 0);
        else
            keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
        break;

/*
    case  KID_F1  :
    case  KID_F2  :
    case  KID_F3  :
    case  KID_F4  :
    case  KID_F5  :
    case  KID_F6  :
    case  KID_F7  :
    case  KID_F8  :
    case  KID_F9  :
    case  KID_F10 :
    case  KID_F11 :
    case  KID_F12 :
    case  KID_TAB :

                  // simulate a key event and send to system.

    case  KID_ENTER :
    case  KID_ESC   :
    case  KID_SPACE :
    case  KID_BACK  :
    case  KID_UP    :
    case  KID_DOWN  :
    case  KID_LEFT  :
    case  KID_RIGHT :
*/
    default:
        {
        int         j, jIndex;
        BOOL        fExtendKey, fPictureKey;

        keyId = KeySelected;
        fPictureKey = fFalse;

        // Check picture key
        for (j=0; j < NUM_PICTURE_KEYS; j++)
            {
            if (gPictureKeys[j].uScanCode == keyId)
                {
                // This is a picture key.
                // it may be a extended key.
                jIndex = j;
                fPictureKey = fTrue;
                break;
                  }

            if (gPictureKeys[j].uScanCode == 0)
                {
                 // This is the last item in gPictureKeys.
                 break;
                }
            }

        fExtendKey = fFalse;

        // Picture key handling
        if (fPictureKey)
            {
              if ((keyId & 0xFF00) == 0xE000)
                  {
                  fExtendKey = fTrue;
                  bScan = (BYTE)(keyId & 0x000000ff);
                  }
              else
                bScan = (BYTE)keyId;

            // Get virtual key code
            bVk = (BYTE)(gPictureKeys[jIndex].uVkey);
            }

        // Generate Keyboard event
        if (fExtendKey)
            {
            keybd_event(bVk, bScan, (DWORD)KEYEVENTF_EXTENDEDKEY, 0);
            keybd_event(bVk, bScan, (DWORD)(KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP), 0);
            }
        else
            {
            keybd_event(bVk, bScan, 0, 0);
            keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
            }
#if 0
        // if the Shift Key is pressed, we need to release this key.
        if (GetKeyState(VK_SHIFT) & 0x80)
            {
            fModifierSpecial = fTrue;
            _fShift = !_fShift;
              // simulate the SHIFT-UP key event.
              keybd_event((BYTE)VK_SHIFT, (BYTE)KID_LSHFT, (DWORD)KEYEVENTF_KEYUP, 0);
            }
            
        // if the Ctrl Key is pressed, we need to release this key.
        if (GetKeyState(VK_CONTROL) & 0x80)
            {
            fModifierSpecial = fTrue;
            // simulate the Ctrl-UP key event.
            keybd_event((BYTE)VK_CONTROL, (BYTE)KID_CTRL, (DWORD)KEYEVENTF_KEYUP, 0);
            }
#endif
            
#if 0
        // if the Alt Key is pressed, we need to release this key.
        if (lpCurKbdLayout->ModifierStatus & MODIFIER_ALT)
            {
            fModifierSpecial = TRUE;
            lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_ALT);

            // simulate the SHIFT-UP key event.
            keybd_event((BYTE)VK_MENU, (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);
            }

        // if the Right Alt Key is pressed, we need to release this key.
        if (lpCurKbdLayout->ModifierStatus & MODIFIER_ALTGR)
            {
            fModifierSpecial = TRUE;
            lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_ALTGR);

            // simulate the SHIFT-UP key event.
            keybd_event((BYTE)VK_RMENU, (BYTE)KID_RALT, (DWORD)KEYEVENTF_KEYUP, 0);
            }
#endif

        if (fModifierSpecial)
            {
            if (_fCaps == _fShift)
                // use state 0
                m_pKorIMX->GetHangulSKbd()->dwCurLabel = 0;
            else
                // use state 1
                m_pKorIMX->GetHangulSKbd()->dwCurLabel = 1;
                hr = SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, _dwSoftLayout, fFalse);            
            }
            
        break;
        }

/*
      default         :


              if ( lpszLabel == NULL )
              {
                 hr = E_FAIL;

                 return hr;
              }

              pic = m_pKorIMX->GetIC( );

              if ( pic == NULL )
              {
                  return hr;
              }

              if (pes = new CEditSession(CKorIMX::_EditSessionCallback))
              {

                 WCHAR   *lpLabel;
                 int     i, iLen;

                 iLen = (int) wcslen(lpszLabel);
                 lpLabel = (WCHAR *)cicMemAllocClear((iLen+1)*sizeof(WCHAR));
                
                 if ( lpLabel == NULL )
                 {
                    // not enough memory.

                    hr = E_OUTOFMEMORY;
                    return hr;
                 }

                 for ( i=0; i<iLen; i++)
                     lpLabel[i] = lpszLabel[i];

                 lpLabel[iLen] = L'\0';

                 pes->_state.u = ESCB_KEYLABEL;
                 pes->_state.pv = m_pKorIMX;
                 pes->_state.wParam = (WPARAM)KeySelected;
                 pes->_state.lParam = (LPARAM)lpLabel;
                 pes->_state.pic = pic;
                 pes->_state.pv1 = NULL;

                 pic->EditSession(m_pKorIMX->_tid, 
                                  pes, 
                                  TF_ES_READWRITE, 
                                  &hr);

                 if ( FAILED(hr) )
                 {
                     SafeFreePointer(lpLabel);
                 }

                 SafeRelease(pes);

              }
              else
                 hr = E_FAIL;

              SafeRelease(pic);

              break;
    */
    }
 
    return hr;
}


CSoftKbdWindowEventSink::CSoftKbdWindowEventSink(CKorIMX *pKorIMX) 
{
                                               
     m_pKorIMX = pKorIMX;
   
     _cRef = 1;
}

CSoftKbdWindowEventSink::~CSoftKbdWindowEventSink()
{

}


//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CSoftKbdWindowEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ISoftKbdWindowEventSink))
    {
        *ppvObj = SAFECAST(this, CSoftKbdWindowEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CSoftKbdWindowEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CSoftKbdWindowEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
//  ISoftKbdWindowEventSink
//


STDAPI CSoftKbdWindowEventSink::OnWindowClose( )
{

    HRESULT hr = S_OK;

    if (m_pKorIMX)
        m_pKorIMX->SetSoftKBDOnOff(FALSE);

    return hr;
}

STDAPI CSoftKbdWindowEventSink::OnWindowMove(int xWnd, int yWnd, int width, int height)
{

    HRESULT hr = S_OK;

    if (m_pKorIMX)
        m_pKorIMX->SetSoftKBDPosition(xWnd, yWnd);

// support size change later.
    UNREFERENCED_PARAMETER(width);
    UNREFERENCED_PARAMETER(height);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\textsink.h ===
//
// tes.h
//
// ITfTextEventSink object
//

#if !defined (__TEXTSINK_H__INCLUDED_)
#define __TEXTSINK_H__INCLUDED_

#include "private.h"

#define TES_INVALID_COOKIE  ((DWORD)(-1))

class CTextEditSink : public ITfTextEditSink
{
public:
    CTextEditSink(void *pv);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfTextEditSink
    //
    STDMETHODIMP OnEndEdit(TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    HRESULT _Advise(ITfContext *pic);
    HRESULT _Unadvise();

private:

    long         m_cRef;
    ITfContext  *m_pic;
    DWORD        m_dwEditCookie;
//    DWORD        m_dwLayoutCookie;
//    DWORD        m_dwFlags;
	void        *m_pv;
};

#endif // __TEXTSINK_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\textsink.cpp ===
//
// tes.cpp
//

#include "private.h"
#include "korimx.h"
#include "textsink.h"
#include "editcb.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CTextEventSink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CTextEditSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfTextEditSink))
    {
        *ppvObj = SAFECAST(this, ITfTextEditSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CTextEditSink::AddRef()
{
    return ++m_cRef;
}

STDAPI_(ULONG) CTextEditSink::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTextEditSink::CTextEditSink(void *pv)
{
    Dbg_MemSetThisName(TEXT("CTextEditSink"));

    m_cRef = 1;
    m_dwEditCookie = TES_INVALID_COOKIE;
    m_pv = pv;
    Assert(m_pv != NULL);

    //m_dwLayoutCookie = TES_INVALID_COOKIE;
}

//+---------------------------------------------------------------------------
//
// EndEdit
//
//----------------------------------------------------------------------------

STDAPI CTextEditSink::OnEndEdit(TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord)
{
    CKorIMX 	    *pKorImx;
    CHangulAutomata	*pAutomata;
	CEditSession    *pes;
	BOOL		     fChanged = fFalse;
	HRESULT          hr = S_OK;
	
	pKorImx = (CKorIMX *)m_pv;
	Assert(pKorImx);
	
#if 0
	pEditRecord->GetSelectionStatus(&fChanged);

	if (fChanged)
		{
		BOOL fInWriteSession;

        if (SUCCEEDED(m_pic->InWriteSession(pKorImx->GetTID(), &fInWriteSession)))
        	{
            if (!fInWriteSession)
				if (pes = new CEditSession(CKorIMX::_EditSessionCallback))
					{
					// Complete the current composition here.
					// But you have to use async edit session here.
					// because this TextEditSink notification is inside of
					// another edit session. You can not have recursive 
					// edit session.
					pes->_state.u 		= ESCB_COMP_COMPLETE;
					pes->_state.pv 		= pKorImx;
					pes->_state.pRange 	= NULL;
					pes->_state.pic 	= m_pic;

					m_pic->EditSession(pKorImx->GetTID(), pes, TF_ES_READWRITE, &hr);

					pes->Release();
					}
			}
		}
#else
	pEditRecord->GetSelectionStatus(&fChanged);

	if (fChanged)
		{
		BOOL fInWriteSession;

        if (SUCCEEDED(m_pic->InWriteSession(pKorImx->GetTID(), &fInWriteSession)))
        	{
            if (!fInWriteSession)
            	{
				pAutomata = pKorImx->GetAutomata(m_pic);
				Assert(pAutomata);
				//pAutomata->MakeComplete();
				}
			}
		}
#endif

	return hr;
}

//+---------------------------------------------------------------------------
//
// CTextEditSink::Advise
//
//----------------------------------------------------------------------------

HRESULT CTextEditSink::_Advise(ITfContext *pic)
{
    HRESULT hr = E_FAIL;
    ITfSource *source = NULL;

    m_pic = NULL;

    if (FAILED(pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfTextEditSink, (ITfTextEditSink *)this, &m_dwEditCookie)))
		goto Exit;
		
    m_pic = pic;
    m_pic->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CTextEditSink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CTextEditSink::_Unadvise()
{
    HRESULT hr = E_FAIL;
    ITfSource *source = NULL;

    if (m_pic == NULL)
        goto Exit;

    if (FAILED(m_pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (SUCCEEDED(source->UnadviseSink(m_dwEditCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(m_pic);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\toolbar.h ===
//
//  TOOLBAR.H
//
//  History:
//      24-JAN-2000 CSLim Created

#if !defined (__TOOLBAR_H__INCLUDED_)
#define __TOOLBAR_H__INCLUDED_

#include "globals.h"

class CKorIMX;
class CMode;
class FMode;
class HJMode;
class CPad;
class CSoftKbdMode;

#define UPDTTB_NONE		0x00000000
#define UPDTTB_CMODE	0x00000001
#define UPDTTB_FHMODE	0x00000002  // Full/Half shape mode
#define UPDTTB_HJMODE	0x00000004  // Hanja mode
#define UPDTTB_SKDMODE	0x00000008  // Soft keyboard mode
#define UPDTTB_ALL (UPDTTB_CMODE|UPDTTB_FHMODE|UPDTTB_HJMODE|UPDTTB_SKDMODE)


class CToolBar
{
public:
	CKorIMX* m_pimx;
	ITfContext* m_pic;

	CToolBar(CKorIMX* pImx);
	~CToolBar();

	void CheckEnable();
	void SetCurrentIC(ITfContext* pic);
	void SetUIFocus(BOOL fFocus);

	BOOL Initialize();
	VOID Terminate();
	DWORD SetConversionMode(DWORD dwConvMod);
	UINT  GetConversionMode(ITfContext *pic = NULL);
	UINT  GetConversionModeIDI(ITfContext *pic = NULL);

	BOOL Update(DWORD dwUpdate = UPDTTB_NONE, BOOL fRefresh = fFalse);

	BOOL IsOn(ITfContext *pic = NULL);
	BOOL SetOnOff(BOOL fOn);

	ITfContext* GetIC()		{ return m_pic;	}
	HWND GetOwnerWnd(ITfContext *pic = NULL);
	CSoftKbdMode *GetSkbdMode()		{ return m_pSkbdMode; }

    IImeIPoint1* GetIPoint(ITfContext *pic = NULL);

private:
	BOOL    m_fFocus;
	CMode  *m_pCMode;
	FMode  *m_pFMode;
	HJMode *m_pHJMode;
#if !defined(_WIN64)
	CPad   *m_pPad;
#endif
	CSoftKbdMode *m_pSkbdMode;

	CMode *GetCMode()		{ return m_pCMode; }
	FMode *GetFMode()		{ return m_pFMode; }
	HJMode *GetHJMode()		{ return m_pHJMode; }
};

#endif	// __TOOLBAR_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\tipcand.cpp ===
/****************************************************************************
   TIPCAND.CPP : CKorIMX's Candidate UI member functions implementation
   
   History:
      16-DEC-1999 CSLim Created
****************************************************************************/

#include "private.h"
#include <initguid.h>    // For DEFINE_GUID IID_ITfCandidateUIEx and CLSID_TFCandidateUIEx
#include "mscandui.h"
#include "korimx.h"
#include "immxutil.h"
#include "dispattr.h"
#include "helpers.h"
#include "funcprv.h"
#include "kes.h"
#include "editcb.h"
#include "osver.h"
#include "ucutil.h"
#include "hanja.h"
#include "canduies.h"
#include "candkey.h"
#include "tsattrs.h"

//
// candidate list related functions
//

typedef struct _ENUMFONTFAMPARAM
{
    LPCWSTR  szFontFace;
    BYTE     chs;
    BOOL     fVertical;

    BOOL     fFound;        // output
    BOOL     fTrueType;        // output
    LOGFONTW LogFont;        // output
} ENUMFONTFAMPARAM;

static BOOL FFontExist(LPCWSTR szFontFace, LOGFONTW *pLogFont);
static BOOL CALLBACK FEnumFontFamProcA(const ENUMLOGFONTA *lpELF, const NEWTEXTMETRICA *lpNTM, DWORD dwFontType, LPARAM lParam);
static BOOL CALLBACK FEnumFontFamProcW(const ENUMLOGFONTW *lpELF, const NEWTEXTMETRICW *lpNTM, DWORD dwFontType, LPARAM lParam);
static BOOL FEnumFontFamProcMain(const LOGFONTW *pLogFont, DWORD dwFontType, ENUMFONTFAMPARAM *pParam);
static BOOL FFindFont(BYTE chs, BOOL fVertical, LOGFONTW *pLogFont);


/*---------------------------------------------------------------------------
    CKorIMX::CreateCandidateList

    Create a candidate list from input Hangul char
---------------------------------------------------------------------------*/
CCandidateListEx *CKorIMX::CreateCandidateList(ITfContext *pic, ITfRange *pRange, LPWSTR pwzRead)
{
    CCandidateListEx       *pCandList;
    HANJA_CAND_STRING_LIST CandStrList;

    Assert(pic != NULL);
    Assert(pRange != NULL);

    if (pic == NULL || pwzRead == NULL)
        return NULL;

    ZeroMemory(&CandStrList, sizeof(HANJA_CAND_STRING_LIST));
    // Get Conversion list
    if (GetConversionList(*pwzRead, &CandStrList))
        {
        // Create ITfCandidateList object and add cadn string to it.
        pCandList = new CCandidateListEx(CandidateUICallBack, pic, pRange);
        
        for (UINT i=0; i<CandStrList.csz; i++)
            {
            CCandidateStringEx *pCandStr;
            WCHAR                szCand[2];

            // Add candidate Hanja
            szCand[0] = CandStrList.pHanjaString[i].wchHanja;
            szCand[1] = L'\0';

            pCandList->AddString(szCand, GetLangID(), this, NULL, &pCandStr);
            pCandStr->SetInlineComment(CandStrList.pHanjaString[i].wzMeaning);
            pCandStr->m_bHanjaCat = CandStrList.pHanjaString[i].bHanjaCat;
            
            // Set read Hangul char
            pCandStr->SetReadingString(pwzRead);
            pCandStr->Release();
            }

        // Free temp result buffer and return
        cicMemFree(CandStrList.pwsz);
        cicMemFree(CandStrList.pHanjaString);

        return pCandList;
        }
    else
        MessageBeep(MB_ICONEXCLAMATION);

    return NULL;
}

#define FONTNAME_MSSANSSERIF        L"Microsoft Sans Serif"
#define FONTNAME_GULIM_KOR            L"\xAD74\xB9BC"      // Gulim
#define FONTNAME_GULIM_KOR_VERT        L"@\xAD74\xB9BC"      // Gulim
#define FONTNAME_GULIM_ENG            L"Gulim"              // Gulim
#define FONTNAME_GULIM_ENG_VERT        L"@Gulim"              // Gulim

static const LPCWSTR rgszCandFontList9xHoriz[] = 
{
    FONTNAME_GULIM_KOR,
    FONTNAME_GULIM_ENG,
    NULL
};

static const LPCWSTR rgszCandFontList9xVert[] = 
{
    FONTNAME_GULIM_KOR_VERT,
    FONTNAME_GULIM_ENG_VERT,
    NULL
};

static const LPCWSTR rgszCandFontListNT5Horiz[] = 
{
    FONTNAME_MSSANSSERIF,
    FONTNAME_GULIM_KOR,
    FONTNAME_GULIM_ENG,
    NULL
};

static const LPCWSTR rgszCandFontListNT5Vert[] = 
{
    FONTNAME_GULIM_KOR_VERT,
    FONTNAME_GULIM_ENG_VERT,
    NULL
};

/*---------------------------------------------------------------------------
     CKorIMX::GetCandidateFontInternal
---------------------------------------------------------------------------*/
void CKorIMX::GetCandidateFontInternal(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LOGFONTW *plf, LONG lFontPoint, BOOL fCandList)
{
    HDC  hDC;
    LOGFONTW lfMenu;
    LOGFONTW lfFont;
    LONG lfHeightMin;
    BOOL fVertFont = fFalse;
    const LPCWSTR *ppFontFace = rgszCandFontList9xHoriz;
    BOOL fFound;

    //
    // get menu font
    //
    if (!IsOnNT()) 
        {
        NONCLIENTMETRICSA ncmA = {0};

        ncmA.cbSize = sizeof(ncmA);
        SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncmA), &ncmA, 0);

        ConvertLogFontAtoW( &ncmA.lfMenuFont, &lfMenu );
        }
    else
        {
        NONCLIENTMETRICSW ncmW = {0};

        ncmW.cbSize = sizeof(ncmW);
        SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(ncmW), &ncmW, 0);

        lfMenu = ncmW.lfMenuFont;
        }

    // check font direction of main doc
    if (fCandList)
        {
        ITfReadOnlyProperty *pProp = NULL;
        VARIANT var;

        if ((pic != NULL) && (pic->GetAppProperty(TSATTRID_Text_VerticalWriting, &pProp) == S_OK))
            {
            QuickVariantInit(&var);

            if (pProp->GetValue(ec, pRange, &var) == S_OK)
                {
                Assert( var.vt == VT_BOOL );
                fVertFont = var.boolVal;
                VariantClear( &var );
                }

            SafeRelease( pProp );
            }
        }
    
    // set face name
    if (IsOnNT5())
        ppFontFace = fVertFont ? rgszCandFontListNT5Vert : rgszCandFontListNT5Horiz; 
    else
        ppFontFace = fVertFont ? rgszCandFontList9xVert :  rgszCandFontList9xHoriz; 


    // find font from font list (expected font)
    fFound = FFontExist(*(ppFontFace++), &lfFont);
    while (!fFound && (*ppFontFace != NULL))
        fFound = FFontExist(*(ppFontFace++), &lfFont);

    // find another Korean font if no expected font is found
    if (!fFound)
        fFound = FFindFont(HANGEUL_CHARSET, fVertFont, &lfFont);

    // use menu font when no Korean font found
    if (!fFound)
        lfFont = lfMenu;

    //
    // store font
    //

    *plf = lfMenu;

    plf->lfCharSet        = lfFont.lfCharSet;
    plf->lfOutPrecision   = lfFont.lfOutPrecision;
    plf->lfQuality        = lfFont.lfQuality;
    plf->lfPitchAndFamily = lfFont.lfPitchAndFamily;
    wcscpy(plf->lfFaceName, lfFont.lfFaceName);

    //
    // font size
    //
    
    // check minimum size
    hDC = GetDC(NULL);
    // Cand font size 12pt
    lfHeightMin = -MulDiv(lFontPoint, GetDeviceCaps(hDC, LOGPIXELSY), 72);    // minimum size
    ReleaseDC(NULL, hDC);

    plf->lfHeight = min(lfHeightMin, plf->lfHeight);
}



/*   G E T  T E X T   D I R E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
TEXTDIRECTION CKorIMX::GetTextDirection(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    TEXTDIRECTION dir = TEXTDIRECTION_LEFTTORIGHT;
    ITfReadOnlyProperty *pProp = NULL;
    VARIANT var;
    LONG lOrientation;

    QuickVariantInit(&var);

    if (pic == NULL)
        goto LError;

    if (pic->GetAppProperty(TSATTRID_Text_Orientation, &pProp) != S_OK)
        goto LError;

    if (pProp->GetValue(ec, pRange, &var) != S_OK)
        goto LError;

    Assert(var.vt == VT_I4);

    lOrientation = var.lVal;
    Assert((0 <= lOrientation) && (lOrientation < 3600));

    if (lOrientation < 450)
        dir = TEXTDIRECTION_LEFTTORIGHT;
    else 
    if (lOrientation < 900 + 450)
        dir = TEXTDIRECTION_BOTTOMTOTOP;
    else
    if (lOrientation < 1800 + 450)
        dir = TEXTDIRECTION_RIGHTTOLEFT;
    else
    if (lOrientation < 2700 + 450)
        dir = TEXTDIRECTION_TOPTOBOTTOM;
    else
        dir = TEXTDIRECTION_LEFTTORIGHT;

LError:
    SafeRelease(pProp);
    VariantClear(&var);

    return dir;
}



/*   G E T  C A N D  U I  D I R E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CANDUIUIDIRECTION CKorIMX::GetCandUIDirection(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    TEXTDIRECTION DirText = GetTextDirection(ec, pic, pRange);
    CANDUIUIDIRECTION DirCand = CANDUIDIR_LEFTTORIGHT;
    
    switch(DirText) 
        {
    case TEXTDIRECTION_TOPTOBOTTOM:
        DirCand = CANDUIDIR_RIGHTTOLEFT;
        break;
    case TEXTDIRECTION_RIGHTTOLEFT:
        DirCand = CANDUIDIR_BOTTOMTOTOP;
        break;
    case TEXTDIRECTION_BOTTOMTOTOP:
        DirCand = CANDUIDIR_LEFTTORIGHT;
        break;
    case TEXTDIRECTION_LEFTTORIGHT:
        DirCand = CANDUIDIR_TOPTOBOTTOM;
        break;
        }

    return DirCand;
}

/*---------------------------------------------------------------------------
    CKorIMX::OpenCandidateUI

    Open candidate UI
     - Open candidate UI window at the specified range
     - This function never release the range nor candidate list object. 
       They must be released in caller side.
---------------------------------------------------------------------------*/
void CKorIMX::OpenCandidateUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList )
{
    ITfDocumentMgr     *pdim;

    Assert(pic != NULL);
    Assert(pRange != NULL);
    Assert(pCandList != NULL);

    if (pic == NULL || pRange == NULL || pCandList == NULL)
        return;

    // Create and initialize candidate UI
    if (m_pCandUI == NULL) 
        {
        if (SUCCEEDED(CoCreateInstance(CLSID_TFCandidateUI, 
                         NULL, 
                         CLSCTX_INPROC_SERVER, 
                         IID_ITfCandidateUI, 
                         (LPVOID*)&m_pCandUI)))
            {
            // Set client ID
            m_pCandUI->SetClientId(GetTID());
            }
        }
    
    Assert(m_pCandUI != NULL);

    if (m_pCandUI != NULL && SUCCEEDED(GetFocusDIM(&pdim)))
        {
        LOGFONTW lf;
        ULONG    iSelection;
        ITfCandUICandString    *pCandString;
        ITfCandUICandIndex     *pCandIndex;
        ITfCandUIInlineComment *pCandInlineComment;
        CANDUIUIDIRECTION       dir;
        ITfCandUICandWindow    *pCandWindow;

        // Set Cand string and Cand index font
        GetCandidateFontInternal(ec, pic, pRange, &lf, 12, fTrue);
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUICandString, (IUnknown**)&pCandString))) 
            {
            pCandString->SetFont(&lf);
            pCandString->Release();
            }

        // Set Inline Comment font
        // GetCandidateFontInternal(ec, pic, pRange, plf, 9, fTrue);
        lf.lfHeight = (lf.lfHeight * 3) / 4;
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUIInlineComment, (IUnknown**)&pCandInlineComment)))
            {
            pCandInlineComment->SetFont(&lf);
            pCandInlineComment->Release();
            }

        GetCandidateFontInternal(ec, pic, pRange, &lf, 12, fFalse);
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUICandIndex, (IUnknown**)&pCandIndex))) 
            {
            pCandIndex->SetFont(&lf);
            pCandIndex->Release();
            }


        // Set UI direction
        dir = GetCandUIDirection(ec, pic, pRange);
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUICandWindow, (IUnknown**)&pCandWindow)))
            {
            pCandWindow->SetUIDirection(dir);
            pCandWindow->Release();
            }

        // set key table
        SetCandidateKeyTable(pic, dir);

        // set and open candidate list 
        if (m_pCandUI->SetCandidateList(pCandList) == S_OK) 
            {

            m_fCandUIOpen = fTrue;
            
            pCandList->GetInitialSelection(&iSelection);
            m_pCandUI->SetSelection(iSelection);

            m_pCandUI->OpenCandidateUI(GetForegroundWindow(), pdim, ec, pRange);
            }
        }
}




/*   C L O S E  C A N D I D A T E  U I  P R O C   */
/*------------------------------------------------------------------------------

    Main procedure of closing CandidateUI

------------------------------------------------------------------------------*/
void CKorIMX::CloseCandidateUIProc()
{
    if (m_pCandUI != NULL) 
        {
        m_pCandUI->CloseCandidateUI();

        // BUGBUG: Candidate UI module never free candidatelist until 
        // set next candidate list.  set NULL candidate list then
        // it frees the previous one.
        m_pCandUI->SetCandidateList(NULL);

        m_fCandUIOpen = fFalse;
        }
}

/*---------------------------------------------------------------------------
    CKorIMX::CloseCandidateUI

    Close CandidateUI in EditSession
---------------------------------------------------------------------------*/
void CKorIMX::CloseCandidateUI(ITfContext *pic)
{
    CEditSession2 *pes;
    ESSTRUCT ess;
    HRESULT hr;
    
    ESStructInit(&ess, ESCB_CANDUI_CLOSECANDUI);

    if ((pes = new CEditSession2(pic, this, &ess, _EditSessionCallback2 )))
        {
        pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
        pes->Release();
        }
}

// REVIEW : NOT USED
void CKorIMX::SelectCandidate( TfEditCookie ec, ITfContext *pic, INT idxCand, BOOL fFinalize )
{
//    IImeIPoint* pIp = GetIPoint( pic );
//    CIImeIPointCallBackCIC* pIPCB = GetIPCB( pic );

//    if (( pIp == NULL ) || (pIPCB == NULL)) {
//        return;
//    }

//    UINT uiType = pIPCB->GetCandidateInfo();


/*
    CONTROLIDS* pControl = NULL;
    INT nControl = 0;


    INT idx;
    idx = idxCand;
    if (uiType == CANDINFO_RECOMMEND) {
        idx |= MAKE_PCACATEGLY(IMEPCA_CATEGLY_RECOMMEND);
    }

    HRESULT hRes = pIp->GetCandidateInfo( idx, &nControl, (VOID**)&pControl );
    if( pControl == NULL || hRes == S_FALSE ) {
        return;
    }


    INT i;

    CONTROLIDS* pCtrl = NULL;
    // generate control IDs
    for( i=0; i<nControl; i++ ) {
        pCtrl = pControl + i;
        pIp->Control( (WORD)pCtrl->dwControl, (LPARAM)pCtrl->lpVoid );
    }

    if (fFinalize) { // select with candidate close
        pIp->Control( (WORD)JCONV_C_CANDCURRENT, (LPARAM)CTRLID_DEFAULT );
    }
    else {
        if (uiType == CANDINFO_RECOMMEND) {
            pIp->Control( (WORD)JCONV_C_RECOMMENDCAND, (LPARAM)CTRLID_DEFAULT );
        }
    }


    pIp->UpdateContext( FALSE ); // generate composition string message
    _UpdateContext( ec, GetDIM(), pic, NULL);
    */
}


void CKorIMX::CancelCandidate(TfEditCookie ec, ITfContext *pic)
{
    /*
    IImeIPoint* pIp = GetIPoint( pic );

    if( pIp == NULL ) 
        {
        return;
        }

    // close candidate

    pIp->Control( (WORD)JCONV_C_CANDCURRENT, (LPARAM)CTRLID_DEFAULT );
    _UpdateContext( ec, GetDIM(), pic, NULL);    //  REVIEW: KOJIW: unneeded???
    */
    CloseCandidateUIProc();
}

//////////////////////////////////////////////////////////////////////////////
// Candlist key code behavior definition tables
CANDUIKEYDATA rgCandKeyDef[] = 
{
    /* 
    { flag,                                keydata,        command,                    paramater }
    */
    { CANDUIKEY_CHAR,                    L'1',            CANDUICMD_SELECTLINE,        1 },
    { CANDUIKEY_CHAR,                    L'2',            CANDUICMD_SELECTLINE,        2 },
    { CANDUIKEY_CHAR,                    L'3',            CANDUICMD_SELECTLINE,        3 },
    { CANDUIKEY_CHAR,                    L'4',            CANDUICMD_SELECTLINE,        4 },
    { CANDUIKEY_CHAR,                    L'5',            CANDUICMD_SELECTLINE,        5 },
    { CANDUIKEY_CHAR,                    L'6',            CANDUICMD_SELECTLINE,        6 },
    { CANDUIKEY_CHAR,                    L'7',            CANDUICMD_SELECTLINE,        7 },
    { CANDUIKEY_CHAR,                    L'8',            CANDUICMD_SELECTLINE,        8 },
    { CANDUIKEY_CHAR,                    L'9',            CANDUICMD_SELECTLINE,        9 },
    { CANDUIKEY_CHAR,                    L'0',            CANDUICMD_SELECTEXTRACAND,   0 },
    { CANDUIKEY_VKEY,                    VK_HANJA,        CANDUICMD_CANCEL,            0 },
    { CANDUIKEY_VKEY,                    VK_RETURN,       CANDUICMD_COMPLETE,          0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR, VK_SPACE,     CANDUICMD_MOVESELNEXT,       0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR, VK_DOWN,      CANDUICMD_MOVESELNEXT,       0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR, VK_UP,        CANDUICMD_MOVESELPREV,       0 },
    { CANDUIKEY_VKEY,                       VK_HOME,      CANDUICMD_MOVESELFIRST,      0 },
    { CANDUIKEY_VKEY,                       VK_END,       CANDUICMD_MOVESELLAST,       0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR, VK_PRIOR,     CANDUICMD_MOVESELPREVPG,     0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR, VK_NEXT,      CANDUICMD_MOVESELNEXTPG,     0 },    
    { CANDUIKEY_VKEY,                       VK_ESCAPE,    CANDUICMD_CANCEL,            0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR, VK_RIGHT,     CANDUICMD_MOVESELNEXT,       0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR, VK_LEFT,      CANDUICMD_MOVESELPREV,       0 },
    { CANDUIKEY_VKEY,                       VK_LWIN,      CANDUICMD_CANCEL,            0 },
    { CANDUIKEY_VKEY,                       VK_RWIN,      CANDUICMD_CANCEL,            0 },
    { CANDUIKEY_VKEY,                       VK_APPS,      CANDUICMD_CANCEL,            0 }
};

#define irgCandKeyDefMax    (sizeof(rgCandKeyDef) / sizeof(rgCandKeyDef[0]))

/*---------------------------------------------------------------------------
    CKorIMX::SetCandidateKeyTable
---------------------------------------------------------------------------*/
void CKorIMX::SetCandidateKeyTable(ITfContext *pic, CANDUIUIDIRECTION dir)
{
    CCandUIKeyTable      *pCandUIKeyTable;
    ITfCandUIFnKeyConfig *pCandUIFnKeyConfig;
    
    if (m_pCandUI == NULL)
        return;

    if (FAILED(m_pCandUI->GetFunction(IID_ITfCandUIFnKeyConfig, (IUnknown**)&pCandUIFnKeyConfig)))
        return;

    if ((pCandUIKeyTable = new CCandUIKeyTable(irgCandKeyDefMax)) == NULL)
        return;

    for (int i = 0; i < irgCandKeyDefMax; i++)
        pCandUIKeyTable->AddKeyData(&rgCandKeyDef[i]);

    pCandUIFnKeyConfig->SetKeyTable(pic, pCandUIKeyTable);
    pCandUIKeyTable->Release();
    pCandUIFnKeyConfig->Release();
}

/*---------------------------------------------------------------------------
    CKorIMX::CandidateUICallBack
---------------------------------------------------------------------------*/
HRESULT CKorIMX::CandidateUICallBack(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList, CCandidateStringEx *pCand, TfCandidateResult imcr)
{
    CKorIMX *pSIMX = (CKorIMX *)(pCand->m_pv);
    CEditSession2 *pes;
    ESSTRUCT        ess;
    HRESULT hr;

    Assert(pic != NULL);
    Assert(pRange != NULL);
    
    // Only handle CAND_FINALIZED and CAND_CANCELED
    if (imcr == CAND_FINALIZED)
        {
        ESStructInit(&ess, ESCB_FINALIZECONVERSION);

        ess.pRange    = pRange;
        ess.pCandList = pCandList;
        ess.pCandStr  = pCand;


        if (pes = new CEditSession2(pic, pSIMX, &ess, CKorIMX::_EditSessionCallback2))
            {
            pCandList->AddRef(); ;        // be released in edit session callback
            pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
            pes->Release();
            }
        }

    // If user hit ESC or arrow keys..
    if (imcr == CAND_CANCELED)
        {
           // Complete current comp char if exist
           // This will reset Automata also.
        ESStructInit(&ess, ESCB_COMPLETE);
        
        ess.pRange    = pRange;
        
        if ((pes = new CEditSession2(pic, pSIMX, &ess, CKorIMX::_EditSessionCallback2)) == NULL)
            return fFalse;

        pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
        pes->Release();
        }

    return S_OK;
}

/*---------------------------------------------------------------------------
    CKorIMX::IsCandKey
---------------------------------------------------------------------------*/
BOOL CKorIMX::IsCandKey(WPARAM wParam, const BYTE abKeyState[256])
{
    if (IsShiftKeyPushed(abKeyState) || IsControlKeyPushed(abKeyState))
        return fFalse;

    if (wParam == VK_HANGUL || wParam == VK_HANJA || wParam == VK_JUNJA)
        return fTrue;
    
    for (int i=0; i<irgCandKeyDefMax; i++)
        {
        if (rgCandKeyDef[i].uiKey == wParam)
            return fTrue;
        }
        
    if (wParam >= VK_NUMPAD0 && wParam <= VK_NUMPAD9)
        return fTrue;
    else
        return fFalse;
}

/////////////////////////////////////////////////////////////////////////////
// Private Functions


/*   F  F O N T  E X I S T   */
/*------------------------------------------------------------------------------

    Check if the font is installed

------------------------------------------------------------------------------*/
BOOL FFontExist(LPCWSTR szFontFace, LOGFONTW *pLogFont)
{
    ENUMFONTFAMPARAM param = {0};
    HDC hDC;

    param.szFontFace = szFontFace;
    param.fFound     = FALSE;

    hDC = GetDC(NULL);
    if (!IsOnNT5()) 
        {
        CHAR szFontFaceA[LF_FACESIZE];

        ConvertStrWtoA(szFontFace, -1, szFontFaceA, LF_FACESIZE);
        EnumFontFamiliesA(hDC, szFontFaceA, (FONTENUMPROCA)FEnumFontFamProcA, (LPARAM)&param);
        }
    else
        EnumFontFamiliesW(hDC, szFontFace, (FONTENUMPROCW)FEnumFontFamProcW, (LPARAM)&param);
    
    ReleaseDC(NULL, hDC);

    if (param.fFound)
        *pLogFont = param.LogFont;

    return param.fFound;
}



/*   F  E N U M  F O N T  F A M  P R O C  A   */
/*------------------------------------------------------------------------------

    Callback funtion in enumeration font (ANSI version)

------------------------------------------------------------------------------*/
BOOL CALLBACK FEnumFontFamProcA(const ENUMLOGFONTA *lpELF, const NEWTEXTMETRICA *lpNTM, DWORD dwFontType, LPARAM lParam)
{
    LOGFONTW lfW;

    UNREFERENCED_PARAMETER(lpNTM);
    UNREFERENCED_PARAMETER(dwFontType);

    ConvertLogFontAtoW(&lpELF->elfLogFont, &lfW);

    return FEnumFontFamProcMain(&lfW, dwFontType, (ENUMFONTFAMPARAM *)lParam);
}



/*   F  E N U M  F O N T  F A M  P R O C  W   */
/*------------------------------------------------------------------------------

    Callback funtion in enumeration font (Unicode version)

------------------------------------------------------------------------------*/
BOOL CALLBACK FEnumFontFamProcW(const ENUMLOGFONTW *lpELF, const NEWTEXTMETRICW *lpNTM, DWORD dwFontType, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lpNTM);

    return FEnumFontFamProcMain(&lpELF->elfLogFont, dwFontType, (ENUMFONTFAMPARAM *)lParam);
}


/*   F  E N U M  F O N T  F A M  P R O C  M A I N   */
/*------------------------------------------------------------------------------

    Main procedure of enumeration font (find fonts)

------------------------------------------------------------------------------*/
BOOL FEnumFontFamProcMain( const LOGFONTW *pLogFont, DWORD dwFontType, ENUMFONTFAMPARAM *pParam )
{
    if (pParam->szFontFace != NULL)
        {
        if (pParam->fFound)
            goto Exit;

        // check font face
        if (wcscmp( pParam->szFontFace, pLogFont->lfFaceName ) == 0)
            {
            pParam->fFound    = TRUE;
            pParam->fTrueType = (dwFontType == TRUETYPE_FONTTYPE);
            pParam->LogFont   = *pLogFont;
            }
        }
    else
        {
        // check character set

        if (pLogFont->lfCharSet != pParam->chs)
            goto Exit;

        // check font direction

        if (pParam->fVertical && (pLogFont->lfFaceName[0] != L'@'))
            goto Exit;
        else 
            if (!pParam->fVertical && (pLogFont->lfFaceName[0] == L'@'))
            goto Exit;

        // store first found font anyway
        if (!pParam->fFound)
            {
            pParam->fFound    = TRUE;
            pParam->fTrueType = (dwFontType == TRUETYPE_FONTTYPE);
            pParam->LogFont   = *pLogFont;
            goto Exit;
            }

        // check if the font is better than previous

        // font type (truetype font has priority)
        if (pParam->fTrueType && (dwFontType != TRUETYPE_FONTTYPE))
            goto Exit;
        else 
        if (!pParam->fTrueType && (dwFontType == TRUETYPE_FONTTYPE))
            {
            pParam->fTrueType = (dwFontType == TRUETYPE_FONTTYPE);
            pParam->LogFont   = *pLogFont;
            goto Exit;
            }

        // font family (swiss font has priority)
        if (((pParam->LogFont.lfPitchAndFamily & (0x0f<<4)) == FF_SWISS) && ((pLogFont->lfPitchAndFamily & (0x0f<<4)) != FF_SWISS))
            goto Exit;
        else 
        if (((pParam->LogFont.lfPitchAndFamily & (0x0f<<4)) != FF_SWISS) && ((pLogFont->lfPitchAndFamily & (0x0f<<4)) == FF_SWISS))
            {
            pParam->fTrueType = (dwFontType == TRUETYPE_FONTTYPE);
            pParam->LogFont   = *pLogFont;
            goto Exit;
            }

        // pitch (variable pitch font has priority)
        if (((pParam->LogFont.lfPitchAndFamily & (0x03)) == VARIABLE_PITCH) && ((pLogFont->lfPitchAndFamily & (0x03)) != VARIABLE_PITCH))
            goto Exit;
        else
        if (((pParam->LogFont.lfPitchAndFamily & (0x03)) != VARIABLE_PITCH) && ((pLogFont->lfPitchAndFamily & (0x03)) == VARIABLE_PITCH))
            {
            pParam->fTrueType = (dwFontType == TRUETYPE_FONTTYPE);
            pParam->LogFont   = *pLogFont;
            goto Exit;
            }
        }

Exit:
    return TRUE;
}


/*   F  F I N D  F O N T   */
/*------------------------------------------------------------------------------

    Find the font that matches about following specified in the parameter
        * character set
        * font direction (vertical/horizontal)

    The priorities of finding are as belloow
        * TrueType font
        * Swiss (w/o serif) font
        * variable pitch font

------------------------------------------------------------------------------*/
BOOL FFindFont(BYTE chs, BOOL fVertical, LOGFONTW *pLogFont)
{
    ENUMFONTFAMPARAM param = {0};
    HDC hDC;

    param.szFontFace = NULL;
    param.chs        = chs;
    param.fVertical  = fVertical;
    param.fFound     = FALSE;

    hDC = GetDC(NULL);
    if (!IsOnNT5())
        EnumFontFamiliesA(hDC, NULL, (FONTENUMPROCA)FEnumFontFamProcA, (LPARAM)&param);
    else
        EnumFontFamiliesW(hDC, NULL, (FONTENUMPROCW)FEnumFontFamProcW, (LPARAM)&param);

    ReleaseDC(NULL, hDC);

    if (param.fFound)
        *pLogFont = param.LogFont;

    return param.fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\toolbar.cpp ===
/****************************************************************************
   TOOLBAR.CPP : Cicero Toolbar button management class

   History:
      24-JAN-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "korimx.h"
#include "cmode.h"
#include "fmode.h"
#include "hjmode.h"
#include "skbdmode.h"
#include "pad.h"
#include "immxutil.h"
#include "helpers.h"
#include "toolbar.h"
#include "userex.h"

/*---------------------------------------------------------------------------
	CToolBar::CToolBar
	Ctor
---------------------------------------------------------------------------*/
CToolBar::CToolBar(CKorIMX* pImx)
{
	m_pimx      = pImx;
	m_pic       = NULL;
	m_pCMode    = NULL;
	m_pFMode    = NULL;
	m_pHJMode   = NULL;
	m_pSkbdMode = NULL;
#if !defined(_WIN64)
	m_pPad      = NULL;
#endif
	m_fFocus    = fFalse;
}

/*---------------------------------------------------------------------------
	CToolBar::~CToolBar
	Dtor
---------------------------------------------------------------------------*/
CToolBar::~CToolBar()
{
	m_pimx = NULL;
    SafeReleaseClear(m_pic);
}

/*---------------------------------------------------------------------------
	CToolBar::Initialize
	
	Initialize Toolbar buttons. Add to Cic main toolbar.
---------------------------------------------------------------------------*/
BOOL CToolBar::Initialize()
{
	ITfThreadMgr		*ptim;
	ITfLangBarItemMgr 	*plbim;
	HRESULT 			 hr;
	
	if (m_pimx == NULL)
		return fFalse;

	ptim  = m_pimx->GetTIM();
	plbim = NULL;

	//////////////////////////////////////////////////////////////////////////
	// Get Notify UI mananger(IID_ITfLangBarItemMgr) in current TIM
	if (FAILED(hr = GetService(ptim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim)))
		return fFalse;

	//////////////////////////////////////////////////////////////////////////
	// Create Han/Eng toggle button
	if (!(m_pCMode = new CMode(this))) 
		{
		hr = E_OUTOFMEMORY;
		return fFalse;
		}
	plbim->AddItem(m_pCMode);

	//////////////////////////////////////////////////////////////////////////
	// Create Full/Half shape toggle button
	if (!(m_pFMode = new FMode(this))) 
		{
		hr = E_OUTOFMEMORY;
		return fFalse;
		}
	plbim->AddItem(m_pFMode);

	//////////////////////////////////////////////////////////////////////////
	// Create Hanja Conv button
	if (!(m_pHJMode = new HJMode(this))) 
		{
		hr = E_OUTOFMEMORY;
		return fFalse;
		}
	plbim->AddItem(m_pHJMode);

	//////////////////////////////////////////////////////////////////////////
	// Create Soft Keyboard button
	if (!(m_pSkbdMode = new CSoftKbdMode(this))) 
		{
		hr = E_OUTOFMEMORY;
		return fFalse;
		}
	plbim->AddItem(m_pSkbdMode);

#if !defined(_WIN64)
	//////////////////////////////////////////////////////////////////////////
	// Create Soft Keyboard button
	if (IsWin64() == fFalse)
		{
		if ((m_pPad = new CPad(this, m_pimx->GetPadCore())) == NULL) 
			{
			hr = E_OUTOFMEMORY;
			return fFalse;
			}
		plbim->AddItem(m_pPad);
		}
#endif

	SafeRelease(plbim);
	return fTrue;
}

/*---------------------------------------------------------------------------
	CToolBar::Terminate
	
	Delete toolbar buttonsfrom Cic main toolbar.
---------------------------------------------------------------------------*/
void CToolBar::Terminate()
{
	ITfThreadMgr		*ptim;
	ITfLangBarItemMgr 	*plbim;
	HRESULT 			hr;
	
	if (m_pimx == NULL) 
		return;
		
	ptim  = m_pimx->GetTIM();
	plbim = NULL;

	if (FAILED(hr = GetService(ptim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim)))
		return;

	if (m_pCMode) 
		{
		plbim->RemoveItem(m_pCMode);
		SafeReleaseClear(m_pCMode);
		}

	if (m_pFMode) 
		{
		plbim->RemoveItem(m_pFMode);
		SafeReleaseClear(m_pFMode);
		}

	if (m_pHJMode) 
		{
		plbim->RemoveItem(m_pHJMode);
		SafeReleaseClear(m_pHJMode);
		}

	if (m_pSkbdMode) 
		{
		plbim->RemoveItem(m_pSkbdMode);
		SafeReleaseClear(m_pSkbdMode);
		}

#if !defined(_WIN64)
	if (m_pPad) 
		{
		plbim->RemoveItem(m_pPad);
		SafeReleaseClear(m_pPad);
		}
#endif

	SafeRelease(plbim);
}

/*---------------------------------------------------------------------------
	CToolBar::SetConversionMode
	
	Foward the call to CKorIMX
---------------------------------------------------------------------------*/
DWORD CToolBar::SetConversionMode(DWORD dwConvMode)
{
	if (m_pimx && m_pic)
		return m_pimx->SetConvMode(m_pic, dwConvMode);

	return 0;
}

/*---------------------------------------------------------------------------
	CToolBar::GetConversionMode

	Foward the call to CKorIMX
---------------------------------------------------------------------------*/
UINT CToolBar::GetConversionMode(ITfContext *pic)
{
	if (pic == NULL)
		pic = m_pic;

	if (m_pimx && pic)
		return m_pimx->GetConvMode(pic);

	return 0;
}

/*---------------------------------------------------------------------------
	CToolBar::IsOn

	Foward the call to CKorIMX
---------------------------------------------------------------------------*/
BOOL CToolBar::IsOn(ITfContext *pic)
{
	if (pic == NULL)
		pic = m_pic;

	if (m_pimx && pic)
		return m_pimx->IsOn(pic);

	return fFalse;
}

/*---------------------------------------------------------------------------
	CToolBar::CheckEnable
---------------------------------------------------------------------------*/
void CToolBar::CheckEnable()
{
	if (m_pic == NULL) // empty or disabled(exclude cand ui)
		{
		m_pCMode->Enable(fFalse);
		m_pFMode->Enable(fFalse);
		m_pHJMode->Enable(fFalse);
		m_pSkbdMode->Enable(fFalse);
#if !defined(_WIN64)
		if (IsWin64() == fFalse)
			m_pPad->Enable(fFalse);
#endif
		}
	else
		{
		m_pCMode->Enable(fTrue);
		m_pFMode->Enable(fTrue);
		m_pHJMode->Enable(fTrue);
		m_pSkbdMode->Enable(fTrue);
#if !defined(_WIN64)
		if (IsWin64() == fFalse)
			m_pPad->Enable(fTrue);
#endif
		}
}

/*---------------------------------------------------------------------------
	CToolBar::SetUIFocus
---------------------------------------------------------------------------*/
void CToolBar::SetUIFocus(BOOL fFocus)
{
	if (m_fFocus == fFocus) // same as previous state
		return;

	m_fFocus = fFocus;

	// notify the latest focus to IMEPad
	if (m_pimx && m_pimx->GetPadCore())
	    {
		m_pimx->GetPadCore()->SetFocus(fFocus);
	    }

	if (fFocus)
		Update(UPDTTB_ALL, fTrue);
}

/*---------------------------------------------------------------------------
	CToolBar::SetCurrentIC
---------------------------------------------------------------------------*/
void CToolBar::SetCurrentIC(ITfContext* pic)
{
    SafeReleaseClear(m_pic);
    
	m_pic = pic;
	if (m_pic)
	    {
        m_pic->AddRef();
	    }
    
	if (m_pimx == NULL)
		return;

	CheckEnable();	// enable or disable context

	// changed context - update all toolbar buttons
	Update(UPDTTB_ALL, fTrue);
}


/*---------------------------------------------------------------------------
	CToolBar::SetOnOff

	Foward the call to CKorIMX
---------------------------------------------------------------------------*/
BOOL CToolBar::SetOnOff(BOOL fOn)
{
	if (m_pimx && m_pic) 
		{
		m_pimx->SetOnOff(m_pic, fOn);
		return fOn;
		}
		
	return fFalse;
}

/*---------------------------------------------------------------------------
	CToolBar::GetOwnerWnd

	Foward the call to CKorIMX
---------------------------------------------------------------------------*/
HWND CToolBar::GetOwnerWnd(ITfContext *pic)
{
	if (pic == NULL)
	    {
		pic = m_pic;
	    }

	if (m_pimx && pic)
		return m_pimx->GetOwnerWnd();

	return 0;
}

/*---------------------------------------------------------------------------
	CToolBar::GetIPoint
---------------------------------------------------------------------------*/
IImeIPoint1* CToolBar::GetIPoint(ITfContext *pic)
{
	if (pic == NULL )
	    {
		pic = m_pic;
	    }
	
	if (m_pimx && pic)
	    {
		return m_pimx->GetIPoint(pic);
	    }
	
	return NULL;
}

/*---------------------------------------------------------------------------
	CToolBar::GetOwnerWnd

	Update buttons. dwUpdate has update bits corresponding each button.
---------------------------------------------------------------------------*/
BOOL CToolBar::Update(DWORD dwUpdate, BOOL fRefresh)
{
	DWORD dwFlag = TF_LBI_BTNALL;

	if (fRefresh)
		dwFlag |= TF_LBI_STATUS;

	if ((dwUpdate & UPDTTB_CMODE) && m_pCMode && m_pCMode->GetSink())
		m_pCMode->GetSink()->OnUpdate(dwFlag);

	if ((dwUpdate & UPDTTB_FHMODE) && m_pFMode && m_pFMode->GetSink())
		m_pFMode->GetSink()->OnUpdate(dwFlag);

	if ((dwUpdate & UPDTTB_HJMODE) && m_pHJMode && m_pHJMode->GetSink())
		m_pHJMode->GetSink()->OnUpdate(dwFlag);

	if ((dwUpdate & UPDTTB_SKDMODE) && m_pSkbdMode && m_pSkbdMode->GetSink())
		m_pSkbdMode->GetSink()->OnUpdate(dwFlag);

#if !defined(_WIN64)
	if ((IsWin64() == fFalse) && (dwUpdate & UPDTTB_SKDMODE) && m_pPad && m_pPad->GetSink())
		m_pPad->GetSink()->OnUpdate(dwFlag);
#endif

	return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\ucutil.h ===
//
// ucutil.h
//

#ifndef UCUTIL_H
#define UCUTIL_H

/*   C O N V E R T  S T R  W T O  A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
__inline int ConvertStrWtoA( LPCWSTR pwch, int cwch, LPSTR pch, int cch, UINT cpg = CP_ACP )
{
	return WideCharToMultiByte( cpg, 0, pwch, cwch, pch, cch, NULL, NULL );
}


/*   C O N V E R T  S T R  A T O  W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
__inline int ConvertStrAtoW( LPCSTR pch, int cch, LPWSTR pwch, int cwch, UINT cpg = CP_ACP )
{
	return MultiByteToWideChar( cpg, 0, pch, cch, pwch, cwch );
}

UINT CpgFromChs( BYTE chs );
void ConvertLogFontWtoA( CONST LOGFONTW *plfW, LOGFONTA *plfA );
void ConvertLogFontAtoW( CONST LOGFONTA *plfA, LOGFONTW *plfW );


// Unicode Character Block Description
#define UNICODE_C0_CONTROL_START							0x0000
#define UNICODE_C0_CONTROL_END								0x001f
#define UNICODE_BASIC_LATIN_START							0x0020
#define UNICODE_BASIC_LATIN_END								0x007f
#define UNICODE_LATIN1_SUPPLEMENT_START						0x0080
#define UNICODE_LATIN1_SUPPLEMENT_END						0x00FF
#define UNICODE_LATIN_EXTENDED_A_START						0x0100
#define UNICODE_LATIN_EXTENDED_A_END						0x017F
#define UNICODE_LATIN_EXTENDED_B_START						0x0180
#define UNICODE_LATIN_EXTENDED_B_END						0x024F
#define UNICODE_IPA_EXTENSIONS_START						0x0250
#define UNICODE_IPA_EXTENSIONS_END							0x02AF
#define UNICODE_SPACING_MODIFIER_LETTERS_START				0x02B0
#define UNICODE_SPACING_MODIFIER_LETTERS_END				0x02FF
#define UNICODE_COMBINING_DIACRITICAL_MARKS_START			0x0300
#define UNICODE_COMBINING_DIACRITICAL_MARKS_END				0x036F
#define UNICODE_GREEK_START									0x0370
#define UNICODE_GREEK_END									0x03FF
#define UNICODE_CYRILLIC_START								0x0400
#define UNICODE_CYRILLIC_END								0x04FF
#define UNICODE_ARMENIAN_START								0x0530
#define UNICODE_ARMENIAN_END								0x058F
#define UNICODE_HEBREW_START								0x0590
#define UNICODE_HEBREW_END									0x05FF
#define UNICODE_ARABIC_START								0x0600
#define UNICODE_ARABIC_END									0x06FF
#define UNICODE_DEVANAGARI_START							0x0900
#define UNICODE_DEVANAGARI_END								0x097F
#define UNICODE_BENGALI_START								0x0980
#define UNICODE_BENGALI_END									0x09FF
#define UNICODE_THAI_START									0x0E00
#define UNICODE_THAI_END									0x0E7F
#define UNICODE_TIBETAN_START								0x0F00
#define UNICODE_TIBETAN_END									0x0FBF
#define UNICODE_HANGUL_JAMO_START							0x1100
#define UNICODE_HANGUL_JAMO_END								0x11FF
#define UNICODE_GENERAL_PUNCTUATION_START					0x2000
#define UNICODE_GENERAL_PUNCTUATION_END						0x206F
#define UNICODE_SUPERSCRIPTS_AND_SUBSCRIPTS_START			0x2070
#define UNICODE_SUPERSCRIPTS_AND_SUBSCRIPTS_END				0x209F
#define UNICODE_CURRENCY_SYMBOLS_START						0x20A0
#define UNICODE_CURRENCY_SYMBOLS_END						0x20CF
#define UNICODE_LETTERLIKE_SYMBOLS_START					0x2100
#define UNICODE_LETTERLIKE_SYMBOLS_END						0x214F
#define UNICODE_NUMBER_FORMS_START							0x2150
#define UNICODE_NUMBER_FORMS_END							0x218F
#define UNICODE_ARROWS_START								0x2190
#define UNICODE_ARROWS_END									0x21FF
#define UNICODE_MATH_OPERATORS_START						0x2200
#define UNICODE_MATH_OPERATORS_END							0x22FF
#define UNICODE_MISC_TECHNICAL_START						0x2300
#define UNICODE_MISC_TECHNICAL_END							0x23FF
#define UNICODE_CONTROL_PICTURES_START						0x2400
#define UNICODE_CONTROL_PICTURES_END						0x243F
#define UNICODE_OCR_START									0x2440
#define UNICODE_OCR_END										0x245F
#define UNICODE_ENCLOSED_ALPHANUMERICS_START				0x2460
#define UNICODE_ENCLOSED_ALPHANUMERICS_END					0x24FF
#define UNICODE_BOX_DRAWING_START							0x2500
#define UNICODE_BOX_DRAWING_END								0x257F
#define UNICODE_BLOCK_ELEMENTS_START						0x2580
#define UNICODE_BLOCK_ELEMENT_END							0x259F
#define UNICODE_GEOMETRIC_SHAPE_START						0x25A0
#define UNICODE_GEOMETRIC_SHAPE_END							0x25FF
#define UNICODE_MISC_SYMBOLS_START							0x2600
#define UNICODE_MISC_SYMBOLD_END							0x26FF
#define UNICODE_CJK_SYMBOLS_AND_PUNCTUATIONS_START			0x3000
#define UNICODE_CJK_SYMBOLS_AND_PUNCTUATIONS_END			0x303F
#define UNICODE_HIRAGANA_START								0x3040
#define UNICODE_HIRAGANA_END								0x309F
#define UNICODE_KATAKANA_START								0x30A0
#define UNICODE_KATAKANA_END								0x30FF
#define UNICODE_BOPOMOFO_START								0x3100
#define UNICODE_BOPOMOFO_END								0x312F
#define UNICODE_HANGUL_COMPATIBILITY_JAMO_START				0x3130
#define UNICODE_HANGUL_COMPATIBILITY_JAMO_END				0x318F
#define UNICODE_KANBUN_START								0x3190
#define UNICODE_KANBUN_END									0x319F
#define UNICODE_ENCLOSED_CJK_LETTERS_AND_MONTHS_START		0x3200
#define UNICODE_NCLOSED_CJK_LETTERS_AND_MONTHS_END			0x32FF
#define UNICODE_CJK_COMPATIBILITY_START						0x3300
#define UNICODE_CJK_COMPATIBILITY_END						0x33FF
#define UNICODE_CJK_UNIFIED_IDEOGRAPHS_START				0x4E00
#define UNICODE_CJK_UNIFIED_IDEOGRAPHS_END					0x9FFF
#define UNICODE_HANGUL_SYLLABLES_START						0xAC00
#define UNICODE_HANGUL_SYLLABLES_END						0xD7A3
#define UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_START			0xF900
#define UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_END			0xFAFF
#define UNICODE_FULLWIDTH_ASCII_START						0xFF01
#define UNICODE_FULLWIDTH_ASCII_END							0xFF5E
#define UNICODE_HALFWIDTH_CJK_PUNCTUATION_START				0xFF61
#define UNICODE_HALFWIDTH_CJK_PUNCTUATION_END				0xFF64
#define UNICODE_HALFWIDTH_KATAKANA_START					0xFF65
#define UNICODE_HALFWIDTH_KATAKANA_END						0xFF9F
#define UNICODE_HALFWIDTH_HANGUL_JAMO_FILLER				0xFFA0
#define UNICODE_HALFWIDTH_HANGULE_JAMO_START				0xFFA1
#define UNICODE_HALFWIDTH_HANGULE_JAMO_END					0xFFDC
#define UNICODE_FULLWIDTH_PUNCTUATION_AND_CURRENCY_START	0xFFE0
#define UNICODE_FULLWIDTH_PUNCTUATION_AND_CURRENCY_END		0xFFE6
#define UNICODE_HALFWIDTH_FORMS_ARROWS_SHAPES_START			0xFFE8
#define UNICODE_HALFWIDTH_FORMS_ARROWS_SHAPES_END			0xFFEE

/*---------------------------------------------------------------------------
	fIsHangulSyllable
---------------------------------------------------------------------------*/
__inline
BOOL fIsHangulSyllable(WCHAR wcCh)
    {
    return (wcCh >= UNICODE_HANGUL_SYLLABLES_START && 
            wcCh <= UNICODE_HANGUL_SYLLABLES_END);
    }

/*---------------------------------------------------------------------------
	fIsHangulCompJamo
---------------------------------------------------------------------------*/
__inline
BOOL fIsHangulCompJamo(WCHAR wcCh)
    {
    return (wcCh >= UNICODE_HANGUL_COMPATIBILITY_JAMO_START && 
            wcCh <= UNICODE_HANGUL_COMPATIBILITY_JAMO_END);
    }
    
/*---------------------------------------------------------------------------
	fIsHangul
---------------------------------------------------------------------------*/
__inline 
BOOL fIsHangul(WCHAR wcCh)
    {
    return (fIsHangulSyllable(wcCh) || fIsHangulCompJamo(wcCh));
    }

/*---------------------------------------------------------------------------
	fIsHanja
	
	TODO: What about Extenstion-A ?
---------------------------------------------------------------------------*/
__inline 
BOOL fIsHanja(WCHAR wch)
{
	if ( (wch >= UNICODE_CJK_UNIFIED_IDEOGRAPHS_START       && wch <= UNICODE_CJK_UNIFIED_IDEOGRAPHS_END) ||  
		 (wch >= UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_START && wch <= UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_END) )
		return TRUE;
	else
		return FALSE;
}

/*---------------------------------------------------------------------------
	fIsHangulOrHanja
---------------------------------------------------------------------------*/
__inline 
BOOL fIsHangulOrHanja(WCHAR wcCh)
    {
    return (fIsHangul(wcCh) || fIsHanja(wcCh));
    }

#endif /* UCUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\userex.cpp ===
/****************************************************************************
    USEREX.CPP

    Owner: cslim
    Copyright (c) 1997-2000 Microsoft Corporation

    Windows User API extension functions
    
    History:
    01-JUN-2000 cslim       Ported from IME code
    19-JUL-1999 cslim       Created
*****************************************************************************/

#include "private.h"
#include <windowsx.h>
#include "userex.h"
#include "osver.h"

inline Min(INT a, INT b) 
{
     return ((a)<(b)?(a):(b)) ;
}

/*---------------------------------------------------------------------------
    LoadStringExW

    Wrapper of LoadStringW() API.
    Load Unicode string with specified Language in any platform.
---------------------------------------------------------------------------*/
INT WINAPI LoadStringExW(HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, INT nBufferMax)
{
    INT     cchwstr = 0;
    UINT    block, num;
    HRSRC   hres;
    HGLOBAL hgbl;
    LPWSTR  lpwstr;

    if (!hInst || !lpBuffer)
        return 0;

    block = (uID >>4)+1;
    num   = uID & 0xf;

    hres = FindResourceEx(hInst,
                          RT_STRING,
                          MAKEINTRESOURCE(block),
                          GetSystemDefaultLangID());

    if (hres == NULL)
        hres = FindResourceEx(hInst,
                          RT_STRING,
                          MAKEINTRESOURCE(block),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT));

    if (!hres)
        goto Error;

    if ((hgbl = LoadResource(hInst, hres)) == NULL)
        goto Error;

    if ((lpwstr = (LPWSTR)LockResource(hgbl)) == NULL)
        goto Error;

    for(UINT i = 0; i < num; i++)
        lpwstr += *lpwstr + 1;

    cchwstr = *lpwstr;
    CopyMemory(lpBuffer, lpwstr+1, Min(cchwstr, nBufferMax-1) * sizeof(WCHAR));
    
 Error:
     lpBuffer[Min(cchwstr, nBufferMax-1)]= (WCHAR)0x0000;
    return cchwstr;
}

/*---------------------------------------------------------------------------
    LoadStringExA

    Wrapper of LoadStringA() API.
---------------------------------------------------------------------------*/
INT WINAPI LoadStringExA(HINSTANCE hInst, INT uID, LPSTR lpBuffer, INT nBufferMax)
{
    INT cchstr;
    LPWSTR lpwstr;

    if (!hInst || !lpBuffer)
        return 0;

    if ((lpwstr = (LPWSTR)GlobalAllocPtr(GHND, nBufferMax*sizeof(WCHAR))) == NULL)
        return 0;

    // Call wide version
    LoadStringExW(hInst, uID, lpwstr, nBufferMax/2);
    
    // W to A
    cchstr = WideCharToMultiByte(CP_ACP, 
                              0, 
                              lpwstr, -1,
                              lpBuffer, nBufferMax, 
                              NULL, NULL); 

    if (cchstr)
        cchstr--;    // remove NULL char

    GlobalFreePtr(lpwstr);
    return cchstr;
}

/*---------------------------------------------------------------------------
    LoadMenuTemplateEx
---------------------------------------------------------------------------*/
static MENUTEMPLATE* LoadMenuTemplateEx(LANGID lgid, HINSTANCE hInstance, LPCSTR pchTemplate)
{
    HRSRC  hResMenu;
    HANDLE hMenuTmpl;

    hResMenu = FindResourceEx(hInstance, RT_MENU, pchTemplate, lgid);

    if((hResMenu == NULL) && (lgid != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)))
        hResMenu = FindResourceEx(hInstance,
                                 RT_MENU,
                                 pchTemplate,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
        
    if (hResMenu == NULL)
        return NULL; 

    hMenuTmpl = LoadResource( hInstance, hResMenu );
    if(hMenuTmpl == NULL)
        return NULL;

    return (MENUTEMPLATE *)LockResource( hMenuTmpl );
}

/*---------------------------------------------------------------------------
    LoadMenuEx
---------------------------------------------------------------------------*/
HMENU WINAPI LoadMenuEx(HINSTANCE hInstance, LPCSTR lpMenuName)
{
    MENUTEMPLATE* pMenuTmpl;
    pMenuTmpl = LoadMenuTemplateEx(GetSystemDefaultLangID(), hInstance, lpMenuName);
    if (pMenuTmpl != NULL)
        return LoadMenuIndirect(pMenuTmpl);
    else
        return HMENU(0);
}

/*---------------------------------------------------------------------------
    LoadDialogTemplateEx
---------------------------------------------------------------------------*/
DLGTEMPLATE* WINAPI LoadDialogTemplateEx(LANGID lgid, HINSTANCE hInstance, LPCSTR pchTemplate)
{
    HRSRC  hResDlg;
    HANDLE hDlgTmpl;

    hResDlg = FindResourceExA(hInstance, RT_DIALOG, pchTemplate, lgid);

    if ((hResDlg == NULL) && (lgid != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)))
        hResDlg = FindResourceExA(hInstance,
                                  RT_DIALOG,
                                  pchTemplate,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

    if (hResDlg == NULL)
        return NULL; 

    hDlgTmpl = LoadResource(hInstance, hResDlg);

    if(hDlgTmpl == NULL)
        return NULL;

    return (DLGTEMPLATE *)LockResource(hDlgTmpl);
}

/*---------------------------------------------------------------------------
    OurGetMessage
---------------------------------------------------------------------------*/
BOOL WINAPI OurGetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
{
    if (IsOnNT())
        return ::GetMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    else
        return ::GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
}

/*---------------------------------------------------------------------------
    IsWin64
---------------------------------------------------------------------------*/
#if !defined(_WIN64)
BOOL WINAPI IsWin64()
{
    static BOOL fFristCallIsWin64 = fTrue;
    static BOOL fIsWin64 = fFalse;
    SYSTEM_INFO sys;

    if (fFristCallIsWin64 == fFalse)
            return fIsWin64;

    GetNativeSystemInfo(&sys);
    
    fIsWin64 = (sys.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
    			||(sys.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64);

    fFristCallIsWin64 = fFalse;
    return fIsWin64;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\ucutil.cpp ===
//
// uctuil.cpp
//

#include    "private.h"
#include	"debug.h"
#include	"ucutil.h"


/*   C P G  F R O M  C H S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
UINT CpgFromChs( BYTE chs )
{
	DWORD dwChs = chs;
	CHARSETINFO ChsInfo = {0};

	if (chs != SYMBOL_CHARSET && TranslateCharsetInfo( &dwChs, &ChsInfo, TCI_SRCCHARSET ))
		{
		return ChsInfo.ciACP;
		}

	return GetACP();
}


//
// conversion functions
//

/*   C O N V E R T  L O G  F O N T  W T O  A   */
/*------------------------------------------------------------------------------

	Convert LOGFONTW to LOGFONTA

------------------------------------------------------------------------------*/
void ConvertLogFontWtoA( CONST LOGFONTW *plfW, LOGFONTA *plfA )
{
	UINT cpg;

	plfA->lfHeight         = plfW->lfHeight;
	plfA->lfWidth          = plfW->lfWidth;
	plfA->lfEscapement     = plfW->lfEscapement;
	plfA->lfOrientation    = plfW->lfOrientation;
	plfA->lfWeight         = plfW->lfWeight;
	plfA->lfItalic         = plfW->lfItalic;
	plfA->lfUnderline      = plfW->lfUnderline;
	plfA->lfStrikeOut      = plfW->lfStrikeOut;
	plfA->lfCharSet        = plfW->lfCharSet;
	plfA->lfOutPrecision   = plfW->lfOutPrecision;
	plfA->lfClipPrecision  = plfW->lfClipPrecision;
	plfA->lfQuality        = plfW->lfQuality;
	plfA->lfPitchAndFamily = plfW->lfPitchAndFamily;

	cpg = CpgFromChs( plfW->lfCharSet );
	ConvertStrWtoA( plfW->lfFaceName, -1, plfA->lfFaceName, ARRAYSIZE(plfA->lfFaceName), cpg );
}


/*   C O N V E R T  L O G  F O N T  A T O  W   */
/*------------------------------------------------------------------------------

	Convert LOGFONTA to LOGFONTW

------------------------------------------------------------------------------*/
void ConvertLogFontAtoW( CONST LOGFONTA *plfA, LOGFONTW *plfW )
{
	UINT cpg;

	plfW->lfHeight         = plfA->lfHeight;
	plfW->lfWidth          = plfA->lfWidth;
	plfW->lfEscapement     = plfA->lfEscapement;
	plfW->lfOrientation    = plfA->lfOrientation;
	plfW->lfWeight         = plfA->lfWeight;
	plfW->lfItalic         = plfA->lfItalic;
	plfW->lfUnderline      = plfA->lfUnderline;
	plfW->lfStrikeOut      = plfA->lfStrikeOut;
	plfW->lfCharSet        = plfA->lfCharSet;
	plfW->lfOutPrecision   = plfA->lfOutPrecision;
	plfW->lfClipPrecision  = plfA->lfClipPrecision;
	plfW->lfQuality        = plfA->lfQuality;
	plfW->lfPitchAndFamily = plfA->lfPitchAndFamily;

	cpg = CpgFromChs( plfA->lfCharSet );
	ConvertStrAtoW( plfA->lfFaceName, -1, plfW->lfFaceName, ARRAYSIZE(plfW->lfFaceName), cpg );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\tip\userex.h ===
/****************************************************************************
	USEREX.H

	Owner: cslim
	Copyright (c) 1997-2000 Microsoft Corporation

	Windows User API extension functions
	
	History:
	01-JUN-2000 cslim       Ported from IME code
	19-JUL-1999 cslim       Created
*****************************************************************************/

#if !defined (_USEREX_H__INCLUDED_)
#define _USEREX_H__INCLUDED_

// Function declare
extern INT WINAPI LoadStringExW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, INT nBufferMax);
extern INT WINAPI LoadStringExA(HINSTANCE hInst, INT uID, LPSTR lpBuffer, INT nBufferMax);
extern HMENU WINAPI LoadMenuEx(HINSTANCE hInstance, LPCSTR lpMenuName);
extern DLGTEMPLATE* WINAPI LoadDialogTemplateEx(LANGID lgid, HINSTANCE hInstance, LPCSTR pchTemplate);
extern BOOL WINAPI OurGetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
extern BOOL WINAPI IsWin64();

/*---------------------------------------------------------------------------
	IsHighContrast
---------------------------------------------------------------------------*/
inline
BOOL IsHighContrastBlack()
{
	// high contrast black
	return (GetSysColor(COLOR_3DFACE) == RGB(0,0,0));
}

#endif // _USEREX_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\api1632.h ===
#ifndef H__api1632
#define H__api1632


/* Wonderware additions....  */

#ifdef WIN32

// ignore nb30.h
#define NCB_INCLUDED

// ignore wwheap.h
#define H__wwheap
typedef unsigned long HHEAP;

#define hmemcpy(d,s,l) memcpy(d,s,l)
#define GlobalPtrHandle(x)      \
            (GlobalHandle(x))
#define HeapAllocPtr(x,y,z) \
            (GlobalLock(GlobalAlloc(y,z)))
#define HeapFreePtr(p) \
            (GlobalUnlock(GlobalHandle(p)), GlobalFree(GlobalHandle(p)))
#define HeapInit() (1)

#define _fstrncpy strncpy
#define _fstrcpy  strcpy
#define _fstrncmp strncmp
#define _fstrnicmp _strnicmp
#define _fstricmp _stricmp
#define _fstrupr  _strupr
#define _fstrchr  strchr
#define _fstrrchr strrchr
#define _fstrcat  strcat
#define _fstrlen  strlen
#define _fmemcpy  memcpy
#define _fmemset  memset
#define _fstrstr  strstr
#define _fstrpbrk strpbrk

#define MoveTo(h,x,y) MoveToEx(h,x,y,NULL)

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\version\verres.h ===
/****************************************************************************
	VERRES.H

	Owner: cslim
	Copyright (c) 1997-2000 Microsoft Corporation

	History:
	18-DEC-2000 cslim       Created
*****************************************************************************/
#if !defined (_VERRES_H__INCLUDED_)
#define _VERRES_H__INCLUDED_

#include <ntverp.h>

// For Boot strapper exe (setup.exe)
// #define THIS_VERSION_STR TEXT("{6.1.2406.0}")

#ifndef VERRES_VERSION_MAJOR
#define VERRES_VERSION_MAJOR 6
#endif

#ifndef VERRES_VERSION_MINOR
#define VERRES_VERSION_MINOR 1
#endif

#ifndef VERRES_VERSION_BUILD
#define VERRES_VERSION_BUILD VER_PRODUCTBUILD
#endif

#ifndef VERRES_VERSION_REVISION
#define VERRES_VERSION_REVISION 0
#endif

#endif // !defined (_VERRES_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\cks32.h ===
VOID	FAR PASCAL Checksum32( DWORD FAR *lpChksum,
			    BYTE FAR *lpData, WORD wLength );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\crc.h ===
/* $Header: "Ver=%v  %f  LastEdit=%w  Locker=%l" */
/* "Ver=1  16-Dec-92,10:03:32  LastEdit=IGOR  Locker=***_NOBODY_***" */
void FAR PASCAL one_crc_16( WORD FAR *, BYTE );
void FAR PASCAL crc_16( WORD FAR *, BYTE FAR *, int);
void FAR PASCAL one_crc_ccitt(WORD FAR *, BYTE );
void FAR PASCAL crc_ccitt(WORD FAR *, BYTE FAR *, int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\critsec.h ===
extern CRITICAL_SECTION csNetDde;

#define EnterCrit() (EnterCriticalSection(&csNetDde))
#define LeaveCrit() (LeaveCriticalSection(&csNetDde))
#define CheckCritIn() assert((HANDLE)(ULONG_PTR)GetCurrentThreadId() == csNetDde.OwningThread)
#define CheckCritOut() assert((HANDLE)(ULONG_PTR)GetCurrentThreadId() != csNetDde.OwningThread)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\ddepkt.h ===
#ifndef H__ddepkt
#define H__ddepkt

/*
    D D E P K T
	
	DDEPKT is the unit of "message" in the netdde environment.
	Each DDEPKT contains the information pertaining to one DDE message.
 */
typedef struct ddepkt {
    DWORD		dp_size;	/* size of DDEPKT including this structure */
    struct ddepkt FAR  *dp_prev;	/* previous pointer */
    struct ddepkt FAR  *dp_next;	/* next pointer */
    DWORD_PTR	dp_hDstDder;	/* handle to destination DDER */
    DWORD_PTR	dp_hDstRouter;	/* handle to destination Router */
    DWORD		dp_routerCmd;	/* command for final Router */
} DDEPKT;
typedef DDEPKT FAR *LPDDEPKT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\dbgdde.h ===
VOID	FAR PASCAL DebugDDEMessage( PSTR, HWND, UINT, WPARAM, LPARAM );
extern BOOL	bDebugDDE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\dder.h ===
#ifndef H__dder
#define H__dder

/*	Calls from Router */
VOID	DderConnectionComplete( HDDER hDder, HROUTER hRouter );
VOID	DderConnectionBroken( HDDER hDder );
VOID	DderPacketFromRouter( HROUTER hRouter, LPDDEPKT lpDdePkt );
VOID	DderSetNextForRouter( HDDER hDder, HDDER hDderNext );
VOID	DderSetPrevForRouter( HDDER hDder, HDDER hDderPrev );
VOID	DderGetNextForRouter( HDDER hDder, HDDER FAR *lphDderNext );
VOID	DderGetPrevForRouter( HDDER hDder, HDDER FAR *lphDderPrev );

/*	Calls from IPC */
VOID	DderPacketFromIPC( HDDER hDder, HIPC hIpc, LPDDEPKT lpDdePkt );
HDDER	DderInitConversation( HIPC hIpc, HROUTER hRouter, LPDDEPKT lpDdePkt );
VOID	DderCloseConversation( HDDER hDder, HIPC hIpcFrom );

/*
    types
 */
#define DDTYPE_LOCAL_NET        (1)     /* local -> net */
#define DDTYPE_NET_LOCAL        (2)     /* net -> local */
#define DDTYPE_LOCAL_LOCAL      (3)     /* local -> local */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\csv.h ===
PSTR FAR PASCAL CsvToken( PSTR pszBuf );
BOOL FAR PASCAL TokenBool( PSTR pszToken, BOOL bDefault );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\debug.h ===
#ifndef H__debug
#define H__debug

/*
    Any functions that use windows.h types must be put in the 2nd section
 */

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
void    debug(char *, ...);
void    DebugInit( char * lpszDebugName );
#else
void    _cdecl  debug(char *, ...);
void    __stdcall DebugInit( char * lpszDebugName );
#endif

#if DBG
#define DPRINTF(x)  debug x
#define DIPRINTF(x)  if (bDebugInfo) debug x
#define HEXDUMP(s, n) hexDump(s, n)
#define MEMERROR() NDDELogError(MSG417, __LINE__, __FILE__, NULL);
#else
#define DPRINTF(x)
#define DIPRINTF(x)
#define HEXDUMP(s, n)
#define MEMERROR()
#endif // DBG

#ifndef SKIP_DEBUG_WIN32
/*  dump.c functions */

BOOL    DumpDacl( LPTSTR szDumperName, PSECURITY_DESCRIPTOR pSD );
BOOL    DumpSid( LPTSTR szDumperName, PSID pSid );
VOID    DumpToken( HANDLE hToken );
BOOL    GetTokenUserDomain( HANDLE hToken, PSTR user, DWORD nUser,
            PSTR domain, DWORD nDomain );
VOID    DumpWhoIAm( LPSTR lpszMsg );
#endif // SKIP_DEBUG_WIN32

// #define DEBUG_IT
#ifndef DEBUG_IT
#define TRACEINIT(x)
#else
#define TRACEINIT(x) { char sz[100]; \
    char *szT; \
    wsprintfA(sz, "pid=%x, tid=%x | ", GetCurrentProcessId(), GetCurrentThreadId()); \
    szT = sz + strlen(sz); \
    wsprintfA##x; \
    strcat(szT, "\n"); \
    OutputDebugString(sz); \
    }
#endif

#endif // H__debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\getglobl.h ===
#ifndef H__getglobl
#define H__getglobl

HANDLE FAR PASCAL GetGlobalAlloc( WORD, DWORD );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\hardware.h ===
/* eliminate x86 specific compiler statements for other platforms */
/*      future versions should use undersore version of platform names */

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
#define __stdcall
#define _stdcall
#define stdcall
#define __cdecl
#define _cdecl
#define cdecl
#define __export
#define _export
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\ddepkts.h ===
#ifndef H__ddepkts
#define H__ddepkts

#ifndef H__ddepkt
#include    "ddepkt.h"
#define H__ddepkt
#endif

#define PQOS PSECURITY_QUALITY_OF_SERVICE
#define QOS SECURITY_QUALITY_OF_SERVICE

/*
    DDEPKTCMN           common information for all DDE message packets
 */
typedef struct {
    DDEPKT      dc_ddePkt;
    WORD        dc_message;
    WORD        dc_filler1;
    DWORD       dc_hConvSrc;
    DWORD       dc_hConvDst;
} DDEPKTCMN;
typedef DDEPKTCMN FAR *LPDDEPKTCMN;

/*
    DDEPKTINIT          initiate packet
 */
typedef struct {
    DDEPKTCMN   dp_init_ddePktCmn;
    HDDER       dp_init_fromDder;
    WORD        dp_init_offsFromNode;
    WORD        dp_init_offsFromApp;
    WORD        dp_init_offsToNode;
    WORD        dp_init_offsToApp;
    WORD        dp_init_offsToTopic;
    WORD        dp_init_offsPassword;
    DWORD       dp_init_hSecurityKey;
    DWORD       dp_init_dwSecurityType;
    DWORD       dp_init_sizePassword;
} DDEPKTINIT;
typedef DDEPKTINIT FAR *LPDDEPKTINIT;

/*
    DDEPKTSEC       defines the structure of "dp_init_offsPassword"
*/

typedef struct {
    WORD    dp_sec_offsUserName;
    WORD    dp_sec_sizeUserName;
    WORD    dp_sec_offsDomainName;
    WORD    dp_sec_sizeDomainName;
    WORD    dp_sec_offsPassword;
    WORD    dp_sec_sizePassword;
    WORD    dp_sec_offsQos;
    WORD    dp_sec_sizeQos;
} DDEPKTSEC;
typedef DDEPKTSEC FAR *LPDDEPKTSEC;

/*
    DDEPKTIACK          initiate ack packet
 */
typedef struct {
    DDEPKTCMN   dp_iack_ddePktCmn;
    HDDER       dp_iack_fromDder;
    DWORD       dp_iack_reason;
    DWORD       dp_iack_hSecurityKey;               /* replaced iack_prmXXXX */
    DWORD       dp_iack_dwSecurityType;             /* replaced iack_prmXXXX */
    WORD        dp_iack_offsFromNode;
    WORD        dp_iack_offsFromApp;
    WORD        dp_iack_offsFromTopic;
    WORD        dp_iack_offsSecurityKey;
    DWORD       dp_iack_sizeSecurityKey;
} DDEPKTIACK;
typedef DDEPKTIACK FAR *LPDDEPKTIACK;

#include    "sectype.h"

/*
    DDEPKTTERM          terminate packet
 */
typedef struct {
    DDEPKTCMN   dp_term_ddePktCmn;
} DDEPKTTERM;
typedef DDEPKTTERM FAR *LPDDEPKTTERM;

/*
    DDEPKTEXEC          execute packet
 */
typedef struct {
    DDEPKTCMN   dp_exec_ddePktCmn;
    char        dp_exec_string[ 1 ];
} DDEPKTEXEC;
typedef DDEPKTEXEC FAR *LPDDEPKTEXEC;

/*
    DDEPKTEACK          ack execute packet
 */
typedef struct {
    DDEPKTCMN   dp_eack_ddePktCmn;
    BYTE        dp_eack_fAck;
    BYTE        dp_eack_fBusy;
    BYTE        dp_eack_bAppRtn;
    BYTE        dp_eack_filler;
} DDEPKTEACK;
typedef DDEPKTEACK FAR *LPDDEPKTEACK;

/*
    DDEPKTGACK          generic ack packet
        
        used for
            WM_DDE_ACK_ADVISE
            WM_DDE_ACK_REQUEST
            WM_DDE_ACK_UNADVISE
            WM_DDE_ACK_POKE
            WM_DDE_ACK_DATA
 */
typedef struct {
    DDEPKTCMN   dp_gack_ddePktCmn;
    BYTE        dp_gack_fAck;
    BYTE        dp_gack_fBusy;
    BYTE        dp_gack_bAppRtn;
    char        dp_gack_itemName[ 1 ];
} DDEPKTGACK;
typedef DDEPKTGACK FAR *LPDDEPKTGACK;

/*
    DDEPKTRQST          request packet
 */
typedef struct {
    DDEPKTCMN   dp_rqst_ddePktCmn;
    WORD        dp_rqst_cfFormat;
    WORD        dp_rqst_offsFormat;
    WORD        dp_rqst_offsItemName;
    WORD        dp_rqst_filler;
} DDEPKTRQST;
typedef DDEPKTRQST FAR *LPDDEPKTRQST;

/*
    DDEPKTUNAD          unadvise packet
 */
typedef struct {
    DDEPKTCMN   dp_unad_ddePktCmn;
    WORD        dp_unad_cfFormat;
    WORD        dp_unad_offsFormat;
    WORD        dp_unad_offsItemName;
    WORD        dp_unad_filler;
} DDEPKTUNAD;
typedef DDEPKTUNAD FAR *LPDDEPKTUNAD;

/*
    DDEPKTADVS          advise packet
 */
typedef struct {
    DDEPKTCMN   dp_advs_ddePktCmn;
    WORD        dp_advs_cfFormat;
    WORD        dp_advs_offsFormat;
    WORD        dp_advs_offsItemName;
    BYTE        dp_advs_fAckReq;
    BYTE        dp_advs_fNoData;
} DDEPKTADVS;
typedef DDEPKTADVS FAR *LPDDEPKTADVS;

/*
    DDEPKTDATA          data packet
 */
typedef struct {
    DDEPKTCMN   dp_data_ddePktCmn;
    WORD        dp_data_cfFormat;
    WORD        dp_data_offsFormat;
    WORD        dp_data_offsItemName;
    WORD        dp_data_offsData;
    DWORD       dp_data_sizeData;
    BYTE        dp_data_fResponse;
    BYTE        dp_data_fAckReq;
    BYTE        dp_data_fRelease;
    BYTE        dp_data_filler;
} DDEPKTDATA;
typedef DDEPKTDATA FAR *LPDDEPKTDATA;

/*
    DDEPKTPOKE          poke packet
 */
typedef struct {
    DDEPKTCMN   dp_poke_ddePktCmn;
    WORD        dp_poke_cfFormat;
    WORD        dp_poke_offsFormat;
    WORD        dp_poke_offsItemName;
    WORD        dp_poke_offsData;
    DWORD       dp_poke_sizeData;
    BYTE        dp_poke_fRelease;
    BYTE        dp_poke_filler[ 3 ];
} DDEPKTPOKE;
typedef DDEPKTPOKE FAR *LPDDEPKTPOKE;

/*
    DDEPKTTEST          generic test packet
        
        used for
            WM_DDE_TEST
 */
typedef struct {
    DDEPKTCMN   dp_test_ddePktCmn;
    BYTE        dp_test_nTestNo;
    BYTE        dp_test_nPktNo;
    BYTE        dp_test_nTotalPkts;
    BYTE        dp_test_filler;
} DDEPKTTEST;
typedef DDEPKTTEST FAR *LPDDEPKTTEST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\hexdump.h ===
#ifndef H__hexdump
#define H__hexdump

VOID FAR PASCAL hexDump( LPSTR, int );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\host.h ===
#ifdef _WINDOWS
#define PcToHostLong(x) (x)
#define PcToHostWord(x) (x)
#define HostToPcLong(x) (x)
#define HostToPcWord(x) (x)
#ifdef WIN32
#include "api1632.h"
#define byte    unsigned char
#endif
#else
#ifdef VAX
#define PcToHostLong(x) (x)
#define PcToHostWord(x) (x)
#define HostToPcLong(x) (x)
#define HostToPcWord(x) (x)
#else
#define PcToHostLong(x)   ( (((x)&0xFF) << 24) |		\
			    ((((x)>>8)&0xFF) << 16) |		\
			    ((((x)>>16)&0xFF) << 8) |		\
			    ((((x)>>24)&0xFF)) )
#define HostToPcLong(x)   ( (((x)&0xFF) << 24) |		\
			    ((((x)>>8)&0xFF) << 16) |		\
			    ((((x)>>16)&0xFF) << 8) |		\
			    ((((x)>>24)&0xFF)) )
#define PcToHostWord(x) ( (((x)>>8) & 0xFF) | (((x) & 0xFF)<<8) )
#define HostToPcWord(x) ( (((x)>>8) & 0xFF) | (((x) & 0xFF)<<8) )
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\internal.h ===
#ifndef H__internal
#define H__internal

VOID	FAR PASCAL	InternalErrorSetHWnd( HWND );
VOID	FAR PASCAL	InternalErrorSignOn( void );
VOID	FAR PASCAL	InternalErrorSignOff( void );
int	FAR PASCAL	InternalErrorNumUsers( void );
VOID  	FAR PASCAL 	InternalErrorStarted( void );
VOID  	FAR PASCAL 	InternalErrorDone( void );
BOOL  	FAR PASCAL 	InternalErrorAlreadyStarted( void );

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
VOID 	far 		InternalError(LPSTR, ...);
#else
VOID	far cdecl	InternalError(LPSTR, ...);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\ipc.h ===
#ifndef H__ipc
#define H__ipc

HIPC	IpcInitConversation( HDDER hDder, LPDDEPKT lpDdePkt, 
		BOOL bStartApp, LPSTR lpszCmdLine, WORD dd_type );
VOID	IpcAbortConversation( HIPC hIpc );
BOOL	IpcXmitPacket( HIPC hIpc, HDDER hDder, LPDDEPKT lpDdePkt );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\hmemcpy.h ===
#ifdef WIN32
typedef char *  LPHSTR;
typedef void *  LPHVOID;
#else
typedef char huge*  LPHSTR;
typedef void huge*  LPHVOID;

VOID FAR PASCAL hmemcpy( LPVOID lpDest, const LPVOID lpSrc, 
			    DWORD dwSize );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

nddemsg.h nddemsg.rc: nddemsg.mc
	mc -v -h $(O) nddemsg.mc -r $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\nddelog.h ===
#define MAX_VAR_ARGS    16
#define MAX_LOG_STRING  64

VOID NDDELogErrorA(DWORD EventId, ...);
VOID NDDELogWarningA(DWORD EventId, ...);
VOID NDDELogInfoA(DWORD EventId, ...);
VOID NDDELogDataA(DWORD EventId, DWORD cbData, LPVOID lpvData);
LPSTR LogStringA(LPSTR szFormat, ...);

VOID NDDELogErrorW(DWORD EventId, ...);
VOID NDDELogWarningW(DWORD EventId, ...);
VOID NDDELogInfoW(DWORD EventId, ...);
VOID NDDELogDataW(DWORD EventId, DWORD cbData, LPVOID lpvData);
LPWSTR LogStringW(LPWSTR szFormat, ...);

#ifdef UNICODE
#define NDDELogError	NDDELogErrorW
#define NDDELogWarning	NDDELogWarningW
#define NDDELogInfo	NDDELogInfoW
#define NDDELogData	NDDELogDataW
#define LogString	LogStringW
#else
#define NDDELogError	NDDELogErrorA
#define NDDELogWarning	NDDELogWarningA
#define NDDELogInfo	NDDELogInfoA
#define NDDELogData	NDDELogDataA
#define LogString	LogStringA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\nddeapis.h ===
//========================================================================
//
//  NDDEAPIS.H  supplemental include file for dde share apis
//
//========================================================================
// tabstop = 4

#ifndef          NDDEAPI_INCLUDED
#define          NDDEAPI_INCLUDED

#ifndef _INC_NDDESEC
#include    "nddesec.h"
#endif

// ============= connectFlags options =====

#define DDEF_NOPASSWORDPROMPT   0x0001

// others reserved!

//============== Api Constants ============

// String size constants

#define MAX_PASSWORD            15

// Permission mask bits

#define DDEACCESS_REQUEST       NDDE_SHARE_REQUEST
#define DDEACCESS_ADVISE        NDDE_SHARE_ADVISE
#define DDEACCESS_POKE          NDDE_SHARE_POKE
#define DDEACCESS_EXECUTE       NDDE_SHARE_EXECUTE

// ============== Data Structures =========


//=============================================================
// DDESESSINFO - contains information about a DDE session

// ddesess_Status defines

#define DDESESS_CONNECTING_WAIT_NET_INI                1
#define DDESESS_CONNECTING_WAIT_OTHR_ND                2
#define DDESESS_CONNECTED                              3
#define DDESESS_DISCONNECTING                          4       

struct DdeSessInfo_tag {
                char        ddesess_ClientName[UNCLEN+1];
                short       ddesess_Status;
                DWORD_PTR   ddesess_Cookie;      // used to distinguish
                                                                                                               // clients of the same
                                                                                                               // name on difft. nets
};

typedef struct DdeSessInfo_tag DDESESSINFO;
typedef struct DdeSessInfo_tag * PDDESESSINFO;
typedef struct DdeSessInfo_tag far * LPDDESESSINFO;


struct DdeConnInfo_tag {
        LPSTR   ddeconn_ShareName;
        short   ddeconn_Status;
        short   ddeconn_pad;
};

typedef struct DdeConnInfo_tag DDECONNINFO;
typedef struct DdeConnInfo_tag * PDDECONNINFO;
typedef struct DdeConnInfo_tag far * LPDDECONNINFO;



//=============================================================
//=============================================================
//
//                              API FUNCTION PROTOTYPES
//
//=============================================================
//=============================================================

//   The following functions are to be supplied (not necessarily part of API)


LPBYTE WINAPI
DdeEnkrypt2(                            // pointer to enkrypted byte stream returned
        LPBYTE  lpPasswordK1,           // password output in first phase
        DWORD   cPasswordK1Size,        // size of password to be enkrypted
        LPBYTE  lpKey,                  // pointer to key 
        DWORD   cKey,                   // size of key
        LPDWORD lpcbPasswordK2Size      // get size of resulting enkrypted stream
);


#endif  // NDDEAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\nddemsg.c ===
#include "windows.h"

int
WinMain( HINSTANCE x, HINSTANCE y, LPSTR z, int a )
{
return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\nddeapip.h ===
UINT WINAPI
NDdeSpecialCommandA(
    LPSTR   lpszServer,
    UINT    nCommand,
    LPBYTE  lpDataIn,
    UINT    nBytesDataIn,
    LPBYTE  lpDataOut,
    UINT   *lpBytesDataOut
);

UINT WINAPI
NDdeSpecialCommandW(
    LPWSTR  lpszServer,
    UINT    nCommand,
    LPBYTE  lpDataIn,
    UINT    nBytesDataIn,
    LPBYTE  lpDataOut,
    UINT   *lpBytesDataOut
);

#ifdef UNICODE
#define NDdeSpecialCommand      NDdeSpecialCommandW
#else
#define NDdeSpecialCommand      NDdeSpecialCommandA
#endif

/*
 * These constants were enlarged to fix a bug in NetDDE
 * but for some reason they are exported in the public
 * nddeapi.h file so internally we use these private
 * constants instead.
 */
#define MAX_DOMAINNAMEP          31
#define MAX_USERNAMEP            (15 + MAX_DOMAINNAME + 3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\nddesec.h ===
#ifndef          _INC_NDDESEC
#define          _INC_NDDESEC

#include <winnt.h>

#define NDDE_SHAREDB_ADD        (0x00000001)
#define NDDE_SHAREDB_DELETE     (0x00000002)
#define NDDE_SHAREDB_LIST       (0x00000004)
#define NDDE_SHAREDB_FSERVICE   (0x00000008)
#define NDDE_SHAREDB_READ       (0x00000010)
#define NDDE_SHAREDB_WRITE      (0x00000020)
#define NDDE_SHAREDB_SPECIALCOMMAND (0x00000040)

#define NDDE_SHAREDB_ADMIN      (NDDE_SHAREDB_ADD |         \
                                 NDDE_SHAREDB_DELETE |      \
                                 NDDE_SHAREDB_LIST |        \
                                 NDDE_SHAREDB_FSERVICE |    \
                                 NDDE_SHAREDB_READ |        \
                                 NDDE_SHAREDB_WRITE |       \
                                 NDDE_SHAREDB_SPECIALCOMMAND |       \
                                 READ_CONTROL |             \
                                 WRITE_DAC |                \
                                 WRITE_OWNER)

#define NDDE_SHAREDB_OPER       (NDDE_SHAREDB_ADD |         \
                                 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_POWER      (NDDE_SHAREDB_ADD |         \
                                 NDDE_SHAREDB_FSERVICE |    \
                                 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_USER       (NDDE_SHAREDB_ADD |         \
                                 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_EVERYONE   (NDDE_SHAREDB_LIST)

#define NDDE_SHARE_READ             (0x00000001)
#define NDDE_SHARE_WRITE            (0x00000002)
#define NDDE_SHARE_INITIATE_STATIC  (0x00000004)
#define NDDE_SHARE_INITIATE_LINK    (0x00000008)
#define NDDE_SHARE_REQUEST          (0x00000010)
#define NDDE_SHARE_ADVISE           (0x00000020)
#define NDDE_SHARE_POKE             (0x00000040)
#define NDDE_SHARE_EXECUTE          (0x00000080)
#define NDDE_SHARE_ADD_ITEMS        (0x00000100)
#define NDDE_SHARE_LIST_ITEMS       (0x00000200)

#define NDDE_SHARE_GENERIC_READ     (NDDE_SHARE_READ |               \
                                    NDDE_SHARE_INITIATE_STATIC |     \
                                    NDDE_SHARE_REQUEST |             \
                                    NDDE_SHARE_ADVISE |              \
                                    NDDE_SHARE_LIST_ITEMS)

#define NDDE_SHARE_GENERIC_WRITE    (NDDE_SHARE_INITIATE_STATIC |    \
                                     NDDE_SHARE_INITIATE_LINK |      \
                                     NDDE_SHARE_POKE |               \
                                     DELETE)

#define NDDE_SHARE_GENERIC_EXECUTE (NDDE_SHARE_INITIATE_STATIC |     \
                                    NDDE_SHARE_INITIATE_LINK |       \
                                    NDDE_SHARE_EXECUTE)

#define NDDE_SHARE_GENERIC_ALL     (NDDE_SHARE_READ |                \
                                    NDDE_SHARE_WRITE |               \
                                    NDDE_SHARE_INITIATE_STATIC |     \
                                    NDDE_SHARE_INITIATE_LINK |       \
                                    NDDE_SHARE_REQUEST |             \
                                    NDDE_SHARE_ADVISE |              \
                                    NDDE_SHARE_POKE |                \
                                    NDDE_SHARE_EXECUTE |             \
                                    NDDE_SHARE_ADD_ITEMS |           \
                                    NDDE_SHARE_LIST_ITEMS |          \
                                    DELETE |                         \
                                    READ_CONTROL |                   \
                                    WRITE_DAC |                      \
                                    WRITE_OWNER)



#define NDDE_ITEM_REQUEST          (0x00000001)
#define NDDE_ITEM_ADVISE           (0x00000002)
#define NDDE_ITEM_POKE             (0x00000004)

#define NDDE_ITEM_GENERIC_READ     (NDDE_ITEM_REQUEST | NDDE_ITEM_ADVISE)
#define NDDE_ITEM_GENERIC_WRITE    (NDDE_ITEM_POKE)
#define NDDE_ITEM_GENERIC_EXECUTE  (0)
#define NDDE_ITEM_GENERIC_ALL      (NDDE_ITEM_REQUEST |               \
                                   NDDE_ITEM_ADVISE |                 \
                                   NDDE_ITEM_POKE |                   \
                                   DELETE |                           \
                                   READ_CONTROL |                     \
                                   WRITE_DAC |                        \
                                   WRITE_OWNER)


#define NDDE_GUI_NONE              (0)

#define NDDE_GUI_READ              (NDDE_SHARE_GENERIC_READ)

#define NDDE_GUI_READ_LINK         (NDDE_SHARE_GENERIC_READ |         \
                                    NDDE_SHARE_INITIATE_LINK)

#define NDDE_GUI_CHANGE            (NDDE_SHARE_GENERIC_READ |         \
                                    NDDE_SHARE_GENERIC_WRITE |        \
                                    NDDE_SHARE_GENERIC_EXECUTE)

#define NDDE_GUI_FULL_CONTROL      (NDDE_SHARE_GENERIC_ALL)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\netddesh.h ===
/*
 * Strings share with other modules:
 */
#define NETDDE_TITLE    "NetDDE"
#define NETDDE_CLASS    "NetDDEMainWdw"

typedef struct _THREADDATA {
    struct _THREADDATA  *ptdNext;
    HWINSTA             hwinsta;
    HDESK               hdesk;
    HWND                hwndDDE;
    HWND                hwndDDEAgent;
    HANDLE              heventReady;
    DWORD               dwThreadId;
    BOOL                bInitiating;
} THREADDATA, *PTHREADDATA;

typedef struct _IPCINIT {
    HDDER       hDder;
    LPDDEPKT    lpDdePkt;
    BOOL        bStartApp;
    LPSTR       lpszCmdLine;
    WORD        dd_type;
} IPCINIT, *PIPCINIT;

typedef struct _IPCXMIT {
    HIPC        hIpc;
    HDDER       hDder;
    LPDDEPKT    lpDdePkt;
} IPCXMIT, *PIPCXMIT;

extern PTHREADDATA ptdHead;

extern UINT    wMsgIpcXmit;
extern UINT    wMsgDoTerminate;

extern DWORD tlsThreadData;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\netbasic.h ===
#ifndef H__netbasic
#define H__netbasic

#include "warning.h"

typedef ULONG_PTR       CONNID;
typedef unsigned long   PKTID;
typedef ULONG_PTR       HPKTZ;
typedef ULONG_PTR       HROUTER;
typedef ULONG_PTR       HDDER;
typedef ULONG_PTR       HIPC;
typedef ULONG_PTR       HTIMER;

/* maximum node name string length.
    Buffers for names should be declared char buf[ MAX_NODE_NAME+1 ]; */
#define MAX_NODE_NAME   16

/* maximum network interface name string length.
    Buffers for names should be declared char buf[ MAX_NI_NAME+1 ]; */
#define MAX_NI_NAME     8

/* maximum connection info for a netintf DLL
    Buffers for names should be declared char buf[ MAX_CONN_INFO+1 ]; */
#define MAX_CONN_INFO   (512)

/* maximum string length of "additional routing info".  This is the
    information used for routing from one node to another.
    Buffers for names should be declared char buf[ MAX_ROUTE_INFO+1 ]; */
#define MAX_ROUTE_INFO  512

/* maximum application name string length.
    Buffers for names should be declared char buf[ MAX_APP_NAME+1 ]; */
#define MAX_APP_NAME    255

/* maximum topic name string length.
    Buffers for names should be declared char buf[ MAX_TOPIC_NAME+1 ]; */
#define MAX_TOPIC_NAME  255

/*  max length for a share name */
#define MAX_SHARENAMEBUF        MAX_APP_NAME + MAX_TOPIC_NAME + 1

#define ILLEGAL_NAMECHARS       " +*\\/,?()\"'"

/*
    Reason codes for Initiate Ack failing
 */
#define RIACK_TASK_MEMORY_ERR                   (1)
#define RIACK_NETDDE_NOT_ACTIVE                 (2)
#define RIACK_LOCAL_MEMORY_ERR                  (3)
#define RIACK_ROUTE_NOT_ESTABLISHED             (4)
#define RIACK_DEST_MEMORY_ERR                   (5)
#define RIACK_NOPERM                            (6)
#define RIACK_NOPERM_TO_STARTAPP                (7)
#define RIACK_STARTAPP_FAILED                   (8)
#define RIACK_NORESP_AFTER_STARTAPP             (9)
#define RIACK_UNKNOWN                           (10)
#define RIACK_TASK_IO_ERR                       (11)
#define RIACK_TASK_MAGIC_ERR                    (12)
#define RIACK_DUPLICATE_NODE_NAME               (13)
/*  1.1 reason codes                                    */
#define RIACK_NEED_PASSWORD                     (16)
#define RIACK_SHARE_NAME_TOO_BIG                (17)
/*  NT reason codes                                     */
#define RIACK_NO_NDDE_AGENT                     (20)
#define RIACK_NOT_SHARED                        (21)
#define RIACK_NOPERM_TO_INITAPP                 (22)
/*  Share access error base: 0x100 + error code returned by ntddeapi    */
#define RIACK_SHARE_ACCESS_ERROR                (256)
/* !!! Any changes must be put into hpux\netdde.h !!! */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\netintf.h ===
#ifndef H__netintf
#define H__netintf

#include "netbasic.h"

#ifdef _WINDOWS
DWORD	NDDEInit( LPSTR lpszNodeName, HWND hWndNetdde );
#else
BOOL 	NDDEInit( LPSTR lpszNodeName );
#endif

/*  interface init status return */

#define NDDE_INIT_OK            1
#define NDDE_INIT_NO_SERVICE    2
#define NDDE_INIT_FAIL          3

void	NDDETimeSlice( void );
void	NDDEShutdown( void );

DWORD	NDDEGetCAPS( WORD nIndex );
#define NDDE_SPEC_VERSION	    0x0001
#define	NDDE_CUR_VERSION	    (0x0000030AL)

#define NDDE_MAPPING_SUPPORT    0x0002
#define	NDDE_MAPS_YES		    (0x00000001L)
#define	NDDE_MAPS_NO		    (0x00000000L)

#define NDDE_SCHEDULE_METHOD	0x0003
#define	NDDE_TIMESLICE		    (0x00000000L)

#define NDDE_CONFIG_PARAMS      0x5701      /* Wonderware Params 0x57='W' */
#define NDDE_PARAMS_OK          (0x00000001L)
#define NDDE_PARAMS_NO          (0x00000000L)


#ifdef _WINDOWS
CONNID	NDDEAddConnection( LPSTR nodeName );
#else
CONNID	NDDEAddConnection( LPSTR nodeName, HPKTZ hPktz );
#endif

CONNID	NDDEGetNewConnection( void );

VOID	NDDEDeleteConnection( CONNID connID );

DWORD	NDDEGetConnectionStatus( CONNID connID );

BOOL	NDDERcvPacket( CONNID connID, LPVOID lpRcvBuf,
		    LPWORD lpwLen, LPWORD lpwPktStatus );
		
BOOL	NDDEXmtPacket( CONNID connID, LPVOID lpXmtBuf, WORD wPktLen );

BOOL	NDDESetConnectionConfig(    CONNID connID,
			    WORD wMaxUnAckPkts,
			    WORD wPktSize,
			    LPSTR lpszName );

BOOL	NDDEGetConnectionConfig( CONNID connID,
			    WORD FAR *lpwMaxUnAckPkts,
			    WORD FAR *lpwPktSize,
			    DWORD FAR *lptimeoutRcvConnCmd,
			    DWORD FAR *lptimeoutRcvConnRsp,
			    DWORD FAR *lptimeoutMemoryPause,
			    DWORD FAR *lptimeoutKeepAlive,
			    DWORD FAR *lptimeoutXmtStuck,
			    DWORD FAR *lptimeoutSendRsp,
			    WORD FAR *lpwMaxNoResponse,
			    WORD FAR *lpwMaxXmtErr,
			    WORD FAR *lpwMaxMemErr );


/*
    Connection status information
 */
#define NDDE_CONN_OK		((DWORD)0x00000001L)
#define NDDE_CONN_CONNECTING	((DWORD)0x00000002L)

#define NDDE_CONN_STATUS_MASK	(NDDE_CONN_OK | NDDE_CONN_CONNECTING)

#define NDDE_CALL_RCV_PKT	((DWORD)0x00000004L)

#define NDDE_READY_TO_XMT	((DWORD)0x00000008L)

/*
    Packet Status
 */
#define NDDE_PKT_HDR_OK			(0x0001)
#define NDDE_PKT_HDR_ERR		(0x0002)
#define NDDE_PKT_DATA_OK		(0x0004)
#define NDDE_PKT_DATA_ERR		(0x0008)

#ifdef _WINDOWS
typedef BOOL (*FP_Init) ( LPSTR lpszNodeName, HWND hWndNetdde );
#else
typedef BOOL (*FP_Init) ( LPSTR lpszNodeName );
#endif
typedef void (*FP_TimeSlice) ( void );
typedef void (*FP_Shutdown) ( void );
typedef DWORD (*FP_GetCAPS) ( WORD nIndex );
#ifdef _WINDOWS
typedef CONNID (*FP_AddConnection) ( LPSTR nodeName );
#else
typedef CONNID (*FP_AddConnection) ( LPSTR nodeName, HPKTZ hPktzNotify );
#endif
typedef CONNID (*FP_GetNewConnection) ( void );
typedef VOID (*FP_DeleteConnection) ( CONNID connId );
typedef DWORD (*FP_GetConnectionStatus) ( CONNID connId );
typedef BOOL (*FP_RcvPacket) ( CONNID connId, LPVOID lpRcvBuf,
		    LPWORD lpwLen, LPWORD lpwPktStatus );
typedef BOOL (*FP_XmtPacket) ( CONNID connId, LPVOID lpXmtBuf, WORD wPktLen );
typedef BOOL (*FP_SetConnectionConfig) ( CONNID connId,
			    WORD wMaxUnAckPkts,
			    WORD wPktSize,
			    LPSTR lpszName );
typedef BOOL (*FP_GetConnectionConfig) ( CONNID connId,
			    WORD FAR *lpwMaxUnAckPkts,
			    WORD FAR *lpwPktSize,
			    DWORD FAR *lptimeoutRcvConnCmd,
			    DWORD FAR *lptimeoutRcvConnRsp,
			    DWORD FAR *lptimeoutMemoryPause,
			    DWORD FAR *lptimeoutKeepAlive,
			    DWORD FAR *lptimeoutXmtStuck,
			    DWORD FAR *lptimeoutSendRsp,
			    WORD FAR *lpwMaxNoResponse,
			    WORD FAR *lpwMaxXmtErr,
			    WORD FAR *lpwMaxMemErr );

typedef struct {
    FP_Init                 Init;
    FP_GetCAPS              GetCAPS;
    FP_GetNewConnection		GetNewConnection;
    FP_AddConnection		AddConnection;
    FP_DeleteConnection		DeleteConnection;
    FP_GetConnectionStatus	GetConnectionStatus;
    FP_RcvPacket            RcvPacket;
    FP_XmtPacket            XmtPacket;
    FP_SetConnectionConfig	SetConnectionConfig;
    FP_GetConnectionConfig	GetConnectionConfig;
    FP_Shutdown             Shutdown;
    FP_TimeSlice            TimeSlice;
    char                    dllName[ 9 ];
} NIPTRS;
typedef NIPTRS FAR *LPNIPTRS;

/* returns the next available network interface that supports mapping names
    to addresses */
BOOL	GetNextMappingNetIntf( LPNIPTRS FAR *lplpNiPtrs, int FAR *lpnNi );

/* converts a string representation of netintf to pointer set */
BOOL	NameToNetIntf( LPSTR lpszName, LPNIPTRS FAR *lplpNiPtrs );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\nscommn.h ===
/*
 * NSCOMMON.H    NetDDE setup code common to NetDDE tools and NT setup code.
 *
 * Created 10/3/93  SanfordS
 */

BOOL    CreateShareDBInstance(VOID);
BOOL    CreateDefaultTrust(HKEY hKeyUserRoot);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\proflspt.h ===
BOOL FAR PASCAL MyWritePrivateProfileInt( LPSTR lpAppName, LPSTR lpKeyName,
			int nValue, LPSTR lpFileName );
BOOL FAR PASCAL WritePrivateProfileLong( LPSTR lpAppName, LPSTR lpKeyName,
			LONG lValue, LPSTR lpFileName );
LONG FAR PASCAL GetPrivateProfileLong( LPSTR lpAppName, LPSTR lpKeyName,
			LONG lDefault, LPSTR lpFileName );
BOOL FAR PASCAL TestPrivateProfile( LPCSTR lpAppName, LPCSTR lpKeyName,
			LPCSTR lpFileName );
BOOL FAR WINAPI MyWritePrivateProfileString(LPCSTR  lpszSection, LPCSTR  lpszKey,
                        LPCSTR  lpszString, LPCSTR  lpszFile );
UINT FAR WINAPI MyGetPrivateProfileInt(LPCSTR  lpszSection, LPCSTR  lpszKey,
                        INT dwDefault, LPCSTR lpszFile );
DWORD FAR WINAPI MyGetPrivateProfileString(LPCSTR lpszSection, LPCSTR lpszKey,
                        LPCSTR lpszDefault, LPSTR lpszReturnBuffer,
                        DWORD cbReturnBuffer, LPCSTR lpszFile );



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\netpkt.h ===
#ifndef H__netpkt
#define H__netpkt

#include "netbasic.h"

/*
    N E T P K T
	
	NETPKT is the data structure sent across the variety of network
	interfaces.

 */
typedef struct {
    /* checksum of pkthdr.  Set and checked in netintf only. */
    DWORD	np_cksHeader;

    /* magic number of this connection ... unused at this time */
    DWORD	np_magicNum;

    /* offset of this packet in a message.  PKTZ level only. */
    DWORD	np_pktOffsInMsg;	

    /* size of overall message.  PKTZ level only */
    DWORD	np_msgSize;

    /* id of last packet received OK. PKTZ level only.  Set when ready 
	to xmt */
    PKTID	np_lastPktOK;

    /* last packet received.  PKTZ level only.  Set when ready to xmt */
    PKTID	np_lastPktRcvd;
    
    /* size of packet excluding header. If 0, this indicates control pkt and
	np_type should be NPKT_CONTROL.  Only set/checked at pktz level */
    WORD	np_pktSize;					    

    /* status of np_lastPktRcvd, one of:
	    PS_NO_INFO
	    PS_OK
	    PS_DATA_ERR
	    PS_MEMORY_ERR
	 PKTZ level only ... set when ready to xmt
       */
    BYTE	np_lastPktStatus;

    /* either VERMETH_CRC16 or VERMETH_CKS32.  This represents how the fields
	np_cksData and np_cksHeader are calculated.  Only played with at
	netintf level */
    BYTE	np_verifyMethod;

    /* either NPKT_ROUTER, NPKT_PKTZ or NPKT_CONTROL.  Pktz level only */
    BYTE	np_type;

    /* filler for byte-alignment problems */
    BYTE	np_filler[3];
    
    /* packet ID of this packet.  PKTZ level only */
    PKTID	np_pktID;

    /* checksum of data portion of pkt.  Only set and/or checked at 
	netintf level */
    DWORD	np_cksData;
} NETPKT;
typedef NETPKT FAR *LPNETPKT;

/* packet status */
#define PS_NO_INFO		(1)
#define PS_OK			(2)
#define PS_DATA_ERR		(3)
#define PS_MEMORY_ERR		(4)
#define PS_NO_RESPONSE		(5)

/* packet type */
#define NPKT_ROUTER	(1)
#define NPKT_PKTZ	(2)
#define NPKT_CONTROL	(3)
#define NPKT_NETIF	(4)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\rerr.h ===
#ifndef H__rerr
#define H__rerr

/*
    Router Errors
 */
    /* no memory */
#define RERR_NO_MEMORY			(1)
    /* connection with the next node failed */
#define RERR_NEXT_NODE_CONN_FAILED	(2)
    /* addl info after final destination reached */
#define RERR_ADDL_INFO			(3)
    /* no addl info and final destination not reached */
#define RERR_NO_ADDL_INFO		(4)
    /* connection failed during route setup */
#define RERR_CONN_FAIL			(5)
    /* route string too long */
#define RERR_ROUTE_TOO_LONG		(6)
    /* node name in route string too long */
#define RERR_NODE_NAME_TOO_LONG		(7)
    /* connection table netintf not found */
#define RERR_CONN_NETINTF_INVALID	(8)
    /* connection table: no netintf to map name */
#define RERR_CONN_NO_MAPPING_NI		(9)
    /* likely infinite loop */
#define RERR_TOO_MANY_HOPS		(10)
    /* Looped ... NET_NET with same PKTZ in and out */
#define RERR_DIRECT_LOOP		(11)

#define RERR_MAX_ERR            (12)

/* if you add any errors here, be sure to update the error messages
    in router.c !!! */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\pktz.h ===
#ifndef H__pktz
#define H__pktz

#define NDDESignature   0x4E444445L

/* states of packetizer */
#define PKTZ_CONNECTED                  1
#define PKTZ_WAIT_PHYSICAL_CONNECT      2
#define PKTZ_WAIT_NEG_CMD               3
#define PKTZ_WAIT_NEG_RSP               4
#define PKTZ_PAUSE_FOR_MEMORY           5
#define PKTZ_CLOSE                      6

/* Timer IDs */
#define TID_NO_RCV_CONN_CMD             1
#define TID_NO_RCV_CONN_RSP             2
#define TID_MEMORY_PAUSE                3
#define TID_NO_RESPONSE                 4
#define TID_KEEPALIVE                   5
#define TID_XMT_STUCK                   6
#define TID_CLOSE_PKTZ                  7


/*
    PKTZ_NEG_CMD:  negotiate pktsize, etc.
 */
typedef struct {
    WORD nc_type;            /* PKTZ_NEG_CMD */
    WORD nc_pktSize;         /* proposed size of packets */
    WORD nc_maxUnackPkts;    /* proposed maximum unacknowledged packets */
    WORD nc_offsSrcNodeName; /* offset (from nc_strings[0]) of source node name */
    WORD nc_offsDstNodeName; /* offset (from nc_strings[0]) of destination node name */
    WORD nc_offsProtocols;   /* offset (from nc_strings[0]) of start of protocol strings */
    WORD nc_protocolBytes;   /* number of bytes of protocol strings */
    BYTE nc_strings[1];      /* start of NULL-terminated strings
                                 srcNodeName
                                 dstNodeName
                                 protocols
                              */
} NEGCMD, FAR *LPNEGCMD;

#define NEGRSP_ERRCLASS_NONE        (0x0000)
#define NEGRSP_ERRCLASS_NAME        (0x0001)

#define NEGRSP_ERRNAME_MISMATCH     (0x0001)
#define NEGRSP_ERRNAME_DUPLICATE    (0x0002)

#define NEGRSP_PROTOCOL_NONE    (0xFFFF)

typedef struct {
    WORD nr_type;           /* one of PKTZ_NEG_CMD or PKTZ_NEG_RSP or PKTZ_KEEPALIVE */
    WORD nr_pktSize;        /* size of packets agreed upon */
    WORD nr_maxUnackPkts;   /* maximum unacknowledged packets agreed on */
    WORD nr_protocolIndex;  /* protocol index.  NEGRSP_PROTOCOL_NONE indicates error */
    WORD nr_errorClass;     /* errors */
    WORD nr_errorNum;
} NEGRSP, FAR *LPNEGRSP;

typedef struct {
    WORD        pc_type;    /* PKTZ_NEG_... */
} PKTZCMD;
typedef PKTZCMD FAR *LPPKTZCMD;

/* types of PKTZ messages */
#define PKTZ_NEG_CMD    (1)
#define PKTZ_NEG_RSP    (2)
#define PKTZ_KEEPALIVE  (3)


/*
    N E T H D R

        NETHDR is the data in front of each network packet that the
        PKTZ uses to keep track of various information
 */
typedef struct nethdr {
    struct nethdr FAR *nh_prev; /* previous link */
    struct nethdr FAR *nh_next; /* next link */
    WORD  nh_noRsp;             /* count of consecutive no response errors */
    WORD  nh_xmtErr;            /* count of consecutive transmission errors */
    WORD  nh_memErr;            /* count of consecutive out-of-memory errors */
    WORD  nh_filler;            /* filler for byte-alignment problems */
    DWORD nh_timeSent;          /* timestamp of when sent (in msec) */
    HTIMER nh_hTimerRspTO;      /* hTimer for send response timeout */
} NETHDR, FAR *LPNETHDR;


/*
    PKTZ is the data associated with each instance of PKTZ
 */
typedef struct {
    CONNID    pk_connId;            /* connId: connection id for the associated network interface */
    WORD      pk_state;             /* PKTZ_... */
    BOOL      pk_fControlPktNeeded; /* fControlPktNeeded: do we need to send a control packet */
    PKTID     pk_pktidNextToSend;   /* pktidNextToSend: pktId of the next packet that we should send.  If we get a NACK regarding a packet, we should set pktidNextToSend to that pktid and retransmit it next chance we have */
    PKTID     pk_pktidNextToBuild;  /* pktidNextToBuild: pktId of the next packet that we build. */
    BYTE      pk_lastPktStatus;     /* lastPktStatus: status of last packet that we received from the other side.  This gets put into the next packet that we send out (put in np_lastPktStatus field) */
    PKTID     pk_lastPktRcvd;       /* lastPktRcvd: last packet that we received.  This gets put into np_lastPktRcvd on next pkt we xmit. */
    PKTID     pk_lastPktOk;         /* lastPktOk: last packet that we received OK.  This gets put into np_lastPktOK on the next pkt we xmit. */
    PKTID     pk_lastPktOkOther;    /* lastPktOkOther: last packet that the other side has received OK.  */
    PKTID     pk_pktidNextToRecv;   /* pktidNextToRecv: next packet number that we're expecting.  We ignore any packets except this packet number */
    DWORD     pk_pktOffsInXmtMsg;   /* pktOffsInMsg: where we should start in the next DDE Packet to xmit. If this is non-zero, it means that part of the DDE Packet at the head of the DDE Packet list (pk_ddePktListHead) is in the unacked packet list */
    LPDDEPKT  pk_lpDdePktSave;      /* lpDdePktSave: if we are in the middle of a DDE packet, this is a pointer to the beginning of the packet */
    char      pk_szDestName[ MAX_NODE_NAME+1 ];/* szDestName: name of destination node */
    char      pk_szAliasName[ MAX_NODE_NAME+1 ]; /* szAliasName: alias of destination node, e.g. 15.8.0.244 w/ destName of sidloan */
    WORD      pk_pktSize;           /* pktSize: how big are the packets for this netintf */
    WORD      pk_maxUnackPkts;      /* maxUnackPkts: how many unacknowledged packets should we xmit? */
    DWORD     pk_timeoutRcvNegCmd;  /* configuration parameters for timeouts and retry limits */
    DWORD     pk_timeoutRcvNegRsp;
    DWORD     pk_timeoutMemoryPause;
    DWORD     pk_timeoutKeepAlive;
    DWORD     pk_timeoutXmtStuck;
    DWORD     pk_timeoutSendRsp;
    WORD      pk_wMaxNoResponse;
    WORD      pk_wMaxXmtErr;
    WORD      pk_wMaxMemErr;
    BOOL      pk_fDisconnect;  /* disconnect information */
    int       pk_nDelay;
    LPNIPTRS  pk_lpNiPtrs;/* lpNiPtrs: pointer to list of functions for associated netintf */
            /* statistics */
    DWORD     pk_sent;
    DWORD     pk_rcvd;
    HTIMER    pk_hTimerKeepalive;
    HTIMER    pk_hTimerXmtStuck; /* hTimerRcvNegCmd: timer for timeout waiting for client to send us the connect cmd */
    HTIMER    pk_hTimerRcvNegCmd; /* hTimerRcvNegRsp: timer for timeout waiting for server to send us the connect cmd rsp */
    HTIMER    pk_hTimerRcvNegRsp; /* hTimerMemoyrPause: timer for waiting before retransmitting a packet that was NACKed because of memory errors */
    HTIMER    pk_hTimerMemoryPause;
    HTIMER    pk_hTimerCloseConnection; /* rt_hTimerClose: timer for closing this route */
                          /* list of saved packets that have been transmitted and are not acked. */
    LPNETHDR  pk_pktUnackHead;          /* Head is lowest numbered (least recent) packet */
    LPNETHDR  pk_pktUnackTail;          /* tail is highest numbered (most recent) packet */
    LPVOID    pk_rcvBuf;                /* receive buffer for getting info from netintf */
    LPNETPKT  pk_controlPkt;            /* buffer for control packet.  Must always have memory available to send a control packet */
    LPNETHDR  pk_pktFreeHead;           /* list of packet buffers available for transmission */
    LPNETHDR  pk_pktFreeTail;
                                        /* list of DDE packets that have yet to be xmitted */
    LPVOID    pk_ddePktHead;            /* earliest (least recent) */
    LPVOID    pk_ddePktTail;            /* latest (most recent) */
    LPVOID    pk_prevPktz;              /* list of packetizers in the system */
    LPVOID    pk_nextPktz;
    LPVOID    pk_prevPktzForNetintf;    /* list of packetizers associated with this netintf */
    LPVOID    pk_nextPktzForNetintf;
    HROUTER   pk_hRouterHead;           /* head of list of routers associated with PKTZ */
    WORD      pk_hRouterExtraHead;      /* extra info for list of hRouters */
} PKTZ;
typedef PKTZ FAR *LPPKTZ;



VOID	PktzSlice( void );
BOOL	PktzGetPktzForRouter( LPNIPTRS lpNiPtrs, LPSTR lpszNodeName,
		LPSTR lpszNodeInfo, HROUTER hRouter, WORD hRouterExtra,
		WORD FAR *lpwHopErr, BOOL bDisconnect, int nDelay,
		HPKTZ hPktzDisallowed );
HPKTZ	PktzNew( LPNIPTRS lpNiPtrs, BOOL bClient,
		LPSTR lpszNodeName, LPSTR lpszNodeInfo, CONNID connId,
		BOOL bDisconnect, int nDelay );
VOID	PktzAssociateRouter( HPKTZ hPktz, HROUTER hRouter,
		WORD hRouterExtra );
VOID	PktzDisassociateRouter( HPKTZ hPktz, HROUTER hRouter,
		WORD hRouterExtra );
HPKTZ	PktzGetNext( HPKTZ hPktz );
HPKTZ	PktzGetPrev( HPKTZ hPktz );
VOID	PktzSetNext( HPKTZ hPktz, HPKTZ hPktzNext );
VOID	PktzSetPrev( HPKTZ hPktz, HPKTZ hPktzPrev );
VOID	PktzLinkDdePktToXmit( HPKTZ hPktz, LPDDEPKT lpDdePkt );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\router.h ===
#ifndef H__router
#define H__router

/*	Calls from DDER */
BOOL	RouterGetRouterForDder( const LPSTR lpszNodeName, HDDER hDder );
VOID	RouterPacketFromDder( HROUTER hRouter, HDDER hDder, 
	    LPDDEPKT lpDdePkt );
VOID	RouterAssociateDder( HROUTER hRouter, HDDER hDder );
VOID	RouterDisassociateDder( HROUTER hRouter, HDDER hDder );

/*	Calls from PKTZ */
VOID	RouterPacketFromNet( HPKTZ hPktzFrom, LPDDEPKT lpDdePkt );
VOID	RouterConnectionComplete( HROUTER hRouter, WORD hRouterExtra,
	    HPKTZ hPktz );
VOID	RouterConnectionBroken( HROUTER hRouter, WORD hRouterExtra,
	    HPKTZ hPktz, BOOL bFromPktz );
VOID	RouterGetNextForPktz( HROUTER hRouter, WORD hRouterExtra,
	    HROUTER FAR *lphRouterNext, WORD FAR *lphRouterExtraNext );
VOID	RouterGetPrevForPktz( HROUTER hRouter, WORD hRouterExtra,
	    HROUTER FAR *lphRouterPrev, WORD FAR *lphRouterExtraPrev );
VOID	RouterSetNextForPktz( HROUTER hRouter, WORD hRouterExtra,
	    HROUTER hRouterNext, WORD hRouterExtraNext );
VOID	RouterSetPrevForPktz( HROUTER hRouter, WORD hRouterExtra,
	    HROUTER hRouterPrev, WORD hRouterExtraPrev );

#ifdef _WINDOWS
VOID	RouterCloseByName( LPSTR lpszName );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\sectype.h ===
#ifndef H__sectype
#define H__sectype

/*
    NetDDE security types
*/
#define     WW_SECURITY_TYPE        1L
#define     MS_SECURITY_TYPE        2L
#define     NT_SECURITY_TYPE        3L

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\security.h ===
/* GetRoutingInfo() looks up routing information for the specified node and
    returns whether an entry was found or not
 */
BOOL GetRoutingInfo( LPSTR lpszNodeName, LPSTR lpszRouteInfo, 
    int nMaxRouteInfo, BOOL FAR *pbDisconnect, int FAR *nDelay );

/* GetConnectionInfo() looks up connection information for 
    the specified node and returns whether an entry was found or not
 */
BOOL GetConnectionInfo( LPSTR lpszNodeName, LPSTR lpszNetIntf,
    LPSTR lpszConnInfo, int nMaxConnInfo, 
    BOOL FAR *pbDisconnect, int FAR *nDelay );

BOOL ValidateSecurityInfo( void );
BOOL ValidateRoutingInfo( void );
BOOL ValidateConnectionInfo( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\seckey.h ===
#ifndef H__seckey
#define H__seckey

VOID FAR PASCAL DdeSecKeyObtainNew( 
            LPDWORD lphSecurityKey,
            LPSTR FAR *lplpSecurityKey,
            LPDWORD lpsizeSecurityKey );

BOOL FAR PASCAL DdeSecKeyRetrieve( 
            DWORD hSecurityKey,
            LPSTR FAR *lplpSecurityKey,
            LPDWORD lpsizeSecurityKey );

VOID FAR PASCAL DdeSecKeyAge( void );

VOID FAR PASCAL DdeSecKeyRelease( DWORD hSecurityKey );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\shrtrust.h ===
#ifndef H__shrtrust
#define H__shrtrust

/*
    NetDDE will fill in the following structure and pass it to NetDDE
    Agent whenever it wants to have an app started in the user's
    context.  The reason for the sharename and modifyId is to that
    a user must explicitly permit NetDDE to start an app on behalf of
    other users.
 */

#define NDDEAGT_CMD_REV         1
#define NDDEAGT_CMD_MAGIC       0xDDE1DDE1

/*      commands        */
#define NDDEAGT_CMD_WINEXEC     0x1
#define NDDEAGT_CMD_WININIT     0x2

/*      return status   */
#define NDDEAGT_START_NO        0x0

#define NDDEAGT_INIT_NO         0x0
#define NDDEAGT_INIT_OK         0x1

typedef struct {
    DWORD       dwMagic;        // must be NDDEAGT_CMD_MAGIC
    DWORD       dwRev;          // must be 1
    DWORD       dwCmd;          // one of above NDDEAGT_CMD_*
    DWORD       qwModifyId[2];  // modify Id of the share
    UINT        fuCmdShow;      // fuCmdShow to use with WinExec()
    char        szData[1];      // sharename\0 cmdline\0
} NDDEAGTCMD;
typedef NDDEAGTCMD *PNDDEAGTCMD;

#define DDE_SHARE_KEY_MAX           512
#define TRUSTED_SHARES_KEY_MAX      512
#define TRUSTED_SHARES_KEY_SIZE     15
#define KEY_MODIFY_ID_SIZE          8

#define DDE_SHARES_KEY_A                "SOFTWARE\\Microsoft\\NetDDE\\DDE Shares"
#define TRUSTED_SHARES_KEY_A            "SOFTWARE\\Microsoft\\NetDDE\\DDE Trusted Shares"
#define DEFAULT_TRUSTED_SHARES_KEY_A    "DEFAULT\\"##TRUSTED_SHARES_KEY_A
#define TRUSTED_SHARES_KEY_PREFIX_A     "DDEDBi"
#define TRUSTED_SHARES_KEY_DEFAULT_A    "DDEDBi12345678"
#define KEY_MODIFY_ID_A                 "SerialNumber"
#define KEY_DB_INSTANCE_A               "ShareDBInstance"
#define KEY_CMDSHOW_A                   "CmdShow"
#define KEY_START_APP_A                 "StartApp"
#define KEY_INIT_ALLOWED_A              "InitAllowed"

#define DDE_SHARES_KEY_W                L"SOFTWARE\\Microsoft\\NetDDE\\DDE Shares"
#define TRUSTED_SHARES_KEY_W            L"SOFTWARE\\Microsoft\\NetDDE\\DDE Trusted Shares"
#define DEFAULT_TRUSTED_SHARES_KEY_W    L"DEFAULT\\"##TRUSTED_SHARES_KEY_W
#define TRUSTED_SHARES_KEY_PREFIX_W     L"DDEDBi"
#define TRUSTED_SHARES_KEY_DEFAULT_W    L"DDEDBi12345678"
#define KEY_MODIFY_ID_W                 L"SerialNumber"
#define KEY_DB_INSTANCE_W               L"ShareDBInstance"
#define KEY_CMDSHOW_W                   L"CmdShow"
#define KEY_START_APP_W                 L"StartApp"
#define KEY_INIT_ALLOWED_W              L"InitAllowed"

#define DDE_SHARES_KEY                  TEXT(DDE_SHARES_KEY_A)
#define TRUSTED_SHARES_KEY              TEXT(TRUSTED_SHARES_KEY_A)
#define DEFAULT_TRUSTED_SHARES_KEY      TEXT(DEFAULT_TRUSTED_SHARES_KEY_A)
#define TRUSTED_SHARES_KEY_PREFIX       TEXT(TRUSTED_SHARES_KEY_PREFIX_A)
#define TRUSTED_SHARES_KEY_DEFAULT      TEXT(TRUSTED_SHARES_KEY_DEFAULT_A)
#define KEY_MODIFY_ID                   TEXT(KEY_MODIFY_ID_A)
#define KEY_DB_INSTANCE                 TEXT(KEY_DB_INSTANCE_A)
#define KEY_CMDSHOW                     TEXT(KEY_CMDSHOW_A)
#define KEY_START_APP                   TEXT(KEY_START_APP_A)
#define KEY_INIT_ALLOWED                TEXT(KEY_INIT_ALLOWED_A)

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\tmpbuf.h ===
#ifndef H__tmpbuf
#define H__tmpbuf

extern char	tmpBuf [500];
extern char	tmpBuf2[500];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\timer.h ===
#ifndef H__timer
#define H__timer

typedef VOID (*FP_TimerCallback) (  DWORD_PTR dwUserInfo1, 
				    DWORD dwUserInfo2,
				    DWORD_PTR dwUserInfo3 );

HTIMER	TimerSet(   long timeoutPeriod,		/* msec */
		    FP_TimerCallback TimerCallback,
		    DWORD_PTR dwUserInfo1,
		    DWORD dwUserInfo2,
		    DWORD_PTR dwUserInfo3 );

BOOL	TimerDelete( HTIMER hTimer );

VOID	TimerSlice( void );

/*
    The following is a list of timeouts that the user must set up
 */

/* timeoutRcvConnCmd: how long to wait from when netintf tells us we have
    a conection to when we recv the connect command from the other side */
extern DWORD	timeoutRcvConnCmd;

/* timeoutRcvConnRsp: how long to wait from when we send the conn cmd
    to when we recv the connect command response from the other side */
extern DWORD	timeoutRcvConnRsp;

/* timeoutMemoryPause: how long to wait between sending packets that cause
    memory errors on the remote side. */
extern DWORD	timeoutMemoryPause;

/* timeoutSendRsp: how long to wait between sending a packet and expecting
    a response from the other side regarding that packet */
extern DWORD	timeoutSendRsp;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\tmpbufc.h ===
/* use only in .c file and only 1 per application */
#include "tmpbuf.h"

char	tmpBuf [500];
char	tmpBuf2[500];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\unddesi.h ===
/* UNDDESHAREINFO - contains information about a NDDE share */

struct UNDdeShareInfo_tag {
    LONG            lRevision;
    LPWSTR          lpszShareName;
    LONG            lShareType;
    LPWSTR          lpszAppTopicList;
    LONG            fSharedFlag;
    LONG            fService;
    LONG            fStartAppFlag;
    LONG            nCmdShow;
    LONG            qModifyId[2];
    LONG            cNumItems;
    LPWSTR          lpszItemList;
};
typedef struct UNDdeShareInfo_tag   UNDDESHAREINFO;
typedef struct UNDdeShareInfo_tag * PUNDDESHAREINFO;

/*
    Special commands
*/
#define NDDE_SC_TEST        0
#define NDDE_SC_REFRESH     1
#define NDDE_SC_GET_PARAM   2
#define NDDE_SC_SET_PARAM   3
#define NDDE_SC_DUMP_NETDDE 4

struct sc_param {
    LONG    pType;
    LONG    offSection;
    LONG    offKey;
    LONG    offszValue;
    UINT    pData;
};

typedef struct sc_param SC_PARAM;
typedef struct sc_param * PSC_PARAM;

#define SC_PARAM_INT    0
#define SC_PARAM_STRING 1

void    RefreshNDDECfg(void);
void    RefreshDSDMCfg(void);
void    DebugDdeIntfState();
void    DebugDderState();
void    DebugRouterState();
void    DebugPktzState();



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\wwassert.h ===
#ifndef H__assert
#define H__assert

#include "debug.h"

VOID FAR PASCAL AssertLog( LPSTR, int );

#define USES_ASSERT	static char *__assertFile__ = __FILE__;

#define assert(x) 						\
    {								\
	if( !(x) )  {						\
	    AssertLog( __assertFile__, __LINE__ );			\
	}							\
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\verify.h ===
#ifndef H__verify
#define H__verify

/*
    Verify Methods
 */
#define VERMETH_CRC16		(1)		/* CRC-16 */
#define VERMETH_CKS32		(2)		/* 32-bit checksum */

BOOL	FAR PASCAL VerifyHdr( LPNETPKT lpPacket );
BOOL	FAR PASCAL VerifyData( LPNETPKT lpPacket );
VOID	FAR PASCAL PreparePktVerify( BYTE verifyMethod, LPNETPKT lpPacket );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\userdde.h ===
#ifndef H__userdde
#define H__userdde

#include "ddepkt.h"

VOID		DebugDdePkt( LPDDEPKT lpDdePkt );

LPDDEPKT	CreateInitiatePkt(
    LPSTR   lpszToNode, 
    LPSTR   lpszToApp,
    LPSTR   lpszToTopic,
    LPSTR   lpszFromNode,
    LPSTR   lpszFromApp,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    DWORD   dwSecurityType,
    PSECURITY_QUALITY_OF_SERVICE    pqosClient,
    LPBYTE  lpPassword,
    DWORD   dwPasswordSize,
    DWORD   hSecurityKey);

LPDDEPKT	CreateAckInitiatePkt(
    LPSTR   lpszFromNode,
    LPSTR   lpszFromApp,
    LPSTR   lpszFromTopic,
    LPBYTE  lpSecurityKey,
    DWORD   dwSecurityKeySize,
    DWORD   hSecurityKey,
    BOOL    bSuccess,
    DWORD   dwReason );

LPDDEPKT	CreateExecutePkt( LPSTR lpszCommand );

LPDDEPKT	CreateTerminatePkt( void );

VOID		FillTerminatePkt( LPDDEPKT lpDdePkt );

LPDDEPKT	CreateAckExecutePkt( BOOL fAck, BOOL fBusy, BYTE bAppRtn );

LPDDEPKT	CreateGenericAckPkt( WORD wDdeMsg, LPSTR lpszItem, 
		    BOOL fAck, BOOL fBusy, BYTE bAppRtn );

LPDDEPKT	CreateRequestPkt( LPSTR lpszItem, WORD cfFormat );

LPDDEPKT	CreateUnadvisePkt( LPSTR lpszItem, WORD cfFormat );

LPDDEPKT	CreateAdvisePkt( LPSTR lpszItem, WORD cfFormat,
		    BOOL fAckReq, BOOL fNoData );

LPDDEPKT	CreateDataPkt( LPSTR lpszItem, WORD cfFormat,
		    BOOL fResponse, BOOL fAckReq, BOOL fRelease,
		    LPVOID lpData, DWORD dwSizeOfData );

LPDDEPKT	CreatePokePkt( LPSTR lpszItem, WORD cfFormat,
		    BOOL fRelease, LPVOID lpData, DWORD dwSizeOfData );

LPDDEPKT	DdePktCopy( LPDDEPKT lpDdePkt );

WORD		GetClipFormat( LPDDEPKT lpDdePkt, WORD cfFormat,
		    WORD wOffsFormat );

LPDDEPKT FAR PASCAL CreateTestPkt( int nTestNo, int nPacket, 
			int nNum, DWORD dwSize );

/* LPSTR	GetStringOffset( LPDDEPKT lpDdePkt, WORD wOffsString ); */
#define GetStringOffset( lpDdePkt, wOffsString ) \
	(((LPSTR)(lpDdePkt)) + (wOffsString))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ddeshare\ddeshare.h ===
/* $Header: "Ver=%v  %f  LastEdit=%w  Locker=%l" */
/* "Ver=1  16-Nov-92,15:47:10  LastEdit=BILL  Locker=***_NOBODY_***" */
/***********************************************************************\
*                                                                       *
*       Copyright Wonderware Software Development Corp. 1989            *
*                                                                       *
*                       ThisFileName="d:\ww\src\spccvt\spccvt.h" *
*                       LastEditDate="1992 Nov 16  15:47:11"            *
*                                                                       *
\***********************************************************************/


#ifndef H__udprot
#define H__udprot

#ifndef LINT_ARGS
#define LINT_ARGS
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\winmsg.h ===
#ifndef H__WINMSG
#define H__WINMSG

#define NETDDEMSG_GETNODENAME	"NetddeGetOurNodeName"	
#define NETDDEMSG_GETCLIENTINFO	"NetddeGetClientInfo"
#define NETDDEMSG_SESSIONENUM	"NetddeSessionEnum"
#define NETDDEMSG_CONNENUM	"NetddeConnectionEnum"
#define NETDDEMSG_SESSIONCLOSE	"NetddeSessionClose"

/*
    CMD/RSP for client info.
        fTouched must be set by NetDDE
 */
typedef struct {
    LONG	fTouched;
    LONG_PTR hWndClient;
    LONG	cClientNodeLimit;
    LONG	cClientAppLimit;
} INFOCLI_CMD;
typedef INFOCLI_CMD FAR *LPINFOCLI_CMD;

typedef struct {
    LONG	fTouched;
    LONG	lReturn;
    WORD	offsClientNode;
    WORD	offsClientApp;
} INFOCLI_RSP;
typedef INFOCLI_RSP FAR *LPINFOCLI_RSP;

typedef struct {
    LONG	fTouched;
    LONG	nLevel;
    LONG	lReturnCode;
    DWORD	cBufSize;
    DWORD	cbTotalAvailable;
    DWORD	nItems;
} SESSENUM_CMR;
typedef SESSENUM_CMR FAR *LPSESSENUM_CMR;

typedef struct {
    LONG	fTouched;
    LONG	nLevel;
    LONG	lReturnCode;
    char	clientName[ UNCLEN+1 ];
    short	pad;
    DWORD	cookie;
    DWORD	cBufSize;
    DWORD	cbTotalAvailable;
    DWORD	nItems;
} CONNENUM_CMR;
typedef CONNENUM_CMR FAR *LPCONNENUM_CMR;

typedef struct {
    LONG	fTouched;
    LONG	lReturnCode;
    char	clientName[ UNCLEN+1 ];
    short	pad;
    DWORD_PTR cookie;
} SESSCLOSE_CMR;
typedef SESSCLOSE_CMR FAR *LPSESSCLOSE_CMR;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\incs\wwdde.h ===
#ifndef H__wwdde
#define H__wwdde

#define WM_DDE_ACK_INITIATE	(WM_DDE_LAST+1)
#define WM_DDE_ACK_EXECUTE	(WM_DDE_LAST+2)
#define WM_DDE_ACK_ADVISE	(WM_DDE_LAST+3)
#define WM_DDE_ACK_REQUEST	(WM_DDE_LAST+4)
#define WM_DDE_ACK_UNADVISE	(WM_DDE_LAST+5)
#define WM_DDE_ACK_POKE		(WM_DDE_LAST+6)
#define WM_DDE_ACK_DATA		(WM_DDE_LAST+7)
#define WM_DDE_WWTEST		(WM_DDE_LAST+8)
#define WM_HANDLE_DDE_INITIATE	(WM_DDE_LAST+9)
#define WM_HANDLE_DDE_INITIATE_PKT	(WM_DDE_LAST+10)

/* don't add any more here without changing ddeq.h, since it relies on only
    16 total messages! */

#define CF_INTOUCH_SPECIAL	(15)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ddeshare\dialogs.h ===
#define IDC_SHARENAME               101
#define IDC_APPNAME                 102
#define IDC_TOPICNAME               103
#define IDC_APPNAME_NEW             104
#define IDC_TOPICNAME_NEW           105
#define IDC_APPNAME_STATIC          106
#define IDC_TOPICNAME_STATIC        107
#define IDC_F_START_APP             108
#define IDC_SACL                    109
#define IDC_DACL                    110
#define IDC_ITEM_LIST               111
#define IDC_ITEMNAME                112
#define IDC_ADD                     113
#define IDC_DELETE                  114
#define IDC_ALL_ITEMS               115
#define IDC_RESTRICT_ITEMS          116
#define IDC_WW_STYLE                117
#define IDC_OLD_STYLE               118
#define IDC_NEW_STYLE               119
#define IDC_STATIC                  120
#define IDC_MYHELP                  121
#define IDC_F_SERVICE               122

#define IDC_SHARE_LIST              201
#define IDC_ADD_SHARE               203
#define IDC_PROPERTIES              204
#define IDC_DELETE_SHARE            205
#define IDC_TRUST_SHARE             206

#define IDC_SHARE_NAME              301
#define IDC_START_APP               303
#define IDC_INIT_ENABLE             304
#define IDC_CMD_OVERRIDE            305
#define IDC_CMD_SHOW                306
#define IDC_MODIFY                  308
#define IDC_VALUE                   309
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ddeshare\ddeshare.c ===
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin

    DDESHARE.C

    DDE Share Access Applettee. Allows shares and trusted shares to be
    viewed, created, or modified.

    Revisions:
    12-92   PhilH.  Wonderware port from WFW'd DDEShare.
     3-93   IgorM.  Wonderware overhaul. Add trust share access.
                    Access all share types. New Security convictions.

   $History: End */

#define UNICODE
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "nddeapi.h"
#include "nddeapip.h"
#include "dialogs.h"
#include "debug.h"
#include "hexdump.h"
#include "tmpbuf.h"
#include "rc.h"
#include "nddeagnt.h"
#include <htmlhelp.h>

#define DDESHARE_VER    TEXT("Version 1.00.12 NT")

// Flags and typedef for the NT LanMan computer browser dialog.
// The actual function is I_SystemFocusDialog, in NTLANMAN.DLL.
#define FOCUSDLG_DOMAINS_ONLY        (1)
#define FOCUSDLG_SERVERS_ONLY        (2)
#define FOCUSDLG_SERVERS_AND_DOMAINS (3)
typedef UINT (APIENTRY *LPFNSYSFOCUS)(HWND, UINT, LPWSTR, UINT, PBOOL,
      LPWSTR, DWORD);
// Typedef for the ShellAbout function
typedef void (WINAPI *LPFNSHELLABOUT)(HWND, LPTSTR, LPTSTR, HICON);

HWND            hWndParent;
BOOL            bNetDDEdbg  = FALSE;
HICON           hIcon1, hIcon2;
HINSTANCE       hInst;
LPTSTR          lpszServer;
TCHAR           szTargetComputer[MAX_COMPUTERNAME_LENGTH+3];
TCHAR           szClassName[] = TEXT("NetDDEShareClass");
TCHAR           szAppName[20];
HANDLE          hAccel;

int WINAPI WinMain( HINSTANCE, HINSTANCE, LPSTR, int );
BOOL FAR PASCAL InitializeApplication( void );
BOOL FAR PASCAL InitializeInstance(LPSTR lpCmdLine, int nCmdShow);
LRESULT CALLBACK
DdeShareWindowProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK About( HWND hDlg, UINT message, WPARAM wParam,
                        LPARAM lParam);
INT_PTR CALLBACK TrustSharesDlg(HWND hDlg, UINT message,
                        WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DdeSharesDlg(HWND hDlg, UINT message,
                        WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AddShareDlg( HWND hDlg, UINT message,
                        WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK TrustedShareDlg( HWND hDlg, UINT message,
                        WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ServerNameDlg( HWND hDlg, UINT message,
                        WPARAM wParam, LPARAM lParam);
BOOL    RefreshShareWindow ( HWND );
BOOL    RefreshTrustedShareWindow ( HWND );
int     GetNDDEdbg(PSTR);
VOID    NDDEdbgDump(void);
VOID    ReverseNDDEdbg(WPARAM, PSTR);
BOOL ChangeMenuId(HMENU hMenu, UINT cmd, int ids, UINT cmdInsert, UINT flags);
LPTSTR IdToSz(int ids);
LPTSTR lstrcatId(LPTSTR szBuf, int id);
int MessageBoxId(HWND hwndParent, int idsText, int idsCaption, UINT mb);
extern VOID HandleError ( HWND hwnd, int ids, UINT code );

int
WINAPI
WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpszCmdLine,
    int nCmdShow)
{
    MSG         msg;
    DWORD       len;

    hInst = hInstance;
    msg.wParam = 0;

    LoadString(hInst, IDS_APPNAME, szAppName, sizeof(szAppName)/sizeof(TCHAR));

    /*  Setup the configuration file path in a permenent string (in DS).
        Strip trailing blanks and tack on a \ if needed.
    */

    DebugInit( "DDESHARE" );

    if (*lpszCmdLine == '+') {
        bNetDDEdbg = TRUE;
        lpszCmdLine++;
    }
    if( *lpszCmdLine == '\0' )  {
        len = MAX_COMPUTERNAME_LENGTH + 1;
        lstrcpy( szTargetComputer, TEXT("\\\\") );
        if( GetComputerName( &szTargetComputer[2], &len ) ) {
            lpszServer = szTargetComputer;
        } else {
            lpszServer = NULL;
        }
#ifdef UNICODE
        DPRINTF(( "%ws Targetting local computer", DDESHARE_VER ));
#else
        DPRINTF(( "%s Targetting local computer", DDESHARE_VER ));
#endif
    } else {
#ifdef UNICODE
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszCmdLine, -1,
                        szTargetComputer, MAX_COMPUTERNAME_LENGTH+3 );
        // if lpszCmdLine is >=18 chars, then all 18 chars are copied, but
        // it is NOT necessarily NULL terminated.  Make the 18th char NULL.
        szTargetComputer[MAX_COMPUTERNAME_LENGTH+2] = '\0';
#else
        // lstrcpyn always null-terminates
        lstrcpyn(szTargetComputer, lpszCmdLine, MAX_COMPUTERNAME_LENGTH+3);
#endif

        lpszServer = szTargetComputer;
#ifdef UNICODE
        DPRINTF(( "%ws Targetting \"%ws\"", DDESHARE_VER, lpszServer ));
#else
        DPRINTF(( "%s Targetting \"%s\"", DDESHARE_VER, lpszServer ));
#endif
    }
    if( !InitializeApplication() ) {
        DPRINTF(("Could not initialize application"));
        return 0;
    }

    if( !InitializeInstance(lpszCmdLine, nCmdShow) ) {
        DPRINTF(("Could not initialize instance"));
        return 0;
    }

    while (GetMessage ((LPMSG)&msg, (HWND)NULL, 0, 0)) {
        if (!TranslateAccelerator(hWndParent, hAccel, &msg)) {
            TranslateMessage ( &msg);
            DispatchMessage (&msg);
        }
    }

    return( (int) msg.wParam );
}

BOOL FAR PASCAL InitializeApplication( void )
{
    WNDCLASS  wc;

    // Register the frame class
    wc.style         = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS
                        | CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc   = DdeShareWindowProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInst;
    wc.hIcon         = LoadIcon( hInst, MAKEINTRESOURCE(IDICON_NetDDE) );
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_APPWORKSPACE+1);
    wc.lpszMenuName  = MAKEINTRESOURCE(IDMENU_DdeShareMenu);
    wc.lpszClassName = szClassName;

    if (!RegisterClass (&wc))  {
        return( FALSE );
    }

    return TRUE;
}


/*----------------------  InitializeInstance  --------------------------*/


BOOL
FAR PASCAL
InitializeInstance(
    LPSTR   lpCmdLine,
    int     nCmdShow)
{
    TCHAR   szBuf[100];
    HMENU   hDebugMenu;

    // Create the parent window

    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(DSACCEL));
    if (!hAccel) {
        return(FALSE);
    }

    hWndParent = CreateWindow (szClassName,
            szAppName,
            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
            CW_USEDEFAULT,
            0,
            300,
            150,
            NULL,
            NULL,
            hInst,
            NULL);

    if (hWndParent ) {
        lstrcpy(szBuf, szAppName);
        lstrcatId(szBuf, IDS_ON);
        lstrcat(szBuf, lpszServer);
        SetWindowText(hWndParent, szBuf);
        if( bNetDDEdbg )  {
            hDebugMenu = GetSystemMenu( hWndParent, FALSE );
            ChangeMenuId(hDebugMenu, 0, IDS_MENU1, IDM_DEBUG_DDE,    MF_APPEND | MF_STRING | MF_MENUBARBREAK );
            ChangeMenuId(hDebugMenu, 0, IDS_MENU2, IDM_LOG_INFO,     MF_APPEND | MF_STRING );
            ChangeMenuId(hDebugMenu, 0, IDS_MENU3, IDM_LOG_ERRORS,   MF_APPEND | MF_STRING );
            ChangeMenuId(hDebugMenu, 0, IDS_MENU4, IDM_LOG_DDE_PKTS, MF_APPEND | MF_STRING );
            ChangeMenuId(hDebugMenu, 0, IDS_MENU5, IDM_DEBUG_NETDDE, MF_APPEND | MF_STRING );
            CheckMenuItem( hDebugMenu, IDM_LOG_INFO,
                GetNDDEdbg("DebugInfo") ? MF_CHECKED : MF_UNCHECKED );
            CheckMenuItem( hDebugMenu, IDM_LOG_DDE_PKTS,
                GetNDDEdbg("DebugDdePkts") ? MF_CHECKED : MF_UNCHECKED );
            CheckMenuItem( hDebugMenu, IDM_LOG_ERRORS,
                GetNDDEdbg("DebugErrors") ? MF_CHECKED : MF_UNCHECKED );
            CheckMenuItem( hDebugMenu, IDM_DEBUG_DDE,
                GetNDDEdbg("DebugDDEMessages") ? MF_CHECKED : MF_UNCHECKED );
        }

        ShowWindow (hWndParent, nCmdShow);
        UpdateWindow (hWndParent);
        return TRUE;
    }

    return FALSE;
}

VOID
CenterDlg(HWND hDlg)
{
    int             screenHeight;
    int             screenWidth;
    RECT            rect;

    GetWindowRect(hDlg, &rect);

    screenHeight = GetSystemMetrics(SM_CYSCREEN);
    screenWidth  = GetSystemMetrics(SM_CXSCREEN);

    MoveWindow(hDlg,
           (screenWidth - (rect.right - rect.left)) / 2,
           (screenHeight - (rect.bottom - rect.top)) / 2,
           rect.right - rect.left,
           rect.bottom - rect.top,
           FALSE);
    SetFocus(GetDlgItem(hDlg, IDOK));
}

INT_PTR
CALLBACK
About(
    HWND        hDlg,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (message) {

    case WM_INITDIALOG:
        CenterDlg(hDlg);
        return FALSE;

    case WM_COMMAND:
        EndDialog(hDlg, TRUE);
        return TRUE;

    default:
        return FALSE;
    }
}

LRESULT CALLBACK
DdeShareWindowProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    int         x, y;
    PAINTSTRUCT ps;
    HDC         hDC;

    switch (msg)  {

    case WM_CREATE:
        START_NETDDE_SERVICES(hWnd);
        hIcon1 = LoadIcon(hInst, MAKEINTRESOURCE(IDICON_DdeShare));
        hIcon2 = LoadIcon(hInst, MAKEINTRESOURCE(IDICON_TrustShare));
        break;

    case WM_PAINT:
        hDC = BeginPaint(hWnd, &ps);
        DrawIconEx(hDC, 10, 10, hIcon1, 0, 0, 0, NULL, DI_NORMAL | DI_DEFAULTSIZE | DI_NOMIRROR);
        DrawIconEx(hDC, 62, 10, hIcon2, 0, 0, 0, NULL, DI_NORMAL | DI_DEFAULTSIZE | DI_NOMIRROR);
        EndPaint(hWnd, &ps);
        break;

    case WM_LBUTTONDBLCLK:
        x = LOWORD(lParam);
        y = HIWORD(lParam);
        if (y > 10 && y < 42) {
            if (x > 10 && x < 42) {
                PostMessage(hWnd, WM_COMMAND, IDM_DDESHARES, 0L);
            } else if (x > 62 && x < 94) {
                PostMessage(hWnd, WM_COMMAND, IDM_TRUSTSHARES, 0L);
            }
        }
        break;

    case WM_COMMAND:
        switch( LOWORD( wParam ) ) {
        case IDM_DDESHARES:
            DialogBoxParam(hInst, MAKEINTRESOURCE(DID_DDESHARES_DLG), hWnd,
                                 DdeSharesDlg, 0L );
            break;

        case IDM_TRUSTSHARES:
            DialogBoxParam(hInst, MAKEINTRESOURCE(DID_TRUSTSHARES_DLG), hWnd,
                                 TrustSharesDlg, 0L );
            break;

        case IDM_SERVERNAME:
             {
             WCHAR rgwch[MAX_COMPUTERNAME_LENGTH + 3];
             TCHAR szBuf[MAX_COMPUTERNAME_LENGTH + 32];
             BOOL  bOK = FALSE;
             BOOL  fFoundLMDlg = FALSE;
             HMODULE hMod;
             LPFNSYSFOCUS lpfn;

             rgwch[0] = TEXT('\0');

             if (hMod = LoadLibraryW(L"NTLANMAN.DLL"))
                {
                if (lpfn = (LPFNSYSFOCUS)GetProcAddress(hMod, "I_SystemFocusDialog"))
                   {
                   fFoundLMDlg = TRUE;

                   (*lpfn)(hWnd, FOCUSDLG_SERVERS_ONLY, rgwch,
                        MAX_COMPUTERNAME_LENGTH+3, &bOK, L"DdeShare.hlp",
                        HELP_DLG_SELECTCOMPUTER);

                   if (IDOK == bOK && rgwch[0])
                      {
                      #ifndef UNICODE
                      WideCharToMultiByte(CP_ACP,
                          WC_COMPOSITECHECK | WC_DISCARDNS, rgwch,
                          -1, szTargetComputer, MAX_COMPUTERNAME_LENGTH + 3, NULL, &bOK);

                      // if rgwch is >=18 chars, then all 18 chars are copied, but
                      // it is NOT necessarily NULL terminated.  Make the 18th char NULL.
                      szTargetComputer[MAX_COMPUTERNAME_LENGTH + 2] = TEXT('\0');

                      #else
                      lstrcpy(szTargetComputer, rgwch);
                      #endif

                      lpszServer = szTargetComputer;
                      }
                   // else User hit Cancel or entered an empty c-name
                   }
                // Else couldn't get the proc
                FreeLibrary(hMod);
                }
             // Else couldn't find the DLL

             // If we didn't find the fancy LanMan dialog, we still can get
             // by with our own cheesy version-- 'course, ours comes up faster, too.
             if (!fFoundLMDlg)
                {
                bOK = DialogBoxParam(hInst, MAKEINTRESOURCE(DID_SERVERNAME_DLG),
                        hWnd,  ServerNameDlg, 0L ) != FALSE;
                }

             lstrcat(lstrcatId(lstrcpy(szBuf, szAppName), IDS_ON),
                        szTargetComputer);
             SetWindowText(hWnd, szBuf);
             }
            break;

        case IDM_EXIT:
            PostMessage(hWnd, WM_CLOSE, 0, 0L);
            break;

        case IDC_MYHELP:
            HtmlHelpA(hWnd, "DdeShare.chm", HH_DISPLAY_TOPIC, 0);
            break;

        case MENU_HELP_ABOUT:
            {
            HMODULE hMod;
            LPFNSHELLABOUT lpfn;

            if (hMod = LoadLibrary(TEXT("SHELL32"))) {
               if (lpfn = (LPFNSHELLABOUT)GetProcAddress(hMod,
                      #ifdef UNICODE
                        "ShellAboutW"
                      #else
                        "ShellAboutA"
                      #endif
                      )) {
                  (*lpfn)(hWnd, szAppName, TEXT(""),
                        LoadIcon(hInst, MAKEINTRESOURCE(IDICON_NetDDE)));
               }
               FreeLibrary(hMod);
            }
            // Else couldn't load lib
            }
            break;

         default:
            return DefWindowProc( hWnd, msg, wParam, lParam );
            break;
        }
        break;

    case WM_SYSCOMMAND:
        switch( LOWORD(wParam) ) {
        case IDM_DEBUG_DDE:
            ReverseNDDEdbg(wParam, "DebugDDEMessages");
            break;
        case IDM_LOG_INFO:
            ReverseNDDEdbg(wParam, "DebugInfo");
            break;
        case IDM_LOG_ERRORS:
            ReverseNDDEdbg(wParam, "DebugErrors");
            break;
        case IDM_LOG_DDE_PKTS:
            ReverseNDDEdbg(wParam, "DebugDdePkts");
            break;
        case IDM_DEBUG_NETDDE:
            NDDEdbgDump();
            break;
        default:
            return (DefWindowProc(hWnd, msg, wParam, lParam));
            break;
        }
        break;

    case WM_DESTROY:
        PostQuitMessage (0);
        return DefWindowProc( hWnd, msg, wParam, lParam );
        break;

    default:
        return DefWindowProc( hWnd, msg, wParam, lParam );
    }

    return 0;
}

BOOL
RefreshShareWindow ( HWND hDlg )
{
    UINT    RetCode;
    DWORD   entries;
    DWORD   avail;
    HWND    hCtl;
    TCHAR * s;
    LPBYTE  lpBuf;
    BOOL    OK;

    /* probe for lenght */
    RetCode = NDdeShareEnum ( lpszServer, 0, (LPBYTE)NULL, 0, &entries, &avail );
    if (RetCode != NDDE_BUF_TOO_SMALL) {
        HandleError ( hWndParent, IDS_ERROR8, RetCode );
        return FALSE;
    }
    lpBuf = LocalAlloc(LPTR, avail);
    if (lpBuf == NULL) {
        MessageBoxId ( hWndParent, IDS_MBTEXT6, IDS_MBCAP6,
                MB_ICONEXCLAMATION | MB_OK );
        return FALSE;
    }
    RetCode = NDdeShareEnum ( lpszServer, 0, lpBuf, avail, &entries, &avail );
    HandleError ( hWndParent, IDS_ERROR9, RetCode );
    hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
    SendMessage ( hCtl, LB_RESETCONTENT, 0, 0L );
    if (RetCode == NDDE_NO_ERROR) {
        for ( s = (TCHAR *)lpBuf; *s; s += lstrlen(s) + 1 ) {
            SendMessage(hCtl, LB_ADDSTRING, 0, (LPARAM)s );
        }
        OK = TRUE;
    } else {
        SendMessage(hCtl, LB_ADDSTRING, 0, (LPARAM)IdToSz(IDS_NOSHARES));
        OK = FALSE;
    }
    LocalFree(lpBuf);
    return(OK);
}


/*
 *  Given a share name, GetNddeShareModifyId() will retrieve the modify id
 *  associated with the DSDM share
 */
BOOL
GetNddeShareModifyId(
    LPTSTR  lpszShareName,
    LPDWORD lpdwId )
{
    PNDDESHAREINFO      lpDdeI = NULL;
    DWORD               avail = 0;
    WORD                items = 0;
    UINT                nRet;
    BOOL                bRetrieved = FALSE;

     /* get the share information out of the DSDM DB */
    nRet = NDdeShareGetInfo ( lpszServer, lpszShareName, 2, (LPBYTE)NULL,
        0, &avail, &items );
    if (nRet == NDDE_BUF_TOO_SMALL) {
        lpDdeI = (PNDDESHAREINFO) LocalAlloc(LMEM_FIXED, avail);
        if (lpDdeI == NULL) {
            bRetrieved = FALSE;
        } else {
            items = 0;
            nRet = NDdeShareGetInfo ( lpszServer, lpszShareName, 2, (LPBYTE)lpDdeI,
                avail, &avail, &items );

            if( nRet == NDDE_NO_ERROR )  {
                /* compare modify ids */
                bRetrieved = TRUE;
                lpdwId[0] = lpDdeI->qModifyId[0];
                lpdwId[1] = lpDdeI->qModifyId[1];
            } else {
                bRetrieved = FALSE;
            }
            LocalFree(lpDdeI);
        }
    } else {
        bRetrieved = FALSE;
    }
    return( bRetrieved );
}

BOOL
CompareModifyIds( LPTSTR lpszShareName )
{
    DWORD       dwIdNdde[2];
    DWORD       dwIdTrusted[2];
    DWORD       dwOptions;
    UINT        RetCode;
    BOOL        bRetrievedNdde;

    bRetrievedNdde = GetNddeShareModifyId( lpszShareName, &dwIdNdde[0] );
    if (!bRetrievedNdde) {
        return(FALSE);
    }
    RetCode = NDdeGetTrustedShare( lpszServer,lpszShareName,
        &dwOptions, &dwIdTrusted[0], &dwIdTrusted[1] );
    if (RetCode != NDDE_NO_ERROR) {
        return(FALSE);
    }
    if( (dwIdNdde[0] == dwIdTrusted[0])
        && (dwIdNdde[1] == dwIdTrusted[1]) )  {
        return(TRUE);
    } else {
        return(FALSE);
    }
}






BOOL
RefreshTrustedShareWindow ( HWND hDlg )
{
    UINT    RetCode;
    DWORD   entries;
    DWORD   avail;
    TCHAR * s;
    HWND    hCtl;
    LPBYTE  lpBuf;

    /* probe for lenght */
    RetCode = NDdeTrustedShareEnum ( lpszServer, 0, (LPBYTE)NULL, 0, &entries, &avail );
    if (RetCode != NDDE_BUF_TOO_SMALL) {
        HandleError ( hWndParent, IDS_ERROR10, RetCode );
        return FALSE;
    }

    if (avail == 0) {
        SendDlgItemMessage ( hDlg, IDC_SHARE_LIST, LB_RESETCONTENT, 0, 0L );
        return TRUE;
    }

    lpBuf = LocalAlloc(LPTR, avail);
    if (lpBuf == NULL) {
        MessageBoxId ( hWndParent, IDS_MBTEXT6, IDS_MBCAP7,
                MB_ICONEXCLAMATION | MB_OK );
        return FALSE;
    }
    RetCode = NDdeTrustedShareEnum ( lpszServer, 0, lpBuf, avail,
            &entries, &avail );
    HandleError ( hWndParent, IDS_ERROR11, RetCode );
    hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
    SendMessage ( hCtl, LB_RESETCONTENT, 0, 0L );
    if (RetCode == NDDE_NO_ERROR) {
        for ( s = (TCHAR *)lpBuf; *s; s += lstrlen(s) + 1 ) {
            if (CompareModifyIds(s))
            {
                   SendMessage(hCtl, LB_ADDSTRING, 0, (LPARAM)s );
            }
        }
        LocalFree(lpBuf);
        return(TRUE);
    } else {
        LocalFree(lpBuf);
        return(FALSE);
    }
}


BOOL ChangeMenuId(
HMENU hMenu,
UINT cmd,
int ids,
UINT cmdInsert,
UINT flags)
{
    TCHAR szBuf[40];

    LoadString(hInst, ids, szBuf, sizeof(szBuf)/sizeof(TCHAR));
    return(ChangeMenu(hMenu, cmd, szBuf, cmdInsert, flags));
}


LPTSTR IdToSz(
int ids)
{
    static TCHAR szBuf[1000];

    LoadString(hInst, ids, szBuf, sizeof(szBuf)/sizeof(TCHAR));
    return(szBuf);
}


LPTSTR lstrcatId(
LPTSTR szBuf,
int id)
{
    TCHAR sz[100];

    LoadString(hInst, id, sz, sizeof(sz)/sizeof(TCHAR));
    return(lstrcat(szBuf, sz));
}


int MessageBoxId(
HWND hwndParent,
int idsText,
int idsCaption,
UINT mb)
{
    TCHAR szText[200];
    TCHAR szCap[30];

    LoadString(hInst, idsText, szText, sizeof(szText)/sizeof(TCHAR));
    LoadString(hInst, idsCaption, szCap, sizeof(szCap)/sizeof(TCHAR));
    return(MessageBox(hwndParent, szText, szCap, mb));
}

VOID HandleError (
    HWND    hwnd,
    int     ids,
    UINT    code )
{
    TCHAR szBuf[128];
    TCHAR s[128];

    if ( code == NDDE_NO_ERROR )
            return;
    LoadString(hInst, ids, s, sizeof(s)/sizeof(TCHAR));
    NDdeGetErrorString ( code, szBuf, 128 );
    MessageBox ( hwnd, szBuf, s, MB_ICONEXCLAMATION | MB_OK );
}

INT_PTR
CALLBACK
DdeSharesDlg(
    HWND        hDlg,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    int             idx;
    HWND            hCtl;
    UINT            RetCode;
    TCHAR           szBuf[MAX_NDDESHARENAME+1];

    switch (message) {

    case WM_INITDIALOG:
        CenterDlg(hDlg);
        if (RefreshShareWindow(hDlg) == FALSE) {
            PostMessage(hDlg, IDCANCEL, 0, 0L);
            return(FALSE);
        }
        SendDlgItemMessage(hDlg, IDC_SHARE_LIST, LB_SETCURSEL, 0, 0);
        break;

    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case IDC_ADD_SHARE:
            if ( DialogBoxParam(hInst,
                    MAKEINTRESOURCE(DID_DDESHARE_DLG), hDlg,
                     AddShareDlg, 0L ) )
                RefreshShareWindow(hDlg);
            break;

        case IDC_DELETE_SHARE:
            hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
            idx = (int)SendMessage( hCtl, LB_GETCURSEL, 0, 0L );
            if ( idx == LB_ERR ) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT1,
                    IDS_MBCAP1,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }

            if (SendMessage( hCtl, LB_GETTEXTLEN, idx, 0) <= MAX_NDDESHARENAME) { 
                SendMessage( hCtl, LB_GETTEXT, idx, (LPARAM)szBuf );
                RetCode = NDdeShareDel ( lpszServer, szBuf, 0 );
                if (RetCode == NDDE_NO_ERROR) {
                    RefreshShareWindow(hDlg);
                    RetCode = NDdeSetTrustedShare(lpszServer, szBuf, 0);
                    if (RetCode != NDDE_NO_ERROR) {
                        HandleError ( hDlg, IDS_ERROR12, RetCode);
                    }
                } else {
                    HandleError ( hDlg, IDS_ERROR13, RetCode);
                }
            }
            break;
        case IDC_SHARE_LIST:
            if (HIWORD(wParam) != LBN_DBLCLK) {
                break;
            }
            /*  fall through */
        case IDC_PROPERTIES:
            hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
            idx = (int)SendMessage( hCtl, LB_GETCURSEL, 0, 0L );
            if ( idx == LB_ERR ) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT2,
                    IDS_MBCAP1,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }
            if (SendMessage( hCtl, LB_GETTEXTLEN, idx, 0) <= MAX_NDDESHARENAME) { 
                SendMessage( hCtl, LB_GETTEXT, idx, (LPARAM)szBuf );
                if (DialogBoxParam( hInst, MAKEINTRESOURCE(DID_DDESHARE_DLG), hDlg,
                         AddShareDlg, (LPARAM)(LPTSTR)szBuf))
                    RefreshShareWindow(hDlg);
            }
            break;
        case IDC_TRUST_SHARE:
            hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
            idx = (int)SendMessage( hCtl, LB_GETCURSEL, 0, 0L );
            if ( idx == LB_ERR ) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT3,
                    IDS_MBCAP1,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }
            if (SendMessage( hCtl, LB_GETTEXTLEN, idx, 0) <= MAX_NDDESHARENAME) { 
                SendMessage( hCtl, LB_GETTEXT, idx, (LPARAM)szBuf );
                DialogBoxParam( hInst, MAKEINTRESOURCE(DID_TRUSTEDSHARE_DLG), hDlg,
                     TrustedShareDlg, (LPARAM)(LPTSTR)szBuf);
            }
            break;
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;
    default:
        return FALSE;
    }
    return(TRUE);
}

INT_PTR
CALLBACK
TrustSharesDlg(
    HWND        hDlg,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    int             idx;
    HWND            hCtl;
    TCHAR           szBuf[MAX_NDDESHARENAME+1];

    switch (message) {

    case WM_INITDIALOG:
        CenterDlg(hDlg);
        if (RefreshTrustedShareWindow(hDlg) == FALSE) {
            PostMessage(hDlg, IDCANCEL, 0, 0L);
            return FALSE;
        }
        SendDlgItemMessage(hDlg, IDC_SHARE_LIST, LB_SETCURSEL, 0, 0);
        break;

    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case IDC_SHARE_LIST:
            if (HIWORD(wParam) != LBN_DBLCLK) {
                break;
            }
            /*  fall through */
        case IDC_PROPERTIES:
            hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
            idx = (int)SendMessage( hCtl, LB_GETCURSEL, 0, 0L );
            if ( idx == LB_ERR ) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT4,
                    IDS_MBCAP4,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }
            if (SendMessage( hCtl, LB_GETTEXTLEN, idx, 0) <= MAX_NDDESHARENAME) { 
                SendMessage( hCtl, LB_GETTEXT, idx, (LPARAM)szBuf );
                DialogBoxParam( hInst, MAKEINTRESOURCE(DID_TRUSTEDSHARE_DLG), hDlg,
                     TrustedShareDlg, (LPARAM)(LPTSTR)szBuf);
            }
            break;
        case IDC_DELETE_SHARE:
            hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
            idx = (int)SendMessage( hCtl, LB_GETCURSEL, 0, 0L );
            if ( idx == LB_ERR ) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT5,
                    IDS_MBCAP4,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }
            if (SendMessage( hCtl, LB_GETTEXTLEN, idx, 0) <= MAX_NDDESHARENAME) { 
                SendMessage( hCtl, LB_GETTEXT, idx, (LPARAM)szBuf );
                HandleError ( hDlg, IDS_ERROR14,
                    NDdeSetTrustedShare ( lpszServer, szBuf, NDDE_TRUST_SHARE_DEL ) );
                RefreshTrustedShareWindow(hDlg);
            }
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR
CALLBACK
TrustedShareDlg(
    HWND        hDlg,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    BOOL            fError;
    TCHAR           szBuf[128];
    DWORD           dwOptions = 0;
    DWORD           dwSerial0, dwSerial1;
    UINT            RetCode;

    switch (message) {

    case WM_INITDIALOG:
        CenterDlg(hDlg);
        SetDlgItemText( hDlg, IDC_SHARE_NAME, (LPCTSTR) lParam );
        RetCode = NDdeGetTrustedShare(lpszServer, (LPTSTR)lParam, &dwOptions,
            &dwSerial0, &dwSerial1);
        if (RetCode == NDDE_NO_ERROR) {
            CheckDlgButton( hDlg, IDC_START_APP, dwOptions & NDDE_TRUST_SHARE_START );
            CheckDlgButton( hDlg, IDC_INIT_ENABLE, dwOptions & NDDE_TRUST_SHARE_INIT );
            CheckDlgButton( hDlg, IDC_CMD_OVERRIDE, dwOptions & NDDE_TRUST_CMD_SHOW );
            SetDlgItemInt( hDlg, IDC_CMD_SHOW, dwOptions & NDDE_CMD_SHOW_MASK, FALSE );
        }
        break;

    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case IDC_MODIFY:
        case IDOK:
            dwOptions = 0;
            GetDlgItemText(hDlg, IDC_SHARE_NAME, szBuf, sizeof(szBuf)/sizeof(TCHAR));
            dwOptions = GetDlgItemInt(hDlg, IDC_CMD_SHOW, &fError, FALSE);
            if (IsDlgButtonChecked(hDlg, IDC_START_APP)) {
                dwOptions |= NDDE_TRUST_SHARE_START;
            }
            if (IsDlgButtonChecked(hDlg, IDC_INIT_ENABLE)) {
                dwOptions |= NDDE_TRUST_SHARE_INIT;
            }
            if (IsDlgButtonChecked(hDlg, IDC_CMD_OVERRIDE)) {
                dwOptions |= NDDE_TRUST_CMD_SHOW;
            }

            if (dwOptions == 0) {
                MessageBoxId( hDlg,
                    IDS_MBTEXT11,
                    IDS_MBCAP11,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }

            RetCode = NDdeSetTrustedShare(lpszServer, szBuf, dwOptions);
            HandleError ( hWndParent, IDS_ERROR15, RetCode );
            if (LOWORD(wParam) == IDOK) {
                EndDialog(hDlg, TRUE);
            }
            break;

        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR
CALLBACK
ServerNameDlg(
    HWND        hDlg,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    TCHAR           szBuf[64];       // szappname + " on " + targetcompuer == 20 + 4 + 17
    DWORD           dwOptions = 0;

    switch (message) {

    case WM_INITDIALOG:
        CenterDlg(hDlg);
        break;

    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case IDOK:
            dwOptions = 0;
            GetDlgItemText(hDlg, IDC_SERVER_NAME, szBuf, MAX_COMPUTERNAME_LENGTH+1);
            if (lstrlen(szBuf) > 0) {
                lstrcpy( szTargetComputer, TEXT("\\\\") );
                lstrcpyn( &szTargetComputer[2], szBuf, sizeof(szTargetComputer)/sizeof(TCHAR) - 2);
                lpszServer = szTargetComputer;
                lstrcpy(szBuf, szAppName);
                lstrcatId(szBuf, IDS_ON);
                lstrcat(szBuf, lpszServer);
                SetWindowText(hWndParent, szBuf);
            }
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

/*
    Special commands
*/
#define NDDE_SC_TEST        0
#define NDDE_SC_REFRESH     1
#define NDDE_SC_GET_PARAM   2
#define NDDE_SC_SET_PARAM   3
#define NDDE_SC_DUMP_NETDDE 4

struct sc_param {
    LONG    pType;
    LONG    offSection;
    LONG    offKey;
    LONG    offszValue;
    UINT    pData;
};

typedef struct sc_param SC_PARAM;
typedef struct sc_param * PSC_PARAM;

#define SC_PARAM_INT    0
#define SC_PARAM_STRING 1

int
GetNDDEdbg(LPSTR pszName)
{
    BYTE        szBuf[1024];
    PSC_PARAM   pParam;
    LPSTR       lpVal;
    UINT        Value;
    UINT        Count;
    UINT        nCount;
    UINT        RetStat;

    pParam = (PSC_PARAM)szBuf;
    pParam->pType = SC_PARAM_INT;
    pParam->offSection = sizeof(SC_PARAM);
    lpVal = (LPSTR)pParam + pParam->offSection;
    Count = sizeof(SC_PARAM);
    strcpy(lpVal, "General");
    pParam->offKey = pParam->offSection + strlen("General") + 1;
    Count += pParam->offKey;
    lpVal = (LPSTR)pParam + pParam->offKey;
    strcpy(lpVal, pszName);
    Count += strlen(pszName);
    nCount = sizeof(UINT);

    RetStat = NDdeSpecialCommand(lpszServer, NDDE_SC_GET_PARAM,
            (LPBYTE)pParam, Count, (LPBYTE)&Value, &nCount);
    if (RetStat != NDDE_NO_ERROR) {
        DPRINTF(("Bad get special command: %d", RetStat));
    }
    return(Value);
}

void
SetNDDEdbg(
    LPSTR   pszName,
    UINT    inValue)
{
    BYTE        szBuf[1024];
    PSC_PARAM   pParam;
    LPSTR       lpVal;
    UINT        Size;
    UINT        Count   = 0;
    UINT        RetStat;
    UINT        Dummy = 0;


    pParam = (PSC_PARAM)szBuf;
    pParam->pType = SC_PARAM_INT;
    pParam->pData = inValue;
    pParam->offSection = sizeof(SC_PARAM);
    pParam->offszValue = 0;
    lpVal = (LPSTR)pParam + pParam->offSection;
    strcpy(lpVal, "General");
    Size = strlen("General") + 1;
    pParam->offKey = pParam->offSection + Size;
    Count += Size;
    lpVal = (LPSTR)pParam + pParam->offKey;
    strcpy(lpVal, pszName);
    Size =  strlen(pszName) + 1;
    Count += Size + sizeof(SC_PARAM);

    RetStat = NDdeSpecialCommand(lpszServer, NDDE_SC_SET_PARAM,
            (LPBYTE)pParam, Count, (LPBYTE)&Dummy, &Dummy);
    if (RetStat != NDDE_NO_ERROR) {
        DPRINTF(("Bad set special command: %d", RetStat));
    }
    return;
}

VOID
NDDEdbgDump(void)
{
    UINT    RetStat;
    UINT    Dummy = 0;

    RetStat = NDdeSpecialCommand(lpszServer, NDDE_SC_DUMP_NETDDE,
            (LPBYTE)&Dummy, Dummy, (LPBYTE)&Dummy, &Dummy);
    if (RetStat != NDDE_NO_ERROR) {
        DPRINTF(("Bad dump netdde special command: %d", RetStat));
    }
}

VOID
ReverseNDDEdbg(
    WPARAM  idMenu,
    LPSTR   pszIniName )
{
    HMENU       hMenu;
    int         DbgFlag;
    UINT    RetStat;
    UINT    Dummy = 0;


    hMenu = GetSystemMenu( hWndParent, FALSE );
    DbgFlag = GetNDDEdbg(pszIniName);
    if (DbgFlag) {
        DbgFlag = 0;
    } else {
        DbgFlag = 1;
    }
    CheckMenuItem( hMenu, (UINT)idMenu, DbgFlag ? MF_CHECKED : MF_UNCHECKED );
    SetNDDEdbg(pszIniName, DbgFlag);
    RetStat = NDdeSpecialCommand(lpszServer, NDDE_SC_REFRESH,
        (LPBYTE)&Dummy, Dummy,
        (LPBYTE)&Dummy, &Dummy);
    InvalidateRect( hWndParent, NULL, TRUE );
    UpdateWindow( hWndParent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\nddeexts\exts.h ===
DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   dtd
        ,"dtd                           - Dump NetDDE THREADDATA structs\n"
        ,""
        ,""
        ,NOARGS)

DOIT(   dpktz
        ,"dpktz <lppktz>                - Dump PKTZ structure\n"
        ,""
        ,""
        ,STDARGS1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ddeshare\dialogs.c ===
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin

    DIALOGS.C

    DDE Share Access Applettee. Create, view or modify share attributes.
    Calls SED to edit permissions associaed with share.

    Revisions:
    12-92   PhilH.  Wonderware port from WFW'd DDEShare.
     3-93   IgorM.  Wonderware complete overhaul. Add trust share access.
                    Access all share types. New Security convictions.

   $History: End */

#define UNICODE
#include <windows.h>
#include <string.h>
#include <stdlib.h>

#include "dialogs.h"
#include "nddeapi.h"
#include "nddesec.h"
#include "debug.h"
#include "rc.h"
#include <sedapi.h>
#include <htmlhelp.h>

// if turn on audit make sure it works correctly with security descriptors.
//#define INIT_AUDIT
//#define DO_AUDIT

#ifdef UNICODE

#define CharStrChr wcschr

#else

#define CharStrChr strchr

#endif

/* max (max_appname, max_nddesharename) == 256 */
#define MAX_SHARE_INFO_BUF  256

/*  arbitrary limit on share info size, use dynamic alloc for completeness  */
#define MAX_ITEM_LIST_BUF   5000

PNDDESHAREINFO          lpDdeI  = NULL;
PSECURITY_DESCRIPTOR    pSD     = NULL;
BOOL                    fSecurityDescriptorDirty = FALSE;
TCHAR                   BigBuf[2048];
TCHAR                   szAclEdit[]    = TEXT("ACLEDIT");
CHAR                    szSedDaclEdit[] = "SedDiscretionaryAclEditor";

#ifdef DO_AUDIT
CHAR                    szSedSaclEdit[] = "SedSystemAclEditor";
#endif

typedef DWORD (*SEDDESCRETIONARYACLEDITOR)(
    HWND hWnd,
    HANDLE hInst,
    LPWSTR Server,
    PSED_OBJECT_TYPE_DESCRIPTOR ObjectTypeDescriptor,
    PSED_APPLICATION_ACCESSES ApplicationAccesses,
    LPWSTR ObjectName,
    PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
    ULONG_PTR CallbackContext,
    PSECURITY_DESCRIPTOR pSD,
    BOOLEAN CouldntReadDacl,
    BOOLEAN CantWriteDacl,
    LPDWORD SEDStatusReturn,
     DWORD SEDdummy
);

extern HANDLE hInst;
extern LPTSTR lpszServer;
#define MAX_SHAREOBJECT 64
WCHAR  ShareObjectName[MAX_SHAREOBJECT];

extern int MessageBoxId(HWND hwndParent, int idsText, int idsCaption, UINT mb);
extern VOID HandleError ( HWND hwnd, int ids, UINT code );
extern BOOL ChangeMenuId(HMENU hMenu, UINT cmd, int ids, UINT cmdInsert, UINT flags);
extern LPTSTR lstrcatId(LPTSTR szBuf, int id);
BOOL WINAPI PermissionsEdit( HWND hWnd, LPTSTR pShareName, DWORD_PTR dwSD);
#ifdef DO_AUDIT
BOOL WINAPI AuditEdit( HWND hWnd, LPTSTR pShareName, DWORD dwSD);
#endif

DWORD
SedCallback(
        HWND hWnd,
        HANDLE hInstance,
        ULONG_PTR CallbackContext,
        PSECURITY_DESCRIPTOR SecDesc,
        PSECURITY_DESCRIPTOR SecDescNewObjects,
        BOOLEAN ApplyToSubContainers,
        BOOLEAN ApplyToSubObjects,
        LPDWORD StatusReturn );

#ifdef DO_AUDIT
DWORD
SedAuditCallback(
        HWND hWnd,
        HANDLE hInstance,
        ULONG  CallbackContext,
        PSECURITY_DESCRIPTOR SecDesc,
        PSECURITY_DESCRIPTOR SecDescNewObjects,
        BOOLEAN ApplyToSubContainers,
        BOOLEAN ApplyToSubObjects,
        LPDWORD StatusReturn );
#endif


BOOL
GetAppName( LPTSTR lpAppTopicList, LPTSTR lpAppName, LONG lType )
{
    LPTSTR lpBar;
    LPTSTR lpApp;

    *lpAppName = (TCHAR) 0;
    lpApp = lpAppTopicList;

    switch (lType) {
        case SHARE_TYPE_NEW:
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            break;
        case SHARE_TYPE_STATIC:
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            break;
    }
    if( lpApp == (LPTSTR) NULL ) {
        return TRUE;
    }
    lpBar = CharStrChr( lpApp, TEXT('|') );
    if( lpBar != (LPTSTR) NULL ) {
        *lpBar = (TCHAR) 0;
        lstrcpy( lpAppName, lpApp );
        *lpBar = TEXT('|');
    }

    return TRUE;
}

BOOL
GetTopicName( LPTSTR lpAppTopicList, LPTSTR lpTopicName, LONG lType )
{
    LPTSTR lpBar;
    LPTSTR lpApp;

    lpApp = lpAppTopicList;
    *lpTopicName = (TCHAR) 0;

    switch (lType) {
        case SHARE_TYPE_NEW:
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            break;
        case SHARE_TYPE_STATIC:
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            break;
    }
    if( lpApp == (LPTSTR) NULL ) {
        return TRUE;
    }
    lpBar = CharStrChr( lpApp, TEXT('|') );
    if( lpBar != (LPTSTR) NULL ) {
        lpBar++;
        lstrcpy( lpTopicName, lpBar );
    }

    return TRUE;
}

/*
    Retrieve current dialog box fields into lpDdeI structure
*/
LONG
GetShareInfo(HWND    hDlg)
{
    HWND        hWndLB;
    LONG        lSize = sizeof(NDDESHAREINFO);
    LONG        lChars, lTmp;
    LONG        lRtn;
    PTCHAR      ptTmp;
    int         i, n = 0;
    BOOL        bFirst;
    LPTSTR      lpTmpList;
    TCHAR       dBuf[MAX_SHARE_INFO_BUF];

    lpDdeI->lpszShareName =
        (LPTSTR)((BYTE*)lpDdeI + sizeof( NDDESHAREINFO ));

    SendDlgItemMessage( hDlg, IDC_SHARENAME, WM_GETTEXT,
                MAX_NDDESHARENAME, (LPARAM)dBuf );
    if (lstrlen(dBuf) == 0) {
        SendDlgItemMessage( hDlg, IDC_APPNAME, WM_GETTEXT,
                    MAX_NDDESHARENAME, (LPARAM)dBuf );
        if (lstrlen(dBuf) == 0) {   /* no app name .. no share .. no share info */
            return(0);
        }
        lstrcpy( lpDdeI->lpszShareName, dBuf );
        lstrcat( lpDdeI->lpszShareName, TEXT("|") );

        SendDlgItemMessage( hDlg, IDC_TOPICNAME, WM_GETTEXT,
                    MAX_NDDESHARENAME, (LPARAM)dBuf );
        lstrcat( lpDdeI->lpszShareName, dBuf );
        lSize += (lstrlen( lpDdeI->lpszShareName ) + 1) * sizeof(TCHAR);
    } else {
        lstrcpy( lpDdeI->lpszShareName, dBuf );
        lSize += (lstrlen( lpDdeI->lpszShareName ) + 1) * sizeof(TCHAR);
    }

    lpDdeI->lpszAppTopicList =
        (LPTSTR)(lpDdeI->lpszShareName +
                       lstrlen( lpDdeI->lpszShareName ) + 1);

    lChars = (long)SendDlgItemMessage( hDlg, IDC_APPNAME, WM_GETTEXT,
                   MAX_APPNAME, (LPARAM)dBuf );

    if (lChars > 0) {
        lstrcpy( lpDdeI->lpszAppTopicList, dBuf );
        lstrcat( lpDdeI->lpszAppTopicList, TEXT("|") );
        lChars++;

        lChars += (long)SendDlgItemMessage( hDlg, IDC_TOPICNAME, WM_GETTEXT,
                    MAX_APPNAME, (LPARAM)dBuf );
        lstrcat( lpDdeI->lpszAppTopicList, dBuf );
        lpDdeI->lShareType |= SHARE_TYPE_OLD;
    } else {
        lpDdeI->lShareType &= ~SHARE_TYPE_OLD;
    }
    lpDdeI->lpszAppTopicList[lChars++] = (TCHAR) 0;

    lTmp = (LONG)SendDlgItemMessage( hDlg, IDC_APPNAME_NEW, WM_GETTEXT,
                MAX_APPNAME, (LPARAM)dBuf );
    if (lTmp > 0) {
        ptTmp = &lpDdeI->lpszAppTopicList[lChars];
        lChars +=lTmp;
        lstrcpy( ptTmp, dBuf );
        lstrcat( ptTmp, TEXT("|") );
        lChars++;

        lChars += (LONG)SendDlgItemMessage( hDlg, IDC_TOPICNAME_NEW, WM_GETTEXT,
                    MAX_APPNAME, (LPARAM)dBuf );
        lstrcat( ptTmp, dBuf );
        lpDdeI->lShareType |= SHARE_TYPE_NEW;
    } else {
        lpDdeI->lShareType &= ~SHARE_TYPE_NEW;
    }
    lpDdeI->lpszAppTopicList[lChars++] = (TCHAR) 0;
    lTmp = (LONG)SendDlgItemMessage( hDlg, IDC_APPNAME_STATIC, WM_GETTEXT,
                MAX_APPNAME, (LPARAM)dBuf );

    if (lTmp > 0) {
        ptTmp = &lpDdeI->lpszAppTopicList[lChars];
        lChars +=lTmp;
        lstrcpy( ptTmp, dBuf );
        lstrcat( ptTmp, TEXT("|") );
        lChars++;

        lChars += (LONG)SendDlgItemMessage( hDlg, IDC_TOPICNAME_STATIC, WM_GETTEXT,
                    MAX_APPNAME, (LPARAM)dBuf );
        lstrcat( ptTmp, dBuf );
        lpDdeI->lShareType |= SHARE_TYPE_STATIC;
    } else {
        lpDdeI->lShareType &= ~SHARE_TYPE_STATIC;
    }
    lpDdeI->lpszAppTopicList[lChars++] = (TCHAR) 0;

    /*  add the final NULL */
    lpDdeI->lpszAppTopicList[lChars++] = (TCHAR) 0;
    lSize += sizeof(TCHAR) * lChars;

    /* Form the item list. */
    lpTmpList = (LPTSTR)LocalAlloc( LPTR, MAX_ITEM_LIST_BUF );
    lChars    = 0;
    n         = 0;
    hWndLB = GetDlgItem( hDlg, IDC_ITEM_LIST );
    if( !IsDlgButtonChecked( hDlg, IDC_ALL_ITEMS ) ) {
        bFirst = TRUE;
        lRtn = (LONG)SendMessage( hWndLB, LB_GETCOUNT, 0, 0L );
        if( lRtn != LB_ERR ) {
            n = (int) lRtn;
            for( i=0; i<n; i++ ) {

                if ( SendMessage( hWndLB, LB_GETTEXTLEN, i, 0 ) < (sizeof(dBuf)/sizeof(TCHAR)) )
                    lRtn = (LONG)SendMessage( hWndLB, LB_GETTEXT, i, (LPARAM)dBuf );
                else
                    lRtn = LB_ERR;
                if( !bFirst ) {
                    lChars++;
                } else {
                    bFirst = FALSE;
                }
                if( lRtn != LB_ERR ) {
                    lstrcpy( &lpTmpList[lChars], dBuf );
                    lChars += lstrlen( dBuf );
                }
            }
        }
    }

    lpTmpList[ lChars++ ] = (TCHAR) 0;
    lpTmpList[ lChars++ ] = (TCHAR) 0;
    lSize += sizeof(TCHAR) * lChars;
    lpDdeI->cNumItems = n;
    lpDdeI->lpszItemList = lpTmpList;

    if( IsDlgButtonChecked( hDlg, IDC_F_START_APP ) == 0 ) {
        lpDdeI->fStartAppFlag = 0;
    } else {
        lpDdeI->fStartAppFlag = 1;
    }

    if( IsDlgButtonChecked( hDlg, IDC_F_SERVICE ) == 0 ) {
        lpDdeI->fService = 0;
    } else {
        lpDdeI->fService = 1;
    }
    return(lSize);
}

/*
    Get Share SD from DSDM
*/
BOOL
GetShareSD(
    HWND    hDlg,
    LPTSTR  lpShareName )
{
    LONG    ret;
    DWORD   cbRequired;

    ret = NDdeGetShareSecurity(
        lpszServer,
        lpShareName,
        OWNER_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION,
        NULL,                       // dummy address  .. NULLs taboo
        0,                          // size of buffer for security descriptor
        &cbRequired);               // address of required size of buffer

    if ( ret != NDDE_BUF_TOO_SMALL ) {
        HandleError ( hDlg, IDS_ERROR1, ret );
        return FALSE;
    }

    if( pSD != NULL ) {
        LocalFree( pSD );
    }
    pSD = LocalAlloc(LMEM_ZEROINIT, cbRequired);
    if (pSD == NULL) {
        MessageBoxId ( hDlg,
            IDS_MBTEXT8, IDS_MBCAP1, MB_ICONEXCLAMATION | MB_OK );
        return(FALSE);
    }

    ret = NDdeGetShareSecurity(
        lpszServer,
        lpShareName,
        OWNER_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION,
        pSD,                        // address of security descriptor
        cbRequired,                 // size of buffer for security descriptor
        &cbRequired);               // address of required size of buffer

    if ( ret != NDDE_NO_ERROR ) {
        HandleError ( hDlg, IDS_ERROR2, ret );
        LocalFree(pSD);
        return FALSE;
    }
    return(TRUE);
}

/*
    Add/View/Modify DDE Share Dialog Proc
*/
INT_PTR
CALLBACK
AddShareDlg(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT        ret;
    int         n = 0;
    LONG        lSize;
    TCHAR       *dBuf;
    TCHAR       dBuf2[MAX_SHARE_INFO_BUF];
    HWND        hWndEB, hWndLB;
    LONG        lRtn, lIdx;
    BOOL        bNameInUse;
    int         i;
    BOOL        OK;
    TCHAR       szItemName[512];

static BOOL    fSDEditCalled       = FALSE;
static BOOL    fAddShareEntry      = FALSE;
static BOOL    fPropertiesCalled   = FALSE;



    switch (message) {
    case WM_INITDIALOG:            /* message: initialize dialog box */
        SendDlgItemMessage ( hDlg, IDC_SHARENAME, EM_LIMITTEXT,
                MAX_NDDESHARENAME, 0L );
        SendDlgItemMessage ( hDlg, IDC_APPNAME, EM_LIMITTEXT,
                MAX_APPNAME, 0L );
        SendDlgItemMessage ( hDlg, IDC_APPNAME_NEW, EM_LIMITTEXT,
                MAX_APPNAME, 0L );
        SendDlgItemMessage ( hDlg, IDC_APPNAME_STATIC, EM_LIMITTEXT,
                MAX_APPNAME, 0L );

        fSDEditCalled = FALSE;
        fSecurityDescriptorDirty = FALSE;

        if (lParam) {
            fPropertiesCalled = TRUE;
            fAddShareEntry    = FALSE;
        } else {
            fPropertiesCalled = FALSE;
            fAddShareEntry    = TRUE;
        }

        lpDdeI = (PNDDESHAREINFO)&BigBuf;
        lpDdeI->lpszShareName =
            (LPTSTR)((BYTE*)lpDdeI + sizeof( NDDESHAREINFO ));
        lpDdeI->lpszShareName[0] = TEXT('\0');
        lpDdeI->lRevision        = 1L;
        lpDdeI->lShareType       = 1L;
        lpDdeI->lpszAppTopicList = NULL;
        lpDdeI->fSharedFlag      = 1;
        lpDdeI->fService         = 0;
        lpDdeI->fStartAppFlag    = 0;
        lpDdeI->qModifyId[0]     = 0;
        lpDdeI->qModifyId[1]     = 0;
        lpDdeI->nCmdShow         = SW_SHOWMINNOACTIVE;
        lpDdeI->cNumItems        = 0;
        lpDdeI->lpszItemList     = NULL;

        EnableWindow( GetDlgItem( hDlg, IDC_ADD ),       FALSE );
        EnableWindow( GetDlgItem( hDlg, IDC_DELETE ),    FALSE );
        EnableWindow( GetDlgItem( hDlg, IDC_ITEM_LIST ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDC_ITEMNAME ),  FALSE );
        CheckRadioButton( hDlg, IDC_ALL_ITEMS, IDC_RESTRICT_ITEMS,
                                IDC_ALL_ITEMS );

        if ( fPropertiesCalled ) {
            UINT ret1;
            DWORD avail;
            WORD items;

            items = 0;
            ret1 = NDdeShareGetInfo (
                lpszServer,
                (LPTSTR)lParam,
                2,
                (LPBYTE)&BigBuf,
                2048 * sizeof(TCHAR),
                &avail,
                &items);

            if ( ret1 != NDDE_NO_ERROR ) {
                    HandleError ( hDlg, IDS_ERROR3, ret1 );
                    EndDialog ( hDlg, FALSE );
                    return TRUE;
            }

            SetDlgItemText ( hDlg, IDC_SHARENAME, lpDdeI->lpszShareName );
            EnableWindow( GetDlgItem( hDlg, IDC_SHARENAME ), FALSE );

            if (dBuf = LocalAlloc( LPTR, MAX_ITEM_LIST_BUF )) {

                if (lpDdeI->lShareType & SHARE_TYPE_OLD) {
                    GetAppName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_OLD );
                    SetDlgItemText ( hDlg, IDC_APPNAME, dBuf );
                    GetTopicName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_OLD );
                    SetDlgItemText ( hDlg, IDC_TOPICNAME, dBuf );
                }

                if (lpDdeI->lShareType & SHARE_TYPE_NEW) {
                    GetAppName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_NEW );
                    SetDlgItemText ( hDlg, IDC_APPNAME_NEW, dBuf );
                    GetTopicName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_NEW );
                    SetDlgItemText ( hDlg, IDC_TOPICNAME_NEW, dBuf );
                }

                if (lpDdeI->lShareType & SHARE_TYPE_STATIC) {
                    GetAppName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_STATIC );
                    SetDlgItemText ( hDlg, IDC_APPNAME_STATIC, dBuf );
                    GetTopicName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_STATIC );
                    SetDlgItemText ( hDlg, IDC_TOPICNAME_STATIC, dBuf );
                }

                CheckDlgButton( hDlg, IDC_F_START_APP, lpDdeI->fStartAppFlag );
                CheckDlgButton( hDlg, IDC_F_SERVICE, lpDdeI->fService );

                {
                    int     p;
                    LPTSTR  lpszItem;
                    BOOL    bFirst = TRUE;

                    p = lpDdeI->cNumItems;
                    if( p > 0 ) {
                        EnableWindow( GetDlgItem( hDlg, IDC_ADD ),       TRUE );
                        EnableWindow( GetDlgItem( hDlg, IDC_DELETE ),    TRUE );
                        EnableWindow( GetDlgItem( hDlg, IDC_ITEM_LIST ), TRUE );
                            EnableWindow( GetDlgItem( hDlg, IDC_ITEMNAME ),  TRUE );
                        CheckRadioButton( hDlg, IDC_ALL_ITEMS, IDC_RESTRICT_ITEMS,
                                                IDC_RESTRICT_ITEMS );
                    }
                    lpszItem = lpDdeI->lpszItemList;
                    dBuf[0] = TEXT('\0');
                    hWndLB  = GetDlgItem( hDlg, IDC_ITEM_LIST );
                    while( p-- && (*lpszItem != TEXT('\0')) )  {
                        lRtn = (LONG)SendMessage( hWndLB, LB_ADDSTRING, 0,
                            (LPARAM)(LPTSTR)lpszItem);
                        if( bFirst )  {
                            bFirst = FALSE;
                        } else {
                            lstrcat( dBuf, TEXT(",") );
                        }
                        lstrcat( dBuf, lpszItem );
                        lpszItem += lstrlen(lpszItem) + 1;
                    }
                }
                LocalFree( dBuf );
            }
        }
        return (TRUE);

    case WM_COMMAND:
        hWndEB = GetDlgItem( hDlg, IDC_ITEMNAME );
        hWndLB = GetDlgItem( hDlg, IDC_ITEM_LIST );
        switch ( LOWORD(wParam) ) {
        case IDC_DACL:
            if (!fSDEditCalled ) {

                if (!fPropertiesCalled)
                {
                    lSize = GetShareInfo(hDlg);
                    if (lSize == 0) {
                        MessageBoxId ( hDlg, IDS_MBTEXT9, IDS_MBCAP1,
                            MB_ICONEXCLAMATION | MB_OK );
                        return(TRUE);
                    }

                   
                    ret = NDdeShareAdd (
                        lpszServer,
                        2,
                        NULL,               /* create a default DDE Share SD */
                        (LPBYTE)lpDdeI,
                        lSize );
                    HandleError ( hDlg, IDS_ERROR4, ret );

                    if (ret != NDDE_NO_ERROR) {
                        return(TRUE);
                    }
 
                    fPropertiesCalled = TRUE;
                }

                OK = GetShareSD(hDlg, lpDdeI->lpszShareName);
                if (!OK) {
                    return(TRUE);
                }
            }

            PermissionsEdit( hDlg, lpDdeI->lpszShareName, (DWORD_PTR)lpDdeI );
            fSDEditCalled = TRUE;
            break;
#ifdef DO_AUDIT
        case IDC_SACL:
            AuditEdit( hDlg, lpDdeI->lpszShareName, (DWORD)lpDdeI );
            break;
#endif
        case IDC_ADD:
            GetDlgItemText( hDlg, IDC_ITEMNAME, dBuf2, sizeof(dBuf2)/sizeof(TCHAR) );
            if( dBuf2[0] != TEXT('\0') ) {
                /*  Check whether item name is already in the list. */
                lRtn = (LONG)SendMessage( hWndLB, LB_GETCOUNT, 0, 0L );
                if( lRtn != LB_ERR ) {
                    n = (int) lRtn;
                    bNameInUse = FALSE;
                    for( i=0; !bNameInUse && (i<n); i++ ) {
                        lRtn = (LONG)SendMessage( hWndLB, LB_GETTEXT, i,
                            (LPARAM)(LPTSTR)szItemName );
                        if( lRtn != LB_ERR ) {
                            if( lstrcmpi( szItemName, dBuf2 ) == 0 ) {
                                bNameInUse = TRUE;
                            }

                        }
                    }
                }

                if( !bNameInUse ) {
                    /* Insert in sorted order. */
                    lRtn = (LONG)SendMessage(hWndLB, LB_ADDSTRING, 0,
                                        (LPARAM)(LPTSTR)dBuf2);
                    if( lRtn != LB_ERR ) {
                        lRtn = (LONG)SendMessage( hWndLB, LB_SETCURSEL,
                                                (WORD)lRtn, 0L );
                    }
                    if( lRtn != LB_ERR ) {
                        EnableWindow( GetDlgItem( hDlg, IDC_DELETE ),TRUE);
                    }
                }
            }
            SendMessage( hWndEB, EM_SETSEL, 0, (LPARAM) -1 );
            SetFocus( hWndEB );
            break;
        case IDC_DELETE:
            lIdx   = (LONG)SendMessage( hWndLB, LB_GETCURSEL, 0, 0L );
            if( lIdx != LB_ERR ) {
                lRtn = (LONG)SendMessage( hWndLB, LB_DELETESTRING, (WORD)lIdx, 0L);
                if( lRtn != LB_ERR ) {
                    lRtn = (LONG)SendMessage( hWndLB, LB_GETCOUNT, 0, 0L );
                    if( lRtn != LB_ERR ) {
                        if( (int)lRtn > 0 ) {
                            EnableWindow(GetDlgItem(hDlg, IDC_DELETE ),TRUE);
                        } else {
                            EnableWindow(GetDlgItem(hDlg, IDC_DELETE ),FALSE);
                        }
                    }
                }
            }
            break;
        case IDC_ALL_ITEMS:
            SendMessage( hWndLB, LB_RESETCONTENT, 0, 0 );
            EnableWindow( GetDlgItem( hDlg, IDC_ADD ),    FALSE );
            EnableWindow( GetDlgItem( hDlg, IDC_DELETE ), FALSE );
            EnableWindow( hWndLB, FALSE );
            EnableWindow( hWndEB, FALSE );
            /* Zap item list. */
            break;
        case IDC_RESTRICT_ITEMS:
            /* Load Item listbox with current items. */
            EnableWindow( GetDlgItem( hDlg, IDC_ADD ),    TRUE );
            EnableWindow( GetDlgItem( hDlg, IDC_DELETE ), TRUE );
            EnableWindow( hWndLB, TRUE );
            EnableWindow( hWndEB, TRUE );

            lRtn = (LONG)SendMessage( hWndLB, LB_GETCOUNT, 0, 0L );

            if( lRtn != LB_ERR ) {

                if (dBuf = LocalAlloc( LPTR, MAX_ITEM_LIST_BUF ) ) {
                    n = (int) lRtn;
                    if( n == 0 ) {

                        {
                            int     p;
                            LPTSTR  lpszItem;
                            BOOL    bFirst = TRUE;

                            p = lpDdeI->cNumItems;
                            lpszItem = lpDdeI->lpszItemList;
                            dBuf[0] = TEXT('\0');
                            while( p-- && (*lpszItem != TEXT('\0')) )  {
                                lRtn = (LONG)SendMessage( hWndLB, LB_ADDSTRING, 0,
                                    (LPARAM)(LPTSTR)lpszItem);
                                if( bFirst )  {
                                    bFirst = FALSE;
                                } else {
                                    lstrcat( dBuf, TEXT(",") );
                                }
                                lstrcat( dBuf, lpszItem );
                                lpszItem += lstrlen(lpszItem) + 1;
                            }
                        }
                    }
                    LocalFree(dBuf);
                }
            }
            break;
        case IDOK:
            lSize = GetShareInfo(hDlg);
            if (lSize == 0) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT10,
                    IDS_MBCAP1,
                    MB_ICONEXCLAMATION | MB_OK );
                return(TRUE);
            }
            if ( !fPropertiesCalled ) {
                ret = NDdeShareAdd (
                        lpszServer,
                        2,
                        NULL,
                        (LPBYTE)lpDdeI,
                        lSize );
                HandleError ( hDlg, IDS_ERROR5, ret );
            } else {
                ret = NDdeShareSetInfo (
                        lpszServer,
                        lpDdeI->lpszShareName,
                        2,
                        (LPBYTE)lpDdeI,
                        lSize, 0 );
                HandleError ( hDlg, IDS_ERROR6, ret );

                if (fSecurityDescriptorDirty)
                {
                    ret = NDdeSetShareSecurity(
                        lpszServer,
                        lpDdeI->lpszShareName,
                        OWNER_SECURITY_INFORMATION |
                        DACL_SECURITY_INFORMATION,  // type of information to set
                        pSD                         // address of security descriptor
                        )                ;
                    HandleError ( hDlg, IDS_ERROR7, ret );
                }
            }

            if ( ret == NDDE_NO_ERROR ) {
                if( pSD ) {
                    LocalFree( pSD );
                    pSD = NULL;
                }
                EndDialog(hDlg, TRUE);
            }
            return (TRUE);

        case IDC_MYHELP:
            HtmlHelpA(hDlg, "DdeShare.chm", HELP_CONTEXT, HELP_DLG_PROPERTIES);
            break;

        case IDCANCEL:
            if ( fAddShareEntry && fPropertiesCalled) {
                NDdeShareDel(lpszServer, lpDdeI->lpszShareName, 0);
            }
            if( pSD ) {
                LocalFree( pSD );
                pSD = NULL;
            }
            EndDialog(hDlg, FALSE );
            return (TRUE);
        }
        break;
    }

    return FALSE;                     /* Didn't process a message    */
}

#define cPerms 19
#define MAX_PERMNAME_LENGTH 32
#define MAX_SPECIAL_LENGTH 64
static WCHAR awchPerms[cPerms * MAX_PERMNAME_LENGTH];

static SED_APPLICATION_ACCESS KeyPerms[cPerms] =
   {
   SED_DESC_TYPE_RESOURCE,0,                       0,
         awchPerms + MAX_PERMNAME_LENGTH * 0,
   SED_DESC_TYPE_RESOURCE, NDDE_GUI_READ,          0,
         awchPerms + MAX_PERMNAME_LENGTH * 1,
   SED_DESC_TYPE_RESOURCE, NDDE_GUI_READ_LINK,     0,
         awchPerms + MAX_PERMNAME_LENGTH * 2,
   SED_DESC_TYPE_RESOURCE, NDDE_GUI_CHANGE,        0,
         awchPerms + MAX_PERMNAME_LENGTH * 3,
   SED_DESC_TYPE_RESOURCE, GENERIC_ALL,  0,
         awchPerms + MAX_PERMNAME_LENGTH * 4,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_READ, 0,
         awchPerms + MAX_PERMNAME_LENGTH * 5,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_WRITE,0,
         awchPerms + MAX_PERMNAME_LENGTH * 6,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_INITIATE_STATIC, 0,
         awchPerms + MAX_PERMNAME_LENGTH * 7,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_INITIATE_LINK,   0,
         awchPerms + MAX_PERMNAME_LENGTH * 8,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_REQUEST,         0,
         awchPerms + MAX_PERMNAME_LENGTH * 9,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_ADVISE,          0,
         awchPerms + MAX_PERMNAME_LENGTH * 10,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_POKE,            0,
         awchPerms + MAX_PERMNAME_LENGTH * 11,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_EXECUTE,         0,
         awchPerms + MAX_PERMNAME_LENGTH * 12,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_ADD_ITEMS,       0,
         awchPerms + MAX_PERMNAME_LENGTH * 13,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_LIST_ITEMS,      0,
         awchPerms + MAX_PERMNAME_LENGTH * 14,
   SED_DESC_TYPE_RESOURCE_SPECIAL,DELETE,                     0,
         awchPerms + MAX_PERMNAME_LENGTH * 15,
   SED_DESC_TYPE_RESOURCE_SPECIAL,READ_CONTROL,               0,
         awchPerms + MAX_PERMNAME_LENGTH * 16,
   SED_DESC_TYPE_RESOURCE_SPECIAL,WRITE_DAC,                  0,
         awchPerms + MAX_PERMNAME_LENGTH * 17,
   SED_DESC_TYPE_RESOURCE_SPECIAL,WRITE_OWNER,                0,
         awchPerms + MAX_PERMNAME_LENGTH * 18

   };


VOID wcscpyId(
LPWSTR szTo,
int ids)
{
    WCHAR szBuf[100];

    LoadStringW(hInst, ids, szBuf, sizeof(szBuf)/sizeof(WCHAR));
    wcscpy(szTo, szBuf);
}


BOOL WINAPI
PermissionsEdit(
    HWND    hWnd,
    LPTSTR  pShareName,
    DWORD_PTR dwSD )
{
    SEDDESCRETIONARYACLEDITOR   lpfnSDAE;
    SED_OBJECT_TYPE_DESCRIPTOR  ObjectTypeDescriptor;
    SED_APPLICATION_ACCESSES    ApplicationAccesses;
    PSECURITY_DESCRIPTOR        plSD = NULL;
    GENERIC_MAPPING             GmDdeShare;
    SED_HELP_INFO               HelpInfo;
    HANDLE                      hLibrary;
    DWORD                       Status;
    DWORD                       dwRtn;
    WCHAR                       wShareName[MAX_NDDESHARENAME+1];
    WCHAR                       awchSpecial[MAX_SPECIAL_LENGTH];
    unsigned                    i;

#ifdef UNICODE
    lstrcpyn( wShareName, pShareName, MAX_NDDESHARENAME+1 );
#else
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pShareName, -1,
                    wShareName, MAX_NDDESHARENAME+1 );
#endif

    if( wShareName[0] == L'\0' ) {
        wcscpyId( wShareName, IDS_UNNAMED );
    }
    hLibrary = LoadLibrary( szAclEdit );
    if( hLibrary == (HANDLE) NULL ) {
#ifdef UNICODE
        DPRINTF(("Could not load library (%ws) = %d", szAclEdit, GetLastError()));
#else
        DPRINTF(("Could not load library (%s) = %d", szAclEdit, GetLastError()));
#endif
        return FALSE;
    }

    lpfnSDAE = (SEDDESCRETIONARYACLEDITOR)
                    GetProcAddress( hLibrary, szSedDaclEdit );
    if( lpfnSDAE == NULL ) {
#ifdef UNICODE
        DPRINTF(("Could not find function (%s) in library (%ws) = %d",
            szSedDaclEdit, szAclEdit, GetLastError() ));
#else
        DPRINTF(("Could not find function (%s) in library (%s) = %d",
            szSedDaclEdit, szAclEdit, GetLastError() ));
#endif
        FreeLibrary( hLibrary );
        return FALSE;
    }

    plSD = pSD;

    HelpInfo.pszHelpFileName = L"ddeshare.hlp";
    HelpInfo.aulHelpContext[HC_MAIN_DLG]                    = HELP_DLG_DDESHARENAMEPERMISSOINS;
    HelpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG]          = 0;
    HelpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0;
    HelpInfo.aulHelpContext[HC_ADD_USER_DLG]                = 0;

    GmDdeShare.GenericRead    = NDDE_GUI_READ;
    GmDdeShare.GenericWrite   = NDDE_GUI_CHANGE;
    GmDdeShare.GenericExecute = NDDE_GUI_READ_LINK;
    GmDdeShare.GenericAll     = NDDE_GUI_FULL_CONTROL;

    LoadString(hInst, IDS_SHAREOBJECT, ShareObjectName, MAX_SHAREOBJECT);

    ObjectTypeDescriptor.Revision                    = SED_REVISION1;
    ObjectTypeDescriptor.IsContainer                 = TRUE;
    ObjectTypeDescriptor.AllowNewObjectPerms         = FALSE;
    ObjectTypeDescriptor.MapSpecificPermsToGeneric   = FALSE;
    ObjectTypeDescriptor.GenericMapping              = &GmDdeShare;
    ObjectTypeDescriptor.GenericMappingNewObjects    = &GmDdeShare;
    ObjectTypeDescriptor.ObjectTypeName              = ShareObjectName;
    ObjectTypeDescriptor.HelpInfo                    = &HelpInfo;
    ObjectTypeDescriptor.ApplyToSubContainerTitle    = NULL;
//  ObjectTypeDescriptor.ApplyToSubContainerHelpText = NULL;
    ObjectTypeDescriptor.ApplyToSubContainerConfirmation = NULL;
    ObjectTypeDescriptor.SpecialObjectAccessTitle    = awchSpecial;
    ObjectTypeDescriptor.SpecialNewObjectAccessTitle = awchSpecial;

    // Load permission names
    LoadString(hInst, IDS_SPECIAL_PERMNAME, awchSpecial, MAX_SPECIAL_LENGTH);
    for (i = 0;i < cPerms;i++)
       {
       LoadString(hInst, IDS_PERMNAME + i,
            awchPerms + MAX_PERMNAME_LENGTH * i, MAX_PERMNAME_LENGTH);
       }

    ApplicationAccesses.Count           = sizeof(KeyPerms)/sizeof(KeyPerms[0]);
    ApplicationAccesses.AccessGroup     = KeyPerms;
    ApplicationAccesses.DefaultPermName = awchPerms + MAX_PERMNAME_LENGTH;

    dwRtn = (*lpfnSDAE)( hWnd,
                         hInst,
                         NULL,
                         &ObjectTypeDescriptor,
                         &ApplicationAccesses,
                         wShareName,
                         SedCallback,
                         (ULONG_PTR)dwSD,
                         plSD,
                         FALSE,
                         FALSE, 
                         &Status,
                         0L );

    if (dwRtn != NO_ERROR) {
        DPRINTF(("SED rtn ( %ld, %ld )", dwRtn, Status));
    }

    FreeLibrary( hLibrary );

    return TRUE;
}


DWORD
SedCallback(
        HWND hWnd,
        HANDLE hInstance,
        ULONG_PTR dwSD,
        PSECURITY_DESCRIPTOR SecDesc,
        PSECURITY_DESCRIPTOR SecDescNewObjects,
        BOOLEAN ApplyToSubContainers,
        BOOLEAN ApplyToSubObjects,
        LPDWORD StatusReturn )
{
    DWORD                lSD;

    if( pSD ) {
        LocalFree( pSD );
        pSD = (PSECURITY_DESCRIPTOR) NULL;
    }
    lSD = GetSecurityDescriptorLength( SecDesc );
    if( pSD = (PSECURITY_DESCRIPTOR)LocalAlloc( 0, lSD ) ) {
        MakeSelfRelativeSD( SecDesc, pSD, &lSD );
    }
    if( IsValidSecurityDescriptor( pSD ) ) {
//      DPRINTF(("SedCallback = 0."));
        fSecurityDescriptorDirty = TRUE;
        return 0;
    } else {
//      DPRINTF(("SedCallback = 1."));
        return 1;
    }
}


#ifdef DO_AUDIT

LPWSTR IdToWszAlloc(
int ids)
{
    int cch;
    WCHAR szBuf[50];
    LPWSTR wsz = NULL;

    cch = LoadStringW(hInst, ids, szBuf, sizeof(szBuf));
    if (cch) {
        wsz = (LPWSTR)LocalAlloc(LPTR, (cch + 1) * sizeof(WCHAR));
        if (wsz != NULL) {
            wcscpy(wsz, szBuf);
        }
    }
    return(wsz);
}


BOOL WINAPI
AuditEdit( HWND hWnd, LPTSTR pShareName, DWORD dwSD )
{
    SEDDESCRETIONARYACLEDITOR   lpfnSsAE;
    SED_OBJECT_TYPE_DESCRIPTOR  ObjectTypeDescriptor;
    SED_APPLICATION_ACCESSES    ApplicationAccesses;
    SED_APPLICATION_ACCESS      KeyPerms[5];
    PSECURITY_DESCRIPTOR        plSD = NULL;
    GENERIC_MAPPING             GmDdeShare;
    SED_HELP_INFO               HelpInfo;
    HANDLE      hLibrary;
    DWORD       Status;
    DWORD       dwRtn;
    WCHAR       wShareName[MAX_NDDESHARENAME+1];

#ifdef UNICODE
    lstrcpyn( wShareName, pShareName, MAX_NDDESHARENAME+1 );
#else
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pShareName, -1,
                    wShareName, MAX_NDDESHARENAME+1 );
#endif

    hLibrary = LoadLibrary( szAclEdit );
    if( hLibrary == (HANDLE) NULL ) {
#ifdef UNICODE
        DPRINTF(("Could not load library (%ws) = %d", szAclEdit, GetLastError()));
#else
        DPRINTF(("Could not load library (%s) = %d", szAclEdit, GetLastError()));
#endif
        return FALSE;
    }

    lpfnSsAE = (SEDDESCRETIONARYACLEDITOR)
                    GetProcAddress( hLibrary, szSedSaclEdit );
    if( lpfnSsAE == NULL ) {
#ifdef UNICODE
        DPRINTF(("Could not find function (%s) in library (%ws) = %d",
            szSedSaclEdit, szAclEdit, GetLastError() ));
#else
        DPRINTF(("Could not find function (%s) in library (%s) = %d",
            szSedSaclEdit, szAclEdit, GetLastError() ));
#endif
        FreeLibrary( hLibrary );
        return FALSE;
    }

    if( pSD == NULL ) {
        if( !InitializeShareSD( &pSD ) ) {
            FreeLibrary( hLibrary );
            return FALSE;
        }
    }
    plSD = pSD;

    HelpInfo.pszHelpFileName = L"ddeshare.hlp";
    HelpInfo.aulHelpContext[HC_MAIN_DLG]                    = 0;
    HelpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG]          = 0;
    HelpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0;
    HelpInfo.aulHelpContext[HC_ADD_USER_DLG]                = 0;

    GmDdeShare.GenericRead    = NDDE_SHARE_GENERIC_READ;
    GmDdeShare.GenericWrite   = NDDE_SHARE_GENERIC_WRITE;
    GmDdeShare.GenericExecute = NDDE_SHARE_GENERIC_EXECUTE;
    GmDdeShare.GenericAll     = NDDE_SHARE_GENERIC_ALL;

    ObjectTypeDescriptor.Revision                    = SED_REVISION1;
    ObjectTypeDescriptor.IsContainer                 = TRUE;
    ObjectTypeDescriptor.AllowNewObjectPerms         = FALSE;
    ObjectTypeDescriptor.MapSpecificPermsToGeneric   = FALSE;
    ObjectTypeDescriptor.GenericMapping              = &GmDdeShare;
    ObjectTypeDescriptor.GenericMappingNewObjects    = NULL;
    ObjectTypeDescriptor.ObjectTypeName              = ShareObjectName;
    ObjectTypeDescriptor.HelpInfo                    = &HelpInfo;
    ObjectTypeDescriptor.ApplyToSubContainerTitle    = NULL;
    //ObjectTypeDescriptor.ApplyToSubContainerHelpText = NULL;
    ObjectTypeDescriptor.ApplyToSubContainerConfirmation = NULL;
    ObjectTypeDescriptor.SpecialObjectAccessTitle    = NULL;
    ObjectTypeDescriptor.SpecialNewObjectAccessTitle = NULL;

    KeyPerms[0].Type            = SED_DESC_TYPE_AUDIT;
//    KeyPerms[0].AccessMask1     = ACCESS_SYSTEM_SECURITY;
    KeyPerms[0].AccessMask1     = READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    KeyPerms[0].AccessMask2     = 0;
    KeyPerms[0].PermissionTitle = IdToWszAlloc(IDS_NOACCESS);

    KeyPerms[1].Type            = SED_DESC_TYPE_AUDIT;
//    KeyPerms[1].AccessMask1     = NDDE_GUI_READ | ACCESS_SYSTEM_SECURITY;
    KeyPerms[1].AccessMask1     = READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    KeyPerms[1].AccessMask2     = 0;
    KeyPerms[1].PermissionTitle = IdToWszAlloc(IDS_READ);

    KeyPerms[2].Type            = SED_DESC_TYPE_AUDIT;
//    KeyPerms[2].AccessMask1     = NDDE_GUI_READ_LINK | ACCESS_SYSTEM_SECURITY;
    KeyPerms[2].AccessMask1     = READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    KeyPerms[2].AccessMask2     = 0;
    KeyPerms[2].PermissionTitle = IdToWszAlloc(IDS_READANDLINK);

    KeyPerms[3].Type            = SED_DESC_TYPE_AUDIT;
//    KeyPerms[3].AccessMask1     = NDDE_GUI_CHANGE | ACCESS_SYSTEM_SECURITY;
    KeyPerms[3].AccessMask1     = READ_CONTROL | WRITE_DAC | DELETE | ACCESS_SYSTEM_SECURITY;
    KeyPerms[3].AccessMask2     = 0;
    KeyPerms[3].PermissionTitle = IdToWszAlloc(IDS_CHANGE);

    KeyPerms[4].Type            = SED_DESC_TYPE_AUDIT;
//    KeyPerms[4].AccessMask1     = NDDE_GUI_FULL_CONTROL | ACCESS_SYSTEM_SECURITY;
    KeyPerms[4].AccessMask1     = READ_CONTROL | WRITE_DAC | DELETE | ACCESS_SYSTEM_SECURITY;
    KeyPerms[4].AccessMask2     = 0;
    KeyPerms[4].PermissionTitle = IdToWszAlloc(IDS_FULLCTRL);

    ApplicationAccesses.Count           = 5;
    ApplicationAccesses.AccessGroup     = KeyPerms;
    ApplicationAccesses.DefaultPermName = KeyPerms[1].PermissionTitle;

    dwRtn = (*lpfnSsAE)( hWnd,
                         hInst,
                         NULL,
                         &ObjectTypeDescriptor,
                         &ApplicationAccesses,
                         wShareName,
                         SedAuditCallback,
                         (ULONG)dwSD,
                         plSD,
                         FALSE,
                         FALSE,
                         &Status );

    LocalFree(KeyPerms[0].PermissionTitle);
    LocalFree(KeyPerms[1].PermissionTitle);
    LocalFree(KeyPerms[2].PermissionTitle);
    LocalFree(KeyPerms[3].PermissionTitle);
    LocalFree(KeyPerms[4].PermissionTitle);

    DPRINTF(("SEDSacl rtn ( %ld, %ld )", dwRtn, Status));

    FreeLibrary( hLibrary );

    return TRUE;
}


DWORD
SedAuditCallback(
        HWND hWnd,
        HANDLE hInstance,
        ULONG  dwSD,
        PSECURITY_DESCRIPTOR SecDesc,
        PSECURITY_DESCRIPTOR SecDescNewObjects,
        BOOLEAN ApplyToSubContainers,
        BOOLEAN ApplyToSubObjects,
        LPDWORD StatusReturn )
{
    DWORD                lSD;

    if( pSD ) {
        LocalFree( pSD );
        pSD = (PSECURITY_DESCRIPTOR) NULL;
    }
    lSD = GetSecurityDescriptorLength( SecDesc );
    if( pSD = LocalAlloc( 0, lSD ) ) {
        MakeSelfRelativeSD( SecDesc, pSD, &lSD );
    }
    if( IsValidSecurityDescriptor( pSD ) ) {
        DPRINTF(("SedAuditCallback = 0."));
        return 0;
    } else {
        DPRINTF(("SedAuditCallback = 1."));
        return 1;
    }
}
#endif // DO_AUDIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ddeshare\rc.h ===
#ifndef H__rc
#define H__rc

#define DSACCEL                 80

#define CI_OK                   1
#define CI_CANCEL               2

#define CI_VERSION              100

#define MENU_ADD                200
#define MENU_DELETE             201
#define MENU_LIST               202

#define IDM_DDESHARES           210
#define IDM_TRUSTSHARES         211
#define IDM_SERVERNAME          212
#define IDM_EXIT                213

#define IDC_SERVER_NAME         221

#define IDM_DEBUG_DDE           250
#define IDM_LOG_INFO            251
#define IDM_LOG_ERRORS          252
#define IDM_LOG_DDE_PKTS        253
#define IDM_DEBUG_NETDDE        254

#define HELP_DLG_DDESHARES               101
#define HELP_DLG_DDETRUSTEDSHARES        111
#define HELP_DLG_PROPERTIES              121
#define HELP_DLG_TRUSTEDSHAREPROPERTIES  131
#define HELP_DLG_DDESHARENAMEPERMISSOINS 141
#define HELP_DLG_ADDUSERSANDGROUPS       151
#define HELP_DLG_FINDACCOUNT             161
#define HELP_DLG_LOCALGROUPMEMBERSHIP    171
#define HELP_DLG_GLOBALGROUPMEMBERSHIP   181
#define HELP_DLG_SELECTCOMPUTER          191

#define HELP_MENU_DDESHARES             300
#define HELP_MENU_TRUSTEDSHARES         310
#define HELP_MENU_SELECTCOMPUTER        320
#define HELP_MENU_EXIT                  330

#define MENU_HELP_ABOUT             300

#define IDICON_NetDDE           1
#define IDICON_DdeShare         2
#define IDICON_TrustShare       3
#define IDMENU_DdeShareMenu     4

#define DID_DDESHARE_DLG        5
#define DID_TRUSTEDSHARE_DLG    6
#define DID_DDESHARES_DLG       7
#define DID_TRUSTSHARES_DLG     8
#define DID_SERVERNAME_DLG      9

#define IDS_PERMNAME            0x400
#define IDS_SPECIAL_PERMNAME    0x3FF
#define IDS_ERROR1              1
#define IDS_ERROR2              2
#define IDS_ERROR3              3
#define IDS_ERROR4              4
#define IDS_ERROR5              5
#define IDS_ERROR6              6
#define IDS_ERROR7              7
#define IDS_ERROR8              8
#define IDS_ERROR9              9
#define IDS_ERROR10             10
#define IDS_ERROR11             11
#define IDS_ERROR12             12
#define IDS_ERROR13             13
#define IDS_ERROR14             14
#define IDS_ERROR15             15
#define IDS_ERROR16             16
#define IDS_ERROR17             17
#define IDS_ERROR18             18
#define IDS_ERROR19             19
#define IDS_ERROR20             20
#define IDS_APPNAME             21
#define IDS_ON                  22
#define IDS_MBTEXT1             23
#define IDS_MBCAP1              24
#define IDS_MBTEXT2             25
#define IDS_MBTEXT3             26
#define IDS_MBTEXT4             27
#define IDS_MBCAP4              28
#define IDS_MBTEXT5             29
#define IDS_MENU1               30
#define IDS_MENU2               31
#define IDS_MENU3               32
#define IDS_MENU4               33
#define IDS_MENU5               34
#define IDS_MBTEXT6             35
#define IDS_MBCAP6              36
#define IDS_NOSHARES            37
#define IDS_MBCAP7              38
#define IDS_MBTEXT8             39
#define IDS_MBTEXT9             40
#define IDS_MBTEXT10            41
#define IDS_UNNAMED             42
#define IDS_NOACCESS            43
#define IDS_READ                44
#define IDS_READANDLINK         45
#define IDS_CHANGE              46
#define IDS_FULLCTRL            47
#define IDS_MBCAP11             48
#define IDS_MBTEXT11            49
#define IDS_SHAREOBJECT         50

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\nddeexts\gendef.c ===
LIBRARY NDDEEXTS

;
; This file generates nddeexts.def.  This allows one file (exts.h) to
; be used to generate extension exports, entrypoints, and help text.
;
; To add an extension, add the appropriate entry to exts.h and matching
; code to userexts.c
;
EXPORTS
#define DOIT(name, helpstring1, helpstring2, validflags, argtype) name
#include "exts.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\nddeexts\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

$(O)\nddeexts.def: gendef.c exts.h
        $(CXX_COMPILER_NAME) /EP gendef.c > $(O)\nddeexts.def

nddeexts.c: exts.h $(O)\nddeexts.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\nddenb32\dlc.h ===
#define MAX_NAMES 254

struct NameTableEntry {
    char	EntryName[ 16 ];
    BYTE	EntryNameNum;
    BYTE	EntryNameStatus;	/* & with 0x0087 for status */
};

typedef struct {
    BYTE	PermanentNodeName[ 6 ];
    BYTE	MajorVersionNumber;
    BYTE	AlwaysZero;
    BYTE	LanAdapterType;
    BYTE	MinorVersionNumber;
    WORD	ReportingPeriodMinutes;
    WORD	FrameRejectedReceiveCount;
    WORD	FrameRejectedXmitCount;
    WORD	I_FrameReceiveErrorCount;
    WORD	XmitAbortCount;
    DWORD	SuccessfulFrameXmitCount;
    DWORD	SuccessfulFrameRcvCount;
    WORD	I_FrameXmitErrorCount;
    WORD	RmtRqstBufferDepletionCount;
    WORD	ExpiredT1TimerCount;
    WORD	ExpiredTiTimerCount;
    LPSTR	LocalExtStatPtr;
    WORD	FreeCommandBlocks;
    WORD	CurrentMaxNcbs;
    WORD	MaximumCommands;
    WORD	TransmitBufferDepletionCount;
    WORD	MaximumDatagramPacketSize;
    WORD	PendingSessionCount;
    WORD	MaxPendingSessionCount;
    WORD	MaximumSessions;
    WORD	MaximumSessionPacketSize;
    WORD	NameTableEntryCount;
    struct NameTableEntry TableEntry[ MAX_NAMES ];
} DLC;
typedef DLC FAR *LPDLC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\nddeexts\nddeexts.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "netintf.h"
#include "netpkt.h"
#include "ddepkt.h"
#include "netbasic.h"
#include "netddesh.h"
#include "pktz.h"

PSTR pszExtName         = "USEREXTS";

#include <stdexts.h>
#include <stdexts.c>

char gach1[80];

/****************************************************************************\
* Flags stuff
\****************************************************************************/

#define NO_FLAG (LPSTR)-1  // use this for non-meaningful entries.

/*
 * Converts a 32bit set of flags into an appropriate string.
 * pszBuf should be large enough to hold this string, no checks are done.
 * pszBuf can be NULL, allowing use of a local static buffer but note that
 * this is not reentrant.
 * Output string has the form: " = FLAG1 | FLAG2 ..."
 */
LPSTR GetFlags(
LPSTR *apszFlagStrings,
DWORD dwFlags,
LPSTR pszBuf)
{
    static char szT[400];
    WORD i;
    BOOL fFirst = TRUE;
    BOOL fNoMoreNames = FALSE;

    if (pszBuf == NULL) {
        pszBuf = szT;
    }
    *pszBuf = '\0';

    for (i = 0; dwFlags; dwFlags >>= 1, i++) {
        if (!fNoMoreNames && (apszFlagStrings[i] == NULL)) {
            fNoMoreNames = TRUE;
        }
        if (dwFlags & 1) {
            if (!fFirst) {
                strcat(pszBuf, " | ");
            } else {
                strcat(pszBuf, " = ");
                fFirst = FALSE;
            }
            if (fNoMoreNames || (apszFlagStrings[i] == NO_FLAG)) {
                char ach[16];
                sprintf(ach, "0x%lx", 1 << i);
                strcat(pszBuf, ach);
            } else {
                strcat(pszBuf, apszFlagStrings[i]);
            }
        }
    }
    return(pszBuf);
}


BOOL Idtd()
{
    THREADDATA td, *ptd;

    moveExpValue(&ptd, "netdde!ptdHead");

    SAFEWHILE (ptd != NULL) {
        move(td, ptd);
        Print(
            "PTHREADDATA @ %x:\n"
            "  hwinsta     = %x\n"
            "  hdesk       = %x\n"
            "  hwndDDE     = %x\n"
            "  hwndDDEAgent= %x\n"
            "  heventReady = %x\n"
            "  dwThreadId  = %x\n"
            "  bInitiating = %x\n"
        ,
            ptd,
            td.hwinsta,
            td.hdesk,
            td.hwndDDE,
            td.hwndDDEAgent,
            td.heventReady,
            td.dwThreadId,
            td.bInitiating
        );
        ptd = td.ptdNext;
    }
    return(TRUE);
}



BOOL Idpktz(
DWORD opts,
PVOID param1)
{
    PKTZ pktz;

    if (param1 == 0) {
        Print("You must supply a pktz pointer.  Try breaking on PktzSlice().\n");
        return(FALSE);
    }
    move(pktz, param1);
    Print(
            "pk_connId              = %08lx\n"
            "pk_state               = %08lx\n"
            "pk_fControlPktNeeded   = %08lx\n"
            "pk_pktidNextToSend     = %08lx\n"
            "pk_pktidNextToBuild    = %08lx\n"
            "pk_lastPktStatus       = %08lx\n"
            "pk_lastPktRcvd         = %08lx\n"
            "pk_lastPktOk           = %08lx\n"
            "pk_lastPktOkOther      = %08lx\n"
            "pk_pktidNextToRecv     = %08lx\n"
            "pk_pktOffsInXmtMsg     = %08lx\n"
            "pk_lpDdePktSave        = %08lx\n"
            ,
             pktz.pk_connId           ,
             pktz.pk_state            ,
             pktz.pk_fControlPktNeeded,
             pktz.pk_pktidNextToSend  ,
             pktz.pk_pktidNextToBuild ,
             pktz.pk_lastPktStatus    ,
             pktz.pk_lastPktRcvd      ,
             pktz.pk_lastPktOk        ,
             pktz.pk_lastPktOkOther   ,
             pktz.pk_pktidNextToRecv  ,
             pktz.pk_pktOffsInXmtMsg  ,
             pktz.pk_lpDdePktSave     );

    Print(
            "pk_szDestName          = \"%s\"\n"
            "pk_szAliasName         = \"%s\"\n"
            ,
             &pktz.pk_szDestName         ,
             &pktz.pk_szAliasName        );

    Print(
            "pk_pktSize             = %08lx\n"
            "pk_maxUnackPkts        = %08lx\n"
            "pk_timeoutRcvNegCmd    = %08lx\n"
            "pk_timeoutRcvNegRsp    = %08lx\n"
            "pk_timeoutMemoryPause  = %08lx\n"
            "pk_timeoutKeepAlive    = %08lx\n"
            "pk_timeoutXmtStuck     = %08lx\n"
            "pk_timeoutSendRsp      = %08lx\n"
            "pk_wMaxNoResponse      = %08lx\n"
            "pk_wMaxXmtErr          = %08lx\n"
            "pk_wMaxMemErr          = %08lx\n"
            "pk_fDisconnect         = %08lx\n"
            "pk_nDelay              = %08lx\n"
            ,
             pktz.pk_pktSize            ,
             pktz.pk_maxUnackPkts       ,
             pktz.pk_timeoutRcvNegCmd   ,
             pktz.pk_timeoutRcvNegRsp   ,
             pktz.pk_timeoutMemoryPause ,
             pktz.pk_timeoutKeepAlive   ,
             pktz.pk_timeoutXmtStuck    ,
             pktz.pk_timeoutSendRsp     ,
             pktz.pk_wMaxNoResponse     ,
             pktz.pk_wMaxXmtErr         ,
             pktz.pk_wMaxMemErr         ,
             pktz.pk_fDisconnect        ,
             pktz.pk_nDelay             );

    Print(
            "pk_lpNiPtrs            = %08lx\n"
            "pk_sent                = %08lx\n"
            "pk_rcvd                = %08lx\n"
            "pk_hTimerKeepalive     = %08lx\n"
            "pk_hTimerXmtStuck      = %08lx\n"
            "pk_hTimerRcvNegCmd     = %08lx\n"
            "pk_hTimerRcvNegRsp     = %08lx\n"
            "pk_hTimerMemoryPause   = %08lx\n"
            "pk_hTimerCloseConnection = %08lx\n"
            "pk_pktUnackHead        = %08lx\n"
            "pk_pktUnackTail        = %08lx\n"
            "pk_rcvBuf              = %08lx\n"
            ,
             pktz.pk_lpNiPtrs               ,
             pktz.pk_sent                   ,
             pktz.pk_rcvd                   ,
             pktz.pk_hTimerKeepalive        ,
             pktz.pk_hTimerXmtStuck         ,
             pktz.pk_hTimerRcvNegCmd        ,
             pktz.pk_hTimerRcvNegRsp        ,
             pktz.pk_hTimerMemoryPause      ,
             pktz.pk_hTimerCloseConnection  ,
             pktz.pk_pktUnackHead           ,
             pktz.pk_pktUnackTail           ,
             pktz.pk_rcvBuf                 );

    Print(
            "pk_controlPkt          = %08lx\n"
            "pk_pktFreeHead         = %08lx\n"
            "pk_pktFreeTail         = %08lx\n"
            "pk_ddePktHead          = %08lx\n"
            "pk_ddePktTail          = %08lx\n"
            "pk_prevPktz            = %08lx\n"
            "pk_nextPktz            = %08lx\n"
            "pk_prevPktzForNetintf  = %08lx\n"
            "pk_nextPktzForNetintf  = %08lx\n"
            "pk_hRouterHead         = %08lx\n"
            "pk_hRouterExtraHead    = %08lx\n"
            ,
             pktz.pk_controlPkt             ,
             pktz.pk_pktFreeHead            ,
             pktz.pk_pktFreeTail            ,
             pktz.pk_ddePktHead             ,
             pktz.pk_ddePktTail             ,
             pktz.pk_prevPktz               ,
             pktz.pk_nextPktz               ,
             pktz.pk_prevPktzForNetintf     ,
             pktz.pk_nextPktzForNetintf     ,
             pktz.pk_hRouterHead            ,
             pktz.pk_hRouterExtraHead       );
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\nddenb32\config.h ===
#define CI_HELP			101
#define CI_PACKET_SIZE		102
#define CI_MAX_UNACK_PKTS	103
#define CI_RCV_CONN_CMD		104
#define CI_RCV_CONN_RSP		105
#define CI_MEMORY_PAUSE		106
#define CI_NO_RESPONSE		107
#define CI_KEEP_ALIVE		108
#define CI_RETRY_LIMIT_XMIT_ERR	109
#define CI_RETRY_LIMIT_MEM_ERR	110
#define CI_RETRY_LIMIT_RSP_ERR	111
#define CI_XMT_STUCK		112
#define CI_FROM_NETBIOS		113
#define CI_FIXED_PKT_SIZE	114
#define CI_RESTORE          119
#define CI_VERSION          120

#define CI_VAL_CRC		201
#define CI_VAL_CHECKSUM		202

#define CI_LOG_ALL		301
#define CI_LOG_UNUSUAL		302
#define CI_LOG_NONE		303

#define NBE_NRC_BUFLEN                  1
//#define NBE_FULL_BUFFERS              2
#define NBE_NRC_ILLCMD                  3
#define NBE_NRC_CMDTMO                  4
#define NBE_NRC_INCOMP                  5
#define NBE_NRC_BADDR                   6
#define NBE_NRC_SNUMOUT                 7
#define NBE_NRC_NORES                   8
#define NBE_NRC_SCLOSED                 9
#define NBE_NRC_CMDCAN                  10
//#define NBE_PCDMA_FAILED              11
#define NBE_NRC_DUPNAME                 12
#define NBE_NRC_NAMTFUL                 13
#define NBE_NRC_ACTSES                  14
#define NBE_NRC_NOWILD                  15
#define NBE_NRC_LOCTFUL                 16
#define NBE_NRC_REMTFUL                 17
#define NBE_NRC_ILLNN                   18
#define NBE_NRC_NOCALL                  19
//#define NBE_NRC_NOWILD2                 20
#define NBE_NRC_INUSE                   21
#define NBE_NRC_NAMERR                  22
#define NBE_NRC_SABORT                  23
#define NBE_NRC_NAMCONF                 24
//#define NBE_INCOMPAT_REMOTE_DEV       25
#define NBE_NRC_IFBUSY                  26
#define NBE_NRC_TOOMANY                 27
#define NBE_NRC_BRIDGE                  28
#define NBE_NRC_CANOCCR                 29
//#define NBE_RESERVED_NAME             30
#define NBE_NRC_CANCEL                  31
#define NBE_NRC_DUPENV                  32
//#define NBE_MULT_REQ_FOR_SAME_SESSION 33
#define NBE_NRC_ENVNOTDEF               34
#define NBE_NRC_OSRESNOTAV              35
#define NBE_NRC_MAXAPPS                 36
#define NBE_NRC_NOSAPS                  37
#define NBE_NRC_NORESOURCES             38
#define NBE_NRC_SYSTEM                  39
//#define NBE_HOT_CARRIER_REMOTE        40
//#define NBE_HOT_CARRIER_LOCAL         41
//#define NBE_NO_CARRIER                42
//#define NBE_INTERFACE_FAILURE         43
//#define NBE_BITS_ON_TOO_LONG          44
//#define NBE_BITS_ON                   45
//#define NBE_ADAPTER_FAILED            46
//#define NBE_DIR_INITIALIZE_ERROR      47
//#define NBE_DIR_OPEN_ADAPTER_ERROR    48
//#define NBE_IBM_LAN_INTERNAL_ERROR    49
//#define NBE_NETBIOS_CARD_ERROR        50
#define NBE_NRC_OPENERR                 51
//#define NBE_SAP_FAILED                52
//#define NBE_UNEXPECTED_ADAPTER_CLOSE  53
#define NBE_HARDWARE_ERROR              54
#define NBE_UNKNOWN_ERROR               55

#define NBE_NRC_INVADDRESS         2
#define NBE_NRC_INVDDID            11
#define NBE_NRC_LOCKFAIL            25
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\nddenb32\dllmain.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DLLMAIN.C;1  16-Dec-92,10:14:24  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.		*
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#define NOCOMM
#define LINT_ARGS
#include	"windows.h"

HANDLE	hInst;

INT  APIENTRY LibMain(HANDLE hInstance, DWORD ul_reason_being_called, LPVOID lpReserved)
{
    hInst = hInstance;
    return 1;
	UNREFERENCED_PARAMETER(hInstance);
	UNREFERENCED_PARAMETER(ul_reason_being_called);
	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ndeapi\client\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt
IDL_NAME = ndeapi
INCS     = -I$(SDK_INC_PATH)  -I$(SDK_INC_PATH)\crt
EXTRN_DEPENDS = $(SDK_INC_PATH)\windef.h \
                ..\$(IDL_NAME).acf
CPP_FLAGS = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) $(C_DEFINES) $(NET_C_DEFINES)

$(O)\$(IDL_NAME)_c.c : ..\$(IDL_NAME).idl $(EXTRN_DEPENDS)
    midl -Oicf -robust -server none -oldnames -error all -ms_ext -c_ext $(CPP_FLAGS) ..\$(IDL_NAME).idl $(INCS) /out $(O) /acf ..\$(IDL_NAME).acf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\nddenb32\netbios.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NETBIOS.C;3  13-Feb-93,9:21:54  LastEdit=IGOR  Locker=IGORM" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    "api1632.h"

#include    <dos.h>
#include    <string.h>
#include    <windows.h>

#undef      NCB_INCLUDED
#include    <nb30.h>        // Use Microsoft's NCB defs

#include    "host.h"
#include    "netintf.h"
#include    "netpkt.h"
#include    "dlc.h"
#include    "hexdump.h"
#include    "debug.h"
#include    "verify.h"
#include    "wwassert.h"
#include    "tmpbuf.h"
#include    "tmpbufc.h"
#include    "proflspt.h"
#include    "config.h"
#include    "nddemsg.h"
#include    "nddelog.h"


USES_ASSERT

#define NETBIOS_SPECIAL     0x1F

#define RS_IDLE             0x11
#define RS_RECVING          0x12

#define SS_IDLE             0x21
#define SS_XMITING          0x22

typedef struct conn {
    struct conn FAR    *prev;
    struct conn FAR    *next;

    char                nodeName[ MAX_NODE_NAME+1 ];
    BYTE                sessionLsn;
    BYTE                lananum;
    int                 current_lananum;
    int                 lananum_count;
    DWORD               state;
    WORD                wMaxUnAckPkts;
    WORD                wPktSize;
    BYTE                bXmtVerifyMethod;
    NCB                 ncbCall;

    LPSTR               lpRcvBuf;
    NCB                 ncbRecv;
    WORD                wLastPktStatus;
    WORD                wLastPktSize;
    WORD                wRcvState;

    LPSTR               lpXmtBuf;
    NCB                 ncbSend;
    WORD                wXmtState;
} CONN;
typedef CONN FAR *LPCONN;

extern HANDLE   hInst;

BYTE    lananum[ MAX_LANA ];    // configured lan adapter numbers
int     nLananums;              // how many lananums are configured
int     last_good_lana = 0;     // index of the last lana that connected

/*
        Event Logger Control Variables
*/
BOOL    bNDDELogInfo            = FALSE;
BOOL    bNDDELogWarnings        = FALSE;
BOOL    bNDDELogErrors          = TRUE;


/*
        Debug Logger (netdde.log) Control Variables
*/
BOOL    bDebugInfo          = FALSE;
BOOL    bDebugMenu          = FALSE;
BOOL    bLogAll             = FALSE;
BOOL    bLogUnusual         = TRUE;
BOOL    bUseNetbiosPost;
BOOL    bUseResetAdapter    = FALSE;
BOOL    bUseAdapterStatus   = TRUE;
WORD    dflt_pktsize;

BYTE    dflt_vermeth            = VERMETH_CKS32;
WORD    dflt_maxunack           = 10;
DWORD   dflt_timeoutRcvConnCmd  = 60000;
DWORD   dflt_timeoutRcvConnRsp  = 60000;
DWORD   dflt_timeoutMemoryPause = 10000;
DWORD   dflt_timeoutKeepAlive   = 60000;
DWORD   dflt_timeoutXmtStuck    = 120000;
DWORD   dflt_timeoutSendRsp     = 60000;
WORD    dflt_maxNoResponse      = 3;
WORD    dflt_maxXmtErr          = 3;
WORD    dflt_maxMemErr          = 3;
BYTE    dflt_maxSessions        = 0;

char        szNetddeIni[]           =       "netdde.ini";
char        szUsePost[]             =       "UseNetbiosPost";
char        szUseReset[]            =       "UseResetAdapter";
char        szUseStatus[]           =       "UseAdapterStatus";

BOOL        bNameAdded[ MAX_LANA ];
char        buf[ 500 ];
char        ourNodeName[ 20 ];
LPCONN      lpConnHead;
PNCB        lpNcbListen[ MAX_LANA ];

HWND            NB_hWndNetdde;

/*
 *  only put NCBs in the DS if they are SYNCHRONOUS, i.e., if ASYNCH is not set
 */
NCB             ncbAddName;
NCB             ncbHangup;
NCB             ncbDeleteName;
NCB             ncbCancel;
NCB             ncbCheck;


#if DBG
VOID                        LogDebugInfo( CONNID connId, DWORD dwFlags );
#endif // DBG

VOID                        Configure( void ) { };
BOOL
FAR PASCAL
ConfigureDlgProc( HWND hDummy, unsigned uDummy, WORD wDummy, LONG lDummy )
{
    return(FALSE);
}

VOID    FAR PASCAL MakeHelpPathName( char *szFileName, int nMax );
BOOL    FAR PASCAL SetupListen( int nLananum );
VOID    FAR PASCAL SetupReceive( LPCONN lpConn );
CONNID  FAR PASCAL CreateConnId( void );
BOOL    FAR PASCAL AllocateBuffers( LPCONN lpConn );
VOID    FAR PASCAL FreeBuffers( LPCONN lpConn );
VOID    FAR PASCAL FreeConnId( CONNID connId );
VOID    FAR PASCAL DoDisconnect( CONNID connId );
LPSTR   FAR PASCAL NetbiosErrorMsg( BYTE errCode );
UCHAR   APIENTRY   Netbios( PNCB pncb );
VOID               NetbiosPost( PNCB lpNcb );
VOID    FAR PASCAL HangUpSession( BYTE, BYTE );
BYTE    FAR PASCAL NetbiosDeleteName( BYTE, LPSTR );
VOID    FAR PASCAL CancelNCB( BYTE, PNCB );
BOOL    FAR PASCAL InitLanaNums( VOID );



void
NDDETimeSlice( void )
{
    LPCONN      lpConn;
    BOOL        gotRcv;
    BOOL        bClose;
    LPNETPKT    lpPacket;

    lpConn = lpConnHead;
    while( lpConn )  {
        if( lpConn->state & NDDE_CONN_CONNECTING )  {
            if( lpConn->ncbCall.ncb_cmd_cplt != NRC_PENDING )  {
                if( lpConn->ncbCall.ncb_retcode == 0x00 )  {
                    DIPRINTF(( "Connected Lsn %d", lpConn->ncbCall.ncb_lsn ));
                    lpConn->state = NDDE_CONN_OK | NDDE_READY_TO_XMT;
                    lpConn->sessionLsn = lpConn->ncbCall.ncb_lsn;
                    last_good_lana = lpConn->current_lananum;
                    SetupReceive( lpConn );
                } else {
                    if (++lpConn->current_lananum >= nLananums) {
                        lpConn->current_lananum = 0;    // wrap around
                    }
                    if( ++lpConn->lananum_count >= nLananums )  {
                        // tried them all and it still failed
                        if( bLogAll )  {
                            /*  Connect failed to "%1": %2  */
                            NDDELogWarning(MSG200, (LPSTR) lpConn->nodeName,
                                NetbiosErrorMsg( lpConn->ncbCall.ncb_retcode ), NULL );
                        } else if( bLogUnusual )  {
                            switch( lpConn->ncbCall.ncb_retcode )  {
                            case 0x12:  // no remote listen
                            case 0x14:  // cannot find name or no answer
                                break;
                            default:
                                /*  Connect failed to "%1": %2  */
                                NDDELogError(MSG200, (LPSTR) lpConn->nodeName,
                                    NetbiosErrorMsg( lpConn->ncbCall.ncb_retcode ), NULL );
                            }
                        }
                        lpConn->state = 0;
                    } else {
                        // try the next LAN adapter num
                        lpConn->lananum = lananum[ lpConn->current_lananum ];
                        lpConn->ncbCall.ncb_lana_num = lpConn->lananum;
                        lpConn->ncbCall.ncb_cmd_cplt = 0;
                        lpConn->ncbCall.ncb_retcode = 0;
                        Netbios( &lpConn->ncbCall );
                    }
                }
            }
        } else if( lpConn->state & NDDE_CONN_OK )  {
            bClose = FALSE;
            gotRcv = FALSE;
            if( lpConn->wRcvState == RS_RECVING )  {
                if( lpConn->ncbRecv.ncb_cmd_cplt != NRC_PENDING )  {
                    lpConn->wRcvState = RS_IDLE;
                    if( lpConn->ncbRecv.ncb_retcode == 0x00 )  {
                        lpPacket = (LPNETPKT) lpConn->lpRcvBuf;
                        if( VerifyHdr( lpPacket ) && VerifyData( lpPacket ) ){
                            lpConn->wLastPktStatus =
                                NDDE_PKT_HDR_OK | NDDE_PKT_DATA_OK;
                            lpConn->wLastPktSize = lpConn->ncbRecv.ncb_length;
                            gotRcv = TRUE;
                        } else {
                            bClose = TRUE;
                        }
                    } else if( (lpConn->ncbRecv.ncb_retcode == 0x0A)                    // NRC_SCLOSED
                                || (lpConn->ncbRecv.ncb_retcode == 0x18) )  {           // NRC_SABORT
                        if( bLogAll )  {
                            // Session has been closed normally
                            /*  Receive error. Session to %1 closed abonormally: %2  */
                            NDDELogWarning(MSG201, (LPSTR) lpConn->nodeName,
                                NetbiosErrorMsg( lpConn->ncbRecv.ncb_retcode ), NULL );
                        }
                        bClose = TRUE;
                    } else {
                        if( bLogUnusual )  {
                            /*  Receive error. Session to %1 closed abonormally: %2  */
                            NDDELogError(MSG201, (LPSTR) lpConn->nodeName,
                                NetbiosErrorMsg( lpConn->ncbRecv.ncb_retcode ), NULL );
                        }
                        bClose = TRUE;
                    }
                }
            }
            if( !bClose && (lpConn->wXmtState == SS_XMITING) )  {
                if( lpConn->ncbSend.ncb_cmd_cplt != NRC_PENDING )  {
                    lpConn->wXmtState = SS_IDLE;
                    if( lpConn->ncbSend.ncb_retcode == 0x00 )  {
                        lpConn->state |= NDDE_READY_TO_XMT;
                        lpConn->wXmtState = SS_IDLE;
                    } else if( (lpConn->ncbSend.ncb_retcode == 0x0A) ||                    // NRC_SCLOSED
                        (lpConn->ncbSend.ncb_retcode == 0x18) )  {                         // NRC_SABORT
                        bClose = TRUE;
                    } else {
                        if( bLogUnusual )  {
                            /*  Send error. Session to %1 closed abonormally: %2  */
                            NDDELogWarning(MSG202, (LPSTR) lpConn->nodeName,
                                NetbiosErrorMsg( lpConn->ncbSend.ncb_retcode ), NULL );
                        }
                        bClose = TRUE;
                    }
                }
            }
            if( bClose )  {
                DoDisconnect( (CONNID) lpConn );
            } else if( gotRcv )  {
                lpConn->state |= NDDE_CALL_RCV_PKT;
            }
        }
        lpConn = lpConn->next;
    }
}




DWORD
NDDEGetCAPS( WORD nIndex )
{
    switch( nIndex )  {
    case NDDE_SPEC_VERSION:
        return( NDDE_CUR_VERSION );
        break;

    case NDDE_MAPPING_SUPPORT:
        return( NDDE_MAPS_YES );
        break;

    case NDDE_SCHEDULE_METHOD:
        return( NDDE_TIMESLICE );
        break;

    default:
        return( 0L );
    }
}




DWORD
NDDEInit(
    LPSTR   lpszNodeName,
    HWND    hWndNetdde )
{
    BOOL                ok;
    static char         dllName[] = "NetBIOS";

#if DBG
    DebugInit( "NetBIOS" );
#endif // DBG

    NB_hWndNetdde = hWndNetdde;

/*
        Determine what we're allowed to log in the event logger
*/
    bNDDELogInfo = MyGetPrivateProfileInt( dllName,
        "NDDELogInfo", FALSE, szNetddeIni );
    bNDDELogWarnings = MyGetPrivateProfileInt( dllName,
        "NDDELogWarnings", FALSE, szNetddeIni );
    bNDDELogErrors = MyGetPrivateProfileInt( dllName,
        "NDDELogErrors", TRUE, szNetddeIni );


    if( lstrlen( lpszNodeName ) > 15 )  {
        NDDELogError(MSG208, lpszNodeName);
        return( NDDE_INIT_FAIL );
    }

    lstrcpy( ourNodeName, lpszNodeName);

    bUseNetbiosPost = MyGetPrivateProfileInt( dllName,
        szUsePost, TRUE, szNetddeIni );
    bUseResetAdapter = MyGetPrivateProfileInt( dllName,
        szUseReset, TRUE, szNetddeIni );
    bUseAdapterStatus = MyGetPrivateProfileInt( dllName,
        szUseStatus, TRUE, szNetddeIni );

    bLogAll = MyGetPrivateProfileInt( dllName,
                        "LogAll", FALSE, szNetddeIni );
    bLogUnusual = MyGetPrivateProfileInt( dllName,
                        "LogUnusual", TRUE, szNetddeIni );
    if( bLogAll )  {
        bLogUnusual = TRUE;
    }

#if DBG
    bDebugMenu = MyGetPrivateProfileInt( "General", "DebugMenu",
        FALSE, szNetddeIni);
    bDebugInfo = MyGetPrivateProfileInt( dllName, "DebugInfo",
        FALSE, szNetddeIni);
#endif

    dflt_vermeth = (BYTE)MyGetPrivateProfileInt( dllName,
                        "Vermeth", VERMETH_CKS32, szNetddeIni );
    if( dflt_vermeth != VERMETH_CRC16 )  {
        dflt_vermeth = VERMETH_CKS32;
    }
    dflt_maxunack = (WORD)MyGetPrivateProfileInt( dllName,
                        "Maxunack", 10, szNetddeIni );
    dflt_timeoutRcvConnCmd = GetPrivateProfileLong( dllName,
                        "TimeoutRcvConnCmd", 60000, szNetddeIni );
    dflt_timeoutRcvConnRsp = GetPrivateProfileLong( dllName,
                        "TimeoutRcvConnRsp", 60000, szNetddeIni );
    dflt_timeoutMemoryPause = GetPrivateProfileLong( dllName,
                        "TimeoutMemoryPause", 10000, szNetddeIni );
    dflt_timeoutKeepAlive = GetPrivateProfileLong( dllName,
                        "TimeoutKeepAlive", 60000, szNetddeIni );
    dflt_timeoutXmtStuck = GetPrivateProfileLong( dllName,
                        "TimeoutXmtStuck", 120000, szNetddeIni );
    dflt_timeoutSendRsp = GetPrivateProfileLong( dllName,
                        "TimeoutSendRsp", 60000, szNetddeIni );
    dflt_maxNoResponse = (WORD)MyGetPrivateProfileInt( dllName,
                        "MaxNoResponse", 3, szNetddeIni );
    dflt_maxXmtErr = (WORD)MyGetPrivateProfileInt( dllName,
                        "MaxXmtErr", 3, szNetddeIni );
    dflt_maxMemErr = (WORD)MyGetPrivateProfileInt( dllName,
                        "MaxMemErr", 3, szNetddeIni );
    dflt_maxSessions = (BYTE)MyGetPrivateProfileInt( dllName,
                        "MaxSessions", 0, szNetddeIni );

    ok = InitLanaNums();

    if (ok) {
        return(NDDE_INIT_OK);
    } else {
        return(NDDE_INIT_FAIL);
    }

}

BOOL
InitLanaNums( )
{
    BOOL                ok = TRUE;
    LANA_ENUM           lana_enum;
    NCB                 ncbEnum;
    int                 i, l;

    /*
     * find out how many and which lananums we support
     */
    _fmemset( (LPSTR)&ncbEnum, 0, sizeof(ncbEnum) );
    ncbEnum.ncb_command = NCBENUM;
    ncbEnum.ncb_buffer = (PUCHAR)&lana_enum;
    ncbEnum.ncb_length = sizeof(lana_enum);
    Netbios(&ncbEnum);
    if (ncbEnum.ncb_retcode != NRC_GOODRET) {
        DPRINTF(("ncbEnum failed: %s", NetbiosErrorMsg(ncbEnum.ncb_retcode)));
        NDDELogError(MSG204, NULL);
        nLananums = 0;
        ok = FALSE;
    } else {
        nLananums = lana_enum.length;
        for (l = 0; l < nLananums ; l++) {
            lananum[l] = lana_enum.lana[l];
        }
    }

    /*
     * allocate NCB listen blocks for each lanna
     */
    for( i=0; ok && i<nLananums; i++ )  {
        lpNcbListen[i] = HeapAllocPtr( hHeap, GMEM_MOVEABLE,
            (DWORD)sizeof(NCB) );
        if( !lpNcbListen[i] )  {
            NDDELogError(MSG203, NULL);
            ok = FALSE;
        }
    }

    if (ok) {
        dflt_pktsize = 0;
        /*
         * cycle through each lan adapter and determine default pkt size
         */
        for( l = 0; ok && l < nLananums; l++ )  {
            /*
             * Reset each adapter.
             */
            if( !bUseResetAdapter )  {
                DIPRINTF(( "Skipping reset adapter" ));
                dflt_pktsize = 1470;
            } else {
                _fmemset( (LPSTR)&ncbCheck, 0, sizeof(ncbCheck) );
                ncbCheck.ncb_command         = NCBRESET;
                ncbCheck.ncb_lana_num        = lananum[l];
                ncbCheck.ncb_callname[0]     = dflt_maxSessions;    // Num Sessions
                ncbCheck.ncb_callname[1]     = 0;    // Num Commands
                ncbCheck.ncb_callname[2]     = 0;    // Num Names
                ncbCheck.ncb_callname[3]     = 0;    // Name #1 Usage:
                                                        // 0: don't want it
                                                        // 1: want it
                Netbios( &ncbCheck );
                DIPRINTF(( "Reset adapter status: %02X", ncbCheck.ncb_retcode ));

                if( ncbCheck.ncb_retcode != 0x00 )  {
                    /*  NetBIOS Reset Adapter interface %1 failed: %2   */
                    NDDELogInfo(MSG209, LogString("%d", lananum[l]),
                        LogString("0x%0X", ncbCheck.ncb_retcode), NULL);
                    /*
                     * this adapter must be messed up even though the registry
                     * says its ok.  Just remove this lananum from the list.
                     */
                    nLananums--;
                    lananum[l] = lananum[nLananums];
                    HeapFreePtr(lpNcbListen[l]);
                    lpNcbListen[l] = lpNcbListen[nLananums];
                    if (nLananums == 0) {
                        ok = FALSE;
                    } else {
                        l--;
                    }
                    continue;
                }
            }

            /*
             * get status of each adapter.
             */
            if( !bUseAdapterStatus )  {
                DIPRINTF(( "Skipping Adapter Status" ));
                dflt_pktsize = 1470;
            } else {
                {
                    DLC DlcData;

                    _fmemset( (LPSTR)&ncbCheck, 0, sizeof(ncbCheck) );
                    ncbCheck.ncb_command     = NCBASTAT;
                    ncbCheck.ncb_buffer  = (LPSTR) &DlcData;
                    ncbCheck.ncb_length      = sizeof(DlcData) - sizeof(DlcData.TableEntry);
                    for( i = 0; i < NCBNAMSZ; i++ )  {
                        ncbCheck.ncb_callname[i] = ' ';
                    }
                    ncbCheck.ncb_callname[0] = '*';
                    ncbCheck.ncb_lana_num = lananum[l];
                    ncbCheck.ncb_retcode = 0xFF;

                    Netbios( &ncbCheck );
                }
                DIPRINTF(( "Adapter status returned: %02X", ncbCheck.ncb_retcode ));
                if( (ncbCheck.ncb_retcode != 0x00)
                        && (ncbCheck.ncb_retcode != 0x06) )  {                         // NRC_INCOMP
                    if (ncbCheck.ncb_retcode == 0xFF) {
                        /*
                         * Int 5C Vector set but NetBIOS not installed.
                         */
                        NDDELogError(MSG210, NULL);
                    } else {
                        /*
                         * NetBIOS Adapter Status Query on interface %1 failed: %2
                         */
                        NDDELogError(MSG211, LogString("%d", l),
                            LogString("0x%0X", ncbCheck.ncb_retcode), NULL);
                    }
                    /*
                     * Remove this lananum from the list.
                     */
                    nLananums--;
                    lananum[l] = lananum[nLananums];
                    HeapFreePtr(lpNcbListen[l]);
                    lpNcbListen[l] = lpNcbListen[nLananums];
                    if (nLananums == 0) {
                        ok = FALSE;
                    } else {
                        l--;
                    }
                    continue;
                }
            }
            // make dflt_pktsize maximum of available LAN Adapters
            dflt_pktsize = max((int)dflt_pktsize,1470);
        }
    }

    if( ok )  {
        /*
         * cycle through each lan adapter and add name
         */
        for( l=0; ok && l<nLananums; l++ )  {
            _fmemset( (LPSTR)&ncbAddName, 0, sizeof(ncbAddName) );
            ncbAddName.ncb_command = NCBADDNAME;
            for( i = 0; i < NCBNAMSZ; i++ )  {
                ncbAddName.ncb_callname[i] = ' ';
                ncbAddName.ncb_name[i] = ' ';
            }
            // ournodename will fit safely
            //do not NULL-terminate (leave ncb_name padded with spaces)
            strncpy( ncbAddName.ncb_name, ourNodeName, lstrlen(ourNodeName));
            ncbAddName.ncb_name[15] = NETBIOS_SPECIAL;
            ncbAddName.ncb_lana_num = lananum[l];
            Netbios( &ncbAddName );
            bNameAdded[l] = FALSE;
            switch( ncbAddName.ncb_retcode )  {
            case NRC_GOODRET:
                bNameAdded[l] = TRUE;
                break;
            case NRC_DUPNAME:
            case NRC_INUSE:
                /*  Node name "%1" already in use on network adapter %2 */
                NDDELogError(MSG212, (LPSTR) ourNodeName,
                    LogString("%d", l), NULL);
                ok = FALSE;
                break;
            default:
                /*  Unknown Error Code returned by adapter %1
                    while adding node name to network: %2 */
                NDDELogError(MSG213, LogString("%d", l),
                    LogString("0x%0X", ncbAddName.ncb_retcode), NULL);
                ok = FALSE;
            }
        }
    }
    if( ok )  {
        for( l=0; ok && l<nLananums; l++ )  {
            ok = SetupListen( l );
            if( !ok ) {
                NDDELogError(MSG214, NULL);
            }
        }
    }

    return ok;
}



void
NDDEShutdown( void )
{
    LPCONN      lpConn;
    CONNID      connId;
    int         i;
    int         stat;

    lpConn = lpConnHead;
    while( connId = (CONNID) lpConn )  {
        lpConn = lpConn->next;
        NDDEDeleteConnection( connId );
    }
    lpConnHead = lpConn;

    for( i=0; i<nLananums; i++ )  {
        if( lpNcbListen[i] )
            if (lpNcbListen[i]->ncb_cmd_cplt == NRC_PENDING) {
                CancelNCB( lananum[i], lpNcbListen[i] );
            } else {
                HangUpSession( lananum[i], lpNcbListen[i]->ncb_lsn );
            }
        if (stat = NetbiosDeleteName( lananum[i], ourNodeName )) {
            /*  Unable to delete our name "%1" from interface: status = %2  */
            NDDELogWarning(MSG205, (LPSTR) ourNodeName,
                LogString("0x%0X", stat), NULL);
        }
    }
}




CONNID
FAR PASCAL CreateConnId( void )
{
    LPCONN      lpConn;

    lpConn = HeapAllocPtr( hHeap, GMEM_MOVEABLE | GMEM_ZEROINIT,
        (DWORD) sizeof(CONN) );
    if( lpConn )  {
        lstrcpy( lpConn->nodeName, "[UNKNOWN]" );              // nodeName is MAX_NODE_NAME+1 (17) chars
        lpConn->sessionLsn              = 0;
        lpConn->state                   = 0;
        lpConn->wMaxUnAckPkts           = dflt_maxunack;
        lpConn->wPktSize                = dflt_pktsize;
        lpConn->bXmtVerifyMethod        = dflt_vermeth;
        lpConn->prev                    = (LPCONN) NULL;
        lpConn->next                    = lpConnHead;
        lpConn->wRcvState               = RS_IDLE;
        lpConn->wXmtState               = SS_IDLE;
        if( AllocateBuffers( lpConn ) )  {
            /* link into list */
            if( lpConnHead )  {
                lpConnHead->prev = lpConn;
            }
            lpConnHead = lpConn;
        } else {
            HeapFreePtr( lpConn );
            lpConn = NULL;
        }
    }
    return( (CONNID) lpConn );
}




VOID
FAR PASCAL FreeConnId( CONNID connId )
{
    LPCONN      lpConn;
    LPCONN      lpConnPrev;
    LPCONN      lpConnNext;

    if( connId )  {
        lpConn = (LPCONN) connId;
        lpConnPrev = lpConn->prev;
        lpConnNext = lpConn->next;
        if( lpConnPrev )  {
            lpConnPrev->next = lpConnNext;
        } else {
            lpConnHead = lpConnNext;
        }
        if( lpConnNext )  {
            lpConnNext->prev = lpConnPrev;
        }
        FreeBuffers( lpConn );
        HeapFreePtr( lpConn );
    }
}




BOOL
FAR PASCAL
SetupListen( int nLananum )
{
    PNCB       lpNCB;
    int         i;

    if( lpNcbListen[nLananum] == NULL )  {
        return( FALSE );
    }

    lpNCB = lpNcbListen[nLananum];
    _fmemset( (LPSTR)lpNCB, 0, sizeof(NCB) );
    lpNCB->ncb_command = NCBLISTEN | ASYNCH;
    for( i = 0; i < NCBNAMSZ; i++ )  {
        lpNCB->ncb_callname[i] = ' ';
        lpNCB->ncb_name[i] = ' ';
    }
    lpNCB->ncb_callname[0] = '*';
    for( i=0; i<15; i++ )  {
        if( ourNodeName[i] == '\0' )  {
            break;
        } else {
            lpNCB->ncb_name[i] = ourNodeName[i];
        }
    }
    lpNCB->ncb_name[15] = NETBIOS_SPECIAL;
    lpNCB->ncb_rto = 0;
    lpNCB->ncb_sto = 0;
    lpNCB->ncb_lana_num = lananum[nLananum];
    if( bUseNetbiosPost )  {
        lpNCB->ncb_post = NetbiosPost;
    }

    Netbios( lpNCB );

    return( TRUE );
}




CONNID
NDDEGetNewConnection( void )
{
    LPCONN  lpConn;
    int     i;
    CONNID  connIdWaitGet = (CONNID) NULL;
    static BOOL bNetDisappeared = FALSE;
    static BOOL bNetReturned = FALSE;


    for( i=0; !connIdWaitGet && i<nLananums; i++ )  {
        if( lpNcbListen[i]
            && (lpNcbListen[i]->ncb_cmd_cplt != NRC_PENDING ) )  {
            if( lpNcbListen[i]->ncb_retcode == 0x00 )  {                // NRC_GOODRET
                connIdWaitGet = CreateConnId();
                if( connIdWaitGet )  {
                    lpConn = (LPCONN) connIdWaitGet;
                    lpConn->sessionLsn  = lpNcbListen[i]->ncb_lsn;
                    lpConn->lananum     = lananum[i];
                    lpConn->state       = NDDE_CONN_OK | NDDE_READY_TO_XMT;
                    DIPRINTF(( "Someone called us, lsn: %d",
                            lpConn->sessionLsn ));
                    SetupReceive( lpConn );
                } else {
                    /* not enough memory for connection ... close it */
                    HangUpSession( lananum[i], lpNcbListen[i]->ncb_lsn );
                }
                SetupListen( i );
            } else {

                //  The net is down or the cable is unplugged.  Log an error
                //  infrequently, so we dont slow down the system
                //  No need to repeatedly retry without waiting at least 1 sec
                //
                if(lpNcbListen[i]->ncb_retcode != NRC_NOWILD)
                {
                    bNetReturned = FALSE;

                    if (bNetDisappeared == FALSE)
                    {
                        bNetDisappeared = TRUE;
                        /*  Listen failed: %1   */
                        NDDELogError(MSG206,
                            NetbiosErrorMsg( lpNcbListen[i]->ncb_retcode ), NULL );
                    }

                    Sleep(2000);
                    SetupListen( i );
                }
                else
                {
                    //  NRC_NOWILD is the error we get when the network comes back; we need to
                    //  free and then reinitialize the lpncblisten structures; also reset the log timeout
                    //

                    bNetDisappeared = FALSE;

                    if (bNetReturned == FALSE)
                    {
                        bNetReturned = TRUE;
                        NDDELogError(MSG206,
                            NetbiosErrorMsg( lpNcbListen[i]->ncb_retcode ), NULL );
                    }
                }
            }
        }
    }

    //  cancel all NCB calls before freeing the memory; InitLanaNums will reinitialize all NB settings
    //
    if (bNetReturned)
    {
        for( i=0; i<nLananums; i++ )
        {
            if ( lpNcbListen[i] )
            {
                if (lpNcbListen[i]->ncb_cmd_cplt == NRC_PENDING)
                    CancelNCB(lananum[i], lpNcbListen[i]);

                HeapFreePtr( lpNcbListen[i] );
                lpNcbListen[i] = NULL;
            }
        }

        InitLanaNums();
    }

    return( connIdWaitGet );
}




CONNID
	NDDEAddConnection( LPSTR nodeName )
{
    LPCONN      lpConn;
    CONNID      connId;
    BOOL        ok;
    int         i;


    if( lstrlen(nodeName) > 15 )  {
        NDDELogError(MSG207, nodeName, NULL);
        return( (CONNID) NULL );
    }

    connId = CreateConnId();
    if( connId )  {
        ok = TRUE;
        lpConn = (LPCONN) connId;
        _fstrncpy( lpConn->nodeName, nodeName, sizeof(lpConn->nodeName) );
        AnsiUpperBuff( lpConn->nodeName, lstrlen(lpConn->nodeName) );
        lpConn->state   = NDDE_CONN_CONNECTING;
        _fmemset( (LPSTR)&lpConn->ncbCall, 0, sizeof(NCB) );
        lpConn->ncbCall.ncb_command = NCBCALL | ASYNCH;
        for( i = 0; i < NCBNAMSZ; i++ )  {
            lpConn->ncbCall.ncb_callname[i] = ' ';
            lpConn->ncbCall.ncb_name[i] = ' ';
        }
        lstrcpy( tmpBuf, nodeName );
        AnsiUpperBuff( tmpBuf, lstrlen(tmpBuf) );
        _fstrncpy( lpConn->ncbCall.ncb_callname, tmpBuf, lstrlen(tmpBuf) );

        lstrcpy( tmpBuf, ourNodeName );
        _fstrncpy( lpConn->ncbCall.ncb_name, tmpBuf, lstrlen(tmpBuf) );
        lpConn->ncbCall.ncb_callname[15] = NETBIOS_SPECIAL;
        lpConn->ncbCall.ncb_name[15] = NETBIOS_SPECIAL;
        lpConn->ncbCall.ncb_rto = 0;
        lpConn->ncbCall.ncb_sto = 0;
        lpConn->current_lananum = last_good_lana;
        lpConn->lananum_count = 0;
        lpConn->lananum = lananum[last_good_lana];
        lpConn->ncbCall.ncb_lana_num = lpConn->lananum;
        if( bUseNetbiosPost )  {
            lpConn->ncbCall.ncb_post = NetbiosPost;
        }
        Netbios( &lpConn->ncbCall );
    }
    return( connId );
}




VOID
NDDEDeleteConnection( CONNID connId )
{
    if( connId )  {
        DoDisconnect( connId );
        FreeConnId( connId );
    }
}




VOID
FAR PASCAL
DoDisconnect( CONNID connId )
{
    LPCONN      lpConn;

    DIPRINTF(( "DoDisconnect" ));

    lpConn = (LPCONN) connId;
    if( lpConn )  {
        if( lpConn->sessionLsn > 0 )  {
            if( lpConn->wRcvState == RS_RECVING )  {
                CancelNCB( lpConn->lananum, &lpConn->ncbRecv );
                lpConn->wRcvState = RS_IDLE;
            }
            if( lpConn->wXmtState == SS_XMITING )  {
                CancelNCB( lpConn->lananum, &lpConn->ncbSend );
                lpConn->wXmtState = SS_IDLE;
            }
            HangUpSession( lpConn->lananum, lpConn->sessionLsn );
            lpConn->sessionLsn = 0;
        }
        lpConn->state &= ~NDDE_CONN_STATUS_MASK;
    }
}




DWORD
NDDEGetConnectionStatus( CONNID connId )
{
    LPCONN      lpConn;

    lpConn = (LPCONN) connId;
    if( lpConn )  {
        return( lpConn->state );
    } else {
        return( 0 );
    }
}




BOOL
NDDERcvPacket(
    CONNID  connId,
    LPVOID  lpRcvBuf,
    LPWORD  lpwLen,
    LPWORD  lpwPktStatus )
{
    LPCONN      lpConn;

    lpConn = (LPCONN) connId;
    if( lpConn
        && (lpConn->state & NDDE_CONN_OK)
        && (lpConn->state & NDDE_CALL_RCV_PKT) )  {

        *lpwLen         = lpConn->wLastPktSize;
        *lpwPktStatus   = lpConn->wLastPktStatus;
        _fmemcpy( lpRcvBuf, lpConn->lpRcvBuf, lpConn->wLastPktSize );

        /* get ready to receive another pkt */
        SetupReceive( lpConn );

        lpConn->state &= ~NDDE_CALL_RCV_PKT;
        return( TRUE );
    } else {
        return( FALSE );
    }
}




VOID
FAR PASCAL
SetupReceive( LPCONN lpConn )
{
    _fmemset( (LPSTR)&lpConn->ncbRecv, 0, sizeof(NCB) );
    lpConn->ncbRecv.ncb_command = NCBRECV | ASYNCH;
    lpConn->ncbRecv.ncb_lsn = lpConn->sessionLsn;
    lpConn->ncbRecv.ncb_buffer = lpConn->lpRcvBuf;
    lpConn->ncbRecv.ncb_length = (WORD)lpConn->wPktSize;
    if( bUseNetbiosPost )  {
        lpConn->ncbRecv.ncb_post = NetbiosPost;
    }
    lpConn->ncbRecv.ncb_lana_num = lpConn->lananum;
    Netbios( &lpConn->ncbRecv );
    lpConn->wRcvState = RS_RECVING;
}



BOOL
NDDEXmtPacket(
    CONNID  connId,
    LPVOID  lpXmtBuf,
    WORD    wPktLen )
{
    LPCONN      lpConn;
    LPNETPKT    lpPacket;

    lpConn = (LPCONN) connId;
    if( lpConn
        && (lpConn->state & NDDE_CONN_OK)
        && (lpConn->state & NDDE_READY_TO_XMT)
        && (lpConn->wXmtState == SS_IDLE) )  {

        /* copy contents in */
        _fmemcpy( lpConn->lpXmtBuf, lpXmtBuf, wPktLen );
        lpPacket = (LPNETPKT) lpConn->lpXmtBuf;
        lpPacket->np_pktSize = wPktLen - sizeof(NETPKT);

        PreparePktVerify( lpConn->bXmtVerifyMethod, lpPacket );

        _fmemset( (LPSTR)&lpConn->ncbSend, 0, sizeof(NCB) );
        lpConn->ncbSend.ncb_command      = NCBSEND | ASYNCH;
        lpConn->ncbSend.ncb_lsn          = lpConn->sessionLsn;
        lpConn->ncbSend.ncb_buffer   = (LPSTR)lpConn->lpXmtBuf;
        lpConn->ncbSend.ncb_length       =
            lpPacket->np_pktSize + sizeof(NETPKT);
        if( bUseNetbiosPost )  {
            lpConn->ncbSend.ncb_post = NetbiosPost;
        }
        lpConn->ncbSend.ncb_lana_num = lpConn->lananum;
        lpConn->state &= ~NDDE_READY_TO_XMT;
        lpConn->wXmtState = SS_XMITING;

        Netbios( &lpConn->ncbSend );
        return( TRUE );
    }
    return( FALSE );
}

#if DBG
VOID DumpNCB(PNCB n)
{
    DPRINTF(("NCB Cmd: %02X, RetCode: %02X, Lsn: %02X, Num: %02X",
        n->ncb_command, n->ncb_retcode, n->ncb_lsn, n->ncb_num));
    DPRINTF(("BufAddr: %08lX, Length: %d, CallName: %Fs, Name: %Fs",
        n->ncb_buffer, n->ncb_length, n->ncb_callname, n->ncb_name));
    DPRINTF(("Rto: %02X, Sto: %02X, PostAddr: %08lX, LanNum: %02X, CmdCplt: %02X",
        n->ncb_rto, n->ncb_sto, n->ncb_post, n->ncb_lana_num, n->ncb_cmd_cplt));
}
#endif  //DBG
VOID
LogDebugInfo(
    CONNID  connId,
    DWORD   dwFlags )
{
#if DBG
    LPCONN      lpConn;

    if( connId )  {
        lpConn = (LPCONN) connId;
        DPRINTF(( "\"%-16.16Fs\" session: %02X state:%08lX rcvState:%04X xmtState:%04X",
            (LPSTR)lpConn->nodeName, lpConn->sessionLsn, lpConn->state,
            lpConn->wRcvState, lpConn->wXmtState ));
        if (lpConn->wRcvState != RS_IDLE) {
            DPRINTF(( "Receiving NCB"));
            DumpNCB((PNCB)&lpConn->ncbRecv);
        }
        if (lpConn->wXmtState != SS_IDLE) {
            DPRINTF(( "Transmitting NCB"));
            DumpNCB((PNCB)&lpConn->ncbSend);
        }
    } else {
        DPRINTF(( "NetBIOS State ..." ));
        lpConn = lpConnHead;
        while( lpConn )  {
            LogDebugInfo( (CONNID) lpConn, dwFlags );
            lpConn = lpConn->next;
        }
        DPRINTF(( "" ));
    }
#endif  //DBG
}




BOOL
NDDESetConnectionConfig(
    CONNID  connId,
    WORD    wMaxUnAckPkts,
    WORD    wPktSize,
    LPSTR   lpszName )
{
    LPCONN      lpConn;

    lpConn = (LPCONN) connId;
    if( lpConn )  {
        lpConn->wPktSize = wPktSize;
        lpConn->wMaxUnAckPkts = wMaxUnAckPkts;
        _fstrncpy( lpConn->nodeName, lpszName, sizeof(lpConn->nodeName) );
    }
    return( TRUE );
}




BOOL
NDDEGetConnectionConfig(
    CONNID      connId,
    WORD FAR   *lpwMaxUnAckPkts,
    WORD FAR   *lpwPktSize,
    DWORD FAR  *lptimeoutRcvConnCmd,
    DWORD FAR  *lptimeoutRcvConnRsp,
    DWORD FAR  *lptimeoutMemoryPause,
    DWORD FAR  *lptimeoutKeepAlive,
    DWORD FAR  *lptimeoutXmtStuck,
    DWORD FAR  *lptimeoutSendRsp,
    WORD FAR   *lpwMaxNoResponse,
    WORD FAR   *lpwMaxXmtErr,
    WORD FAR   *lpwMaxMemErr )
{
    LPCONN      lpConn;

    lpConn = (LPCONN) connId;
    if( lpConn )  {
        *lpwPktSize = lpConn->wPktSize;
        *lpwMaxUnAckPkts = lpConn->wMaxUnAckPkts;
    } else {
        *lpwPktSize = dflt_pktsize;
        *lpwMaxUnAckPkts = dflt_maxunack;
    }
    *lptimeoutRcvConnCmd        = dflt_timeoutRcvConnCmd;
    *lptimeoutRcvConnRsp        = dflt_timeoutRcvConnRsp;
    *lptimeoutMemoryPause       = dflt_timeoutMemoryPause;
    *lptimeoutKeepAlive         = dflt_timeoutKeepAlive;
    *lptimeoutXmtStuck          = dflt_timeoutXmtStuck;
    *lptimeoutSendRsp           = dflt_timeoutSendRsp;
    *lpwMaxNoResponse           = dflt_maxNoResponse;
    *lpwMaxXmtErr               = dflt_maxXmtErr;
    *lpwMaxMemErr               = dflt_maxMemErr;

    return( TRUE );
}




BOOL
FAR PASCAL
AllocateBuffers( LPCONN lpConn )
{
    /* shouldn't be in the middle of stuff */
    assert( lpConn->wRcvState == RS_IDLE );
    assert( lpConn->wXmtState == SS_IDLE );

    /* get rid of old buffers */
    FreeBuffers( lpConn );

    lpConn->lpXmtBuf = HeapAllocPtr( hHeap, GMEM_MOVEABLE, lpConn->wPktSize );
    lpConn->lpRcvBuf = HeapAllocPtr( hHeap, GMEM_MOVEABLE, lpConn->wPktSize );
    if( lpConn->lpXmtBuf && lpConn->lpRcvBuf )  {
        lpConn->wXmtState       = SS_IDLE;
        lpConn->wRcvState       = RS_IDLE;
        return( TRUE );
    } else {
        FreeBuffers( lpConn );
        return( FALSE );
    }
}

VOID
FAR PASCAL
FreeBuffers( LPCONN lpConn )
{
    if( lpConn->lpXmtBuf )  {
        HeapFreePtr( lpConn->lpXmtBuf );
        lpConn->lpXmtBuf = NULL;
    }
    if( lpConn->lpRcvBuf )  {
        HeapFreePtr( lpConn->lpRcvBuf );
        lpConn->lpRcvBuf = NULL;
    }
}

VOID
FAR PASCAL
HangUpSession(
    BYTE    lananum,
    BYTE    sessionLsn )
{
    DIPRINTF(( "Hanging up session %d", sessionLsn ));
    _fmemset( (LPSTR)&ncbHangup, 0, sizeof(NCB) );
    ncbHangup.ncb_command = NCBHANGUP;
    ncbHangup.ncb_lsn = sessionLsn;
    ncbHangup.ncb_lana_num = lananum;
    Netbios( &ncbHangup );
}

VOID
FAR PASCAL
CancelNCB(
    BYTE    lananum,
    PNCB   lpNCBToCancel )
{
    PNCB       lpNCB;

    lpNCB = &ncbCancel;
    _fmemset( (LPSTR)lpNCB, 0, sizeof(NCB) );
    lpNCB->ncb_command = NCBCANCEL;
    lpNCB->ncb_buffer = (LPSTR) lpNCBToCancel;
    lpNCB->ncb_lana_num = lananum;
    Netbios( lpNCB );
}

BYTE
FAR PASCAL
NetbiosDeleteName(
    BYTE    lananum,
    LPSTR   lpszName )
{
    int                         i;

    _fmemset( (LPSTR)&ncbDeleteName, 0, sizeof(ncbDeleteName) );
    ncbDeleteName.ncb_command = NCBDELNAME;
    for( i = 0; i < NCBNAMSZ; i++ )  {
        ncbDeleteName.ncb_callname[i] = ' ';
        ncbDeleteName.ncb_name[i] = ' ';
    }

    // ournodename will fit safely
    //do not NULL-terminate (leave ncb_name padded with psace)
    strncpy( ncbDeleteName.ncb_name, ourNodeName, lstrlen(ourNodeName) );
    ncbDeleteName.ncb_name[15] = NETBIOS_SPECIAL;
    ncbDeleteName.ncb_lana_num = lananum;
    Netbios( &ncbDeleteName );
    return( ncbDeleteName.ncb_retcode );
}




LPSTR
FAR PASCAL
NetbiosErrorMsg( BYTE errCode )
{
    static      char    msg[ 100 ];
    PSTR        pMsg;
    int         id;

    wsprintf( msg, "%02X: ", errCode );
    pMsg = &msg[ lstrlen(msg) ];
    switch( errCode ) {
    case NRC_BUFLEN:
        id = NBE_NRC_BUFLEN;
        break;
//    case 0x02:
//        id = NBE_FULL_BUFFERS;
//        break;
    case NRC_ILLCMD:
        id = NBE_NRC_ILLCMD;
        break;
    case NRC_CMDTMO:
        id = NBE_NRC_CMDTMO;
        break;
    case NRC_INCOMP:
        id = NBE_NRC_INCOMP;
        break;
    case NRC_BADDR:
        id = NBE_NRC_BADDR;
        break;
    case NRC_SNUMOUT:
        id = NBE_NRC_SNUMOUT;
        break;
    case NRC_NORES:
        id = NBE_NRC_NORES;
        break;
    case NRC_SCLOSED:
        id = NBE_NRC_SCLOSED;
        break;
    case NRC_CMDCAN:
        id = NBE_NRC_CMDCAN;
        break;
//    case 0x0C:
//        id = NBE_PCDMA_FAILED;
//        break;
    case NRC_DUPNAME:
        id = NBE_NRC_DUPNAME;
        break;
    case NRC_NAMTFUL:
        id = NBE_NRC_NAMTFUL;
        break;
    case NRC_ACTSES:
        id = NBE_NRC_ACTSES;
        break;
//    case 0x10:
//        id = NBE_NRC_NOWILD;
//        break;
    case NRC_LOCTFUL:
        id = NBE_NRC_LOCTFUL;
        break;
    case NRC_REMTFUL:
        id = NBE_NRC_REMTFUL;
        break;
    case NRC_ILLNN:
        id = NBE_NRC_ILLNN;
        break;
    case NRC_NOCALL:
        id = NBE_NRC_NOCALL;
        break;
    case NRC_NOWILD:
        id = NBE_NRC_NOWILD;
        break;
    case NRC_INUSE:
        id = NBE_NRC_INUSE;
        break;
    case NRC_NAMERR:
        id = NBE_NRC_NAMERR;
        break;
    case NRC_SABORT:
        id = NBE_NRC_SABORT;
        break;
    case NRC_NAMCONF:
        id = NBE_NRC_NAMCONF;
        break;
//    case 0x1A:
//        id = NBE_INCOMPAT_REMOTE_DEV;
//        break;
    case NRC_IFBUSY:
        id = NBE_NRC_IFBUSY;
        break;
    case NRC_TOOMANY:
        id = NBE_NRC_TOOMANY;
        break;
    case NRC_BRIDGE:
        id = NBE_NRC_BRIDGE;
        break;
    case NRC_CANOCCR:
        id = NBE_NRC_CANOCCR;
        break;
//    case 0x25:
//        id = NBE_RESERVED_NAME;
//        break;
    case NRC_CANCEL:
        id = NBE_NRC_CANCEL;
        break;
    case NRC_DUPENV:
        id = NBE_NRC_DUPENV;
        break;
//    case 0x33:
//        id = NBE_MULT_REQ_FOR_SAME_SESSION;
//        break;
    case NRC_ENVNOTDEF:
        id = NBE_NRC_ENVNOTDEF;
        break;
    case NRC_OSRESNOTAV:
        id = NBE_NRC_OSRESNOTAV;
        break;
    case NRC_MAXAPPS:
        id = NBE_NRC_MAXAPPS;
        break;
    case NRC_NOSAPS:
        id = NBE_NRC_NOSAPS;
        break;
    case NRC_NORESOURCES:
        id = NBE_NRC_NORESOURCES;
        break;
    case NRC_INVADDRESS:
        id = NBE_NRC_INVADDRESS;
        break;
    case NRC_INVDDID:
        id = NBE_NRC_INVDDID;
        break;
    case NRC_LOCKFAIL:
        id = NBE_NRC_LOCKFAIL;
        break;
    case NRC_OPENERR:
        id = NBE_NRC_OPENERR;
        break;
    case NRC_SYSTEM:
        id = NBE_NRC_SYSTEM;
        break;
//    case 0x41:
//        id = NBE_HOT_CARRIER_REMOTE;
//        break;
//    case 0x42:
//        id = NBE_HOT_CARRIER_LOCAL;
//        break;
//    case 0x43:
//        id = NBE_NO_CARRIER;
//        break;
//    case 0x45:
//        id = NBE_INTERFACE_FAILURE;
//        break;
//    case 0x4E:
//        id = NBE_BITS_ON_TOO_LONG;
//        break;
//    case 0x4F:
//        id = NBE_BITS_ON;
//        break;
//    case 0x50:
//        id = NBE_ADAPTER_FAILED;
//        break;
//    case 0xF7:
//        id = NBE_DIR_INITIALIZE_ERROR;
//        break;
//    case 0xF8:
//        id = NBE_DIR_OPEN_ADAPTER_ERROR;
//        break;
//    case 0xF9:
//        id = NBE_IBM_LAN_INTERNAL_ERROR;
//        break;
//    case 0xFA:
//        id = NBE_NETBIOS_CARD_ERROR;
//        break;
//    case 0xFB:
//        id = NBE_NRC_OPENERR;
//        break;
//    case 0xFC:
//        id = NBE_SAP_FAILED;
//        break;
//    case 0xFD:
//        id = NBE_UNEXPECTED_ADAPTER_CLOSE;
//        break;
    default:
        if( (errCode >= 0x50) && (errCode <= 0xF6) )  {
            id =  NBE_HARDWARE_ERROR;
        } else {
            id =  NBE_UNKNOWN_ERROR;
        }
        break;
    }
    LoadString(hInst, id, pMsg, sizeof(msg) - lstrlen(msg));
    return( msg );
}


VOID
NetbiosPost( PNCB lpNCB )
{
    /* tell NetDDE that we're done */
    PostMessage( NB_hWndNetdde, WM_TIMER, 0, 0L );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ndeapi\client\oldstub.c ===
#include <stdlib.h>
#include <rpc.h>
#include <rpcndr.h>

// ====================================================================
//                MIDL allocate and free
// ====================================================================

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
void * MIDL_user_allocate(size_t len)
#else
void * _stdcall MIDL_user_allocate(size_t len)
#endif
{
    return(malloc(len));
}

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
void MIDL_user_free(void * ptr)
#else
void _stdcall MIDL_user_free(void * ptr)
#endif
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ndeapi\server\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt
IDL_NAME = ndeapi
INCS     = -I$(SDK_INC_PATH)  -I$(SDK_INC_PATH)\crt
EXTRN_DEPENDS = $(SDK_INC_PATH)\windef.h \
                ..\$(IDL_NAME).acf
CPP_FLAGS = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) $(C_DEFINES) $(NET_C_DEFINES)

$(O)\$(IDL_NAME)_s.c : ..\$(IDL_NAME).idl $(EXTRN_DEPENDS)
    midl -Oicf -robust -client none -oldnames -error all -ms_ext -c_ext $(CPP_FLAGS) ..\$(IDL_NAME).idl $(INCS) /out $(O) /acf ..\$(IDL_NAME).acf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ndeapi\server\nddeapis.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDEAPIU.C;1  2-Apr-93,16:21:24  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>
#include <rpcndr.h>
#include "ndeapi.h"
#include "debug.h"

char    tmpBuf2[500];
HANDLE  hThread;
DWORD   IdThread;

extern INT APIENTRY NDdeApiInit( void );



//
// CreateSids
//
// Create 3 Security IDs
//
// Caller must free memory allocated to SIDs on success.
//
// Returns: TRUE if successfull, FALSE if not.
//


BOOL
CreateSids(
    PSID                    *BuiltInAdministrators,
    PSID                    *System,
    PSID                    *AuthenticatedUsers
)
{
    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and System, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  BuiltInAdministrators)) {

        // error

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            //  sub-authority
                                         SECURITY_LOCAL_SYSTEM_RID,
                                         0,0,0,0,0,0,0,
                                         System)) {

        // error

        FreeSid(*BuiltInAdministrators);
        *BuiltInAdministrators = NULL;

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_AUTHENTICATED_USER_RID,
                                         0,0,0,0,0,0,0,
                                         AuthenticatedUsers)) {

        // error

        FreeSid(*BuiltInAdministrators);
        *BuiltInAdministrators = NULL;

        FreeSid(*System);
        *System = NULL;

    } else {
        return TRUE;
    }

    return FALSE;
}


//
// CreateRPCSd
//
// Creates a SECURITY_DESCRIPTOR with specific DACLs.  Modify the code to
// change. 
//
// Caller must free the returned buffer if not NULL.
//

PSECURITY_DESCRIPTOR
CreateRPCSd(
    VOID
)
{
    PSID                    AuthenticatedUsers;
    PSID                    BuiltInAdministrators;
    PSID                    System;

    if (!CreateSids(&BuiltInAdministrators,
                    &System,
                    &AuthenticatedUsers)) {

        // error

    } else {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        PSECURITY_DESCRIPTOR    pSd = NULL;
        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(AuthenticatedUsers) +
            GetLengthSid(BuiltInAdministrators) +
            GetLengthSid(System);

        pSd = LocalAlloc(LPTR,
                        SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

        if (!pSd) {

            // error

        } else {

            ACL                     *Acl;

            Acl = (ACL *)((BYTE *)pSd + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION)) {

                // error

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            FILE_ALL_ACCESS & ~(WRITE_DAC | 
                                                 WRITE_OWNER |
                                                 FILE_CREATE_PIPE_INSTANCE),
                                            AuthenticatedUsers)) {

                // Failed to build the ACE granting "Authenticated users"
                // (SYNCHRONIZE | GENERIC_READ) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            BuiltInAdministrators)) {

                // Failed to build the ACE granting "Built-in Administrators"
                // GENERIC_ALL access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            System)) {

                // Failed to build the ACE granting "System"
                // GENERIC_ALL access.

            } else if (!InitializeSecurityDescriptor(pSd,
                                                     SECURITY_DESCRIPTOR_REVISION)) {

                // error

            } else if (!SetSecurityDescriptorDacl(pSd,
                                                  TRUE,
                                                  Acl,
                                                  FALSE)) {

                // error

            } else {
                FreeSid(AuthenticatedUsers);
                FreeSid(BuiltInAdministrators);
                FreeSid(System);

                return pSd;
            }

            LocalFree(pSd);
        }

        FreeSid(AuthenticatedUsers);
        FreeSid(BuiltInAdministrators);
        FreeSid(System);
    }

    return NULL;
}


DWORD StartRpc( DWORD x ) {
    RPC_STATUS status;
    unsigned char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszEndpoint         = "\\pipe\\nddeapi";
    unsigned int    cMinCalls           = 1;
    unsigned int    cMaxCalls           = 20;

    if( NDdeApiInit() ) {

        SECURITY_DESCRIPTOR     *pSd;

        pSd = CreateRPCSd();

        if (!pSd) {
           DPRINTF(("CreateRPCSD failed."));

           return 0;
        } else {

            status = RpcServerUseProtseqEp(
                pszProtocolSequence,
                cMaxCalls,
                pszEndpoint,
                pSd);

            LocalFree(pSd);
        }

        if (status)
           {
           DPRINTF(("RpcServerUseProtseqEp returned 0x%x", status));
           return( 0 );
           }

        status = RpcServerRegisterIf(
            nddeapi_ServerIfHandle,
            NULL,
            NULL);

        if (status)
           {
           DPRINTF(("RpcServerRegisterIf returned 0x%x", status));
           return( 0 );
           }

        status = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_WINNT, NULL, NULL);

        if (status)
           {
           DPRINTF(("RpcServerRegisterAuthInfo returned 0x%x", status));
           }


        status = RpcServerListen(
            cMinCalls,
            cMaxCalls,
            FALSE /* don't wait*/);

    }
    return 0;
}

// ====================================================================
//                MIDL allocate and free
// ====================================================================

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
void * MIDL_user_allocate(size_t len)
#else
void * _stdcall MIDL_user_allocate(size_t len)
#endif
{
    return(LocalAlloc(LPTR,len));
}

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
void MIDL_user_free(void * ptr)
#else
void _stdcall MIDL_user_free(void * ptr)
#endif
{
    LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ndeapi\server\nddeapip.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDEAPIP.C;2  11-Feb-93,11:28:36  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin

    NDDEAPIP.C

    Network DDE Share access Api implementation routines.

    Revisions:
    12-92   BillU.  Wonderware secure DSDM port.
    12-92   ColeC.  Wonderware RPC'd for NT..
     3-93   IgorM.  Wonderware new APIs for NT. General overhaul and engine swap.

   $History: End */


#include <windows.h>
#include <rpc.h>
#include <rpcndr.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>

#include "nddeapi.h"
#include "nddesec.h"
#include "nddelog.h"
#include "nddemsg.h"
#define SKIP_DEBUG_WIN32
#include "debug.h"
#include "hexdump.h"
#include "ndeapi.h"
#include "shrtrust.h"
#include "unddesi.h"
#include "proflspt.h"
#include "mbstring.h"

//#define NDDE_DEBUG
#if DBG
BOOL    bDebugDSDMInfo      = FALSE;
BOOL    bDebugDSDMErrors    = FALSE;
#endif

static PSECURITY_DESCRIPTOR    pDsDmSD;
static CRITICAL_SECTION        DsDmCriticalSection;
static WCHAR                   szTrustedShareKey[TRUSTED_SHARES_KEY_MAX] = L"";


//
// Generic mapping for share objects
//

static GENERIC_MAPPING        ShareGenMap = {
    NDDE_SHARE_GENERIC_READ,
    NDDE_SHARE_GENERIC_WRITE,
    NDDE_SHARE_GENERIC_EXECUTE,
    NDDE_SHARE_GENERIC_ALL
};


// internal api declarations

unsigned long
_wwNDdeGetShareSecurityA(
    unsigned char * lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor buffer
    unsigned long   cbSD,           // and length for SD buffer
    unsigned long   bRemoteCall,    // RPC client (not local) call
    unsigned long * lpcbSDRequired, // number of bytes needed
    unsigned long * lpnSizeReturned // number actually written
);

unsigned long
_wwNDdeGetShareSecurityW(
    wchar_t *       lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor buffer
    unsigned long   cbSD,           // and length for SD buffer
    unsigned long   bRemoteCall,    // RPC client (not local) call
    unsigned long * lpcbSDRequired, // number of bytes needed
    unsigned long * lpnSizeReturned // number actually written
);

unsigned long _wwNDdeShareGetInfoA(
    unsigned char   *lpszShareName,     // name of share
    unsigned long    nLevel,            // info level must be 2
    byte            *lpBuffer,          // gets struct
    unsigned long    cBufSize,          // sizeof buffer
    unsigned long   *lpnTotalAvailable, // number of bytes available
    unsigned short  *lpnItems,          // item mask for partial getinfo
                                        // (must be 0)
    unsigned long *lpnSizeToReturn,

    unsigned long *lpnSn,
    unsigned long *lpnAt,
    unsigned long *lpnIt
);

unsigned long
_wwNDdeShareGetInfoW(
    wchar_t        *lpszShareName,      // name of share
    unsigned long   nLevel,             // info level must be 2
    byte           *lpBuffer,           // gets struct
    unsigned long   cBufSize,           // sizeof buffer
    unsigned long  *lpnTotalAvailable,  // number of bytes available
    unsigned short *lpnItems,           // item mask for partial getinfo
                                        // (must be 0)
    unsigned long   bRemoteCall,        // RPC client (not local) call
    unsigned long  *lpnSizeToReturn,
    unsigned long  *lpnSn,
    unsigned long  *lpnAt,
    unsigned long  *lpnIt
);
    



/**************************************************************
    external refs
***************************************************************/
BOOL
BuildNewSecurityDescriptor(
    PSECURITY_DESCRIPTOR    pNewSecurityDescriptor,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pPreviousSecurityDescriptor,
    PSECURITY_DESCRIPTOR    pUpdatedSecurityDescriptor );

PSECURITY_DESCRIPTOR
AllocCopySecurityDescriptor(
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    PDWORD                  pLength );


BOOL
NDdeParseAppTopicListW(
    LPWSTR  appTopicList,DWORD cchCount,
    LPWSTR *pOldStr,
    LPWSTR *pNewStr,
    LPWSTR *pStaticStr,
    PLONG   pShareType );

unsigned long  BuildRegistrySharePath(
                  LPWSTR lpszShareName,
                  DWORD cchCount,
                  LPWSTR pszShareRegistryPath);

BOOL
NDdeParseItemList (
    LPWSTR      itemList,DWORD cchCount,
    LONG        cNumItems,
    PLONG       plSize );


BOOL ValidateMultiSzW( LPWSTR pMz, DWORD cchCount,DWORD *pcbSize);
BOOL ValidateAppTopicListW( LPWSTR appTopicList, DWORD cchCount,DWORD *pcbSize);

BOOL
UpdateDSDMModifyId(LONG lSerialId[]);

BOOL
UpdateShareModifyId(
    HKEY    hKey,
    LONG    lSerialId[]);

BOOL
GetShareSerialNumber(
    PWCHAR  pwShareName,
    LPBYTE  lpSerialNumber);

BOOL
GetShareNameSD(
    HKEY                    hKey,
    PSECURITY_DESCRIPTOR   *ppSD,
    DWORD                  *pcbData );

BOOL
NDdeShareAccessCheckAudit(
    LPWSTR                  lpszShareName,
    PSECURITY_DESCRIPTOR    pSD,
    DWORD                   dwDesiredAccess,
    PGENERIC_MAPPING        pgm,
    BOOL                    fObjectCreation,
    BOOL                    fObjectDeletion,
    DWORD                  *pGrantedAccess,
    BOOL                   *pStatus );



BOOL
GetTokenHandleRead( PHANDLE pTokenHandle );

HANDLE
OpenCurrentUserKey(ULONG DesiredAccess);

// dll instance saved in libmain
// Not needed in the server
//HINSTANCE        hInst;

GENERIC_MAPPING ShareDBGenericMapping = { NDDE_SHAREDB_EVERYONE,
                                          NDDE_SHAREDB_USER,
                                          NDDE_SHAREDB_USER,
                                          NDDE_SHAREDB_ADMIN };

GENERIC_MAPPING ShareGenericMapping = { NDDE_SHARE_GENERIC_READ,
                                        NDDE_SHARE_GENERIC_WRITE,
                                        NDDE_SHARE_GENERIC_EXECUTE,
                                        NDDE_SHARE_GENERIC_ALL };

// if ImpersonateAndSetup returns TRUE ReverAtCleanup must
// be called to release the Critical Section.
BOOL ImpersonateAndSetup(BOOL RpcClient )                                
{                                                                   
    RPC_STATUS              rpcStatus;                             
                                                                    
    EnterCriticalSection( &DsDmCriticalSection );                  
    if( RpcClient ) {                                               
        rpcStatus = RpcImpersonateClient( 0 );                      
        if( rpcStatus != RPC_S_OK )  {                              
            LeaveCriticalSection( &DsDmCriticalSection );           
            NDDELogErrorW( MSG400, LogStringW( L"%d", rpcStatus ),  
                NULL );                                             
            return FALSE;                              
        }                                                           
    }    

    return TRUE;
}

BOOL RevertAndCleanUp(BOOL RpcClient )                                   
{    
    BOOL fRevert = TRUE;

    if( RpcClient ) {                                               
        fRevert = RevertToSelf();                                             
    }     

    LeaveCriticalSection( &DsDmCriticalSection );      

    return fRevert;
}


/**************************************************************

    NetDDE DSDM SHARE ACCESS API

***************************************************************/


/*
    Access Permission Checks
*/

// returns TRUE if access is granted for either the User or Share Permissions
unsigned long NDdeShareAccessCheck(BOOL RpcClient,
                          LPWSTR lpszShareName,PSECURITY_DESCRIPTOR pSnSDUser,
                          DWORD dwUserPermissions,DWORD dwSharePermissions,
                          BOOL fObjectCreation,BOOL fObjectDeletion,
                             /* in/out */ HANDLE   *phClientToken)
{
    unsigned long  ddeErr = NDDE_ACCESS_DENIED;
    DWORD dwGrantedAccess;
    BOOL fStatus;
    BOOL OK;

    if (!ImpersonateAndSetup(RpcClient))
    {
        return NDDE_ACCESS_DENIED;
    }

    if (NULL != pSnSDUser && 0 != dwUserPermissions)
    {
        OK = NDdeShareAccessCheckAudit( lpszShareName, pSnSDUser, dwUserPermissions,
                               &ShareGenericMapping, fObjectCreation, fObjectDeletion,
                               &dwGrantedAccess, &fStatus );

        if( OK && fStatus ) 
        {
            ddeErr = NDDE_NO_ERROR;
        }

    }

    if (NDDE_NO_ERROR != ddeErr && 0 != dwSharePermissions)
    {

        OK = NDdeShareAccessCheckAudit(lpszShareName, pDsDmSD,
            dwSharePermissions, &ShareDBGenericMapping, fObjectCreation,fObjectDeletion,
            &dwGrantedAccess, &fStatus );

        if( OK && fStatus ) 
        {
            ddeErr = NDDE_NO_ERROR;
        }

    }

    if ( (NDDE_NO_ERROR == ddeErr) && (NULL !=  phClientToken))
    {
        // if caller requested the client token return it
        if( !GetTokenHandleRead(phClientToken) ) 
        {
            ddeErr = NDDE_ACCESS_DENIED; // if can't get clientToken when request then don't have access.
        }
    }

    RevertAndCleanUp(RpcClient);
    
    return ddeErr;
}


/*
    Share Name Validation
*/

// this one needs to be exported for clipbook(clausgi 8/4/92)
BOOL WINAPI
NDdeIsValidShareNameW( LPWSTR shareName )
{
    DWORD len;

    if ( !shareName ) {
        return FALSE;
    }

    len = wcslen(shareName);

    if ( len < 1 || len > MAX_NDDESHARENAME ) {
        return FALSE;
    }

    // share name cannot contain '=' because of .ini syntax!
    if ( wcschr(shareName, L'=') || wcschr(shareName, L'\\')) {
        return FALSE;
    }
    return TRUE;
}

// sets sup and validates the ShareInfo Information 
// its okay for the out params to be null.
unsigned long GetDDEShareInfo(unsigned long   nLevel,
                              byte *lpBuffer,unsigned long   cBufSize,
                             byte* psn,unsigned long   lsn, 
                             byte *pat, unsigned long   lat,
                             byte * pSD,unsigned long   lsd,
                             byte *pit,unsigned long   lit,
                             // out params
                             PUNDDESHAREINFO  *plpDdeShare,
                             LPWSTR *ppOldStr,
                             LPWSTR *ppNewStr,
                             LPWSTR  *ppStaticStr,
                             LONG *plShareType,
                             LONG *plItemList,
                             PSECURITY_DESCRIPTOR    *ppShareSD)
{

    PUNDDESHAREINFO pLocalDdeShareInfo;

    // all out params except the security secriptor need to be set.
    if (NULL == plpDdeShare || NULL == ppOldStr || NULL == ppNewStr
            || NULL == ppStaticStr || NULL == plShareType || NULL == plItemList)
    {
        return  NDDE_INVALID_PARAMETER;
    }

    if ( nLevel != 2 )  
    {
        return NDDE_INVALID_LEVEL;
    }


    // setup the shareInfo Fields
    if(lpBuffer == NULL ) 
    {
        return NDDE_INVALID_PARAMETER;
    }

    if ( cBufSize < sizeof(UNDDESHAREINFO) ) 
    {
        return NDDE_BUF_TOO_SMALL;
    }


    pLocalDdeShareInfo = (PUNDDESHAREINFO)lpBuffer;

    /* Fixup the pointers in the UNDDESHAREINFO strucure */
    pLocalDdeShareInfo->lpszShareName    = (LPWSTR)psn;
    pLocalDdeShareInfo->lpszAppTopicList = (LPWSTR)pat;
    pLocalDdeShareInfo->lpszItemList     = (LPWSTR)pit;


    // validate the Security Descriptor even if not going to set the out param.
    if (lsd != 0)
    {
        if (!IsValidSecurityDescriptor(pSD))
        {
            return(NDDE_INVALID_SECURITY_DESC);
        }
        else // 6-25-93 a-mgates Added this else {}.
        {
            if (ppShareSD)
            {
                *ppShareSD = pSD;
            }
        }
    }
    else
    {
        if (ppShareSD)
        {
            *ppShareSD = NULL;
        }
    }


    // validate the shareName

    // checks if the buf size  is at least a single wchar 
    // and that it fits into an even number of wchars
    // strange check for if even number since if WCHAR size changed the check
    //   wouldn't work.
    if (lsn < sizeof (WCHAR) || (lsn & (sizeof (WCHAR) - 1)) != 0) {
        return FALSE;
    }

    // make sure buffer isn't isn't null and is valid memory
    if ( ((PWCHAR)psn == NULL) || (IsBadReadPtr(psn,lsn) != 0) ) {
        return FALSE;
    }

    // makeSure null terminated.
    if (((PWCHAR)psn)[lsn/sizeof (WCHAR) - 1] != L'\0') {
        return FALSE;
    }

    if ( !NDdeIsValidShareNameW( pLocalDdeShareInfo->lpszShareName )) {
        return NDDE_INVALID_SHARE;
    }


    // validate and Parse the TopicList.
    if ( !NDdeParseAppTopicListW( pLocalDdeShareInfo->lpszAppTopicList,lat/sizeof(WCHAR),
                                  ppOldStr, ppNewStr, ppStaticStr,
                                  plShareType)) {
        return NDDE_INVALID_TOPIC;
    }

     
    // validate and parse the Item List
    if ( !NDdeParseItemList ( pLocalDdeShareInfo->lpszItemList,lit/sizeof(WCHAR),
                              pLocalDdeShareInfo->cNumItems, plItemList )) 
    {
        return NDDE_INVALID_ITEM_LIST;
    }


    *plpDdeShare = pLocalDdeShareInfo;

    return NDDE_NO_ERROR;
}





//=================== API FUNCTIONS ============================
//
//  Dde Share manipulation functions in NDDEAPI.DLL
//
//=================== API FUNCTIONS ============================



unsigned long
wwNDdeShareAddW(
    unsigned long   nLevel,       // info level must be 2
    byte          * lpBuffer,     // contains struct, data
    unsigned long   cBufSize,     // sizeof supplied buffer
    byte          * psn,
    unsigned long   lsn,
    byte          * pat,
    unsigned long   lat,
    byte          * pSD,
    unsigned long   lsd,
    byte          * pit,
    unsigned long   lit
)
{
    PUNDDESHAREINFO         lpDdeShare;
    PSECURITY_DESCRIPTOR    pShareSD = pSD, pNewSD;
    LONG                    lRtn;
    HKEY                    hKey;
    DWORD                   dwDisp;
    WCHAR                   szShareAdd[DDE_SHARE_KEY_MAX];
    LONG                    lItemList;
    BOOL                    OK;
    DWORD                   dwDesiredShareDBAccess = 0;
    LPWSTR                  pOldStr;
    LPWSTR                  pNewStr;
    LPWSTR                  pStaticStr;
    LONG                    lShareType;
    LONG                    lSerialNumber[2];
    HANDLE                  hClientToken;
    unsigned long           ddeErr;

    ddeErr =  GetDDEShareInfo(nLevel,lpBuffer,cBufSize,psn,lsn, 
                             pat,lat,pSD,lsd,
                             pit,lit,
                             &lpDdeShare,&pOldStr, &pNewStr,&pStaticStr,
                             &lShareType,&lItemList,&pShareSD);

    if (ddeErr != NDDE_NO_ERROR)
    {
        return ddeErr;
    }


    /*  Make sure the caller has AddShare(As) access rights. */
    dwDesiredShareDBAccess = NDDE_SHAREDB_ADD;
    if (lpDdeShare->fService) {
        dwDesiredShareDBAccess |= NDDE_SHAREDB_FSERVICE;
    }


    ddeErr =  NDdeShareAccessCheck(TRUE,lpDdeShare->lpszShareName,NULL,0,
                             dwDesiredShareDBAccess,
                             TRUE,FALSE,NULL);

    if (NDDE_NO_ERROR != ddeErr)
    {
        return ddeErr;
    }

#ifdef NDDE_DEBUG
    DPRINTF(("Revision               = (%d)", lpDdeShare->lRevision));
    DPRINTF(("ShareName              = (%ws)", lpDdeShare->lpszShareName));
    DPRINTF(("ShareType              = (%d)", lpDdeShare->lShareType));
    DPRINTF(("ShareType*             = (%d)", lShareType));
    DPRINTF(("AppTopicList"));
    DPRINTF(("  Old-style link share = (%ws)", pOldStr));
    DPRINTF(("  New-style link share = (%ws)", pNewStr));
    DPRINTF(("  Static data share    = (%ws)", pStaticStr));
    DPRINTF(("SharedFlag             = (%d)", lpDdeShare->fSharedFlag));
    DPRINTF(("ServiceFlag            = (%d)", lpDdeShare->fService));
    DPRINTF(("StartAppFlag           = (%d)", lpDdeShare->fStartAppFlag));
    DPRINTF(("nCmdShow               = (%d)", lpDdeShare->nCmdShow));
    DPRINTF(("SerialNumber           = (%d, %d)", lpDdeShare->qModifyId[0],
                                                 lpDdeShare->qModifyId[1]));
    DPRINTF(("NumItems               = (%d)", lpDdeShare->cNumItems));
    {
        LPWSTR  lpszItem = lpDdeShare->lpszItemList;
        int     n= 0;
        for( n=0; n<lpDdeShare->cNumItems; n++ )  {
            DPRINTF(("ItemList[%d]             = (%ws)", n, lpszItem));
            lpszItem = lpszItem + wcslen(lpszItem) + 1;
        }
    }
#endif

    ddeErr = BuildRegistrySharePath(lpDdeShare->lpszShareName,DDE_SHARE_KEY_MAX,szShareAdd);
    if (ddeErr != NDDE_NO_ERROR)
    {
        return ddeErr; 
    }

    lRtn = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
            szShareAdd,
            0,
            L"NetDDEShare",
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            NULL,   /* use default inherited from container */
            &hKey,
            &dwDisp );

    if( lRtn == ERROR_SUCCESS ) {
        if (dwDisp == REG_OPENED_EXISTING_KEY) {
            RegCloseKey( hKey );
            return NDDE_SHARE_ALREADY_EXIST;
        }
        OK = UpdateDSDMModifyId(lSerialNumber);
        if (!OK) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }

        lpDdeShare->qModifyId[0] = lSerialNumber[0];
        lpDdeShare->qModifyId[1] = lSerialNumber[1];

        /*  Set the key values. */

        lRtn = RegSetValueExW( hKey,
                   L"ShareName",
                   0,
                   REG_SZ,
                   (LPBYTE)lpDdeShare->lpszShareName,
                   sizeof(WCHAR) *
                   (wcslen( lpDdeShare->lpszShareName ) + 1) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"OldStyleLink",
                   0,
                   REG_SZ,
                   (LPBYTE)pOldStr,
                   sizeof(WCHAR) * (wcslen( pOldStr ) + 1) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"NewStyleLink",
                   0,
                   REG_SZ,
                   (LPBYTE)pNewStr,
                   sizeof(WCHAR) * (wcslen( pNewStr ) + 1) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"StaticDataLink",
                   0,
                   REG_SZ,
                   (LPBYTE)pStaticStr,
                   sizeof(WCHAR) * (wcslen( pStaticStr ) + 1) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"ItemList",
                   0,
                   REG_MULTI_SZ,
                   (LPBYTE)lpDdeShare->lpszItemList,
                   sizeof(WCHAR) * lItemList );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }

        lRtn = RegSetValueExW( hKey,
                   L"Revision",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->lRevision,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"ShareType",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lShareType,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"SharedFlag",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->fSharedFlag,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"Service",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->fService,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"StartAppFlag",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->fStartAppFlag,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"fuCmdShow",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->nCmdShow,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }


        OK = ImpersonateAndSetup( TRUE );
        if( !OK) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_ACCESS_DENIED;
        }

        if( !GetTokenHandleRead( &hClientToken ) ) {
       #if DBG
            if (bDebugDSDMErrors) {
                DPRINTF(("Could not get client token handle."));
            }
       #endif
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );

            RevertAndCleanUp(TRUE);
            return NDDE_ACCESS_DENIED;
        }
        RevertAndCleanUp(TRUE);

        OK = CreatePrivateObjectSecurity(
                   pDsDmSD,            // psdParent
                   pShareSD,        // psdCreator
                       &pNewSD,            // lppsdNew
                       FALSE,            // fContainer
                       hClientToken,        // hClientToken
                       &ShareGenMap);        // pgm


        CloseHandle(hClientToken);

        if (!OK) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }

        lRtn = RegSetValueExW( hKey,
                   L"SecurityDescriptor",
                   0,
                   REG_BINARY,
                   pNewSD,
                   GetSecurityDescriptorLength( pNewSD ) );

        OK = DestroyPrivateObjectSecurity(&pNewSD);
    #if DBG
        if (!OK && bDebugDSDMErrors) {
            DPRINTF(("Unable to DestroyPrivateObject(): %d", GetLastError()));
        }
    #endif

        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"NumItems",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->cNumItems,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        OK = UpdateShareModifyId(hKey, lSerialNumber);

        // no longer needed
        // RegCloseKey( hKey ); ALREADY CLOSED BY UpdateShareModifyId!

        if (!OK) {
            return NDDE_REGISTRY_ERROR;
        }
    } else {
        return NDDE_REGISTRY_ERROR;
    }

    return NDDE_NO_ERROR;
}


/*
    Delete a Share
*/

unsigned long
wwNDdeShareDelA(
    unsigned char * lpszShareName, // name of share to delete
    unsigned long   wReserved      // reserved for force level (?) 0 for now
)
{
    UINT        uRtn;
    WCHAR       lpwShareName[MAX_NDDESHARENAME *2];

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    if (0 == MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME *2))
    {
        return NDDE_INVALID_SHARE;
    }

    uRtn = wwNDdeShareDelW( lpwShareName, wReserved );

    return uRtn;
}

unsigned long
wwNDdeShareDelW(
    wchar_t *     lpszShareName,  // name of share to delete
    unsigned long wReserved       // reserved for force level (?) 0 for now
)
{
    WCHAR                   szShareDel[DDE_SHARE_KEY_MAX];
    LONG                    lRtn;
    PSECURITY_DESCRIPTOR    pSnSD;
    DWORD                   cbData;
    HKEY                    hKey;
    BOOL                    OK;
    DWORD                   dwDesiredUserAccess = 0;
    DWORD                   dwDesiredShareDBAccess = 0;
    ULONG                   ddeErr;

    if( lpszShareName == (wchar_t *) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }
    if ( !NDdeIsValidShareNameW(lpszShareName) ) {
        return NDDE_INVALID_SHARE;
    }
    if ( wReserved != 0 ) {
        return NDDE_INVALID_PARAMETER;
    }

 
    ddeErr = BuildRegistrySharePath(lpszShareName,DDE_SHARE_KEY_MAX,szShareDel);
    if (ddeErr != NDDE_NO_ERROR)
    {
        return ddeErr; 
    }

    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                  szShareDel,
                  0,
                  KEY_WRITE | KEY_READ | DELETE,
                  &hKey );

    if( lRtn != ERROR_SUCCESS ) {
        return NDDE_ACCESS_DENIED; 
    } else {
        OK = GetShareNameSD( hKey, &pSnSD, &cbData );
        RegCloseKey( hKey );
        if( !OK ) {
            return NDDE_REGISTRY_ERROR;
        }
        /*  Can have Ds rights on the ShareDB or DELETE on the ShareName. */
        /*  Make sure the caller has DelShare(Ds) access rights. */

        dwDesiredUserAccess = DELETE;
        dwDesiredShareDBAccess = NDDE_SHAREDB_DELETE;

        ddeErr =  NDdeShareAccessCheck(TRUE,lpszShareName,pSnSD,dwDesiredUserAccess,
                             dwDesiredShareDBAccess,
                             FALSE,TRUE,NULL);


        LocalFree(pSnSD);

        if (NDDE_NO_ERROR != ddeErr)
        {
            return ddeErr;
        }


        lRtn = RegDeleteKeyW( HKEY_LOCAL_MACHINE, szShareDel );
        if( lRtn != ERROR_SUCCESS ) {
            NDDELogErrorW( MSG402, szShareDel, LogStringW( L"%d", lRtn ),
                LogStringW( L"%d", GetLastError() ), NULL );
            return NDDE_REGISTRY_ERROR;
        }
    }

    return NDDE_NO_ERROR;
}


/*
    Get Share Security
*/

unsigned long
wwNDdeGetShareSecurityA(
    unsigned char * lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor buffer
    unsigned long   cbSD,           // and length for SD buffer
    unsigned long   bRemoteCall,    // RPC client (not local) call
    unsigned long * lpcbSDRequired, // number of bytes needed
    unsigned long * lpnSizeReturned // number actually written
)
{
    return  _wwNDdeGetShareSecurityA( lpszShareName, si, pSD, cbSD,
        TRUE /*  if comes from RPC enforce as a RemoteCall */, lpcbSDRequired, lpnSizeReturned );

}


unsigned long
_wwNDdeGetShareSecurityA(
    unsigned char * lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor buffer
    unsigned long   cbSD,           // and length for SD buffer
    unsigned long   bRemoteCall,    // RPC client (not local) call
    unsigned long * lpcbSDRequired, // number of bytes needed
    unsigned long * lpnSizeReturned // number actually written
)
{
    UINT        uRtn;
    WCHAR       lpwShareName[MAX_NDDESHARENAME *2];

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    if (0 == MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME *2 ))
    {
        return  NDDE_INVALID_SHARE;
    }

    uRtn = _wwNDdeGetShareSecurityW( lpwShareName, si, pSD, cbSD,
        bRemoteCall, lpcbSDRequired, lpnSizeReturned );

    return uRtn;
}

unsigned long
wwNDdeGetShareSecurityW(
    wchar_t *       lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor buffer
    unsigned long   cbSD,           // and length for SD buffer
    unsigned long   bRemoteCall,    // RPC client (not local) call
    unsigned long * lpcbSDRequired, // number of bytes needed
    unsigned long * lpnSizeReturned // number actually written
)
{
    return _wwNDdeGetShareSecurityW( lpszShareName, si, pSD, cbSD,
        TRUE /*  if comes from RPC enforce as a RemoteCall */, lpcbSDRequired, lpnSizeReturned );
}


unsigned long
_wwNDdeGetShareSecurityW(
    wchar_t *       lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor buffer
    unsigned long   cbSD,           // and length for SD buffer
    unsigned long   bRemoteCall,    // RPC client (not local) call
    unsigned long * lpcbSDRequired, // number of bytes needed
    unsigned long * lpnSizeReturned // number actually written
)
{
    WCHAR                   szShareSet[DDE_SHARE_KEY_MAX];
    LONG                    lRtn;
    HKEY                    hKey;
    BOOL                    OK;
    DWORD                   dwDesiredUserAccess = 0;
    DWORD                   dwDesiredShareDBAccess = 0;
    PSECURITY_DESCRIPTOR    pSnSD;
    DWORD                   cbData;
    ULONG                   ddeErr;


    if (NULL == lpnSizeReturned)
    {
        return NDDE_INVALID_PARAMETER;
    }

    *lpnSizeReturned = 0L;      /* assume nothing is returned */

    if( lpszShareName == (wchar_t *) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }
    if ( !NDdeIsValidShareNameW(lpszShareName) ) {
        return NDDE_INVALID_SHARE;
    }

    if (lpcbSDRequired == NULL) {
        return(NDDE_INVALID_PARAMETER);
    }
    // check for share existence - must exist for GetInfo
    ddeErr = BuildRegistrySharePath(lpszShareName,DDE_SHARE_KEY_MAX,szShareSet);
    if (ddeErr != NDDE_NO_ERROR)
    {
        return ddeErr; 
    }

    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
        szShareSet,
        0,
        KEY_READ,
        &hKey );
    if( lRtn != ERROR_SUCCESS )  {
    return NDDE_SHARE_NOT_EXIST;
    }

    /*  Make sure the caller has proper access rights. */
    /*  **********Read the key security info here. **************/
    OK = GetShareNameSD( hKey, &pSnSD, &cbData );
    RegCloseKey( hKey );
    if( !OK ) {
    return NDDE_REGISTRY_ERROR;
    }
    if (!bRemoteCall) {
    *lpcbSDRequired = cbData;          // number of bytes needed
    if ((cbSD < cbData) || (pSD == NULL) || (IsBadWritePtr(pSD,cbSD) != 0)) {
        LocalFree( pSnSD );
        return(NDDE_BUF_TOO_SMALL);
    } else {
        *lpnSizeReturned = cbData;
        memcpy(pSD, pSnSD, cbData);
        LocalFree( pSnSD );
        return(NDDE_NO_ERROR);
    }
    }

    if (si & (DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION |
          GROUP_SECURITY_INFORMATION)) {
        dwDesiredUserAccess = READ_CONTROL;
        dwDesiredShareDBAccess = READ_CONTROL;
    }

    if (si & SACL_SECURITY_INFORMATION) {
        dwDesiredUserAccess |= ACCESS_SYSTEM_SECURITY;
        dwDesiredShareDBAccess |= ACCESS_SYSTEM_SECURITY;
    }

    ddeErr =  NDdeShareAccessCheck(bRemoteCall,lpszShareName,pSnSD,dwDesiredUserAccess,
                            dwDesiredShareDBAccess,
                            FALSE,FALSE,NULL);


    if (NDDE_NO_ERROR != ddeErr)
    {
        LocalFree( pSnSD );
        return ddeErr;
    }

    if ( (pSD != NULL) && (IsBadWritePtr(pSD,cbSD) != 0) ) {
        LocalFree( pSnSD );
        return(NDDE_INVALID_PARAMETER);
    }

    OK = GetPrivateObjectSecurity(
            pSnSD,              // ObjectDescriptor
            si,                 // SecurityInformation
            pSD,                // ResultantDescriptor
            cbSD,               // DescriptorLength
            lpcbSDRequired);    // ReturnLength

    LocalFree( pSnSD );

    if (!OK) {
    // just a guess.
    return NDDE_BUF_TOO_SMALL;
    } else {
        *lpnSizeReturned = GetSecurityDescriptorLength(pSD);
    }

    return(NDDE_NO_ERROR);
}


/*
    Set Share Security
*/

unsigned long
wwNDdeSetShareSecurityA(
    unsigned char * lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor
    unsigned long   sdl             // and length
)
{
    UINT        uRtn;
    WCHAR       lpwShareName[MAX_NDDESHARENAME *2];

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    if (0 == MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME *2 ))
    {
        return NDDE_INVALID_SHARE;
    }

    uRtn = wwNDdeSetShareSecurityW( lpwShareName, si, pSD, sdl );

    return uRtn;
}

unsigned long
wwNDdeSetShareSecurityW(
    wchar_t *       lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor
    unsigned long   sdl             // and length
)
{
    DWORD dwDesiredUserAccess = 0;
    DWORD dwDesiredShareDBAccess = 0;
    WCHAR                   szShareSet[DDE_SHARE_KEY_MAX];
    LONG                    lRtn;
    HKEY                    hKey;
    BOOL                    OK;
    DWORD            cbSDold;
    PSECURITY_DESCRIPTOR    pSDold;
    LONG                    lSerialNumber[2];
    DWORD                   cbData;
    HANDLE            hClientToken;
    ULONG               ddeErr;

    if (pSD) {
        if (!IsValidSecurityDescriptor(pSD)) {
            return(NDDE_INVALID_SECURITY_DESC);
        }
    } else {
        return(NDDE_INVALID_SECURITY_DESC);
    }

    if( lpszShareName == (wchar_t *) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }
    if ( !NDdeIsValidShareNameW(lpszShareName) ) {
        return NDDE_INVALID_SHARE;
    }

    ddeErr = BuildRegistrySharePath(lpszShareName,DDE_SHARE_KEY_MAX,szShareSet);
    if (ddeErr != NDDE_NO_ERROR)
    {
        return ddeErr; 
    }


    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
        szShareSet,
        0,
        KEY_WRITE | KEY_READ,
        &hKey );
    if( lRtn != ERROR_SUCCESS )  {
    return NDDE_ACCESS_DENIED;
    }

    /*  **********Read the key security info here. **************/
    OK = GetShareNameSD( hKey, &pSDold, &cbData );
    if( !OK ) {
        RegCloseKey( hKey );
        return NDDE_REGISTRY_ERROR;
    }


    if (si & DACL_SECURITY_INFORMATION) {
        dwDesiredUserAccess = WRITE_DAC;
        dwDesiredShareDBAccess = WRITE_DAC;
    }

    if (si & (GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION)) {
        dwDesiredUserAccess |= WRITE_OWNER;
        dwDesiredShareDBAccess |= WRITE_OWNER;
    }

    if (si & SACL_SECURITY_INFORMATION) {
        dwDesiredUserAccess |= ACCESS_SYSTEM_SECURITY;
        dwDesiredShareDBAccess |= ACCESS_SYSTEM_SECURITY;
    }

    ddeErr =  NDdeShareAccessCheck(TRUE,lpszShareName,pSDold,dwDesiredUserAccess,
                            dwDesiredShareDBAccess,
                            FALSE,FALSE,&hClientToken);

    if(NDDE_NO_ERROR != ddeErr) 
    {
        LocalFree( pSDold );
        RegCloseKey(hKey);
        return ddeErr;
    }

    OK = SetPrivateObjectSecurity(si,    // si
        pSD,            // psdSource
        &pSDold,            // lppsdTarget
        &ShareGenMap,        // pgm
        hClientToken);        // hClientToken

    CloseHandle(hClientToken);

    if (!OK) {
        LocalFree(pSDold);
        RegCloseKey(hKey);

        // failed, possibly access denied, insufficient privilege,
        // out of memory...  all in a way are ACCESS_DENIED.

        return NDDE_ACCESS_DENIED;
    }

    cbSDold = GetSecurityDescriptorLength(pSDold);

    OK = UpdateDSDMModifyId(lSerialNumber);
    if (!OK) {
        LocalFree(pSDold);
        RegCloseKey( hKey );
        return NDDE_REGISTRY_ERROR;
    }

    if (pSDold) {
    lRtn = RegSetValueExW( hKey,
           L"SecurityDescriptor",
           0,
           REG_BINARY,
           (LPBYTE)pSDold,
           cbSDold );

    DestroyPrivateObjectSecurity(&pSDold);
    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Set Share SD: %d", lRtn));
        }
#endif
        RegCloseKey( hKey );
        return NDDE_REGISTRY_ERROR;
    }
    } else {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }

    OK = UpdateShareModifyId(hKey, lSerialNumber);

    // RegCloseKey(hKey); ALREADY CLOSED BY UpdateShareModifyId

    if( !OK ) {
    return NDDE_REGISTRY_ERROR;
    }

    return NDDE_NO_ERROR;
}


/*
    Enumerate Shares
*/

unsigned long
wwNDdeShareEnumA(
    unsigned long   nLevel,             //  0 for null separated 00 terminated list
    byte *          lpBuffer,           // pointer to buffer
    unsigned long   cBufSize,           // size of buffer
    unsigned long * lpnEntriesRead,     // number of names returned
    unsigned long * lpcbTotalAvailable, // number of bytes available
    unsigned long * lpnSizeToReturn     // num bytes for Rpc to ret to client
)
{
    DWORD       cbTotalBytes;
    DWORD       cbEntriesRead;
    DWORD       cbSizeToReturn;
    UINT        enumRet = NDDE_NO_ERROR;
    LPWSTR      lpLocalBuf = NULL;

    if (!lpnSizeToReturn)
    {
        return NDDE_INVALID_PARAMETER;
    }

    *lpnSizeToReturn = 0; 

    if ( nLevel != 0 ) {
        return NDDE_INVALID_LEVEL;      
    }


    if ( !lpnEntriesRead || !lpcbTotalAvailable) {
        return NDDE_INVALID_PARAMETER;
    }


    // lpBuffer can be NULL if cBufSize is 0, to get needed buffer size
    if ( (lpBuffer == NULL) && (cBufSize != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    // if lpBuffer is not NULL, need to validate it up to cBufSize bytes
    if ( (lpBuffer != NULL) && (IsBadWritePtr(lpBuffer,cBufSize) != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    if (cBufSize > 0) {
        lpLocalBuf = (LPWSTR)LocalAlloc( LPTR, sizeof(WCHAR)*cBufSize );
        if( lpLocalBuf == NULL ) {
            MEMERROR();
            return NDDE_OUT_OF_MEMORY;
        }
    } else {
        lpLocalBuf = NULL;
    }

    enumRet    = wwNDdeShareEnumW( nLevel,
                        (LPBYTE)lpLocalBuf, sizeof(WCHAR)*cBufSize,
                        &cbEntriesRead, &cbTotalBytes, &cbSizeToReturn );

    *lpnEntriesRead     = cbEntriesRead;

    // this can be wrong in DBCS so since Total can may need to be 2* the number
    // of WCHARS if every WCHAR maps to a DBCS character.
    // so we can return the needed size the first time and then when ask
    // again could get a Buffer To small but we still return the incorrect buffer
    // size.
    *lpcbTotalAvailable = cbTotalBytes / sizeof(WCHAR); 
    *lpnSizeToReturn    = cbSizeToReturn / sizeof(WCHAR);

    if( enumRet == NDDE_NO_ERROR && lpLocalBuf) { 
        if (0 == WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpLocalBuf, cbTotalBytes / sizeof(WCHAR), 
                        lpBuffer,cBufSize,
                            NULL, NULL ))
        {
            enumRet = NDDE_BUF_TOO_SMALL;
        }
    }

    if (NULL != lpLocalBuf) 
    {
        LocalFree( lpLocalBuf );
    }

    return( enumRet );
}

unsigned long
wwNDdeShareEnumW(
    unsigned long   nLevel,             //  0 for null separated 00 terminated list
    byte *          lpBuffer,           // pointer to buffer
    unsigned long   cBufSize,           // size of buffer
    unsigned long * lpnEntriesRead,     // number of names returned
    unsigned long * lpcbTotalAvailable, // number of bytes available
    unsigned long * lpnSizeToReturn     // num bytes for Rpc to ret to client
)
{
    WCHAR       szShareName[ MAX_NDDESHARENAME + 1];
    DWORD       cbShareName;
    DWORD       cbTotalAvailable;
    DWORD       cbEntriesRead;
    UINT        ret;
    HKEY        hKeyRoot;
    DWORD       cbLeft;
    DWORD       cbThis;
    UINT        enumRet = NDDE_NO_ERROR;
    LPWSTR      lpszTarget;
    int         idx = 0;
    unsigned long ddeErr;
    DWORD       dwDesiredShareDBAccess = 0;
    

 
   if (!lpnSizeToReturn) {
        return NDDE_INVALID_PARAMETER;
    }

    *lpnSizeToReturn = 0; 

    if ( nLevel != 0 ) {
        return NDDE_INVALID_LEVEL;
    }


    if ( !lpnEntriesRead || !lpcbTotalAvailable) {
        return NDDE_INVALID_PARAMETER;
    }

    // lpBuffer can be NULL if cBufSize is 0, to get needed buffer size
    if ( (lpBuffer == NULL) && (cBufSize != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    // if lpBuffer is not NULL, need to validate it up to cBufSize bytes
    if ( (lpBuffer != NULL) && (IsBadWritePtr(lpBuffer,cBufSize) != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    /*  Make sure the caller has EnumShare(Ls) access rights. */
    dwDesiredShareDBAccess = NDDE_SHAREDB_LIST;

    ddeErr =  NDdeShareAccessCheck(TRUE,L"ShareDB",NULL,0,
                            dwDesiredShareDBAccess,
                            FALSE,FALSE,NULL);


    if( NDDE_NO_ERROR != ddeErr ) {
        return ddeErr;
    }

    cbLeft = cBufSize;

    if( cbLeft > 1)  {
        cbLeft -= sizeof(WCHAR);        // but leave space for double-NULL
    }

    cbTotalAvailable = sizeof(WCHAR);   // leave space for double-NULL
    cbEntriesRead    = 0;
    lpszTarget       = (LPWSTR)lpBuffer;

    ret = RegOpenKeyEx( HKEY_LOCAL_MACHINE, DDE_SHARES_KEY,
        0, KEY_READ, &hKeyRoot );
    if( ret == ERROR_SUCCESS )  {
        while( ret == ERROR_SUCCESS )  {
            cbShareName = sizeof(szShareName)/sizeof(WCHAR);
            ret = RegEnumKeyExW( hKeyRoot, idx++, szShareName,
                &cbShareName, NULL, NULL, NULL, NULL );
            if( ret == ERROR_SUCCESS )  {
                cbThis = (cbShareName + 1) * sizeof(WCHAR);
                cbTotalAvailable += cbThis;

                if( enumRet == NDDE_NO_ERROR )  {
                    if( cbThis > cbLeft )  {
                        enumRet = NDDE_BUF_TOO_SMALL;
                    } else {
                        /* copy this string in */
                        wcscpy( lpszTarget, szShareName );
                        lpszTarget += cbShareName;
                        *lpszTarget++ = L'\0';
                        /* decrement what's left */
                        cbLeft -= cbThis;
                        cbEntriesRead++;
                    }
                }
            }
        }
        RegCloseKey( hKeyRoot );
    }


    // if cbTotalAvailable is still a single WCHAR it means
    // we found no shares. need to increment by one
    // and check available buffer

    if ((sizeof(WCHAR) == cbTotalAvailable))
    {
        cbTotalAvailable += sizeof(WCHAR);

        if (cBufSize < 2*sizeof(WCHAR))
        {
            enumRet = NDDE_BUF_TOO_SMALL;
        }
        else if (NULL != lpszTarget) // will be pointing to the start of the buffer
        {
            lpszTarget[0] = L'\0';
            ++lpszTarget; // increment 
        }
    }

    *lpnEntriesRead      = cbEntriesRead;
    *lpcbTotalAvailable  = cbTotalAvailable;


    if( enumRet == NDDE_NO_ERROR ) {

        if( lpszTarget )  
        {
            *lpszTarget = L'\0';
        }
        *lpnSizeToReturn = cbTotalAvailable;
    }

    return( enumRet );
}


/*
    Set Trusted Share
*/

unsigned long
wwNDdeSetTrustedShareA(
    unsigned char * lpszShareName,      // name of share
    unsigned long   dwOptions           // trust share options
)
{
    UINT        uRtn;
    WCHAR       lpwShareName[MAX_NDDESHARENAME *2];

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    if (0 == MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME *2 ))
    {
        return NDDE_INVALID_SHARE;
    }

    uRtn = wwNDdeSetTrustedShareW( lpwShareName, dwOptions );

    return uRtn;
}

unsigned long
wwNDdeSetTrustedShareW(
    wchar_t *       lpszShareName,      // name of share
    unsigned long   dwOptions           // trust share options
)
{
    LONG    lRet;
    DWORD   dwDisp;
    HKEY    hKeyRoot, hSubKey, hCurrentUserKey;
    LONG    lSerialNumber[2];
    DWORD   cbSerialNumber = 2 * sizeof( LONG );
    UINT    uData;
    DWORD    cbData = sizeof(uData);
    BOOL    OK;
    LONG    RetStatus = NDDE_NO_ERROR;

    if (lpszShareName == NULL) {
        return(NDDE_INVALID_PARAMETER);
    }

    if ( !NDdeIsValidShareNameW(lpszShareName) ) {
        return NDDE_INVALID_SHARE;
    }

    if (!GetShareSerialNumber(lpszShareName, (LPBYTE)lSerialNumber)) {
        lSerialNumber[0] = 0;
        lSerialNumber[1] = 0;
    }


    OK = ImpersonateAndSetup( TRUE );
    if( !OK) {
        return NDDE_ACCESS_DENIED;
    }


    hCurrentUserKey = (HKEY)OpenCurrentUserKey(KEY_ALL_ACCESS);
    if (hCurrentUserKey == 0) {
        RevertAndCleanUp( TRUE );
        return(NDDE_TRUST_SHARE_FAIL);
    }

    lRet = RegCreateKeyExW( hCurrentUserKey,
        szTrustedShareKey,
        0, L"",
        REG_OPTION_NON_VOLATILE,
        KEY_CREATE_SUB_KEY,
        NULL,
        &hKeyRoot,
        &dwDisp);
    if( lRet == ERROR_SUCCESS)  {   /* must be have access */
        if ((dwOptions == 0) || (dwOptions & NDDE_TRUST_SHARE_DEL)) {
            /*  Delete a Trust Share */
            lRet = RegDeleteKeyW(hKeyRoot, lpszShareName);
            RegCloseKey(hKeyRoot);
            if (lRet != ERROR_SUCCESS) {
#if DBG
                if (bDebugDSDMErrors) {
                    DPRINTF(("Trusted Share Key Delete Failed: %d", lRet));
                }
#endif
                RetStatus = NDDE_TRUST_SHARE_FAIL;
            }
        } else {    /* Create or Modify a Trust Share */
            lRet = RegCreateKeyExW( hKeyRoot,
                lpszShareName,
                0, NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE | KEY_READ,
                NULL,
                &hSubKey,
                &dwDisp);
            if (lRet != ERROR_SUCCESS) { /* fail to create or open */
#if DBG
                if (bDebugDSDMErrors) {
                    DPRINTF(("Trusted Share Key Open/Create Failed: %d", lRet));
                }
#endif
                RegCloseKey(hKeyRoot);
                RetStatus = NDDE_TRUST_SHARE_FAIL;
            } else {
                lRet = RegSetValueEx( hSubKey,
                   KEY_MODIFY_ID,
                   0,
                   REG_BINARY,
                   (LPBYTE)lSerialNumber, cbSerialNumber );
#if DBG
                if ((lRet != ERROR_SUCCESS) && bDebugDSDMErrors) {
                    DPRINTF(("Unable to set trusted share serial number."));
                }
#endif
                if (dwOptions & NDDE_TRUST_CMD_SHOW) {
                    uData = dwOptions & NDDE_CMD_SHOW_MASK;
                    lRet = RegSetValueEx( hSubKey,
                        KEY_CMDSHOW,
                        0,
                        REG_DWORD,
                        (LPBYTE)&uData,
                        cbData );
#if DBG
                    if ((lRet != ERROR_SUCCESS) && bDebugDSDMErrors) {
                        DPRINTF(("Unable to set trusted share command show."));
                    }
#endif
                } else {
                    lRet = RegDeleteValue( hSubKey, KEY_CMDSHOW);
                }
                uData = (dwOptions & NDDE_TRUST_SHARE_START ? 1 : 0);
                lRet = RegSetValueEx( hSubKey,
                    KEY_START_APP,
                    0,
                    REG_DWORD,
                    (LPBYTE)&uData,
                    cbData );
#if DBG
                if ((lRet != ERROR_SUCCESS) && bDebugDSDMErrors) {
                    DPRINTF(("Unable to set trusted share start app flag."));
                }
#endif
                uData = (dwOptions & NDDE_TRUST_SHARE_INIT ? 1 : 0);
                lRet = RegSetValueEx( hSubKey,
                    KEY_INIT_ALLOWED,
                    0,
                    REG_DWORD,
                    (LPBYTE)&uData,
                    cbData );
#if DBG
                if ((lRet != ERROR_SUCCESS) && bDebugDSDMErrors) {
                    DPRINTF(("Unable to set trusted share int allowed flag."));
                }
#endif
                RegCloseKey(hSubKey);
                RegCloseKey(hKeyRoot);
            }
        }
    } else {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to open current user trusted shares root key for setting: %d", lRet));
            DPRINTF(("   %ws", szTrustedShareKey));
        }
#endif
        RetStatus = NDDE_TRUST_SHARE_FAIL;
    }
    RegCloseKey( hCurrentUserKey );
    RevertAndCleanUp( TRUE );
    return(RetStatus);
}


/*
    Get Trusted Share Options
*/

unsigned long
wwNDdeGetTrustedShareA(
    unsigned char * lpszShareName,      // name of share
    unsigned long * lpdwOptions,        // ptr to trust share opt
    unsigned long * lpdwShareModId0,    // ptr to trust share opt
    unsigned long * lpdwShareModId1     // ptr to trust share opt
)
{
    UINT        uRtn;
    WCHAR       lpwShareName[MAX_NDDESHARENAME *2];

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    if (0 == MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME *2 ))
    {
        return NDDE_INVALID_SHARE;
    }


    uRtn = wwNDdeGetTrustedShareW( lpwShareName,
        lpdwOptions, lpdwShareModId0, lpdwShareModId1 );

    return uRtn;
}

unsigned long
wwNDdeGetTrustedShareW(
    wchar_t *       lpszShareName,      // name of share
    unsigned long * lpdwOptions,        // ptr to trust share opt
    unsigned long * lpdwShareModId0,    // ptr to trust share opt
    unsigned long * lpdwShareModId1     // ptr to trust share opt
)
{
    LONG    lRet;
    UINT    len;
    HKEY    hKeyRoot, hCurrentUserKey;
    UINT    uData;
    LONG    lSerialId[2];
    DWORD    cbData = sizeof(uData);
    DWORD   dwType;
    DWORD   dwOptions = 0;
    PWCHAR  lpTrustedShare;
    BOOL    OK;

    if (lpszShareName == NULL) {
        return(NDDE_INVALID_PARAMETER);
    }

    if ( !NDdeIsValidShareNameW(lpszShareName) ) {
        return NDDE_INVALID_SHARE;
    }

    if ( (NULL == lpdwOptions) || (NULL == lpdwShareModId0)
            || (NULL == lpdwShareModId1))
    {
        return NDDE_INVALID_PARAMETER;
    }

    // +2 , 1 for NULL and 1 for the Separator.
    len = (wcslen(szTrustedShareKey) + wcslen(lpszShareName) + 2) * sizeof(WCHAR);
    lpTrustedShare = LocalAlloc(LPTR, len);
    if (lpTrustedShare == NULL) {
        MEMERROR();
        return(NDDE_OUT_OF_MEMORY);
    }
    wcscpy(lpTrustedShare, szTrustedShareKey);
    wcscat(lpTrustedShare, L"\\");
    wcscat(lpTrustedShare, lpszShareName);

    OK = ImpersonateAndSetup( TRUE );
    if( !OK) {
        LocalFree(lpTrustedShare);
        return NDDE_ACCESS_DENIED;
    }

    hCurrentUserKey = (HKEY)OpenCurrentUserKey(KEY_ALL_ACCESS);
    if (hCurrentUserKey == 0) {
        RevertAndCleanUp( TRUE );
        LocalFree(lpTrustedShare);
        return(NDDE_TRUST_SHARE_FAIL);
    }


    lRet = RegOpenKeyExW( hCurrentUserKey, lpTrustedShare,
        0, KEY_QUERY_VALUE, &hKeyRoot );

    RevertAndCleanUp(TRUE);


    if( lRet == ERROR_SUCCESS )  {   /* must be have access */

        cbData = sizeof(uData);
        lRet = RegQueryValueEx(hKeyRoot, KEY_CMDSHOW, NULL,
                &dwType, (LPBYTE)&uData, &cbData);
        if (lRet == ERROR_SUCCESS) {
            dwOptions = uData;
            dwOptions |= NDDE_TRUST_CMD_SHOW;
        }

        cbData = sizeof(uData);
        lRet = RegQueryValueEx(hKeyRoot, KEY_START_APP, NULL,
                &dwType, (LPBYTE)&uData, &cbData);
        if (lRet == ERROR_SUCCESS) {
            if (uData == 1)
                dwOptions |= NDDE_TRUST_SHARE_START;
        }

        cbData = sizeof(uData);
        lRet = RegQueryValueEx(hKeyRoot, KEY_INIT_ALLOWED, NULL,
                &dwType, (LPBYTE)&uData, &cbData);
        if (lRet == ERROR_SUCCESS) {
            if (uData == 1)
                dwOptions |= NDDE_TRUST_SHARE_INIT;
        }
        cbData = 2 * sizeof(LONG);
        lRet = RegQueryValueEx(hKeyRoot, KEY_MODIFY_ID, NULL,
                &dwType, (LPBYTE)lSerialId, &cbData);
        if (lRet == ERROR_SUCCESS) {
            *lpdwShareModId0 = lSerialId[0];
            *lpdwShareModId1 = lSerialId[1];
        } else {
#if DBG
            if (bDebugDSDMErrors) {
                DPRINTF(("Unable to access trusted share serial number: %d", lRet));
            }
#endif
            *lpdwShareModId0 = 0;
            *lpdwShareModId1 = 0;
        }

        *lpdwOptions = dwOptions;
        RegCloseKey(hKeyRoot);
        RegCloseKey( hCurrentUserKey );
        LocalFree(lpTrustedShare);
        return(NDDE_NO_ERROR);
    } else {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to open current user trusted shares root key for getting: %d", lRet));
            DPRINTF(("   %ws", lpTrustedShare));
        }
#endif
        RegCloseKey( hCurrentUserKey );
        LocalFree(lpTrustedShare);
        return(NDDE_TRUST_SHARE_FAIL);
    }
}


/*
    Enumerate Trusted Shares
*/
unsigned long
wwNDdeTrustedShareEnumA(
    unsigned long   nLevel,                 /* 0 (0 sep, 00 term) */
    byte           *lpBuffer,               /* pointer to buffer */
    unsigned long   cBufSize,               /* size of buffer */
    unsigned long  *lpnEntriesRead,         /* num names returned */
    unsigned long  *lpcbTotalAvailable,     /* num bytes available */
    unsigned long  *lpnSizeToReturn    )
{
    DWORD       cbTotalBytes;
    DWORD       cbEntriesRead;
    DWORD       cbSizeToReturn;
    UINT        enumRet = NDDE_NO_ERROR;
    LPWSTR      lpLocalBuf = NULL;

   if (!lpnSizeToReturn ) {
        return NDDE_INVALID_PARAMETER;
    }

    *lpnSizeToReturn = 0; 

    if ( nLevel != 0 ) {
        return NDDE_INVALID_LEVEL;
    }

    if ( !lpnEntriesRead || !lpcbTotalAvailable) {
        return NDDE_INVALID_PARAMETER;
    }


    // lpBuffer can be NULL if cBufSize is 0, to get needed buffer size
    if ( (lpBuffer == NULL) && (cBufSize != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    // if lpBuffer is not NULL, need to validate it up to cBufSize bytes
    if ( (lpBuffer != NULL) && (IsBadWritePtr(lpBuffer,cBufSize) != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }


    if (cBufSize > 0) {
        lpLocalBuf = (LPWSTR)LocalAlloc( LPTR, sizeof(WCHAR)*cBufSize );
        if( lpLocalBuf == NULL ) {
            MEMERROR();
            return NDDE_OUT_OF_MEMORY;
        }
    } else {
        lpLocalBuf = NULL;
    }

    enumRet    = wwNDdeTrustedShareEnumW( nLevel,
                        (LPBYTE)lpLocalBuf, sizeof(WCHAR)*cBufSize,
                        &cbEntriesRead, &cbTotalBytes, &cbSizeToReturn );

    *lpnEntriesRead     = cbEntriesRead;
    *lpcbTotalAvailable = cbTotalBytes / sizeof(WCHAR); 
    *lpnSizeToReturn    = cbSizeToReturn / sizeof(WCHAR);

    if( enumRet == NDDE_NO_ERROR && lpLocalBuf) { 
        if (0 == WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpLocalBuf, cbTotalBytes / sizeof(WCHAR), 
                        lpBuffer,cBufSize,
                            NULL, NULL ))
        {
            enumRet = NDDE_BUF_TOO_SMALL;
        }
    }
    if (NULL != lpLocalBuf) 
    {
        LocalFree( lpLocalBuf );
    }
    return( enumRet );
}

unsigned long
wwNDdeTrustedShareEnumW(
    unsigned long       nLevel,             /* 0 (0 sep, 00 term) */
    byte               *lpBuffer,           /* pointer to buffer */
    unsigned long       cBufSize,           /* size of buffer */
    unsigned long      *lpnEntriesRead,     /* num names returned */
    unsigned long      *lpcbTotalAvailable, /* num bytes available */
    unsigned long      *lpnSizeToReturn)
{
    WCHAR       szShareName[ MAX_NDDESHARENAME + 1];
    DWORD       cbShareName;
    DWORD       cbTotalAvailable;
    DWORD       cbEntriesRead;
    DWORD       dwDisp;
    LONG        lRet;
    HKEY        hKeyRoot, hCurrentUserKey;
    DWORD       cbLeft;
    DWORD       cbThis;
    UINT        enumRet = NDDE_NO_ERROR;
    LPWSTR      lpszTarget;
    int         idx = 0;
    BOOL        OK;

    if (!lpnSizeToReturn) {
        return NDDE_INVALID_PARAMETER;
    }

    *lpnSizeToReturn = 0; 

    if ( nLevel != 0 ) {
        return NDDE_INVALID_LEVEL;
    }
    if ( !lpnEntriesRead || !lpcbTotalAvailable) {
        return NDDE_INVALID_PARAMETER;
    }

    // lpBuffer can be NULL if cBufSize is 0, to get needed buffer size
    if ( (lpBuffer == NULL) && (cBufSize != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    // if lpBuffer is not NULL, need to validate it up to cBufSize bytes
    if ( (lpBuffer != NULL) && (IsBadWritePtr(lpBuffer,cBufSize) != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }


    /* Assume as System Service WE HAVE RIGHTS! */

    OK = ImpersonateAndSetup( TRUE );
    if( !OK) {
        return NDDE_ACCESS_DENIED;
    }

    hCurrentUserKey = (HKEY)OpenCurrentUserKey(KEY_ALL_ACCESS);
    if (hCurrentUserKey == 0) {
        RevertAndCleanUp( TRUE );
        return(NDDE_TRUST_SHARE_FAIL);
    }

    cbLeft = cBufSize;
    if( cbLeft > 1 )  {
        cbLeft -= sizeof(WCHAR);        // but leave space for double-NULL
    }
    cbTotalAvailable = sizeof(WCHAR);   // leave space for double-NULL
    cbEntriesRead    = 0;
    lpszTarget       = (LPWSTR)lpBuffer;


    lRet = RegCreateKeyExW(
            hCurrentUserKey,
            szTrustedShareKey,
            0,
            L"",
            REG_OPTION_NON_VOLATILE,
            KEY_ENUMERATE_SUB_KEYS,
            NULL,
            &hKeyRoot,
            &dwDisp);
    if( lRet == ERROR_SUCCESS )  {
        while( lRet == ERROR_SUCCESS )  {
            cbShareName = sizeof(szShareName) / sizeof(szShareName[0]);
            lRet = RegEnumKeyExW( hKeyRoot, idx++, szShareName,
                &cbShareName, NULL, NULL, NULL, NULL );
            if( lRet == ERROR_SUCCESS )  {
                cbThis = (cbShareName + 1) * sizeof(WCHAR);
                cbTotalAvailable += cbThis;
                if( enumRet == NDDE_NO_ERROR )  {
                    if( cbThis > cbLeft )  {
                        enumRet = NDDE_BUF_TOO_SMALL;
                    } else {
                        /* copy this string in */
                        wcscpy( lpszTarget, szShareName );
                        lpszTarget += cbShareName;
                        *lpszTarget++ = L'\0';
                        /* decrement what's left */
                        cbLeft -= cbThis;
                        cbEntriesRead++;
                    }
                }
            } else {
                if (lRet != ERROR_NO_MORE_ITEMS) {
#if DBG
                    if (bDebugDSDMErrors) {
                        DPRINTF(("Error while enumerating trusted shares: %d", lRet));
                    }
#endif
                    RegCloseKey(hKeyRoot);
                    RegCloseKey( hCurrentUserKey );
                    RevertAndCleanUp( TRUE );
                    return(NDDE_TRUST_SHARE_FAIL);
                }
            }
        }
    } else {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to open current user trusted shares key for enumeration: %d", lRet));
            DPRINTF(("   %ws", szTrustedShareKey));
        }
#endif
        RegCloseKey( hCurrentUserKey );
        RevertAndCleanUp( TRUE );
        return(NDDE_TRUST_SHARE_FAIL);
    }
    RegCloseKey( hKeyRoot );
    RegCloseKey( hCurrentUserKey );
    RevertAndCleanUp( TRUE );

    
    // if cbTotalAvailable is still a single WCHAR it means
    // we found no shares. need to increment by one
    // and check available buffer

    if (sizeof(WCHAR) == cbTotalAvailable)
    {
        cbTotalAvailable += sizeof(WCHAR);

        if (cBufSize < 2*sizeof(WCHAR))
        {
            enumRet = NDDE_BUF_TOO_SMALL;
        }
        else if (NULL != lpszTarget) // will be pointing to the start of the buffer
        {
            lpszTarget[0] = L'\0';
            ++lpszTarget; // increment 
        }
    }

    *lpnEntriesRead      = cbEntriesRead;
    *lpcbTotalAvailable  = cbTotalAvailable;

    if( enumRet == NDDE_NO_ERROR ) {
        if( lpszTarget )  {
            *lpszTarget = L'\0';
        }
        *lpnSizeToReturn = cbTotalAvailable;
    }
    return( (lpBuffer == NULL) ? NDDE_BUF_TOO_SMALL : enumRet );
}


/*
    Get DDE Share Info
*/

unsigned long
wwNDdeShareGetInfoW(
    wchar_t        *lpszShareName,      // name of share
    unsigned long   nLevel,             // info level must be 2
    byte           *lpBuffer,           // gets struct
    unsigned long   cBufSize,           // sizeof buffer
    unsigned long  *lpnTotalAvailable,  // number of bytes available
    unsigned short *lpnItems,           // item mask for partial getinfo
                                        // (must be 0)
    unsigned long   bRemoteCall,        // RPC client (not local) call
    unsigned long  *lpnSizeToReturn,
    unsigned long  *lpnSn,
    unsigned long  *lpnAt,
    unsigned long  *lpnIt
)
{

    return _wwNDdeShareGetInfoW( lpszShareName, nLevel,
                          lpBuffer,cBufSize,lpnTotalAvailable, lpnItems,
                          TRUE /* if comes through RPC interface force remote */,
                          lpnSizeToReturn,lpnSn,lpnAt,lpnIt );

}

unsigned long
_wwNDdeShareGetInfoW(
    wchar_t        *lpszShareName,      // name of share
    unsigned long   nLevel,             // info level must be 2
    byte           *lpBuffer,           // gets struct
    unsigned long   cBufSize,           // sizeof buffer
    unsigned long  *lpnTotalAvailable,  // number of bytes available
    unsigned short *lpnItems,           // item mask for partial getinfo
                                        // (must be 0)
    unsigned long   bRemoteCall,        // RPC client (not local) call
    unsigned long  *lpnSizeToReturn,
    unsigned long  *lpnSn,
    unsigned long  *lpnAt,
    unsigned long  *lpnIt
)
        /*  This function has an extra argument, bRemoteCall, that allows
            NetDDE to call locally.  In this case, we have to avoid
            the RpcImpersonateClient and RevertToSelf calls.
        */

{
    DWORD               cbRequired;
    HKEY                hKey;
    WCHAR               szKeyName[ DDE_SHARE_KEY_MAX ];
    LPBYTE              lpbuf;
    UINT                ubufsize;
    LONG                lRtn;
    PUNDDESHAREINFO     lpNDDEinfo;
    LPWSTR              lpszTarget;
    DWORD               cbData;
    DWORD               dwType;
    LONG                nItems;
    BOOL                OK;
    DWORD               dwDesiredUserAccess = 0;
    DWORD               dwDesiredShareDBAccess = 0;
    PSECURITY_DESCRIPTOR pKeySD;
    LPWSTR              pOldStr, pNewStr, pStaticStr;
    LONG                lShareType;
    LONG                lItemList;
    PUNDDESHAREINFO     lpUDdeShare;
    ULONG               ddeErr;

    if (NULL == lpnSizeToReturn)
    {
        return NDDE_INVALID_PARAMETER;
    }

    *lpnSizeToReturn = 0; 

    if ( lpszShareName == (LPWSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }
    if ( lpnItems == (LPWORD) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }
    if ( nLevel        != 2 ) {
        return NDDE_INVALID_LEVEL;
    }
    if ( !NDdeIsValidShareNameW( lpszShareName ) )  {
        return NDDE_INVALID_SHARE;
    }

    if ( (NULL == lpnSn) || (NULL == lpnAt) || (NULL == lpnIt))
    {
        return NDDE_INVALID_PARAMETER;
    }

    ddeErr = BuildRegistrySharePath(lpszShareName,DDE_SHARE_KEY_MAX,szKeyName);
    if (ddeErr != NDDE_NO_ERROR)
    {
        return ddeErr; 
    }


    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE, szKeyName,
        0, KEY_READ, &hKey );
    if( lRtn == ERROR_SUCCESS )  {
        /*  Make sure the caller has GetShareInfo(R) access rights. */
        /*  **********Read the key security info here. **************/
        if (bRemoteCall) {
            OK = GetShareNameSD( hKey, &pKeySD, &cbData );
            if (!OK) {
                RegCloseKey( hKey );
                return NDDE_ACCESS_DENIED;
            }
            dwDesiredUserAccess = NDDE_SHARE_READ;
            dwDesiredShareDBAccess = NDDE_SHAREDB_READ;

              
            ddeErr =  NDdeShareAccessCheck(bRemoteCall,lpszShareName,pKeySD,dwDesiredUserAccess,
                            dwDesiredShareDBAccess,
                            FALSE,FALSE,NULL);


            LocalFree( pKeySD );

            if(NDDE_NO_ERROR != ddeErr) {
#if DBG
                if (bDebugDSDMErrors) {
                    DPRINTF(("Share \"%ws\" access validation error: %d",
                        lpszShareName, GetLastError()));
                }
#endif
                RegCloseKey( hKey );
                return ddeErr;
            }
        }

        if (lpbuf = LocalAlloc(LPTR, 20000))  {
            ubufsize = 20000;
        }
        else {
            RegCloseKey( hKey );
            return NDDE_OUT_OF_MEMORY;
        }
 

        /*  Set the key values. */
        cbRequired = sizeof(NDDESHAREINFO);
        cbData = ubufsize;
        lRtn = RegQueryValueExW( hKey,
                       L"ShareName",
                       NULL,
                       &dwType,
                       lpbuf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData;

        cbData = ubufsize;
        lRtn = RegQueryValueExW( hKey,
                       L"OldStyleLink",
                       NULL,
                       &dwType,
                       lpbuf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData;

        cbData = ubufsize;
        lRtn = RegQueryValueExW( hKey,
                       L"NewStyleLink",
                       NULL,
                       &dwType,
                       lpbuf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData;

        cbData = ubufsize;
        lRtn = RegQueryValueExW( hKey,
                       L"StaticDataLink",
                       NULL,
                       &dwType,
                       lpbuf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData;
        cbRequired++;                   /*  Allow for the extra NULL */

        cbData = ubufsize;
        lRtn = RegQueryValueExW( hKey,
                   L"ItemList",
                   NULL,
                   &dwType,
                   lpbuf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData;

        cbData = ubufsize;
        lRtn = RegQueryValueExW( hKey,
                       L"SecurityDescriptor",
                       NULL,
                       &dwType,
                       lpbuf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData + 3; // leave room in case we need to round up

        cbData = ubufsize;
        lRtn = RegQueryValueExW( hKey,
                       L"NumItems",
                       NULL,
                       &dwType,
                       lpbuf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        nItems = *((LPLONG)lpbuf);
        cbRequired += cbData;

        *lpnTotalAvailable = cbRequired;
        if( lpnItems )  {
            *lpnItems = (WORD)nItems;
        }

        if( (cbRequired <= cBufSize) &&
            (IsBadWritePtr(lpBuffer,cbRequired) == 0) ) {
            DWORD cbRemaining = cbRequired; // amount remaining in buffer as we read.

            lpNDDEinfo = (PUNDDESHAREINFO)lpBuffer;

            lpszTarget = (LPWSTR)(lpBuffer + sizeof(UNDDESHAREINFO));

            if (cbRemaining < sizeof(NDDESHAREINFO))
            {
                RegCloseKey(hKey);
                return NDDE_REGISTRY_ERROR;
            }
            cbRemaining -= sizeof(NDDESHAREINFO);
            cbData = cbRemaining;

            lRtn = RegQueryValueExW( hKey,
                           L"ShareName",
                           NULL,
                           &dwType,
                           (LPBYTE)lpszTarget, &cbData );
            if( lRtn != ERROR_SUCCESS) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }

            lpNDDEinfo->lpszShareName = lpszTarget;

            /* Check share name for corruption. */
            if( lstrcmpiW( lpNDDEinfo->lpszShareName, lpszShareName ) != 0 ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            lpszTarget = (LPWSTR) ((LPBYTE)lpszTarget + cbData);
            cbRemaining -= cbData;

            cbData = cbRemaining;
            lRtn = RegQueryValueExW( hKey,
                           L"OldStyleLink",
                           NULL,
                           &dwType,
                           (LPBYTE)lpszTarget, &cbData );
            if( lRtn != ERROR_SUCCESS) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->lpszAppTopicList = lpszTarget;

            lpszTarget = (LPWSTR) ((LPBYTE)lpszTarget + cbData);
            cbRemaining -= cbData;

            cbData = cbRemaining;
            lRtn = RegQueryValueExW( hKey,
                           L"NewStyleLink",
                           NULL,
                           &dwType,
                           (LPBYTE)lpszTarget, &cbData );
            if( lRtn != ERROR_SUCCESS) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }

            lpszTarget = (LPWSTR) ((LPBYTE)lpszTarget + cbData);
            cbRemaining -= cbData;

            cbData = cbRemaining;
            lRtn = RegQueryValueExW( hKey,
                           L"StaticDataLink",
                           NULL,
                           &dwType,
                           (LPBYTE)lpszTarget, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }

            lpszTarget = (LPWSTR) ((LPBYTE)lpszTarget + cbData);
            cbRemaining -= cbData;

            if (cbRemaining == 0) // make sure we won't go negative moving past the NULL
            {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }

            *lpszTarget++ = L'\0'; // add on the terminating NULL
            cbRemaining -= 1;

            if ( !NDdeParseAppTopicListW( lpNDDEinfo->lpszAppTopicList,
                                          (DWORD) (lpszTarget - lpNDDEinfo->lpszAppTopicList),
                                          &pOldStr, &pNewStr, &pStaticStr,
                                          &lShareType) ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = cbRemaining;
            lRtn = RegQueryValueExW( hKey,
                       L"ItemList",
                       NULL,
                       &dwType,
                       (LPBYTE)lpszTarget, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }

            lpNDDEinfo->lpszItemList = lpszTarget;
            lpszTarget = (LPWSTR) ((LPBYTE)lpszTarget + cbData);
            cbRemaining -= cbData; 
            
            // cbRemaining should be zero but is actually still larger
            // because we don't add the security descriptor or the 
            // NumItems field onto the end of the structure but
            // the calculation for the bufferSize includes it.

            if ( !NDdeParseItemList ( lpNDDEinfo->lpszItemList,
                                      (DWORD) (lpszTarget - lpNDDEinfo->lpszItemList),
                                      nItems, &lItemList )) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }


            cbData = sizeof(LONG);
            lRtn = RegQueryValueExW( hKey,
                           L"Revision",
                           NULL,
                           &dwType,
                           lpbuf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->lRevision = *((LPLONG)lpbuf);
            /* Check Revision for corruption. */
            if( lpNDDEinfo->lRevision != 1 ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(LONG);
            lRtn = RegQueryValueExW( hKey,
                           L"ShareType",
                           NULL,
                           &dwType,
                           lpbuf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->lShareType = *((LPLONG)lpbuf);
            if( lpNDDEinfo->lShareType != lShareType ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(LONG);
            lRtn = RegQueryValueExW( hKey,
                           L"SharedFlag",
                           NULL,
                           &dwType,
                           lpbuf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->fSharedFlag = *((LPLONG)lpbuf);
            /* Check share flag for corruption. */
            if( lpNDDEinfo->fSharedFlag > 1 ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(LONG);
            lRtn = RegQueryValueExW( hKey,
                           L"Service",
                           NULL,
                           &dwType,
                           lpbuf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->fService = *((LPLONG)lpbuf);
            if( lpNDDEinfo->fService > 1 ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(LONG);
            lRtn = RegQueryValueExW( hKey,
                           L"StartAppFlag",
                           NULL,
                           &dwType,
                           lpbuf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->fStartAppFlag = *((LPLONG)lpbuf);
            if( lpNDDEinfo->fStartAppFlag > 1 ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(LONG);
            lRtn = RegQueryValueExW( hKey,
                           L"fuCmdShow",
                           NULL,
                           &dwType,
                           lpbuf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }

            if (cbData != sizeof(LONG))
            {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            lpNDDEinfo->nCmdShow = *((LPLONG)lpbuf);

            cbData = 2 * sizeof(LONG);
            lRtn = RegQueryValueEx( hKey,
                           KEY_MODIFY_ID,
                           NULL,
                           &dwType,
                           lpbuf, &cbData );
            if( lRtn != ERROR_SUCCESS) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }

            if (cbData != 2*sizeof(LONG))
            {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            memcpy( &lpNDDEinfo->qModifyId[0], lpbuf, cbData ); 

            lpNDDEinfo->cNumItems = nItems;
        } else {
            RegCloseKey( hKey );
            return NDDE_BUF_TOO_SMALL;
        }
        RegCloseKey( hKey );
    } else {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to open DDE share \"%ws\": %d",
                lpszShareName, lRtn));
        }
#endif
        return NDDE_SHARE_NOT_EXIST;
    }

    if (IsBadWritePtr(lpBuffer,sizeof(NDDESHAREINFO)) != 0)
        return NDDE_BUF_TOO_SMALL;
    else  {
        lpUDdeShare = (PUNDDESHAREINFO)lpBuffer;
        *lpnSn = (LONG)((LPBYTE)lpUDdeShare->lpszShareName - lpBuffer);
        *lpnAt = (LONG)((LPBYTE)lpUDdeShare->lpszAppTopicList - lpBuffer);
        *lpnIt = (LONG)((LPBYTE)lpUDdeShare->lpszItemList - lpBuffer);
    }

    *lpnSizeToReturn = *lpnTotalAvailable;
    return NDDE_NO_ERROR;
}

/*
 * We have to keep ConvertNDdeToAnsi and wwNDdeShareGetInfoA around till
 * netdde.exe is UNICODIZED because it calls this.   (SanfordS)
 */
unsigned long ConvertNDdeToAnsii(
    PUNDDESHAREINFO lpUDdeShare,
    PNDDESHAREINFO  lpDdeShare,
    int             ccbBuffer,
    int             *pcbRequired)
{
    int         cbRequired;
    UINT        uRtn = NDDE_NO_ERROR;
    LPBYTE      lpszTarget;
    LPBYTE      lpUDdeShareEnd;
    int         cchAppTopicList;
    int         cchShareName;
    int         cchItemList;

    // this functions assumpes the lpUDdeShare has already been validated
    // The validate functions are being used here to get the size
    // if this can ever be called from an untrusted source need to
    // change ValidateAppTopicListW and ValidateItemListW to pass
    // in a correct maxCharacter count.

    if (!pcbRequired)
    {
        return NDDE_INVALID_PARAMETER;
    }

    *pcbRequired = 0;

    if ( (NULL == lpUDdeShare->lpszShareName) || (NULL == lpUDdeShare->lpszItemList)
        || (NULL == lpUDdeShare->lpszAppTopicList))
    {
        return NDDE_INVALID_PARAMETER;
    }

    /* Compute size required. */
    cbRequired    = sizeof( NDDESHAREINFO );

    cchShareName  = WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                    lpUDdeShare->lpszShareName, -1, NULL, 0, NULL, NULL );
    cbRequired   += sizeof(CHAR) * cchShareName;


    if (!ValidateAppTopicListW(lpUDdeShare->lpszAppTopicList,-1,&cchAppTopicList))
    {
        return NDDE_INVALID_PARAMETER;
    }

    cchAppTopicList = WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                lpUDdeShare->lpszAppTopicList,cchAppTopicList,
                NULL, 0, NULL, NULL );

    cbRequired += sizeof(CHAR)*cchAppTopicList; 

    if (!ValidateMultiSzW( lpUDdeShare->lpszItemList,-1,&cchItemList ))
    {
        return NDDE_INVALID_PARAMETER;
    }

    cchItemList = WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
            lpUDdeShare->lpszItemList,cchItemList,
            NULL, 0, NULL, NULL );

    cbRequired += sizeof(CHAR) * cchItemList;

    // if either the cchItemList or cchAppTopicList is now zero
    // return a failure
    if (0 == cchItemList || 0 == cchAppTopicList || 0 == cchShareName)
    {
        return NDDE_INVALID_PARAMETER;
    }


    if( (ccbBuffer >= cbRequired) && (lpDdeShare != NULL) ) {
        lpDdeShare->lRevision     = lpUDdeShare->lRevision;
        lpDdeShare->lShareType    = lpUDdeShare->lShareType;
        lpDdeShare->fSharedFlag   = lpUDdeShare->fSharedFlag;
        lpDdeShare->fService      = lpUDdeShare->fService;
        lpDdeShare->fStartAppFlag = lpUDdeShare->fStartAppFlag;
        lpDdeShare->nCmdShow      = lpUDdeShare->nCmdShow;
        lpDdeShare->qModifyId[0]  = lpUDdeShare->qModifyId[0];
        lpDdeShare->qModifyId[1]  = lpUDdeShare->qModifyId[1];
        lpDdeShare->cNumItems     = lpUDdeShare->cNumItems;
    
        // if any of the WideChars fail, return of of memory.
        lpszTarget = ((LPBYTE)lpDdeShare + sizeof( NDDESHAREINFO ));
        lpDdeShare->lpszShareName = (LPSTR) lpszTarget;
        
        
        if (0 == WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpUDdeShare->lpszShareName, -1,
                        lpDdeShare->lpszShareName, cchShareName, NULL, NULL ))
        {
            uRtn = NDDE_OUT_OF_MEMORY;
        }

        if (NDDE_NO_ERROR == uRtn)
        {
            lpszTarget += sizeof(CHAR) * cchShareName;

            lpDdeShare->lpszAppTopicList = (LPSTR) lpszTarget;
            
            if (0 == WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                            lpUDdeShare->lpszAppTopicList, cchAppTopicList,
                            lpDdeShare->lpszAppTopicList, cchAppTopicList,
                                NULL, NULL ))
            {
                uRtn = NDDE_OUT_OF_MEMORY;
            }
        }

        if (NDDE_NO_ERROR == uRtn)
        {

            lpszTarget += sizeof(CHAR) * cchAppTopicList;

            lpDdeShare->lpszItemList = (LPSTR) lpszTarget;

            if (0 == WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                            lpUDdeShare->lpszItemList, cchItemList,
                            lpDdeShare->lpszItemList, cchItemList, NULL, NULL ))
            {
                uRtn = NDDE_OUT_OF_MEMORY;
            }
        }
    }
    else
    {   
        uRtn = NDDE_BUF_TOO_SMALL;
    }

    *pcbRequired = cbRequired;
    return uRtn;
}


unsigned long _wwNDdeShareGetInfoA(
    unsigned char   *lpszShareName,     // name of share
    unsigned long    nLevel,            // info level must be 2
    byte            *lpBuffer,          // gets struct
    unsigned long    cBufSize,          // sizeof buffer
    unsigned long   *lpnTotalAvailable, // number of bytes available
    unsigned short  *lpnItems,          // item mask for partial getinfo
                                        // (must be 0)
    unsigned long *lpnSizeToReturn,

    unsigned long *lpnSn,
    unsigned long *lpnAt,
    unsigned long *lpnIt
)
{
    PUNDDESHAREINFO     lpUDdeShare;
    UINT                uRtn;
    DWORD               dwLen;
    WORD                nItems;
    WCHAR               lpwShareName[MAX_NDDESHARENAME *2];
    int                 nLen;
    DWORD               nRetSize, n0, n1, n2;

    PNDDESHAREINFO      lpDdeShare;

    if (NULL == lpnSizeToReturn)
    {
        return NDDE_INVALID_PARAMETER;
    }

    *lpnSizeToReturn = 0;

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    if (0 == MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME *2 ))
    {
        return NDDE_INVALID_SHARE;
    }


    if ( ( NULL == lpnSn) || (NULL == lpnAt) || (NULL == lpnIt)
        || (NULL == lpnTotalAvailable) || (NULL == lpnItems))
    {
        return NDDE_INVALID_PARAMETER;
    }

    nItems = 0;
    uRtn = _wwNDdeShareGetInfoW( lpwShareName, nLevel,
                          lpBuffer, 0, &dwLen, &nItems,
                          FALSE /* remote if false since GetInfoA is internal only */,
                          &nRetSize, &n0, &n1, &n2 );
    if( uRtn == NDDE_BUF_TOO_SMALL ) {
        lpUDdeShare = (PUNDDESHAREINFO)LocalAlloc( LPTR, dwLen );
        if( !lpUDdeShare )  {
            MEMERROR();
            return( NDDE_OUT_OF_MEMORY );
        }
        nItems = 0;
        uRtn = _wwNDdeShareGetInfoW( lpwShareName, nLevel,
                              (LPBYTE)lpUDdeShare, dwLen, &dwLen, &nItems,
                              FALSE /* remote if false since GetInfoA is internal only */,
                              &nRetSize, &n0, &n1, &n2 );

        if( uRtn == NDDE_NO_ERROR ) {

            uRtn = ConvertNDdeToAnsii( (PUNDDESHAREINFO)lpUDdeShare,
                                (PNDDESHAREINFO) lpBuffer,
                                cBufSize,&nLen);

            *lpnTotalAvailable = nLen; 
            *lpnItems          = nItems;

            if (NDDE_BUF_TOO_SMALL == uRtn)
            {
                LocalFree(lpUDdeShare);
                return uRtn;
            }

        }

        LocalFree( lpUDdeShare );

    }

    if( uRtn == NDDE_NO_ERROR ) {
        lpDdeShare = (PNDDESHAREINFO)lpBuffer;
        *lpnSn = (LONG)((LPBYTE)lpDdeShare->lpszShareName - lpBuffer);
        *lpnAt = (LONG)((LPBYTE)lpDdeShare->lpszAppTopicList - lpBuffer);
        *lpnIt = (LONG)((LPBYTE)lpDdeShare->lpszItemList - lpBuffer);
        *lpnSizeToReturn = nLen;
    } else {
        *lpnTotalAvailable = 0;
        *lpnItems          = 0;
    }

    return uRtn;
}


/*
    Set DDE Share Info
*/



unsigned long
wwNDdeShareSetInfoW(
    wchar_t       *lpszShareName,       // name of share
    unsigned long  nLevel,              // info level must be 2
    byte          *lpBuffer,            // must point to struct
    unsigned long  cBufSize,            // sizeof buffer
    unsigned short sParmNum,            // Parameter index
                                        // ( must be 0 - entire )
    byte * psn,
    unsigned long lsn,
    byte * pat,
    unsigned long lat,
    byte * pit,
    unsigned long lit
)
{
    WCHAR                szShareSet[DDE_SHARE_KEY_MAX];
    PUNDDESHAREINFO      lpDdeShare;
    LONG                 lRtn;
    LONG                 lItemList;
    HKEY                 hKey;
    BOOL                 OK;
    DWORD                dwDesiredUserAccess = 0;
    DWORD                dwDesiredShareDBAccess = 0;
    PSECURITY_DESCRIPTOR pSnSD;
    LPWSTR               pOldStr;
    LPWSTR               pNewStr;
    LPWSTR               pStaticStr;
    LONG                 lShareType;
    LONG                 lSerialNumber[2];
    DWORD                cbData;
     DWORD                     dwType;
     LONG                         fOldService;
     WCHAR                     buf[16];
    unsigned long           ddeErr;

    ddeErr =  GetDDEShareInfo(nLevel,lpBuffer,cBufSize,psn,lsn, 
                             pat,lat,NULL /* no security descriptor in SetShareInfo */,0,
                             pit,lit,
                             &lpDdeShare,&pOldStr, &pNewStr,&pStaticStr,
                             &lShareType,&lItemList,NULL);

    if (ddeErr != NDDE_NO_ERROR)
    {
        return ddeErr;
    }

    // since only setting all paramters is supported, the supplied
    // name of the share MUST match the name of the share contained
    // in the supplied struct!
    if ( lstrcmpiW( lpDdeShare->lpszShareName, lpszShareName ) ) {
        return NDDE_INVALID_PARAMETER;
    }

    // check for share existence - must exist for SetInfo
    ddeErr = BuildRegistrySharePath(lpszShareName,DDE_SHARE_KEY_MAX,szShareSet);
    if (ddeErr != NDDE_NO_ERROR)
    {
        return ddeErr; 
    }

    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
          szShareSet,
          0,
          KEY_WRITE | KEY_READ,
          &hKey );
    if( lRtn != ERROR_SUCCESS )  {
    return NDDE_SHARE_NOT_EXIST;
    }
    /*  Make sure the caller has WriteShareInfo(W) access rights. */
    /*  **********Read the key security info here. **************/
    OK = GetShareNameSD( hKey, &pSnSD, &cbData );
    if( OK ) 
    {
        dwDesiredUserAccess = NDDE_SHARE_WRITE;
        dwDesiredShareDBAccess = NDDE_SHAREDB_WRITE;


        ddeErr =  NDdeShareAccessCheck(TRUE,lpszShareName,pSnSD,dwDesiredUserAccess,
                    dwDesiredShareDBAccess,
                    FALSE,FALSE,NULL);

        LocalFree( pSnSD );
    }

    if(NDDE_NO_ERROR != ddeErr) 
    {
        RegCloseKey( hKey );
        return ddeErr;
    }

    /*  Make sure the caller has AddShare(As) access rights. */
    cbData = sizeof(buf);
    *(LONG *)buf = 0L;
   lRtn = RegQueryValueExW( hKey,
                            L"Service",
                            NULL,
                            &dwType,
                            (LPBYTE)buf, &cbData );
    fOldService = *(LONG *)buf;
    dwDesiredShareDBAccess = NDDE_SHAREDB_ADD;
    if (lpDdeShare->fService != fOldService) {

        dwDesiredShareDBAccess = NDDE_SHAREDB_FSERVICE;

        ddeErr =  NDdeShareAccessCheck(TRUE,lpDdeShare->lpszShareName,NULL,0,
             dwDesiredShareDBAccess,
             TRUE,FALSE,NULL);

        if (NDDE_NO_ERROR != ddeErr) {
            RegCloseKey( hKey );
            return ddeErr;
        }
    }

    OK = UpdateDSDMModifyId(lSerialNumber);
    if (!OK) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lpDdeShare->qModifyId[0] = lSerialNumber[0];
    lpDdeShare->qModifyId[1] = lSerialNumber[1];

    /*  *****************Do the SetInfo Operation**************** */

#ifdef NDDE_DEBUG
    DPRINTF(("Revision               = (%d)", lpDdeShare->lRevision));
    DPRINTF(("ShareName              = (%ws)", lpDdeShare->lpszShareName));
    DPRINTF(("ShareType              = (%d)", lpDdeShare->lShareType));
    DPRINTF(("ShareType*             = (%d)", lShareType));
    DPRINTF(("AppTopicList"));
    DPRINTF(("  Old-style link share = (%ws)", pOldStr));
    DPRINTF(("  New-style link share = (%ws)", pNewStr));
    DPRINTF(("  Static data share    = (%ws)", pStaticStr));
    DPRINTF(("SharedFlag             = (%d)", lpDdeShare->fSharedFlag));
    DPRINTF(("ServiceFlag            = (%d)", lpDdeShare->fService));
    DPRINTF(("StartAppFlag           = (%d)", lpDdeShare->fStartAppFlag));
    DPRINTF(("nCmdShow               = (%d)", lpDdeShare->nCmdShow));
    DPRINTF(("SerialNumber           = (%d, %d)", lpDdeShare->qModifyId[0],
                           lpDdeShare->qModifyId[1]));
    DPRINTF(("NumItems               = (%d)", lpDdeShare->cNumItems));
    {
    LPWSTR      lpszItem = lpDdeShare->lpszItemList;
    int n= 0;
    for( n=0; n<lpDdeShare->cNumItems; n++ )  {
        DPRINTF(("ItemList[%d]             = (%ws)", n, lpszItem));
        lpszItem = lpszItem + wcslen(lpszItem) + 1;
    }
    }
#endif
    /*  Set the key values. */
    lRtn = RegSetValueExW( hKey,
           L"ShareName",
           0,
           REG_SZ,
           (LPBYTE)lpDdeShare->lpszShareName,
           sizeof(WCHAR) *
               (wcslen( lpDdeShare->lpszShareName ) + 1) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"OldStyleLink",
           0,
           REG_SZ,
           (LPBYTE)pOldStr,
           sizeof(WCHAR) * (wcslen( pOldStr ) + 1) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"NewStyleLink",
           0,
           REG_SZ,
           (LPBYTE)pNewStr,
           sizeof(WCHAR) * (wcslen( pNewStr ) + 1) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"StaticDataLink",
           0,
           REG_SZ,
           (LPBYTE)pStaticStr,
           sizeof(WCHAR) * (wcslen( pStaticStr ) + 1) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"ItemList",
           0,
           REG_MULTI_SZ,
           (LPBYTE)lpDdeShare->lpszItemList,
           sizeof(WCHAR) * lItemList );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"Revision",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->lRevision,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"ShareType",
           0,
           REG_DWORD,
           (LPBYTE)&lShareType,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"SharedFlag",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->fSharedFlag,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"Service",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->fService,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"StartAppFlag",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->fStartAppFlag,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"fuCmdShow",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->nCmdShow,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueEx( hKey,
           KEY_MODIFY_ID,
           0,
           REG_BINARY,
           (LPBYTE)&lpDdeShare->qModifyId[0],
           2 * sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"NumItems",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->cNumItems,
           sizeof( LONG ) );
    RegCloseKey(hKey);

    if( lRtn != ERROR_SUCCESS ) {
    return NDDE_REGISTRY_ERROR;
    }

    return NDDE_NO_ERROR;
}


/*
    Special Command
*/

unsigned long
wwNDdeSpecialCommand(
    unsigned long  nCommand,
    byte          *lpDataIn,
    unsigned long  nBytesDataIn,
    byte          *lpDataOut,
    unsigned long *nBytesDataOut
)
{
    UINT        RetValue, RetDataLength;
    UINT        i;
    BOOL        ok  = TRUE;
    PSC_PARAM   psc_param;
    char        szBuf[1024];
    UINT        nLength;
    UINT        umax;
    DWORD       dwDesiredShareDBAccess = 0;
    unsigned long     ddeErr;

    RetValue      = NDDE_NO_ERROR;
    RetDataLength = 0;

    // check caller access.

    dwDesiredShareDBAccess = NDDE_SHAREDB_SPECIALCOMMAND;

    ddeErr =  NDdeShareAccessCheck(TRUE,L"NetDDE SpecialCommand",NULL,0,
                                dwDesiredShareDBAccess,
                                FALSE,FALSE,NULL);

    if(NDDE_NO_ERROR != ddeErr) {
        return ddeErr;
    }


    switch( nCommand ) {

        case NDDE_SC_TEST: {       // test command, return *lpDataIn to *lpDataOut

            if ( (lpDataIn == NULL)  || (IsBadReadPtr(lpDataIn,nBytesDataIn) != 0) ||
                 (lpDataOut == NULL) || (IsBadWritePtr(lpDataOut,nBytesDataIn) != 0) )  {
                RetValue = NDDE_INVALID_PARAMETER;
                break;
            }

            for( i=0; i<nBytesDataIn; i++ ) {
                lpDataOut[i] = lpDataIn[i];
            }
            RetDataLength = nBytesDataIn;
            }
            break;

        case NDDE_SC_REFRESH:       // refresh NetDDE operating params from reg
            RefreshNDDECfg();
            RefreshDSDMCfg();
            break;

        case NDDE_SC_DUMP_NETDDE:
#if DBG
            DebugDdeIntfState();
            DebugDderState();
            DebugRouterState();
            DebugPktzState();
#endif
            break;

        case NDDE_SC_GET_PARAM:     // get a NetDDE param from registry

            if (   (lpDataIn == NULL)
                || (nBytesDataOut == NULL)
                || (nBytesDataIn < sizeof(SC_PARAM) )
                || (IsBadReadPtr(lpDataIn,sizeof(SC_PARAM)) != 0)) {
                RetValue = NDDE_INVALID_PARAMETER;
                break;
            }

            psc_param = (PSC_PARAM)lpDataIn;
            umax = max(psc_param->offSection, psc_param->offKey);
            if ( (nBytesDataIn < umax) ||
                 (IsBadReadPtr(lpDataIn,umax) != 0) ) {
                RetValue = NDDE_INVALID_PARAMETER;
                break;
            }
            if (psc_param->pType == SC_PARAM_INT) {
                if ( (*nBytesDataOut < sizeof(UINT)) ||
                     (lpDataOut == NULL) ||
                     (IsBadWritePtr(lpDataOut,sizeof(UINT)) != 0) ) {
                     RetDataLength = sizeof(UINT);
                     RetValue = NDDE_BUF_TOO_SMALL;
                } else {
                    *((UINT *)lpDataOut) = MyGetPrivateProfileInt(
                        (LPCSTR)psc_param + psc_param->offSection,
                        (LPCSTR)psc_param + psc_param->offKey,
                        0, NULL);
                    RetDataLength = sizeof(UINT);
                }
            } else if (psc_param->pType == SC_PARAM_STRING) {
                nLength = MyGetPrivateProfileString(
                    (LPCSTR)psc_param + psc_param->offSection,
                    (LPCSTR)psc_param + psc_param->offKey,
                    "Dummy",
                    (LPSTR)szBuf, 1024, NULL);
                RetDataLength = nLength;
                if ( (*nBytesDataOut < nLength) ||
                     (lpDataOut == NULL) || 
                     (IsBadWritePtr(lpDataOut,nLength) != 0) ) {
                     RetValue = NDDE_BUF_TOO_SMALL;
                } else {
                    strncpy(lpDataOut, szBuf, nLength);
                }
            }
            break;

        case NDDE_SC_SET_PARAM:     // set a NetDDE param in registry

            if (   (lpDataIn == NULL)
                || (nBytesDataIn < sizeof(SC_PARAM) )
                || (IsBadReadPtr(lpDataIn,sizeof(SC_PARAM)) != 0)) {
                RetValue = NDDE_INVALID_PARAMETER;
                break;
            }
            psc_param = (PSC_PARAM)lpDataIn;
            umax = max(max(psc_param->offSection, psc_param->offKey), psc_param->offszValue);
            if ( (nBytesDataIn < umax) ||
                 (IsBadReadPtr(lpDataIn,umax) != 0) ) {
                RetValue = NDDE_INVALID_PARAMETER;
                break;
            }
            if (psc_param->pType == SC_PARAM_INT) {
                ok = MyWritePrivateProfileInt(
                    (LPSTR)psc_param + psc_param->offSection,
                    (LPSTR)psc_param + psc_param->offKey,
                    psc_param->pData,
                    NULL);
            } else if (psc_param->pType == SC_PARAM_STRING) {
                ok = MyWritePrivateProfileString(
                    (LPCSTR)psc_param + psc_param->offSection,
                    (LPCSTR)psc_param + psc_param->offKey,
                    (LPCSTR)psc_param + psc_param->offszValue,
                    NULL);
            }
            if (!ok) {
                RetValue = NDDE_REGISTRY_ERROR;
            }
            break;

        default:
            RetValue      = NDDE_INVALID_SPECIAL_COMMAND;
            RetDataLength = 0;
            break;
    }

    *nBytesDataOut = RetDataLength;
    return RetValue;
}


BOOL
BuildShareDatabaseSD( PSECURITY_DESCRIPTOR *ppSD )
{
    PSID                        AdminsAliasSid;
    PSID                        PowerUsersAliasSid;
    PSID                        UsersAliasSid;
    PSID                        WorldSid;
    PSID                        CreatorOwnerSid;
    SID_IDENTIFIER_AUTHORITY    CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    NtAuthority    = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SECURITY_DESCRIPTOR         aSD;
    PSECURITY_DESCRIPTOR        pSD;
    int                         AceCount;
    PSID                        AceSid[10];
    ACCESS_MASK                 AceMask[10];
    BYTE                        AceFlags[10];
    PACL                        TmpAcl;
    PACCESS_ALLOWED_ACE         TmpAce;
    DWORD                       lSD;
    LONG                        DaclLength;
    BOOL                        OK;
    int                         i;

    OK = InitializeSecurityDescriptor( &aSD, SECURITY_DESCRIPTOR_REVISION );

    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        return FALSE;
    }

    OK = AllocateAndInitializeSid( &NtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &AdminsAliasSid );

    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        return FALSE;
    }

    AceCount = 0;

    AceSid[AceCount]   = AdminsAliasSid;
    AceMask[AceCount]  = NDDE_SHAREDB_ADMIN;
    AceFlags[AceCount] = 0;
    AceCount++;

    OK = AllocateAndInitializeSid( &NtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_POWER_USERS,
                                    0, 0, 0, 0, 0, 0,
                                    &PowerUsersAliasSid );
    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        return FALSE;
    }

    AceSid[AceCount]   = PowerUsersAliasSid;
    AceMask[AceCount]  = NDDE_SHAREDB_POWER;
    AceFlags[AceCount] = 0;
    AceCount++;

    OK = AllocateAndInitializeSid( &NtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_USERS,
                                    0, 0, 0, 0, 0, 0,
                                    &UsersAliasSid );

    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        FreeSid( PowerUsersAliasSid );
        return FALSE;
    }

    AceSid[AceCount]   = UsersAliasSid;
    AceMask[AceCount]  = NDDE_SHAREDB_USER;
    AceFlags[AceCount] = 0;
    AceCount++;

    OK = AllocateAndInitializeSid( &WorldAuthority,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &WorldSid );
    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        FreeSid( PowerUsersAliasSid );
        FreeSid( UsersAliasSid );
        return FALSE;
    }

    AceSid[AceCount]   = WorldSid;
    AceMask[AceCount]  = NDDE_SHAREDB_EVERYONE;
    AceFlags[AceCount] = 0;
    AceCount++;

    //
    // The rest of this ACL will provide inheritable protection
    // for DDE share objects when they are created.  Notice that
    // each of the following ACEs is marked as InheritOnly and
    // ObjectInherit.
    //

    AceSid[AceCount]   = WorldSid;
    AceMask[AceCount]  = NDDE_GUI_READ_LINK;
    AceFlags[AceCount] = INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;
    AceCount++;

    OK = AllocateAndInitializeSid(   &CreatorAuthority,
                                1,
                                SECURITY_CREATOR_OWNER_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                &CreatorOwnerSid );
    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        FreeSid( PowerUsersAliasSid );
        FreeSid( UsersAliasSid );
        FreeSid( WorldSid );
        return FALSE;
    }


    AceSid[AceCount]   = CreatorOwnerSid;
    AceMask[AceCount]  = NDDE_GUI_FULL_CONTROL;
    AceFlags[AceCount] = INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;
    AceCount++;


    OK = SetSecurityDescriptorOwner( &aSD, AdminsAliasSid, FALSE);
    if( !OK ) {
        NDDELogErrorW( MSG411, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        FreeSid( PowerUsersAliasSid );
        FreeSid( UsersAliasSid );
        FreeSid( WorldSid );
        FreeSid( CreatorOwnerSid );
        return FALSE;
    }

    OK = SetSecurityDescriptorGroup( &aSD, AdminsAliasSid, FALSE );
    if( !OK ) {
        NDDELogErrorW( MSG412, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        FreeSid( PowerUsersAliasSid );
        FreeSid( UsersAliasSid );
        FreeSid( WorldSid );
        FreeSid( CreatorOwnerSid );
        return FALSE;
    }

    /*  Setup the default ACL for a new DDE Share Object. */
    DaclLength = (DWORD)sizeof(ACL);
    for( i=0; i<AceCount; i++ ) {
        DaclLength += GetLengthSid( AceSid[i] ) +
                      (DWORD)sizeof( ACCESS_ALLOWED_ACE ) -
                      (DWORD)sizeof(DWORD);
    }
    TmpAcl = (PACL)LocalAlloc( 0, DaclLength );
    if( !TmpAcl ) {
        MEMERROR();
        NDDELogErrorW( MSG406, LogStringW( L"%d", GetLastError() ), NULL );
    }
    OK = InitializeAcl( TmpAcl, DaclLength, ACL_REVISION2 );
    if( !OK ) {
        NDDELogErrorW( MSG407, LogStringW( L"%d", GetLastError() ), NULL );
    }
    for( i=0; i<AceCount; i++ ) {
        OK = AddAccessAllowedAce( TmpAcl, ACL_REVISION2, AceMask[i],
                                      AceSid[i] );
        if( !OK ) {
            NDDELogErrorW( MSG408, LogStringW( L"%d", GetLastError() ), NULL);
        }
        OK = GetAce( TmpAcl, i, (LPVOID *)&TmpAce );
        if( !OK ) {
            NDDELogErrorW( MSG409, LogStringW( L"%d", GetLastError() ), NULL);
        }
        TmpAce->Header.AceFlags = AceFlags[i];
    }

    OK = SetSecurityDescriptorDacl ( &aSD, TRUE, TmpAcl, FALSE );
    if( !OK ) {
        NDDELogErrorW( MSG413, LogStringW( L"%d", GetLastError() ), NULL);
    }
    lSD = GetSecurityDescriptorLength( &aSD );
    pSD = (PSECURITY_DESCRIPTOR)LocalAlloc( 0, lSD );
    if (pSD == NULL) {
        MEMERROR();
    } else {
        OK  = MakeSelfRelativeSD( &aSD, pSD, &lSD );
        if( !OK ) {
            NDDELogErrorW( MSG414, LogStringW( L"%d", GetLastError() ), NULL);
            LocalFree( pSD );
            *ppSD = NULL;
        } else {
            *ppSD = pSD;
        }
    }

    FreeSid( AdminsAliasSid );
    FreeSid( PowerUsersAliasSid );
    FreeSid( UsersAliasSid );
    FreeSid( WorldSid );
    FreeSid( CreatorOwnerSid );

    LocalFree( TmpAcl );

    return OK;
}


static char    dllName[]             = "NDDEAPI";
static char    szNetddeIni[]        = "netdde.ini";

/*
    Determine what we're allowed to log in the event logger
*/
void
RefreshDSDMCfg(void)
{
#if DBG
    bDebugDSDMInfo = MyGetPrivateProfileInt( dllName,
        "DebugInfo", FALSE, szNetddeIni );
    bDebugDSDMErrors = MyGetPrivateProfileInt( dllName,
        "DebugErrors", FALSE, szNetddeIni );
#endif
}

INT APIENTRY
NDdeApiInit( void )
{
    HKEY        hKey;
    LONG        lRtn;
    DWORD       dwInstance;
    DWORD       dwType = REG_DWORD;
    DWORD       cbData = sizeof(DWORD);

#if DBG
    RefreshDSDMCfg();
    if (bDebugDSDMInfo) {
        DPRINTF(("NDdeApiInit() called."));
    }
#endif
    /*  Build the Security Descriptor for the ShareDatabase. */
    if( !BuildShareDatabaseSD( &pDsDmSD ) ) {
        NDDELogErrorW( MSG405, NULL );
        return FALSE;
    }

    /*  Check that the ShareDatabase key exists in the Registry. */
    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                  DDE_SHARES_KEY,
                  0,
                  READ_CONTROL | KEY_QUERY_VALUE,
                  &hKey );

    if( lRtn != ERROR_SUCCESS ) {
        MessageBox( NULL, "DDE Shares database does not exist.", "NDdeApi",
            MB_OK );
        return FALSE;
    }

    lRtn = RegQueryValueEx( hKey,
                KEY_DB_INSTANCE,
                NULL,
                &dwType,
                (LPBYTE)&dwInstance, &cbData );
    RegCloseKey(hKey);
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to query DDE Shares DB Instance Value: %d", lRtn));
        }
#endif
        return FALSE;
    }
    swprintf(szTrustedShareKey, L"%ws\\%ws%08X",
        TRUSTED_SHARES_KEY_W,
        TRUSTED_SHARES_KEY_PREFIX_W,
        dwInstance);

    __try
    {
        InitializeCriticalSection( &DsDmCriticalSection );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPRINTF(("InitializeCriticalSection excepted."));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ndeapi\server\nddeapir.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDEAPIR.C;1  16-Dec-92,10:14:40  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    "windows.h"

int
WinMain( HINSTANCE x, HINSTANCE y, LPSTR z, int a )
{
	return(0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\dde1.h ===
/* DDE.H: include file for Microsoft Windows apps that use DDE.
 *
 *      This file contains the definitions of the DDE constants
 *      and strucutures.
 *
 */
#ifndef DDE1_H
#define DDE1_H

/*
 *
 * The data sturcture of options for ADVISE, DATA, REQUEST and POKE
 *
 */
typedef struct {
	unsigned short unused   :12,	/* reserved for future use */
		fResponse :1,	/* in response to request  */
		fRelease  :1,	/* release data		   */
		fNoData   :1,	/* null data handle ok	   */
		fAckReq   :1;	/* Ack expected		   */
	
	short	cfFormat;	/* clipboard data format   */
} DDELNWW;
typedef DDELNWW *	LPDDELN;


/* WM_DDE_ACK message wStatus values */
#define ACK_MSG    0x8000
#define BUSY_MSG   0x4000
#define NACK_MSG   0x0000


typedef struct {
	DDELNWW     options;	        /* flags and format	*/
	unsigned    char	info[ 2 ];	/* data buffer		*/
} DATA;

typedef DATA *	PDATA;
typedef DATA *	LPDATA;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ndeapi\client\nddeapic.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin

    NDDEAPIC.C -

    Network DDE Api implementation routines - Client side

    Revisions:
     7-92   clausgi created for WFW
    12-92   BillU.  Wonderware secure DSDM port.
    12-92   ColeC.  Wonderware RPC'd for NT..
     3-93   IgorM.  Wonderware new APIs for NT and SD massaging.

   $History: End */

#include <windows.h>
#include <rpc.h>
#include <rpcndr.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <memory.h>
#include <strsafe.h>

#include "nddeapi.h"
#include "nddesec.h"
#include "debug.h"
#include "ndeapi.h"
#include "unddesi.h"
#include "mbstring.h"

//#define NDDE_DEBUG

char    tmpBuf [500];

// dll instance saved in libmain
HINSTANCE          hInst;

wchar_t  * pszUuid                          = NULL;
wchar_t  * pszProtocolSequence              = L"ncacn_np";
wchar_t    szNetworkAddress[UNCLEN+1];
wchar_t  * szEndpoint                       = L"\\pipe\\nddeapi";
wchar_t  * pszOptions                       = L"security=impersonation static true";
wchar_t  * pszStringBinding                 = NULL;


RPC_STATUS NDdeApiBindA( LPSTR  pszNetworkAddress );
RPC_STATUS NDdeApiBindW( LPWSTR pszNetworkAddress );
RPC_STATUS NDdeApiUnbind( void );

int LengthMultiSzA( LPSTR pMz );
int LengthMultiSzW( LPWSTR pMz );
int LengthAppTopicListA( LPSTR pMz );
int LengthAppTopicListW( LPWSTR pMz );


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// Validation functions
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
BOOL WINAPI NDdeIsValidShareNameA ( LPSTR shareName )
{
    if ( !shareName ) {
        return FALSE;
    }

    if ( strlen(shareName) < 1 || strlen(shareName) > MAX_NDDESHARENAME ) {
        return FALSE;
    }

    // share name cannot contain '=' or '\' because of registry and .ini syntax!

    if (GetSystemMetrics(SM_DBCSENABLED)) {
        if (_mbschr(shareName, '=') || _mbschr(shareName, '\\'))
            return FALSE;
    } else {
        if (strchr(shareName, '=') || strchr(shareName, '\\'))
            return FALSE;
    }

    return TRUE;
}


BOOL WINAPI NDdeIsValidShareNameW ( LPWSTR shareName )
{
    if ( !shareName ) {
        return FALSE;
    }

    if ( wcslen(shareName) < 1 || wcslen(shareName) > MAX_NDDESHARENAME ) {
        return FALSE;
    }

    // share name cannot contain '=' because of .ini syntax!
    if ( wcschr(shareName, L'=') || wcschr(shareName, L'\\')) {
        return FALSE;
    }

    return TRUE;
}


BOOL NDdeParseAppTopicListA (
    LPSTR appTopicList,
    LPSTR *pOldStr,
    LPSTR *pNewStr,
    LPSTR *pStaticStr,
    PLONG  pShareType )
{
    LPSTR       pStr;
    BOOL        bAnyPresent;
    int         len;
    int         nBarPos;

    /*  There should be three fields separated by NULLs ending with a
        double NULL.  Four NULLs total.  At least one field should
        contain a valid app|topic pair.  No commas are allowed and there
        should be at least one character on each side of the vertical
        bar.
    */

    *pOldStr    = NULL;
    *pNewStr    = NULL;
    *pStaticStr = NULL;
    *pShareType = 0;

    if ( !appTopicList ) {
        return FALSE;
    }

    bAnyPresent = FALSE;
    /*  Check the old style link share. */
    pStr     = appTopicList;
    *pOldStr = pStr;
    len      = strlen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = strcspn( pStr, BAR_CHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x1;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( strchr ( pStr, SEP_CHAR )) {
        return FALSE;
    }

    /*  Check the new style link share. */
    pStr     = pStr + strlen(pStr) + 1;
    *pNewStr = pStr;
    len      = strlen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = strcspn( pStr, BAR_CHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x2;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( strchr ( pStr, SEP_CHAR )) {
        return FALSE;
    }

    /*  Check the static data share. */
    pStr        = pStr + strlen(pStr) + 1;
    *pStaticStr = pStr;
    len         = strlen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = strcspn( pStr, BAR_CHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x4;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( strchr ( pStr, SEP_CHAR )) {
        return FALSE;
    }

    /*  Check for the extra NULL at the end of the AppTopicList. */
    pStr = pStr + strlen(pStr) + 1;
    if( *pStr != '\0' ) {
        return FALSE;
    }

    return bAnyPresent;
}

BOOL WINAPI NDdeIsValidAppTopicListA ( LPSTR appTopicList )
{
    LPSTR pOldStr;
    LPSTR pNewStr;
    LPSTR pStaticStr;
    LONG   lShareType;

    return NDdeParseAppTopicListA( appTopicList, &pOldStr, &pNewStr,
                                   &pStaticStr,  &lShareType );
}

BOOL NDdeParseAppTopicListW (
    LPWSTR appTopicList,
    LPWSTR *pOldStr,
    LPWSTR *pNewStr,
    LPWSTR *pStaticStr,
    PLONG  pShareType )
{
    LPWSTR      pStr;
    BOOL        bAnyPresent;
    int         len;
    int         nBarPos;

    /*  There should be three fields separated by NULLs ending with a
        double NULL.  Four NULLs total.  At least one field should
        contain a valid app|topic pair.  No commas are allowed and there
        should be at least one character on each side of the vertical
        bar.
    */

    *pOldStr    = NULL;
    *pNewStr    = NULL;
    *pStaticStr = NULL;
    *pShareType = 0;

    if ( !appTopicList ) {
        return FALSE;
    }

    bAnyPresent = FALSE;
    /*  Check the old style link share. */
    pStr     = appTopicList;
    *pOldStr = pStr;
    len      = wcslen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x1;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check the new style link share. */
    pStr     = pStr + wcslen(pStr) + 1;
    *pNewStr = pStr;
    len      = wcslen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x2;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check the static data share. */
    pStr        = pStr + wcslen(pStr) + 1;
    *pStaticStr = pStr;
    len         = wcslen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x4;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check for the extra NULL at the end of the AppTopicList. */
    pStr = pStr + wcslen(pStr) + 1;
    if( *pStr != L'\0' ) {
        return FALSE;
    }

    return bAnyPresent;
}

BOOL ValidateItemName ( LPWSTR itemName )
{
    if ( !itemName ) {
        return FALSE;
    }

    if ( wcslen(itemName) > MAX_ITEMNAME ) {
        return FALSE;
    }

    if ( wcschr ( itemName, SEP_CHAR ) ) {
        return FALSE;
    }

    return TRUE;
}

BOOL WINAPI NDdeIsValidAppTopicListW ( LPWSTR appTopicList )
{
    LPWSTR pOldStr;
    LPWSTR pNewStr;
    LPWSTR pStaticStr;
    LONG   lShareType;

    return NDdeParseAppTopicListW( appTopicList, &pOldStr, &pNewStr,
                                   &pStaticStr,  &lShareType );
}

DWORD PtrToOffset( LPVOID field, LPVOID base ) {

    if( field == NULL ) {
        return 0;
    } else {
        return (DWORD)((LPBYTE)field - (LPBYTE)base);
    }
}

LPVOID OffsetToPtr( LPVOID base, DWORD offset ) {

    if( offset == 0 ) {
        return NULL;
    } else {
        return (LPVOID)((LPBYTE)base + offset);
    }
}


/*
    Covert DDE Share Info to Unicode and back
*/
int
ConvertNDdeToAnsii(
    PUNDDESHAREINFO lpUDdeShare,
    PNDDESHAREINFO  lpDdeShare,
    int             ccbBuffer )
{
    int         cbRequired;
    LPWSTR      pStr;
    LPBYTE      lpszTarget;
    int         cchAppTopicList, nAppTopicStart;
    int         cchShareName;
    int         cchItemList;

    /* Compute size required. */
    cbRequired    = sizeof( NDDESHAREINFO );
    cchShareName  = WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                    lpUDdeShare->lpszShareName, -1, NULL, 0, NULL, NULL );
    cbRequired   += sizeof(CHAR) * cchShareName;

    pStr = lpUDdeShare->lpszAppTopicList;
    nAppTopicStart = cbRequired;
    cbRequired += sizeof(CHAR) * WideCharToMultiByte( CP_ACP,
        WC_COMPOSITECHECK, pStr, -1, NULL, 0, NULL, NULL );
    pStr = pStr + wcslen( pStr ) + 1;
    cbRequired += sizeof(CHAR) * WideCharToMultiByte( CP_ACP,
        WC_COMPOSITECHECK, pStr, -1, NULL, 0, NULL, NULL );
    pStr = pStr + wcslen( pStr ) + 1;
    cbRequired += sizeof(CHAR) * WideCharToMultiByte( CP_ACP,
        WC_COMPOSITECHECK, pStr, -1, NULL, 0, NULL, NULL );
    cbRequired += sizeof(CHAR);         /* The extra NULL */
    cchAppTopicList = (cbRequired - nAppTopicStart) / sizeof( CHAR );

    cchItemList = LengthMultiSzW( lpUDdeShare->lpszItemList );
    cbRequired += sizeof(CHAR) * cchItemList;

    if( (ccbBuffer >= cbRequired) && (lpDdeShare != NULL) ) {
        lpDdeShare->lRevision     = lpUDdeShare->lRevision;
        lpDdeShare->lShareType    = lpUDdeShare->lShareType;
        lpDdeShare->fSharedFlag   = lpUDdeShare->fSharedFlag;
        lpDdeShare->fService      = lpUDdeShare->fService;
        lpDdeShare->fStartAppFlag = lpUDdeShare->fStartAppFlag;
        lpDdeShare->nCmdShow      = lpUDdeShare->nCmdShow;
        lpDdeShare->qModifyId[0]  = lpUDdeShare->qModifyId[0];
        lpDdeShare->qModifyId[1]  = lpUDdeShare->qModifyId[1];
        lpDdeShare->cNumItems     = lpUDdeShare->cNumItems;

        lpszTarget = ((LPBYTE)lpDdeShare + sizeof( NDDESHAREINFO ));
        lpDdeShare->lpszShareName = (LPSTR) lpszTarget;
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpUDdeShare->lpszShareName, -1,
                        lpDdeShare->lpszShareName, cchShareName, NULL, NULL );
        lpszTarget += sizeof(CHAR) * cchShareName;

        lpDdeShare->lpszAppTopicList = (LPSTR) lpszTarget;
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpUDdeShare->lpszAppTopicList, cchAppTopicList,
                        lpDdeShare->lpszAppTopicList, cchAppTopicList,
                            NULL, NULL );
        lpszTarget += sizeof(CHAR) * cchAppTopicList;

        lpDdeShare->lpszItemList = (LPSTR) lpszTarget;
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpUDdeShare->lpszItemList, cchItemList,
                        lpDdeShare->lpszItemList, cchItemList, NULL, NULL );
        lpszTarget += sizeof(CHAR) * cchItemList;
    }

    return cbRequired;
}



int
ConvertNDdeToUnicode(
    PNDDESHAREINFO  lpDdeShare,
    PUNDDESHAREINFO lpUDdeShare,
    int             ccbBuffer )
{
    int         cbRequired;
    LPSTR       pStr;
    LPSTR       lpszTarget;
    int         cchAppTopicList, nAppTopicStart;
    int         cchShareName;
    int         cchItemList;

    /* Compute size required. */
    cbRequired    = sizeof( UNDDESHAREINFO );
    cchShareName  = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                    lpDdeShare->lpszShareName, -1, NULL, 0 );
    cbRequired   += sizeof(WCHAR) * cchShareName;

    pStr = lpDdeShare->lpszAppTopicList;
    nAppTopicStart = cbRequired;
    cbRequired += sizeof(WCHAR) * MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                    pStr, -1, NULL, 0 );
    pStr = pStr + strlen( pStr ) + 1;
    cbRequired += sizeof(WCHAR) * MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                    pStr, -1, NULL, 0 );
    pStr = pStr + strlen( pStr ) + 1;
    cbRequired += sizeof(WCHAR) * MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                    pStr, -1, NULL, 0 );
    cbRequired += sizeof(WCHAR);                /* The extra NULL */
    cchAppTopicList = (cbRequired - nAppTopicStart) / sizeof( WCHAR );

    cchItemList = LengthMultiSzA( lpDdeShare->lpszItemList );
    cbRequired += sizeof(WCHAR) * cchItemList;

    if( (ccbBuffer >= cbRequired) && (lpUDdeShare != NULL) ) {
        lpUDdeShare->lRevision = lpDdeShare->lRevision;
        lpUDdeShare->lShareType = lpDdeShare->lShareType;
        lpUDdeShare->fSharedFlag = lpDdeShare->fSharedFlag;
        lpUDdeShare->fService = lpDdeShare->fService;
        lpUDdeShare->fStartAppFlag = lpDdeShare->fStartAppFlag;
        lpUDdeShare->nCmdShow = lpDdeShare->nCmdShow;
        lpUDdeShare->qModifyId[0] = lpDdeShare->qModifyId[0];
        lpUDdeShare->qModifyId[1] = lpDdeShare->qModifyId[1];
        lpUDdeShare->cNumItems = lpDdeShare->cNumItems;

        lpszTarget = ((LPSTR)lpUDdeShare + sizeof( UNDDESHAREINFO ));

        lpUDdeShare->lpszShareName = (LPWSTR) lpszTarget;
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                        lpDdeShare->lpszShareName, -1,
                        lpUDdeShare->lpszShareName, cchShareName );
        lpszTarget += sizeof(WCHAR) * cchShareName;

        lpUDdeShare->lpszAppTopicList = (LPWSTR) lpszTarget;
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                        lpDdeShare->lpszAppTopicList, cchAppTopicList,
                        lpUDdeShare->lpszAppTopicList, cchAppTopicList );
        lpszTarget += sizeof(WCHAR) * cchAppTopicList;

        lpUDdeShare->lpszItemList = (LPWSTR) lpszTarget;
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                        lpDdeShare->lpszItemList, cchItemList,
                        lpUDdeShare->lpszItemList, cchItemList );
    }
    return cbRequired;
}

/*=================== API FUNCTIONS ============================
 *
 *  Dde Share manipulation functions in NDDEAPI.DLL
 *
 *=================== API FUNCTIONS ============================*/

/*
    Create and Add a Share
*/

UINT WINAPI
NDdeShareAddW (
    LPWSTR                  lpszServer, // server to execute on ( must be NULL )
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains struct, data
    DWORD                   cBufSize    // sizeof supplied buffer
)
{
    UINT                        RetValue;
    PSECURITY_DESCRIPTOR        pSDrel = NULL;
    DWORD                       dwSize = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD                       sdr;
    BOOL                        OK;

    if (pSD) {
        if (!IsValidSecurityDescriptor(pSD)) {
            return(NDDE_INVALID_SECURITY_DESC);
        }
        dwSize = GetSecurityDescriptorLength(pSD);
        OK = GetSecurityDescriptorControl(pSD, &sdc, &sdr);
        if (!OK) {
            DPRINTF(("NDdeShareAddW(): cannot get SD control: %d", GetLastError()));
            return(NDDE_INVALID_SECURITY_DESC);
        }
        if (!(sdc & SE_SELF_RELATIVE)) {
            pSDrel = LocalAlloc(LPTR, dwSize);
            if (pSDrel == NULL) {
                // MEMERROR();
                return(NDDE_OUT_OF_MEMORY);
            }
            OK = MakeSelfRelativeSD(pSD, pSDrel, &dwSize);
            if (!OK) {
                DPRINTF(("NDdeShareAddW(): bad SD: %d", GetLastError()));
                LocalFree(pSDrel);
                return(NDDE_INVALID_SECURITY_DESC);
            }
        } else {
            pSDrel = pSD;
        }
    }

    RetValue = NDDE_CANT_ACCESS_SERVER;
    RpcTryExcept {
        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {

            PUNDDESHAREINFO pN;
            DWORD nSn, nAt, nIt;

            pN  = (PUNDDESHAREINFO)lpBuffer;

            nSn = (wcslen(pN->lpszShareName) + 1) * sizeof(wchar_t);
            nAt = LengthAppTopicListW( pN->lpszAppTopicList ) * sizeof(wchar_t);
            nIt = LengthMultiSzW( pN->lpszItemList ) * sizeof(wchar_t);

            RetValue = wwNDdeShareAddW(
                nLevel, lpBuffer, cBufSize,
                (byte *)pN->lpszShareName, nSn,
                (byte *)pN->lpszAppTopicList, nAt,
                (byte *)pSDrel, dwSize,
                (byte *)pN->lpszItemList, nIt );

            NDdeApiUnbind();
        }
        if (pSD && !(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return RetValue;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareAddW", RpcExceptionCode() ));
        if (!(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}



UINT WINAPI
NDdeShareAddA (
    LPSTR                   lpszServer, // server to execute on ( must be NULL )
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains struct, data
    DWORD                   cBufSize    // sizeof supplied buffer
)
{
    PUNDDESHAREINFO     lpUDdeShare;
    LPWSTR              lpwszServer;
    UINT                uRtn;
    int                 nLen;

    if (lpBuffer == NULL) {
        return NDDE_INVALID_PARAMETER;
    }

    if (lpszServer == NULL) {
        lpwszServer = NULL;
    } else {
        nLen = (strlen(lpszServer) + 1) * sizeof(WCHAR);
        lpwszServer = LocalAlloc(LPTR, nLen);
        if (lpwszServer == NULL) {
            // MEMERROR();
            return(NDDE_OUT_OF_MEMORY);
        }
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                        lpszServer, -1,
                        lpwszServer, nLen / sizeof(WCHAR) );
    }


    nLen = ConvertNDdeToUnicode( (PNDDESHAREINFO)lpBuffer, NULL, 0 );
    lpUDdeShare = (PUNDDESHAREINFO)LocalAlloc( LPTR, nLen );
    if (lpUDdeShare == NULL) {
        // MEMERROR();
        uRtn = NDDE_OUT_OF_MEMORY;
    } else {
        nLen = ConvertNDdeToUnicode((PNDDESHAREINFO)lpBuffer , lpUDdeShare, nLen );
        uRtn = NDdeShareAddW(lpwszServer, nLevel, pSD, (LPBYTE)lpUDdeShare, nLen);
        LocalFree( lpUDdeShare );
    }

    if (lpwszServer != NULL) {
        LocalFree( lpwszServer );
    }
    return uRtn;
}


/*
    Delete a Share
*/

UINT WINAPI
NDdeShareDelA (
    LPSTR       lpszServer,     // server to execute on ( must be NULL )
    LPSTR       lpszShareName,  // name of share to delete
    UINT        wReserved       // reserved for force level (?) 0 for now
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeShareDelA(
                lpszShareName, wReserved );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareDelA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


UINT WINAPI
NDdeShareDelW (
    LPWSTR      lpszServer,     // server to execute on ( must be NULL )
    LPWSTR      lpszShareName,  // name of share to delete
    UINT        wReserved       // reserved for force level (?) 0 for now
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeShareDelW(
                lpszShareName, wReserved );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareDelW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


/*
    Get Share Security Descriptor
*/

UINT WINAPI
NDdeGetShareSecurityA(
    LPSTR                       lpszServer,         // server to execute on ( must be NULL )
    LPSTR                       lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbSDRequired  // address of required size of buffer
)
{
    UINT RetValue;

    RpcTryExcept {

        DWORD   ncbSizeToReturn;

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeGetShareSecurityA(
                lpszShareName, (unsigned long) si,
                (byte *) pSD, cbSD, TRUE, lpcbSDRequired, &ncbSizeToReturn  );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeGetShareSecurityA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept

}



UINT WINAPI
NDdeGetShareSecurityW(
    LPWSTR                      lpszServer,         // server to execute on ( must be NULL )
    LPWSTR                      lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of buffer security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbSDRequired  // address of required size of buffer
)
{
    UINT RetValue;

    RpcTryExcept {

        DWORD   ncbSizeToReturn;

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeGetShareSecurityW(
                lpszShareName, (unsigned long) si,
                (byte *) pSD, cbSD, TRUE, lpcbSDRequired, &ncbSizeToReturn  );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeGetShareSecurityW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


/*
    Set Share Security Descriptor
*/

UINT WINAPI
NDdeSetShareSecurityA(
    LPSTR                       lpszServer,         // server to execute on ( must be NULL )
    LPSTR                       lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
)
{
    UINT                        RetValue;
    PSECURITY_DESCRIPTOR        pSDrel = NULL;
    DWORD                       dwSize = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD                       sdr;
    BOOL                        OK;

    if (pSD) {
        if (!IsValidSecurityDescriptor(pSD)) {
            return(NDDE_INVALID_SECURITY_DESC);
        }
        dwSize = GetSecurityDescriptorLength(pSD);
        OK = GetSecurityDescriptorControl(pSD, &sdc, &sdr);
        if (!OK) {
            DPRINTF(("NDdeSetShareSecurityA(): cannot get SD control: %d", GetLastError()));
            return(NDDE_INVALID_SECURITY_DESC);
        }
        if (!(sdc & SE_SELF_RELATIVE)) {
            pSDrel = LocalAlloc(LPTR, dwSize);
            if (pSDrel == NULL) {
                // MEMERROR();
                return(NDDE_OUT_OF_MEMORY);
            }
            OK = MakeSelfRelativeSD(pSD, pSDrel, &dwSize);
            if (!OK) {
                DPRINTF(("NDdeSetShareSecurityA(): bad SD: %d", GetLastError()));
                LocalFree(pSDrel);
                return(NDDE_INVALID_SECURITY_DESC);
            }
        } else {
            pSDrel = pSD;
        }
    } else {
        return(NDDE_INVALID_SECURITY_DESC);
    }

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSetShareSecurityA(
                lpszShareName, (unsigned long) si,
                (byte *) pSDrel, dwSize );
            NDdeApiUnbind();
        } else {
            RetValue = NDDE_CANT_ACCESS_SERVER;
        }
        if (!(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return RetValue;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSetShareSecurityA", RpcExceptionCode() ));
        if (!(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept

}

UINT WINAPI
NDdeSetShareSecurityW(
    LPWSTR                      lpszServer,         // server to execute on ( must be NULL )
    LPWSTR                      lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
)
{
    UINT                        RetValue;
    PSECURITY_DESCRIPTOR        pSDrel = NULL;
    DWORD                       dwSize = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD                       sdr;
    BOOL                        OK;

    if (pSD) {
        if (!IsValidSecurityDescriptor(pSD)) {
            return(NDDE_INVALID_SECURITY_DESC);
        }
        dwSize = GetSecurityDescriptorLength(pSD);
        OK = GetSecurityDescriptorControl(pSD, &sdc, &sdr);
        if (!OK) {
            DPRINTF(("NDdeSetShareSecurityW(): cannot get SD control: %d", GetLastError()));
            return(NDDE_INVALID_SECURITY_DESC);
        }
        if (!(sdc & SE_SELF_RELATIVE)) {
            pSDrel = LocalAlloc(LPTR, dwSize);
            if (pSDrel == NULL) {
                // MEMERROR();
                return(NDDE_OUT_OF_MEMORY);
            }
            OK = MakeSelfRelativeSD(pSD, pSDrel, &dwSize);
            if (!OK) {
                DPRINTF(("NDdeSetShareSecurityW(): bad SD: %d", GetLastError()));
                LocalFree(pSDrel);
                return(NDDE_INVALID_SECURITY_DESC);
            }
        } else {
            pSDrel = pSD;
        }
    } else {
        return(NDDE_INVALID_SECURITY_DESC);
    }

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSetShareSecurityW(
                lpszShareName, (unsigned long) si,
                (byte *) pSDrel, dwSize );
            NDdeApiUnbind();
        } else {
            RetValue = NDDE_CANT_ACCESS_SERVER;
        }
        if (!(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return RetValue;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSetShareSecurityW", RpcExceptionCode() ));
        if (!(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


/*
    Enumerate Shares
*/

UINT WINAPI
NDdeShareEnumA (
    LPSTR   lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
)
{
    UINT                RetValue;
    unsigned long       lpnRetSize;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {

            RetValue = wwNDdeShareEnumA(
                nLevel, lpBuffer, cBufSize, lpnEntriesRead,
                lpcbTotalAvailable, &lpnRetSize );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareEnumA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


UINT WINAPI
NDdeShareEnumW (
    LPWSTR  lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
)
{
    UINT                RetValue;
    unsigned long       lpnRetSize;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeShareEnumW(
                nLevel, lpBuffer, cBufSize, lpnEntriesRead,
                lpcbTotalAvailable, &lpnRetSize );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareEnumW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}





UINT WINAPI
NDdeShareGetInfoW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // gets struct
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
)
{
    UINT RetValue;
    DWORD lpnRetSize, lpnSn, lpnAt, lpnIt;
    PUNDDESHAREINFO p;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            if ( lpnItems == (LPWORD) NULL ) {
                return NDDE_INVALID_PARAMETER;
            }
            if ( *lpnItems     != 0 ) {
                return NDDE_INVALID_PARAMETER;
            }
            RetValue = wwNDdeShareGetInfoW(
                lpszShareName, nLevel, lpBuffer, cBufSize,
                lpnTotalAvailable, lpnItems,
                TRUE,   /* RPC, Not a local call */
                &lpnRetSize, &lpnSn, &lpnAt, &lpnIt );
            NDdeApiUnbind();

            if( RetValue == NDDE_NO_ERROR ) {

                p = (PUNDDESHAREINFO)lpBuffer;
                p->lpszShareName    = (LPWSTR)(lpBuffer + lpnSn);
                p->lpszAppTopicList = (LPWSTR)(lpBuffer + lpnAt);
                p->lpszItemList     = (LPWSTR)(lpBuffer + lpnIt);
            }
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareGetInfoW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}



UINT WINAPI
NDdeShareGetInfoA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level
    LPBYTE  lpBuffer,           // gets struct
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
)
{
    PUNDDESHAREINFO     lpUDdeShare;
    UINT                uRtn;
    WCHAR               lpwShareName[MAX_NDDESHARENAME + 1];
    WCHAR               lpwServer[MAX_COMPUTERNAME_LENGTH + 1];
    int                 nLen;

    if( lpszShareName == NULL ||
            lpnTotalAvailable == NULL ||
            lpnItems == NULL ||
            *lpnItems != 0) {
        return NDDE_INVALID_PARAMETER;
    }

    if (lpszServer != NULL) {
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszServer, -1,
                             lpwServer, MAX_COMPUTERNAME_LENGTH + 1 );
    }
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME + 1 );

    /*
     * First try to call with actual buffer given - may be big enough as is.
     */
    uRtn = NDdeShareGetInfoW((lpszServer == NULL) ? NULL : lpwServer,
            lpwShareName,
            nLevel,
            lpBuffer,
            cBufSize,
            lpnTotalAvailable,
            lpnItems);

    if( uRtn == NDDE_BUF_TOO_SMALL ) {
        /*
         * Buffer won't hold UNICODE form so allocate one big enough and
         * try again.
         */
        lpUDdeShare = (PUNDDESHAREINFO)LocalAlloc( LPTR, *lpnTotalAvailable );
        if( lpUDdeShare == NULL)  {
            // MEMERROR();
            return( NDDE_OUT_OF_MEMORY );
        }
        uRtn = NDdeShareGetInfoW((lpszServer == NULL) ? (LPWSTR)lpszServer : lpwServer,
                lpwShareName,
                nLevel,
                (LPBYTE)lpUDdeShare,
                *lpnTotalAvailable,
                lpnTotalAvailable,
                lpnItems);

        if( uRtn == NDDE_NO_ERROR ) {
            /*
             * It fit so convert data to Ansii and see if it will fit in
             * lpBuffer.  If so, cool, else BUF_TOO_SMALL.
             */
            nLen = ConvertNDdeToAnsii( lpUDdeShare, NULL, 0 );
            *lpnTotalAvailable = nLen;

            if( nLen > (int)cBufSize ) {
                LocalFree( lpUDdeShare );
                return NDDE_BUF_TOO_SMALL;
            }

            ConvertNDdeToAnsii( (PUNDDESHAREINFO)lpUDdeShare,
                                (PNDDESHAREINFO) lpBuffer,
                                cBufSize );
        }

        LocalFree( lpUDdeShare );
    } else if( uRtn == NDDE_NO_ERROR ) {
        lpUDdeShare = (PUNDDESHAREINFO)LocalAlloc( LPTR, *lpnTotalAvailable );
        if( lpUDdeShare == NULL)  {
            // MEMERROR();
            return( NDDE_OUT_OF_MEMORY );
        }
        /*
         * Move results into temporary buffer and fixup pointers.
         */
        memcpy(lpUDdeShare, lpBuffer, *lpnTotalAvailable);
        lpUDdeShare->lpszShareName = (LPWSTR)(
                (LPBYTE)(((PNDDESHAREINFO)lpBuffer)->lpszShareName) +
                ((DWORD_PTR)lpUDdeShare - (DWORD_PTR)lpBuffer));
        lpUDdeShare->lpszAppTopicList = (LPWSTR)(
                (LPBYTE)(((PNDDESHAREINFO)lpBuffer)->lpszAppTopicList) +
                ((DWORD_PTR)lpUDdeShare - (DWORD_PTR)lpBuffer));
        /*
         * Convert temporary buffer to Ansii and place into original buffer.
         */
        *lpnTotalAvailable = ConvertNDdeToAnsii(
                lpUDdeShare,
                (PNDDESHAREINFO)lpBuffer,
                *lpnTotalAvailable);
        LocalFree(lpUDdeShare);
    }

    return uRtn;
}



UINT WINAPI
NDdeShareSetInfoW (
    LPWSTR  lpszServer, // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // must point to struct
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {

            PUNDDESHAREINFO pN;
            DWORD nSn, nAt, nIt;

            pN  = (PUNDDESHAREINFO)lpBuffer;

            nSn = (wcslen(pN->lpszShareName) + 1) * sizeof(wchar_t);
            nAt = LengthAppTopicListW( pN->lpszAppTopicList ) *
                sizeof(wchar_t);
            nIt = LengthMultiSzW( pN->lpszItemList ) * sizeof(wchar_t);

            RetValue = wwNDdeShareSetInfoW(
                lpszShareName, nLevel, lpBuffer, cBufSize, sParmNum,
                (byte *)pN->lpszShareName, nSn,
                (byte *)pN->lpszAppTopicList, nAt,
                (byte *)pN->lpszItemList, nIt );

            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareSetInfoW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}



UINT WINAPI
NDdeShareSetInfoA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // must point to struct
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
)
{
    PUNDDESHAREINFO     lpUDdeShare;
    UINT                uRtn;
    int                 nLen;
    WCHAR               lpwShareName[MAX_NDDESHARENAME + 1];
    WCHAR               lpwServer[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR              lpwszServer = lpwServer;

    if(lpszShareName == NULL ||
            lpBuffer == NULL ||
            ((PNDDESHAREINFO)lpBuffer)->lpszShareName == NULL ||
            ((PNDDESHAREINFO)lpBuffer)->lpszAppTopicList == NULL ||
            ((PNDDESHAREINFO)lpBuffer)->lpszItemList == NULL) {
        return NDDE_INVALID_PARAMETER;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME + 1 );

    if (lpszServer != NULL) {
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszServer, -1,
                             lpwServer, MAX_COMPUTERNAME_LENGTH + 1 );
    } else {
        lpwszServer = NULL;
    }

    nLen = ConvertNDdeToUnicode( (PNDDESHAREINFO)lpBuffer, NULL, 0 );
    lpUDdeShare = (PUNDDESHAREINFO)LocalAlloc( LPTR, nLen );
    if( !lpUDdeShare )  {
        // MEMERROR();
        return( NDDE_OUT_OF_MEMORY );
    }
    nLen = ConvertNDdeToUnicode( (PNDDESHAREINFO)lpBuffer, lpUDdeShare, nLen );

    uRtn = NDdeShareSetInfoW(lpwszServer, lpwShareName, nLevel,
            (LPBYTE)lpUDdeShare, nLen, sParmNum);

    LocalFree( lpUDdeShare );

    return uRtn;
}


/*
    Set/Create a trusted share
*/

UINT WINAPI
NDdeSetTrustedShareA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSetTrustedShareA(
                lpszShareName, (unsigned long) dwTrustOptions);
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSetTrustedShareA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}

UINT WINAPI
NDdeSetTrustedShareW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSetTrustedShareW(
                lpszShareName, (unsigned long) dwTrustOptions);
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSetTrustedShareW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}

/*
    Get a trusted share options
*/

UINT WINAPI
NDdeGetTrustedShareA (
    LPSTR       lpszServer,         // server to execute on ( must be NULL )
    LPSTR       lpszShareName,      // name of share to get
    LPDWORD     lpdwTrustOptions,   // trust options to apply
    LPDWORD     lpdwShareModId0,    // share mod id word 0
    LPDWORD     lpdwShareModId1     // share mod id word 1
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeGetTrustedShareA(
                lpszShareName, lpdwTrustOptions,
                lpdwShareModId0, lpdwShareModId1  );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeGetTrustedShareA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}

UINT WINAPI
NDdeGetTrustedShareW (
    LPWSTR      lpszServer,         // server to execute on ( must be NULL )
    LPWSTR      lpszShareName,      // name of share to get
    LPDWORD     lpdwTrustOptions,   // trust options to apply
    LPDWORD     lpdwShareModId0,    // share mod id word 0
    LPDWORD     lpdwShareModId1     // share mod id word 1
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeGetTrustedShareW(
                lpszShareName, lpdwTrustOptions,
                lpdwShareModId0, lpdwShareModId1  );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeGetTrustedShareW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


/*
    Enumerate trusted shares
*/
UINT WINAPI
NDdeTrustedShareEnumA (
    LPSTR   lpszServer,             // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,               // pointer to buffer
    DWORD   cBufSize,               // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
)
{
    UINT                RetValue;
    unsigned long       lpnRetSize;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {

            RetValue = wwNDdeTrustedShareEnumA(
                nLevel, lpBuffer, cBufSize, lpnEntriesRead,
                lpcbTotalAvailable, &lpnRetSize );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeTrustedShareEnumA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}

UINT WINAPI
NDdeTrustedShareEnumW (
    LPWSTR  lpszServer,             // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,               // pointer to buffer
    DWORD   cBufSize,               // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
)
{
    UINT                RetValue;
    unsigned long       lpnRetSize;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeTrustedShareEnumW(
                nLevel, lpBuffer, cBufSize, lpnEntriesRead,
                lpcbTotalAvailable, &lpnRetSize );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeTrustedShareEnumW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


/*
    Special Command
*/
UINT WINAPI
NDdeSpecialCommandA(
    LPSTR   lpszServer,
    UINT    nCommand,
    LPBYTE  lpDataIn,
    UINT    nBytesDataIn,
    LPBYTE  lpDataOut,
    UINT   *lpBytesDataOut
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSpecialCommand(
                nCommand, lpDataIn, nBytesDataIn, lpDataOut,
                    (unsigned long *)lpBytesDataOut );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSpecialCommandA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


UINT WINAPI
NDdeSpecialCommandW(
    LPWSTR  lpszServer,
    UINT    nCommand,
    LPBYTE  lpDataIn,
    UINT    nBytesDataIn,
    LPBYTE  lpDataOut,
    UINT   *nBytesDataOut
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSpecialCommand(
                nCommand, lpDataIn, nBytesDataIn, lpDataOut,
                    (unsigned long *)nBytesDataOut );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSpecialCommandW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


UINT WINAPI
NDdeGetErrorStringA (
    UINT    uErrorCode,         // Error code to get string for
    LPSTR   lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
)
{
    if (!LoadStringA ( hInst, uErrorCode, lpszErrorString, (int)cBufSize )) {
        return NDDE_INTERNAL_ERROR;
    }
    return NDDE_NO_ERROR;
}


UINT WINAPI
NDdeGetErrorStringW (
    UINT    uErrorCode,         // Error code to get string for
    LPWSTR  lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
)
{
    if (!LoadStringW ( hInst, uErrorCode, lpszErrorString, (int)cBufSize )) {
        return NDDE_INTERNAL_ERROR;
    }
    return NDDE_NO_ERROR;
}


//=============== DLL housekeeping ===============//

INT  APIENTRY LibMain(
    HANDLE hInstance,
    DWORD ul_reason_being_called,
    LPVOID lpReserved )
{
    hInst = hInstance;
#if DBG
    DebugInit( "NDDEAPI" );
#endif

    return 1;

    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(ul_reason_being_called);
    UNREFERENCED_PARAMETER(lpReserved);
}

RPC_STATUS NDdeApiBindA( LPSTR pszNetworkAddress )
{
    WCHAR lpwNetworkAddress[UNCLEN+1];

    if( pszNetworkAddress ) {

        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszNetworkAddress, -1,
                    lpwNetworkAddress, UNCLEN+1 );
    } else {
        StringCchCopyW( lpwNetworkAddress, UNCLEN+1, L"" );
    }
    return NDdeApiBindW( lpwNetworkAddress );
}

RPC_STATUS NDdeApiBindW( LPWSTR pszNetworkAddress )
{
    RPC_STATUS status;

    if( pszNetworkAddress != NULL) {
        StringCchCopyW( szNetworkAddress, UNCLEN+1, pszNetworkAddress );
    } else {
        StringCchCopyW( szNetworkAddress, UNCLEN+1, L"" );
    }

    status = RpcStringBindingComposeW(pszUuid,
                                     pszProtocolSequence,
                                     szNetworkAddress,
                                     szEndpoint,
                                     pszOptions,
                                     &pszStringBinding);
    if( status != RPC_S_OK ) {
         StringCchPrintfA (tmpBuf, sizeof(tmpBuf),
             "RpcStringBindingComposeW failed: (0x%x)\n", status );

         MessageBox(NULL, tmpBuf,  "RPC Runtime Error",  MB_ICONEXCLAMATION);
         return(status);
    }

    status = RpcBindingFromStringBindingW( pszStringBinding,
                                           &hNDdeApi );
    RpcStringFreeW( &pszStringBinding );

    if( status != RPC_S_OK ) {
         StringCchPrintfA (tmpBuf, sizeof(tmpBuf),
             "RpcBindingFromStringBindingW failed:(0x%x)\n", status );

         MessageBox(NULL, tmpBuf,  "RPC Runtime Error",  MB_ICONEXCLAMATION);
         return(status);
    }

    // See windows bug #557787; the server part of the fix was checked into Windows Server (the
    // RpcServerRegisterAuthInfo() call in server\nddeapis.c).  This is the client part of the fix,
    // but it will fail if the server did not RegisterAuthInfo.  Since this would break all client
    // apps using nddeapi.dll talking to an XP or earlier netdde server, this part cannot be checked
    // in until later -- at least 1 version after 'Longhorn'
    //
    // status = RpcBindingSetAuthInfo(hNDdeApi, NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
    //                                RPC_C_AUTHN_WINNT, NULL, 0);


    return(status);
}


RPC_STATUS NDdeApiUnbind( void )
{
     RPC_STATUS status;

     status = RpcBindingFree(&hNDdeApi);  // remote calls done; unbind
     if (status) {
          MessageBox(NULL, "RpcBindingFree failed", "RPC Error",
                     MB_ICONSTOP);
     }
     return(status);
}

int LengthMultiSzA( LPSTR pMz )
{
    int nLen;

    nLen = 0;

    if( !pMz ) {
        return 0;
    }
    if( *pMz != '\0' ) {
        while( *pMz++ != '\0' ) {
            nLen++;
            while( *pMz++ != '\0' ) {
                nLen++;
            }
            nLen++;
        }
    } else {
        nLen++;
    }
    nLen++;             /* count the second terminating '\0' */

    return nLen;
}

int LengthMultiSzW( LPWSTR pMz )
{
    int nLen;

    nLen = 0;

    if( !pMz ) {
        return 0;
    }
    if( *pMz != L'\0' ) {
        while( *pMz++ != L'\0' ) {
            nLen++;
            while( *pMz++ != L'\0' ) {
                nLen++;
            }
            nLen++;
        }
    } else {
        nLen++;
    }
    nLen++;             /* count the second terminating '\0' */

    return nLen;
}

int LengthAppTopicListA( LPSTR pMz )
{
    LPSTR a, b, c;
    long x;

    if( !pMz ) {
        return 0;
    }
    if( NDdeParseAppTopicListA( pMz, &a, &b, &c, &x ) ) {
        return strlen(a) + strlen(b) + strlen(c) + 4;
    } else {
        return 0;
    }

}

int LengthAppTopicListW( LPWSTR pMz )
{
    LPWSTR a, b, c;
    long x;

    if( !pMz ) {
        return 0;
    }
    if( NDdeParseAppTopicListW( pMz, &a, &b, &c, &x ) ) {
        return wcslen(a) + wcslen(b) + wcslen(c) + 4;
    } else {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ndeapi\server\nddeapiu.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDEAPIU.C;1  2-Apr-93,16:21:24  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin

    NDDEAPIU.C

    Network DDE Share Api utility routines. Perform support functions for
    main API functions.

    Revisions:
     4-93   IgorM.  Wonderware new API changes for NT. Subdivide and conquer.

   $History: End */

#include <windows.h>
#include <rpc.h>
#include <rpcndr.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>

#include "nddeapi.h"
#include "nddesec.h"
#include "nddelog.h"
#include "nddemsg.h"
#define SKIP_DEBUG_WIN32
#include "debug.h"
#include "hexdump.h"
#include "ndeapi.h"
#include "shrtrust.h"
#include "unddesi.h"

#if DBG
extern BOOL bDebugDSDMErrors;
extern BOOL bDebugDSDMInfo;
#endif

BOOL ValidateMultiSzW( LPWSTR pMz, DWORD cchCount,DWORD *pcbSize);
BOOL ValidateAppTopicListW( LPWSTR appTopicList, DWORD cchCount,DWORD *pcbSize);


/*
    Build Registry Path to the specificied
*/

// cchCount must have room for the null.
unsigned long  BuildRegistrySharePath(LPWSTR lpszShareName,DWORD cchCount,LPWSTR pszShareRegistryPath)
{
    WCHAR szPathSep[] = L"\\";
    DWORD cchTotal;
    
    // should just use wnsprintf(), fix if change the other netdde 
    // areas that are using wsprintf()
    cchTotal = wcslen(DDE_SHARES_KEY_W) + wcslen(szPathSep) + wcslen(lpszShareName) + 1;

    if (cchTotal > cchCount) 
    {
        return NDDE_OUT_OF_MEMORY; // not realy out of memory but this is what netdde has always returned
    }

    wcscpy( pszShareRegistryPath, DDE_SHARES_KEY_W );
    wcscat( pszShareRegistryPath, L"\\" );
    wcscat(pszShareRegistryPath,lpszShareName );

    return NDDE_NO_ERROR;
}


/*
    Parse App Topic List
*/

BOOL NDdeParseAppTopicListW (
    LPWSTR  appTopicList,
    DWORD   cchCount,
    LPWSTR *pOldStr,
    LPWSTR *pNewStr,
    LPWSTR *pStaticStr,
    PLONG   pShareType )
{
    LPWSTR      pStr;
    BOOL        bAnyPresent;
    int         len;
    int         nBarPos;


    *pOldStr    = NULL;
    *pNewStr    = NULL;
    *pStaticStr = NULL;
    *pShareType = 0;

    if ( !appTopicList || 0 == cchCount) {
        return FALSE;
    }

    if (!ValidateAppTopicListW(appTopicList,cchCount,NULL))
    {
        return FALSE;
    }
    
    bAnyPresent = FALSE;
    /*  Check the old style link share. */
    pStr     = appTopicList;
    *pOldStr = pStr;
    len      = wcslen( pStr ); 
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= SHARE_TYPE_OLD;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check the new style link share. */
    pStr     = pStr + wcslen(pStr) + 1;
    *pNewStr = pStr;
    len      = wcslen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= SHARE_TYPE_NEW;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check the static data share. */
    pStr        = pStr + wcslen(pStr) + 1;
    *pStaticStr = pStr;
    len         = wcslen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= SHARE_TYPE_STATIC;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check for the extra NULL at the end of the AppTopicList. */
    pStr = pStr + wcslen(pStr) + 1;
    if( *pStr != L'\0' ) {
        return FALSE;
    }

    return bAnyPresent;
}


/*
    Parse Item List
*/
BOOL
NDdeParseItemList (
    LPWSTR      itemList,
    DWORD       cchCount,
    LONG        cNumItems,
    PLONG       plSize )
{
    LPWSTR      lpszItem = itemList;
    int         n = 0;
    LONG        lSize = 0;
    int         nLen;

    if (NULL == itemList)
    {
        return FALSE;
    }

    // itemList is a NULL separated list that ends with two NULLs
    // first item could be an empty string.

    // validate its a valid Itemlist by making sure we find two NULLs
    // before the end of the string. move from start instead of end
    // since no guarantee string is exactly cchCount.

    if (!ValidateMultiSzW(itemList,cchCount,NULL))
    {
        return FALSE;
    }

    do {
        if( *lpszItem == L'\0' )  {
            break; // while loop
        } else {
            n++;
            nLen = wcslen(lpszItem) + 1;
            
            if (nLen > MAX_ITEMNAME) // Netdde Max definitions don't include the NULL.
            {
                return FALSE;
            }

            if ( wcschr ( lpszItem, SEP_CHAR ) ) // if contains a separator charator the item is invalid
            {
                return FALSE;
            }

            lSize += nLen;
            lpszItem += nLen;
        }
    } while( *lpszItem != L'\0' );

    if( n == 0 )  {
        lSize++;                /* include first NULL of double NULL */
    }
    if( n != cNumItems )  {
        return( FALSE );
    }

    lSize ++;   // room for last NULL
    *plSize = lSize;

    return( TRUE );
}


/*
    Miscellaneous Functions
*/

// given a multiSZ and max count size returns the actual size
// of the multiSZ, if run out if cchCount before hit a valid
// MultiSZ FALSE is returned.
BOOL ValidateMultiSzW( LPWSTR pMz, DWORD cchCount,DWORD *pcbSize)
{
LPWSTR pCurChar = pMz;
DWORD cchRemaining = cchCount;
BOOL fValid = FALSE;
DWORD dwSize = 0;

   if (cchRemaining >= 1 && *pCurChar == L'\0')
   {
       dwSize = 1;
       fValid = TRUE;
   }
   else
   {
        while (cchRemaining > 1) 
        {
            ++dwSize;

            if (pCurChar[0] == L'\0' && pCurChar[1] == L'\0')
            {
                ++dwSize; // add on another char for the terminating NULL
                fValid = TRUE;
                break;
            }

            --cchRemaining;
            ++pCurChar;
        }
   }

    if (fValid)
    {
        if (pcbSize)
        {
            *pcbSize = dwSize;
        }
    }

    return fValid;
}


// validate that given string is in a valid form of an appTopicList ending with two
// NULLs. 

BOOL ValidateAppTopicListW( LPWSTR appTopicList, DWORD cchCount,DWORD *pcbSize)
{
DWORD cchRemaining = cchCount;
DWORD dwNullCount = 0;
LPWSTR pCurPos = appTopicList;
BOOL  fValid = FALSE;
DWORD dwSize = 0;

    /*  There should be three fields separated by NULLs ending with a
        double NULL.  Four NULLs total.  At least one field should
        contain a valid app|topic pair.  No commas are allowed and there
        should be at least one character on each side of the vertical
        bar.
    */

    while (cchRemaining > 1)
    {
        ++dwSize; 

        if (*pCurPos == L'\0')
        {
            if (dwNullCount < 2)
            {
                ++dwNullCount;
            }
            else
            {
                // we found 3 nulls next one should be
                // a null.
                if (pCurPos[1] == L'\0')
                {
                    ++dwSize; // increment for null
                    fValid = TRUE;
                }

                break;
            }
        }

        --cchRemaining;
        ++pCurPos;
    }

    if (fValid)
    {
        if (pcbSize)
        {
            *pcbSize = dwSize;
        }
    }

    return fValid;
}


BOOL
ValidateItemName ( LPWSTR itemName )
{
    if ( !itemName ) {
        return FALSE;
    }

    if ( wcslen(itemName) > MAX_ITEMNAME ) {
        return FALSE;
    }

    if ( wcschr ( itemName, SEP_CHAR ) ) {
        return FALSE;
    }

    return TRUE;
}


/*
    Get Share Serial Number
*/
BOOL
GetShareSerialNumber(
    PWCHAR  pwShareName,
    LPBYTE  lpSerialNumber)
{
    LONG    lRtn;
    HKEY    hKey;
    DWORD   cbData;
    DWORD   dwType;
    WCHAR   szShareSubKey[DDE_SHARE_KEY_MAX];


    if (NDDE_NO_ERROR != BuildRegistrySharePath(pwShareName,
                    DDE_SHARE_KEY_MAX,szShareSubKey))
    {
        return FALSE;
    }

    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                  szShareSubKey,
                  0,
                  KEY_QUERY_VALUE,
                  &hKey );

    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to open DDE share \"HKEY_LOCAL_MACHINE\\%ws\" key for query.",
                szShareSubKey));
        }
#endif
        return FALSE;
    }
    cbData = 2 * sizeof( LONG );
    lRtn = RegQueryValueEx( hKey,
        KEY_MODIFY_ID,
        NULL,
        &dwType,
        lpSerialNumber, &cbData );
    RegCloseKey( hKey );
    if (lRtn != ERROR_SUCCESS) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to query DDE share \"%ws\" serial number.",
                pwShareName));
        }
#endif
        return(FALSE);
    }
    return(TRUE);
}


/*
    Update Share Modify Id  (Unicode)
*/
BOOL
UpdateShareModifyId(
    HKEY    hKey,
    LONG    lSerialId[])
{
    DWORD   cbData;
    LONG    lRtn;

    cbData = 2 * sizeof( LONG );
    lRtn = RegSetValueEx( hKey,
                   KEY_MODIFY_ID,
                   0,
                   REG_BINARY,
                   (LPBYTE)lSerialId, cbData );
    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Set Share Modify Id: %d", lRtn));
        }
#endif
        RegCloseKey( hKey );
        return FALSE;
    }
    RegCloseKey( hKey );
    return(TRUE);
}


/*
    Update DSDM Modify Id   (Unicode)
*/
BOOL
UpdateDSDMModifyId(LONG lSerialId[])
{
    LONG    lRtn;
    HKEY    hDdeShareKey;
    DWORD   dwType;
    DWORD   cbData;

    /*  Get and update the current SerialNumber. */
    /*  Do we have to Lock the value somehow? */
    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                  DDE_SHARES_KEY,
                  0,
                  KEY_WRITE | KEY_READ,
                  &hDdeShareKey );
    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Open DSDM Key: %d", lRtn));
        }
#endif
        return FALSE;
    }
    cbData = 2 * sizeof( LONG );
    lRtn = RegQueryValueEx( hDdeShareKey,
                   KEY_MODIFY_ID,
                   NULL,
                   &dwType,
                   (LPBYTE)lSerialId,
                   &cbData );
    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Query DSDM Modify Id: %d", lRtn));
        }
#endif
        RegCloseKey( hDdeShareKey );
        return FALSE;
    }

    if( ++lSerialId[0] == 0 ) {
        ++lSerialId[1];
    }
    lRtn = RegSetValueEx( hDdeShareKey,
                   KEY_MODIFY_ID,
                   0,
                   REG_BINARY,
                   (LPBYTE)lSerialId, cbData );
    RegCloseKey( hDdeShareKey );
    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Set DSDM Modify Id: %d", lRtn));
        }
#endif
        return FALSE;
    }
    return(TRUE);
}


/*
    Get Share's Security Descriptor stored in Registry (UNICODE)
*/
BOOL
GetShareNameSD(
    HKEY                    hKey,
    PSECURITY_DESCRIPTOR   *ppSD,
    PDWORD                  pcbData )
{
    PSECURITY_DESCRIPTOR pSD;
    DWORD       cbData;
    DWORD       dwType;
    LONG        lRtn;
    BOOL        OK = TRUE;

    /*  **********Read the key security info here. **************/
    /*  Get the size of the SD. */
    cbData = 0;
    lRtn = RegQueryValueExW( hKey,
                   L"SecurityDescriptor",
                   NULL,
                   &dwType,
                   NULL, &cbData );

    if( (lRtn != ERROR_MORE_DATA) && (lRtn != ERROR_SUCCESS) ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Probe share SD size: %d, cbData: %d",
                lRtn, cbData));
        }
#endif
        *pcbData = 0;
        *ppSD = NULL;
        return FALSE;
    }

    pSD = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cbData );
    if( !pSD ) {
        MEMERROR();
        /* LocalAlloc failed: %1 */
        NDDELogErrorW( MSG406, LogStringW( L"%d", GetLastError() ), NULL );
        *ppSD = NULL;
        return FALSE;
    }
    lRtn = RegQueryValueExW( hKey,
                   L"SecurityDescriptor",
                   NULL,
                   &dwType,
                   (LPBYTE)pSD, &cbData );

    if( (lRtn == ERROR_SUCCESS) && (OK = IsValidSecurityDescriptor(pSD)) ) {
        *ppSD = pSD;
        *pcbData = cbData;
        return TRUE;
    } else {
#if DBG
        if (!OK && bDebugDSDMErrors) {
            DPRINTF(("Invalid SD fished out of Registery: %d", GetLastError()));
            HEXDUMP(pSD, cbData);
        }
#endif
        /* Could not read the ShareName Security Descriptor: %1 */
        NDDELogErrorW( MSG415, LogStringW( L"%d", GetLastError() ), NULL );
        *ppSD = NULL;
        *pcbData = 0;
        LocalFree( pSD );
        return FALSE;
    }
}


/*
    Share Access Check And Audit
*/
BOOL
NDdeShareAccessCheckAudit(
    LPWSTR                  lpszShareName,
    PSECURITY_DESCRIPTOR    pSD,
    DWORD                   dwDesiredAccess,
    PGENERIC_MAPPING        pgm,
    BOOL                    fObjectCreation,
    BOOL                    fObjectDeletion,
    DWORD                  *pGrantedAccess,
    BOOL                   *pStatus )
{
    BOOL        OK;
    BOOL        fGenerateOnClose;
    HANDLE      hAudit;

    /*  Make sure the caller has the appropriate access rights. */
    hAudit = &hAudit;
    OK = AccessCheckAndAuditAlarmW(
        L"NetDDE",
        (LPVOID)&hAudit,
        L"DDE Share",
        lpszShareName,
        pSD,
        dwDesiredAccess,
        pgm,
        fObjectCreation,
        pGrantedAccess,
        pStatus,
        &fGenerateOnClose );

    if( OK && *pStatus )  {
#if DBG
        if (bDebugDSDMInfo) {
            DPRINTF(( "NddeShareAccessCheckAudit: %x => %x, %d/%d",
                dwDesiredAccess, *pGrantedAccess, *pStatus, OK ));
        }
#endif
        if (fObjectDeletion) {
            ObjectDeleteAuditAlarmW( L"NetDDE", (LPVOID)&hAudit,
                fGenerateOnClose );
        }
        ObjectCloseAuditAlarmW( L"NetDDE", (LPVOID)&hAudit,
            fGenerateOnClose );
    } else {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(( "Error -- NddeShareAccessCheckAudit: lpszShareName=%ws, pStatus=%d, OK=%d, Err=%d",
                lpszShareName, *pStatus, OK, GetLastError() ));
        }
#endif
    }

    return OK;
}


/*
    Build a new Security Descriptor from an old one and an updated one
*/
BOOL
BuildNewSecurityDescriptor(
    PSECURITY_DESCRIPTOR    pNewSecurityDescriptor,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pPreviousSecurityDescriptor,
    PSECURITY_DESCRIPTOR    pUpdatedSecurityDescriptor
)
{
    BOOL Defaulted;
    PSID pOwnerSid;
    PSID pGroupSid;
    BOOL DaclPresent;
    PACL pDacl;
    BOOL SaclPresent;
    PACL pSacl;
    BOOL OK = TRUE;

    if( OK ) {
        if( SecurityInformation & OWNER_SECURITY_INFORMATION )
            OK = GetSecurityDescriptorOwner( pUpdatedSecurityDescriptor,
                                             &pOwnerSid, &Defaulted );
        else
            OK = GetSecurityDescriptorOwner( pPreviousSecurityDescriptor,
                                             &pOwnerSid, &Defaulted );

        if( OK )
            SetSecurityDescriptorOwner( pNewSecurityDescriptor,
                                        pOwnerSid, Defaulted );
    }

    if( OK ) {
        if( SecurityInformation & DACL_SECURITY_INFORMATION )
            OK = GetSecurityDescriptorDacl( pUpdatedSecurityDescriptor,
                                            &DaclPresent, &pDacl, &Defaulted );
        else
            OK = GetSecurityDescriptorDacl( pPreviousSecurityDescriptor,
                                            &DaclPresent, &pDacl, &Defaulted );

        if( OK )
            SetSecurityDescriptorDacl( pNewSecurityDescriptor,
                                       DaclPresent, pDacl, Defaulted );
    }

    if( OK ) {
        if( SecurityInformation & SACL_SECURITY_INFORMATION )
            OK = GetSecurityDescriptorSacl( pUpdatedSecurityDescriptor,
                                            &SaclPresent, &pSacl, &Defaulted );
        else
            OK = GetSecurityDescriptorSacl( pPreviousSecurityDescriptor,
                                            &SaclPresent, &pSacl, &Defaulted );

        if( OK )
            SetSecurityDescriptorSacl( pNewSecurityDescriptor,
                                       SaclPresent, pSacl, Defaulted );
    }

    if( OK ) {
        if ( SecurityInformation & GROUP_SECURITY_INFORMATION ) {
            OK = GetSecurityDescriptorGroup( pUpdatedSecurityDescriptor,
                                         &pGroupSid, &Defaulted );
        } else {
            OK = GetSecurityDescriptorGroup( pPreviousSecurityDescriptor,
                                         &pGroupSid, &Defaulted );
        }

        if( OK )
            OK = SetSecurityDescriptorGroup( pNewSecurityDescriptor,
                                         pGroupSid, Defaulted );
    }

    return OK;
}


/*
    Make a Self Relative Security Descriptor
 */
PSECURITY_DESCRIPTOR
AllocCopySecurityDescriptor(
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    PDWORD                  pLength)
{
    PSECURITY_DESCRIPTOR    pSecurityDescriptorCopy;
    DWORD                   Length;
    BOOL                    OK;

    Length = GetSecurityDescriptorLength(pSecurityDescriptor);

    if(pSecurityDescriptorCopy =
            (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, Length)) {
        MakeSelfRelativeSD(pSecurityDescriptor,
                           pSecurityDescriptorCopy,
                           &Length);
        *pLength = Length;
        OK = IsValidSecurityDescriptor(pSecurityDescriptorCopy);
        if (!OK) {
#if DBG
            if (bDebugDSDMErrors) {
                DPRINTF(("Created an invalid SD: %d, Length: %d", GetLastError(), Length));
                HEXDUMP(pSecurityDescriptorCopy, Length);
            }
#endif
            LocalFree(pSecurityDescriptorCopy);
            pSecurityDescriptorCopy = NULL;
        }
    } else {
        MEMERROR();
    }

    return pSecurityDescriptorCopy;
}


/*
    Extract Current Thread token handle
*/
BOOL
GetTokenHandleRead( PHANDLE pTokenHandle )
{
    if( !OpenThreadToken( GetCurrentThread(),
                          TOKEN_READ,
                          FALSE,
                          pTokenHandle ) ) {

        if( GetLastError() == ERROR_NO_TOKEN ) {
            if( !OpenProcessToken( GetCurrentProcess(),
                                   TOKEN_READ,
                                   pTokenHandle ) ) {
                return FALSE;
            }
        } else {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\cfconvrt.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "CFCONVRT.C;2  25-Feb-93,11:32:40  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

//#define   DEBUG_CONVERT

#include    <memory.h>
#include    <string.h>
#include    <dde.h>
#include    "dde1.h"
#include    "host.h"
#include    "windows.h"
#include    "netbasic.h"
#include    "ddepkt.h"
#include    "ddepkts.h"
#include    "debug.h"
#include    "hexdump.h"
#include    "getglobl.h"
#include    "userdde.h"
#include    "nddemsg.h"
#include    "nddelog.h"


extern  BOOL    bDebugInfo;


#pragma pack(2)

typedef struct tagMETAFILEPICT16 {    /* mfp16wow32 */
    WORD    mm;
    WORD    xExt;
    WORD    yExt;
    WORD    hMF;
} METAFILEPICT16;
typedef METAFILEPICT16 UNALIGNED *LPMETAFILEPICT16;

#pragma pack(1)

typedef struct tagBITMAP16
  {
    WORD        bmType;
    WORD        bmWidth;
    WORD        bmHeight;
    WORD        bmWidthBytes;
    BYTE        bmPlanes;
    BYTE        bmBitsPixel;
    LPVOID      bmBits;
  } BITMAP16;
typedef BITMAP16 UNALIGNED *LPBITMAP16;


#pragma pack()


BOOL
FAR PASCAL
ConvertDataToPktMetafile(
    LPSTR   *plpDataPortion,
    DWORD   *pdwSize,
    HANDLE  *phDataComplex,
    BOOL    bWin16Con )
{
    HANDLE              hPict;
    BOOL                ok = TRUE;
    LPMETAFILEPICT      lpMetafilePict;
    LPMETAFILEPICT16    lpMetafilePict16;
    LPMETAFILEPICT      lpMetafilePictNew;
    LPSTR               lpDataPortion = *plpDataPortion;
    DWORD               dwSize = *pdwSize;
    DWORD               dwhMFSize;
    DWORD               dwErr;
    HANDLE              hDataComplex = *phDataComplex;

    /* the only thing in the DDE data is the handle to the METAFILEPICT */
    hPict = *((LPHANDLE)lpDataPortion);

    lpMetafilePict = (LPMETAFILEPICT) GlobalLock( hPict );
    if( lpMetafilePict )  {
        if( lpMetafilePict->hMF )  {
            dwhMFSize = GetMetaFileBitsEx(lpMetafilePict->hMF, 0, NULL);
            if (dwhMFSize == 0) {
                dwErr = GetLastError();
                DPRINTF(("Unable to get size of Meta File object: %d", dwErr));
                /* GetMetaFileBitsEx() failed: %1 */
                NDDELogError(MSG079, LogString("%d", dwErr), NULL);
                GlobalUnlock(hPict);
                return(FALSE);
            }


            if (bWin16Con) {
                dwSize = sizeof(METAFILEPICT16) + dwhMFSize;
            } else {
                dwSize = sizeof(METAFILEPICT) + dwhMFSize;
            }

            hDataComplex = GlobalAlloc( GMEM_MOVEABLE, dwSize );
            if( hDataComplex )  {
                // copy the metafile after the matafilepict structure

                // unlocked later
                lpMetafilePictNew = (LPMETAFILEPICT) GlobalLock(
                    hDataComplex );

                // copy metafilepict part
                if (bWin16Con) {
                    lpMetafilePict16 = (LPMETAFILEPICT16)lpMetafilePictNew;
                    lpMetafilePict16->mm = (WORD) lpMetafilePict->mm;
                    lpMetafilePict16->xExt = (WORD) lpMetafilePict->xExt;
                    lpMetafilePict16->yExt = (WORD) lpMetafilePict->yExt;
                    lpDataPortion = ((LPBYTE) lpMetafilePictNew) + sizeof(METAFILEPICT16);
                } else {
                    *lpMetafilePictNew = *lpMetafilePict;
                    lpDataPortion = ((LPBYTE) lpMetafilePictNew) + sizeof(METAFILEPICT);
                }

                if (GetMetaFileBitsEx(lpMetafilePict->hMF, dwhMFSize,
                        lpDataPortion) != dwhMFSize) {
                    dwErr = GetLastError();
                    DPRINTF(("hMF copy failed using GetMetaFileBitsEx(): %d", dwErr));
                    /* GetMetaFileBitsEx() failed: %1 */
                    NDDELogError(MSG079, LogString("%d", dwErr), NULL);
                    GlobalUnlock(hPict);
                    GlobalUnlock(hDataComplex);
                    GlobalFree(hDataComplex);
                    return(FALSE);
                }
                lpDataPortion = (LPSTR) lpMetafilePictNew;
            } else {
                MEMERROR();
                /*  Not enough memory for metafile copy: %1 */
                NDDELogError(MSG050,
                    LogString("%d", dwSize), NULL);
                ok = FALSE;
            }
        } else {
            /*  No metafile in metafilepict */
            NDDELogError(MSG051, NULL);
            ok = FALSE;
        }
        GlobalUnlock( hPict );
    } else {
        /*  Could not lock metafilepict */
        NDDELogError(MSG052, NULL);
        ok = FALSE;
    }

    *plpDataPortion = lpDataPortion;
    *pdwSize = dwSize;
    *phDataComplex = hDataComplex;
    return( ok );
}

HANDLE
FAR PASCAL
ConvertPktToDataMetafile(
    LPDDEPKT        lpDdePkt,
    LPDDEPKTDATA    lpDdePktData,
    BOOL            bWin16Con )
{
    HANDLE              hData;
    HANDLE              hPict = 0;
    HANDLE              hPictMetafile = 0;
    DWORD               dwhMFSize;
    DWORD               dwErr;
    LPBYTE              lphMF;
    LPMETAFILEPICT16    lpMetafilePict16;
    LPMETAFILEPICT      lpMetafilePict;
    LPSTR               lpData;
    BOOL                ok = TRUE;

    hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        sizeof(HANDLE)+sizeof(DDELN) );
    if( hData == 0 )  {
        MEMERROR();
        return( 0 );
    }
    lpData = GlobalLock( hData );
    if( lpData == NULL )  {
        /*  Couldn't lock memory for metafile handle */
        NDDELogError(MSG053, NULL);
        GlobalFree( hData );
        return( 0 );
    }

    /* copy in data portion */
    hPict = GlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        (DWORD) sizeof(METAFILEPICT) );
    if( hPict )  {
        lpMetafilePict = (LPMETAFILEPICT) GlobalLock( hPict );
        if (lpMetafilePict == NULL) {
            /*  Couldn't lock memory for metafile handle */
            NDDELogError(MSG053, NULL);
            GlobalFree( hPict );
            GlobalUnlock( hData );
            GlobalFree( hData );
            return( 0 );
        }

        // copy METAFILEPICT struct
        if (bWin16Con) {
            dwhMFSize = lpDdePktData->dp_data_sizeData - sizeof(METAFILEPICT16);
            lphMF = GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData )
                + sizeof(METAFILEPICT16);
            lpMetafilePict16 = (LPMETAFILEPICT16) GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData );
            lpMetafilePict->mm = (DWORD) lpMetafilePict16->mm;
            lpMetafilePict->xExt = (DWORD) lpMetafilePict16->xExt;
            lpMetafilePict->yExt = (DWORD) lpMetafilePict16->yExt;
        } else {
            dwhMFSize = lpDdePktData->dp_data_sizeData - sizeof(METAFILEPICT);
            lphMF = GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData )
                + sizeof(METAFILEPICT);
            memcpy( lpMetafilePict,
                GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData ),
                sizeof(METAFILEPICT) );
        }

        // create the HMF
        lpMetafilePict->hMF = SetMetaFileBitsEx(dwhMFSize, lphMF);
        hPictMetafile = lpMetafilePict->hMF;
        if (hPictMetafile == 0) {
            dwErr = GetLastError();
            DPRINTF(("SetMetaFileBitsEx(size == %d) failed: %d, mode: %d",
                dwhMFSize, dwErr, bWin16Con));
            /* SetMetaFileBitsEx() failed: %1 */
            NDDELogError(MSG080, LogString("%d", dwErr), NULL);
            ok = FALSE;
        }

        GlobalUnlock( hPict );
    } else {
        MEMERROR();
        /*  Not enough memory for metafilepict: %1  */
        NDDELogError(MSG055,
            LogString("%d", sizeof(METAFILEPICT)), NULL);
        ok = FALSE;
    }

    if( ok )  {
        *( (LPHANDLE) ((LPDATA)lpData)->info ) = hPict;
        GlobalUnlock(hData);
        return( hData );
    } else {
        if( hPict )  {
            GlobalUnlock(hPict);
            GlobalFree( hPict );
        }
        if( hPictMetafile )  {
            GlobalFree( hPictMetafile );
        }
        if (hData) {
            GlobalUnlock(hData);
            GlobalFree(hData);
        }
        return( NULL );
    }
}

/*
 * One might ask - why are they using GetBitmapBits() to convert the
 * bitmap to bits instead of the more sane GetDIBits() API.  History
 * has it that this came from clipbrd of ancient times.  Clipbrd dealt with
 * this problem by storing a parellel CF_DIB format along with the near-
 * useless bits of CF_BITMAP fame.  So for compatability, we cannot fix this
 * to do the correct thing...ah life in the compatability lane.
 */
BOOL
FAR PASCAL
ConvertDataToPktBitmap(
    LPSTR   *plpDataPortion,
    DWORD   *pdwSize,
    HANDLE  *phDataComplex,
    BOOL    bWin16Con )
{
    HANDLE              hBitmap;
    BITMAP              Bitmap;
    LPBITMAP16          lpBitmap16;
    BOOL                ok = TRUE;
    LPBITMAP            lpBitmap;
    LPSTR               lpDataPortion = *plpDataPortion;
    LPBYTE              lpData = NULL;
    DWORD               dwSize = *pdwSize;
    DWORD               cbBitmap;
    HANDLE              hDataComplex = *phDataComplex;

    /* the only thing in the DDE data is the handle to the BITMAP */
    hBitmap = *((LPHANDLE)lpDataPortion);
#if DBG
    if (bDebugInfo) {
        DPRINTF(( "Info from DDE: %ld bytes", dwSize ));
        HEXDUMP( (LPSTR)lpDataPortion, (int) min( (DWORD)0x40, dwSize ) );
//        DPRINTF(( "BITMAP %04X size: %ld", hBitmap, GlobalSize(hBitmap) ));
    }
#endif

    lpBitmap = &Bitmap;
    // get bitmap header
    ok = GetObject ( hBitmap, sizeof(BITMAP), lpBitmap );

    if( ok )  {     // calculate # of bytes needed to store bitmap bits
        cbBitmap = GetBitmapBits(hBitmap, 0, NULL);
        if (bWin16Con) {
            dwSize = sizeof(BITMAP16) + cbBitmap;
        } else {
            dwSize = sizeof(BITMAP) + cbBitmap;
        }

#if DBG
        if (bDebugInfo) {
            DPRINTF(( "bitmap %Fp %ld bytes", lpBitmap, dwSize ));
            HEXDUMP( (LPSTR) lpBitmap, 0x40 );
        }
#endif
        hDataComplex = GlobalAlloc( GMEM_MOVEABLE, dwSize );
        if( hDataComplex )  {
            // unlocked later
            lpData = GlobalLock( hDataComplex );

            // copy bitmap header
            if (bWin16Con) {
                lpBitmap16 = (LPBITMAP16) lpData;
                lpBitmap16->bmType = (WORD) lpBitmap->bmType;
                lpBitmap16->bmWidth = (WORD) lpBitmap->bmWidth;
                lpBitmap16->bmHeight = (WORD) lpBitmap->bmHeight;
                lpBitmap16->bmWidthBytes = (WORD) ((lpBitmap->bmWidth
                    * lpBitmap->bmBitsPixel + 15) >> 3) & 0xFFFE;
//                lpBitmap16->bmWidthBytes = (WORD) lpBitmap->bmWidthBytes;
                lpBitmap16->bmPlanes = (BYTE) lpBitmap->bmPlanes;
                lpBitmap16->bmBitsPixel = (BYTE) lpBitmap->bmBitsPixel;
                lpDataPortion = ((LPBYTE) lpData) + sizeof(BITMAP16);
            } else {
                memcpy ( lpData, lpBitmap, sizeof(BITMAP ) );
                lpDataPortion = ((LPBYTE) lpData) + sizeof(BITMAP);
            }
            // copy bits
            if ( !GetBitmapBits ( hBitmap, cbBitmap, lpDataPortion)) {
                    ok = FALSE;
            }
#ifdef  DEBUG_CONVERT
            DPRINTF(("ConvertDataToPktBitmap(), size: %d, mode: %d", dwSize, bWin16Con));
            HEXDUMP(lpData, dwSize);
#endif
        } else {
            MEMERROR();
            /*  Not enough memory for bitmap copy: %1   */
            NDDELogError(MSG056,
                LogString("%d", dwSize), NULL);
            ok = FALSE;
        }
    } else {
        /*  Could not lock bitmap   */
        NDDELogError(MSG057, NULL);
        ok = FALSE;
    }

    *plpDataPortion = lpData;

    *pdwSize = dwSize;
    *phDataComplex = hDataComplex;
    return( ok );
}

HANDLE
FAR PASCAL
ConvertPktToDataBitmap(
    LPDDEPKT        lpDdePkt,
    LPDDEPKTDATA    lpDdePktData,
    BOOL            bWin16Con )
{
    HANDLE              hData;
    HANDLE              hBitmap = NULL;
    BITMAP              Bitmap;
    LPBITMAP            lpBitmap;
    LPBITMAP16          lpBitmap16;
    LPSTR               lpData;
    BOOL                ok = TRUE;

    hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        sizeof(HANDLE) + sizeof(DDELN) );
    if( hData == NULL )  {
        MEMERROR();
        /*  Not enough memory for bitmap copy: %1   */
        NDDELogError(MSG056,
            LogString("%d", sizeof(HANDLE) + sizeof(DDELN)), NULL);
        return( NULL );
    }

    lpData = GlobalLock( hData );
    if( lpData == NULL )  {
        /*  Could not lock memory for bitmap handle */
        NDDELogError(MSG058, NULL);
        GlobalFree( hData );
        return( NULL );
    }

    /* copy in bitmap header */
    if (bWin16Con) {
        lpBitmap = &Bitmap;
        lpBitmap16 = (LPBITMAP16)GetStringOffset( lpDdePkt,
                lpDdePktData->dp_data_offsData );
        lpBitmap->bmType = (DWORD) lpBitmap16->bmType;
        lpBitmap->bmWidth = (DWORD) lpBitmap16->bmWidth;
        lpBitmap->bmHeight = (DWORD) lpBitmap16->bmHeight;
        lpBitmap->bmWidthBytes = (DWORD) lpBitmap16->bmWidthBytes;
        lpBitmap->bmPlanes = (WORD) lpBitmap16->bmPlanes;
        lpBitmap->bmBitsPixel = (WORD) lpBitmap16->bmBitsPixel;
        lpBitmap->bmBits = (LPBYTE)lpBitmap16 + sizeof(BITMAP16);
    } else {
        lpBitmap = (LPBITMAP)GetStringOffset( lpDdePkt,
                lpDdePktData->dp_data_offsData );
        lpBitmap->bmBits = (LPBYTE)lpBitmap + sizeof(BITMAP);
    }

#ifdef  DEBUG_CONVERT
    DPRINTF(("ConvertPktToDataBitmap(), size: %d, mode: %d", lpDdePktData->dp_data_sizeData, bWin16Con));
    HEXDUMP(GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData ),
            lpDdePktData->dp_data_sizeData);
#endif

    if ( lpBitmap->bmWidth ) {      // make sure no 0 width
            // assume bits follow header in packet data

            hBitmap = CreateBitmapIndirect ( lpBitmap );
    }

    if( hBitmap )  {
        *( (LPHANDLE) ((LPDATA)lpData)->info ) = hBitmap;
        GlobalUnlock(hData);
        return( hData );
    } else {
        if( hBitmap )  {
            GlobalFree( hBitmap );
        }
        GlobalUnlock(hData);
        GlobalFree(hData);
        return( NULL );
    }
}


BOOL
FAR PASCAL
ConvertDataToPktEnhMetafile(
    LPSTR   *plpDataPortion,
    DWORD   *pdwSize,
    HANDLE  *phDataComplex )
{
    DWORD           dwSize = *pdwSize;
    LPSTR           lpDataPortion = *plpDataPortion;
    HANDLE          hDataComplex = *phDataComplex;
    HENHMETAFILE    hEMF;
    LPBYTE          lpEnhMetafile;
    DWORD           dwhEMFSize;
    DWORD           dwErr;
    BOOL            ok = TRUE;

    hEMF = *((LPHANDLE)lpDataPortion);
    dwhEMFSize = GetEnhMetaFileBits(hEMF, 0, NULL);
    if (dwhEMFSize == 0) {
        dwErr = GetLastError();
        DPRINTF(("Unable to get size of Meta Enhanced File object: %d", dwErr));
        /* GetEnhMetaFileBits() failed: %1 */
        NDDELogError(MSG081, LogString("%d", dwErr), NULL);
        return(FALSE);
    }
    hDataComplex = GlobalAlloc( GMEM_MOVEABLE, dwhEMFSize );
    if( hDataComplex )  {
        lpEnhMetafile = (LPBYTE) GlobalLock( hDataComplex );
        if (GetEnhMetaFileBits(hEMF, dwhEMFSize,
                    lpEnhMetafile) != dwhEMFSize) {
            dwErr = GetLastError();
            DPRINTF(("hEMF copy failed using GetEnhMetaFileBits(): %d", dwErr));
            /* GetMetaFileBitsEx() failed: %1 */
            NDDELogError(MSG081, LogString("%d", dwErr), NULL);
            GlobalUnlock(hDataComplex);
            GlobalFree(hDataComplex);
            ok = FALSE;
        }
        lpDataPortion = (LPSTR) lpEnhMetafile;
    } else {
        MEMERROR();
        /*  Not enough memory for metafile copy: %1 */
        NDDELogError(MSG050, LogString("%d", dwhEMFSize), NULL);
        ok = FALSE;
    }

    *plpDataPortion = lpDataPortion;
    *pdwSize = dwhEMFSize;
    *phDataComplex = hDataComplex;
    return( ok );
}

HANDLE
FAR PASCAL
ConvertPktToDataEnhMetafile(
    LPDDEPKT        lpDdePkt,
    LPDDEPKTDATA    lpDdePktData )
{
    HANDLE              hData;
    LPBYTE              lpEMF;
    HENHMETAFILE        hEMF;
    HANDLE              hBitmap = NULL;
    LPSTR               lpData;
    DWORD               dwErr;
    BOOL                ok = TRUE;

    hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        sizeof(HANDLE) + sizeof(DDELN) );
    if( hData == NULL )  {
        MEMERROR();
        /*  Not enough memory for bitmap copy: %1   */
        NDDELogError(MSG056,
            LogString("%d", sizeof(HANDLE) + sizeof(DDELN)), NULL);
        return( NULL );
    }

    lpData = GlobalLock( hData );
    if( lpData == NULL )  {
        /*  Could not lock memory for bitmap handle */
        NDDELogError(MSG058, NULL);
        GlobalFree( hData );
        return( NULL );
    }

    /* copy in data portion */

    lpEMF = (LPBYTE)GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsData );
    hEMF = SetEnhMetaFileBits( lpDdePktData->dp_data_sizeData, lpEMF);
    if (hEMF == 0) {
        dwErr = GetLastError();
        DPRINTF(("SetEnhMetaFileBitsEx(size == %d) failed: %d",
            lpDdePktData->dp_data_sizeData, dwErr));
        /* SetEnhMetaFileBits() failed: %1 */
        NDDELogError(MSG082, LogString("%d", dwErr), NULL);
        ok = FALSE;
    }

    if( ok )  {
        *( (LPHANDLE) ((LPDATA)lpData)->info ) = hEMF;
        GlobalUnlock(hData);
        return( hData );
    } else {
        if( hEMF )  {
            GlobalFree( hEMF );
        }
        GlobalUnlock(hData);
        GlobalFree(hData);
        return( NULL );
    }
}


BOOL
FAR PASCAL
ConvertDataToPktDIB(
    LPSTR   *plpDataPortion,
    DWORD   *pdwSize,
    HANDLE  *phDataComplex )
{
    DWORD           dwSize = *pdwSize;
    LPSTR           lpDataPortion = *plpDataPortion;
    HANDLE          hDataComplex = *phDataComplex;
    HANDLE          hIndirect;
    LPBYTE          lpIndirect;
    DWORD           dwErr;
    BOOL            ok = TRUE;

    hIndirect = *((LPHANDLE)lpDataPortion);

    dwSize = (DWORD)GlobalSize(hIndirect);
    if (dwSize == 0) {
        dwErr = GetLastError();
        DPRINTF(("Unable to get size of Indirect object: %d", dwErr));
        /* GlobalSize() for indirect object failed: %1 */
        NDDELogError(MSG086, LogString("%d", dwErr), NULL);
        return(FALSE);
    }
    hDataComplex = GlobalAlloc( GMEM_MOVEABLE, dwSize );
    if( hDataComplex )  {
        lpDataPortion = (LPSTR) GlobalLock( hDataComplex );
        lpIndirect = (LPBYTE) GlobalLock(hIndirect);
        memcpy(lpDataPortion, lpIndirect, dwSize);
    } else {
        MEMERROR();
        /*  Not enough memory for metafile copy: %1 */
        NDDELogError(MSG050, LogString("%d", dwSize), NULL);
        ok = FALSE;
    }
#ifdef  DEBUG_CONVERT
    DPRINTF(("ConvertDataToPktDIB(), size: %d", dwSize));
    HEXDUMP(lpDataPortion, dwSize);
#endif
    *plpDataPortion = lpDataPortion;
    *pdwSize = dwSize;
    *phDataComplex = hDataComplex;
    return( ok );
}

HANDLE
FAR PASCAL
ConvertPktToDataDIB(
    LPDDEPKT        lpDdePkt,
    LPDDEPKTDATA    lpDdePktData )
{
    HANDLE              hData;
    LPBYTE              lpIndirectData;
    HANDLE              hIndirect = NULL;
    LPSTR               lpData;
    LPBYTE              lpStupidData;
    DWORD               dwErr;
    BOOL                ok = TRUE;


    hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        sizeof(HANDLE) + sizeof(DDELN) );
    if( hData == NULL )  {
        MEMERROR();
        /* Unable to allocate enough memory [%1] for %2 conversion: %3 */
        NDDELogError(MSG085,
            LogString("%d", sizeof(HANDLE) + sizeof(DDELN)),
            "CF_DIB", LogString("%d", GetLastError()), NULL);
        return( NULL );
    }

    lpData = GlobalLock( hData );
    if( lpData == NULL )  {
        /*  Could not lock memory for bitmap handle */
        NDDELogError(MSG058, NULL);
        GlobalFree( hData );
        return( NULL );
    }

    /* copy in data portion */

    lpIndirectData = (LPBYTE)GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsData );
    hIndirect = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
            lpDdePktData->dp_data_sizeData);
    if (hIndirect == 0) {
        MEMERROR();
        dwErr = GetLastError();
        DPRINTF(("Unalbe to allocate memory for indirect object of size %d. Error: %d",
            lpDdePktData->dp_data_sizeData, dwErr));
        /* Unable to allocate enough memory [%1] for %2 conversion: %3 */
        NDDELogError(MSG085,
            LogString("%d", lpDdePktData->dp_data_sizeData),
            "CF_DIB", LogString("%d", dwErr), NULL);
        ok = FALSE;
    } else {
        lpStupidData = GlobalLock(hIndirect);
        memcpy(lpStupidData, lpIndirectData, lpDdePktData->dp_data_sizeData);

#ifdef  DEBUG_CONVERT
        DPRINTF(("ConvertPktToDataDIB(), size: %d", lpDdePktData->dp_data_sizeData));
        HEXDUMP(lpStupidData, lpDdePktData->dp_data_sizeData);
#endif
        GlobalUnlock(hIndirect);
    }

    if( ok )  {
        *( (LPHANDLE) ((LPDATA)lpData)->info ) = hIndirect;
        GlobalUnlock(hData);
        return( hData );
    } else {
        if( hIndirect )  {
            GlobalFree( hIndirect );
        }
        GlobalUnlock(hData);
        GlobalFree(hData);
        return( NULL );
    }
}

BOOL
FAR PASCAL
ConvertDataToPktPalette(
    LPSTR   *plpDataPortion,
    DWORD   *pdwSize,
    HANDLE  *phDataComplex )
{
    DWORD           dwSize = *pdwSize;
    LPSTR           lpDataPortion = *plpDataPortion;
    HANDLE          hDataComplex = *phDataComplex;
    LOGPALETTE     *lpLogPalette = NULL;
    HANDLE          hPalette;
    DWORD           dwErr;
    DWORD           dwCount;
    DWORD           dwTmp;
    BOOL            ok = TRUE;

    hPalette = *((LPHANDLE)lpDataPortion);
    dwCount = GetPaletteEntries(hPalette, 0, 0, NULL);
    if (dwCount == 0) {
        dwErr = GetLastError();
        DPRINTF(("Unable to get number of palette entries: %d", dwErr));
        /* GetPaletteEntries() failed: %1 */
        NDDELogError(MSG083, LogString("%d", dwErr), NULL);
        return(FALSE);
    }
    dwSize = dwCount * sizeof(PALETTEENTRY) + sizeof(LOGPALETTE) - sizeof(PALETTEENTRY);
    hDataComplex = GlobalAlloc( GMEM_MOVEABLE, dwSize );
    if( hDataComplex )  {
        MEMERROR();
        lpLogPalette = (LOGPALETTE *) GlobalLock( hDataComplex );
        lpLogPalette->palVersion = 0x300;
        lpLogPalette->palNumEntries = (WORD)dwCount;
        dwTmp = GetPaletteEntries(hPalette, 0, dwCount, lpLogPalette->palPalEntry);
#ifdef  DEBUG_CONVERT
        DPRINTF(("ConvertDataToPktPalette(), size: %d, count: %d", dwSize, dwCount));
        HEXDUMP(lpLogPalette, dwSize);
#endif
        if (dwTmp == 0) {
            dwErr = GetLastError();
            DPRINTF(("Unable to get the palette entries: %d", dwErr));
            /* GetPaletteEntries() failed: %1 */
            NDDELogError(MSG083, LogString("%d", dwErr), NULL);
            GlobalUnlock(hDataComplex);
            GlobalFree(hDataComplex);
            return(FALSE);
        }
    } else {
        /* Unable to allocate enough memory [%1] for %2 conversion: %3 */
        NDDELogError(MSG085,
            LogString("%d", dwSize),
            "CF_PALETTE", LogString("%d", GetLastError()), NULL);
        ok = FALSE;
    }

    *plpDataPortion = (LPSTR)lpLogPalette;
    *pdwSize = dwSize;
    *phDataComplex = hDataComplex;
    return( ok );
}

HANDLE
FAR PASCAL
ConvertPktToDataPalette(
    LPDDEPKT        lpDdePkt,
    LPDDEPKTDATA    lpDdePktData )
{
    HANDLE              hData;
    LOGPALETTE         *lpIndirectData;
    HANDLE              hPalette = NULL;
    LPSTR               lpData;
    DWORD               dwErr;
    BOOL                ok = TRUE;


    hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        sizeof(HANDLE) + sizeof(DDELN) );
    if( hData == NULL )  {
        MEMERROR();
        /* Unable to allocate enough memory [%1] for %2 conversion: %3 */
        NDDELogError(MSG085,
            LogString("%d", sizeof(HANDLE) + sizeof(DDELN)),
            "CF_PALETTE", LogString("%d", GetLastError()), NULL);
        return( NULL );
    }

    lpData = GlobalLock( hData );
    if( lpData == NULL )  {
        /*  Could not lock memory for bitmap handle */
        NDDELogError(MSG058, NULL);
        GlobalFree( hData );
        return( NULL );
    }

    /* copy in data portion */

    lpIndirectData = (LOGPALETTE *)GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsData );
#ifdef  DEBUG_CONVERT
    DPRINTF(("ConvertPktToDataPalette(), size: %d", lpDdePktData->dp_data_sizeData));
    HEXDUMP(lpIndirectData, lpDdePktData->dp_data_sizeData);
#endif
    hPalette = CreatePalette(lpIndirectData);
    if (hPalette == 0) {
        dwErr = GetLastError();
        DPRINTF(("Unable to create palette: %d", dwErr));
        /* CreatePalette() failed: %1 */
        NDDELogError(MSG084, LogString("%d", dwErr), NULL);
        ok = FALSE;
    }

    if( ok )  {
        *( (LPHANDLE) ((LPDATA)lpData)->info ) = hPalette;
        GlobalUnlock(hData);
        return( hData );
    } else {
        if( hPalette )  {
            GlobalFree( hPalette );
        }
        GlobalUnlock(hData);
        GlobalFree(hData);
        return( NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\ddeintf.h ===
VOID	FAR PASCAL DDEHandleInitiate( HWND hWndNetdde, HWND hWndClient, ATOM aApp, ATOM aTopic );
BOOL	FAR PASCAL DDEIntfInit( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\ddeq.h ===
#define INIT_Q_SIZE	120

typedef HANDLE	HDDEQ;

typedef struct {
    UINT_PTR	wMsg		:  4;
    UINT_PTR	fRelease	:  1;
    UINT_PTR	fAckReq		:  1;
    UINT_PTR	fResponse	:  1;
    UINT_PTR	fNoData		:  1;
    UINT_PTR	hData		: sizeof(UINT_PTR) * 8; // 32 or 64
} DDEQENT;
typedef DDEQENT FAR *LPDDEQENT;

HDDEQ	FAR PASCAL DDEQAlloc( void );
BOOL	FAR PASCAL DDEQAdd( HDDEQ, LPDDEQENT );
BOOL	FAR PASCAL DDEQRemove( HDDEQ, LPDDEQENT );
VOID	FAR PASCAL DDEQFree( HDDEQ );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\enkrypt.c ===
#define		WIN31
#include "windows.h"
#include "nddeapi.h"
#include "nddeapis.h"
#include "netcons.h"
#include "debug.h"
#include <string.h>
#include <stdlib.h>
#include <memory.h>
#include <strsafe.h>

void
PassEncrypt(
char		*cryptkey,	// ptr to session logon is taking place on
char		*pwd,		// ptr to password string
char		*buf);          // place to store encrypted text

/*
    Performs the second phase of enkryption (f2).
*/
#define MAX_K2BUF   256

static char    K2Buf[MAX_K2BUF];
static char    KeyBuf[8];
static char    PasswordBuf[MAX_PASSWORD+1];

LPBYTE WINAPI
DdeEnkrypt2(                            // pointer to enkrypted byte stream returned
        LPBYTE  lpPasswordK1,           // password output in first phase
        DWORD   cPasswordK1Size,        // size of password to be enkrypted
        LPBYTE  lpKey,                  // pointer to key
        DWORD   cKey,                   // size of key
        LPDWORD lpcbPasswordK2Size      // get size of resulting enkrypted stream
)
{
    DWORD   KeyLen = cKey;
    LPBYTE  lpKeyIt = lpKey;


    if( (cKey == 0) || (cPasswordK1Size == 0) )  {
        *lpcbPasswordK2Size = cPasswordK1Size;
        return(lpPasswordK1);
    } else {
        SecureZeroMemory(PasswordBuf, sizeof(PasswordBuf) );
        StringCbCopy( PasswordBuf, MAX_PASSWORD+1, lpPasswordK1 );
        memcpy( KeyBuf, lpKey, 8 );
        PassEncrypt( KeyBuf, PasswordBuf, K2Buf );
        *lpcbPasswordK2Size = SESSION_PWLEN;
        return( (LPBYTE)K2Buf );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\ddeq.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DDEQ.C;1  16-Dec-92,10:15:52  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */


#include    "host.h"
#include    "windows.h"
#include    "spt.h"
#include    "ddeq.h"
#include    "wwassert.h"
#include    "debug.h"
#include    "nddemsg.h"
#include    "nddelog.h"

USES_ASSERT

typedef struct {
    int         oldest;
    int         newest;
    int         nEntries;
    DDEQENT     qEnt[ 1 ];
} DDEQ;
typedef DDEQ FAR *LPDDEQ;

#ifdef COMMENT
    oldest      newest  #liveEntries    valid entries
        0       0       0
        0       1       1               1
        0       2       2               1,2
        0       3       3               1,2,3
        1       3       2               2,3
        2       3       1               3
        3       3       0
        3       0       1               0


    oldest      newest  valid entries
        0       3       1,2,3
        1       0       2,3,0
        2       1       3,0,1
        3       2       0,1,2
#endif

HDDEQ
FAR PASCAL
DDEQAlloc( void )
{
    HDDEQ       hDDEQ;
    LPDDEQ      lpDDEQ;
    DWORD       size;

    size = (DWORD) sizeof( DDEQ ) + ((INIT_Q_SIZE-1) * sizeof(DDEQENT));
    hDDEQ = GetGlobalAlloc( GMEM_MOVEABLE, size);
    if( hDDEQ )  {                              // did the alloc succeed?
        lpDDEQ = (LPDDEQ) GlobalLock( hDDEQ );
        assert( lpDDEQ );                       // did the lock succeed?
        lpDDEQ->newest          = 0;
        lpDDEQ->oldest          = 0;
        lpDDEQ->nEntries        = INIT_Q_SIZE;
        GlobalUnlock( hDDEQ );
    } else {
        MEMERROR();
    }

    return( hDDEQ );
}

BOOL
FAR PASCAL
DDEQAdd(
    HDDEQ       hDDEQ,
    LPDDEQENT   lpDDEQEnt )
{
    register LPDDEQ     lpDDEQ;
    int                 candidate, nEntriesNew;

    lpDDEQ = (LPDDEQ) GlobalLock( hDDEQ );
    assert( lpDDEQ );
    candidate = (lpDDEQ->newest + 1) % lpDDEQ->nEntries;
    if( candidate == lpDDEQ->oldest )  {
        /*
         * Dynamically grow the queue since we are full.
         */
        nEntriesNew = lpDDEQ->nEntries + INIT_Q_SIZE;
        GlobalUnlock(hDDEQ);
        if (!GlobalReAlloc(hDDEQ,
                sizeof( DDEQ ) + ((nEntriesNew - 1) * sizeof(DDEQENT)),
                GMEM_MOVEABLE)) {
            MEMERROR();
            /* Unable to add to DDE msg queue. Newest: %1, Oldest: %2, Entries: %3 */
            NDDELogError(MSG059,
                LogString("%d", lpDDEQ->newest),
                LogString("%d", lpDDEQ->oldest),
                LogString("%d", lpDDEQ->nEntries), NULL);
            return(FALSE);
        } else {
            int i;

            lpDDEQ = (LPDDEQ) GlobalLock( hDDEQ );
            assert(lpDDEQ);
            if (candidate != 0) {
                /*
                 * oldest == newest + 1 so move all the oldest ones
                 * out to the newly allocated area which moves the
                 * free space to between oldest and newest.
                 * candidate = 0 is a redundant case where no work is needed.
                 */
                for (i = lpDDEQ->nEntries - 1; i >= lpDDEQ->oldest; i--) {
                    lpDDEQ->qEnt[i + INIT_Q_SIZE] = lpDDEQ->qEnt[i];
                }
                lpDDEQ->oldest += INIT_Q_SIZE;
            }
            lpDDEQ->nEntries += INIT_Q_SIZE;
            candidate = (lpDDEQ->newest + 1) % lpDDEQ->nEntries;
        }
    }
    lpDDEQ->newest = candidate;
    lpDDEQ->qEnt[ lpDDEQ->newest ] = *lpDDEQEnt;
    GlobalUnlock( hDDEQ );

    return(TRUE);
}

BOOL
FAR PASCAL
DDEQRemove(
    HDDEQ       hDDEQ,
    LPDDEQENT   lpDDEQEnt )
{
    register LPDDEQ     lpDDEQ;
    BOOL                bRemoved;

    lpDDEQ = (LPDDEQ) GlobalLock( hDDEQ );
    assert( lpDDEQ );
    if( lpDDEQ->oldest == lpDDEQ->newest )  {
        bRemoved = FALSE;
    } else {
        lpDDEQ->oldest = (lpDDEQ->oldest + 1) % lpDDEQ->nEntries;
        *lpDDEQEnt = lpDDEQ->qEnt[ lpDDEQ->oldest ];
        bRemoved = TRUE;
    }
    GlobalUnlock( hDDEQ );

    return( bRemoved );
}

VOID
FAR PASCAL
DDEQFree( HDDEQ hDDEQ )
{
    DDEQENT     DDEQEnt;
    DWORD       size;

    while( DDEQRemove(hDDEQ, &DDEQEnt )){
        if( DDEQEnt.hData )  {
            size = (DWORD)GlobalSize((HANDLE)DDEQEnt.hData);
            if (size) {
                /*
                 * List here all the messages that are freed.
                 */
                NDDELogWarning(MSG060,
                        LogString("msg       %x\n"
                                  "fRelease  %d\n"
                                  "fAckReq   %d\n",
                                  DDEQEnt.wMsg,
                                  DDEQEnt.fRelease,
                                  DDEQEnt.fAckReq),
                        LogString("fResponse %d\n"
                                  "fNoData   %d\n"
                                  "hData     %x\n\n",
                                  DDEQEnt.fResponse,
                                  DDEQEnt.fNoData,
                                  DDEQEnt.hData), NULL);
                GlobalFree((HANDLE)DDEQEnt.hData);
            } else {
                if (!DDEQEnt.fRelease) {
                    /*  DDEQFree() releasing invalid msg handle %1 */
                    NDDELogError(MSG060,
                        LogString("0x%0X", DDEQEnt.hData), NULL);
                }
            }
        }
    }
    GlobalFree( hDDEQ );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\hndltokn.h ===
int __stdcall ForceImpersonate( HANDLE hClientAccessToken );
int __stdcall ForceClearImpersonation( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\encrypt.c ===
//***   encrypt.c - This file contains the routines for session password
//                                      encryption.
#include <windows.h>
#include <hardware.h>
#include "netcons.h"
#include <des.h>


void InitKeyLM( const unsigned char *KeyIn, unsigned char *KeyOut);

#define ENCRYPT 0
#define DECRYPT 1

#include <string.h>



//* Standard text used in the password encryption process.

static char StdText[8] = "KGS!@#$%";

void Encrypt(
                char *key,                      // Key to encrypt with
                char *text,                     // 8 bytes of text to encrypt
                char *buf,                      // buffer to receive result
                int bufLen,                     // length of result buffer
                void *scratch);                 // unused


#ifdef CONN_SEG
#pragma alloc_text(CONN_SEG, Encrypt)
#endif


//**    Encrypt - encrypt text with key
//
//      This routine takes a key and encrypts 8 bytes of data with the key
//      until the result buffer is filled.  The key is advanced ahead for each
//      iteration so it must be (bufLen/8)*7 bytes long.  Any partial buffer
//      left over is filled with zeroes.

void
Encrypt(
char *key,                                      // Key to encrypt with
char *text,                                     // 8 bytes of text to encrypt
char *buf,                                      // buffer to receive result
int bufLen,
void *scratch)
{
        do {
            DESTable KeySched;
            unsigned char keyLM[ 8 ];

            InitKeyLM(key, keyLM);
            deskey(&KeySched, keyLM);
            des(buf, text, &KeySched, ENCRYPT);

            key += CRYPT_KEY_LEN;
            buf += CRYPT_TXT_LEN;
        } while ((bufLen -= CRYPT_TXT_LEN) >= CRYPT_TXT_LEN);

        if (bufLen != 0)
                memset(buf, 0, bufLen);
        return;
}


//**    PassEncrypt - encrypt user's password
//
//      This routine takes the session encryption text and encrypts it using
//      the user's password using the following algorithm taken from encrypt.doc.
//
//  Notation for algorithm description:
//
//              All variables are named according to the convention     <letter><number>
//              where the number defines the length of the item.  And [k..j] is used
//              to specify a substring that starts at byte "k" and extends to byte "j"
//              in the specified variable.  Please note that 0 is used as the first
//              character in the string.
//
//      There is an encryption function, E, whose inputs are a seven byte
//      encryption key and and eight bytes of data and whose output is eight
//      bytes of encrypted data.
//
//      C8 is received as the data portion of the negotiate response SMB.
//
//      At the Redir the following is done to create the
//      smb_apasswd in the session setup SMB:
//
//      Let P14 be the plain text password the redirector received at logon time.
//
//      Let P24 be the session password to be sent in the session setup SMB.
//
//      First P14 is used to encrypt the standard text, S8, and obtain P21:
//              P21[0..7] = E(P14[0..6], S8)
//              P21[8..15] = E(P14[7..13], S8)
//              P21[16..20] = 0
//
//      Then P21 is used to encrypt negotiate smb_cryptkey, C8, from the server
//      to get, P24, the smb_apasswd of the session setup SMB:
//
//              P24[0..7] = E(P21[0..6], C8)
//              P24[8..15] = E(P21[7..13], C8)
//              P24[16..23] = E(P21[14..20], C8)

char    p21[21];                        // encrypted password

void
PassEncrypt(
char            *cryptkey,      // ptr to session logon is taking place on
char            *pwd,           // ptr to password string
char            *buf)           // place to store encrypted text
{
    // First encrypt the "standard text" with user's password to obtain the
    // encrypted password.

    Encrypt(pwd, StdText, p21, sizeof(p21), buf);

    // Encrypt the negotiated encryption text with the encrypted password
    // to obtain the password text to be transmitted.

    Encrypt(p21, cryptkey, buf, SESSION_PWLEN, buf+SESSION_PWLEN);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\hndltokn.c ===
#include    <hardware.h>
#include    "nt.h"
#include    "ntdef.h"
#include    "ntpsapi.h"
#define SKIP_DEBUG_WIN32
#include    "debug.h"
#include    "hndltokn.h"


int __stdcall ForceImpersonate( HANDLE hToken )
{
    NTSTATUS    Status;

    Status = NtSetInformationThread( NtCurrentThread(),
        ThreadImpersonationToken, (PVOID) &hToken, (ULONG)sizeof(hToken) );
    if ( NT_SUCCESS( Status ) )  {
        return( TRUE );
    } else {
        return( FALSE );
    }
}

int __stdcall ForceClearImpersonation( void )
{
    HANDLE      hToken = NULL;
    NTSTATUS    Status;


    Status = NtSetInformationThread( NtCurrentThread(),
        ThreadImpersonationToken, (PVOID) &hToken, (ULONG)sizeof(hToken) );
    if ( NT_SUCCESS( Status ) )  {
        return( TRUE );
    } else {
        return( FALSE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\netcons.h ===
#ifndef NETCONS_INCLUDED
#define NETCONS_INCLUDED

/*	When allocating space for such an item,
 *	use the form:
 *		char username[UNLEN+1];
 */
#define UNLEN		20	   	    /* Maximum user name length	*/


/*
 *	Constants used with encryption
 */

#define	CRYPT_KEY_LEN	7
#define	CRYPT_TXT_LEN	8
#define SESSION_PWLEN	24


#endif /* NETCONS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\netdde.h ===
#define MAX_NETINTFS 8

#define CI_COMBO_NAME			309

BOOL	FAR PASCAL InitApplication( HANDLE );
BOOL	FAR PASCAL InitInstance( HANDLE, int, LPSTR );
LPARAM	FAR PASCAL MainWndProc( HWND, unsigned, WPARAM, LPARAM );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\ddeintf.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DDEINTF.C;3  22-Mar-93,10:50:44  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

/*
        U N A D V I S E  --->

            Client                      Server
Atom:           nothing                 add

Memory:         N/A                     N/A

Queue:          Add to outgoing         Add to incoming


        E X E C U T E  --->

            Client                      Server

Atom:           N/A                     N/A

Memory:         nothing                 create

Queue:          Add to outgoing         Add to incoming


        P O K E  --->

            Client                      Server

Atom:           nothing                 adMemory:         nothing                 create

Queue:          Add to outgoing         Add to incoming


        A D V I S E  --->

            Client                      Server

Atom:           nothing                 add

Memory:         nothing                 create

Queue:          Add to outgoing         Add to incoming


        R E Q U E S T  --->

            Client                      Server

Atom:           nothing                 add

Memory:         N/A                     N/A

Queue:          Add to outgoing         Add to incoming




        A C K  --->

            Client                              Server

Atom:           delete                          add/del

Memory:         if !fRelease or NACK_MSG        if fRelease and ACK_MSG
                 Free it                            Free it

Queue:          Sub from incoming - must        Sub from outgoing - must
                    be WM_DDE_DATA                  be WM_DDE_DATA


        <--- D A T A

            Client                              Server

Atom:       - add                               if !fAckReq delete
            - if fResponse delete

Memory:     create if non-NULL                  if fAckReq - nothing
                                                else if fRelease - free

                                                if !fAckReq && !fRelease
                                                    ERROR

Queue:      if fResponse                        if fResponse
                sub from outgoing                   sub from incoming

            if fAckReq                          if fAckReq
                add to incoming                     add to outgoing


        <--- A C K

            Client                              Server

Atom:       if cmd was REQUEST, POKE,           if cmd was REQUEST, POKE,
                ADVISE or UNADVISE:                 ADVISE or UNADVISE:
                    add/del                             delete

Memory:     if cmd was                          if cmd was
                EXECUTE:  nothing                   EXECUTE:  free
                UNADVISE: N/A                       UNADVISE: N/A
                ADVISE:   if ACK_MSG - free         ADVISE:   ACK_MSG: nothing
                          if NACK_MSG - nothing               NACK_MSG: free
                REQUEST:  N/A                       REQUEST:  N/A
                POKE:     if fRelease & ACK_MSG     POKE:if fRelease & ACK_MSG
                            free                                nothing
                          else                           else
                            nothing                             free

Queue:          sub from outgoing               sub from incoming
 */



#define LINT_ARGS
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    "tmpbuf.h"
#define NOMINMAX
#include    <ctype.h>
#include    <memory.h>

#include    "host.h"

#include    <windows.h>
#include    <hardware.h>
#include    <dde.h>
#include    "dde1.h"
#include    "shellapi.h"
#include    "debug.h"
#include    "netbasic.h"
#include    "ddepkt.h"
#include    "ddepkts.h"
#include    "ddeq.h"
#include    "dder.h"
#include    "ipc.h"
#include    "spt.h"
#include    "dbgdde.h"
#include    "wwassert.h"
#include    "hmemcpy.h"
#include    "userdde.h"
#include    "wwdde.h"
#include    "internal.h"
#include    "hexdump.h"
#include    "nddeapi.h"
#include    "nddeapis.h"
#include    "winmsg.h"
#include    "seckey.h"
#include    "shrtrust.h"
#include    "uservald.h"
#include    "wininfo.h"
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "hndltokn.h"
#include    "netddesh.h"
#include    "critsec.h"
#include    "wwassert.h"
#define     STRSAFE_NO_DEPRECATE
#include    "strsafe.h"

BOOL WINAPI DdeGetQualityOfService(HWND hwndClient, HWND hwndServer, PSECURITY_QUALITY_OF_SERVICE pqos);

USES_ASSERT


/*  extracted from ndeapi.h  */

unsigned long _wwNDdeGetShareSecurityA(
    unsigned char *lpszShareName,
    unsigned long si,
    byte *psd,
    unsigned long cbsd,
    unsigned long bRemoteCall,
    unsigned long *lpcbsdRequired,
    unsigned long *lpnSizeToReturn);

unsigned long _wwNDdeShareGetInfoA(
    unsigned char *lpszShareName,
    unsigned long nLevel,
    byte *lpBuffer,
    unsigned long cBufSize,
    unsigned long *lpnTotalAvailable,
    unsigned short *lpnItems,
    unsigned long *lpnSizeToReturn,
    unsigned long *lpnSnOffset,
    unsigned long *lpnAtOffset,
    unsigned long *lpnItOffset);


BOOL MapShareInformation(WORD dd_type, LPSTR lpAppName, LPSTR lpTopicName, LPSTR lpRsltAppName,
        LPSTR lpRsltTopicName, LPSTR lpszCmdLine, PNDDESHAREINFO *lplpShareInfo, LONG *lplActualShareType);

LRESULT RequestExec(HANDLE hWndDDE, LPSTR lpszCmdLine, PNDDESHAREINFO lpShareInfo);
LRESULT RequestInit(HANDLE hWndDDE, PNDDESHAREINFO lpShareInfo);


#define WIQ_INCR        100

typedef struct {
    UINT        message;
    LPARAM      lParam;
} WIMSG;
typedef WIMSG FAR *LPWIMSG;

typedef struct {
    int         wi_nMessagesQueued;
    int         wi_nMessagesLeft;
    WIMSG       wi_msg[1];
} MSGQHDR;
typedef MSGQHDR FAR *LPMSGQHDR;

extern LPSTR    lpszServer;
extern char     szInitiatingNode[ ];
extern char     szInitiatingApp[ ];
extern WORD     wMsgInitiateAckBack;
extern BOOL     bNetddeClosed;
extern DWORD    dwReasonInitFail;
extern BOOL     bLogExecFailures;
extern BOOL     bDefaultStartApp;

#if  DBG
extern  BOOL    bDebugInfo;
extern  BOOL    bDebugDdePkts;
extern  BOOL    bDumpTokens;
#endif // DBG


/*
    External Routines
*/
#if  DBG
VOID    FAR PASCAL  DebugDderState( void );
VOID    FAR PASCAL  DebugRouterState( void );
VOID    FAR PASCAL  DebugPktzState( void );
#endif // DBG

VOID    FAR PASCAL  DderUpdatePermissions( HDDER, PNDDESHAREINFO, DWORD);
BOOL                IsShare(LPSTR);
BOOL                GetShareAppTopic( DWORD, PNDDESHAREINFO, LPSTR, LPSTR);
WORD                ExtractFlags(LPSTR lpApp);


extern LPBYTE WINAPI
DdeEnkrypt2(                            // pointer to enkrypted byte stream returned
        LPBYTE  lpPasswordK1,           // password output in first phase
        DWORD   cPasswordK1Size,        // size of password to be enkrypted
        LPBYTE  lpKey,                  // pointer to key
        DWORD   cKey,                   // size of key
        LPDWORD lpcbPasswordK2Size      // get size of resulting enkrypted stream
);


/*
    External variables used
 */
extern HANDLE   hInst;
extern WORD     wClipFmtInTouchDDE;
extern HCURSOR  hDDEInitCursor;
extern char     ourNodeName[];
extern WORD     cfPrinterPicture;
extern DWORD    dwReasonInitFail;


/*
    Local variables
 */
#if  DBG
BOOL                bDebugDDE;
VOID    FAR PASCAL  debug_srv_client(HWND hWndDDE, LPWININFO lpWinInfo);
VOID    FAR PASCAL  DebugDdeIntfState( void );
#endif // DBG

unsigned long   nW, nX, nY, nZ;

HWND            hWndDDEHead;            // Protect by CritSec
HWND            hWndDDEHeadTerminating; // Protect by CritSec
int             nInitsWaiting=0;        // Protect by CritSec
char            szNetDDEIntf[]  =       "NetDDEIntf";
UINT            uAgntExecRtn;
HHEAP           hHeap;


/*
    External Functions for conversions
*/
extern BOOL    FAR PASCAL  ConvertDataToPktMetafile( LPSTR *plpDataPortion,
                            DWORD *pdwSize, HANDLE *phDataComplex, BOOL bWin16Con );
extern HANDLE  FAR PASCAL  ConvertPktToDataMetafile( LPDDEPKT lpDdePkt,
                            LPDDEPKTDATA lpDdePktData, BOOL bWin16Con );
extern BOOL    FAR PASCAL  ConvertDataToPktBitmap( LPSTR *plpDataPortion,
                            DWORD *pdwSize, HANDLE *phDataComplex, BOOL bWin16Con );
extern HANDLE  FAR PASCAL  ConvertPktToDataBitmap( LPDDEPKT lpDdePkt,
                            LPDDEPKTDATA lpDdePktData, BOOL bWin16Con );
extern BOOL    FAR PASCAL  ConvertDataToPktEnhMetafile( LPSTR *plpDataPortion,
                            DWORD *pdwSize, HANDLE *phDataComplex);
extern HANDLE  FAR PASCAL  ConvertPktToDataEnhMetafile( LPDDEPKT lpDdePkt,
                            LPDDEPKTDATA lpDdePktData );
extern BOOL    FAR PASCAL  ConvertDataToPktPalette( LPSTR *plpDataPortion,
                            DWORD *pdwSize, HANDLE *phDataComplex);
extern HANDLE  FAR PASCAL  ConvertPktToDataPalette( LPDDEPKT lpDdePkt,
                            LPDDEPKTDATA lpDdePktData );
extern BOOL FAR PASCAL      ConvertDataToPktDIB(LPSTR   *plpDataPortion,
                            DWORD   *pdwSize, HANDLE  *phDataComplex);
extern HANDLE  FAR PASCAL   ConvertPktToDataDIB(LPDDEPKT        lpDdePkt,
                            LPDDEPKTDATA    lpDdePktData );

/*
    Local routines
 */
LPWININFO FAR PASCAL CreateWinInfo( LPSTR lpszNode, LPSTR lpszApp,
        LPSTR lpszTopic, LPSTR lpszClient, HWND hWndDDE );
LONG_PTR FAR PASCAL  DDEWddeWndProc( HWND, UINT, WPARAM, LPARAM );
BOOL    FAR PASCAL  AddAck( LPWININFO, LPARAM );
BOOL    FAR PASCAL  AddData( LPWININFO, LPARAM );
BOOL    FAR PASCAL  AddPoke( LPWININFO, LPARAM );
BOOL    FAR PASCAL  AddAdvise( LPWININFO, LPARAM );
BOOL    FAR PASCAL  AddExecute( LPWININFO, LPARAM );
BOOL    FAR PASCAL  AddRequestUnadvise( UINT, LPWININFO, LPARAM );
VOID    FAR PASCAL  DDEWndSetNext( HWND, HWND );
VOID    FAR PASCAL  DDEWndSetPrev( HWND, HWND );
VOID    FAR PASCAL  DDEWndDeleteFromList( HWND );
VOID    FAR PASCAL  DDEWndAddToList( HWND );
BOOL    FAR PASCAL  WaitInitAddMsg( LPWININFO, unsigned, LPARAM );
VOID    FAR PASCAL  SendQueuedMessages( HWND, LPWININFO );
VOID    FAR PASCAL  DeleteQueuedMessages( LPWININFO );
ATOM    FAR PASCAL  GlobalAddAtomAndCheck( LPSTR );
VOID    FAR PASCAL  DoTerminate( LPWININFO lpWinInfo );
VOID    FAR PASCAL  ServiceInitiates( void );
LPBYTE              GetInitPktPassword( LPDDEPKTINIT lpDdePktInit );
LPBYTE              GetInitPktUser( LPDDEPKTINIT lpDdePktInit );
LPBYTE              GetInitPktDomain( LPDDEPKTINIT lpDdePktInit );
PQOS                GetInitPktQos( LPDDEPKTINIT lpDdePktInit, PQOS );
WORD                GetInitPktPasswordSize( LPDDEPKTINIT lpDdePktInit );
void                GlobalFreehData(HANDLE  hData );


#ifdef  DUMP_ON
VOID
DumpToken( HANDLE hToken );
#endif // DUMP_ON


BOOL
_stdcall
NDDEValidateLogon(
    LPBYTE  lpChallenge,
    UINT    cbChallengeSize,
    LPBYTE  lpResponse,
    UINT    cbResponseSize,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    PHANDLE phLogonToken
    );


BOOL
FAR PASCAL
DDEIntfInit( void )
{
    WNDCLASS    wddeClass;

    wddeClass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wddeClass.hIcon          = (HICON)NULL;
    wddeClass.lpszMenuName   = (LPSTR)NULL;
    wddeClass.lpszClassName  = szNetDDEIntf;
    wddeClass.hbrBackground  = (HBRUSH)NULL;
    wddeClass.hInstance      = hInst;
    wddeClass.style          = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
    wddeClass.lpfnWndProc    = DDEWddeWndProc;
    wddeClass.cbClsExtra     = 0;
    wddeClass.cbWndExtra     = WNDEXTRA;

    if (!RegisterClass((LPWNDCLASS) &wddeClass)) {
        return FALSE;
    }

    return( TRUE );
}



LONG_PTR
FAR PASCAL
DDEWddeWndProc (
    HWND        hWnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam )
{
    LPWININFO   lpWinInfo;
    HDDER       hDder;
    UINT_PTR    aItem;
    LPDDEPKT    lpDdePkt;
    HANDLE      hData;
    DWORD       sizePassword;
    LPBYTE      lpPasswordK1;
    DWORD       sizePasswordK1;
    DWORD       hSecurityKey = 0;
    LPBYTE      lpszPasswordBuf;
    BOOL        bLocal;
    BOOL        ok = TRUE;
    BOOL        bHasPasswordK1 = FALSE;
    PTHREADDATA ptd;
    char        PasswordK1Buf[1000];

    assert( IsWindow(hWnd) );
    lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );

    switch (message) {

    case WM_HANDLE_DDE_INITIATE:
        /*
         * Phase 3 of WM_DDE_INITIATE processing.
         * Get QOS of our client.
         * Get User info of our client.
         * If we are having problems, ask user for password.
         *
         * Continue below at WM_HANDLE_DDE_INITIATE_PKT.
         */
        TRACEINIT((szT, "DDEWddeWndProc: WM_HANDLE_DDE_INITIATE"));
        assert( lpWinInfo );
        if (lpWinInfo->nInitNACK == 0) {
            /* get the QOS on the first initiate */
            ok = DdeGetQualityOfService( lpWinInfo->hWndDDELocal,
                lpWinInfo->hWndDDE, &lpWinInfo->qosClient);
            if (!ok) {
                /*  DdeGetQualityOfService() failed: %1 */
                NDDELogError(MSG016, LogString("%d", GetLastError()), NULL);
            } else {
                GetUserDomain(
                    lpWinInfo->hWndDDELocal, lpWinInfo->hWndDDE,
                    lpWinInfo->szUserName,             // current user name
                    sizeof(lpWinInfo->szUserName),
                    lpWinInfo->szDomainName,           // current user domain
                    sizeof(lpWinInfo->szDomainName) );
            }
        }
        if( lpWinInfo->nInitNACK > 0 )  {
            /* NACKed at least once */
            if( (lpWinInfo->nInitNACK == 1)
                    && (lpWinInfo->dwSecurityType == NT_SECURITY_TYPE) )  {
                ok = GetUserDomainPassword(
                    lpWinInfo->hWndDDELocal,
                    lpWinInfo->hWndDDE,
                    lpWinInfo->szUserName,             // current user name
                    sizeof(lpWinInfo->szUserName),
                    lpWinInfo->szDomainName,           // current user domain
                    sizeof(lpWinInfo->szDomainName),
                    PasswordK1Buf,
                    sizeof(PasswordK1Buf),
                    lpWinInfo->lpSecurityKeyRcvd,
                    lpWinInfo->sizeSecurityKeyRcvd,
                    &sizePasswordK1,
                    &bHasPasswordK1 );
                lpPasswordK1 = PasswordK1Buf;
                hSecurityKey = lpWinInfo->hSecurityKeyRcvd;
            }
            if( !bHasPasswordK1 )  {
                ptd = TlsGetValue(tlsThreadData);
                if ( !(lpWinInfo->connectFlags & DDEF_NOPASSWORDPROMPT )
                    && ptd->hwndDDEAgent )  {
                    ok = FALSE;
                }
                if (ptd->hwndDDEAgent == 0) {
                    ok = FALSE;
                    NDDELogError(MSG078, NULL);
                }
            }
            if( !ok )  {
                IpcAbortConversation( (HIPC)lpWinInfo->hWndDDE );
            } else if( bHasPasswordK1 ) {
                // go ahead and send the packet */
            } else {
                // don't send the initiate packet
                ok = FALSE;
            }
        }

        // ok == TRUE at this point means to send the initiate packet
        // ok == FALSE means don't send the initiate packet
        if( !ok )  {
            break;
        }

        // intentional fall-through

    case WM_HANDLE_DDE_INITIATE_PKT:
        /*
         * Phase 4 of WM_DDE_INITIATE processing.
         *
         * Get password from Sec Key if not already entered.
         * Create an init pkt.
         * Have Dder send it off.
         *
         * Continue at DderInitConversation().
         */
        if (lpWinInfo->wState == WST_TERMINATED) {
            ok = FALSE;
        }
        sizePassword = (DWORD)wParam;
        lpszPasswordBuf = (LPSTR) lParam;
        if( ok && !bHasPasswordK1 )  {
            lpPasswordK1 = DdeEnkrypt2( lpszPasswordBuf, sizePassword,
                lpWinInfo->lpSecurityKeyRcvd, lpWinInfo->sizeSecurityKeyRcvd,
                &sizePasswordK1 );
            hSecurityKey = lpWinInfo->hSecurityKeyRcvd;
#if DBG
            if (bDebugInfo && lpPasswordK1 && lpszPasswordBuf) {
                DPRINTF(("Password (%ld): %Fs", sizePassword, lpszPasswordBuf));
                DPRINTF(("Enkrypted 1 Password (%ld) (%x) Sent Out:", sizePasswordK1, lpPasswordK1));
                if( lpPasswordK1 ) {
                    HEXDUMP(lpPasswordK1, (int)sizePasswordK1);
                }
            }
#endif // DBG
        }
        if (ok) {
            lpDdePkt = CreateInitiatePkt(
                ((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName,
                ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName,
                ((LPSTR)lpWinInfo) + lpWinInfo->offsTopicName,
                ourNodeName,
                ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                lpWinInfo->szUserName,
                lpWinInfo->szDomainName,
                lpWinInfo->dwSecurityType,
                &lpWinInfo->qosClient,
                lpPasswordK1,
                sizePasswordK1,
                hSecurityKey);     /* first time no password */
            if( lpDdePkt == NULL )  {
                ok = FALSE;
            }
        }

        if( ok )  {
            ptd = TlsGetValue(tlsThreadData);
            lpWinInfo->bInitiating = TRUE;
            hDder = DderInitConversation( (HIPC)hWnd, 0, lpDdePkt );
            if( (lstrlen(((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName) == 0)
                || (lstrcmpi( ((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName,
                    ourNodeName ) == 0) )  {
                bLocal = TRUE;
            } else {
                bLocal = FALSE;
            }
            if( hDder == 0 )  {
                HeapFreePtr( lpDdePkt );
            }
            lpDdePkt = NULL;
            lpWinInfo->bInitiating = FALSE;
            if( hDder == 0 )  {
                if( bLocal && (dwReasonInitFail == RIACK_NEED_PASSWORD) )  {
                    ok = TRUE;
                } else {
                    ok = FALSE;
                }
            }
            /* note the hDder */
            lpWinInfo->hDder = hDder;

            /* mark that we sent the initiate packet */
            lpWinInfo->dwSent++;

            if( lpWinInfo->wState == WST_OK )  {
                /* already rcvd the initiate ack */
                SendQueuedMessages( hWnd, lpWinInfo );
            }
        }

        if( !ok )  {
            IpcAbortConversation( (HIPC)hWnd );
        }
        break;

    case WM_DDE_REQUEST:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam) )  {
            switch (lpWinInfo->wState) {
            case WST_WAIT_NET_INIT_ACK :
                WaitInitAddMsg( lpWinInfo, message, lParam );
                break;
            case WST_OK :
                assert( lpWinInfo->hDder );
                if (!AddRequestUnadvise( message, lpWinInfo, lParam )) {
                    /*
                     * failed to add message to queue - we
                     * have no choice but to shut this down since
                     * emulating a NACK or busy would require a
                     * queue entry anyway.
                     */
                    /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                    NDDELogError(MSG416, LogString("%x", message), NULL);
                    lpWinInfo->bRcvdTerminateLocally = TRUE;
                    DoTerminate( lpWinInfo );
                }
                break;
            case WST_TERMINATED :
            default:
                GlobalDeleteAtom( HIWORD(lParam) );
                break;
            }
        } else {
            GlobalDeleteAtom( HIWORD(lParam) );
        }
        break;

    case WM_DDE_ADVISE:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam) )  {
            switch (lpWinInfo->wState) {
            case WST_WAIT_NET_INIT_ACK:
                WaitInitAddMsg( lpWinInfo, message, lParam );
                break;
            case WST_OK:
                assert( lpWinInfo->hDder );
                if (!AddAdvise( lpWinInfo, lParam )) {
                    /*
                     * failed to add message to queue - we
                     * have no choice but to shut this down since
                     * emulating a NACK or busy would require a
                     * queue entry anyway.
                     */
                    /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                    NDDELogError(MSG416, LogString("%x", message), NULL);
                    lpWinInfo->bRcvdTerminateLocally = TRUE;
                    DoTerminate( lpWinInfo );
                }
                break;
            case WST_TERMINATED:
            default:
                UnpackDDElParam( WM_DDE_ADVISE, lParam,
                    (PUINT_PTR)&hData, &aItem );
                FreeDDElParam( WM_DDE_ADVISE, lParam );
                if ( hData )  {
                    GlobalFree( hData );
                }
                GlobalDeleteAtom( (ATOM)aItem );
                break;
            }
        } else {
            UnpackDDElParam( WM_DDE_ADVISE, lParam,
                (PUINT_PTR)&hData, &aItem );
            FreeDDElParam( WM_DDE_ADVISE, lParam );
            if ( hData )  {
                GlobalFree( hData );
            }
            GlobalDeleteAtom( (ATOM)aItem );
        }
        break;

    case WM_DDE_UNADVISE:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam) )  {
            switch (lpWinInfo->wState) {
            case WST_WAIT_NET_INIT_ACK:
                WaitInitAddMsg( lpWinInfo, message, lParam );
                break;
            case WST_OK:
                assert( lpWinInfo->hDder );
                if (!AddRequestUnadvise( message, lpWinInfo, lParam )) {
                    /*
                     * failed to add message to queue - we
                     * have no choice but to shut this down since
                     * emulating a NACK or busy would require a
                     * queue entry anyway.
                     */
                    /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                    NDDELogError(MSG416, LogString("%x", message), NULL);
                    lpWinInfo->bRcvdTerminateLocally = TRUE;
                    DoTerminate( lpWinInfo );
                }
                break;
            case WST_TERMINATED:
            default:
                GlobalDeleteAtom( HIWORD(lParam) );
                break;
            }
        } else {
            GlobalDeleteAtom( HIWORD(lParam) );
        }
        break;

    case WM_DDE_POKE:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam)  )  {
            switch (lpWinInfo->wState) {
            case WST_WAIT_NET_INIT_ACK:
                WaitInitAddMsg( lpWinInfo, message, lParam );
                break;
            case WST_OK:
                assert( lpWinInfo->hDder );
                if (!AddPoke( lpWinInfo, lParam )) {
                    /*
                     * failed to add message to queue - we
                     * have no choice but to shut this down since
                     * emulating a NACK or busy would require a
                     * queue entry anyway.
                     */
                    /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                    NDDELogError(MSG416, LogString("%x", message), NULL);
                    lpWinInfo->bRcvdTerminateLocally = TRUE;
                    DoTerminate( lpWinInfo );
                }
                break;
            case WST_TERMINATED:
            default:
                UnpackDDElParam( WM_DDE_POKE, lParam,
                    (PUINT_PTR)&hData, &aItem );
                FreeDDElParam( WM_DDE_POKE, lParam );
                if ( hData )  {
                    GlobalFreehData( hData );
                }
                GlobalDeleteAtom( (ATOM)aItem );
                break;
            }
        } else {
            UnpackDDElParam( WM_DDE_POKE, lParam,
                (PUINT_PTR)&hData, &aItem );
            FreeDDElParam( WM_DDE_POKE, lParam );
            if ( hData )  {
                GlobalFreehData( hData );
            }
            GlobalDeleteAtom( (ATOM)aItem );
        }
        break;

    case WM_DDE_DATA:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam)) {
            switch (lpWinInfo->wState) {
            case WST_OK:
                if( lpWinInfo->hDder )  {
                    if (!AddData( lpWinInfo, lParam )) {
                        /*
                         * failed to add message to queue - we
                         * have no choice but to shut this down since
                         * emulating a NACK or busy would require a
                         * queue entry anyway.
                         */
                        /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                        NDDELogError(MSG416, LogString("%x", message), NULL);
                        lpWinInfo->bRcvdTerminateLocally = TRUE;
                        DoTerminate( lpWinInfo );
                    }
                } else {
                    UnpackDDElParam( WM_DDE_DATA, lParam,
                        (PUINT_PTR)&hData, &aItem );
                    FreeDDElParam( WM_DDE_DATA, lParam );
                    if ( hData )  {
                        GlobalFreehData( hData );
                    }
                    GlobalDeleteAtom( (ATOM)aItem );
                }
                break;
            case WST_TERMINATED:
            default:
                UnpackDDElParam( WM_DDE_DATA, lParam,
                    (PUINT_PTR)&hData, &aItem );
                FreeDDElParam( WM_DDE_DATA, lParam );
                if ( hData )  {
                    GlobalFreehData( hData );
                }
                GlobalDeleteAtom( (ATOM)aItem );
                break;
            }
        } else {
            UnpackDDElParam( WM_DDE_DATA, lParam,
                (PUINT_PTR)&hData, &aItem );
            FreeDDElParam( WM_DDE_DATA, lParam );
            if ( hData )  {
                GlobalFreehData( hData );
            }
            GlobalDeleteAtom( (ATOM)aItem );
        }
        break;

    case WM_DDE_ACK:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow( (HWND)wParam ) )  {
            switch( lpWinInfo->wState )  {
            case WST_WAIT_NET_INIT_ACK:
                assert( FALSE );
                break;
            case WST_WAIT_INIT_ACK:
                GlobalDeleteAtom( HIWORD(lParam) );
                GlobalDeleteAtom( LOWORD(lParam) );
                lpWinInfo->hWndDDELocal = (HWND) wParam;
                lpWinInfo->wState = WST_OK;
                break;
            case WST_OK:
                EnterCrit();
                ptd = TlsGetValue(tlsThreadData);
                if( ptd->bInitiating )  {
                    LeaveCrit();
                    lpWinInfo->nExtraInitiateAcks++;
                    PostMessage( (HWND)wParam, WM_DDE_TERMINATE,
                        (UINT_PTR)hWnd, 0L );
                } else if( lpWinInfo->hDder )  {
                    LeaveCrit();
                    if (!AddAck( lpWinInfo, lParam )) {
                        /*
                         * failed to add message to queue - we
                         * have no choice but to shut this down since
                         * emulating a NACK or busy would require a
                         * queue entry anyway.
                         */
                        /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                        NDDELogError(MSG416, LogString("%x", message), NULL);
                        lpWinInfo->bRcvdTerminateLocally = TRUE;
                        DoTerminate( lpWinInfo );
                    }
                }
                break;
            case WST_TERMINATED:
                AddAck( lpWinInfo, lParam);
                break;
            default:
                /*  WM_DDE_ACK received, WinInfo in unknown state: %1 */
                NDDELogError(MSG017, LogString("%d", lpWinInfo->wState), NULL);
                FreeDDElParam( WM_DDE_ACK, lParam );
                break;
            }
        } else {
            FreeDDElParam( WM_DDE_ACK, lParam );
        }
        break;

    case WM_DDE_EXECUTE:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam) )  {
            switch (lpWinInfo->wState) {
            case WST_WAIT_NET_INIT_ACK:
                WaitInitAddMsg( lpWinInfo, message, lParam );
                break;
            case WST_OK:
                if( lpWinInfo->hDder )  {
                    if (!AddExecute( lpWinInfo, lParam )) {
                        /*
                         * failed to add message to queue - we
                         * have no choice but to shut this down since
                         * emulating a NACK or busy would require a
                         * queue entry anyway.
                         */
                        /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                        NDDELogError(MSG416, LogString("%x", message), NULL);
                        lpWinInfo->bRcvdTerminateLocally = TRUE;
                        DoTerminate( lpWinInfo );
                    }
                } else {
                    UnpackDDElParam( WM_DDE_EXECUTE, lParam,
                        &aItem, (PUINT_PTR)&hData );
                    FreeDDElParam( WM_DDE_EXECUTE, lParam );
                    if( hData )  {
                        GlobalFree( hData );
                    }
                }
                break;
            case WST_TERMINATED:
            default:
                UnpackDDElParam( WM_DDE_EXECUTE, lParam,
                    &aItem, (PUINT_PTR)&hData );
                FreeDDElParam( WM_DDE_EXECUTE, lParam );
                if( hData )  {
                    GlobalFree( hData );
                }
                break;
            }
        } else {
            UnpackDDElParam( WM_DDE_EXECUTE, lParam,
                &aItem, (PUINT_PTR)&hData );
            FreeDDElParam( WM_DDE_EXECUTE, lParam );
            if( hData )  {
                GlobalFree( hData );
            }
        }
        break;

    case WM_DDE_TERMINATE:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( (HWND)wParam == lpWinInfo->hWndDDELocal )  {
            /* note that we rcvd a terminate from the conversation locally */
            lpWinInfo->bRcvdTerminateLocally = TRUE;

            /* do rest of terminate logic */
            DoTerminate( lpWinInfo );
        } else {
            /* multiple initiate ack problem */
            lpWinInfo->nExtraInitiateAcks--;
            if( lpWinInfo->nExtraInitiateAcks < 0 )  {
                /*  Too many terminates received or wrong window    */
                NDDELogError(MSG018,
                    LogString("  hWnd: %0X, wParam: %0X, hWnd->localWnd: %0X",
                        hWnd, wParam, lpWinInfo->hWndDDELocal ),
                    LogString("  SL: %d, RL: %d, SN: %d, RN: %d",
                        lpWinInfo->bSentTerminateLocally,
                        lpWinInfo->bRcvdTerminateLocally,
                        lpWinInfo->bSentTerminateNet,
                        lpWinInfo->bRcvdTerminateNet ), NULL);
                lpWinInfo->bRcvdTerminateLocally = TRUE;
                DoTerminate( lpWinInfo );
            }
        }
        break;

    case WM_DESTROY:
        if( !bNetddeClosed && lpWinInfo )  {
            if( lpWinInfo->hDder )  {
                DderCloseConversation( lpWinInfo->hDder,
                    (HIPC) lpWinInfo->hWndDDE );
                lpWinInfo->hDder = 0;
            }
            DDEWndDeleteFromList( hWnd );

            if( lpWinInfo->qDDEIncomingCmd )  {
                DDEQFree( lpWinInfo->qDDEIncomingCmd );
                lpWinInfo->qDDEIncomingCmd = 0;
            }

            if( lpWinInfo->qDDEOutgoingCmd )  {
                DDEQFree( lpWinInfo->qDDEOutgoingCmd );
                lpWinInfo->qDDEOutgoingCmd = 0;
            }

            if( lpWinInfo->lpDdePktTerminate )  {
                HeapFreePtr( lpWinInfo->lpDdePktTerminate );
                lpWinInfo->lpDdePktTerminate = NULL;
            }

            if (lpWinInfo->lpSecurityKeyRcvd) {
                HeapFreePtr( lpWinInfo->lpSecurityKeyRcvd );
                lpWinInfo->lpSecurityKeyRcvd = NULL;
                lpWinInfo->sizeSecurityKeyRcvd = 0L;
            }

            if( lpWinInfo->fCallObjectCloseAuditAlarm )  {
                HANDLE  hAudit = (HANDLE)lpWinInfo->hAudit;

                ObjectCloseAuditAlarm( NDDE_AUDIT_SUBSYSTEM, (LPVOID)&hAudit,
                    lpWinInfo->fGenerateAuditOnClose );
                lpWinInfo->fCallObjectCloseAuditAlarm = FALSE;
            }

            HeapFreePtr( lpWinInfo );
            SetWindowLongPtr( hWnd, 0, 0L );
        }
        break;

    default:
        if (message == wMsgDoTerminate) {
            DoTerminate((LPWININFO)lParam);
            break;
        }

        return DefWindowProc (hWnd, message, wParam, lParam);
    }
    return (LONG_PTR) 0;
}



/*
 * Phase 1 of WM_DDE_INITIATE processing.
 *
 * Make sure we are not shutting down.
 * Validate atoms:
 *      Make sure it starts with a \\ or else ignore.
 *      Make sure app name is reasonable.
 * Remember client module name.
 * Create the NetDDE server window. (DDEWddeWndProc)
 * Create associated conversation info. (WST_WAIT_NET_INIT_ACK)
 * Send an ACK reply.
 * Link new window into list of NetDDE windows. (DDEWndAddToList)
 *
 * Life continues at ServiceInitiates().
 */
VOID
FAR PASCAL
DDEHandleInitiate(
    HWND    hWndNetdde,
    HWND    hWndClient,
    ATOM    aApp,
    ATOM    aTopic )
{
    char        szApp[ 256 ];
    char        szTopic[ 256 ];
    char        nodeName[ 256 ];
    char        appName[ 256 ];
    char        clientNameFull[ 128 ];
    PSTR        pszClientName;
    PSTR        pszNodeName;
    PSTR        pszNodeNameTo;
    HWND        hWndDDE;
    BOOL        ok                  = TRUE;
    LPWININFO   lpWinInfo           = NULL;
    LPDDEPKT    lpDdePkt            = NULL;
    int         n;

    CheckCritIn();

    TRACEINIT((szT, "DDEHandleInitiate: PROCESSING WM_DDE_INITIATE message."));
    if( aApp && aTopic )  {
        GlobalGetAtomName( aApp, szApp, sizeof(szApp) );
        GlobalGetAtomName( aTopic, szTopic, sizeof(szTopic) );

        if( (szApp[0] == '\\') && (szApp[1] == '\\') )  {
            /**** validate topic name ****/
            pszNodeName = &szApp[2];
            pszNodeNameTo = nodeName;
            while( *pszNodeName && (*pszNodeName != '\\') )  {
                *pszNodeNameTo++ = *pszNodeName++;
            }
            *pszNodeNameTo = '\0';

            if( (nodeName[0] == '\0') || (lstrlen(nodeName) > MAX_NODE_NAME)) {
                /*  Invalid network node name: "%1" from "%2" */
                NDDELogError(MSG019, (LPSTR)nodeName, (LPSTR)szApp, NULL );
                TRACEINIT((szT, "DDEHandleInitiate: Error1 Leaving."));
                return;
            }

            if( *pszNodeName != '\\' )  {
                /*  No application name: "%1"   */
                NDDELogError(MSG020, (LPSTR)szApp, NULL );
                TRACEINIT((szT, "DDEHandleInitiate: Error2 Leaving."));
                return;
            }
            pszNodeName++;      /* past the backslash */
            pszNodeNameTo = appName;
            while( *pszNodeName )  {
                *pszNodeNameTo++ = *pszNodeName++;
            }
            *pszNodeNameTo = '\0';

            if( appName[0] == '\0' )  {
                /*  Invalid application name: "%1" from "%2"    */
                NDDELogError(MSG021, (LPSTR)appName, (LPSTR)szApp, NULL );
                TRACEINIT((szT, "DDEHandleInitiate: Error3 Leaving."));
                return;
            }

            n = GetModuleFileName(
                (HANDLE)GetClassLongPtr( hWndClient, GCLP_HMODULE ),
                clientNameFull, sizeof(clientNameFull) );

            // GetModuleFileName may not NULL-terminate the buffer
            if (n == sizeof(clientNameFull))
                clientNameFull[n-1] = '\0';

            pszClientName = &clientNameFull[ n-1 ];

            while ( n--
                && (*pszClientName != '\\')
                && (*pszClientName != ':')
                && (*pszClientName != '/'))  {
                if (*pszClientName == '.') {    /* null the . */
                    *pszClientName = '\0';
                }
                pszClientName--;
            }
            pszClientName++;


            LeaveCrit();
            hWndDDE = CreateWindow(
                (LPSTR) szNetDDEIntf,
                (LPSTR) GetAppName(),
                WS_CHILD,
                0,
                0,
                0,
                0,
                (HWND) hWndNetdde,
                (HMENU) NULL,
                (HANDLE) hInst,
                (LPSTR) NULL);

            if( hWndDDE )  {
                lpWinInfo = CreateWinInfo( nodeName, appName,
                    szTopic, pszClientName, hWndDDE );
                if( lpWinInfo )  {
                    lpWinInfo->bClientSideOfNet = TRUE;
                    lpWinInfo->hWndDDELocal = hWndClient;
                    lpWinInfo->hTask = GetWindowTask( hWndClient );
                    lpWinInfo->wState = WST_WAIT_NET_INIT_ACK;
                    InterlockedIncrement(&lpWinInfo->dwWaitingServiceInitiate);
                    lpWinInfo->connectFlags = ExtractFlags(appName);
                    EnterCrit();
                    nInitsWaiting++;
                    LeaveCrit();
                } else {
                    ok = FALSE;
                }
            } else {
                /*  Could not create server agent window for "%1" client */
                NDDELogError(MSG022, pszClientName, NULL);
                ok = FALSE;
                TRACEINIT((szT, "DDEHandleInitiate: Error4 Leaving."));
            }

            if( ok )  {
                aApp = GlobalAddAtom( szApp );
                aTopic = GlobalAddAtom( szTopic );
#if DBG
                if( bDebugDDE )  {
                    DebugDDEMessage( "sent", (HWND)-1, WM_DDE_ACK,
                        (WPARAM) hWndDDE,
                        MAKELONG(aApp,aTopic) );
                }
#endif // DBG
                SendMessage( hWndClient, WM_DDE_ACK,
                    (UINT_PTR)hWndDDE, MAKELONG(aApp, aTopic) );

                EnterCrit();
                DDEWndAddToList( hWndDDE );
                LeaveCrit();
            }
            if( !ok )  {
                if( hWndDDE )  {
                    DestroyWindow( hWndDDE );
                    hWndDDE = 0;
                }
                if( lpDdePkt )  {
                    HeapFreePtr( lpDdePkt );
                    lpDdePkt = NULL;
                }
            }
            EnterCrit();
        }
    }
    TRACEINIT((szT, "DDEHandleInitiate: Leaving."));
}



BOOL
FAR PASCAL
AddAck(
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    HANDLE      hData;
    BOOL        bRemoved;
    DDEQENT     DDEQEnt;
    UINT        wMsg;
    BOOL        bUseAtom;
    BOOL        bDeleteAtom;
    UINT_PTR    wStatus;
    UINT_PTR    aItem;
    BOOL        bLocalWndValid;
    char        szItemName[ 256 ];
    BOOL        bDoneProcessing     = FALSE;
    BOOL        bRtn = TRUE;
    LPDDEPKT    lpDdePkt;

    bLocalWndValid = IsWindow( lpWinInfo->hWndDDELocal );
    if( lpWinInfo->bClientSideOfNet )  {
        /* must be ack to a data command */
        UnpackDDElParam( WM_DDE_ACK, lParam, &wStatus, &aItem );
        FreeDDElParam( WM_DDE_ACK, lParam );
        wMsg = WM_DDE_ACK_DATA;
        bRemoved = DDEQRemove( lpWinInfo->qDDEIncomingCmd, &DDEQEnt );
        if( !bRemoved )  {
            /*  Extraneous WM_DDE_ACK from DDE Client "%1"  */
            NDDELogWarning(MSG023,
                (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName), NULL);
            bUseAtom = FALSE;
            bDeleteAtom = FALSE;
        } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_DATA )  {
            /*  WM_DDE_ACK from DDE Client "%1" not matching DATA: %2   */
            NDDELogWarning(MSG024,
                (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST), NULL );
            bUseAtom = FALSE;
            bDeleteAtom = FALSE;
        } else {
            /* ATOM:  delete the atom */
            bUseAtom = TRUE;
            bDeleteAtom = TRUE;
            wMsg = WM_DDE_ACK_DATA;

            /* MEMORY: if !fRelease or data was NACKed, free it */
            if( !DDEQEnt.fRelease || ((wStatus & ACK_MSG) != ACK_MSG) )  {
                if( bLocalWndValid && DDEQEnt.hData )  {
                    GlobalFreehData( (HANDLE)DDEQEnt.hData );
                }
            }
        }
    } else {
        assert( lpWinInfo->bServerSideOfNet );
        /* can be ACK to:
            WM_DDE_REQUEST
            WM_DDE_POKE
            WM_DDE_ADVISE
            WM_DDE_UNADVISE
            WM_DDE_EXECUTE
         */
        bRemoved = DDEQRemove( lpWinInfo->qDDEIncomingCmd, &DDEQEnt );
        if( !bRemoved )  {
            /*  Extraneous %1 from DDE Client "%2"  */
            NDDELogWarning(MSG023, "WM_DDE_ACK",
                (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName), NULL);
            bUseAtom = FALSE;
            bDeleteAtom = FALSE;
        } else
            switch( DDEQEnt.wMsg + WM_DDE_FIRST )  {
            case WM_DDE_REQUEST:                /* ATOM:  delete the atom */
                UnpackDDElParam( WM_DDE_ACK, lParam, &wStatus, &aItem );
                FreeDDElParam( WM_DDE_ACK, lParam );
                bUseAtom = TRUE;
                bDeleteAtom = TRUE;
                wMsg = WM_DDE_ACK_REQUEST;
                break;

            case WM_DDE_UNADVISE:                /* ATOM:  delete the atom */
                UnpackDDElParam( WM_DDE_ACK, lParam, &wStatus, &aItem );
                FreeDDElParam( WM_DDE_ACK, lParam );
                bUseAtom = TRUE;
                bDeleteAtom = TRUE;
                wMsg = WM_DDE_ACK_UNADVISE;
                break;

            case WM_DDE_POKE:                   /* ATOM:  delete the atom */
                UnpackDDElParam( WM_DDE_ACK, lParam, &wStatus, &aItem );
                FreeDDElParam( WM_DDE_ACK, lParam );
                bUseAtom = TRUE;
                bDeleteAtom = TRUE;
                wMsg = WM_DDE_ACK_POKE;

                /* MEMORY: free if ACK or !fRelease */
                if( !DDEQEnt.fRelease || (wStatus != ACK_MSG) )  {
                    if( DDEQEnt.hData )  {
                        if( bLocalWndValid )  {
                            GlobalFreehData( (HANDLE)DDEQEnt.hData );
                        }
                    }
                }
                break;

            case WM_DDE_ADVISE:                /* ATOM:  delete the atom */
                UnpackDDElParam( WM_DDE_ACK, lParam, &wStatus, &aItem );
                FreeDDElParam( WM_DDE_ACK, lParam );
                bUseAtom = TRUE;
                bDeleteAtom = TRUE;
                wMsg = WM_DDE_ACK_ADVISE;

                /* MEMORY: free if NACK */
                if( wStatus == NACK_MSG )  {
                    if( DDEQEnt.hData )  {
                        if( bLocalWndValid )  {
                            GlobalFree( (HANDLE)DDEQEnt.hData );
                        }
                    }
                }
                break;

            case WM_DDE_EXECUTE:                /* ATOM:  N/A */
                bUseAtom = FALSE;
                bDeleteAtom = FALSE;
                wMsg = WM_DDE_ACK_EXECUTE;

                /* MEMORY: free */
                if( DDEQEnt.hData )  {
                    if( bLocalWndValid )  {
                        GlobalFree( (HANDLE)DDEQEnt.hData );
                    }
                }
                if( lpWinInfo->wState != WST_TERMINATED ) {
                    UnpackDDElParam( WM_DDE_ACK, lParam,
                        &wStatus, (PUINT_PTR)&hData );
                    FreeDDElParam( WM_DDE_ADVISE, lParam );
                    lpDdePkt = CreateAckExecutePkt(
                        wStatus & ACK_MSG ? 1 : 0,
                        wStatus & BUSY_MSG ? 1 : 0,
                        (BYTE) (wStatus & 0xFF) );
                    if( lpDdePkt )  {
                        lpWinInfo->dwSent++;
                        DderPacketFromIPC( lpWinInfo->hDder,
                            (HIPC) lpWinInfo->hWndDDE, lpDdePkt );
                    } else {
                        bRtn = FALSE;
                    }
                }
                bDoneProcessing = TRUE;
                break;

            default:
                /*  INTERNAL ERROR -- Unknown DDE Command AddAck Server: %1 */
                NDDELogError(MSG042,
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST), NULL);
                bRtn = FALSE;
        }
    }

    if( !bDoneProcessing )  {
        if( bUseAtom )  {
            GlobalGetAtomName( (ATOM)aItem, szItemName,
                sizeof(szItemName) );
        } else {
            szItemName[0] = '\0';
        }
        if( bDeleteAtom )  {
            GlobalDeleteAtom( (ATOM)aItem );
        }
        if( lpWinInfo->wState != WST_TERMINATED ) {
            lpDdePkt = CreateGenericAckPkt( (WORD)wMsg, szItemName,
                ((BOOL)(wStatus & ACK_MSG ? 1 : 0)),
                ((BOOL)(wStatus & BUSY_MSG ? 1 : 0)),
                (BYTE) (wStatus & 0xFF) );
            if( lpDdePkt )  {
                lpWinInfo->dwSent++;
                DderPacketFromIPC( lpWinInfo->hDder,
                    (HIPC) lpWinInfo->hWndDDE, lpDdePkt );
            } else {
                bRtn = FALSE;
            }
        }
    }
    return( bRtn );
}



BOOL
FAR PASCAL
AddRequestUnadvise(
    UINT        wMsg,
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    LPDDEPKT    lpDdePkt;
    char        szItemName[ 256 ];
    DDEQENT     DDEQEnt;
    UINT_PTR    cfFormat;
    UINT_PTR    aItem;

    UnpackDDElParam( WM_DDE_REQUEST, lParam, &cfFormat, &aItem );
    FreeDDElParam( WM_DDE_REQUEST, lParam );
    GlobalGetAtomName( (ATOM)aItem, szItemName, sizeof(szItemName) );

    assert( (wMsg == WM_DDE_REQUEST) || (wMsg == WM_DDE_UNADVISE) );
    DDEQEnt.wMsg        = wMsg - WM_DDE_FIRST;
    DDEQEnt.fRelease    = FALSE;
    DDEQEnt.fAckReq     = FALSE;
    DDEQEnt.fResponse   = FALSE;
    DDEQEnt.fNoData     = FALSE;
    DDEQEnt.hData       = 0;

    if( !DDEQAdd( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt ) )  {
        return( FALSE );
    }


    if( wMsg == WM_DDE_REQUEST )  {
        lpDdePkt = CreateRequestPkt( szItemName, (WORD)cfFormat );
    } else {
        lpDdePkt = CreateUnadvisePkt( szItemName, (WORD)cfFormat );
    }
    if( lpDdePkt )  {
        lpWinInfo->dwSent++;
        DderPacketFromIPC( lpWinInfo->hDder, (HIPC) lpWinInfo->hWndDDE,
            lpDdePkt );
    } else {
        return( FALSE );
    }

    return( TRUE );
}



BOOL
FAR PASCAL
AddData(
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    char        szItemName[ 256 ];
    HANDLE      hData;
    UINT_PTR    aItem;
    HANDLE      hDataComplex        = 0;
    DWORD       dwSize;
    LPSTR       lpMem;
    LPSTR       lpDataPortion;
    WORD        cfFormat;
    DDEQENT     DDEQEnt;
    DDEQENT     DDEQEntReq;
    BOOL        bRemoved;
    LPDDEPKT    lpDdePkt;
    BOOL        ok                  = TRUE;

    UnpackDDElParam( WM_DDE_DATA, lParam, (PUINT_PTR)&hData, &aItem );
    FreeDDElParam( WM_DDE_DATA, lParam );
    GlobalGetAtomName( (ATOM)aItem, szItemName, sizeof(szItemName) );

    /* basic DDEQEnt initialization */
    DDEQEnt.wMsg        = WM_DDE_DATA - WM_DDE_FIRST;
    DDEQEnt.fRelease    = FALSE;
    DDEQEnt.fAckReq     = FALSE;
    DDEQEnt.fResponse   = FALSE;
    DDEQEnt.fNoData     = FALSE;
    DDEQEnt.hData       = (UINT_PTR)hData;

    if( hData )  {
        dwSize = (DWORD)GlobalSize(hData);
        lpMem = GlobalLock( hData );
        if( lpMem )  {
            /* initialize flags in DDEQEnt */
            assert( lpWinInfo->bServerSideOfNet );
            DDEQEnt.fRelease    = ((LPDDELN)lpMem)->fRelease;
            DDEQEnt.fAckReq     = ((LPDDELN)lpMem)->fAckReq;
            DDEQEnt.fResponse   = ((LPDDELN)lpMem)->fResponse;
            if( DDEQEnt.fAckReq )  {
                if( !DDEQAdd( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt ) )  {
                    GlobalUnlock( hData );
                    return( FALSE );
                }
            }
            if( DDEQEnt.fResponse )  {
                bRemoved = DDEQRemove( lpWinInfo->qDDEIncomingCmd,
                    &DDEQEntReq );
                if( !bRemoved )  {
                    /*  Extraneous WM_DDE_DATA response from DDE Server "%1"  */
                    NDDELogWarning(MSG025,
                        (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL);
                } else if( (DDEQEntReq.wMsg + WM_DDE_FIRST) != WM_DDE_REQUEST ) {
                    /*  %1 from DDE Server "%2" not matching %3: %4   */
                    NDDELogWarning(MSG026, "WM_DDE_DATA",
                        (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName),
                        "REQUEST",
                        LogString("0x%0X", DDEQEntReq.wMsg + WM_DDE_FIRST), NULL );
                }
            }
            cfFormat = (WORD)((LPDDELN)lpMem)->cfFormat;
            lpDataPortion = (LPSTR)lpMem + sizeof(DDELN);
            dwSize -= sizeof(DDELN);
        } else {
            dwSize = 0L;
            lpMem = NULL;
            lpDataPortion = NULL;
            cfFormat = 0;
        }
    } else {
        dwSize = 0L;
        lpMem = NULL;
        lpDataPortion = NULL;
        cfFormat = 0;
    }

    if( lpDataPortion )  {
        switch (cfFormat) {
            case CF_METAFILEPICT:
                if( !ConvertDataToPktMetafile( &lpDataPortion, &dwSize,
                    &hDataComplex, lpWinInfo->bWin16Connection ) ) {
                    ok = FALSE;
                }
                break;
            case CF_BITMAP:
                if( !ConvertDataToPktBitmap( &lpDataPortion, &dwSize,
                    &hDataComplex, lpWinInfo->bWin16Connection  ) ) {
                    ok = FALSE;
                }
                break;
            case CF_ENHMETAFILE:
                if( !ConvertDataToPktEnhMetafile( &lpDataPortion, &dwSize,
                    &hDataComplex ) ) {
                    ok = FALSE;
                }
                break;
            case CF_PALETTE:
                if( !ConvertDataToPktPalette( &lpDataPortion, &dwSize,
                    &hDataComplex ) ) {
                    ok = FALSE;
                }
                break;
            case CF_DIB:
                if( !ConvertDataToPktDIB( &lpDataPortion, &dwSize,
                    &hDataComplex ) ) {
                    ok = FALSE;
                }
                break;
            default:
                if (cfFormat == cfPrinterPicture) {
                    if( !ConvertDataToPktMetafile( &lpDataPortion, &dwSize,
                        &hDataComplex, lpWinInfo->bWin16Connection  ) ) {
                    ok = FALSE;
                    }
                }
                break;
        }
    }

    if (!ok) {
        if (hData)
            GlobalUnlock( hData );
        return FALSE;
    }

    lpDdePkt = CreateDataPkt( szItemName,
                              cfFormat,
                              (BOOL)DDEQEnt.fResponse,
                              (BOOL)DDEQEnt.fAckReq,
                              (BOOL)DDEQEnt.fRelease,
                              lpDataPortion,
                              dwSize );

    if( hData )  {
        GlobalUnlock( hData );
        if( !DDEQEnt.fAckReq )  {
            GlobalDeleteAtom( (ATOM)aItem );
            if( DDEQEnt.fRelease && (DDEQEnt.hData != 0) )  {
                assert( hData == (HANDLE)DDEQEnt.hData );
                GlobalFreehData( (HANDLE)DDEQEnt.hData );
            }
        }
    }
    if( hDataComplex )  {
        GlobalUnlock( hDataComplex );
        GlobalFree( hDataComplex );
    }

    if( lpDdePkt )  {
        lpWinInfo->dwSent++;
        DderPacketFromIPC( lpWinInfo->hDder,
            (HIPC) lpWinInfo->hWndDDE, lpDdePkt );
    } else {
        return( FALSE );
    }
    return( TRUE );
}



BOOL
FAR PASCAL
AddPoke(
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    char        szItemName[ 256 ];
    HANDLE      hData;
    UINT_PTR    aItem;
    DWORD       dwSize;
    HANDLE      hDataComplex        = 0;
    LPSTR       lpMem               = (LPSTR) NULL;
    LPSTR       lpDataPortion;
    WORD        cfFormat;
    DDEQENT     DDEQEnt;
    LPDDEPKT    lpDdePkt            = (LPDDEPKT) NULL;
    BOOL        ok                  = TRUE;

    UnpackDDElParam( WM_DDE_POKE, lParam, (PUINT_PTR)&hData, &aItem );
    FreeDDElParam( WM_DDE_POKE, lParam );
    GlobalGetAtomName( (ATOM)aItem, szItemName, sizeof(szItemName) );

    /* basic DDEQEnt initialization */
    DDEQEnt.wMsg        = WM_DDE_POKE - WM_DDE_FIRST;
    DDEQEnt.fRelease    = FALSE;
    DDEQEnt.fAckReq     = FALSE;
    DDEQEnt.fResponse   = FALSE;
    DDEQEnt.fNoData     = FALSE;
    DDEQEnt.hData       = (UINT_PTR)hData;

    if( hData )  {
        dwSize = (DWORD)GlobalSize(hData);
        lpMem = GlobalLock( hData );

        if( lpMem )  {
            /* initialize flags in DDEQEnt */
            assert( lpWinInfo->bClientSideOfNet );
            DDEQEnt.fRelease = ((LPDDELN)lpMem)->fRelease;
            if( !DDEQAdd( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt ) )  {
                GlobalUnlock( hData );
                return( FALSE );
            }
            cfFormat = (WORD) ((LPDDELN)lpMem)->cfFormat;
            lpDataPortion = (LPSTR)lpMem + sizeof(DDELN);
            dwSize -= sizeof(DDELN);
        } else {
            dwSize = 0L;
            lpMem = NULL;
            lpDataPortion = NULL;
            cfFormat = 0;
        }
    } else {
        dwSize = 0L;
        lpMem = NULL;
        lpDataPortion = NULL;
        cfFormat = 0;
    }

    switch (cfFormat) {
        case CF_METAFILEPICT:
            if( !ConvertDataToPktMetafile( &lpDataPortion, &dwSize,
                &hDataComplex, lpWinInfo->bWin16Connection  ) ) {
                ok = FALSE;
            }
            break;
        case CF_BITMAP:
            if( !ConvertDataToPktBitmap( &lpDataPortion, &dwSize,
                &hDataComplex, lpWinInfo->bWin16Connection  ) ) {
                ok = FALSE;
            }
            break;
        case CF_ENHMETAFILE:
            if( !ConvertDataToPktEnhMetafile( &lpDataPortion, &dwSize,
                &hDataComplex ) ) {
                ok = FALSE;
            }
            break;
        case CF_PALETTE:
            if( !ConvertDataToPktPalette( &lpDataPortion, &dwSize,
                &hDataComplex ) ) {
                ok = FALSE;
            }
            break;
        case CF_DIB:
            if( !ConvertDataToPktDIB( &lpDataPortion, &dwSize,
                &hDataComplex ) ) {
                ok = FALSE;
            }
            break;
        default:
            if (cfFormat == cfPrinterPicture) {
                if( !ConvertDataToPktMetafile( &lpDataPortion, &dwSize,
                    &hDataComplex, lpWinInfo->bWin16Connection  ) ) {
                ok = FALSE;
                }
            }
            break;
    }

    if (!ok) {
        if (hData)
            GlobalUnlock( hData );
        return FALSE;
    }

    lpDdePkt = CreatePokePkt( szItemName, cfFormat, (BOOL)DDEQEnt.fRelease,
                    lpDataPortion, dwSize );

    if( hDataComplex )  {
        GlobalUnlock( hDataComplex );
        GlobalFree( hDataComplex );
    }
    if( hData && lpMem )  {
        GlobalUnlock( hData );
    }

    if( lpDdePkt )  {
        lpWinInfo->dwSent++;
        DderPacketFromIPC( lpWinInfo->hDder, (HIPC) lpWinInfo->hWndDDE,
            lpDdePkt );
    } else {
        return( FALSE );
    }
    return( TRUE );
}



BOOL
FAR PASCAL
AddAdvise(
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    char        szItemName[ 256 ];
    HANDLE      hData;
    UINT_PTR    aItem;
    LPDDELN     lpOptions;
    WORD        cfFormat;
    DDEQENT     DDEQEnt;
    LPDDEPKT    lpDdePkt;

    UnpackDDElParam( WM_DDE_ADVISE, lParam, (PUINT_PTR)&hData, &aItem );
    FreeDDElParam( WM_DDE_ADVISE, lParam );
    GlobalGetAtomName( (ATOM)aItem, szItemName, sizeof(szItemName) );

    /* basic DDEQEnt initialization */
    DDEQEnt.wMsg        = WM_DDE_ADVISE - WM_DDE_FIRST;
    DDEQEnt.fRelease    = FALSE;
    DDEQEnt.fAckReq     = FALSE;
    DDEQEnt.fResponse   = FALSE;
    DDEQEnt.fNoData     = FALSE;
    DDEQEnt.hData       = (ULONG_PTR)hData;

    if( hData == 0 )  {
        /*  NULL hData from WM_DDE_ADVISE Client: "%1"  */
        NDDELogWarning(MSG027,
            (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName), NULL );
        return( FALSE );
    }
    lpOptions = (LPDDELN) GlobalLock( hData );
    if( lpOptions )  {
        /* initialize flags in DDEQEnt */
        assert( lpWinInfo->bClientSideOfNet );
        DDEQEnt.fAckReq = lpOptions->fAckReq;
        DDEQEnt.fNoData = lpOptions->fNoData;
        if( !DDEQAdd( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt ) )  {
            GlobalUnlock( hData );
            return( FALSE );
        }
        cfFormat = (WORD) lpOptions->cfFormat;
        GlobalUnlock( hData );
    } else {
        cfFormat = 0;
    }

    lpDdePkt = CreateAdvisePkt( szItemName, cfFormat,
        (BOOL)DDEQEnt.fAckReq, (BOOL)DDEQEnt.fNoData );
    if( lpDdePkt )  {
        lpWinInfo->dwSent++;
        DderPacketFromIPC( lpWinInfo->hDder, (HIPC) lpWinInfo->hWndDDE,
            lpDdePkt );
    } else {
        return( FALSE );
    }

    return( TRUE );
}



BOOL
FAR PASCAL
AddExecute(
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    LPSTR       lpString;
    LPDDEPKT    lpDdePkt;
    UINT_PTR    uJunk;
    HANDLE      hData;
    DDEQENT     DDEQEnt;

    UnpackDDElParam( WM_DDE_EXECUTE, lParam, &uJunk, (PUINT_PTR)&hData );
    FreeDDElParam( WM_DDE_EXECUTE, lParam );

    /* basic DDEQEnt initialization */
    DDEQEnt.wMsg        = WM_DDE_EXECUTE - WM_DDE_FIRST;
    DDEQEnt.fRelease    = FALSE;
    DDEQEnt.fAckReq     = FALSE;
    DDEQEnt.fResponse   = FALSE;
    DDEQEnt.fNoData     = FALSE;
    DDEQEnt.hData       = (UINT_PTR)hData;

    if( !DDEQAdd( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt ) )  {
        return( FALSE );
    }

    lpString = GlobalLock( hData );
    if( lpString )  {
        lpDdePkt = CreateExecutePkt( lpString );
        GlobalUnlock( hData );
    } else {
        lpDdePkt = CreateExecutePkt( "" );
    }
    if( lpDdePkt )  {
        lpWinInfo->dwSent++;
        DderPacketFromIPC( lpWinInfo->hDder, (HIPC) lpWinInfo->hWndDDE,
            lpDdePkt );
    } else {
        return( FALSE );
    }

    return( TRUE );
}



VOID
FAR PASCAL
DDEWndAddToList( HWND hWnd )
{
    LPWININFO   lpWinInfo;

    assert( hWnd );
    assert( IsWindow(hWnd) );
    EnterCrit();
    lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );
    assert( lpWinInfo );
    lpWinInfo->hWndPrev = 0;
    lpWinInfo->hWndNext = hWndDDEHead;
    lpWinInfo->bOnWindowList = TRUE;
    if( hWndDDEHead )  {
        DDEWndSetPrev( hWndDDEHead, hWnd );
    }
    hWndDDEHead = hWnd;
    LeaveCrit();
}



VOID
FAR PASCAL
DDEWndDeleteFromList( HWND hWnd )
{
    HWND        hWndPrev;
    HWND        hWndNext;
    LPWININFO   lpWinInfo;

    assert( hWnd );
    assert( IsWindow(hWnd) );
    EnterCrit();
    lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );
    assert( lpWinInfo );
    if( lpWinInfo->bOnWindowList )  {
        hWndPrev = lpWinInfo->hWndPrev;
        hWndNext = lpWinInfo->hWndNext;

        if( hWndPrev )  {
            DDEWndSetNext( hWndPrev, hWndNext );
        } else {
            assert( hWnd == hWndDDEHead );
            hWndDDEHead = hWndNext;
        }

        DDEWndSetPrev( hWndNext, hWndPrev );
        lpWinInfo->bOnWindowList = FALSE;
    } else if( lpWinInfo->bOnTermWindowList )  {
        hWndPrev = lpWinInfo->hWndPrev;
        hWndNext = lpWinInfo->hWndNext;

        if( hWndPrev )  {
            DDEWndSetNext( hWndPrev, hWndNext );
        } else {
            assert( hWnd == hWndDDEHeadTerminating );
            hWndDDEHeadTerminating = hWndNext;
        }

        DDEWndSetPrev( hWndNext, hWndPrev );
        lpWinInfo->bOnTermWindowList = FALSE;
    }
    LeaveCrit();
}



VOID
FAR PASCAL
DDEWndSetNext(
    HWND        hWnd,
    HWND        hWndNext )
{
    LPWININFO   lpWinInfo;

    if( hWnd )  {
        EnterCrit();
        assert( IsWindow(hWnd) );
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );
        assert( lpWinInfo );
        lpWinInfo->hWndNext = hWndNext;
        LeaveCrit();
    }
}



VOID
FAR PASCAL
DDEWndSetPrev(
    HWND        hWnd,
    HWND        hWndPrev )
{
    LPWININFO   lpWinInfo;

    if( hWnd )  {
        assert( IsWindow(hWnd) );
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );
        assert( lpWinInfo );
        lpWinInfo->hWndPrev = hWndPrev;
    }
}



/*
 * Phase 2 of WM_DDE_INITIATE processing.
 *
 * For each window on the hWndDDEHead list that has not yet been processed...
 *    Post a WM_HANDLE_DDE_INITIATE to the NetDDE server window.
 *
 * This routine will fail to post the message if one is already in the target
 * window's queue.
 *
 * Life continues at DDEWddeWndProc(WM_HANDLE_DDE_INITIATE).
 */
VOID
FAR PASCAL
ServiceInitiates( void )
{
    MSG         msg;
    HWND        hWndDDE;
    HWND        hWndNext;
    LPWININFO   lpWinInfo;

    EnterCrit();
    if( nInitsWaiting )  {
        hWndDDE = hWndDDEHead;
        while( hWndDDE )  {
            assert( IsWindow(hWndDDE) );
            lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );
            assert( lpWinInfo );
            hWndNext = lpWinInfo->hWndNext;

            if( (lpWinInfo->wState == WST_WAIT_NET_INIT_ACK)
                    && (lpWinInfo->hDder == 0)
                    && lpWinInfo->dwWaitingServiceInitiate )  {
                InterlockedDecrement(&lpWinInfo->dwWaitingServiceInitiate);
                nInitsWaiting--;

                // WINSE #4298
                // we can't call PeekMessage here, because we can cause a deadlock.
                // if another thread has called SendMessage(ptd->hwndDDE, wMsgIpcInit...)
                // this will cause WM_DDE_INITIATE to be called which will
                // require access to the critical section we hold.
                //
                if( lpWinInfo->dwWaitingServiceInitiate ) {
                    DIPRINTF(("ServiceInitiates: multiple WM_HANDLE_DDE_INITIATEs in queue."));
                    // force back to zero to best mimic the old behavior of using TRUE/FALSE
                    InterlockedExchange(&lpWinInfo->dwWaitingServiceInitiate, 0);

                } else {
                    if (!PostMessage( hWndDDE, WM_HANDLE_DDE_INITIATE, 0, 0L) ) {
                        /* abort the conversation */
                        IpcAbortConversation( (HIPC)hWndDDE );
                    }
                }
            }

            /* move on to next wdw */
            hWndDDE = hWndNext;
        }
    }
    LeaveCrit();
}



/*
 * This function is used to queue up incomming DDE messages that arrive from a client before
 * actual connection with the remote machine has been established.
 *
 * SendQueuedMessages() empties this queue when the connection is established - or not.
 */
BOOL
FAR PASCAL
WaitInitAddMsg(
    LPWININFO   lpWinInfo,
    unsigned    message,
    LPARAM      lParam )
{
    LPMSGQHDR   lpMsgQHdr;
    LPWIMSG     lpWIMsg;
    BOOL        bNeedNew;
    DWORD       wNewCount;
    HANDLE      hMemNew;
    BOOL        ok;

    ok = TRUE;

    /*
     * See if we need to allocate and initialize the queue.
     */
    if( lpWinInfo->hMemWaitInitQueue == 0 )  {
        lpWinInfo->hMemWaitInitQueue = GetGlobalAlloc(
                GMEM_MOVEABLE | GMEM_ZEROINIT,
                (DWORD)sizeof(MSGQHDR) + (WIQ_INCR * sizeof(WIMSG)) );
        if( lpWinInfo->hMemWaitInitQueue == 0 )  {
            MEMERROR();
            return(FALSE);
        }

        /*
         * Initialize with 0 messages
         */
        lpMsgQHdr = (LPMSGQHDR)GlobalLock( lpWinInfo->hMemWaitInitQueue );
        lpMsgQHdr->wi_nMessagesLeft = WIQ_INCR;
        lpMsgQHdr->wi_nMessagesQueued = 0;
        GlobalUnlock( lpWinInfo->hMemWaitInitQueue );
    }

    lpMsgQHdr = (LPMSGQHDR)GlobalLock( lpWinInfo->hMemWaitInitQueue );

    /*
     * point to next available slot
     */
    lpWIMsg = &lpMsgQHdr->wi_msg[ lpMsgQHdr->wi_nMessagesQueued ];
    lpMsgQHdr->wi_nMessagesQueued++;
    lpMsgQHdr->wi_nMessagesLeft--;

    if( lpMsgQHdr->wi_nMessagesLeft == 0 )  {
        /*
         * if full, remember to dynamically grow it before we leave.
         */
        bNeedNew = TRUE;
        wNewCount = lpMsgQHdr->wi_nMessagesQueued + WIQ_INCR;
    } else {
        bNeedNew = FALSE;
    }
    /*
     * place the data
     */
    lpWIMsg->message        = message;
    lpWIMsg->lParam         = lParam;

    GlobalUnlock( lpWinInfo->hMemWaitInitQueue );

    /*
     * grow the queue dynamically BEFORE we leave
     */
    if( bNeedNew )  {
        hMemNew = GlobalReAlloc( lpWinInfo->hMemWaitInitQueue,
                (DWORD)sizeof(MSGQHDR) + (wNewCount * sizeof(WIMSG)),
                GMEM_MOVEABLE );
        if( hMemNew )  {
            /*
             * update queue pointers to reflect new size.
             */
            lpWinInfo->hMemWaitInitQueue = hMemNew;
            lpMsgQHdr = (LPMSGQHDR)GlobalLock( hMemNew );
            lpMsgQHdr->wi_nMessagesLeft = WIQ_INCR;
            GlobalUnlock( hMemNew );
        } else {
            /*
             * The memory may never be needed; this is not a real overflow.
             */
            MEMERROR();
            /*  Overflow of queue (%1) waiting for initial advise   */
            NDDELogError(MSG028, LogString("%d", wNewCount), NULL);
            return(FALSE);
        }
    }
    return( TRUE );
}



/*
 * This routine empties the messages added by WaitInitAddMsg()
 */
VOID
FAR PASCAL
SendQueuedMessages(
    HWND        hWnd,
    LPWININFO   lpWinInfo )
{
    LPMSGQHDR   lpMsgQHdr;
    LPWIMSG     lpWIMsg;
    int         nCount;

    /*
     * If there is no queue - we're done!
     */
    if( lpWinInfo->hMemWaitInitQueue == 0 )  {
        return;
    }

    if( lpWinInfo->hDder && lpWinInfo->wState == WST_OK ) {
        lpMsgQHdr = (LPMSGQHDR)GlobalLock( lpWinInfo->hMemWaitInitQueue );

        lpWIMsg = &lpMsgQHdr->wi_msg[ 0 ];
        nCount = lpMsgQHdr->wi_nMessagesQueued;
        while( --nCount >= 0 )  {
            switch (lpWIMsg->message) {
            case WM_DDE_REQUEST:
                AddRequestUnadvise( lpWIMsg->message, lpWinInfo, lpWIMsg->lParam );
                break;
            case WM_DDE_ADVISE:
                AddAdvise( lpWinInfo, lpWIMsg->lParam );
                break;
            case WM_DDE_UNADVISE:
                AddRequestUnadvise( lpWIMsg->message, lpWinInfo, lpWIMsg->lParam );
                break;
            case WM_DDE_POKE:
                AddPoke( lpWinInfo, lpWIMsg->lParam );
                break;
            case WM_DDE_EXECUTE:
                AddExecute( lpWinInfo, lpWIMsg->lParam );
                break;
            }
            lpWIMsg++;
        }
        GlobalUnlock( lpWinInfo->hMemWaitInitQueue );
    }

    /*
     * free the queue
     */
    GlobalFree( lpWinInfo->hMemWaitInitQueue );
    lpWinInfo->hMemWaitInitQueue = 0;
}



/*
 * This routine empties the messages added by WaitInitAddMsg()
 * and deletes any objects associated with the messages.
 */
VOID
FAR PASCAL
DeleteQueuedMessages( LPWININFO lpWinInfo )
{
    LPMSGQHDR   lpMsgQHdr;
    LPWIMSG     lpWIMsg;
    int         nCount;
    UINT_PTR    aItem;
    LPARAM      lParam;

    if( lpWinInfo->hMemWaitInitQueue == 0 )  {
        return;
    }

    lpMsgQHdr = (LPMSGQHDR)GlobalLock( lpWinInfo->hMemWaitInitQueue );
    lpWIMsg = &lpMsgQHdr->wi_msg[ 0 ];
    nCount = lpMsgQHdr->wi_nMessagesQueued;
    while( --nCount >= 0 )  {
        HANDLE hData;

        switch (lpWIMsg->message) {
        case WM_DDE_REQUEST:
            GlobalDeleteAtom(HIWORD(lpWIMsg->lParam));
            break;

        case WM_DDE_ADVISE:
            UnpackDDElParam( WM_DDE_ADVISE, lpWIMsg->lParam,
                    (PUINT_PTR)&hData, &aItem );

            /*
             * If we've got the local terminate NACK first the
             * queued messages.
             */
            lParam = ReuseDDElParam(lpWIMsg->lParam, WM_DDE_ADVISE,
                                    WM_DDE_ACK, 0, aItem);
            if (!PostMessage(lpWinInfo->hWndDDELocal, WM_DDE_ACK,
                        (WPARAM)lpWinInfo->hWndDDE, lParam)) {
                GlobalDeleteAtom((ATOM)aItem);
                FreeDDElParam(WM_DDE_ACK, lParam);
                GlobalFree(hData);
            }

            break;

        case WM_DDE_UNADVISE:
            /*
             * If we've got the local terminate NACK first the
             * queued messages.
             */
            aItem = HIWORD(lpWIMsg->lParam);
            lParam = PackDDElParam(WM_DDE_ACK, 0, aItem);
            if (!PostMessage(lpWinInfo->hWndDDELocal, WM_DDE_ACK,
                        (WPARAM)lpWinInfo->hWndDDE, lParam)) {
                GlobalDeleteAtom((ATOM)aItem);
                FreeDDElParam(WM_DDE_ACK, lParam);
            }

            break;

        case WM_DDE_POKE:
            UnpackDDElParam( WM_DDE_POKE, lpWIMsg->lParam,
                    (PUINT_PTR)&hData, &aItem );

            /*
             * If we've got the local terminate NACK first the
             * queued messages.
             */
            lParam = ReuseDDElParam(lpWIMsg->lParam, WM_DDE_POKE,
                                    WM_DDE_ACK, 0, aItem);
            if (!PostMessage(lpWinInfo->hWndDDELocal, WM_DDE_ACK,
                        (WPARAM)lpWinInfo->hWndDDE, lParam)) {
                GlobalDeleteAtom((ATOM)aItem);
                FreeDDElParam(WM_DDE_ACK, lParam);
                GlobalFreehData(hData);
            }
            break;

        case WM_DDE_EXECUTE:
            /*
             * If we've got the local terminate NACK first the
             * queued messages.
             */
            lParam = PackDDElParam(WM_DDE_ACK, 0, lpWIMsg->lParam);
            if (!PostMessage(lpWinInfo->hWndDDELocal, WM_DDE_ACK,
                        (WPARAM)lpWinInfo->hWndDDE, lParam)) {
                GlobalFree((HGLOBAL)lpWIMsg->lParam);
            }
            break;
        }
        lpWIMsg++;
    }
    GlobalUnlock( lpWinInfo->hMemWaitInitQueue );

    /*
     * free the queue
     */
    GlobalFree( lpWinInfo->hMemWaitInitQueue );
    lpWinInfo->hMemWaitInitQueue = 0;
}


/*
 * Function to add an atom and prove that it worked.
 */
ATOM
FAR PASCAL
GlobalAddAtomAndCheck( LPSTR lpszItem )
{
    ATOM        aItem;
    char        szAtom[ 256 ];

    if ( aItem = GlobalAddAtom( lpszItem ) )  {
        GlobalGetAtomName( aItem, szAtom, sizeof(szAtom) );
        if( lstrcmpi( szAtom, lpszItem ) != 0 )  {
            /*  Error adding atom: "%1" ==> %2,%\
                Atom retrieved: "%3"    */
            NDDELogError(MSG029, (LPSTR) lpszItem,
                LogString("0x%0X", aItem), (LPSTR) szAtom, NULL);
        }
    } else {
        NDDELogError(MSG030, lpszItem, NULL);
    }
    return( aItem );
}




/*
 *  Request NetDDE Agent to Exec share app if its ok
 *  I think we do this so that the share database is checked in
 *  the context of the user.
 */
LRESULT
RequestExec(
    HANDLE          hWndDDE,
    LPSTR           lpszCmdLine,
    PNDDESHAREINFO  lpShareInfo)
{
    COPYDATASTRUCT  CopyData;
    PNDDEAGTCMD     pAgntCmd;
    DWORD           dwSize;
    LPSTR           lpszShareName;
    LPSTR           lpszTarget;
    PTHREADDATA     ptd;

    /*
     * Validate command line.
     */
    if( (lpszCmdLine == NULL) || (*lpszCmdLine == '\0') )  {
        /*  RequestExec(): Command Line non-existent. */
        NDDELogError(MSG031, NULL);
        return(-1);
    }

    /*
     * allocate packet for NddeAgent
     */
    lpszShareName = lpShareInfo->lpszShareName;
    dwSize = sizeof(NDDEAGTCMD)
                + lstrlen(lpszShareName) + 1
                + lstrlen(lpszCmdLine) + 1 + 1;

    pAgntCmd = (PNDDEAGTCMD)LocalAlloc(LPTR, dwSize);
    if( pAgntCmd == NULL )  {
        MEMERROR();
        return( -1 );
    }

    /*
     * pack in the data.
     */
    pAgntCmd->dwMagic = NDDEAGT_CMD_MAGIC;
    pAgntCmd->dwRev = NDDEAGT_CMD_REV;
    pAgntCmd->dwCmd = NDDEAGT_CMD_WINEXEC;
    pAgntCmd->qwModifyId[0] = lpShareInfo->qModifyId[0];
    pAgntCmd->qwModifyId[1] = lpShareInfo->qModifyId[1];
    pAgntCmd->fuCmdShow = lpShareInfo->nCmdShow;   /* Look In Share later */

    /* build sharename/cmdline string */
    lpszTarget = pAgntCmd->szData;
    lstrcpy( lpszTarget, lpszShareName );
    lpszTarget += lstrlen(lpszShareName) + 1;
    lstrcpy( lpszTarget, lpszCmdLine );
    lpszTarget += lstrlen(lpszCmdLine) + 1;
    *lpszTarget = '\0';

    /*
     * put packet into copydata struct and send it to NddeAgent.
     */
    CopyData.cbData = dwSize;
    CopyData.lpData = pAgntCmd;
    ptd = TlsGetValue(tlsThreadData);
    SendMessage(ptd->hwndDDEAgent, WM_COPYDATA,
        (WPARAM) hWndDDE, (LPARAM) &CopyData);

    /*
     * free our packet
     */
    LocalFree( pAgntCmd );

    return(uAgntExecRtn);
}



/*
 *  Request NetDDE Agent if its ok to do an Init to share app
 *  I think we do this so that the share database is checked in
 *  the context of the user.
 */
LRESULT
RequestInit(
    HANDLE          hWndDDE,
    PNDDESHAREINFO  lpShareInfo)
{
    COPYDATASTRUCT  CopyData;
    PNDDEAGTCMD     pAgntCmd;
    DWORD           dwSize;
    LPSTR           lpszShareName;
    LPSTR           lpszTarget;
    PTHREADDATA     ptd;

    /*
     * allocate packet
     */
    lpszShareName = lpShareInfo->lpszShareName;
    dwSize = sizeof(NDDEAGTCMD)
                + lstrlen(lpszShareName) + 1 + 1;

    pAgntCmd = (PNDDEAGTCMD)LocalAlloc(LPTR, dwSize);
    if( pAgntCmd == NULL )  {
        MEMERROR();
        return( -1 );
    }

    /*
     * Fill packet
     */
    pAgntCmd->dwMagic = NDDEAGT_CMD_MAGIC;
    pAgntCmd->dwRev = NDDEAGT_CMD_REV;
    pAgntCmd->dwCmd = NDDEAGT_CMD_WININIT;
    pAgntCmd->qwModifyId[0] = lpShareInfo->qModifyId[0];
    pAgntCmd->qwModifyId[1] = lpShareInfo->qModifyId[1];

    /* build sharename/cmdline string */
    lpszTarget = pAgntCmd->szData;
    lstrcpy( lpszTarget, lpszShareName );
    lpszTarget += lstrlen(lpszShareName) + 1;
    *lpszTarget = '\0';

    /*
     * put packet into copydata and send it to NddeAgnt
     */
    CopyData.cbData = dwSize;
    CopyData.lpData = pAgntCmd;
    ptd = TlsGetValue(tlsThreadData);
    SendMessage(ptd->hwndDDEAgent, WM_COPYDATA,
        (WPARAM) hWndDDE, (LPARAM) &CopyData);

    /*
     * Free our packet.
     */
    LocalFree( pAgntCmd );

    return(uAgntExecRtn);
}



/*
 * This routine takes a given DDE app|topic pair and produces a
 * resulting app|topic pair and an appropriate command line.
 *
 * This conversion is based on the type of share.  appNames that
 * begin with NDDE$ have topics that specify the share to use.
 * They are either:
 *      NEW (.ole appended topic),
 *      OLD (.dde appended topic),
 * or STATIC. (all others)
 *
 * non-NDDE$ appnames are OLD shares and identify the sharename
 * directly. (ie "app|topic").
 *
 * For NEW (.ole) shares, the topic is a Ole CLASS name that is
 * looked up in the registry to determine the actual server name.
 *
 * The command line consists of the resultant "App Topic" string.
 *
 * Side effects: ForceClearImpersonation on failure.
 *
 */
BOOL
MapShareInformation(
    WORD                dd_type,
    LPSTR               lpAppName,
    LPSTR               lpTopicName,
    LPSTR               lpRsltAppName,
    LPSTR               lpRsltTopicName,
    LPSTR               lpszCmdLine,
    PNDDESHAREINFO      *lplpShareInfo,
    LONG                *lplActualShareType )
{
    LONG                lActualShareType;
    int                 nLenShareName;
    char                szShareName[ MAX_SHARENAMEBUF+1 ];
    BOOL                fAppNameIsShare;
    PNDDESHAREINFO      lpShareInfo = (PNDDESHAREINFO) NULL;
    BOOL                bWildApp = FALSE;
    BOOL                bWildTopic = FALSE;
    DWORD               dwShareBufSize;
    WORD                wShareItemCnt;
    UINT                uErrCode;

    *lplpShareInfo = (PNDDESHAREINFO) NULL;

    fAppNameIsShare = IsShare(lpAppName);
    if( fAppNameIsShare )  {
        /*
         * If the AppName has NDDE$ prepended, then lookup the share
         * and substitute the appropriate strings.
         */
        nLenShareName = strlen( lpTopicName );  // Topic == Sharename
        if (nLenShareName >= MAX_SHARENAMEBUF) {
            dwReasonInitFail = RIACK_SHARE_NAME_TOO_BIG;
            return(FALSE);
        }
        /*
         * Copy share name into a buffer where we can munge it.
         */
        lstrcpyn( szShareName, lpTopicName, MAX_SHARENAMEBUF+1 );

        /*
         * Figure out which type of share it is...
         * .dde = OLD,  .ole = NEW  other = STATIC
         */
        lActualShareType = SHARE_TYPE_STATIC;
        if( nLenShareName >= 5 )  {
            if( _stricmp( &lpTopicName[nLenShareName-4], ".dde" ) == 0 )  {
                lActualShareType = SHARE_TYPE_OLD;
                szShareName[ nLenShareName-4 ] = '\0';

            } else if( _stricmp( &lpTopicName[nLenShareName-4], ".ole" )== 0) {
                lActualShareType = SHARE_TYPE_NEW;
                szShareName[ nLenShareName-4 ] = '\0';
            }
        }

    } else {
        /*
         * AppNames that don't start with NDDE$ are always OLD shares.
         */
        if ((lstrlen(lpAppName) + lstrlen(lpTopicName) + 1) < MAX_SHARENAMEBUF) {
            lActualShareType = SHARE_TYPE_OLD;
            StringCchPrintf( szShareName, MAX_SHARENAMEBUF+1, "%s|%s", lpAppName, lpTopicName );
        } else {
            dwReasonInitFail = RIACK_SHARE_NAME_TOO_BIG;
            return(FALSE);
        }
    }

    /*
     * We have the basic share name in szShareName and the type is set.
     * Now look up that share.
     */
    wShareItemCnt = 0;
    uErrCode = _wwNDdeShareGetInfoA(     /* probe for size */
            szShareName, 2, NULL, 0L,
            &dwShareBufSize, &wShareItemCnt,
            &nW, &nX, &nY, &nZ );
    if( !fAppNameIsShare && ((uErrCode == NDDE_SHARE_NOT_EXIST)
            || (uErrCode == NDDE_INVALID_SHARE)) ) {

        /*
         * For non-NDDE$ shares, try wild topic
         */
        StringCchPrintf( szShareName, MAX_SHARENAMEBUF+1, "%s|*", lpAppName );
        bWildTopic = TRUE;
        wShareItemCnt = 0; // reset to 0 after GetInfoA call
        uErrCode = _wwNDdeShareGetInfoA( szShareName, 2,
                NULL, 0L, &dwShareBufSize, &wShareItemCnt,
                &nW, &nX, &nY, &nZ );
        if( ((uErrCode == NDDE_SHARE_NOT_EXIST)
                || (uErrCode == NDDE_INVALID_SHARE)) ) {
            /*
             * try wild app and topic
             */
            lstrcpyn( szShareName, "*|*", MAX_SHARENAMEBUF+1);
            bWildApp = TRUE;
            wShareItemCnt = 0;  // reset to 0 after GetInfoA call
            uErrCode = _wwNDdeShareGetInfoA( szShareName, 2,
                    NULL, 0L, &dwShareBufSize, &wShareItemCnt,
                    &nW, &nX, &nY, &nZ );
        }
    }

    if (uErrCode == NDDE_BUF_TOO_SMALL) {
        /*
         * allocate enough space for the share data.
         */
        lpShareInfo = HeapAllocPtr(hHeap, GMEM_MOVEABLE, dwShareBufSize);
        if (lpShareInfo == NULL) {
            dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
            return(FALSE);
        }

        wShareItemCnt = 0;
        /*
         * get actual info now
         */
        uErrCode = _wwNDdeShareGetInfoA(
                szShareName, 2, (LPBYTE) lpShareInfo,
                dwShareBufSize, &dwShareBufSize, &wShareItemCnt,
                &nW, &nX, &nY, &nZ );

        if (uErrCode != NDDE_NO_ERROR) {
            ForceClearImpersonation();  // does wwNDdeShareGetInfo have a side effect?
            dwReasonInitFail = RIACK_SHARE_ACCESS_ERROR + uErrCode;
            /*  GetShareInfo Error: %1  */
            NDdeGetErrorString(uErrCode, tmpBuf, sizeof(tmpBuf));
            NDDELogError(MSG032, (LPSTR) tmpBuf, NULL);
            HeapFreePtr(lpShareInfo);
            lpShareInfo = NULL;
            return(FALSE);
        } else {
            /*
             * Make sure the share is shared or local.
             */
            if( !lpShareInfo->fSharedFlag &&
                    (dd_type != DDTYPE_LOCAL_LOCAL) )  {

                ForceClearImpersonation(); // does wwNDdeShareGetInfo have a side effect?
                dwReasonInitFail = RIACK_NOT_SHARED;
                /*  Share "%1" not shared   */
                NDDELogError(MSG033, szShareName, NULL);
                HeapFreePtr(lpShareInfo);
                lpShareInfo = NULL;
                return(FALSE);
            }
        }
    } else {
NoShareError:
        /*
         * Failed to find share.
         */
        ForceClearImpersonation(); // does wwNDdeShareGetInfo have a side effect?
        dwReasonInitFail = RIACK_SHARE_ACCESS_ERROR + uErrCode;
        /*  GetShareInfo "%1" Size Error: %2 / %3   */
        NDdeGetErrorString(uErrCode, tmpBuf, sizeof(tmpBuf));
        NDDELogError(MSG034, szShareName,
            LogString("%d", uErrCode), tmpBuf, NULL);
        return(FALSE);
    }

    /*
     * at this point, we have the share information from the DSDM
     * Extract the App and Topic names from the share info.
     */
    if (!GetShareAppTopic(lActualShareType,
                          lpShareInfo,
                          lpRsltAppName,
                          lpRsltTopicName)) {
        uErrCode = NDDE_SHARE_NOT_EXIST;
        goto NoShareError;
    }

    /*
     * For non NDDE$ appnames, overide the share app and topic names
     * wih * where appropriate.
     */
    if( !fAppNameIsShare )  {
        if( bWildApp )  {
            lstrcpyn( lpRsltAppName, lpAppName, 256 );
        }
        if( bWildTopic )  {
            lstrcpyn( lpRsltTopicName, lpTopicName, 256 );
        }
    }

    if( lActualShareType == SHARE_TYPE_NEW )  { // .ole
        char    szBuff[80];
        HKEY    hkStdFileEditing;

        /*
         * This is an OLE/NEW share.  we need to lookup the apropriate
         * server for the AppName(ie ClassName) requested and set up
         * the command line appropriately.
         */
        lpszCmdLine[0] = '\0';

        StringCchPrintf(szBuff, 80, "%s\\protocol\\StdFileEditing", lpRsltAppName );
        if (RegOpenKey(HKEY_CLASSES_ROOT, szBuff,
                &hkStdFileEditing) == ERROR_SUCCESS) {

            DWORD cb;

            cb = sizeof(szBuff);
            if (RegQueryValue(hkStdFileEditing,
                        "server", szBuff, (PLONG)&cb) == ERROR_SUCCESS ) {
                StringCchPrintf( lpszCmdLine, MAX_APP_NAME + MAX_TOPIC_NAME + 2, "%s %s",
                        (LPSTR)szBuff, (LPSTR)lpRsltTopicName );
            }
            RegCloseKey(hkStdFileEditing);
        }

    } else {
        /*
         * OLD (dde) and STATIC (clipbrd) shares just use the the
         * share's app|topic pair.
         */
        StringCchPrintf( lpszCmdLine, MAX_APP_NAME + MAX_TOPIC_NAME + 2,
                         "%s %s", lpRsltAppName, lpRsltTopicName );
    }

    *lplpShareInfo = lpShareInfo;
    *lplActualShareType = lActualShareType;

    return(TRUE);
}



HIPC
IpcInitConversation(
    HDDER       hDder,
    LPDDEPKT    lpDdePkt,
    BOOL        bStartApp,
    LPSTR       lpszCmdLine,
    WORD        dd_type)
{
    LPDDEPKTINIT            lpDdePktInit    = (LPDDEPKTINIT) lpDdePkt;
    LPDDEPKTCMN             lpDdePktCmn     = (LPDDEPKTCMN) lpDdePkt;
    LPDDEPKTIACK            lpDdePktIack    = NULL;
    HWND                    hWndDDE         = 0;
    DWORD_PTR               dwResult;
    LPWININFO               lpWinInfo       = NULL;
    ATOM                    aApp, aTopic;
    LPBYTE                  lpSecurityKey   = NULL;
    DWORD                   sizeSecurityKey = 0L;
    HANDLE                  hClientAccessToken  = 0;
    PNDDESHAREINFO          lpShareInfo     = NULL;
    PQOS                    pQos            = NULL;
    LPSTR                   lpFromNode      = NULL;
    LPSTR                   lpFromApp       = NULL;
    LPSTR                   lpAppName       = NULL;
    LPSTR                   lpTopicName     = NULL;
    BOOL                    ok              = TRUE;
    BOOL                    bTriedExec      = FALSE;
    BOOL                    bConnected      = FALSE;
    char                    rsltAppName[ 256 ];
    char                    rsltTopicName[ 256 ];
    DWORD                   dwGrantedAccess = 0;
    LONG                    lActualShareType;
    HANDLE                  hAudit = NULL;
    DWORD                   ret;
    BOOL                    fGenerateOnClose = FALSE;
    BOOL                    fCallObjectCloseAuditAlarm = FALSE;
    BOOL                    bQos;
    LONG                    lErr;
    LONG                    shareSI = OWNER_SECURITY_INFORMATION |
                                      DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR    pShareSD;
    DWORD                   cbSDRequired;
    DWORD                   nSizeToReturn;
    PTHREADDATA             ptd;
    BOOL                    bReleaseShare = FALSE;

#if DBG
    if (bDebugDdePkts) {
        DPRINTF(("IpcInitConversation:"));
        DebugDdePkt( lpDdePkt );
    }
#endif // DBG

    lpAppName =   GetStringOffset( lpDdePkt, lpDdePktInit->dp_init_offsToApp);
    lpTopicName = GetStringOffset( lpDdePkt, lpDdePktInit->dp_init_offsToTopic);

    if( (lpDdePktInit->dp_init_offsFromNode != sizeof(DDEPKTINIT)) ||
        (lpDdePktInit->dp_init_sizePassword == 0) )  {

        dwReasonInitFail = RIACK_NEED_PASSWORD;
        ok = FALSE;
    }

    if( ok )  {
        lpFromNode = GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsFromNode);
        lpFromApp = GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsFromApp);

        /* do the reverse krypt */
        ok = DdeSecKeyRetrieve( lpDdePktInit->dp_init_hSecurityKey,
                    &lpSecurityKey, &sizeSecurityKey);
        if (ok) {
            ok = NDDEValidateLogon(
                lpSecurityKey,
                sizeSecurityKey,
                GetInitPktPassword(lpDdePktInit),
                GetInitPktPasswordSize(lpDdePktInit),
                GetInitPktUser(lpDdePktInit),
                GetInitPktDomain(lpDdePktInit),
                &hClientAccessToken );
#if DBG
            if (bDumpTokens) {
                DumpToken( hClientAccessToken );
                DPRINTF(( "ValidateLogon of \"%s\" \\ \"%s\": %d",
                    GetInitPktDomain(lpDdePktInit),
                    GetInitPktUser(lpDdePktInit), ok ));
            }
#endif // DBG
            if( !ok )  {
                dwReasonInitFail = RIACK_NEED_PASSWORD;
            }

        } else {
            dwReasonInitFail = RIACK_NEED_PASSWORD;
        }
    }

    if( ok )  {
        ok = MapShareInformation( dd_type, lpAppName, lpTopicName,
                rsltAppName, rsltTopicName, lpszCmdLine,
                    &lpShareInfo, &lActualShareType );
        if (lpShareInfo) {
            bReleaseShare = TRUE;
        }
#if DBG
        if (bDebugInfo) {
            DPRINTF(("%x MapShareInformation( dd_type: %d, lpAppName: %s, lpTopicName: %s,",
                lpShareInfo,
                dd_type, lpAppName, lpTopicName));
            if (ok) {
                DPRINTF(("     rsltAppName: %s, rsltTopicName: %s, lpszCmdLine: %s): OK",
                    rsltAppName, rsltTopicName, lpszCmdLine));
            } else {
                DPRINTF(("     ): FAILED"));
            }
        }
#endif // DBG
    }

    ptd = TlsGetValue(tlsThreadData);

    if( ok ) {
        /* at this point, we know the app/topic pair, the command
            line and we know the guy has a valid logon */
        hAudit = (HANDLE)hDder;
        assert( hAudit );

        /* let's get security descriptor */
        cbSDRequired = 0;
        ret = _wwNDdeGetShareSecurityA(
            lpShareInfo->lpszShareName,
            shareSI,
            (PSECURITY_DESCRIPTOR)&cbSDRequired,
            0,
            FALSE,
            &cbSDRequired,
            &nSizeToReturn);

        if (ret != NDDE_BUF_TOO_SMALL) {
            DPRINTF(("Unable to get share \"%s\" SD size: %d",
                lpShareInfo->lpszShareName, ret));
            dwReasonInitFail = RIACK_NOPERM;
            ok = FALSE;
        } else {
            pShareSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_ZEROINIT, cbSDRequired);
            if (pShareSD == NULL) {
                MEMERROR();
                ret = NDDE_OUT_OF_MEMORY;
            } else {
                ret = _wwNDdeGetShareSecurityA(
                    lpShareInfo->lpszShareName,
                    shareSI,
                    pShareSD,
                    cbSDRequired,
                    FALSE,
                    &cbSDRequired,
                    &nSizeToReturn);
            }
            if (ret != NDDE_NO_ERROR) {
                DPRINTF(("Unable to get share \"%s\" SD: %d",
                    lpShareInfo->lpszShareName, ret));
                dwReasonInitFail = RIACK_NOPERM;
                LocalFree(pShareSD);
                ok = FALSE;
            }
        }

        if (ok) {
            ForceImpersonate( hClientAccessToken );
#if DBG
            if (bDebugInfo) {
                DumpWhoIAm( "After ForceImpersonate" );
            }
#endif // DBG
            /* let's see what the guy is allowed to do */
            ok = DetermineAccess(
                lpShareInfo->lpszShareName,
                pShareSD,
                &dwGrantedAccess,
                (LPVOID) &hAudit,
                &fGenerateOnClose );
            lErr = GetLastError();
            ForceClearImpersonation();

            if( !ok )  {
                /*  Access Denied. Granted access = %1, Error code: %2  */
                NDDELogWarning(MSG035,
                    LogString("0x%0X", dwGrantedAccess),
                    LogString("%d", lErr), NULL);
                dwReasonInitFail = RIACK_NOPERM;
                LocalFree(pShareSD);
            } else {
                LocalFree(pShareSD);
                /* mark that we should audit the close */
                fCallObjectCloseAuditAlarm = TRUE;

                /* something is allowed */
                switch( lActualShareType )  {
                case SHARE_TYPE_OLD:
                case SHARE_TYPE_NEW:
                    if( (dwGrantedAccess & NDDE_SHARE_INITIATE_LINK) == 0)  {
                        dwReasonInitFail = RIACK_NOPERM;
                        ok = FALSE;
                    }
                    break;
                case SHARE_TYPE_STATIC:
                    if( (dwGrantedAccess & NDDE_SHARE_INITIATE_STATIC)==0)  {
                        dwReasonInitFail = RIACK_NOPERM;
                        ok = FALSE;
                    }
                    break;
                default:
                    /*  Unknown Share Type: %1  */
                    NDDELogError(MSG036,
                        LogString("0x%0X", lActualShareType), NULL);
                    ok = FALSE;
                    break;
                }
            }
        }
    }

    if (ok) {
        /* now we know that the client may be allowed to initiate */
        hWndDDE = CreateWindow( (LPSTR) szNetDDEIntf,
            (LPSTR) GetAppName(),
            WS_CHILD,
            0,
            0,
            0,
            0,
            (HWND) ptd->hwndDDE,
            (HMENU) NULL,
            (HANDLE) hInst,
            (LPSTR) NULL);

        if( hWndDDE )  {
            lpWinInfo = CreateWinInfo(lpFromNode,
                rsltAppName, rsltTopicName,
                lpFromApp, hWndDDE );

            if( lpWinInfo )  {
                if (lpDdePktInit->dp_init_dwSecurityType != NT_SECURITY_TYPE) {
                    lpWinInfo->bWin16Connection = TRUE;
                }

                lpWinInfo->fCallObjectCloseAuditAlarm =
                    fCallObjectCloseAuditAlarm;
                lpWinInfo->fGenerateAuditOnClose = fGenerateOnClose;

                pQos = &lpWinInfo->qosClient;
                if (GetInitPktQos(lpDdePktInit, pQos) == NULL) {
                    pQos->Length = sizeof(QOS);
                    pQos->ImpersonationLevel = SecurityImpersonation;
                    pQos->ContextTrackingMode = SECURITY_STATIC_TRACKING;
                    pQos->EffectiveOnly = TRUE;
                }
                bQos = DdeSetQualityOfService( hWndDDE, &lpWinInfo->qosClient,
                    (PQOS)NULL);
                lpWinInfo->bServerSideOfNet = TRUE;
                lpWinInfo->wState = WST_WAIT_INIT_ACK;

                if( lActualShareType == SHARE_TYPE_STATIC )  {
                    lpShareInfo->cNumItems = 0;
                }

                DderUpdatePermissions(hDder, lpShareInfo, dwGrantedAccess );

                bReleaseShare = FALSE;

                lpWinInfo->hDder = hDder;

                /* don't do it on subsequent errors */
                fCallObjectCloseAuditAlarm = FALSE;
            } else {
                ok = FALSE;
                dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
            }
        } else {
            /*  Could not create client agent window on our node%\
                for client app "%1" on node "%2"    */
            NDDELogError(MSG037, lpFromApp, lpFromNode, NULL);
            ok = FALSE;
            dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
        }
    }

    if( ok )  {
        /* we can't start services, we can't start an app if no-one is
            logged in, and we can't start an app if there's no cmd line
            to start it with */
        if( !lpShareInfo->fStartAppFlag || lpShareInfo->fService )  {
            dwReasonInitFail = RIACK_NOPERM_TO_STARTAPP;
            bStartApp = FALSE;
        } else if( (ptd->hwndDDEAgent == NULL) || (lpszCmdLine[0] == '\0') )  {
            dwReasonInitFail = RIACK_NOPERM_TO_STARTAPP;
            bStartApp = FALSE;
        } else {
            bStartApp = TRUE;
        }

        if (!lpShareInfo->fService) {   /* if its not a service, ask agent */
            if( ptd->hwndDDEAgent ) {        /* agent must exist */
                uAgntExecRtn = (UINT)-1;
                RequestInit(ptd->hwndDDE, lpShareInfo);
                if( uAgntExecRtn == NDDEAGT_INIT_OK )  {
                    ok = TRUE;
                } else {
                    dwReasonInitFail = RIACK_NOPERM_TO_INITAPP;
                    ok = FALSE;
                }
            } else {
                ok = FALSE;
                dwReasonInitFail = RIACK_NO_NDDE_AGENT;
            }
        }
    }


    while( ok && !bConnected )  {

        aApp = GlobalAddAtomAndCheck(rsltAppName);
        aTopic = GlobalAddAtomAndCheck(rsltTopicName);
        if ((aApp == 0) || (aTopic == 0)) {
            /*  IpcInitConversation: null App "%1" or Topic "%2" atoms  */
            NDDELogWarning(MSG038, rsltAppName, rsltTopicName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "sent", (HWND)-1, WM_DDE_INITIATE,
                (UINT_PTR) hWndDDE, MAKELONG(aApp, aTopic) );
        }
#endif // DBG
        lstrcpyn( szInitiatingNode,
            GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsFromNode),
            MAX_NODE_NAME+1 );
        lstrcpyn( szInitiatingApp,
            GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsFromApp),
            256 );
        EnterCrit();
        ptd = TlsGetValue(tlsThreadData);
        ptd->bInitiating = TRUE;
        LeaveCrit();

        /*  Broadcast DDE Initiate as the Client */
        ForceImpersonate( hClientAccessToken );
#if DBG
        if (bDebugInfo) {
            DumpWhoIAm( "After ForceImpersonate" );
        }
#endif // DBG
        SendMessageTimeout( HWND_BROADCAST,
                            WM_DDE_INITIATE,
                            (UINT_PTR)hWndDDE,
                            MAKELONG(aApp, aTopic),
                            SMTO_NORMAL,
                            15000,
                            &dwResult );
        ForceClearImpersonation();
#if DBG
        if (bDebugInfo) {
            DumpWhoIAm( "After ForceClearImpersonation" );
        }
#endif // DBG

        EnterCrit();
        ptd = TlsGetValue(tlsThreadData);
        ptd->bInitiating = FALSE;
        LeaveCrit();
        GlobalDeleteAtom( aApp );
        GlobalDeleteAtom( aTopic );
        if( lpWinInfo->hWndDDELocal )  {
            /* success */
            bConnected = TRUE;
            DDEWndAddToList( hWndDDE );

            /* mark that we rcvd the init packet */
            lpWinInfo->dwRcvd++;
        } else {
            DIPRINTF(("StartApp: %d, TriedExec: %d, CmdLine: %Fs",
                    bStartApp, bTriedExec, lpszCmdLine));
            // security info was to not start the app or we already
            // tried starting it w/o success
            if( !bStartApp || bTriedExec )  {
                if( bTriedExec )  {
                    dwReasonInitFail = RIACK_NORESP_AFTER_STARTAPP;
                } else {
                    dwReasonInitFail = RIACK_NOPERM_TO_STARTAPP;
                }
                ok = FALSE;
            } else {
                if( bStartApp )  {
                    if( ptd->hwndDDEAgent ) {
                        bTriedExec = TRUE;
                        uAgntExecRtn = (UINT)-1;
                        RequestExec(ptd->hwndDDE, lpszCmdLine, lpShareInfo);
                        if( uAgntExecRtn < 32 )  {
                            /*  EXEC of "%1" failed: status = %2    */
                            NDDELogError(MSG039, lpszCmdLine,
                                    LogString("%d", uAgntExecRtn), NULL);
                            ok = FALSE;
                            dwReasonInitFail = RIACK_STARTAPP_FAILED;
                        } else if( uAgntExecRtn == (UINT)-1 )  {
                            /*  EXEC of "%1" failed: unknown status!    */
                            NDDELogError(MSG040, lpszCmdLine, NULL);
                            /* try to initiate anyway */
                        }
                    } else {
                        ok = FALSE;
                        dwReasonInitFail = RIACK_NO_NDDE_AGENT;
                    }
                } else {
                    ok = FALSE;
                    dwReasonInitFail = RIACK_NOPERM_TO_STARTAPP;
                }
            }
        }
    }

    if( ok )  {
        lpDdePktIack = (LPDDEPKTIACK) CreateAckInitiatePkt( ourNodeName,
            GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsToApp),
            GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsToTopic),
            NULL, 0L, 0,
            TRUE, dwReasonInitFail );           /* ACK Conv, no key needed */
        if( lpDdePktIack )  {
            lpWinInfo->dwSent++;
            lpDdePktIack->dp_iack_dwSecurityType = NT_SECURITY_TYPE;
            DderPacketFromIPC( lpWinInfo->hDder, (HIPC) hWndDDE,
                (LPDDEPKT) lpDdePktIack );
        } else {
            dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
            ok = FALSE;
        }
    }

    if( !ok )  {
        if( hWndDDE )  {
            if( lpWinInfo )  {
                /* this prevents us from freeing the DDER twice */
                lpWinInfo->hDder = 0;
            }
            DestroyWindow( hWndDDE );
            hWndDDE = 0;
        }
    }

    if( fCallObjectCloseAuditAlarm )  {
        assert( hAudit );
        ObjectCloseAuditAlarm( NDDE_AUDIT_SUBSYSTEM, (LPVOID)&hAudit,
            fGenerateOnClose );
        fCallObjectCloseAuditAlarm = FALSE;
    }


    if( hClientAccessToken )  {
        CloseHandle( hClientAccessToken );
        hClientAccessToken = NULL;
    }

    if (bReleaseShare) {
        OutputDebugString("\nlpShareInfo released\n\n");
        HeapFreePtr(lpShareInfo);
    }

    return( (HIPC) hWndDDE );
}




/*
    IpcAbortConversation()

        This function is called from DDER whenever the connection is broken,
        or internally whenever an ACK_INITIATE is FALSE.
 */
VOID
IpcAbortConversation( HIPC hIpc )
{
    HWND        hWndDDE;
    LPWININFO   lpWinInfo;

    DIPRINTF(( "IpcAbortConversation( %08lX )", hIpc ));
    hWndDDE = (HWND) hIpc;
    assert( hWndDDE );
    assert( IsWindow( hWndDDE ) );
    lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );
    if (lpWinInfo == NULL)
        return;

    /* don't use the hDder after we get this notification */
    lpWinInfo->hDder = 0;

    /* pretend we sent and rcvd net terminates */
    lpWinInfo->bRcvdTerminateNet = TRUE;
    lpWinInfo->bSentTerminateNet = TRUE;

    /* do rest of terminate logic */
    SendMessage( lpWinInfo->hWndDDE,wMsgDoTerminate,0,(LPARAM)lpWinInfo );
}



VOID
FAR PASCAL
DoTerminate( LPWININFO lpWinInfo )
{
    WORD        wStateInitially;
    LPDDEPKTCMN lpDdePktCmn;
    LPDDEPKT    lpDdePktTerm;

    /* remember what state we were in */
    wStateInitially = lpWinInfo->wState;

    /* pre-mark that we're terminated */
    lpWinInfo->wState = WST_TERMINATED;

    /*
     * NACK first the queued messages.
     */
    DeleteQueuedMessages( lpWinInfo );

    /* if necessary, sent TERMINATE to local task */
    if( lpWinInfo->bRcvdTerminateNet && !lpWinInfo->bSentTerminateLocally ) {
        PostMessage(lpWinInfo->hWndDDELocal,WM_DDE_TERMINATE,(WPARAM)lpWinInfo->hWndDDE,0);
        lpWinInfo->bSentTerminateLocally = TRUE;
    }

    /* if necessary, sent TERMINATE to remote network */
    /* although, we don't want to send it if we're still waiting for net
        init ack, or if termination is complete */

    if (wStateInitially != WST_WAIT_NET_INIT_ACK &&
        wStateInitially != WST_TERMINATION_COMPLETE &&
        lpWinInfo->bRcvdTerminateLocally &&
        !lpWinInfo->bSentTerminateNet) {

        lpWinInfo->bSentTerminateNet = TRUE;
        if( lpWinInfo->hDder )  {
            /* send the terminate to the network */
            lpDdePktCmn = (LPDDEPKTCMN) lpWinInfo->lpDdePktTerminate;
            ((LPDDEPKT)lpDdePktCmn)->dp_size = sizeof(DDEPKTTERM);
            lpDdePktCmn->dc_message = WM_DDE_TERMINATE;
            lpWinInfo->dwSent++;
            lpDdePktTerm = lpWinInfo->lpDdePktTerminate;
            /* make sure we don't free it */
            lpWinInfo->lpDdePktTerminate = NULL;
            DderPacketFromIPC( lpWinInfo->hDder, (HIPC) lpWinInfo->hWndDDE,
                lpDdePktTerm );
        }
    }

    /* if all 4 messages were sent and received, nobody is interested in us
        any more and we should free ourselves */
    if(    lpWinInfo->bRcvdTerminateNet
        && lpWinInfo->bSentTerminateNet
        && lpWinInfo->bRcvdTerminateLocally
        && lpWinInfo->bSentTerminateLocally )  {

        lpWinInfo->wState = WST_TERMINATION_COMPLETE;

        /* got and sent all terminates ... free us */
        DestroyWindow( lpWinInfo->hWndDDE );
    }
}



BOOL
IpcXmitPacket(
    HIPC        hIpc,
    HDDER       hDder,
    LPDDEPKT    lpDdePkt )
{
    LPDDEPKTCMN         lpDdePktCmn;
    HWND                hWndDDE;
    HANDLE              hData;
    LPSTR               lpData;
    LPDDELN             lpOptions;
    LPSTR               lpszItemName;
    DDEQENT             DDEQEnt;
    DDEQENT             DDEQEntRmv;
    LPWININFO           lpWinInfo;
    LPDDEPKTIACK        lpDdePktIack;
    LPDDEPKTEACK        lpDdePktEack;
    LPDDEPKTGACK        lpDdePktGack;
    LPDDEPKTEXEC        lpDdePktExec;
    LPDDEPKTRQST        lpDdePktRqst;
    LPDDEPKTUNAD        lpDdePktUnad;
    LPDDEPKTDATA        lpDdePktData;
    LPDDEPKTPOKE        lpDdePktPoke;
    LPDDEPKTADVS        lpDdePktAdvs;
    BOOL                bRemoved;
    BOOL                bLocalWndValid;
    BOOL                bRtn = TRUE;
    WORD                wStatus;
    WORD                cfFormat;
    ATOM                aItem;

#if DBG
    DIPRINTF(( "IpcXmitPacket( %08lX, %08lX, %08lX )", hIpc,
            hDder, lpDdePkt ));
    DebugDdePkt( lpDdePkt );
#endif // DBG
    lpDdePktCmn = (LPDDEPKTCMN) lpDdePkt;

    hWndDDE = (HWND) hIpc;
    if( hWndDDE && IsWindow( hWndDDE ) )  {
        if (GetWindowThreadProcessId(hWndDDE, NULL) != GetCurrentThreadId()) {
            IPCXMIT ix;

            ix.hIpc = hIpc;
            ix.hDder = hDder;
            ix.lpDdePkt = lpDdePkt;
            return SendMessage(GetParent(hWndDDE),
                               wMsgIpcXmit,
                               (DWORD_PTR)&ix,
                               0) != FALSE;
        }
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );
        lpWinInfo->dwRcvd++;
    } else {
        /*  Message: %1 to a non-existent window: %2    */
        NDDELogError(MSG041,
            LogString("0x%0X", lpDdePktCmn->dc_message),
            LogString("0x%0X", hWndDDE), NULL);
        HeapFreePtr( lpDdePkt );
        return( FALSE );
    }

    /* check if our partner is still around */
    bLocalWndValid = IsWindow( lpWinInfo->hWndDDELocal );

    switch( lpDdePktCmn->dc_message )  {
    case WM_DDE_ACK_INITIATE:
        lpDdePktIack = (LPDDEPKTIACK) lpDdePkt;
        if( lpDdePktIack->dp_iack_fromDder )  {
            /* successful initiate */
            if( lpWinInfo->hDder && (lpWinInfo->hDder != hDder) )  {
                /*  INTERNAL ERROR -- IpcXmitPacket %1 hDder handles should match %2 */
                NDDELogError(MSG043,
                    LogString("0x%0X", hDder),
                    LogString("0x%0X", lpWinInfo->hDder), NULL );
#if DBG
                if (bDebugInfo) {
                    DebugDdeIntfState();
                    DebugDderState();
                    DebugRouterState();
                    DebugPktzState();
                    DPRINTF(( "" ));
                }
#endif // DBG
            }
            lpWinInfo->hDder = hDder;
            if( lpWinInfo->wState == WST_TERMINATED )  {
                /* terminate came in locally while we were waiting for net
                    init ack */
                SendMessage(lpWinInfo->hWndDDE,wMsgDoTerminate,0,(LPARAM)lpWinInfo);
            } else {
                /* notify the local window that the ack is back */
                if( lpWinInfo->hWndDDELocal
                        && IsWindow(lpWinInfo->hWndDDELocal) )  {
                    SendMessage( lpWinInfo->hWndDDELocal,
                        wMsgInitiateAckBack, (UINT_PTR)lpWinInfo->hWndDDE, 0L );
                }
                lpWinInfo->wState = WST_OK;
                lpWinInfo->dwSecurityType = lpDdePktIack->dp_iack_dwSecurityType;
                if (lpWinInfo->dwSecurityType != NT_SECURITY_TYPE) {
                    lpWinInfo->bWin16Connection = TRUE;
                }
                //DPRINTF(( "ack back ... bInitiating: %d", lpWinInfo->bInitiating ));
                if( !lpWinInfo->bInitiating )  {
                    SendQueuedMessages( hWndDDE, lpWinInfo );
                }
            }
        } else {
            //DPRINTF(( "init nack: reason: %d", lpDdePktIack->dp_iack_reason ));
            if( (++lpWinInfo->nInitNACK > MAX_INIT_NACK)
                   || (lpDdePktIack->dp_iack_reason != RIACK_NEED_PASSWORD)) {
                /* notify the local window that the ack is back */
                if( lpWinInfo->hWndDDELocal
                        && IsWindow(lpWinInfo->hWndDDELocal) )  {
                    SendMessage( lpWinInfo->hWndDDELocal,
                        wMsgInitiateAckBack, (UINT_PTR)lpWinInfo->hWndDDE,
                        lpDdePktIack->dp_iack_reason );
                }

                /* unsuccessfull initiate */
                IpcAbortConversation( hIpc );
            } else {
                lpWinInfo->dwSecurityType = lpDdePktIack->dp_iack_dwSecurityType;
                if (lpWinInfo->sizeSecurityKeyRcvd =
                    lpDdePktIack->dp_iack_sizeSecurityKey) {
                    /* received a security key for password */
                    lpWinInfo->lpSecurityKeyRcvd = HeapAllocPtr( hHeap,
                        GMEM_MOVEABLE, lpWinInfo->sizeSecurityKeyRcvd);
                    if (lpWinInfo->lpSecurityKeyRcvd) {
                        lpWinInfo->hSecurityKeyRcvd =
                            lpDdePktIack->dp_iack_hSecurityKey;
                        hmemcpy(lpWinInfo->lpSecurityKeyRcvd,
                            GetStringOffset( lpDdePkt,
                                lpDdePktIack->dp_iack_offsSecurityKey),
                            lpWinInfo->sizeSecurityKeyRcvd);
                    } else {
                        lpWinInfo->sizeSecurityKeyRcvd = 0;
                    }
                }

                if (!PostMessage( hWndDDE, WM_HANDLE_DDE_INITIATE, 0, 0L) ) {
                    /* abort the conversation */
                    IpcAbortConversation( (HIPC)hWndDDE );
                }
            }
        }
        break;

    case WM_DDE_TERMINATE:
        /* mark that we got a terminate from the net */
        lpWinInfo->bRcvdTerminateNet = TRUE;
        SendMessage(lpWinInfo->hWndDDE,wMsgDoTerminate,0,(LPARAM)lpWinInfo);
        break;

    case WM_DDE_EXECUTE:
        lpDdePktExec = (LPDDEPKTEXEC) lpDdePkt;
        hData = GetGlobalAlloc(
            GMEM_MOVEABLE | GMEM_DDESHARE,
            lstrlen( lpDdePktExec->dp_exec_string )+1 );
        if( hData )  {
            lpData = GlobalLock( hData );
            if( lpData )  {
                lstrcpyn( lpData, lpDdePktExec->dp_exec_string, lstrlen(lpDdePktExec->dp_exec_string)+1 );
                GlobalUnlock( hData );
                DDEQEnt.wMsg            = WM_DDE_EXECUTE - WM_DDE_FIRST;
                DDEQEnt.fRelease        = FALSE;
                DDEQEnt.fAckReq         = FALSE;
                DDEQEnt.fResponse       = FALSE;
                DDEQEnt.fNoData         = FALSE;
                DDEQEnt.hData           = (ULONG_PTR)hData;
                if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
                    bRtn = FALSE;
                }
                if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
                    if( !PostMessage( lpWinInfo->hWndDDELocal,
                                      WM_DDE_EXECUTE,
                                      (UINT_PTR)lpWinInfo->hWndDDE,
                                      PackDDElParam( WM_DDE_EXECUTE,
                                                     (WPARAM)NULL,
                                                     (LPARAM)hData) ) ) {
                        bRtn = FALSE;
                        GlobalFree(hData);
                    }
                } else {
                    GlobalFree(hData);
                }

            } else {
                /*  Lock failed for %1 memory alloc */
                NDDELogError(MSG044, "WM_DDE_EXECUTE", NULL);
                bRtn = FALSE;
            }
        } else {
            MEMERROR();
            /*  Not enough memory for %1 bytes msg: WM_DDE_EXECUTE */
            NDDELogError(MSG045,
                LogString("%d", lstrlen( lpDdePktExec->dp_exec_string )+1), NULL);
            bRtn = FALSE;
        }
        break;

    case WM_DDE_REQUEST:
        lpDdePktRqst = (LPDDEPKTRQST) lpDdePkt;
        wStatus = 0;
        cfFormat = GetClipFormat( lpDdePkt, lpDdePktRqst->dp_rqst_cfFormat,
            lpDdePktRqst->dp_rqst_offsFormat );
        lpszItemName = GetStringOffset( lpDdePkt,
            lpDdePktRqst->dp_rqst_offsItemName );
        aItem = GlobalAddAtomAndCheck( lpszItemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(REQUEST): null Item atom for "%1" */
            NDDELogWarning(MSG046, lpszItemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }

        DDEQEnt.wMsg            = WM_DDE_REQUEST - WM_DDE_FIRST;
        DDEQEnt.fRelease        = FALSE;
        DDEQEnt.fAckReq         = FALSE;
        DDEQEnt.fResponse       = FALSE;
        DDEQEnt.fNoData         = FALSE;
        DDEQEnt.hData           = 0;

        if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
            return( FALSE );
        }
        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                              WM_DDE_REQUEST,
                              (UINT_PTR)lpWinInfo->hWndDDE,
                               PackDDElParam( WM_DDE_REQUEST,
                                              cfFormat,
                                              aItem) ) )  {
                bRtn = FALSE;
            }
        }
        break;

    case WM_DDE_UNADVISE:
        lpDdePktUnad = (LPDDEPKTUNAD) lpDdePkt;
        wStatus = 0;
        cfFormat = GetClipFormat( lpDdePkt, lpDdePktUnad->dp_unad_cfFormat,
            lpDdePktUnad->dp_unad_offsFormat );
        lpszItemName = GetStringOffset( lpDdePkt,
            lpDdePktUnad->dp_unad_offsItemName );
        aItem = GlobalAddAtomAndCheck( lpszItemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(%1): null Item atom for "%2" */
            NDDELogWarning(MSG046, "UNADVISE", lpszItemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }

        DDEQEnt.wMsg            = WM_DDE_UNADVISE - WM_DDE_FIRST;
        DDEQEnt.fRelease        = FALSE;
        DDEQEnt.fAckReq         = FALSE;
        DDEQEnt.fResponse       = FALSE;
        DDEQEnt.fNoData         = FALSE;
        DDEQEnt.hData           = 0;

        if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
            return( FALSE );
        }
        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                WM_DDE_UNADVISE, (UINT_PTR)lpWinInfo->hWndDDE,
                PackDDElParam(WM_DDE_UNADVISE,cfFormat,aItem) ) )  {
                bRtn = FALSE;
            }
        }
        break;

    case WM_DDE_DATA:
        lpDdePktData = (LPDDEPKTDATA) lpDdePkt;
        cfFormat = GetClipFormat( lpDdePkt, lpDdePktData->dp_data_cfFormat,
            lpDdePktData->dp_data_offsFormat );
        lpszItemName = GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsItemName );
        aItem = GlobalAddAtomAndCheck( lpszItemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(%1): null Item atom for "%2" */
            NDDELogWarning(MSG046, "DATA", lpszItemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }

        if( lpDdePktData->dp_data_sizeData == 0L )  {
            hData = 0;
        } else {
            switch (cfFormat) {
                case CF_METAFILEPICT:
                    hData = ConvertPktToDataMetafile( lpDdePkt,
                        lpDdePktData, lpWinInfo->bWin16Connection  );
                    break;
                case CF_BITMAP:
                    hData = ConvertPktToDataBitmap( lpDdePkt,
                        lpDdePktData, lpWinInfo->bWin16Connection  );
                    break;
                case CF_ENHMETAFILE:
                    hData = ConvertPktToDataEnhMetafile( lpDdePkt, lpDdePktData );
                    break;
                case CF_PALETTE:
                    hData = ConvertPktToDataPalette( lpDdePkt, lpDdePktData );
                    break;
                case CF_DIB:
                    hData = ConvertPktToDataDIB( lpDdePkt, lpDdePktData );
                    break;
                default:
                    if (cfFormat == cfPrinterPicture )  {
                        hData = ConvertPktToDataMetafile( lpDdePkt,
                            lpDdePktData, lpWinInfo->bWin16Connection  );
                    } else {
                        hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
                            lpDdePktData->dp_data_sizeData+sizeof(DDELN) );
                        lpData = GlobalLock( hData );
                        if( lpData )  {
                            hmemcpy( ((LPDATA)lpData)->info,
                                GetStringOffset( lpDdePkt,
                                    lpDdePktData->dp_data_offsData ),
                                    lpDdePktData->dp_data_sizeData );
                            GlobalUnlock(hData);
                        } else {
                            MEMERROR();
                        }
                    }
                    break;
            }

            if( hData == 0 )  {
                return( FALSE );
            }

            lpData = GlobalLock( hData );
            if( lpData )  {
                /* zero out the DDELN structure */
                _fmemset( lpData, 0, sizeof(DDELN) );
                ((LPDDELN)lpData)->fResponse = lpDdePktData->dp_data_fResponse;
                ((LPDDELN)lpData)->fAckReq = lpDdePktData->dp_data_fAckReq;
                ((LPDDELN)lpData)->fRelease = TRUE;
                ((LPDDELN)lpData)->cfFormat = cfFormat;

                if( ((LPDDELN)lpData)->fResponse )  {
                    GlobalDeleteAtom( (ATOM)aItem );
                    DDEQRemove( lpWinInfo->qDDEOutgoingCmd, &DDEQEntRmv );
                    if( DDEQEntRmv.wMsg != (WM_DDE_REQUEST - WM_DDE_FIRST) ) {
                        /*  %1 from DDE Server "%2" not matching %3: %4   */
                        NDDELogWarning(MSG026, "WM_DDE_DATA",
                            (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName),
                            "REQUEST",
                            LogString("0x%0X", DDEQEntRmv.wMsg + WM_DDE_FIRST), NULL );
                    }
                }
                if( ((LPDDELN)lpData)->fAckReq )  {
                    DDEQEnt.wMsg        = WM_DDE_DATA - WM_DDE_FIRST;
                    DDEQEnt.fRelease    = TRUE;
                    DDEQEnt.fAckReq     = ((LPDDELN)lpData)->fAckReq;
                    DDEQEnt.fResponse   = ((LPDDELN)lpData)->fResponse;
                    DDEQEnt.fNoData     = FALSE;
                    DDEQEnt.hData       = (ULONG_PTR)hData;
                    if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
                        return( FALSE );
                    }
                }
                GlobalUnlock( hData );
            } else {
                /*  Lock failed for %1 memory alloc */
                NDDELogError(MSG044, "WM_DDE_DATA", NULL);
                return( FALSE );
            }
        }
        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                              WM_DDE_DATA,
                              (UINT_PTR)lpWinInfo->hWndDDE,
                              PackDDElParam( WM_DDE_DATA,
                               (UINT_PTR)hData,
                               aItem) ) )  {
                bRtn = FALSE;
                GlobalFreehData(hData);
            }
        } else {
            GlobalFreehData(hData);
        }
        break;

    case WM_DDE_POKE:
        lpDdePktPoke = (LPDDEPKTPOKE) lpDdePkt;
        cfFormat = GetClipFormat( lpDdePkt, lpDdePktPoke->dp_poke_cfFormat,
            lpDdePktPoke->dp_poke_offsFormat );
        lpszItemName = GetStringOffset( lpDdePkt,
            lpDdePktPoke->dp_poke_offsItemName );
        aItem = GlobalAddAtomAndCheck( lpszItemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(%1): null Item atom for "%2" */
            NDDELogWarning(MSG046, "POKE", lpszItemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }

        if( lpDdePktPoke->dp_poke_sizeData == 0L )  {
            hData = 0;
        } else {
            switch (cfFormat) {
                case CF_METAFILEPICT:
                    hData = ConvertPktToDataMetafile( lpDdePkt,
                        (LPDDEPKTDATA) lpDdePktPoke, lpWinInfo->bWin16Connection  );
                    break;
                case CF_BITMAP:
                    hData = ConvertPktToDataBitmap( lpDdePkt,
                        (LPDDEPKTDATA) lpDdePktPoke, lpWinInfo->bWin16Connection  );
                    break;
                case CF_ENHMETAFILE:
                    hData = ConvertPktToDataEnhMetafile( lpDdePkt,
                        (LPDDEPKTDATA) lpDdePktPoke );
                    break;
                case CF_PALETTE:
                    hData = ConvertPktToDataPalette( lpDdePkt,
                        (LPDDEPKTDATA) lpDdePktPoke );
                    break;
                case CF_DIB:
                    hData = ConvertPktToDataDIB( lpDdePkt,
                        (LPDDEPKTDATA) lpDdePktPoke );
                    break;
                default:
                    if (cfFormat == cfPrinterPicture )  {
                        hData = ConvertPktToDataMetafile( lpDdePkt,
                            (LPDDEPKTDATA) lpDdePktPoke, lpWinInfo->bWin16Connection  );
                    } else {
                        hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
                            lpDdePktPoke->dp_poke_sizeData+sizeof(DDELN) );
                        lpData = GlobalLock( hData );
                        if( lpData )  {
                            hmemcpy( ((LPDATA)lpData)->info,
                                GetStringOffset( lpDdePkt,
                                    lpDdePktPoke->dp_poke_offsData ),
                                    lpDdePktPoke->dp_poke_sizeData );
                            GlobalUnlock(hData);
                        } else {
                            MEMERROR();
                        }
                    }
                    break;
            }

            if( hData == 0 )  {
                return( FALSE );
            }

            lpData = GlobalLock( hData );
            if( lpData )  {
                /* zero out the DDELN structure */
                assert( sizeof(DDELN) == sizeof(LONG) );
                * ((LONG FAR *)lpData) = 0L;

                ((LPDDELN)lpData)->fRelease = TRUE;
                ((LPDDELN)lpData)->cfFormat = cfFormat;

                assert( lpWinInfo->bServerSideOfNet );
                DDEQEnt.wMsg = WM_DDE_POKE - WM_DDE_FIRST;
                DDEQEnt.fRelease        = TRUE;
                DDEQEnt.fAckReq         = FALSE;
                DDEQEnt.fResponse       = FALSE;
                DDEQEnt.fNoData         = FALSE;
                DDEQEnt.hData           = (ULONG_PTR)hData;
                if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
                    return( FALSE );
                }

                GlobalUnlock( hData );
            } else {
                /*  Lock failed for %1 memory alloc */
                NDDELogError(MSG044, "WM_DDE_POKE", NULL);
                return( FALSE );
            }
        }
        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                               WM_DDE_POKE, (UINT_PTR)lpWinInfo->hWndDDE,
                               PackDDElParam( WM_DDE_POKE,
                                (UINT_PTR)hData,
                                aItem) ) )  {
                bRtn = FALSE;
                GlobalFreehData(hData);
            }
        } else {
            GlobalFreehData(hData);
        }
        break;

    case WM_DDE_ADVISE:
        lpDdePktAdvs = (LPDDEPKTADVS) lpDdePkt;
        cfFormat = GetClipFormat( lpDdePkt, lpDdePktAdvs->dp_advs_cfFormat,
            lpDdePktAdvs->dp_advs_offsFormat );
        lpszItemName = GetStringOffset( lpDdePkt,
            lpDdePktAdvs->dp_advs_offsItemName );
        aItem = GlobalAddAtomAndCheck( lpszItemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(%1): null Item atom for "%2" */
            NDDELogWarning(MSG046, "ADVISE", lpszItemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }

        hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
            (DWORD)sizeof(DDELN) );
        if( hData == 0 )  {
            MEMERROR();
            return( FALSE );
        }

        lpOptions = (LPDDELN) GlobalLock( hData );
        if( lpOptions )  {

            /* zero out the DDELN structure */
            assert( sizeof(DDELN) == sizeof(LONG) );
            * ((LONG FAR *)lpOptions) = 0L;

            /* copy in options */
            lpOptions->fAckReq = lpDdePktAdvs->dp_advs_fAckReq;
            lpOptions->fNoData = lpDdePktAdvs->dp_advs_fNoData;
            lpOptions->cfFormat = cfFormat;
            GlobalUnlock( hData );
        } else {
            /*  Lock failed for %1 memory alloc */
            NDDELogError(MSG044, "WM_DDE_ADVISE", NULL);
            return( FALSE );
        }

        assert( lpWinInfo->bServerSideOfNet );
        DDEQEnt.wMsg = WM_DDE_ADVISE - WM_DDE_FIRST;
        DDEQEnt.fRelease        = FALSE;
        DDEQEnt.fAckReq         = lpOptions->fAckReq;
        DDEQEnt.fResponse       = FALSE;
        DDEQEnt.fNoData         = lpOptions->fNoData;
        DDEQEnt.hData           = (ULONG_PTR)hData;
        if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
            return( FALSE );
        }

        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                              WM_DDE_ADVISE, (UINT_PTR)lpWinInfo->hWndDDE,
                              PackDDElParam( WM_DDE_ADVISE,
                               (UINT_PTR)hData,
                               aItem) ) )  {
                bRtn = FALSE;
                GlobalFree(hData);
            }
        } else {
            GlobalFreehData(hData);
        }
        break;

    case WM_DDE_ACK_EXECUTE:
        lpDdePktEack = (LPDDEPKTEACK) lpDdePkt;
        bRemoved = DDEQRemove( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt );
        if( !bRemoved )  {
            /*  Extraneous %1 from DDE Client "%2"  */
            NDDELogWarning(MSG023, "WM_DDE_ACK_EXECUTE",
                (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName), NULL);
        } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_EXECUTE )  {
            /*  %1 from DDE Server "%2" not matching %3: %4   */
            NDDELogWarning(MSG026, "WM_DDE_ACK_EXECUTE",
                (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName),
                "DATA",
                LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST), NULL );
        } else {
            wStatus = 0;
            if( lpDdePktEack->dp_eack_fAck )  {
                wStatus |= ACK_MSG;
            } else {
                wStatus |= NACK_MSG;
            }
            if( lpDdePktEack->dp_eack_fBusy )  {
                wStatus |= BUSY_MSG;
            }
            wStatus |= lpDdePktEack->dp_eack_bAppRtn;
            if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
                if( !PostMessage( lpWinInfo->hWndDDELocal,
                                  WM_DDE_ACK, (UINT_PTR)lpWinInfo->hWndDDE,
                                  PackDDElParam(WM_DDE_ACK,wStatus,DDEQEnt.hData) ) )  {
                    bRtn = FALSE;
                }
            }
        }
        break;

    case WM_DDE_ACK_ADVISE:
    case WM_DDE_ACK_REQUEST:
    case WM_DDE_ACK_UNADVISE:
    case WM_DDE_ACK_POKE:
    case WM_DDE_ACK_DATA:
        lpDdePktGack = (LPDDEPKTGACK) lpDdePkt;
        bRemoved = DDEQRemove( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt );
        wStatus = 0;
        if( lpDdePktGack->dp_gack_fAck )  {
            wStatus |= ACK_MSG;
        } else {
            wStatus |= NACK_MSG;
        }
        if( lpDdePktGack->dp_gack_fBusy )  {
            wStatus |= BUSY_MSG;
        }
        wStatus |= lpDdePktGack->dp_gack_bAppRtn;

        /* keep atom use count same */
        aItem = GlobalAddAtomAndCheck( lpDdePktGack->dp_gack_itemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(%1): null Item atom for "%2" */
            NDDELogWarning(MSG046, "ACK", lpDdePktGack->dp_gack_itemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }
        GlobalDeleteAtom( (ATOM)aItem );

        switch( lpDdePktCmn->dc_message )  {
        case WM_DDE_ACK_ADVISE:
            if( !bRemoved )  {
                /*  Extraneous ACK apparently to an %1.%\
                    From "%2" client -> "%3" app    */
                NDDELogWarning(MSG047, "ADVISE",
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL );
            } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_ADVISE )  {
                /*  %1 ACK not to an %1 [%2]%\
                    From "%3" client -> "%4" app    */
                NDDELogWarning(MSG048, "ADVISE",
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST),
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName, NULL );
            } else {
                if( bLocalWndValid && (wStatus & ACK_MSG) )  {
                    if( DDEQEnt.hData )  {
                        GlobalFree( (HANDLE)DDEQEnt.hData );
                    }
                }
            }
            break;
        case WM_DDE_ACK_REQUEST:
            if( !bRemoved )  {
                /*  Extraneous ACK apparently to an %1.%\
                    From "%2" client -> "%3" app    */
                NDDELogWarning(MSG047, "REQUEST",
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL );
            } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_REQUEST )  {
                /*  %1 ACK not to an %1 [%2]%\
                    From "%3" client -> "%4" app    */
                NDDELogWarning(MSG048, "REQUEST",
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST),
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName, NULL );
            }
            break;
        case WM_DDE_ACK_UNADVISE:
            if( !bRemoved )  {
                /*  Extraneous ACK apparently to an %1.%\
                    From "%2" client -> "%3" app    */
                NDDELogWarning(MSG047, "UNADVISE",
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL );
            } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_UNADVISE )  {
                /*  %1 ACK not to an %1 [%2]%\
                    From "%3" client -> "%4" app    */
                NDDELogWarning(MSG048, "UNADVISE",
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST),
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName, NULL );
            }
            break;
        case WM_DDE_ACK_POKE:
            if( !bRemoved )  {
                /*  Extraneous ACK apparently to an %1.%\
                    From "%2" client -> "%3" app    */
                NDDELogWarning(MSG047, "POKE",
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL );
            } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_POKE )  {
                /*  %1 ACK not to an %1 [%2]%\
                    From "%3" client -> "%4" app    */
                NDDELogWarning(MSG048, "POKE",
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST),
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName, NULL );
            } else {
                if( bLocalWndValid && DDEQEnt.fRelease && (wStatus & ACK_MSG) ) {
                    if( DDEQEnt.hData )  {
                        GlobalFreehData( (HANDLE)DDEQEnt.hData );
                    }
                }
            }
            break;
        case WM_DDE_ACK_DATA:
            if( !bRemoved )  {
                /*  Extraneous ACK apparently to an %1.%\
                    From "%2" client -> "%3" app    */
                NDDELogWarning(MSG047, "DATA",
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL );
            } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_DATA )  {
                /*  %1 ACK not to an %1 [%2]%\
                    From "%3" client -> "%4" app    */
                NDDELogWarning(MSG048, "DATA",
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST),
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName, NULL );
            } else {
                if( bLocalWndValid && DDEQEnt.fRelease && (wStatus &ACK_MSG) ) {
                    if( DDEQEnt.hData )  {
                        GlobalFreehData( (HANDLE)DDEQEnt.hData );
                    }
                }
            }
            break;
        }

        /* post message to local DDE window */
        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                WM_DDE_ACK,
                (UINT_PTR)lpWinInfo->hWndDDE,
                PackDDElParam(WM_DDE_ACK,wStatus,aItem) ) )  {
                bRtn = FALSE;
            }
        }
        break;

    default:
        NDDELogError(MSG049,
            LogString("0x%0X", lpDdePktCmn->dc_message), NULL);
        bRtn = FALSE;
    }

    /* free the packet */
    HeapFreePtr( lpDdePkt );

    return( bRtn );
}



LPWININFO
FAR PASCAL
CreateWinInfo(
    LPSTR   lpszNode,
    LPSTR   lpszApp,
    LPSTR   lpszTopic,
    LPSTR   lpszClient,
    HWND    hWndDDE )
{
    LPWININFO   lpWinInfo;
    BOOL        ok = TRUE;
    DWORD       size;

    AnsiUpper( lpszNode );
    AnsiUpper( lpszApp );
    AnsiUpper( lpszTopic );
    AnsiUpper( lpszClient );

    lpWinInfo = HeapAllocPtr( hHeap,
        GMEM_MOVEABLE | GMEM_ZEROINIT, size = (DWORD) sizeof(WININFO)
            + lstrlen(lpszNode) + 1
            + lstrlen(lpszApp) + 1
            + lstrlen(lpszTopic) + 1
            + lstrlen(lpszClient) + 1 );
    if( lpWinInfo )  {
        SetWindowLongPtr( hWndDDE, 0, (LONG_PTR) lpWinInfo );
        lpWinInfo->szUserName[0]        = '\0';
        lpWinInfo->szDomainName[0]      = '\0';
        lpWinInfo->szPassword[0]        = '\0';
        lpWinInfo->bWin16Connection     = FALSE;
        lpWinInfo->hWndDDE              = hWndDDE;
        lpWinInfo->lpSecurityKeyRcvd    = NULL;
        lpWinInfo->sizeSecurityKeyRcvd  = 0;
        lpWinInfo->nInitNACK            = 0;
        lpWinInfo->qDDEIncomingCmd      = DDEQAlloc();
        lpWinInfo->qDDEOutgoingCmd      = DDEQAlloc();
        if( (lpWinInfo->qDDEIncomingCmd == 0)
            || (lpWinInfo->qDDEOutgoingCmd == 0) )  {
            ok = FALSE;
        }

        /* copy in app, topic and client names */
        lstrcpyn( lpWinInfo->data, lpszApp, lstrlen(lpszApp) + 1);
        lpWinInfo->offsAppName =
            (WORD)((LPSTR)&lpWinInfo->data[0] - (LPSTR)lpWinInfo);

        lpWinInfo->offsNodeName = lpWinInfo->offsAppName +
            lstrlen(lpszApp) + 1;
        lstrcpyn( ((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName,
            lpszNode, lstrlen(lpszNode)+1);

        lpWinInfo->offsTopicName = lpWinInfo->offsNodeName +
            lstrlen(lpszNode) + 1;
        lstrcpyn( ((LPSTR)lpWinInfo) + lpWinInfo->offsTopicName,
            lpszTopic, lstrlen(lpszTopic)+1);

        lpWinInfo->offsClientName = lpWinInfo->offsTopicName +
            lstrlen(lpszTopic) + 1;
        lstrcpyn( ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
            lpszClient, lstrlen(lpszClient)+1);

        /* assure that we have enough memory for the terminate packet */
        lpWinInfo->lpDdePktTerminate = (LPDDEPKT) HeapAllocPtr( hHeap,
            GMEM_MOVEABLE, (DWORD) sizeof(DDEPKTTERM) );
        if( !lpWinInfo->lpDdePktTerminate )  {
            ok = FALSE;
        }
    }

    if( !ok )  {
        if( lpWinInfo )  {
            if( lpWinInfo->qDDEIncomingCmd )  {
                DDEQFree( lpWinInfo->qDDEIncomingCmd );
                lpWinInfo->qDDEIncomingCmd = 0;
            }
            if( lpWinInfo->qDDEOutgoingCmd )  {
                DDEQFree( lpWinInfo->qDDEOutgoingCmd );
                lpWinInfo->qDDEOutgoingCmd = 0;
            }
            if( lpWinInfo->hMemWaitInitQueue )  {
                GlobalFree( lpWinInfo->hMemWaitInitQueue );
                lpWinInfo->hMemWaitInitQueue = 0;
            }
            if( lpWinInfo->lpDdePktTerminate )  {
                HeapFreePtr( lpWinInfo->lpDdePktTerminate );
                lpWinInfo->lpDdePktTerminate = NULL;
            }
            HeapFreePtr( lpWinInfo );
            lpWinInfo = NULL;
            SetWindowLongPtr( hWndDDE, 0, 0 );
        }
    }

    return( lpWinInfo );
}



VOID
FAR PASCAL
IpcFillInConnInfo(
        HIPC            hIpc,
        LPCONNENUM_CMR  lpConnEnum,
        LPSTR           lpDataStart,
        LPWORD          lpcFromBeginning,
        LPWORD          lpcFromEnd
)
{
    HWND                hWndDDE;
    LPWININFO           lpWinInfo;
    LPSTR               lpszAppName;
    LPSTR               lpszTopicName;
    LPDDECONNINFO       lpDdeConnInfo;
    WORD                wStringSize;
    LPSTR               lpszString;

    if( hIpc )  {
        hWndDDE = (HWND) hIpc;
        if( hWndDDE && IsWindow( hWndDDE ) )  {
            lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );

            lpConnEnum->nItems++;
            lpszAppName = ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName;
            lpszTopicName = ((LPSTR)lpWinInfo) + lpWinInfo->offsTopicName;
            lpConnEnum->cbTotalAvailable += sizeof(DDECONNINFO);
            wStringSize = lstrlen(lpszTopicName) + 1;
            if( !IsShare(lpszAppName) )  {
                wStringSize += lstrlen(lpszAppName) + 1;
            }
            lpConnEnum->cbTotalAvailable += wStringSize;
            if( lpConnEnum->lReturnCode == NDDE_NO_ERROR )  {
                if( ((int)(wStringSize+sizeof(DDECONNINFO))) >
                    (*lpcFromEnd - *lpcFromBeginning) )  {
                    lpConnEnum->lReturnCode = NDDE_BUF_TOO_SMALL;
                } else {
                    /* there is room! */
                    lpDdeConnInfo = (LPDDECONNINFO)
                        ((LPSTR)lpDataStart + *lpcFromBeginning);
                    *lpcFromBeginning += sizeof(DDECONNINFO);
                    *lpcFromEnd -= wStringSize;
                    lpszString = ((LPSTR)lpDataStart + *lpcFromEnd);
                    lpDdeConnInfo->ddeconn_Status = lpWinInfo->wState;
                    lpDdeConnInfo->ddeconn_ShareName =
                        (LPSTR)(LONG_PTR)*lpcFromEnd;
                    *lpszString = '\0';
                    if( !IsShare( lpszAppName ) )  {
                        lstrcpy( lpszString, lpszAppName );
                        lstrcat( lpszString, "|" );
                    }
                    lstrcat( lpszString, lpszTopicName );
                }
            }
        }
    }
}

#if DBG

VOID
FAR PASCAL
debug_srv_client(
    HWND        hWndDDE,
    LPWININFO   lpWinInfo)
{
    DPRINTF(( "  %04X: %Fp \\\\%Fs\\%Fs -> \\\\%Fs\\%Fs|%Fs",
        hWndDDE, lpWinInfo,
        lpWinInfo->bClientSideOfNet ?
            (LPSTR)ourNodeName : ((LPSTR)lpWinInfo) +
            lpWinInfo->offsNodeName,
        ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
        lpWinInfo->bClientSideOfNet ?
            ((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName :
            (LPSTR)ourNodeName,
        ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName,
        ((LPSTR)lpWinInfo) + lpWinInfo->offsTopicName ));
}



VOID
FAR PASCAL
DebugDdeIntfState( void )
{
    LPWININFO   lpWinInfo;
    HWND        hWndDDE;

    EnterCrit();
    DPRINTF(( "DDEINTF State [Normal Windows]:" ));
    hWndDDE = hWndDDEHead;
    while( hWndDDE )  {
        assert( IsWindow(hWndDDE) );
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );
        assert( lpWinInfo );
        debug_srv_client(hWndDDE, lpWinInfo);
        DPRINTF(( "  bClientSideOfNet:      %d\n"
                  "  bServerSideOfNet:      %d\n"
                  "  bOnWindowList:         %d\n"
                  "  bOnTermWindowList:     %d\n"
                  "  bSentTerminateNet:     %d\n"
                  "  bRcvdTerminateNet:     %d\n"
                  "  bSentTerminateLocally: %d\n"
                  "  bRcvdTerminateLocally: %d\n"
                  "  bInitiating:           %d\n"
                  "  nExtraInitiateAcks:    %d\n"
                  "  hWndDDE:               %04X\n"
                  "  hWndDDELocal:          %04X\n"
                  "  hDder:                 %Fp\n"
                  "  wState:                %d\n"
                  "  hWndPrev:              %04X\n"
                  "  hWndNext:              %04X\n"
                  "  dwSent:                %ld\n"
                  "  dwRcvd:                %ld\n"
                  ,
                lpWinInfo->bClientSideOfNet,
                lpWinInfo->bServerSideOfNet,
                lpWinInfo->bOnWindowList,
                lpWinInfo->bOnTermWindowList,
                lpWinInfo->bSentTerminateNet,
                lpWinInfo->bRcvdTerminateNet,
                lpWinInfo->bSentTerminateLocally,
                lpWinInfo->bRcvdTerminateLocally,
                lpWinInfo->bInitiating,
                lpWinInfo->nExtraInitiateAcks,
                lpWinInfo->hWndDDE,
                lpWinInfo->hWndDDELocal,
                lpWinInfo->hDder,
                lpWinInfo->wState,
                lpWinInfo->hWndPrev,
                lpWinInfo->hWndNext,
                lpWinInfo->dwSent,
                lpWinInfo->dwRcvd ));
        hWndDDE = lpWinInfo->hWndNext;
    }

    DPRINTF(( "DDEINTF State [Terminating Windows]:" ));
    hWndDDE = hWndDDEHeadTerminating;
    while( hWndDDE )  {
        assert( IsWindow(hWndDDE) );
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );
        assert( lpWinInfo );
        DPRINTF(( "  %04X: %Fp \\\\%Fs\\%Fs -> \\\\%Fs\\%Fs|%Fs",
            hWndDDE, lpWinInfo,
            lpWinInfo->bClientSideOfNet ?
                (LPSTR)ourNodeName : ((LPSTR)lpWinInfo) +
                lpWinInfo->offsNodeName,
            ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
            lpWinInfo->bClientSideOfNet ?
                ((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName :
                (LPSTR)ourNodeName,
            ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName,
            ((LPSTR)lpWinInfo) + lpWinInfo->offsTopicName ));

        DPRINTF(( "    %d %d %d %d %d %d %d %d %d %d %04X %04X %Fp %d %04X %04X %ld %ld",
            lpWinInfo->bClientSideOfNet,
            lpWinInfo->bServerSideOfNet,
            lpWinInfo->bOnWindowList,
            lpWinInfo->bOnTermWindowList,
            lpWinInfo->bSentTerminateNet,
            lpWinInfo->bRcvdTerminateNet,
            lpWinInfo->bSentTerminateLocally,
            lpWinInfo->bRcvdTerminateLocally,
            lpWinInfo->bInitiating,
            lpWinInfo->nExtraInitiateAcks,
            lpWinInfo->hWndDDE,
            lpWinInfo->hWndDDELocal,
            lpWinInfo->hDder,
            lpWinInfo->wState,
            lpWinInfo->hWndPrev,
            lpWinInfo->hWndNext,
            lpWinInfo->dwSent,
            lpWinInfo->dwRcvd ));
        hWndDDE = lpWinInfo->hWndNext;
    }
    LeaveCrit();
}
#endif // DBG



LPBYTE
GetInitPktPassword(
    LPDDEPKTINIT    lpDdePktInit )
{
    LPDDEPKTSEC     lpSecurity;
    LPBYTE          lpPasswd;
    DDEPKTSEC       secAligned;

    lpSecurity = (LPDDEPKTSEC) GetStringOffset(lpDdePktInit,
        lpDdePktInit->dp_init_offsPassword);
    hmemcpy( (LPVOID)&secAligned, (LPVOID)lpSecurity, sizeof(DDEPKTSEC) );

    lpPasswd = (LPBYTE) GetStringOffset( lpSecurity,
                 secAligned.dp_sec_offsPassword);
    return lpPasswd;
}



PQOS
GetInitPktQos(
    LPDDEPKTINIT    lpDdePktInit,
    PQOS            pQosOut )
{
    LPDDEPKTSEC     lpSecurity;
    PQOS            pQos = (PQOS) NULL;
    DDEPKTSEC       secAligned;

    if (lpDdePktInit->dp_init_sizePassword) {
        lpSecurity = (LPDDEPKTSEC) GetStringOffset(lpDdePktInit,
            lpDdePktInit->dp_init_offsPassword);
        hmemcpy( (LPVOID)&secAligned, (LPVOID)lpSecurity, sizeof(DDEPKTSEC) );

        if( secAligned.dp_sec_offsUserName == sizeof(DDEPKTSEC) )  {
            pQos = (PQOS) GetStringOffset( lpSecurity,
                secAligned.dp_sec_offsQos);

            /*
             * If there is no password, the qos may be garbage.
             */
            if (secAligned.dp_sec_sizePassword == 0) {
                if ((PBYTE)pQos > ((PBYTE)lpDdePktInit +
                        lpDdePktInit->dp_init_ddePktCmn.dc_ddePkt.dp_size))
                    return NULL;
            }

            hmemcpy( (LPVOID)pQosOut, (LPVOID)pQos, sizeof(QOS));
        }
    }
    return(pQos);
}



LPBYTE
GetInitPktUser(
    LPDDEPKTINIT    lpDdePktInit )
{
    LPDDEPKTSEC     lpSecurity;
    LPBYTE          lpUser;
    DDEPKTSEC       secAligned;

    lpSecurity = (LPDDEPKTSEC) GetStringOffset(lpDdePktInit,
        lpDdePktInit->dp_init_offsPassword);
    hmemcpy( (LPVOID)&secAligned, (LPVOID)lpSecurity, sizeof(DDEPKTSEC) );

    lpUser = (LPBYTE) GetStringOffset( lpSecurity,
        secAligned.dp_sec_offsUserName);
    return lpUser;
}



LPBYTE
GetInitPktDomain(
    LPDDEPKTINIT    lpDdePktInit )
{
    LPDDEPKTSEC     lpSecurity;
    LPBYTE          lpDomain;
    DDEPKTSEC       secAligned;

    lpSecurity = (LPDDEPKTSEC) GetStringOffset(lpDdePktInit,
        lpDdePktInit->dp_init_offsPassword);
    hmemcpy( (LPVOID)&secAligned, (LPVOID)lpSecurity, sizeof(DDEPKTSEC) );

    lpDomain = (LPBYTE) GetStringOffset( lpSecurity,
        secAligned.dp_sec_offsDomainName);
    return lpDomain;
}



WORD
GetInitPktPasswordSize(
    LPDDEPKTINIT    lpDdePktInit )
{
    LPDDEPKTSEC     lpSecurity;
    DDEPKTSEC       secAligned;

    lpSecurity = (LPDDEPKTSEC) GetStringOffset(lpDdePktInit,
        lpDdePktInit->dp_init_offsPassword);
    hmemcpy( (LPVOID)&secAligned, (LPVOID)lpSecurity, sizeof(DDEPKTSEC) );
    return( secAligned.dp_sec_sizePassword );
}



void
GlobalFreehData(
    HANDLE  hData )
{
    DWORD           dwErr;
    LPBYTE          lpData;
    HANDLE         *lphIndirect;
    HANDLE          hIndirect;
    LPMETAFILEPICT  lpMetafilePict;
    WORD            cfFormat;


    lpData = (LPBYTE) GlobalLock(hData);
    if (lpData == NULL) {
        dwErr = GetLastError();
        DPRINTF(("Unable to lock down hData on a GlobalFreehData(): %d", dwErr));
        return;
    }
    cfFormat = (WORD)((LPDDELN)lpData)->cfFormat;
    switch (cfFormat) {
        case CF_METAFILEPICT:
            lphIndirect = (HANDLE *) (lpData + sizeof(DDELN));
            hIndirect = *lphIndirect;
            lpMetafilePict = (LPMETAFILEPICT) GlobalLock(hIndirect);
            if (lpMetafilePict == NULL) {
                dwErr = GetLastError();
                DPRINTF(("Unable to lock down hMetaFilePict on a GlobalFreehData(): %d", dwErr));

            } else {
                DeleteMetaFile(lpMetafilePict->hMF);
                GlobalUnlock(hIndirect);
                GlobalFree(hIndirect);
            }
            break;
        case CF_DIB:
            lphIndirect = (HANDLE *) (lpData + sizeof(DDELN));
            hIndirect = *lphIndirect;
            GlobalFree(hIndirect);
            break;
        case CF_PALETTE:
        case CF_BITMAP:
            lphIndirect = (HANDLE *) (lpData + sizeof(DDELN));
            hIndirect = *lphIndirect;
            if (!DeleteObject(hIndirect)) {
                dwErr = GetLastError();
                DPRINTF(("Unable to delete object GlobalFreehData(): %d", dwErr));
            }
            break;
        case CF_ENHMETAFILE:
            lphIndirect = (HANDLE *) (lpData + sizeof(DDELN));
            hIndirect = *lphIndirect;
            DeleteEnhMetaFile(hIndirect);
            break;
        default:
            break;
    }
    GlobalUnlock(hData);
    GlobalFree(hData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\netdde.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NETDDE.C;3  9-Feb-93,17:59:36  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    <string.h>
#include    "host.h"
#include    <windows.h>
#include    <hardware.h>
#include    <malloc.h>
#include    "commdlg.h"
#include    "netdde.h"
#include    "netintf.h"
#include    "ddepkt.h"
#include    "ddepkts.h"
#include    "dde.h"
#include    "ipc.h"
#include    "debug.h"
#include    "netpkt.h"
#include    "tmpbuf.h"
#include    "tmpbufc.h"
#include    "pktz.h"
#include    "router.h"
#include    "dder.h"
#include    "hexdump.h"
#include    "ddeintf.h"
#include    "dbgdde.h"
#include    "ddeq.h"
#include    "timer.h"
#include    "proflspt.h"
#include    "security.h"
#include    "netbasic.h"
#include    "nddeapi.h"
#include    "winmsg.h"
#include    "seckey.h"
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "netddesh.h"
#include    "nddeagnt.h"
#include    "critsec.h"
#include    <strsafe.h>

#define DEFAULT_START_APP       TRUE
#define DEFAULT_SECURITY_TYPE   NT_SECURITY_TYPE
#define AGING_TIME              3600L       /* 3600 seconds, or 60 minutes */
#define ONE_SECOND              1000L       /* 1 second */
#define ONE_MINUTE             60000L       /* 60 seconds, or 1 minute */


/* variables for real environment */
BOOL    bNetddeClosed           =  FALSE;
BOOL    bNDDEPaused             =  FALSE;
DWORD   dflt_timeoutRcvConnCmd  =  ONE_MINUTE;
DWORD   dflt_timeoutRcvConnRsp  =  ONE_MINUTE;
DWORD   dflt_timeoutMemoryPause =  5*ONE_SECOND;
DWORD   dflt_timeoutSendRsp     =  10*ONE_SECOND;
DWORD   dflt_timeoutKeepAlive   =  10*ONE_SECOND;
DWORD   dflt_timeoutXmtStuck    =  2*ONE_MINUTE;

WORD    dflt_wMaxNoResponse     = 3;
WORD    dflt_wMaxXmtErr         = 3;
WORD    dflt_wMaxMemErr         = 3;
HDESK   ghdesk = NULL;


typedef struct {
    BOOL                bOk;
    NIPTRS              niPtrs;
    BOOL                bMapping;
    BOOL                bParamsOK;
    HANDLE              hLibrary;
} NI;
typedef NI *PNI;


NI      niInf[ MAX_NETINTFS ];
int     nNi=0;      /* number of table entries consumed */
int     nNiOk=0;    /* number of alive interface */

PTHREADDATA ptdHead;

DWORD tlsThreadData = 0xffffffff;

CRITICAL_SECTION csNetDde;
BOOL bCritSecInitialized=FALSE;

VOID NetDDEThread(PTHREADDATA ptd);
VOID PipeThread(PVOID pvoid);

static SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;


// .ini strings
char    szNetddeIni[]           =       "netdde.ini";
char    szGeneral[]             =       "General";
char    szInterfaceFmt[]        =       "Interface%d";
char    szInterfaces[]          =       "Interfaces";


// global strings
char    szLastConnect[ MAX_NODE_NAME+1 ];
char    ourNodeName[ MAX_NODE_NAME+1 ];
char    szInitiatingNode[ MAX_NODE_NAME+1 ];
char    szInitiatingApp[ 256 ];
char    szServerName[ 132 ];
LPSTR   lpszServer;
BOOL    bInitiating                 = FALSE;    // Protect with CritSec
BOOL    bDefaultAllowConversation   = TRUE;
BOOL    bDefaultStartApp            = DEFAULT_START_APP;
BOOL    bDefaultAdvisePermitted     = TRUE;
BOOL    bDefaultRequestPermitted    = TRUE;
BOOL    bDefaultPokePermitted       = TRUE;
BOOL    bDefaultExecutePermitted    = TRUE;
BOOL    bDefaultRouteDisconnect     = TRUE;
BOOL    bLogPermissionViolations    = TRUE;
BOOL    bLogExecFailures            = TRUE;
BOOL    bLogRetries                 = TRUE;
int     nDefaultRouteDisconnectTime = 30;
BOOL    bDefaultConnDisconnect      = TRUE;
int     nDefaultConnDisconnectTime  = 30;

char    szDefaultRoute[ MAX_ROUTE_INFO+1 ];


#if DBG
BOOL    bDebugMenu      = FALSE;
BOOL    bDebugInfo      = FALSE;
BOOL    bDebugErrors    = FALSE;
BOOL    bDebugDdePkts   = FALSE;
BOOL    bDumpTokens     = FALSE;
extern  BOOL    bDebugDDE;
extern  char    szDebugFileName[];
#endif

DWORD   dwSecurityType      = DEFAULT_SECURITY_TYPE;
DWORD   dwSecKeyAgeLimit    = AGING_TIME;


/*
        Event Logger Control Variables
*/
BOOL    bNDDELogInfo            = FALSE;
BOOL    bNDDELogWarnings        = FALSE;
BOOL    bNDDELogErrors          = TRUE;


WORD    cfPrinterPicture;

char    szAgentAlive[] =    "NetddeAgentAlive";
UINT    wMsgNddeAgntAlive;
char    szAgentWakeUp[] =    "NetddeAgentWakeUp";
UINT    wMsgNddeAgntWakeUp;
char    szAgentExecRtn[] =  "NetddeAgentExecRtn";
UINT    wMsgNddeAgntExecRtn;
char    szAgentDying[] =    "NetddeAgentDying";
UINT    wMsgNddeAgntDying;

UINT    wMsgInitiateAckBack;
UINT    wMsgNetddeAlive;
UINT    wMsgGetOurNodeName;
UINT    wMsgGetClientInfo;
#ifdef  ENUM
UINT    wMsgSessionEnum;
UINT    wMsgConnectionEnum;
#endif
UINT    wMsgSessionClose;

UINT    wMsgIpcInit;
UINT    wMsgIpcXmit;
UINT    wMsgDoTerminate;

DWORD   dwSerialNumber;
WORD    wClipFmtInTouchDDE;
HANDLE  hInst;
HANDLE  hThreadPipe = NULL;

char    szAppName[] = NETDDE_TITLE;


extern  HWND    hWndDDEHead;
extern  HANDLE  hNDDEServDoneEvent;
extern  VOID    NDDEServCtrlHandler (DWORD dwCtrlCode);

VOID    FAR PASCAL ServiceInitiates( void );
VOID    RouteSelectName( void );
BOOL    FAR PASCAL DeleteNetIntf( HWND hWnd, LPSTR lpszIntfName );
VOID    FAR PASCAL MakeHelpPathName( char *szFileName, int nMax );
BOOL    FAR PASCAL DeleteNetIntfFromNetDdeIni( int nToDelete );
FARPROC FAR PASCAL XGetProcAddress( LPSTR lpszDllName, HANDLE hLibrary,
                        LPSTR lpszFuncName );
BOOL    FAR PASCAL GetNiPtrs( HANDLE FAR *lphLibrary, LPSTR lpszDllName,
                        LPNIPTRS lpNiPtrs );
BOOL    FAR PASCAL NetIntfConfigured( LPSTR lpszName );
BOOL    FAR PASCAL RouterCloseByCookie( LPSTR lpszName, DWORD_PTR dwCookie );
#ifdef  ENUM
VOID    FAR PASCAL RouterEnumConnectionsForApi( LPCONNENUM_CMR lpConnEnum );
int     FAR PASCAL RouterCount( void );
VOID    FAR PASCAL RouterFillInEnum( LPSTR lpBuffer, DWORD cBufSize );
#endif
BOOL    CtrlHandler(DWORD);

#if DBG
VOID    FAR PASCAL DebugDdeIntfState( void );
VOID    FAR PASCAL DebugDderState( void );
VOID    FAR PASCAL DebugRouterState( void );
VOID    FAR PASCAL DebugPktzState( void );
#endif

extern HANDLE hNDDEServStartedEvent;

BOOL    FAR PASCAL InitializeInterface( HWND hWnd, PNI pNi, LPSTR lpszDllName, int nNi );


/*
    Global Start-Up Arguments .. saved by service launcher
*/
HANDLE  hInstance;          /* current instance             */
LPSTR   lpCmdLine;          /* command line                 */
int     nCmdShow;           /* show-window type (open/icon) */



//****************************************************************
//    NetDDE WinMain()
//****************************************************************
VOID   __stdcall
NddeMain(DWORD nThreadInput)
{
    DWORD ThreadId;
    PTHREADDATA ptd;

    TRACEINIT((szT, "NddeMain: Entering."));

    if (bNetddeClosed == FALSE) {

        /*
         * Do this section ONLY on first time startup of NetDDE.
         */

        if( !InitApplication( hInstance ) ) {
            TRACEINIT((szT, "NddeMain: Error1 Leaving."));
            goto Cleanup;
        }

        /* Perform initializations that apply to a specific instance */

        if( !InitInstance( hInstance, nCmdShow, lpCmdLine ) ) {
            TRACEINIT((szT, "NddeMain: Error2 Leaving."));
            goto Cleanup;
        }

        /*
         * make this process shutdown near last.
         */
        SetProcessShutdownParameters(0xf0, 0);

        /*
         * set us up so we can be notified of logoffs and shutdowns.
         */
        TRACEINIT((szT, "Setting console control handler."));
        if (!SetConsoleCtrlHandler(CtrlHandler, TRUE)) {
            TRACEINIT((szT, "NddeMain: Error4 Leaving."));
            goto Cleanup;
        }
    } else {

        /*
         * Do this section ONLY on subsequent non-first-time startups.
         */
        bNetddeClosed = FALSE;
    }


    /*
     * This gets done on ALL NETDDE.EXE startups.  the netdde service may be stopped and
     * restarted without netdde.exe exiting.  and this function will be called in that case.
     *  Do not reinitialize the critical section in that case.
     */


   if ( !bCritSecInitialized )
   {
       __try
       {
           InitializeCriticalSection(&csNetDde);
       }
       __except(EXCEPTION_EXECUTE_HANDLER)
       {
          TRACEINIT((szT, "NddeMain: Error 6 InitializeCriticalSection excepted"));
          goto Cleanup;
       }

       bCritSecInitialized = TRUE;
    }

    tlsThreadData = TlsAlloc();
    if (tlsThreadData == 0xffffffff) {
        TRACEINIT((szT, "NddeMain: Error3 Leaving"));
        goto Cleanup;
    }

    /*
     * Create the pipe thread suspended.  This will ensure that the
     * net interfaces will be initialized with the main window.
     */
    ghdesk = GetThreadDesktop(GetCurrentThreadId());
    TRACEINIT((szT, "Creating a pipe thread."));

    /*
     * Check to see if the pipe thread is not already running
     */
    hThreadPipe = CreateThread(NULL, 0,
            (LPTHREAD_START_ROUTINE)PipeThread,
            NULL,
            CREATE_SUSPENDED, &ThreadId);
    if (hThreadPipe == NULL) {
        TRACEINIT((szT, "NddeMain: Error5 Leaving."));
        goto Cleanup;
    }
    TRACEINIT((szT, "Pipe thread created."));

    ptd = LocalAlloc(LPTR, sizeof(THREADDATA));
    if (ptd == NULL) {
        MEMERROR();
    } else {
        ptd->dwThreadId = GetCurrentThreadId();
        NetDDEThread(ptd);
    }

Cleanup:
    if (hNDDEServStartedEvent) {
        SetEvent(hNDDEServStartedEvent);   // let root thread run.
    }

    TRACEINIT((szT, "NddeMain: Leaving"));
}


/*
 * Spawns a NetDDE listening thread and window on the given
 * window station and desktop.  Returns the hwndDDE created
 * if any.  If a NetDDE window already exists on the given
 * window station and desktop, that window is returned.
 */
HWND SpawnNetDDEThread(
LPWSTR szWinSta,
LPWSTR szDesktop,
HANDLE hPipe)
{
    HWND hwndDDE = NULL;
    HANDLE hThread;
    PTHREADDATA ptd;
    HWINSTA hwinstaSave;
    HDESK hdeskSave;

    TRACEINIT((szT,
            "SpawnNetDDEThread: winsta=%ws, desktop=%ws.",
            szWinSta, szDesktop));

    ptd = LocalAlloc(LPTR, sizeof(THREADDATA));
    if (ptd == NULL) {
        MEMERROR();
        return(NULL);
    }

    /*
     * Attempt to open the windowstation
     */
    ptd->hwinsta = OpenWindowStationW(szWinSta, FALSE,
            WINSTA_READATTRIBUTES | WINSTA_ACCESSCLIPBOARD |
            WINSTA_ACCESSGLOBALATOMS | STANDARD_RIGHTS_REQUIRED);
    if (ptd->hwinsta == NULL) {
        TRACEINIT((szT, "SpawnNetDDEThread: OpenWindowStation failed."));
        return(NULL);
    }

    /*
     * Switch windowstations.
     */
    hwinstaSave = GetProcessWindowStation();
    SetProcessWindowStation(ptd->hwinsta);

    /*
     * Attempt to open the desktop
     */
    ptd->hdesk = OpenDesktopW(szDesktop, 0, FALSE,
            DESKTOP_READOBJECTS | DESKTOP_CREATEWINDOW |
            DESKTOP_CREATEMENU | DESKTOP_WRITEOBJECTS |
            STANDARD_RIGHTS_REQUIRED);
    if (ptd->hdesk == NULL) {
        TRACEINIT((szT, "SpawnNetDDEThread: OpenDesktop failed."));
        SetProcessWindowStation(hwinstaSave);
        CloseWindowStation(ptd->hwinsta);
        return(NULL);
    }

    /*
     * Make sure we only create one thread per desktop.
     */
    hdeskSave = GetThreadDesktop(GetCurrentThreadId());
    SetThreadDesktop(ptd->hdesk);

    hwndDDE = FindWindow(NETDDE_CLASS, NETDDE_TITLE);

    SetThreadDesktop(hdeskSave);
    SetProcessWindowStation(hwinstaSave);

    if (hwndDDE != NULL) {
        TRACEINIT((szT, "SpawnNetDDEThread: hwndDDE %x already exists.", hwndDDE));
        return(hwndDDE);
    }

    /*
     * Create a synchronization event and create the dde thread.
     */
    ptd->heventReady = CreateEvent(NULL, FALSE, FALSE, NULL) ;

    hThread = CreateThread(NULL, 0,
            (LPTHREAD_START_ROUTINE)NetDDEThread,
            ptd,
            0, &ptd->dwThreadId);
    if (hThread == NULL) {
        CloseWindowStation(ptd->hwinsta);
        CloseDesktop(ptd->hdesk);
        CloseHandle(ptd->heventReady);
        LocalFree(ptd);
        return(NULL);
    }

    CloseHandle(hThread);

    WaitForSingleObject(ptd->heventReady, INFINITE);
    CloseHandle(ptd->heventReady);
    hwndDDE = ptd->hwndDDE;

    TRACEINIT((szT, "SpawnNetDDEThread: hwndDDE=%x.", hwndDDE));
    return(hwndDDE);
}



VOID PipeThread(
    PVOID pvoid)
{
    SECURITY_ATTRIBUTES sa;
    HANDLE hPipe = NULL;
    DWORD cbRead;
    NETDDE_PIPE_MESSAGE nameinfo;
    PSID psid;
    PACL pdacl;
    DWORD dwResult;
    OVERLAPPED  overlapped;
    HANDLE heventArray[2];


    /* Create named pipe to communicate with Winlogon */

    TRACEINIT((szT, "PipeThread: Starting."));
    /*
     * Create the manual reset event for the OVERLAPPED structure.
     */
    overlapped.Internal =
    overlapped.InternalHigh =
    overlapped.Offset =
    overlapped.OffsetHigh = 0;
    overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL) ;

    if (overlapped.hEvent == NULL) {
        TRACEINIT((szT, "PipeThread: Error3 Leaving."));
        goto Cleanup;
    }

    /*
     * Initialize the array of events on which to wait.
     */
    heventArray[0] = hNDDEServDoneEvent;
    heventArray[1] = overlapped.hEvent;

    /*
     * Setup the pipe's security attributes
     */
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = FALSE;

    psid = LocalAlloc(LPTR, GetSidLengthRequired( 1 ) );
    if (psid == NULL) {
        MEMERROR();
        goto Cleanup;
    }

    InitializeSid( psid, &WorldSidAuthority, 1 );
    *(GetSidSubAuthority( psid, 0 )) = SECURITY_WORLD_RID;
    sa.lpSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR,
            SECURITY_DESCRIPTOR_MIN_LENGTH +
            (ULONG)sizeof(ACL) +
            (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
            GetLengthSid( psid ));

    if (sa.lpSecurityDescriptor == NULL) {
        MEMERROR();
        LocalFree(psid);
        TRACEINIT((szT, "PipeThread: Error Leaving."));
        goto Cleanup;
    }

    InitializeSecurityDescriptor(sa.lpSecurityDescriptor,
            SECURITY_DESCRIPTOR_REVISION);
    pdacl = (PACL)((PCHAR)sa.lpSecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);

    InitializeAcl(pdacl, (ULONG)sizeof(ACL) +
            (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
            GetLengthSid( psid ), ACL_REVISION2);
    AddAccessAllowedAce(pdacl, ACL_REVISION2,
        GENERIC_READ | GENERIC_WRITE, psid);
    SetSecurityDescriptorDacl(sa.lpSecurityDescriptor, TRUE, pdacl, FALSE);

    /*
     * Create the pipe.
     */
    hPipe = CreateNamedPipeW(NETDDE_PIPE,
            PIPE_ACCESS_DUPLEX | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_OVERLAPPED,
            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
            1, 1, 1, 1000, &sa);
    LocalFree(psid);
    LocalFree(sa.lpSecurityDescriptor);

    if (hPipe == INVALID_HANDLE_VALUE) {
        TRACEINIT((szT, "PipeThread: Error2 Leaving."));
        goto Cleanup;
    }

    /*
     * always create a NetDDE thread/window on the default desktop of
     * WINSTA0.
     */
    SpawnNetDDEThread(L"WinSta0", L"Default", hPipe);

    /*
     * wait for connection requests from USER for any other spawns.
     */
    while (TRUE) {
        /*
         * Wait for somebody to connect to our pipe.
         */
        ConnectNamedPipe(hPipe, &overlapped);

        switch (GetLastError()) {
        case ERROR_PIPE_CONNECTED:
            /*
             * This error just means that a pipe connected before we
             * made our call to ConnectNamedPipe.  All we need to do
             * is set our overlapped event so we know that a client
             * is already connected.
             */
            SetEvent(overlapped.hEvent);
            TRACEINIT((szT, "PipeThread: ConnectNamePipe = ERROR_PIPE_CONNECTED"));
            break;

        case ERROR_IO_PENDING:
            /*
             * Nothing to do yet, so fall into out WaitForMultipleObjects()
             * code below.
             */
            TRACEINIT((szT, "PipeThread: ConnectNamePipe = ERROR_IO_PENDING"));
            break;

        default:
            /*
             * A real error ocurred!  Write this error to the Event Log and
             * shut down the NDDE service.
             */
            TRACEINIT((szT, "PipeThread: ConnectNamePipe = error %d", GetLastError()));
            NDDEServCtrlHandler( SERVICE_CONTROL_STOP );
            goto Cleanup;
        }

        /*
         * Wait for NDDE service to stop or a connect on the DDE pipe.  We
         * put the service stop handle first to give a STOP priority over
         * a connect.
         */
        TRACEINIT((szT, "PipeThread: Waiting for multiple objects."));
        dwResult = WaitForMultipleObjects(2, heventArray, FALSE, INFINITE);

        switch (dwResult) {
        case WAIT_OBJECT_0:
            TRACEINIT((szT, "PipeThread: hNDDEServDoneEvent"));
            goto Cleanup;

        case WAIT_OBJECT_0 + 1:
            /*
             * A client has connected, establish a DDE connection.
             */
            TRACEINIT((szT, "PipeThread: client connect"));
            while (ReadFile(hPipe, &nameinfo, sizeof(nameinfo), &cbRead, NULL)) {
                HWND hwndDDE;

                hwndDDE = SpawnNetDDEThread(nameinfo.awchNames,
                        &nameinfo.awchNames[nameinfo.dwOffsetDesktop],
                        hPipe);
                TRACEINIT((szT, "PipeThread: client gets hwnd=0x%X", hwndDDE));
                WriteFile(hPipe, &hwndDDE, sizeof(HWND), &cbRead, NULL);
            }
            TRACEINIT((szT, "PipeThread: DisconnectNamedPipe"));
            DisconnectNamedPipe(hPipe);
            break;

        default:
            /*
             * An error ocurred in WaitForMultiple objects.  We should log
             * the error and stop the NDDE service.
             */
            TRACEINIT((szT, "PipeThread: WFMO error = %d, %d", dwResult, GetLastError()));
            NDDEServCtrlHandler( SERVICE_CONTROL_STOP );
            goto Cleanup;
        }
    }

Cleanup:
    TRACEINIT((szT, "PipeThread: Cleanup overlapped.hEvent"));
    if (overlapped.hEvent) {
        CloseHandle(overlapped.hEvent);
    }

    TRACEINIT((szT, "PipeThread: clode hPipe"));
    if (hPipe) {
        CloseHandle(hPipe);
    }

    if (hNDDEServStartedEvent) {
        SetEvent(hNDDEServStartedEvent);   // let root thread run.
    }

    TRACEINIT((szT, "PipeThread: Leaving."));
}



BOOL
FAR PASCAL
InitApplication( HANDLE hInstance ) {   /* current instance             */

    WNDCLASS  wc;

    wc.style = CS_HREDRAW | CS_VREDRAW; /* Class style(s)                 */
    wc.lpfnWndProc = MainWndProc;       /* Function to retrieve msgs for  */
                                        /* windows of this class.         */
    wc.cbClsExtra = 0;                  /* No per-class extra data.       */
    wc.cbWndExtra = 0;                  /* No per-window extra data.      */
    wc.hInstance = hInstance;           /* Application that owns the class*/
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.hIcon = 0;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = "NetDDEMainWdw";   /* Name used to CreateWindow.     */

    return( RegisterClass( &wc ) );

}



/*
    Refresh NetDDE Configuration Variables
*/
void
RefreshNDDECfg(void)
{
    char    szDefaultLogFile[256] = "";

    /*
     * Load default security info
     */
    bDefaultAllowConversation = MyGetPrivateProfileInt( szGeneral,
        "InitAllow", TRUE, szNetddeIni );
    bDefaultStartApp = MyGetPrivateProfileInt( szGeneral,
        "StartApp", DEFAULT_START_APP, szNetddeIni );
    bDefaultAdvisePermitted = MyGetPrivateProfileInt( szGeneral,
        "DefaultAdvisePermitted", TRUE, szNetddeIni );
    bDefaultRequestPermitted = MyGetPrivateProfileInt( szGeneral,
        "DefaultRequestPermitted", TRUE, szNetddeIni );
    bDefaultPokePermitted = MyGetPrivateProfileInt( szGeneral,
        "DefaultPokePermitted", TRUE, szNetddeIni );
    bDefaultExecutePermitted = MyGetPrivateProfileInt( szGeneral,
        "DefaultExecutePermitted", TRUE, szNetddeIni );
    dwSecurityType = (DWORD)MyGetPrivateProfileInt( szGeneral,
        "SecurityType", DEFAULT_SECURITY_TYPE, szNetddeIni );

    /*
     * Determine what we're allowed to log in the event logger
     */
    bNDDELogInfo = MyGetPrivateProfileInt( szGeneral,
        "NDDELogInfo", FALSE, szNetddeIni );
    bNDDELogWarnings = MyGetPrivateProfileInt( szGeneral,
        "NDDELogWarnings", FALSE, szNetddeIni );
    bNDDELogErrors = MyGetPrivateProfileInt( szGeneral,
        "NDDELogErrors", TRUE, szNetddeIni );

    /*
     * Determine what we are going to dump to private log
     */
#if DBG
    MyGetPrivateProfileString( szGeneral, "DefaultLogFile", "netdde.log",
        szDefaultLogFile, sizeof(szDefaultLogFile), szNetddeIni );
    if (lstrlen(szDefaultLogFile) > 0) {
        StringCchCopy(szDebugFileName, 256, szDefaultLogFile);
    }
    bDebugInfo = MyGetPrivateProfileInt( szGeneral,
        "DebugInfo", FALSE, szNetddeIni );
    bDebugErrors = MyGetPrivateProfileInt( szGeneral,
        "DebugErrors", FALSE, szNetddeIni );
    bDebugDdePkts = MyGetPrivateProfileInt( szGeneral,
        "DebugDdePkts", FALSE, szNetddeIni );
    bDumpTokens = MyGetPrivateProfileInt( szGeneral,
        "DumpTokens", FALSE, szNetddeIni );
    bDebugDDE = MyGetPrivateProfileInt( szGeneral,
        "DebugDDEMessages", FALSE, szNetddeIni );
#endif

    bLogPermissionViolations = MyGetPrivateProfileInt( szGeneral,
        "LogPermissionViolations", TRUE, szNetddeIni );
    bLogExecFailures = MyGetPrivateProfileInt( szGeneral,
        "LogExecFailures", TRUE, szNetddeIni );
    bLogRetries = MyGetPrivateProfileInt( szGeneral,
        "LogRetries", TRUE, szNetddeIni );

    bDefaultRouteDisconnect = MyGetPrivateProfileInt( szGeneral,
        "DefaultRouteDisconnect", TRUE, szNetddeIni );
    MyGetPrivateProfileString( szGeneral, "DefaultRoute", "",
        szDefaultRoute, sizeof(szDefaultRoute), szNetddeIni );
    nDefaultRouteDisconnectTime = MyGetPrivateProfileInt( szGeneral,
        "DefaultRouteDisconnectTime", 30, szNetddeIni );
    bDefaultConnDisconnect = MyGetPrivateProfileInt( szGeneral,
        "DefaultConnectionDisconnect", TRUE, szNetddeIni );
    nDefaultConnDisconnectTime = MyGetPrivateProfileInt( szGeneral,
        "DefaultConnectionDisconnectTime", 30, szNetddeIni );
    dwSecKeyAgeLimit = GetPrivateProfileLong( szGeneral,
        "SecKeyAgeLimit", AGING_TIME, szNetddeIni);
}



BOOL
FAR PASCAL
InitInstance(
    HANDLE      hInstance,      /* Current instance identifier          */
    int         nCmdShow,       /* Param for first ShowWindow() call.   */
    LPSTR       lpCmdLine )
{

    /* Save the instance handle in static variable, which will be used in  */
    /* many subsequence calls from this application to Windows.            */

    hInst = hInstance;

#ifdef  ENUM
    wMsgSessionEnum = RegisterWindowMessage( NETDDEMSG_SESSIONENUM );
    wMsgConnectionEnum = RegisterWindowMessage( NETDDEMSG_CONNENUM );
#endif

    wMsgNddeAgntExecRtn = RegisterWindowMessage( szAgentExecRtn );
    wMsgNddeAgntAlive = RegisterWindowMessage( szAgentAlive );
    wMsgNddeAgntWakeUp = RegisterWindowMessage( szAgentWakeUp );
    wMsgNddeAgntDying = RegisterWindowMessage( szAgentDying );
    wMsgInitiateAckBack = RegisterWindowMessage( "NetddeInitiateAck" );
    wMsgNetddeAlive = RegisterWindowMessage( "NetddeAlive" );
    wMsgGetOurNodeName = RegisterWindowMessage( NETDDEMSG_GETNODENAME );
    wMsgGetClientInfo = RegisterWindowMessage( NETDDEMSG_GETCLIENTINFO );
    wMsgSessionClose = RegisterWindowMessage( NETDDEMSG_SESSIONCLOSE );

    wMsgIpcInit = RegisterWindowMessage( "HandleIpcInit" );
    wMsgIpcXmit = RegisterWindowMessage( "HandleIpcXmit" );
    wMsgDoTerminate = RegisterWindowMessage( "DoTerminate" );

    cfPrinterPicture = (WORD)RegisterClipboardFormat( "Printer_Picture" );

    if( !DDEIntfInit() )  {
        return( FALSE );
    }

    wClipFmtInTouchDDE = (WORD)RegisterClipboardFormat( "InTouch Blocked DDE V2" );

    return( TRUE );
}



/*
 * Started by SpawnNetDDEThread for a specific desktop.
 */
VOID NetDDEThread(
    PTHREADDATA ptd)
{
    HWND        hWnd;           /* Main window handle.                  */
    DWORD       cbName = sizeof(ourNodeName);
    PNI         pNi;
    int         i;
    MSG         msg;

    TRACEINIT((szT, "NetDDEThread: Entering."));

    if (ptd->hdesk != NULL) {
        SetThreadDesktop(ptd->hdesk);
    }

    /* Create a main window for this application instance.  */
    hWnd = CreateWindow(
        NETDDE_CLASS,                   /* Window class name            */
        szAppName,                      /* Text for title bar.          */
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,                           /* no parent.                   */
        NULL,                           /* Use the window class menu.   */
        hInstance,                      /* This instance owns window.   */
        NULL                            /* Pointer not needed.          */
    );

    /* If window could not be created, return "failure" */

    if (hWnd == NULL) {
        if (ptd->heventReady != NULL) {
            SetEvent(ptd->heventReady);
        }
        if (hNDDEServStartedEvent) {
            SetEvent(hNDDEServStartedEvent);    // let root thread run.
        }
        TRACEINIT((szT, "NetDDEThread: Error 1 Leaving."));
        return;
    }

    /*
     * We have a window, so put this thread at the head of the list.
     */
    ptd->hwndDDE = hWnd;
    TRACEINIT((szT, "NetDDEThread: Created hwndDDE=%x.", hWnd));
    TlsSetValue(tlsThreadData, ptd);
    EnterCrit();
    ptd->ptdNext = ptdHead;
    ptdHead = ptd;
    LeaveCrit();

    GetComputerName( ourNodeName, &cbName );

    /* set up lpszServer for NDDEAPI calls */
    lpszServer = szServerName;
    StringCchCopy( lpszServer, 132, "\\\\" );
    StringCchCat ( lpszServer, 132, ourNodeName );

    AnsiUpper( ourNodeName );
    OemToCharBuff ( ourNodeName, ourNodeName, lstrlen(ourNodeName) );

    /*  NetDDE Service on node "%1" started. */
    NDDELogInfo(MSG001, ourNodeName, NULL);


    /*
     * Initialize the net interfaces if need be.
     */
    if (!nNi) {
        for( i=0; i<MAX_NETINTFS; i++ )  {
            pNi = &niInf[i];
            pNi->bOk = FALSE;
            pNi->hLibrary = 0;
            StringCchPrintf( tmpBuf2, sizeof(tmpBuf2), szInterfaceFmt, i+1 );
            MyGetPrivateProfileString( szInterfaces, tmpBuf2,
                "", tmpBuf, sizeof(tmpBuf), szNetddeIni );

            if( tmpBuf[0] == '\0' )  {
                break;      // done looking
            } else {
                InitializeInterface( hWnd, pNi, tmpBuf, nNi );
                nNi++;
            }
        }

        if ( !nNi ) {  /* if no interfaces defined, default to NDDENB32 */
            InitializeInterface ( hWnd, &niInf[0], "NDDENB32", 0 );
            nNi++;
        }
    }


    /*
     * The net interfaces have been associated with the main
     * window, so we can now let the pipe thread run.
     */
    ResumeThread(hThreadPipe);


    /*
     * Send the window handle back to the server and let our
     * creator know that we're ready.
     */
    if (ptd->hdesk != NULL) {
        SetEvent(ptd->heventReady);
    }

    /*
     * Notify starting thread that we are ready to go.
     */
    if (hNDDEServStartedEvent) {
        SetEvent(hNDDEServStartedEvent);
    }

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while( GetMessage( &msg, NULL, 0, 0 ) ) {
        TranslateMessage( &msg );       /* Translates virtual key codes */
        DispatchMessage( &msg );        /* Dispatches message to window */
    }


    if (ptd->hdesk != NULL) {

        if (IsWindow(ptd->hwndDDE))
        {
            TRACEINIT((szT, "NetDDEThread: calling DestroyWindow(%x)", ptd->hwndDDE));
            DestroyWindow(ptd->hwndDDE);
        }

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            DispatchMessage( &msg );        /* Dispatches message to window */
        }

        /*  At this point, hwndDDE has been destroyed and there should be no references
            to, or locks on the desktop, so the following 3 calls should succeed.
         */

        if (!SetThreadDesktop(ghdesk))
                TRACEINIT((szT, "NetDDEThread: SetThreadDesktop failed"));

        if (ptd->hdesk)
            if (CloseDesktop(ptd->hdesk))
                ptd->hdesk = NULL;
            else
                TRACEINIT((szT, "NetDDEThread: CloseDesktop failed"));

        if (ptd->hwinsta)
            if (CloseWindowStation(ptd->hwinsta))
                ptd->hwinsta = NULL;
            else
                TRACEINIT((szT, "NetDDEThread: CloseWindowStation failed"));
    }

    ptd->hwndDDE = NULL;

    // ptd was allocated by SpawnNetDDEThread or NddeMain for this fn
    // it was unlinked from the master ptd list (ptdHead) in WM_DESTROY
    LocalFree(ptd);

    TRACEINIT((szT, "NetDDEThread: Leaving."));
}



BOOL CtrlHandler(
    DWORD dwEvent)
{
    PTHREADDATA ptd;
    if (dwEvent == CTRL_LOGOFF_EVENT || dwEvent == CTRL_SHUTDOWN_EVENT) {
        for (ptd = ptdHead; ptd != NULL; ptd = ptd->ptdNext) {
            if (ptd->hdesk != NULL || dwEvent == CTRL_SHUTDOWN_EVENT) {
                SendMessage(ptd->hwndDDE, WM_CLOSE, 0, 0);
            }
        }
        return TRUE;
    }
    return FALSE;
}



/*
    HandleNetddeCopyData()

    This handles the WM_COPYDATA message from NetDDE to start an
    application in the user's context
*/
BOOL
HandleNetddeCopyData(
    HWND hWndTo,
    HWND hWndFrom,
    PCOPYDATASTRUCT pCopyDataStruct )
{
    extern UINT    uAgntExecRtn;

    if( pCopyDataStruct->dwData == wMsgNddeAgntExecRtn )  {
        /* sanity checks on the structure coming in */
        if( pCopyDataStruct->cbData != sizeof(uAgntExecRtn) )  {
            /*  Invalid COPYDATA size %1 received. */

            NDDELogError(MSG003, LogString("%d", pCopyDataStruct->cbData), NULL);
            return( FALSE );
        }
        uAgntExecRtn = *((ULONG *)(pCopyDataStruct->lpData));
        return( TRUE );
    } else {
        /*  Invalid COPYDATA command %1 received. */

        NDDELogError(MSG004, LogString("0x%0X", pCopyDataStruct->dwData), NULL);
        return( FALSE );
    }
}


/*******************************************************************
 *
 *            MAIN NETDDE WINDOW PROC
 *
 * This window proc handles all NetDDE DDE trafic plus communication
 * with any associated agent window if necessary.  There is one
 * main NetDDE window per desktop and one agent on the logged on
 * desktop.
 *******************************************************************/

LPARAM
FAR PASCAL
MainWndProc(
    HWND        hWnd,              /* window handle                     */
    unsigned    message,           /* type of message                   */
    WPARAM      wParam,            /* additional information            */
    LPARAM      lParam )           /* additional information            */
{
    LPSTR           ptr;
    PNI             pNi;
    CONNID          connId;
    HPKTZ           hPktz;
    DWORD           dwNow;
    LPINFOCLI_CMD   lpInfoCliCmd;
    LPINFOCLI_RSP   lpInfoCliRsp;
    int             i;
    HWND            hDeskTop;
    PTHREADDATA     ptd;
    PTHREADDATA     *pptd;
    HWND            hwndDDEChild;

    static DWORD dwLastCheckKeys = 0;

    if (bNDDEPaused) {
        return (DefWindowProc(hWnd, message, wParam, lParam));
    }

    switch( message ) {
    case WM_CREATE:
        TRACEINIT((szT, "MainWndProc: Created."));
        hDeskTop = GetDesktopWindow();
        if (hDeskTop) {
            if (!UpdateWindow(hDeskTop)) {
                NDDELogError(MSG078, NULL);
                break;
            }
        } else {
            NDDELogError(MSG078, NULL);
            break;
        }
        TRACEINIT((szT, "Post Broadcasting NddeAgentWakeUp call:%x\n", wMsgNddeAgntWakeUp));
        PostMessage( HWND_BROADCAST, wMsgNddeAgntWakeUp, (UINT_PTR) hWnd, 0);
        break;

    case WM_COPYDATA:
        /*
         * This contains the return code from the previous request to the
         * NetDDE Agent application.  The results are placed into the
         * global uAgentExecRtn.
         */
        HandleNetddeCopyData( hWnd, (HWND)wParam, (PCOPYDATASTRUCT) lParam );
        return( TRUE );    // processed the msg */
        break;

    case WM_CLOSE:
        hwndDDEChild = GetWindow(hWnd, GW_CHILD);
        if (hwndDDEChild != NULL) {
            while (hwndDDEChild != NULL) {
                DPRINTF(("Forcing close of window %x\n", hwndDDEChild));
                DestroyWindow(hwndDDEChild);
                hwndDDEChild = GetWindow(hWnd, GW_CHILD);
            }
            NDDELogWarning(MSG015, NULL);
        }
        return (DefWindowProc(hWnd, message, wParam, lParam));

    case WM_DDE_INITIATE:
        /*
         * This is where we catch flying initiates to start conversations.
         */

        TRACEINIT((szT, "MainWndProc: WM_DDE_INITIATE..."));
        EnterCrit();
        ptd = TlsGetValue(tlsThreadData);
        if( !ptd->bInitiating )  {

#if DBG
            if( bDebugDDE )  {
                DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
            }
#endif  // DBG

            // ignore if we don't have any valid network interfaces
            if( nNiOk > 0 )  {
                ptd->bInitiating = TRUE;
                DDEHandleInitiate( hWnd, (HWND) wParam, /* client       */
                            (ATOM) LOWORD(lParam),      /* app          */
                            (ATOM) HIWORD(lParam) );    /* topic        */
                ptd->bInitiating = FALSE;

                /*
                 * Kick ourselves to process queues.
                 */
                PostMessage( hWnd, WM_TIMER, 0, 0L );

            } else {

                TRACEINIT((szT, "MainWndProc: nNiOk == 0."));
                if( LOWORD(lParam) )  {
                    GlobalGetAtomName( (ATOM) LOWORD(lParam),
                        tmpBuf, sizeof(tmpBuf) );
                    if (_fstrnicmp(&tmpBuf[2], ourNodeName, lstrlen(ourNodeName)) == 0) {
                        ptd->bInitiating = TRUE;
                        DDEHandleInitiate( hWnd, (HWND) wParam, /* client       */
                                    (ATOM) LOWORD(lParam),      /* app          */
                                    (ATOM) HIWORD(lParam) );    /* topic        */
                        ptd->bInitiating = FALSE;
                        /*
                         * Kick ourselves to process queues.
                         */
                        PostMessage( hWnd, WM_TIMER, 0, 0L );
                    }
                }
            }
        } else {
            TRACEINIT((szT, "MainWndProc: ptd->bInitiating is set, INIT skipped."));
        }
        LeaveCrit();
        break;

    case WM_TIMER:
        /*
         * This timer goes off to service various goodies:
         *      Security Keys that are ageing.
         *      Initiates in the hWndDDEHead list.
         *      Incomming packets.
         *      Timers. (ie we run all our timers off of one WM_TIMER tick)
         *      NetBios connections.
         */
        if (ptdHead != NULL && ptdHead->hwndDDE != hWnd) {
            PostMessage(ptdHead->hwndDDE, WM_TIMER, 0, 0);
            break;
        }

        /* do not process timers if we are closed */
        if( !bNetddeClosed )  {
            dwNow = GetTickCount();

            /* check for aged keys every minute or so */
            if( (dwNow < dwLastCheckKeys)
                || ((dwNow - dwLastCheckKeys) > ONE_MINUTE))  {
                DdeSecKeyAge();
                dwLastCheckKeys = dwNow;
            }

            // service all initiates
            ServiceInitiates();

            // service all packetizers
            PktzSlice();

            // service all timers
            TimerSlice();

            // service all network interfaces
            for( i=0; i<nNi; i++ )  {
                pNi = &niInf[i];
                if( pNi->bOk )  {
                    /* give the other side a chance */
                    (*pNi->niPtrs.TimeSlice)();

                    connId = (*pNi->niPtrs.GetNewConnection)();
                    if( connId )  {
                        hPktz = PktzNew( &pNi->niPtrs, FALSE /* server */,
                            "", "", connId, FALSE, 0 );
                        if( !hPktz )  {
                            /*  Failed creating new server packetizer for connection id %d */
                            NDDELogError(MSG005, LogString("0x%0X", connId), NULL);
                        }
                    }
                }
            }
            // service all packetizers again
            PktzSlice();
        }
        break;

    case WM_DESTROY:            /* message: window being destroyed */

        /*
         * Unlink this thread from the list.
         */
        TRACEINIT((szT, "MainWndProc: enter wm_destroy (%x)", hWnd));

        EnterCrit();
        for (pptd = &ptdHead; *pptd && (*pptd)->hwndDDE != hWnd;
                pptd = &(*pptd)->ptdNext)
            ;
        if (*pptd)
            *pptd = (*pptd)->ptdNext;

        if (ptdHead == NULL) {
            for( i=0; i<nNi; i++ )  {
                pNi = &niInf[i];
                if( pNi->bOk && pNi->niPtrs.Shutdown )  {
                    (*pNi->niPtrs.Shutdown)();
                }
            }
            bNetddeClosed = TRUE;
            /*  NetDDE Service on node "%1" has been stopped. */
            NDDELogInfo(MSG002, ourNodeName, NULL);
        }
        LeaveCrit();
        TRACEINIT((szT, "MainWndProc: leave wm_destroy (%x)", hWnd));
        PostQuitMessage( 0 );
        break;

    default:                    /* Passes it on if unproccessed    */
        if (message == wMsgIpcInit) {
            PIPCINIT pii;

            pii = (PIPCINIT)wParam;
            return IpcInitConversation( pii->hDder, pii->lpDdePkt,
                    pii->bStartApp, pii->lpszCmdLine, pii->dd_type );

        } else if (message == wMsgIpcXmit) {
            PIPCXMIT pix;

            pix = (PIPCXMIT)wParam;
            return IpcXmitPacket(pix->hIpc, pix->hDder, pix->lpDdePkt);

        } else if (message == wMsgNddeAgntAlive) {
            /*  NetDDE Agent %1 Coming Alive */
            TRACEINIT((szT, "NetDDE window got wMsgAgntAlive.\n"));
            NDDELogInfo(MSG007, LogString("0x%0X", wParam), NULL);
            ptd = TlsGetValue(tlsThreadData);
            ptd->hwndDDEAgent = (HWND) wParam;

        } else if (message == wMsgNddeAgntDying) {
            /*  NetDDE Agent %1 Dying   */
            NDDELogInfo(MSG008, LogString("0x%0X", wParam), NULL);
            ptd = TlsGetValue(tlsThreadData);
            ptd->hwndDDEAgent = 0;

        } else if( message == wMsgNetddeAlive )  {
            if( wParam )  {
                ptr = GlobalLock( (HANDLE) wParam );
                if( ptr )  {
                    *( (HWND FAR *)ptr ) = hWnd;
                    GlobalUnlock( (HANDLE)wParam );
                }
                return( 1L );
            }
        } else if( message == wMsgGetOurNodeName )  {
            if( wParam )  {
#if 0
          //  dont believe this message is ever sent; even if it is,
          //  we dont do anything with 'ptr' after copying the string
                ptr = GlobalLock( (HANDLE) wParam );
                if( ptr )  {
                    lstrcpy( ptr, ourNodeName );
                    GlobalUnlock( (HANDLE)wParam );
                }
#endif
                return( 1L );
            }
#ifdef  ENUM
        } else if( message == wMsgSessionEnum )  {
            if( wParam )  {
                LPSESSENUM_CMR    lpSessEnum;
                LPSTR        lpResult;

                lpSessEnum = (LPSESSENUM_CMR) GlobalLock( (HANDLE) wParam );
                if( lpSessEnum )  {
                    lpSessEnum->fTouched = TRUE;
                    lpSessEnum->lReturnCode = NDDE_NO_ERROR;
                    lpSessEnum->nItems = RouterCount();
                    lpSessEnum->cbTotalAvailable =
                        lpSessEnum->nItems * sizeof(DDESESSINFO);
                    lpResult = ((LPSTR)lpSessEnum) + sizeof(SESSENUM_CMR);
                    RouterFillInEnum( lpResult, lpSessEnum->cBufSize );
                    if( lpSessEnum->cBufSize < lpSessEnum->cbTotalAvailable) {
                        lpSessEnum->lReturnCode = NDDE_BUF_TOO_SMALL;
                    }
                    GlobalUnlock( (HANDLE)wParam );
                }
                return( 1L );
            }
        } else if( message == wMsgConnectionEnum )  {
            if( wParam )  {
                LPCONNENUM_CMR    lpConnEnum;

                lpConnEnum = (LPCONNENUM_CMR) GlobalLock( (HANDLE) wParam );
                if( lpConnEnum )  {
                    lpConnEnum->fTouched = TRUE;
                    RouterEnumConnectionsForApi( lpConnEnum );
                    GlobalUnlock( (HANDLE)wParam );
                }
                return( 1L );
            }
#endif
        } else if( message == wMsgSessionClose )  {
            if( wParam )  {
                LPSESSCLOSE_CMR    lpSessClose;

                lpSessClose = (LPSESSCLOSE_CMR) GlobalLock( (HANDLE) wParam );
                if( lpSessClose )  {
                    lpSessClose->fTouched = TRUE;
                    if( RouterCloseByCookie( lpSessClose->clientName,
                        lpSessClose->cookie ) )  {
                        lpSessClose->lReturnCode = NDDE_NO_ERROR;
                    } else {
                        lpSessClose->lReturnCode = NDDE_INVALID_SESSION;
                    }
                    GlobalUnlock( (HANDLE)wParam );
                }
                return( 1L );
            }
        } else if( message == wMsgGetClientInfo )  {
            if( wParam )  {
                HWND    hWndClient;
                LONG    lMaxNode;
                LONG    lMaxApp;
                LPSTR    lpszResult;
                int    n;
                char    clientNameFull[ 128 ];
                LPSTR    lpszClientName;

                lpInfoCliCmd = (LPINFOCLI_CMD) GlobalLock( (HANDLE) wParam );
                if( lpInfoCliCmd )  {
                    hWndClient = (HWND)lpInfoCliCmd->hWndClient;
                    lMaxNode = lpInfoCliCmd->cClientNodeLimit;
                    lMaxApp = lpInfoCliCmd->cClientAppLimit;
                    lpInfoCliRsp = (LPINFOCLI_RSP)lpInfoCliCmd;
                    lpInfoCliRsp->fTouched = TRUE;
                    EnterCrit();
                    ptd = TlsGetValue(tlsThreadData);
                    if( ptd->bInitiating )  {
                        lpInfoCliRsp->offsClientNode = sizeof(INFOCLI_RSP);
                        lpszResult = ((LPSTR)lpInfoCliRsp) +
                            lpInfoCliRsp->offsClientNode;
                        _fstrncpy( lpszResult, szInitiatingNode,
                            (int)lMaxNode );
                        lpInfoCliRsp->offsClientApp =
                            lpInfoCliRsp->offsClientNode
                                + lstrlen( lpszResult ) + 1;
                        lpszResult = ((LPSTR)lpInfoCliRsp) +
                            lpInfoCliRsp->offsClientApp;
                        _fstrncpy( lpszResult, szInitiatingApp,
                            (int)lMaxApp );
                    } else {
                        lpInfoCliRsp->offsClientNode = sizeof(INFOCLI_RSP);
                        lpszResult = ((LPSTR)lpInfoCliRsp) +
                            lpInfoCliRsp->offsClientNode;
                        *lpszResult = '\0';
                        lpInfoCliRsp->offsClientApp =
                            lpInfoCliRsp->offsClientNode
                                + lstrlen( lpszResult ) + 1;
                        lpszResult = ((LPSTR)lpInfoCliRsp) +
                            lpInfoCliRsp->offsClientApp;

                        n = GetModuleFileName(
                            (HMODULE)GetClassLongPtr( hWndClient, GCLP_HMODULE ),
                            clientNameFull,
                            sizeof(clientNameFull) );
                        lpszClientName = &clientNameFull[ n-1 ];
                        while( *lpszClientName != '.' )  {
                            lpszClientName--;
                        }
                        *lpszClientName = '\0'; // null out '.'

                        while( (*lpszClientName != '\\')
                            && (*lpszClientName != ':')
                            && (*lpszClientName != '/'))  {
                            lpszClientName--;
                        }
                        lpszClientName++;

                        _fstrncpy( lpszResult, lpszClientName,
                            (int)lMaxApp );
                    }
                    GlobalUnlock( (HANDLE)wParam );
                    LeaveCrit();
                }
                return( 1L );
            }
        } else {
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }
    }
    return( 0 );
}



FARPROC
FAR PASCAL
XGetProcAddress(
    LPSTR   lpszDllName,
    HANDLE  hLibrary,
    LPSTR   lpszFuncName )
{
    FARPROC     rtn;

    rtn = GetProcAddress( hLibrary, lpszFuncName );
    if( rtn == (FARPROC)NULL )  {  // try without the underscore
        rtn = GetProcAddress( hLibrary, lpszFuncName+1 );
    }
    if( rtn == (FARPROC)NULL )  {
        /*  Cannot load function address of "%1" from "%2" DLL */

        NDDELogError(MSG009, lpszFuncName, lpszDllName, NULL);
    }
    return( rtn );
}



BOOL
FAR PASCAL
GetNiPtrs(
    HANDLE FAR *lphLibrary,
    LPSTR       lpszDllName,
    LPNIPTRS    lpNiPtrs )
{
    BOOL        ok = TRUE;
    char        dllName[ 128 ];

    lstrcpyn( lpNiPtrs->dllName, lpszDllName, sizeof(lpNiPtrs->dllName) );
    lpNiPtrs->dllName[ sizeof(lpNiPtrs->dllName)-1 ] = '\0';

    lstrcpyn( dllName, lpszDllName, 128 );

    *lphLibrary = LoadLibrary( dllName );
    if( *lphLibrary )  {
        if( ok )  {
            lpNiPtrs->Init = (FP_Init)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEInit" );
            if( !lpNiPtrs->Init )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->GetCAPS = (FP_GetCAPS)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEGetCAPS" );
            if( !lpNiPtrs->GetCAPS )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->GetNewConnection = (FP_GetNewConnection)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEGetNewConnection" );
            if( !lpNiPtrs->GetNewConnection )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->AddConnection = (FP_AddConnection)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEAddConnection" );
            if( !lpNiPtrs->AddConnection )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->DeleteConnection = (FP_DeleteConnection)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEDeleteConnection" );
            if( !lpNiPtrs->DeleteConnection )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->GetConnectionStatus = (FP_GetConnectionStatus)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEGetConnectionStatus" );
            if( !lpNiPtrs->GetConnectionStatus )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->RcvPacket = (FP_RcvPacket)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDERcvPacket" );
            if( !lpNiPtrs->RcvPacket )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->XmtPacket = (FP_XmtPacket)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEXmtPacket" );
            if( !lpNiPtrs->XmtPacket )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->SetConnectionConfig = (FP_SetConnectionConfig)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDESetConnectionConfig" );
            if( !lpNiPtrs->SetConnectionConfig )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->GetConnectionConfig = (FP_GetConnectionConfig)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEGetConnectionConfig" );
            if( !lpNiPtrs->GetConnectionConfig )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->Shutdown = (FP_Shutdown)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEShutdown" );
            if( !lpNiPtrs->Shutdown )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->TimeSlice = (FP_TimeSlice)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDETimeSlice" );
            if( !lpNiPtrs->TimeSlice )  {
                ok = FALSE;
            }
        }

    } else {
        /* Error loading "%1" DLL: %2 */
        NDDELogError(MSG010, dllName, LogString("%d", GetLastError()), NULL);
        return( FALSE );
    }

    if( !ok )  {
        if( *lphLibrary )  {
            FreeLibrary( *lphLibrary );
        }
        *lphLibrary = NULL;

        /* Error loading "%1" DLL functions */
        NDDELogError(MSG011, dllName, NULL);
    }
    return( ok );
}



/* returns the next available network interface that supports mapping names
    to addresses */
BOOL
GetNextMappingNetIntf(
    LPNIPTRS FAR *lplpNiPtrs,
    int FAR      *lpnNi )
{
    int         i;
    PNI         pNi;

    *lpnNi = *lpnNi+1;

    for( i=*lpnNi; i<nNi; i++ )  {
        pNi = &niInf[i];
        if( pNi->bOk && pNi->bMapping )  {
            *lplpNiPtrs = &niInf[ i ].niPtrs;
            *lpnNi = i;
            return( TRUE );
        }
    }
    return( FALSE );
}



BOOL
NameToNetIntf(
    LPSTR           lpszName,
    LPNIPTRS FAR   *lplpNiPtrs )
{
    int         i;
    PNI         pNi;

    *lplpNiPtrs = NULL;
    for( i=0; i<nNi; i++ )  {
        pNi = &niInf[i];
        if( pNi->bOk && (lstrcmpi( pNi->niPtrs.dllName, lpszName ) == 0) ) {
            *lplpNiPtrs = &pNi->niPtrs;
            return( TRUE );
        }
    }
    return( FALSE );
}



BOOL
FAR PASCAL
InitializeInterface(
    HWND    hWndNetdde,
    PNI     pNi,
    LPSTR   lpszDllName,
    int     nCurrentNi )
{
    BOOL        ok;
    DWORD       stat = 0;


    if( ok = GetNiPtrs( &pNi->hLibrary, lpszDllName, &pNi->niPtrs ) )  {

        stat = (*pNi->niPtrs.Init)( ourNodeName, hWndNetdde );
        if (stat != NDDE_INIT_OK) {
            ok = FALSE;
        }

        if( ok )  {
            if( (*pNi->niPtrs.GetCAPS)( NDDE_SPEC_VERSION ) != NDDE_CUR_VERSION )  {
                /*  Wrong version of "%1" DLL: %2%\
                    Disabling this interface. */

                NDDELogError(MSG012, pNi->niPtrs.dllName,
                    LogString("0x%0X", (*pNi->niPtrs.GetCAPS)( NDDE_SPEC_VERSION )), NULL);
                (*pNi->niPtrs.Shutdown)();
                ok = FALSE;
            }
        }
        if( ok )  {
            pNi->bOk = TRUE;
            pNi->bMapping = (BOOL) (*pNi->niPtrs.GetCAPS)( NDDE_MAPPING_SUPPORT );
            nNiOk ++;

        } else {
            /*  Initialization of "%1" DLL failed */
            if (stat != NDDE_INIT_NO_SERVICE) {
                NDDELogError(MSG013, (LPSTR) pNi->niPtrs.dllName, NULL);
            }
        }
    }
    return( ok );
}



BOOL
FAR PASCAL
DeleteNetIntf( HWND hWnd, LPSTR lpszIntfName )
{
    BOOL        ok = TRUE;
    int         i;
    PNI         pNi;
    int         nInterfaces = 0;
    BOOL        found = FALSE;

    for( i=0; ok && !found && i<MAX_NETINTFS; i++ )  {

        StringCchPrintf( tmpBuf2, sizeof(tmpBuf2), szInterfaceFmt, i+1 );
        MyGetPrivateProfileString( szInterfaces, tmpBuf2,
            "", tmpBuf, sizeof(tmpBuf), szNetddeIni );

        if( tmpBuf[0] == '\0' )  {
            return( FALSE );
        } else {
            if( lstrcmpi( lpszIntfName, tmpBuf ) == 0 )  {
                // actually delete it
                found = TRUE;
                ok = DeleteNetIntfFromNetDdeIni( i );
            }
        }
    }

    if( !found || !ok )  {
        return( FALSE );
    }

    found = FALSE;
    for( i=0; ok && !found && i<nNi; i++ )  {
        pNi = &niInf[i];
        if( pNi->bOk && (lstrcmpi( lpszIntfName, pNi->niPtrs.dllName) == 0)){
            found = TRUE;
            if( pNi->niPtrs.Shutdown )  {
                (*pNi->niPtrs.Shutdown)();
            }
            if( pNi->hLibrary )  {
                FreeLibrary( pNi->hLibrary );
                pNi->hLibrary = 0;
            }
            pNi->bOk = FALSE;
            nNiOk --;
        }
    }
    return( ok );
}



BOOL
FAR PASCAL
DeleteNetIntfFromNetDdeIni( int nToDelete )
{
    int         i;
    char        dllName[ 128 ];
    BOOL        done = FALSE;

    // if we delete Interface2  copy Interface3 to Interface2, Interface4
    //  to Interface3, etc.

    for( i=nToDelete; !done && i<MAX_NETINTFS; i++ )  {
        StringCchPrintf( tmpBuf2, sizeof(tmpBuf2), szInterfaceFmt, i+2 );
        MyGetPrivateProfileString( szInterfaces, tmpBuf2,
            "", dllName, sizeof(dllName), szNetddeIni );

        if( dllName[0] == '\0' )  {
            StringCchPrintf( tmpBuf2, sizeof(tmpBuf2), szInterfaceFmt, i+1 );
            MyWritePrivateProfileString( szInterfaces, tmpBuf2,
                NULL, szNetddeIni );
            break;      // done looking
        } else {
            StringCchPrintf( tmpBuf2, sizeof(tmpBuf2), szInterfaceFmt, i+1 );
            MyWritePrivateProfileString( szInterfaces, tmpBuf2,
                dllName, szNetddeIni );
        }
    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\nddeserv.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDESERV.C;1  16-Dec-92,10:16:44  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    <string.h>

#include    "host.h"
#include    <windows.h>
#include    <hardware.h>
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "debug.h"
#include    "netbasic.h"
#include    "ddepkts.h"
#include    "netddesh.h"
#include    "critsec.h"

VOID NDDELogEventW(DWORD EventId, WORD fwEventType, WORD cStrings, LPWSTR *aszMsg);
void RefreshNDDECfg(void);
/*
    Global Start-Up Arguments .. saved by service launcher
*/
extern  HANDLE  hInstance;          /* current instance             */
extern  LPSTR   lpCmdLine;          /* command line                 */
extern  int     nCmdShow;           /* show-window type (open/icon) */

extern  BOOL    bNDDEPaused;        /* stop servicing main window msgs */
extern  BOOL    bNetddeClosed;
extern  HANDLE  hInst;

extern  HANDLE  hThreadPipe;

extern  DWORD   __stdcall   StartRpc( DWORD dwParam );
extern  VOID    __stdcall   NddeMain(DWORD nThreadInput);

/*************************************************************
*   Launching NetDDE as a NT Service
**************************************************************/

/* Other Globals */

SERVICE_STATUS          ssStatus;
SERVICE_STATUS_HANDLE   sshNDDEStatusHandle;
SERVICE_STATUS_HANDLE   sshDSDMStatusHandle;
HANDLE                  hDSDMServDoneEvent = 0;
HANDLE                  hNDDEServDoneEvent = 0;
HANDLE                  hNDDEServStartedEvent = 0;

HANDLE                  hThread;
DWORD                   IdThread;
HANDLE                  hThreadRpc;
DWORD                   IdThreadRpc;

/* exit code that is set by any thread when error occurs */

DWORD                   dwGlobalErr = NO_ERROR;


VOID    NDDEMainFunc(DWORD dwArgc, LPTSTR *lpszArgv);
VOID    NDDEServCtrlHandler (DWORD dwCtrlCode);
VOID    DSDMMainFunc(DWORD dwArgc, LPTSTR *lpszArgv);
VOID    DSDMServCtrlHandler (DWORD dwCtrlCode);

BOOL    ReportStatusToSCMgr (   HANDLE hService,
                                SERVICE_STATUS_HANDLE sshNDDEStatusHandle,
                                DWORD dwCurrentState,
                                DWORD dwWin32ExitCode,
                                DWORD dwCheckPoint,
                                DWORD dwWaitHint);
BOOL    NDDESrvInit( VOID );
BOOL    DSDMSrvInit( VOID );

VOID PauseNDDESrv( VOID );
VOID ResumeNDDESrv( VOID );
VOID PauseDSDMSrv( VOID );
VOID ResumeDSDMSrv( VOID );

int
APIENTRY
WinMain(
    HINSTANCE  hInstancex,
    HINSTANCE  hPrevInstancex,
    LPSTR      lpCmdLinex,
    INT        nCmdShowx )
{

    SERVICE_TABLE_ENTRY   steDispatchTable[] = {

        /* entry for "NetDDE" */
        { TEXT("NetDDE"),(LPSERVICE_MAIN_FUNCTION) NDDEMainFunc},

        /* entry for "NetDDEdsdm" */
        { TEXT("NetDDEdsdm"),(LPSERVICE_MAIN_FUNCTION) DSDMMainFunc},

        /* NULL entry designating end of table */
        { NULL, NULL }
    };

  /*
   * Main thread of service process starts service control
   * dispatcher that dispatches start and control requests
   * for the services specified in steDispatchTable. This
   * function does not return unless there is an error.
   */
    hInstance = hInstancex;
#if DBG
    DebugInit( "NetDDE" );
#endif
    lpCmdLine = lpCmdLinex;
    nCmdShow = nCmdShowx;
    if( !StartServiceCtrlDispatcher( steDispatchTable ) ) {
        NDDELogError(MSG074, LogString("%d", GetLastError()), NULL );
    }
    return 0;
}



/*
 * SERVICE_MAIN_FUNCTION of "NetDDEService"
 *
 * When service is started, the service control dispatcher
 * creates a new thread to execute this function.
 */

VOID
NDDEMainFunc(
    DWORD dwArgc,
    LPTSTR *lpszArgv )
{

  DWORD dwWait;

  TRACEINIT((szT, "NDDEMainFunc: Entering."));

  /* Register control handler function for this service */

  sshNDDEStatusHandle = RegisterServiceCtrlHandler(
          TEXT("NetDDE"),           /* service name             */
          NDDEServCtrlHandler);      /* control handler function */

  if ( sshNDDEStatusHandle == (SERVICE_STATUS_HANDLE) 0 ) {
      TRACEINIT((szT, "NDDEMainFunc: Error1 Leaving."));
      goto Cleanup;
  }

  /* SERVICE_STATUS members that don't change in example */

  ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
  ssStatus.dwServiceSpecificExitCode = 0;

  /* Report status to Service Control Manager */

  if( !ReportStatusToSCMgr(
      NULL,
      sshNDDEStatusHandle,
      SERVICE_START_PENDING, /* service state */
      NO_ERROR,              /* exit code     */
      1,                     /* checkpoint    */
      5000) ) {              /* wait hint     */

      goto Cleanup;
  }

  /*
   * Create event object. Control handler function signals
   * this event when it receives the "stop" control code.
   */

  hNDDEServDoneEvent = CreateEvent (
      NULL,    /* no security attributes */
      TRUE,    /* manual reset event     */
      FALSE,   /* not-signalled          */
      NULL) ;  /* no name                */

  if ( hNDDEServDoneEvent == (HANDLE) 0 ) {
      goto Cleanup;
  }

  /* Report status to Service Control Manager */

    if( !ReportStatusToSCMgr(
            hNDDEServDoneEvent,
            sshNDDEStatusHandle,
            SERVICE_START_PENDING, /* service state */
            NO_ERROR,              /* exit code     */
            2,                     /* checkpoint    */
            500) ) {               /* wait hint     */
        goto Cleanup;
    }

  hNDDEServStartedEvent = CreateEvent (
      NULL,    /* no security attributes */
      TRUE,    /* manual reset event     */
      FALSE,   /* not-signalled          */
      NULL) ;  /* no name                */

  if ( hNDDEServStartedEvent == (HANDLE) 0 ) {
      goto Cleanup;
  }

  /* Report status to Service Control Manager */

    if( !ReportStatusToSCMgr(
            hNDDEServDoneEvent,
            sshNDDEStatusHandle,
            SERVICE_START_PENDING, /* service state */
            NO_ERROR,              /* exit code     */
            3,                     /* checkpoint    */
            500) ) {               /* wait hint     */
        goto Cleanup;
    }

  /* start thread that performs work of service */

  if( !NDDESrvInit() ) {
      TRACEINIT((szT, "NDDEMainFunc: NDDESrvInit failed."));
      goto Cleanup;
  }

  /*
   * Wait till NetDDE is truely ready to handle DDE
   */
  WaitForSingleObject(hNDDEServStartedEvent, INFINITE);
  CloseHandle(hNDDEServStartedEvent);
  hNDDEServStartedEvent = 0;

  /* Report status to Service Control Manager */

    if( !ReportStatusToSCMgr(
            hNDDEServDoneEvent,
            sshNDDEStatusHandle,
            SERVICE_RUNNING, /* service state */
            NO_ERROR,        /* exit code     */
            0,               /* checkpoint    */
            0) ) {           /* wait hint     */
        goto Cleanup;
    }

  /* Wait indefinitely until hNDDEServDoneEvent is signalled */

    TRACEINIT((szT, "NDDEMainFunc: Waiting on hNDDEServDoneEvent=%x.",
            hNDDEServDoneEvent));
    dwWait = WaitForSingleObject (
        hNDDEServDoneEvent,  /* event object      */
        INFINITE);       /* wait indefinitely */
    TRACEINIT((szT, "NDDEMainFunc: hNDDEServDoneEvent=%x is signaled.",
            hNDDEServDoneEvent));

  /* Wait for the Pipe Thread to exit. */

    if (hThreadPipe) {
        TRACEINIT((szT, "NDDEMainFunc: Waiting for Pipe Thread to exit."));
        WaitForSingleObject(hThreadPipe, INFINITE);
        TRACEINIT((szT, "NDDEMainFunc: Pipe Thread has exited."));

        CloseHandle(hThreadPipe);
        hThreadPipe = NULL;
    }

Cleanup :

    EnterCrit();
    if (hNDDEServDoneEvent != 0) {
        TRACEINIT((szT, "NDDEMainFunc: Closing hNDDEServDoneEvent=%x",
            hNDDEServDoneEvent));
        CloseHandle(hNDDEServDoneEvent);
        hNDDEServDoneEvent = 0;
    }
    if (hNDDEServStartedEvent != 0) {
        CloseHandle(hNDDEServStartedEvent);
        hNDDEServStartedEvent = 0;
    }
    LeaveCrit();

  /* try to report stopped status to SC Manager */

    if (sshNDDEStatusHandle != 0) {
        (VOID) ReportStatusToSCMgr(
                    NULL,
                    sshNDDEStatusHandle,
                    SERVICE_STOPPED, dwGlobalErr, 0, 0);
    }


  TRACEINIT((szT, "NDDEMainFunc: leaving"));


  return;

}

/*
 * SERVICE_MAIN_FUNCTION of "DSDMService"
 *
 * When service is started, the service control dispatcher
 * creates a new thread to execute this function.
 */

VOID
DSDMMainFunc(
    DWORD dwArgc,
    LPTSTR *lpszArgv )
{

  DWORD dwWait;

  /* Register control handler function for this service */

  TRACEINIT((szT, "DSDMMainFunc: Entering."));

  sshDSDMStatusHandle = RegisterServiceCtrlHandler(
          TEXT("NetDDEdsdm"),  /* service name             */
          DSDMServCtrlHandler); /* control handler function */

  if ( sshDSDMStatusHandle == (SERVICE_STATUS_HANDLE) 0 ) {
      TRACEINIT((szT, "DSDMMainFunc: Error1 Leaving."));
      goto Cleanup;
  }

  /* SERVICE_STATUS members that don't change in example */

  ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
  ssStatus.dwServiceSpecificExitCode = 0;

  /* Report status to Service Control Manager */

  if( !ReportStatusToSCMgr(
      hDSDMServDoneEvent,
      sshDSDMStatusHandle,
      SERVICE_START_PENDING, /* service state */
      NO_ERROR,              /* exit code     */
      1,                     /* checkpoint    */
      500) ) {              /* wait hint     */

      TRACEINIT((szT, "DSDMMainFunc: Error2 Leaving."));
      goto Cleanup;
  }

  /*
   * Create event object. Control handler function signals
   * this event when it receives the "stop" control code.
   */

  hDSDMServDoneEvent = CreateEvent (
      NULL,    /* no security attributes */
      TRUE,    /* manual reset event     */
      FALSE,   /* not-signalled          */
      NULL) ;  /* no name                */

  if ( hDSDMServDoneEvent == (HANDLE) 0 ) {
      TRACEINIT((szT, "DSDMMainFunc: Error3 Leaving."));
      goto Cleanup;
  }

  /* Report status to Service Control Manager */

    if( !ReportStatusToSCMgr(
            hDSDMServDoneEvent,
            sshDSDMStatusHandle,
            SERVICE_START_PENDING, /* service state */
            NO_ERROR,              /* exit code     */
            2,                     /* checkpoint    */
            500) ) {              /* wait hint     */
        TRACEINIT((szT, "DSDMMainFunc: Error4 Leaving."));
        goto Cleanup;
    }

  /* start thread that performs work of service */

  if( !DSDMSrvInit() ) {
      goto Cleanup;
  }

  /* Report status to Service Control Manager */

    if( !ReportStatusToSCMgr(
            hDSDMServDoneEvent,
            sshDSDMStatusHandle,
            SERVICE_RUNNING, /* service state */
            NO_ERROR,        /* exit code     */
            0,               /* checkpoint    */
            0) ) {           /* wait hint     */
        TRACEINIT((szT, "DSDMMainFunc: Error5 Leaving."));
        goto Cleanup;
    }

  /* Wait indefinitely until hDSDMServDoneEvent is signalled */

    TRACEINIT((szT, "DSDMMainFunc: Waiting on hDSDMServDoneEvent=%x.",
            hDSDMServDoneEvent));
    dwWait = WaitForSingleObject (
        hDSDMServDoneEvent,  /* event object      */
        INFINITE);       /* wait indefinitely */
    TRACEINIT((szT, "DSDMMainFunc: hDSDMServDoneEvent=%x is signaled.",
            hDSDMServDoneEvent));

Cleanup :

    if (hDSDMServDoneEvent != 0) {
        TRACEINIT((szT, "DSDMMainFunc: Closing hDSDMServDoneEvent=%x",
            hDSDMServDoneEvent));
        CloseHandle(hDSDMServDoneEvent);
        hDSDMServDoneEvent = 0;
    }

  /* try to report stopped status to SC Manager */

    if (sshDSDMStatusHandle != 0) {
        (VOID) ReportStatusToSCMgr(
            hDSDMServDoneEvent,
            sshDSDMStatusHandle,
            SERVICE_STOPPED, dwGlobalErr, 0, 0);
    }

  /*
   * When SERVICE_MAIN_FUNCTION returns for the last service
   * in the process, the StartServiceCtrlDispatcher function
   * in the main thread returns, terminating the process.
   */

  TRACEINIT((szT, "DSDMMainFunc: Leaving."));
  return;

}



/*
 * ReportStatusToSCMgr function
 *
 * This function is called by the MainFunc() and
 * by the ServCtrlHandler() to update the service's status
 * to the Service Control Manager.
 */


BOOL
ReportStatusToSCMgr(
    HANDLE  hService,
    SERVICE_STATUS_HANDLE   sshStatusHandle,
    DWORD   dwCurrentState,
    DWORD   dwWin32ExitCode,
    DWORD   dwCheckPoint,
    DWORD   dwWaitHint )
{
  BOOL fResult;

  /* disable control requests until service is started */

  if (dwCurrentState == SERVICE_START_PENDING) {
      ssStatus.dwControlsAccepted = 0;
  } else {
      ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                           SERVICE_ACCEPT_PAUSE_CONTINUE;
  }


  /* These SERVICE_STATUS members set from parameters */

  ssStatus.dwCurrentState = dwCurrentState;
  ssStatus.dwWin32ExitCode = dwWin32ExitCode;
  ssStatus.dwCheckPoint = dwCheckPoint;
  ssStatus.dwWaitHint = dwWaitHint;

  TRACEINIT((szT, "ReportStatusToSCMgr: dwCurrentState=%x.",
        dwCurrentState));
  /* Report status of service to Service Control Manager */

    if (! (fResult = SetServiceStatus (
          sshStatusHandle,    /* service reference handle */
          &ssStatus) ) ) {    /* SERVICE_STATUS structure */

        /* if error occurs, stop service */
        NDDELogError(MSG075, LogString("%d", GetLastError()), NULL);
        if (hService) {
            SetEvent(hService);
        }
  }
  return fResult;
}


/*
 * Service control dispatcher invokes this function when it
 * gets a control request from the Service Control Manager.
 */

VOID
NDDEServCtrlHandler( DWORD dwCtrlCode ) {

  DWORD  dwState = SERVICE_RUNNING;
  PTHREADDATA ptd, ptdNext;

  /* Handle the requested control code */

  switch(dwCtrlCode) {

      /* pause the service if its running */

      case SERVICE_CONTROL_PAUSE:

          TRACEINIT((szT, "NDDEServCtrlHandler: SERVICE_CONTROL_PAUSE"));
          if (ssStatus.dwCurrentState == SERVICE_RUNNING) {
              PauseNDDESrv();

              dwState = SERVICE_PAUSED;
          }
          break;

      /* resume paused service */

      case SERVICE_CONTROL_CONTINUE:

          TRACEINIT((szT, "NDDEServCtrlHandler: SERVICE_CONTROL_CONTINUE"));
          if (ssStatus.dwCurrentState == SERVICE_PAUSED) {
              ResumeNDDESrv();
              dwState = SERVICE_RUNNING;
          }
          break;

      /* stop the service */

      case SERVICE_CONTROL_STOP:

          dwState = SERVICE_STOP_PENDING;

          TRACEINIT((szT, "NDDEServCtrlHandler: SERVICE_CONTROL_STOP"));

          if (!bNetddeClosed) {     /* drop our window too */
              for (ptd = ptdHead; ptd != NULL; ptd = ptdNext) {

                  TRACEINIT((szT, "NDDEServCtrlHandler: Destroying hwndDDE=%x", ptd->hwndDDE));

                  // save ptd->Next as ptd may be invalid after PostMessage returns
                  ptdNext = ptd->ptdNext;
                  PostMessage(ptd->hwndDDE, WM_DESTROY, 0, 0);

#if 0
	/*  Changed the previous call from SendMessage to PostMessage, so this thread does not
         *  keep the window locked.  then netddethread will always free them in 1 place, & we dont
         *  need to try and close the handles here, and we avoid this race condition
         */
                  /*  NetDDEThread may fail to close the desktop/winsta if the above SendMessage has not returned  */
                  if (ptd->hdesk)
                      if (CloseDesktop(ptd->hdesk))
                          ptd->hdesk = NULL;
                      else
                          TRACEINIT((szT, "NDDEServCtrlHandler: closedesktop failed"));

                  if (ptd->hwinsta)
                      if (CloseWindowStation(ptd->hwinsta))
                          ptd->hwinsta = NULL;
                      else
                          TRACEINIT((szT, "NDDEServCtrlHandler: closewindowstation failed"));
#endif
              }
          }


          /*
           * Report status, specifying checkpoint and wait
           * hint, before setting termination event
           */

          (VOID) ReportStatusToSCMgr(
                    hNDDEServDoneEvent,
                    sshNDDEStatusHandle,
                   SERVICE_STOP_PENDING, /* current state */
                   NO_ERROR,             /* exit code     */
                   1,                    /* check point   */
                   500);                /* wait hint     */


            NDDELogInfo(MSG076, NULL);
            TRACEINIT((szT, "NDDEServCtrlHandler: Setting hNDDEServDoneEvent=%x",
                    hNDDEServDoneEvent));
            if (hNDDEServDoneEvent) {
                SetEvent(hNDDEServDoneEvent);
            }
            return;


      /* update service status */

      case SERVICE_CONTROL_INTERROGATE:
          TRACEINIT((szT, "NDDEServCtrlHandler: SERVICE_CONTROL_INTERROGATE"));
          break;

      /* invalid control code */

      default:
          break;

    }

    /* Send a status response */

    (VOID) ReportStatusToSCMgr(
                    hNDDEServDoneEvent,
                    sshNDDEStatusHandle,
                    dwState, NO_ERROR, 0, 0);

}

/*
 * Service control dispatcher invokes this function when it
 * gets a control request from the Service Control Manager.
 */

VOID
DSDMServCtrlHandler( DWORD dwCtrlCode ) {

  DWORD  dwState = SERVICE_RUNNING;
  PTHREADDATA ptd;

  /* Handle the requested control code */

  switch(dwCtrlCode) {

      /* pause the service if its running */

      case SERVICE_CONTROL_PAUSE:

          TRACEINIT((szT, "DSDMServCtrlHandler: SERVICE_CONTROL_PAUSE"));
          if (ssStatus.dwCurrentState == SERVICE_RUNNING) {
              PauseDSDMSrv();

              dwState = SERVICE_PAUSED;
          }
          break;

      /* resume paused service */

      case SERVICE_CONTROL_CONTINUE:

          TRACEINIT((szT, "DSDMServCtrlHandler: SERVICE_CONTROL_CONTINUE"));
          if (ssStatus.dwCurrentState == SERVICE_PAUSED) {
              ResumeDSDMSrv();
              dwState = SERVICE_RUNNING;
          }
          break;

      /* stop the service */

      case SERVICE_CONTROL_STOP:

          dwState = SERVICE_STOP_PENDING;

          TRACEINIT((szT, "DSDMServCtrlHandler: SERVICE_CONTROL_STOP"));
          if (!bNetddeClosed) {     /* drop our window too */
              for (ptd = ptdHead; ptd != NULL; ptd = ptd->ptdNext) {
                  TRACEINIT((szT, "DSDMServCtrlHandler: Destroying hwndDDE=%x", ptd->hwndDDE));
                  SendMessage(ptd->hwndDDE, WM_DESTROY, 0, 0);
              }
          }

          /*
           * Report status, specifying checkpoint and wait
           * hint, before setting termination event
           */

          (VOID) ReportStatusToSCMgr(
                    hDSDMServDoneEvent,
                    sshDSDMStatusHandle,
                   SERVICE_STOP_PENDING, /* current state */
                   NO_ERROR,             /* exit code     */
                   1,                    /* check point   */
                   500);                /* wait hint     */


            NDDELogInfo(MSG077, NULL);
            TRACEINIT((szT, "DSDMServCtrlHandler: Setting hDSDMServDoneEvent=%x", hDSDMServDoneEvent));
            if (hDSDMServDoneEvent) {
                SetEvent(hDSDMServDoneEvent);
            }
            return;


      /* update service status */

      case SERVICE_CONTROL_INTERROGATE:
          TRACEINIT((szT, "DSDMServCtrlHandler: SERVICE_CONTROL_INTERROGATE"));
          break;

      /* invalid control code */

      default:
          break;

    }

    /* Send a status response */

    (VOID) ReportStatusToSCMgr(
                    hDSDMServDoneEvent,
                    sshDSDMStatusHandle,
                    dwState, NO_ERROR, 0, 0);

}


VOID
PauseNDDESrv( VOID )
{
    bNDDEPaused = TRUE;
}

VOID
ResumeNDDESrv( VOID )
{
    bNDDEPaused = FALSE;
}

VOID
PauseDSDMSrv( VOID )
{
    bNDDEPaused = TRUE;
}

VOID
ResumeDSDMSrv( VOID )
{
    bNDDEPaused = FALSE;
}

/*
    Initialize Main NetDDE Proc
*/
BOOL
NDDESrvInit( VOID )
{
    RefreshNDDECfg();

    TRACEINIT((szT, "NDDESrvInit: Creating thread for NddeMain."));
    hThread = CreateThread(
        NULL,           /* Default security                  */
        0,              /* Same stack size as primary thread */
        (LPTHREAD_START_ROUTINE)NddeMain, /* Start address   */
        0,              /* Parameter to WindowThread()       */
        0,              /* Run immediately                   */
        &IdThread );    /* Where to store thread id          */

    if (hThread) {
        CloseHandle(hThread);
        return TRUE;
    } else {
        NDDELogError(MSG071, LogString("%d", GetLastError()), NULL);
        return(FALSE);
    }
}

/*
    Initialize Main DSDM Proc
*/
BOOL
DSDMSrvInit( VOID )
{
    hThreadRpc = CreateThread(
        NULL,           /* Default security                  */
        0,              /* Same stack size as primary thread */
        (LPTHREAD_START_ROUTINE)StartRpc, /* Start address   */
        (LPVOID)hInst,  /* Parameter          */
        0,              /* Run immediately                   */
        &IdThreadRpc ); /* Where to store thread id          */

    if (hThreadRpc) {
        CloseHandle(hThreadRpc);
        return TRUE;
    } else {
        NDDELogError(MSG072, LogString("%d", GetLastError()), NULL);
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\spt.h ===
HANDLE	FAR PASCAL GetGlobalAlloc( WORD, DWORD );
PSTR	FAR PASCAL GetAppName( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\uservald.h ===
#ifndef H__uservald
#define H__uservald

BOOL
GetUserDomain(
    HWND	hWndDdePartner,
    HWND	hWndDdeOurs,
    LPSTR	lpszUserName,
    int		cbUserName,
    LPSTR	lpszDomainName,
    int		cbDomainName );

BOOL
GetUserDomainPassword(
    HWND	hWndDdePartner,
    HWND	hWndDdeOurs,
    LPSTR	lpszUserName,
    int		cbUserName,
    LPSTR	lpszDomainName,
    int		cbDomainName,
    LPSTR	lpszPasswordK1,
    DWORD	cbPasswordK1,
    LPSTR	lpszChallenge,
    int		cbChallenge,
    DWORD	*pcbPasswordK1,
    BOOL	*pbHasPasswordK1 );

BOOL
DetermineAccess(
        LPSTR                   lpszDdeShareName,
        PSECURITY_DESCRIPTOR    pSD,
        LPDWORD                 lpdwGrantedAccess,
        LPVOID                  lpvHandleIdAudit,
        LPBOOL                  lpfGenerateOnClose );

#define NDDE_AUDIT_SUBSYSTEM    TEXT("NetDDE Object")
#define NDDE_AUDIT_OBJECT_TYPE  TEXT("DDE Share")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\shareif.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "SHAREIF.C;1  16-Dec-92,10:17:46  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    <windows.h>
#include    "tmpbuf.h"
#include    "debug.h"
#include    "netbasic.h"
#include    "nddeapi.h"
#include    "nddemsg.h"
#include    "nddelog.h"

static char    szClipRef[] = "NDDE$";

WORD
atohn (
    LPSTR   s,
    int     n )
{
    WORD ret = 0;
    int i;

    for ( i = 0, ret = 0; i < n; ret << 4, i++ )
        if ( '0' <= s[i] && s[i] <= '9' )
            ret += s[i] - '0';
        else if ( tolower(s[i]) >= 'a' && tolower(s[i]) <= 'f' )
            ret += tolower(s[i]) - 'a';
    return ret;
}



/*
 * See if the given DDE appname is prepended by a NDDE$ string -
 * meaning that it is a reference to a NetDDE share.
 */
BOOL
IsShare(LPSTR lpApp)
{
    return( _strnicmp( lpApp, szClipRef, 5 ) == 0 );
}




WORD
ExtractFlags(LPSTR lpApp)
{
    WORD    ret = 0;
    LPSTR   pch;

    if ( IsShare(lpApp) ) {
        pch = lpApp + lstrlen(szClipRef);
        if ( lstrlen(pch) >= 4 ) {
            ret = atohn(pch,4);
        }
    